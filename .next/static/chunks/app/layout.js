/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/layout"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fwonderlandmitch%2FCascadeProjects%2FWonderVite-frontend%2Fapp%2Fglobals.css%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fwonderlandmitch%2FCascadeProjects%2FWonderVite-frontend%2Fsrc%2Fcomponents%2Fplasmic%2FPlasmicWrapper.tsx%22%2C%22ids%22%3A%5B%22PlasmicWrapper%22%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fwonderlandmitch%2FCascadeProjects%2FWonderVite-frontend%2Fsrc%2Fcontexts%2FSettingsContext.tsx%22%2C%22ids%22%3A%5B%22SettingsProvider%22%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fwonderlandmitch%2FCascadeProjects%2FWonderVite-frontend%2Fsrc%2Fproviders%2FAuthProvider.tsx%22%2C%22ids%22%3A%5B%22AuthProvider%22%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fwonderlandmitch%2FCascadeProjects%2FWonderVite-frontend%2Fsrc%2Fproviders%2FQueryProvider.tsx%22%2C%22ids%22%3A%5B%22QueryProvider%22%5D%7D&server=false!":
/*!**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fwonderlandmitch%2FCascadeProjects%2FWonderVite-frontend%2Fapp%2Fglobals.css%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fwonderlandmitch%2FCascadeProjects%2FWonderVite-frontend%2Fsrc%2Fcomponents%2Fplasmic%2FPlasmicWrapper.tsx%22%2C%22ids%22%3A%5B%22PlasmicWrapper%22%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fwonderlandmitch%2FCascadeProjects%2FWonderVite-frontend%2Fsrc%2Fcontexts%2FSettingsContext.tsx%22%2C%22ids%22%3A%5B%22SettingsProvider%22%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fwonderlandmitch%2FCascadeProjects%2FWonderVite-frontend%2Fsrc%2Fproviders%2FAuthProvider.tsx%22%2C%22ids%22%3A%5B%22AuthProvider%22%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fwonderlandmitch%2FCascadeProjects%2FWonderVite-frontend%2Fsrc%2Fproviders%2FQueryProvider.tsx%22%2C%22ids%22%3A%5B%22QueryProvider%22%5D%7D&server=false! ***!
  \**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/globals.css */ \"(app-pages-browser)/./app/globals.css\"));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/components/plasmic/PlasmicWrapper.tsx */ \"(app-pages-browser)/./src/components/plasmic/PlasmicWrapper.tsx\"));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/contexts/SettingsContext.tsx */ \"(app-pages-browser)/./src/contexts/SettingsContext.tsx\"));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/providers/AuthProvider.tsx */ \"(app-pages-browser)/./src/providers/AuthProvider.tsx\"));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/providers/QueryProvider.tsx */ \"(app-pages-browser)/./src/providers/QueryProvider.tsx\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGVXNlcnMlMkZ3b25kZXJsYW5kbWl0Y2glMkZDYXNjYWRlUHJvamVjdHMlMkZXb25kZXJWaXRlLWZyb250ZW5kJTJGYXBwJTJGZ2xvYmFscy5jc3MlMjIlMkMlMjJpZHMlMjIlM0ElNUIlNUQlN0QmbW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGVXNlcnMlMkZ3b25kZXJsYW5kbWl0Y2glMkZDYXNjYWRlUHJvamVjdHMlMkZXb25kZXJWaXRlLWZyb250ZW5kJTJGc3JjJTJGY29tcG9uZW50cyUyRnBsYXNtaWMlMkZQbGFzbWljV3JhcHBlci50c3glMjIlMkMlMjJpZHMlMjIlM0ElNUIlMjJQbGFzbWljV3JhcHBlciUyMiU1RCU3RCZtb2R1bGVzPSU3QiUyMnJlcXVlc3QlMjIlM0ElMjIlMkZVc2VycyUyRndvbmRlcmxhbmRtaXRjaCUyRkNhc2NhZGVQcm9qZWN0cyUyRldvbmRlclZpdGUtZnJvbnRlbmQlMkZzcmMlMkZjb250ZXh0cyUyRlNldHRpbmdzQ29udGV4dC50c3glMjIlMkMlMjJpZHMlMjIlM0ElNUIlMjJTZXR0aW5nc1Byb3ZpZGVyJTIyJTVEJTdEJm1vZHVsZXM9JTdCJTIycmVxdWVzdCUyMiUzQSUyMiUyRlVzZXJzJTJGd29uZGVybGFuZG1pdGNoJTJGQ2FzY2FkZVByb2plY3RzJTJGV29uZGVyVml0ZS1mcm9udGVuZCUyRnNyYyUyRnByb3ZpZGVycyUyRkF1dGhQcm92aWRlci50c3glMjIlMkMlMjJpZHMlMjIlM0ElNUIlMjJBdXRoUHJvdmlkZXIlMjIlNUQlN0QmbW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGVXNlcnMlMkZ3b25kZXJsYW5kbWl0Y2glMkZDYXNjYWRlUHJvamVjdHMlMkZXb25kZXJWaXRlLWZyb250ZW5kJTJGc3JjJTJGcHJvdmlkZXJzJTJGUXVlcnlQcm92aWRlci50c3glMjIlMkMlMjJpZHMlMjIlM0ElNUIlMjJRdWVyeVByb3ZpZGVyJTIyJTVEJTdEJnNlcnZlcj1mYWxzZSEiLCJtYXBwaW5ncyI6IkFBQUEsNEpBQStHO0FBQy9HO0FBQ0EsZ05BQTZLO0FBQzdLO0FBQ0EsOExBQXNLO0FBQ3RLO0FBQ0EsMExBQWdLO0FBQ2hLO0FBQ0EsNExBQWtLIiwic291cmNlcyI6WyIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvVXNlcnMvd29uZGVybGFuZG1pdGNoL0Nhc2NhZGVQcm9qZWN0cy9Xb25kZXJWaXRlLWZyb250ZW5kL2FwcC9nbG9iYWxzLmNzc1wiKTtcbjtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiLCB3ZWJwYWNrRXhwb3J0czogW1wiUGxhc21pY1dyYXBwZXJcIl0gKi8gXCIvVXNlcnMvd29uZGVybGFuZG1pdGNoL0Nhc2NhZGVQcm9qZWN0cy9Xb25kZXJWaXRlLWZyb250ZW5kL3NyYy9jb21wb25lbnRzL3BsYXNtaWMvUGxhc21pY1dyYXBwZXIudHN4XCIpO1xuO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIsIHdlYnBhY2tFeHBvcnRzOiBbXCJTZXR0aW5nc1Byb3ZpZGVyXCJdICovIFwiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvV29uZGVyVml0ZS1mcm9udGVuZC9zcmMvY29udGV4dHMvU2V0dGluZ3NDb250ZXh0LnRzeFwiKTtcbjtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiLCB3ZWJwYWNrRXhwb3J0czogW1wiQXV0aFByb3ZpZGVyXCJdICovIFwiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvV29uZGVyVml0ZS1mcm9udGVuZC9zcmMvcHJvdmlkZXJzL0F1dGhQcm92aWRlci50c3hcIik7XG47XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiwgd2VicGFja0V4cG9ydHM6IFtcIlF1ZXJ5UHJvdmlkZXJcIl0gKi8gXCIvVXNlcnMvd29uZGVybGFuZG1pdGNoL0Nhc2NhZGVQcm9qZWN0cy9Xb25kZXJWaXRlLWZyb250ZW5kL3NyYy9wcm92aWRlcnMvUXVlcnlQcm92aWRlci50c3hcIik7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fwonderlandmitch%2FCascadeProjects%2FWonderVite-frontend%2Fapp%2Fglobals.css%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fwonderlandmitch%2FCascadeProjects%2FWonderVite-frontend%2Fsrc%2Fcomponents%2Fplasmic%2FPlasmicWrapper.tsx%22%2C%22ids%22%3A%5B%22PlasmicWrapper%22%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fwonderlandmitch%2FCascadeProjects%2FWonderVite-frontend%2Fsrc%2Fcontexts%2FSettingsContext.tsx%22%2C%22ids%22%3A%5B%22SettingsProvider%22%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fwonderlandmitch%2FCascadeProjects%2FWonderVite-frontend%2Fsrc%2Fproviders%2FAuthProvider.tsx%22%2C%22ids%22%3A%5B%22AuthProvider%22%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fwonderlandmitch%2FCascadeProjects%2FWonderVite-frontend%2Fsrc%2Fproviders%2FQueryProvider.tsx%22%2C%22ids%22%3A%5B%22QueryProvider%22%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@plasmicapp/data-sources-context/dist/index.esm.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@plasmicapp/data-sources-context/dist/index.esm.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PlasmicDataSourceContextProvider: () => (/* binding */ PlasmicDataSourceContextProvider),\n/* harmony export */   useCurrentUser: () => (/* binding */ useCurrentUser),\n/* harmony export */   usePlasmicDataSourceContext: () => (/* binding */ usePlasmicDataSourceContext)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* __next_internal_client_entry_do_not_use__ PlasmicDataSourceContextProvider,useCurrentUser,usePlasmicDataSourceContext auto */ var _s = $RefreshSig$(), _s1 = $RefreshSig$();\n// src/index.tsx\n\nvar PlasmicDataSourceContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext(void 0);\nfunction usePlasmicDataSourceContext() {\n    _s();\n    return react__WEBPACK_IMPORTED_MODULE_0___default().useContext(PlasmicDataSourceContext);\n}\n_s(usePlasmicDataSourceContext, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nfunction useCurrentUser() {\n    _s1();\n    var _a;\n    const ctx = usePlasmicDataSourceContext();\n    return (_a = ctx == null ? void 0 : ctx.user) != null ? _a : {\n        isLoggedIn: false\n    };\n}\n_s1(useCurrentUser, \"aN7T1kJC94HUAXZL/j+qAQCnDQU=\", false, function() {\n    return [\n        usePlasmicDataSourceContext\n    ];\n});\nvar PlasmicDataSourceContextProvider = PlasmicDataSourceContext.Provider;\n //# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcGxhc21pY2FwcC9kYXRhLXNvdXJjZXMtY29udGV4dC9kaXN0L2luZGV4LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQWtCO0FBZ0JsQixJQUFNLHlDQUEyQiwwREFBTSxDQUVyQyxNQUFTO0FBRUo7O0lBQ0wsT0FBTyx1REFBTSxDQUFXLHdCQUF3QjtBQUNsRDtHQUZnQiw4QkFBOEI7QUFJdkM7O0lBeEJQO0lBeUJFLE1BQU07SUFDTixRQUNFLGdDQUFLLFNBQUwsWUFBYTtRQUNYLFlBQVk7SUFDZDtBQUVKO0lBUGdCLGlCQUFpQjs7UUFDbkI7OztBQVFQLElBQU0sbUNBQ1gseUJBQXlCIiwic291cmNlcyI6WyIvVXNlcnMvd29uZGVybGFuZG1pdGNoL0Nhc2NhZGVQcm9qZWN0cy9zcmMvaW5kZXgudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGxhc21pY0RhdGFTb3VyY2VDb250ZXh0VmFsdWUge1xuICB1c2VyQXV0aFRva2VuPzogc3RyaW5nIHwgbnVsbDtcbiAgaXNVc2VyTG9hZGluZz86IGJvb2xlYW47XG4gIGF1dGhSZWRpcmVjdFVyaT86IHN0cmluZztcbiAgdXNlcj86IHtcbiAgICBlbWFpbDogc3RyaW5nO1xuICAgIHByb3BlcnRpZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+IHwgbnVsbDtcbiAgICByb2xlSWQ6IHN0cmluZztcbiAgICByb2xlTmFtZTogc3RyaW5nO1xuICAgIHJvbGVJZHM6IHN0cmluZ1tdO1xuICAgIHJvbGVOYW1lczogc3RyaW5nW107XG4gIH0gfCBudWxsO1xufVxuXG5jb25zdCBQbGFzbWljRGF0YVNvdXJjZUNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0PFxuICBQbGFzbWljRGF0YVNvdXJjZUNvbnRleHRWYWx1ZSB8IHVuZGVmaW5lZFxuPih1bmRlZmluZWQpO1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlUGxhc21pY0RhdGFTb3VyY2VDb250ZXh0KCkge1xuICByZXR1cm4gUmVhY3QudXNlQ29udGV4dChQbGFzbWljRGF0YVNvdXJjZUNvbnRleHQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlQ3VycmVudFVzZXIoKSB7XG4gIGNvbnN0IGN0eCA9IHVzZVBsYXNtaWNEYXRhU291cmNlQ29udGV4dCgpO1xuICByZXR1cm4gKFxuICAgIGN0eD8udXNlciA/PyB7XG4gICAgICBpc0xvZ2dlZEluOiBmYWxzZSxcbiAgICB9XG4gICk7XG59XG5cbmV4cG9ydCBjb25zdCBQbGFzbWljRGF0YVNvdXJjZUNvbnRleHRQcm92aWRlciA9XG4gIFBsYXNtaWNEYXRhU291cmNlQ29udGV4dC5Qcm92aWRlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@plasmicapp/data-sources-context/dist/index.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@plasmicapp/host/dist/host.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/@plasmicapp/host/dist/host.esm.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("var react_dom__WEBPACK_IMPORTED_MODULE_2___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DataContext: () => (/* binding */ DataContext),\n/* harmony export */   DataCtxReader: () => (/* binding */ DataCtxReader),\n/* harmony export */   DataProvider: () => (/* binding */ DataProvider),\n/* harmony export */   GlobalActionsContext: () => (/* binding */ GlobalActionsContext),\n/* harmony export */   GlobalActionsProvider: () => (/* binding */ GlobalActionsProvider),\n/* harmony export */   PageParamsProvider: () => (/* binding */ PageParamsProvider),\n/* harmony export */   PlasmicCanvasContext: () => (/* binding */ PlasmicCanvasContext),\n/* harmony export */   PlasmicCanvasHost: () => (/* binding */ PlasmicCanvasHost),\n/* harmony export */   PlasmicLinkProvider: () => (/* binding */ PlasmicLinkProvider),\n/* harmony export */   PlasmicTranslatorContext: () => (/* binding */ PlasmicTranslatorContext),\n/* harmony export */   applySelector: () => (/* binding */ applySelector),\n/* harmony export */   mkMetaName: () => (/* binding */ mkMetaName),\n/* harmony export */   mkMetaValue: () => (/* binding */ mkMetaValue),\n/* harmony export */   registerComponent: () => (/* binding */ registerComponent),\n/* harmony export */   registerFunction: () => (/* binding */ registerFunction),\n/* harmony export */   registerGlobalContext: () => (/* binding */ registerGlobalContext),\n/* harmony export */   registerToken: () => (/* binding */ registerToken),\n/* harmony export */   registerTrait: () => (/* binding */ registerTrait),\n/* harmony export */   repeatedElement: () => (/* binding */ repeatedElement),\n/* harmony export */   stateHelpersKeys: () => (/* binding */ stateHelpersKeys),\n/* harmony export */   unstable_registerFetcher: () => (/* binding */ registerFetcher),\n/* harmony export */   useDataEnv: () => (/* binding */ useDataEnv),\n/* harmony export */   useGlobalActions: () => (/* binding */ useGlobalActions),\n/* harmony export */   usePlasmicCanvasComponentInfo: () => (/* binding */ usePlasmicCanvasComponentInfo),\n/* harmony export */   usePlasmicCanvasContext: () => (/* binding */ usePlasmicCanvasContext),\n/* harmony export */   usePlasmicLink: () => (/* binding */ usePlasmicLink),\n/* harmony export */   usePlasmicLinkMaybe: () => (/* binding */ usePlasmicLinkMaybe),\n/* harmony export */   usePlasmicTranslator: () => (/* binding */ usePlasmicTranslator),\n/* harmony export */   useSelector: () => (/* binding */ useSelector),\n/* harmony export */   useSelectors: () => (/* binding */ useSelectors)\n/* harmony export */ });\n/* harmony import */ var _plasmicapp_query__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @plasmicapp/query */ \"(app-pages-browser)/./node_modules/@plasmicapp/query/dist/index.esm.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\");\n/* __next_internal_client_entry_do_not_use__ DataContext,DataCtxReader,DataProvider,GlobalActionsContext,GlobalActionsProvider,PageParamsProvider,PlasmicCanvasContext,PlasmicCanvasHost,PlasmicLinkProvider,PlasmicTranslatorContext,applySelector,mkMetaName,mkMetaValue,registerComponent,registerFunction,registerGlobalContext,registerToken,registerTrait,repeatedElement,stateHelpersKeys,unstable_registerFetcher,useDataEnv,useGlobalActions,usePlasmicCanvasComponentInfo,usePlasmicCanvasContext,usePlasmicLink,usePlasmicLinkMaybe,usePlasmicTranslator,useSelector,useSelectors auto */ var _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$(), _s3 = $RefreshSig$(), _s4 = $RefreshSig$(), _s5 = $RefreshSig$(), _s6 = $RefreshSig$(), _s7 = $RefreshSig$(), _s8 = $RefreshSig$(), _s9 = $RefreshSig$(), _s10 = $RefreshSig$(), _s11 = $RefreshSig$(), _s12 = $RefreshSig$(), _s13 = $RefreshSig$(), _s14 = $RefreshSig$(), _s15 = $RefreshSig$();\n\n\n\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ /* global Reflect, Promise, SuppressedError, Symbol */ var extendStatics = function(d, b) {\n    extendStatics = Object.setPrototypeOf || ({\n        __proto__: []\n    }) instanceof Array && function(d, b) {\n        d.__proto__ = b;\n    } || function(d, b) {\n        for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n};\nfunction __extends(d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n        this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nvar __assign = function() {\n    __assign = Object.assign || function __assign(t) {\n        for(var s, i = 1, n = arguments.length; i < n; i++){\n            s = arguments[i];\n            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\ntypeof SuppressedError === \"function\" ? SuppressedError : function(error, suppressed, message) {\n    var e = new Error(message);\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\nfunction isString(x) {\n    return typeof x === \"string\";\n}\nfunction ensure(x, msg) {\n    if (msg === void 0) {\n        msg = \"\";\n    }\n    if (x === null || x === undefined) {\n        debugger;\n        msg = (isString(msg) ? msg : msg()) || \"\";\n        throw new Error(\"Value must not be undefined or null\".concat(msg ? \"- \".concat(msg) : \"\"));\n    } else {\n        return x;\n    }\n}\nfunction useForceUpdate() {\n    _s();\n    var _a = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0), setTick = _a[1];\n    var update = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"useForceUpdate.useCallback[update]\": function() {\n            setTick({\n                \"useForceUpdate.useCallback[update]\": function(tick) {\n                    return tick + 1;\n                }\n            }[\"useForceUpdate.useCallback[update]\"]);\n        }\n    }[\"useForceUpdate.useCallback[update]\"], []);\n    return update;\n}\n_s(useForceUpdate, \"EcBPlkctupJE0INl+34PkXJSQ3I=\");\nif (globalThis.__PlasmicHostVersion == null) {\n    globalThis.__PlasmicHostVersion = \"3\";\n}\nvar rootChangeListeners = [];\nvar PlasmicRootNodeWrapper = /** @class */ function() {\n    function PlasmicRootNodeWrapper(value) {\n        var _this = this;\n        this.value = value;\n        this.set = function(val) {\n            _this.value = val;\n            rootChangeListeners.forEach(function(f) {\n                return f();\n            });\n        };\n        this.get = function() {\n            return _this.value;\n        };\n    }\n    return PlasmicRootNodeWrapper;\n}();\nvar plasmicRootNode = new PlasmicRootNodeWrapper(null);\nfunction getHashParams() {\n    return new URLSearchParams(location.hash.replace(/^#/, \"?\"));\n}\nfunction getPlasmicOrigin() {\n    var params = getHashParams();\n    return ensure(params.get(\"origin\"), \"Missing information from Plasmic window.\");\n}\nfunction getStudioHash() {\n    var hashParams = getHashParams();\n    if (hashParams.has(\"studioHash\")) {\n        return hashParams.get(\"studioHash\");\n    }\n    var urlParams = new URL(location.href).searchParams;\n    return urlParams.get(\"studio-hash\");\n}\nfunction renderStudioIntoIframe() {\n    var script = document.createElement(\"script\");\n    var plasmicOrigin = getPlasmicOrigin();\n    var hash = getStudioHash();\n    script.src = \"\".concat(plasmicOrigin, \"/static/js/studio\").concat(hash ? \".\".concat(hash, \".js\") : \".js\");\n    document.body.appendChild(script);\n}\nvar renderCount = 0;\nfunction setPlasmicRootNode(node) {\n    // Keep track of renderCount, which we use as key to ErrorBoundary, so\n    // we can reset the error on each render\n    renderCount++;\n    plasmicRootNode.set(node);\n}\n/**\n * React context to detect whether the component is rendered on Plasmic editor.\n * If not, return false.\n * If so, return an object with more information about the component\n */ var PlasmicCanvasContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createContext(false);\nvar usePlasmicCanvasContext = function() {\n    _s1();\n    return react__WEBPACK_IMPORTED_MODULE_1__.useContext(PlasmicCanvasContext);\n};\n_s1(usePlasmicCanvasContext, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nfunction _PlasmicCanvasHost() {\n    _s2();\n    var _a, _b;\n    // If window.parent is null, then this is a window whose containing iframe\n    // has been detached from the DOM (for the top window, window.parent === window).\n    // In that case, we shouldn't do anything.  If window.parent is null, by the way,\n    // location.hash will also be null.\n    var isFrameAttached = !!window.parent;\n    var isCanvas = !!((_a = location.hash) === null || _a === void 0 ? void 0 : _a.match(/\\bcanvas=true\\b/));\n    var isLive = !!((_b = location.hash) === null || _b === void 0 ? void 0 : _b.match(/\\blive=true\\b/)) || !isFrameAttached;\n    var shouldRenderStudio = isFrameAttached && !document.querySelector(\"#plasmic-studio-tag\") && !isCanvas && !isLive;\n    var forceUpdate = useForceUpdate();\n    react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect({\n        \"_PlasmicCanvasHost.useLayoutEffect\": function() {\n            rootChangeListeners.push(forceUpdate);\n            return ({\n                \"_PlasmicCanvasHost.useLayoutEffect\": function() {\n                    var index = rootChangeListeners.indexOf(forceUpdate);\n                    if (index >= 0) {\n                        rootChangeListeners.splice(index, 1);\n                    }\n                }\n            })[\"_PlasmicCanvasHost.useLayoutEffect\"];\n        }\n    }[\"_PlasmicCanvasHost.useLayoutEffect\"], [\n        forceUpdate\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect({\n        \"_PlasmicCanvasHost.useEffect\": function() {\n            if (shouldRenderStudio && isFrameAttached && window.parent !== window) {\n                renderStudioIntoIframe();\n            }\n        }\n    }[\"_PlasmicCanvasHost.useEffect\"], [\n        shouldRenderStudio,\n        isFrameAttached\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect({\n        \"_PlasmicCanvasHost.useEffect\": function() {\n            if (!shouldRenderStudio && !document.querySelector(\"#getlibs\") && isLive) {\n                var scriptElt = document.createElement(\"script\");\n                scriptElt.id = \"getlibs\";\n                scriptElt.src = getPlasmicOrigin() + \"/static/js/getlibs.js\";\n                scriptElt.async = false;\n                scriptElt.onload = ({\n                    \"_PlasmicCanvasHost.useEffect\": function() {\n                        var _a, _b;\n                        (_b = (_a = window).__GetlibsReadyResolver) === null || _b === void 0 ? void 0 : _b.call(_a);\n                    }\n                })[\"_PlasmicCanvasHost.useEffect\"];\n                document.head.append(scriptElt);\n            }\n        }\n    }[\"_PlasmicCanvasHost.useEffect\"], [\n        shouldRenderStudio\n    ]);\n    var _c = react__WEBPACK_IMPORTED_MODULE_1__.useState({\n        \"_PlasmicCanvasHost.useState[_c]\": function() {\n            return deriveCanvasContextValue();\n        }\n    }[\"_PlasmicCanvasHost.useState[_c]\"]), canvasContextValue = _c[0], setCanvasContextValue = _c[1];\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect({\n        \"_PlasmicCanvasHost.useEffect\": function() {\n            if (isCanvas) {\n                var listener_1 = {\n                    \"_PlasmicCanvasHost.useEffect.listener_1\": function() {\n                        setCanvasContextValue(deriveCanvasContextValue());\n                    }\n                }[\"_PlasmicCanvasHost.useEffect.listener_1\"];\n                window.addEventListener(\"hashchange\", listener_1);\n                return ({\n                    \"_PlasmicCanvasHost.useEffect\": function() {\n                        return window.removeEventListener(\"hashchange\", listener_1);\n                    }\n                })[\"_PlasmicCanvasHost.useEffect\"];\n            }\n            return undefined;\n        }\n    }[\"_PlasmicCanvasHost.useEffect\"], [\n        isCanvas\n    ]);\n    if (!isFrameAttached) {\n        return null;\n    }\n    if (isCanvas || isLive) {\n        var appDiv = document.querySelector(\"#plasmic-app.__wab_user-body\");\n        if (!appDiv) {\n            appDiv = document.createElement(\"div\");\n            appDiv.id = \"plasmic-app\";\n            appDiv.classList.add(\"__wab_user-body\");\n            document.body.prepend(appDiv);\n        }\n        return /*#__PURE__*/ react_dom__WEBPACK_IMPORTED_MODULE_2__.createPortal(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(ErrorBoundary, {\n            key: \"\".concat(renderCount)\n        }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(PlasmicCanvasContext.Provider, {\n            value: canvasContextValue\n        }, plasmicRootNode.get())), appDiv, \"plasmic-app\");\n    }\n    if (shouldRenderStudio && window.parent === window) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"iframe\", {\n            src: \"https://docs.plasmic.app/app-content/app-host-ready#appHostUrl=\".concat(encodeURIComponent(location.href)),\n            style: {\n                width: \"100vw\",\n                height: \"100vh\",\n                border: \"none\",\n                position: \"fixed\",\n                top: 0,\n                left: 0,\n                zIndex: 99999999\n            }\n        });\n    }\n    return null;\n}\n_s2(_PlasmicCanvasHost, \"fX4Ub3AQcoSAeInIdIVYymjacp4=\", false, function() {\n    return [\n        useForceUpdate\n    ];\n});\nvar PlasmicCanvasHost = function(props) {\n    _s3();\n    var enableWebpackHmr = props.enableWebpackHmr;\n    var _a = react__WEBPACK_IMPORTED_MODULE_1__.useState(null), node = _a[0], setNode = _a[1];\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect({\n        \"PlasmicCanvasHost.useEffect\": function() {\n            setNode(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(_PlasmicCanvasHost, null));\n        }\n    }[\"PlasmicCanvasHost.useEffect\"], []);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, !enableWebpackHmr && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(DisableWebpackHmr, null), node);\n};\n_s3(PlasmicCanvasHost, \"VJtlwQy3+cE2Kt37iqQtqnxEfIs=\");\n_c = PlasmicCanvasHost;\nvar renderErrorListeners = [];\nfunction registerRenderErrorListener(listener) {\n    renderErrorListeners.push(listener);\n    return function() {\n        var index = renderErrorListeners.indexOf(listener);\n        if (index >= 0) {\n            renderErrorListeners.splice(index, 1);\n        }\n    };\n}\nvar ErrorBoundary = /** @class */ function(_super) {\n    __extends(ErrorBoundary, _super);\n    function ErrorBoundary(props) {\n        var _this = _super.call(this, props) || this;\n        _this.state = {};\n        return _this;\n    }\n    ErrorBoundary.getDerivedStateFromError = function(error) {\n        return {\n            error: error\n        };\n    };\n    ErrorBoundary.prototype.componentDidCatch = function(error) {\n        renderErrorListeners.forEach(function(listener) {\n            return listener(error);\n        });\n    };\n    ErrorBoundary.prototype.render = function() {\n        if (this.state.error) {\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", null, \"Error: \", \"\".concat(this.state.error.message));\n        } else {\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, this.props.children);\n        }\n    };\n    return ErrorBoundary;\n}(react__WEBPACK_IMPORTED_MODULE_1__.Component);\nfunction DisableWebpackHmr() {\n    if (false) {}\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"script\", {\n        type: \"text/javascript\",\n        dangerouslySetInnerHTML: {\n            __html: \"\\n      if (typeof window !== \\\"undefined\\\") {\\n        const RealEventSource = window.EventSource;\\n        window.EventSource = function(url, config) {\\n          if (/[^a-zA-Z]hmr($|[^a-zA-Z])/.test(url)) {\\n            console.warn(\\\"Plasmic: disabled EventSource request for\\\", url);\\n            return {\\n              onerror() {}, onmessage() {}, onopen() {}, close() {}\\n            };\\n          } else {\\n            return new RealEventSource(url, config);\\n          }\\n        }\\n      }\\n      \"\n        }\n    });\n}\n_c1 = DisableWebpackHmr;\nfunction deriveCanvasContextValue() {\n    var _a;\n    var hash = window.location.hash;\n    if (hash && hash.length > 0) {\n        // create URLsearchParams skipping the initial # character\n        var params = new URLSearchParams(hash.substring(1));\n        if (params.get(\"canvas\") === \"true\") {\n            var globalVariants = params.get(\"globalVariants\");\n            return {\n                componentName: (_a = params.get(\"componentName\")) !== null && _a !== void 0 ? _a : null,\n                globalVariants: globalVariants ? JSON.parse(globalVariants) : {},\n                interactive: params.get(\"interactive\") === \"true\"\n            };\n        }\n    }\n    return false;\n}\nvar INTERNAL_CC_CANVAS_SELECTION_PROP = \"__plasmic_selection_prop__\";\nfunction usePlasmicCanvasComponentInfo(props) {\n    _s4();\n    return react__WEBPACK_IMPORTED_MODULE_1__.useMemo({\n        \"usePlasmicCanvasComponentInfo.useMemo\": function() {\n            // Inside Plasmic Studio, code components will receive an additional prop\n            // that contains selection information for that specific code component.\n            // This hook will return that selection information which is useful for\n            // changing the behavior of the code component when it is selected, making\n            // it easier to interact with code components and slots that aren't always\n            // visible in the canvas. (e.g. automatically opening a modal when it's selected)\n            var selectionInfo = props === null || props === void 0 ? void 0 : props[INTERNAL_CC_CANVAS_SELECTION_PROP];\n            if (selectionInfo) {\n                return {\n                    isSelected: selectionInfo.isSelected,\n                    selectedSlotName: selectionInfo.selectedSlotName\n                };\n            }\n            return null;\n        }\n    }[\"usePlasmicCanvasComponentInfo.useMemo\"], [\n        props\n    ]);\n}\n_s4(usePlasmicCanvasComponentInfo, \"nwk+m61qLgjDVUp4IGV/072DDN4=\");\nvar tuple = function() {\n    var args = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        args[_i] = arguments[_i];\n    }\n    return args;\n};\nvar DataContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nfunction mkMetaName(name) {\n    return \"__plasmic_meta_\".concat(name);\n}\nfunction mkMetaValue(meta) {\n    return meta;\n}\nfunction applySelector(rawData, selector) {\n    if (!selector) {\n        return undefined;\n    }\n    var curData = rawData;\n    for(var _i = 0, _a = selector.split(\".\"); _i < _a.length; _i++){\n        var key = _a[_i];\n        curData = curData === null || curData === void 0 ? void 0 : curData[key];\n    }\n    return curData;\n}\nfunction useSelector(selector) {\n    _s5();\n    var rawData = useDataEnv();\n    return applySelector(rawData, selector);\n}\n_s5(useSelector, \"EsrmDriQ5ozGU8eSJjwvNUcJRR0=\", false, function() {\n    return [\n        useDataEnv\n    ];\n});\nfunction useSelectors(selectors) {\n    _s6();\n    if (selectors === void 0) {\n        selectors = {};\n    }\n    var rawData = useDataEnv();\n    return Object.fromEntries(Object.entries(selectors).filter(function(_a) {\n        var key = _a[0], selector = _a[1];\n        return !!key && !!selector;\n    }).map(function(_a) {\n        var key = _a[0], selector = _a[1];\n        return tuple(key, applySelector(rawData, selector));\n    }));\n}\n_s6(useSelectors, \"EsrmDriQ5ozGU8eSJjwvNUcJRR0=\", false, function() {\n    return [\n        useDataEnv\n    ];\n});\nfunction useDataEnv() {\n    _s7();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(DataContext);\n}\n_s7(useDataEnv, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nfunction DataProvider(_a) {\n    _s8();\n    var _b;\n    var _c;\n    var name = _a.name, data = _a.data, hidden = _a.hidden, advanced = _a.advanced, label = _a.label, children = _a.children;\n    var existingEnv = (_c = useDataEnv()) !== null && _c !== void 0 ? _c : {};\n    if (!name) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement((react__WEBPACK_IMPORTED_MODULE_1___default().Fragment), null, children);\n    } else {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(DataContext.Provider, {\n            value: __assign(__assign({}, existingEnv), (_b = {}, _b[name] = data, _b[mkMetaName(name)] = mkMetaValue({\n                hidden: hidden,\n                advanced: advanced,\n                label: label\n            }), _b))\n        }, children);\n    }\n}\n_s8(DataProvider, \"8c9swj0Nnsws4pZsWLLEeC2slDk=\", false, function() {\n    return [\n        useDataEnv\n    ];\n});\n_c2 = DataProvider;\n/**\n * This transforms `{ \"...slug\": \"a/b/c\" }` into `{ \"slug\": [\"a\", \"b\", \"c\"] }.\n */ function fixCatchallParams(params) {\n    var newParams = {};\n    for(var _i = 0, _a = Object.entries(params); _i < _a.length; _i++){\n        var _b = _a[_i], key = _b[0], value = _b[1];\n        if (!value) {\n            continue;\n        }\n        if (key.startsWith(\"...\")) {\n            newParams[key.slice(3)] = typeof value === \"string\" ? value.replace(/^\\/|\\/$/g, \"\").split(\"/\") : value;\n        } else {\n            newParams[key] = value;\n        }\n    }\n    return newParams;\n}\nfunction mkPathFromRouteAndParams(route, params) {\n    if (!params) {\n        return route;\n    }\n    var path = route;\n    for(var _i = 0, _a = Object.entries(params); _i < _a.length; _i++){\n        var _b = _a[_i], key = _b[0], value = _b[1];\n        if (typeof value === \"string\") {\n            path = path.replace(\"[\".concat(key, \"]\"), value);\n        } else if (Array.isArray(value)) {\n            if (path.includes(\"[[...\".concat(key, \"]]\"))) {\n                path = path.replace(\"[[...\".concat(key, \"]]\"), value.join(\"/\"));\n            } else if (path.includes(\"[...\".concat(key, \"]\"))) {\n                path = path.replace(\"[...\".concat(key, \"]\"), value.join(\"/\"));\n            }\n        }\n    }\n    return path;\n}\nfunction PageParamsProvider(_a) {\n    _s9();\n    var children = _a.children, route = _a.route, deprecatedRoute = _a.path, _b = _a.params, params = _b === void 0 ? {} : _b, _c = _a.query, query = _c === void 0 ? {} : _c;\n    route = route !== null && route !== void 0 ? route : deprecatedRoute;\n    params = fixCatchallParams(params);\n    var $ctx = useDataEnv() || {};\n    var path = route ? mkPathFromRouteAndParams(route, params) : undefined;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(DataProvider, {\n        name: \"pageRoute\",\n        data: route,\n        label: \"Page route\",\n        advanced: true\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(DataProvider, {\n        name: \"pagePath\",\n        data: path,\n        label: \"Page path\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(DataProvider, {\n        name: \"params\",\n        data: __assign(__assign({}, $ctx.params), params),\n        label: \"Page URL path params\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(DataProvider, {\n        name: \"query\",\n        data: __assign(__assign({}, $ctx.query), query),\n        label: \"Page URL query params\"\n    }, children))));\n}\n_s9(PageParamsProvider, \"8c9swj0Nnsws4pZsWLLEeC2slDk=\", false, function() {\n    return [\n        useDataEnv\n    ];\n});\n_c3 = PageParamsProvider;\nfunction DataCtxReader(_a) {\n    _s10();\n    var children = _a.children;\n    var $ctx = useDataEnv();\n    return children($ctx);\n}\n_s10(DataCtxReader, \"47A3d3sLCQZmxtjFe11YJHJuL/0=\", false, function() {\n    return [\n        useDataEnv\n    ];\n});\n_c4 = DataCtxReader;\nvar root$7 = globalThis;\nroot$7.__PlasmicFetcherRegistry = [];\nfunction registerFetcher(fetcher, meta) {\n    root$7.__PlasmicFetcherRegistry.push({\n        fetcher: fetcher,\n        meta: meta\n    });\n}\nvar GlobalActionsContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createContext(undefined);\nfunction GlobalActionsProvider(props) {\n    _s11();\n    var contextName = props.contextName, children = props.children, actions = props.actions;\n    var existingActions = useGlobalActions();\n    var namespacedActions = react__WEBPACK_IMPORTED_MODULE_1___default().useMemo({\n        \"GlobalActionsProvider.useMemo[namespacedActions]\": function() {\n            return Object.fromEntries(Object.entries(actions).map({\n                \"GlobalActionsProvider.useMemo[namespacedActions]\": function(_a) {\n                    var key = _a[0], val = _a[1];\n                    return [\n                        \"\".concat(contextName, \".\").concat(key),\n                        val\n                    ];\n                }\n            }[\"GlobalActionsProvider.useMemo[namespacedActions]\"]));\n        }\n    }[\"GlobalActionsProvider.useMemo[namespacedActions]\"], [\n        contextName,\n        actions\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(GlobalActionsContext.Provider, {\n        value: __assign(__assign({}, existingActions), namespacedActions)\n    }, children);\n}\n_s11(GlobalActionsProvider, \"3gpaQAVPj4IFp4H0s18lZFbFJTo=\", false, function() {\n    return [\n        useGlobalActions\n    ];\n});\n_c5 = GlobalActionsProvider;\nfunction useGlobalActions() {\n    _s12();\n    var _a;\n    return (_a = react__WEBPACK_IMPORTED_MODULE_1___default().useContext(GlobalActionsContext)) !== null && _a !== void 0 ? _a : {};\n}\n_s12(useGlobalActions, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nvar PlasmicLinkContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createContext(undefined);\nfunction usePlasmicLinkMaybe() {\n    _s13();\n    return react__WEBPACK_IMPORTED_MODULE_1___default().useContext(PlasmicLinkContext);\n}\n_s13(usePlasmicLinkMaybe, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nvar AnchorLink = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef(_c6 = function AnchorLink(props, ref) {\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"a\", __assign({}, props, {\n        ref: ref\n    }));\n});\n_c7 = AnchorLink;\nfunction usePlasmicLink() {\n    _s14();\n    var Link = react__WEBPACK_IMPORTED_MODULE_1___default().useContext(PlasmicLinkContext);\n    if (Link) {\n        return Link;\n    } else {\n        return AnchorLink;\n    }\n}\n_s14(usePlasmicLink, \"IWpbTDWBgiOiA6LIb7jMuaHi0p4=\");\nfunction PlasmicLinkProvider(props) {\n    var Link = props.Link, children = props.children;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(PlasmicLinkContext.Provider, {\n        value: Link\n    }, children);\n}\n_c8 = PlasmicLinkProvider;\nvar root$6 = globalThis;\n// A compile-time error will occur if a new field is added to the StateHelper\n// interface but not included in the keys array of state helper.\nvar stateHelpersKeys = [\n    \"initFunc\",\n    \"onChangeArgsToValue\",\n    \"onMutate\"\n];\nif (root$6.__PlasmicComponentRegistry == null) {\n    root$6.__PlasmicComponentRegistry = [];\n}\nfunction registerComponent(component, meta) {\n    // Check for duplicates\n    if (root$6.__PlasmicComponentRegistry.some(function(r) {\n        return r.component === component && r.meta.name === meta.name;\n    })) {\n        return;\n    }\n    root$6.__PlasmicComponentRegistry.push({\n        component: component,\n        meta: meta\n    });\n}\nvar root$5 = globalThis;\nif (root$5.__PlasmicFunctionsRegistry == null) {\n    root$5.__PlasmicFunctionsRegistry = [];\n}\nfunction registerFunction(fn, meta) {\n    // Check for duplicates\n    if (root$5.__PlasmicFunctionsRegistry.some(function(r) {\n        return r.function === fn && r.meta.name === meta.name && r.meta.namespace == meta.namespace;\n    })) {\n        return;\n    }\n    root$5.__PlasmicFunctionsRegistry.push({\n        function: fn,\n        meta: meta\n    });\n}\nvar root$4 = globalThis;\nif (root$4.__PlasmicContextRegistry == null) {\n    root$4.__PlasmicContextRegistry = [];\n}\nfunction registerGlobalContext(component, meta) {\n    // Check for duplicates\n    if (root$4.__PlasmicContextRegistry.some(function(r) {\n        return r.component === component && r.meta.name === meta.name;\n    })) {\n        return;\n    }\n    root$4.__PlasmicContextRegistry.push({\n        component: component,\n        meta: meta\n    });\n}\nvar root$3 = globalThis;\nif (root$3.__PlasmicTokenRegistry == null) {\n    root$3.__PlasmicTokenRegistry = [];\n}\nfunction registerToken(token) {\n    root$3.__PlasmicTokenRegistry.push(token);\n}\nvar root$2 = globalThis;\nif (root$2.__PlasmicTraitRegistry == null) {\n    root$2.__PlasmicTraitRegistry = [];\n}\nfunction registerTrait(trait, meta) {\n    root$2.__PlasmicTraitRegistry.push({\n        trait: trait,\n        meta: meta\n    });\n}\nvar _a$1, _b;\nfunction repeatedElement(index, elt) {\n    return repeatedElementFn(index, elt);\n}\nvar repeatedElementFn = function(index, elt) {\n    if (Array.isArray(elt)) {\n        return elt.map(function(v) {\n            return repeatedElementFn(index, v);\n        });\n    }\n    if (elt && /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.isValidElement)(elt) && typeof elt !== \"string\") {\n        return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.cloneElement)(elt);\n    }\n    return elt;\n};\nvar root$1 = globalThis;\nvar setRepeatedElementFn = (_b = (_a$1 = root$1 === null || root$1 === void 0 ? void 0 : root$1.__Sub) === null || _a$1 === void 0 ? void 0 : _a$1.setRepeatedElementFn) !== null && _b !== void 0 ? _b : function(fn) {\n    repeatedElementFn = fn;\n};\nvar PlasmicTranslatorContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createContext(undefined);\nfunction usePlasmicTranslator() {\n    _s15();\n    var _t = react__WEBPACK_IMPORTED_MODULE_1___default().useContext(PlasmicTranslatorContext);\n    var translator = _t ? typeof _t === \"function\" ? _t : _t.translator : undefined;\n    return translator;\n}\n_s15(usePlasmicTranslator, \"Lf7ceh+SvG1w8g2a0mhlFJCQbt0=\");\nvar hostModule = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    DataContext: DataContext,\n    DataCtxReader: DataCtxReader,\n    DataProvider: DataProvider,\n    GlobalActionsContext: GlobalActionsContext,\n    GlobalActionsProvider: GlobalActionsProvider,\n    PageParamsProvider: PageParamsProvider,\n    PlasmicCanvasContext: PlasmicCanvasContext,\n    PlasmicCanvasHost: PlasmicCanvasHost,\n    PlasmicLinkProvider: PlasmicLinkProvider,\n    PlasmicTranslatorContext: PlasmicTranslatorContext,\n    applySelector: applySelector,\n    mkMetaName: mkMetaName,\n    mkMetaValue: mkMetaValue,\n    registerComponent: registerComponent,\n    registerFunction: registerFunction,\n    registerGlobalContext: registerGlobalContext,\n    registerToken: registerToken,\n    registerTrait: registerTrait,\n    repeatedElement: repeatedElement,\n    stateHelpersKeys: stateHelpersKeys,\n    unstable_registerFetcher: registerFetcher,\n    useDataEnv: useDataEnv,\n    useGlobalActions: useGlobalActions,\n    usePlasmicCanvasComponentInfo: usePlasmicCanvasComponentInfo,\n    usePlasmicCanvasContext: usePlasmicCanvasContext,\n    usePlasmicLink: usePlasmicLink,\n    usePlasmicLinkMaybe: usePlasmicLinkMaybe,\n    usePlasmicTranslator: usePlasmicTranslator,\n    useSelector: useSelector,\n    useSelectors: useSelectors\n});\nvar hostVersion = \"1.0.208\";\nvar _a;\nvar root = globalThis;\nif (root.__Sub == null) {\n    // Creating a side effect here by logging, so that vite won't\n    // ignore this block for whatever reason. Hiding this for now\n    // as users are complaining; will have to check if this has\n    // been fixed with vite.\n    // console.log(\"Plasmic: Setting up app host dependencies\");\n    root.__Sub = __assign({\n        React: react__WEBPACK_IMPORTED_MODULE_1__,\n        ReactDOM: /*#__PURE__*/ (react_dom__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (react_dom__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(react_dom__WEBPACK_IMPORTED_MODULE_2__, 2))),\n        PlasmicQuery: _plasmicapp_query__WEBPACK_IMPORTED_MODULE_0__,\n        hostModule: hostModule,\n        hostVersion: hostVersion,\n        hostUtils: {\n            setPlasmicRootNode: setPlasmicRootNode,\n            registerRenderErrorListener: registerRenderErrorListener,\n            setRepeatedElementFn: setRepeatedElementFn\n        },\n        // For backwards compatibility:\n        setPlasmicRootNode: setPlasmicRootNode,\n        registerRenderErrorListener: registerRenderErrorListener,\n        setRepeatedElementFn: setRepeatedElementFn\n    }, hostModule);\n} else {\n    console.warn(\"Encountered likely duplicate host version: \".concat(root.__Sub.hostVersion, \" vs \").concat(hostVersion));\n    root.__Sub.duplicateHostVersions = (_a = root.__Sub.duplicateHostVersions) !== null && _a !== void 0 ? _a : [];\n    root.__Sub.duplicateHostVersions.push(hostVersion);\n}\n //# sourceMappingURL=host.esm.js.map\nvar _c, _c1, _c2, _c3, _c4, _c5, _c6, _c7, _c8;\n$RefreshReg$(_c, \"PlasmicCanvasHost\");\n$RefreshReg$(_c1, \"DisableWebpackHmr\");\n$RefreshReg$(_c2, \"DataProvider\");\n$RefreshReg$(_c3, \"PageParamsProvider\");\n$RefreshReg$(_c4, \"DataCtxReader\");\n$RefreshReg$(_c5, \"GlobalActionsProvider\");\n$RefreshReg$(_c6, \"AnchorLink$React__default.forwardRef\");\n$RefreshReg$(_c7, \"AnchorLink\");\n$RefreshReg$(_c8, \"PlasmicLinkProvider\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcGxhc21pY2FwcC9ob3N0L2Rpc3QvaG9zdC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLFNBQVMsUUFBUSxDQUFDLENBQU07SUFDdEIsT0FBTyxPQUFPLENBQUMsS0FBSyxRQUFRLENBQUM7QUFDL0IsQ0FBQztBQUllLGVBQU0sQ0FBSSxDQUF1QixFQUFFLEdBQW1CO0lBQW5CO1FBQUEsR0FBbUI7SUFBQTtJQUNwRSxJQUFJLENBQUMsS0FBSyxJQUFJLElBQUksQ0FBQyxLQUFLLFNBQVMsRUFBRTtRQUNqQyxRQUFTO1FBQ1QsR0FBRyxHQUFHLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUUsSUFBSyxFQUFFLENBQUM7UUFDMUMsTUFBTSxJQUFJLEtBQUssQ0FDYixxQ0FBc0MsV0FBRyxHQUFHLElBQUssV0FBRyxDQUFFLEdBQUcsRUFBRSxDQUFFLENBQzlELENBQUM7SUFDSCxPQUFNO1FBQ0wsT0FBTyxDQUFDLENBQUM7SUFDVjtBQUNIO0FDZGM7O0lBQ04sU0FBYywrQ0FBUSxDQUFDLENBQUMsQ0FBQyxFQUF0QixPQUFPLFFBQWUsQ0FBQztJQUNoQyxJQUFNLE1BQU0sR0FBRyxrREFBVzs4Q0FBQztZQUN6QixPQUFPO3NEQUFDLFNBQUMsSUFBSSxFQUFLO29CQUFBLFdBQUksR0FBRyxDQUFDO2dCQUFBOztTQUMzQjs2Q0FBRSxFQUFFLENBQUMsQ0FBQztJQUNQLE9BQU8sTUFBTSxDQUFDO0FBQ2hCO0dBTndCLGNBQWM7QUNTdEMsSUFBSyxVQUFrQixDQUFDLG9CQUFvQixJQUFJLElBQUksRUFBRTtJQUNuRCxVQUFrQixDQUFDLG9CQUFvQixHQUFHLEdBQUcsQ0FBQztBQUNoRDtBQUVELElBQU0sbUJBQW1CLEdBQW1CLEVBQUUsQ0FBQztBQUMvQztJQUNFLGdDQUFvQixLQUFnQztRQUFwRCxJQUF3RDtRQUFwQyxJQUFLLFNBQUwsS0FBSyxDQUEyQjtRQUNwRCxJQUFHLE9BQUcsU0FBQyxHQUE4QjtZQUNuQyxLQUFJLENBQUMsS0FBSyxHQUFHLEdBQUcsQ0FBQztZQUNqQixtQkFBbUIsQ0FBQyxPQUFPLENBQUMsU0FBQyxDQUFDO2dCQUFLLFFBQUMsRUFBRTtZQUFBLEVBQUMsQ0FBQztRQUMxQyxDQUFDLENBQUM7UUFDRixJQUFHLE9BQUc7WUFBTSxZQUFJLENBQUMsS0FBSztRQUFBLEVBQUM7S0FMaUM7SUFNMUQsT0FBQztBQUFELENBQUM7QUFFRCxJQUFNLGVBQWUsR0FBRyxJQUFJLHNCQUFzQixDQUFDLElBQUksQ0FBQyxDQUFDO0FBRXpELFNBQVMsYUFBYTtJQUNwQixPQUFPLElBQUksZUFBZSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQy9ELENBQUM7QUFFRCxTQUFTLGdCQUFnQjtJQUN2QixJQUFNLE1BQU0sR0FBRyxhQUFhLEVBQUUsQ0FBQztJQUMvQixPQUFPLE1BQU0sQ0FDWCxNQUFNLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxFQUNwQiwwQ0FBMEMsQ0FDM0MsQ0FBQztBQUNKLENBQUM7QUFFRCxTQUFTLGFBQWE7SUFDcEIsSUFBTSxVQUFVLEdBQUcsYUFBYSxFQUFFLENBQUM7SUFDbkMsSUFBSSxVQUFVLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxFQUFFO1FBQ2hDLE9BQU8sVUFBVSxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsQ0FBQztJQUNyQztJQUNELElBQU0sU0FBUyxHQUFHLElBQUksR0FBRyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxZQUFZLENBQUM7SUFDdEQsT0FBTyxTQUFTLENBQUMsR0FBRyxDQUFDLGFBQWEsQ0FBQyxDQUFDO0FBQ3RDLENBQUM7QUFFRCxTQUFTLHNCQUFzQjtJQUM3QixJQUFNLE1BQU0sR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ2hELElBQU0sYUFBYSxHQUFHLGdCQUFnQixFQUFFLENBQUM7SUFDekMsSUFBTSxJQUFJLEdBQUcsYUFBYSxFQUFFLENBQUM7SUFDN0IsTUFBTSxDQUFDLEdBQUcsR0FBRyxVQUFHLGFBQWEsOEJBQzNCLElBQUksR0FBRyxXQUFJLElBQUksRUFBSyxTQUFHLEtBQUssQ0FDNUIsQ0FBQztJQUNILFFBQVEsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQ3BDLENBQUM7QUFFRCxJQUFJLFdBQVcsR0FBRyxDQUFDLENBQUM7QUFDZCxTQUFVLGtCQUFrQixDQUFDLElBQStCOzs7SUFHaEUsV0FBVyxFQUFFLENBQUM7SUFDZCxlQUFlLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQzVCLENBQUM7QUFRRDs7OztDQUlHLEdBQ1Usd0JBQW9CLGlCQUFHLGdEQUFtQixDQUVyRCxLQUFLLEVBQUU7QUFDSSw4QkFBMEI7O0lBQ3JDLG9EQUFnQixDQUFDLG9CQUFvQixDQUFDO0FBQXRDLEVBQXVDO0lBRDVCLHVCQUF1QjtBQUdwQzs7Ozs7OztJQUtFLElBQU0sZUFBZSxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDO0lBQ3hDLElBQU0sUUFBUSxHQUFHLENBQUMsRUFBQyxjQUFRLENBQUMsVUFBSSxvQ0FBRSxLQUFLLENBQUMsa0JBQWlCLENBQUM7SUFDMUQsSUFBTSxNQUFNLEdBQUcsQ0FBQyxFQUFDLGNBQVEsQ0FBQyxVQUFNLHlDQUFLLENBQUMsZ0JBQWUsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDO0lBQzNFLElBQU0sa0JBQWtCLEdBQ3RCLGVBQWUsSUFDZixDQUFDLFFBQVEsQ0FBQyxhQUFhLENBQUMscUJBQXFCLENBQUMsSUFDOUMsQ0FBQyxRQUFRLElBQ1QsQ0FBQyxNQUFNLENBQUM7SUFDVixJQUFNLFdBQVc7SUFDakIsa0RBQXFCOzhDQUFDO1lBQ3BCLG1CQUFtQixDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztZQUN0QztzREFBTztvQkFDTCxJQUFNLEtBQUssR0FBRyxtQkFBbUIsQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUM7b0JBQ3ZELElBQUksS0FBSyxJQUFJLENBQUMsRUFBRTt3QkFDZCxtQkFBbUIsQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDO29CQUN0QztnQkFDSCxDQUFDOztRQUNILENBQUM7NkNBQUU7UUFBQyxXQUFXO0tBQUMsQ0FBQyxDQUFDO0lBQ2xCLDRDQUFlO3dDQUFDO1lBQ2QsSUFBSSxrQkFBa0IsSUFBSSxlQUFlLElBQUksTUFBTSxDQUFDLE1BQU0sS0FBSyxNQUFNLEVBQUU7Z0JBQ3JFLHNCQUFzQixFQUFFLENBQUM7WUFDMUI7UUFDSCxDQUFDO3VDQUFFO1FBQUMsa0JBQWtCO1FBQUUsZUFBZTtLQUFDLENBQUMsQ0FBQztJQUMxQyw0Q0FBZTt3Q0FBQztZQUNkLElBQUksQ0FBQyxrQkFBa0IsSUFBSSxDQUFDLFFBQVEsQ0FBQyxhQUFhLENBQUMsVUFBVSxDQUFDLElBQUksTUFBTSxFQUFFO2dCQUN4RSxJQUFNLFNBQVMsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxDQUFDO2dCQUNuRCxTQUFTLENBQUMsRUFBRSxHQUFHLFNBQVMsQ0FBQztnQkFDekIsU0FBUyxDQUFDLEdBQUcsR0FBRyxnQkFBZ0IsRUFBRSxHQUFHLHVCQUF1QixDQUFDO2dCQUM3RCxTQUFTLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztnQkFDeEIsU0FBUyxDQUFDLE1BQU07b0RBQUc7O3lCQUNqQixNQUFDLFlBQWMsQ0FBQyw0QkFBc0IsNENBQUksQ0FBQztvQkFDN0MsQ0FBQzs7Z0JBQ0QsUUFBUSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUM7WUFDakM7UUFDSCxDQUFDO3VDQUFFO1FBQUMsa0JBQWtCO0tBQUMsQ0FBQyxDQUFDO0lBRW5CLE1BQThDLDhDQUFjOzJDQUFDO1lBQ2pFLCtCQUF3QixFQUFFO1FBQTFCLENBQTBCOzJDQURyQixrQkFBa0IsVUFBRSxxQkFBcUIsUUFFL0MsQ0FBQztJQUVGLDRDQUFlO3dDQUFDO1lBQ2QsSUFBSSxRQUFRLEVBQUU7Z0JBQ1osSUFBTSxVQUFROytEQUFHO3dCQUNmLHFCQUFxQixDQUFDLHdCQUF3QixFQUFFLENBQUMsQ0FBQztvQkFDcEQsQ0FBQzs7Z0JBQ0QsTUFBTSxDQUFDLGdCQUFnQixDQUFDLFlBQVksRUFBRSxVQUFRLENBQUMsQ0FBQztnQkFDaEQ7b0RBQU8sWUFBTTt3QkFBQSxhQUFNLENBQUMsbUJBQW1CLENBQUMsWUFBWSxFQUFFLFVBQVEsQ0FBQyxDQUFsRDtvQkFBQSxDQUFrRDs7WUFDaEU7WUFDRCxPQUFPLFNBQVMsQ0FBQztRQUNuQixDQUFDO3VDQUFFO1FBQUMsUUFBUTtLQUFDLENBQUMsQ0FBQztJQUNmLElBQUksQ0FBQyxlQUFlLEVBQUU7UUFDcEIsT0FBTyxJQUFJLENBQUM7SUFDYjtJQUNELElBQUksUUFBUSxJQUFJLE1BQU0sRUFBRTtRQUN0QixJQUFJLE1BQU0sR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLDhCQUE4QixDQUFDLENBQUM7UUFDcEUsSUFBSSxDQUFDLE1BQU0sRUFBRTtZQUNYLE1BQU0sR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ3ZDLE1BQU0sQ0FBQyxFQUFFLEdBQUcsYUFBYSxDQUFDO1lBQzFCLE1BQU0sQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLGlCQUFpQixDQUFDLENBQUM7WUFDeEMsUUFBUSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDL0I7UUFDRCxxQkFBTyxtREFBcUIsZUFDMUIsaURBQUMsYUFBYTtZQUFDLEdBQUcsRUFBRSxFQUFHLG1CQUFXLENBQUU7UUFBQSxpQkFDbEMsaURBQUMsb0JBQW9CLENBQUMsUUFBUTtZQUFDLEtBQUssRUFBRSxrQkFBa0I7UUFBQSxDQUNyRCxpQkFBZSxDQUFDLEdBQUcsRUFBRSxDQUNRLENBQ2xCLEVBQ2hCLE1BQU0sRUFDTixhQUFhLENBQ2QsQ0FBQztJQUNIO0lBQ0QsSUFBSSxrQkFBa0IsSUFBSSxNQUFNLENBQUMsTUFBTSxLQUFLLE1BQU0sRUFBRTtRQUNsRCxxQkFDRTtZQUNFLEdBQUcsRUFBRSx5RUFBa0Usa0JBQWtCLENBQ3ZGLFFBQVEsQ0FBQyxJQUFJLENBQ2QsQ0FBRTtZQUNILEtBQUssRUFBRTtnQkFDTCxLQUFLLEVBQUUsT0FBTztnQkFDZCxNQUFNLEVBQUUsT0FBTztnQkFDZixNQUFNLEVBQUUsTUFBTTtnQkFDZCxRQUFRLEVBQUUsT0FBTztnQkFDakIsR0FBRyxFQUFFLENBQUM7Z0JBQ04sSUFBSSxFQUFFLENBQUM7Z0JBQ1AsTUFBTSxFQUFFLFFBQVE7WUFDakI7UUFBQSxFQUNPO0lBRWI7SUFDRCxPQUFPLElBQUksQ0FBQztBQUNkLENBQUM7SUEvRlEsa0JBQWtCOztRQWFMLGNBQWM7OztBQXVHN0Isd0JBRUgsU0FBQyxLQUFLOztJQUNBLG9CQUFnQixHQUFLLEtBQUssaUJBQVYsQ0FBVztJQUM3QixNQUFrQiw4Q0FBYyxDQUNwQyxJQUFJLENBQ0wsRUFGTSxJQUFJLFVBQUUsT0FBTyxRQUVuQixDQUFDO0lBQ0YsNENBQWU7dUNBQUM7WUFDZCxPQUFPLGVBQUMsaURBQUMsa0JBQWtCLE9BQUcsQ0FBQyxDQUFDO1NBQ2pDO3NDQUFFLEVBQUUsQ0FBQyxDQUFDO0lBQ1AscUJBQ0Usb0dBQ0csQ0FBQyxnQkFBZ0Isa0JBQUksZ0RBQUMsa0JBQWlCLEVBQUcsT0FDMUMsSUFBSSxDQUNKO0FBRVAsRUFBRTs7S0FoQlcsaUJBQWlCO0FBbUI5QixJQUFNLG9CQUFvQixHQUEwQixFQUFFLENBQUM7QUFDakQsU0FBVSwyQkFBMkIsQ0FBQyxRQUE2QjtJQUN2RSxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDcEMsT0FBTztRQUNMLElBQU0sS0FBSyxHQUFHLG9CQUFvQixDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUNyRCxJQUFJLEtBQUssSUFBSSxDQUFDLEVBQUU7WUFDZCxvQkFBb0IsQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ3ZDO0lBQ0gsQ0FBQyxDQUFDO0FBQ0osQ0FBQztBQVVEO0lBQTRCLFNBRzNCO0lBQ0MsdUJBQVksS0FBeUI7UUFBckMsSUFDRSwwQkFBTSxLQUFLLENBQUMsSUFFYjtRQURDLEtBQUksQ0FBQyxLQUFLLEdBQUcsRUFBRSxDQUFDOztLQUNqQjtJQUVNLGFBQXdCLDRCQUEvQixTQUFnQyxLQUFZO1FBQzFDLE9BQU87WUFBRSxLQUFLO1FBQUEsQ0FBRSxDQUFDO0tBQ2xCO0lBRUQsYUFBaUIsK0JBQWpCLFNBQWtCLEtBQVk7UUFDNUIsb0JBQW9CLENBQUMsT0FBTyxDQUFDLFNBQUMsUUFBUSxFQUFLO1lBQUEsZUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFmO1FBQUEsQ0FBZSxDQUFDLENBQUM7S0FDN0Q7SUFFRCw4QkFBTSxHQUFOO1FBQ0UsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRTtZQUNwQixxQkFBTyx5RUFBYSxFQUFHLFlBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBRSxDQUFPLENBQUM7UUFDMUQsT0FBTTtZQUNMLHFCQUFPLG9HQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFJLENBQUM7UUFDbkM7S0FDRjtJQUNILE9BQUM7QUFBRCxDQUFDLENBeEIyQiw0Q0FBZSxDQXdCMUM7QUFFRCxTQUFTLGlCQUFpQjtJQUN4QixJQUFJLEtBQXFDLEVBQUUsRUFFMUM7SUFDRCxxQkFDRSxnREFDRTtRQUFBLElBQUksRUFBQyxpQkFBaUI7UUFDdEIsdUJBQXVCLEVBQUU7WUFDdkIsTUFBTSxFQUFFLGdnQkFjVDtRQUNBO0lBQUEsRUFDTztBQUVkLENBQUM7O0FBRUQsU0FBUyx3QkFBd0I7O0lBQy9CLElBQU0sSUFBSSxHQUFHLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDO0lBQ2xDLElBQUksSUFBSSxJQUFJLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFOztRQUUzQixJQUFNLE1BQU0sR0FBRyxJQUFJLGVBQWUsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDdEQsSUFBSSxNQUFNLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxLQUFLLE1BQU0sRUFBRTtZQUNuQyxJQUFNLGNBQWMsR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLGdCQUFnQixDQUFDLENBQUM7WUFDcEQsT0FBTztnQkFDTCxhQUFhLEVBQUUsWUFBTSxDQUFDLEdBQUcsQ0FBQyxnQkFBZSxDQUFDLGtDQUFJLElBQUk7Z0JBQ2xELGNBQWMsRUFBRSxjQUFjLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxjQUFjLENBQUMsR0FBRyxFQUFFO2dCQUNoRSxXQUFXLEVBQUUsTUFBTSxDQUFDLEdBQUcsQ0FBQyxhQUFhLENBQUMsS0FBSyxNQUFNO2FBQ2xELENBQUM7UUFDSDtJQUNGO0lBQ0QsT0FBTyxLQUFLLENBQUM7QUFDZixDQUFDO0FBRUQsSUFBTSxpQ0FBaUMsR0FBRyw0QkFBNEIsQ0FBQztBQUVqRSx1Q0FBd0MsS0FBVTs7SUFDdEQsT0FBTywwQ0FBYTtpREFBQzs7Ozs7OztZQU9uQixJQUFNLGFBQWEsR0FBRyxLQUFLLEtBQUwsYUFBSyx1QkFBTCxLQUFLLENBQUcsaUNBQWlDLENBQUMsQ0FBQztZQUNqRSxJQUFJLGFBQWEsRUFBRTtnQkFDakIsT0FBTztvQkFDTCxVQUFVLEVBQUUsYUFBYSxDQUFDLFVBQXFCO29CQUMvQyxnQkFBZ0IsRUFBRSxhQUFhLENBQUMsZ0JBQXNDO2lCQUN2RSxDQUFDO1lBQ0g7WUFDRCxPQUFPLElBQUksQ0FBQztRQUNkLENBQUM7Z0RBQUU7UUFBQyxLQUFLO0tBQUMsQ0FBQyxDQUFDO0FBQ2Q7SUFqQmdCLDZCQUE2QjtBQ3RUdEMsSUFBTSxLQUFLLEdBQUc7SUFBa0IsSUFBVTtRQUFWLElBQVUsUUFBVixFQUFVLHFCQUFWLEVBQVU7UUFBVixJQUFVOztJQUFRLFdBQUk7QUFBSixDQUFJO0lDVWhELFdBQVcsaUJBQUcsb0RBQWEsQ0FBdUIsU0FBUyxFQUFFO0FBUXBFLFNBQVUsVUFBVSxDQUFDLElBQVk7SUFDckMsT0FBTyx5QkFBa0IsSUFBSSxDQUFFLENBQUM7QUFDbEMsQ0FBQztBQUVLLFNBQVUsV0FBVyxDQUFDLElBQXVCO0lBQ2pELE9BQU8sSUFBSSxDQUFDO0FBQ2QsQ0FBQztBQUVlLHNCQUFhLENBQzNCLE9BQTZCLEVBQzdCLFFBQTRCO0lBRTVCLElBQUksQ0FBQyxRQUFRLEVBQUU7UUFDYixPQUFPLFNBQVMsQ0FBQztJQUNsQjtJQUNELElBQUksT0FBTyxHQUFHLE9BQU8sQ0FBQztJQUN0QixJQUFrQixJQUFtQixRQUFuQixhQUFRLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFuQixFQUFtQixjQUFuQixJQUFtQixDQUFFO1FBQWxDLElBQU0sR0FBRztRQUNaLE9BQU8sR0FBRyxPQUFPLEtBQVAsZUFBTyx1QkFBUCxPQUFPLENBQUcsR0FBRyxDQUFDLENBQUM7SUFDMUI7SUFDRCxPQUFPLE9BQU8sQ0FBQztBQUNqQixDQUFDO0FBSUssU0FBVSxXQUFXLENBQUMsUUFBNEI7O0lBQ3RELElBQU0sT0FBTztJQUNiLE9BQU8sYUFBYSxDQUFDLE9BQU8sRUFBRSxRQUFRLENBQUMsQ0FBQztBQUMxQyxDQUFDOzs7UUFGaUIsVUFBVTs7O0FBSXRCLHNCQUF1QixTQUE0Qjs7SUFBNUI7UUFBQSxTQUE0QjtJQUFBO0lBQ3ZELElBQU0sT0FBTztJQUNiLE9BQU8sTUFBTSxDQUFDLFdBQVcsQ0FDdkIsTUFBTSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FDdEIsTUFBTSxDQUFDLFNBQUMsRUFBZTtZQUFkLEdBQUcsVUFBRSxRQUFRO1FBQU0sUUFBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsUUFBUTtJQUFuQixDQUFtQixDQUFDLENBQ2hELEdBQUcsQ0FBQyxTQUFDLEVBQWU7WUFBZCxHQUFHLFVBQUUsUUFBUTtRQUFNLFlBQUssQ0FBQyxHQUFHLEVBQUUsYUFBYSxDQUFDLE9BQU8sRUFBRSxRQUFRLENBQUMsQ0FBQztLQUFBLENBQUMsQ0FDMUUsQ0FBQztBQUNKLENBQUM7SUFQZSxZQUFZOztRQUNWLFVBQVU7Ozs7O0lBUzFCLE9BQU8saURBQVUsQ0FBQyxXQUFXLENBQUMsQ0FBQztBQUNqQyxDQUFDO0lBRmUsVUFBVTtBQTRCcEIsc0JBQXVCLEVBT1Q7Ozs7SUFObEIsUUFBSSxZQUNKLElBQUksWUFDSixNQUFNLGNBQ04sUUFBUSxnQkFDUixLQUFLLGFBQ0wsUUFBUTtJQUVSLElBQU0sV0FBVyxHQUFHLGtCQUFVLENBQUUsa0NBQUksRUFBRSxDQUFDO0lBQ3ZDLElBQUksQ0FBQyxJQUFJLEVBQUU7UUFDVCxxQkFBT0EsMERBQUEsQ0FBQUEsdURBQUEsUUFBRyxRQUFRLENBQUksQ0FBQztJQUN4QixPQUFNO1FBQ0wscUJBQ0VBLDBEQUFDLFlBQVcsQ0FBQyxRQUFRO1lBQ25CLEtBQUssd0JBQ0EsV0FBVyxnQkFDYixJQUFJLENBQUcsT0FBSSxFQUNYLGFBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBRyxjQUFXLENBQUM7Z0JBQUUsTUFBTTtnQkFBRSxRQUFRO2dCQUFFLEtBQUs7WUFBQSxDQUFFLENBQUM7UUFBQSxHQUc3RCxRQUFRLENBQ1k7SUFFMUI7QUFDSCxDQUFDOzs7UUFoQnFCLFVBQVU7OztNQVJoQixZQUFZO0FBMEI1Qjs7Q0FFRyxHQUNILFNBQVMsaUJBQWlCLENBQ3hCLE1BQXFEO0lBRXJELElBQU0sU0FBUyxHQUFzQyxFQUFFLENBQUM7SUFDeEQsSUFBMkIsSUFBc0IsUUFBdEIsV0FBTSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsRUFBdEIsRUFBc0IsY0FBdEIsSUFBc0IsQ0FBRTtRQUF4QyxlQUFZLEVBQVgsR0FBRyxVQUFFLEtBQUs7UUFDcEIsSUFBSSxDQUFDLEtBQUssRUFBRTtZQUNWLFNBQVM7UUFDVjtRQUNELElBQUksR0FBRyxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUN6QixTQUFTLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUNyQixPQUFPLEtBQUssS0FBSyxRQUFRLEdBQ3JCLEtBQUssQ0FBQyxPQUFPLENBQUMsVUFBVSxFQUFFLEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FDeEMsS0FBSyxDQUFDO1FBQ2IsT0FBTTtZQUNMLFNBQVMsQ0FBQyxHQUFHLENBQUMsR0FBRyxLQUFLLENBQUM7UUFDeEI7SUFDRjtJQUNELE9BQU8sU0FBUyxDQUFDO0FBQ25CLENBQUM7QUFFRCxTQUFTLHdCQUF3QixDQUMvQixLQUFhLEVBQ2IsTUFBcUQ7SUFFckQsSUFBSSxDQUFDLE1BQU0sRUFBRTtRQUNYLE9BQU8sS0FBSyxDQUFDO0lBQ2Q7SUFDRCxJQUFJLElBQUksR0FBRyxLQUFLLENBQUM7SUFDakIsSUFBMkIsSUFBc0IsUUFBdEIsV0FBTSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsRUFBdEIsRUFBc0IsY0FBdEIsSUFBc0IsQ0FBRTtRQUF4QyxlQUFZLEVBQVgsR0FBRyxVQUFFLEtBQUs7UUFDcEIsSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLEVBQUU7WUFDN0IsSUFBSSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBSSxXQUFHLEVBQUcsTUFBRSxLQUFLLENBQUMsQ0FBQztRQUN4QyxPQUFNLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUMvQixJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsZUFBUSxHQUFHLE9BQUksQ0FBQyxFQUFFO2dCQUNsQyxJQUFJLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxlQUFRLEdBQUcsT0FBSSxFQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUN2RCxPQUFNLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxjQUFPLEdBQUcsTUFBRyxDQUFDLEVBQUU7Z0JBQ3ZDLElBQUksR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLGNBQU8sR0FBRyxNQUFHLEVBQUUsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQ3JEO1FBQ0Y7SUFDRjtJQUNELE9BQU8sSUFBSSxDQUFDO0FBQ2QsQ0FBQztBQTBCSyw0QkFBNkIsRUFNVDs7UUFMeEIsUUFBUSxnQkFDUixLQUFLLGFBQ0MsZUFBZSxZQUNyQixFQUFXLGNBQVgsTUFBTSxHQUFHLGtCQUFFLE9BQ1gsYUFBVSxFQUFWLEtBQUssbUJBQUcsRUFBRTtJQUVWLEtBQUssR0FBRyxLQUFLLEtBQUwsYUFBSyxjQUFMLEtBQUssR0FBSSxlQUFlLENBQUM7SUFDakMsTUFBTSxHQUFHLGlCQUFpQixDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ25DLElBQU0sSUFBSSxtQkFBbUIsRUFBRSxDQUFDO0lBQ2hDLElBQU0sSUFBSSxHQUFHLEtBQUssR0FBRyx3QkFBd0IsQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLEdBQUcsU0FBUyxDQUFDO0lBQ3pFLHFCQUNFQSwwREFBQyxhQUFZO1FBQ1gsSUFBSSxFQUFFLFdBQVc7UUFDakIsSUFBSSxFQUFFLEtBQUs7UUFDWCxLQUFLLEVBQUUsWUFBWTtRQUNuQixRQUFRLEVBQUUsSUFBSTtJQUFBLGlCQUVkQSwwREFBQSxDQUFDLFlBQVk7UUFBQyxJQUFJLEVBQUUsVUFBVTtRQUFFLElBQUksRUFBRSxJQUFJO1FBQUUsS0FBSyxFQUFFLFdBQVc7SUFBQSxpQkFDNURBLDBEQUFBLENBQUMsWUFBWSxFQUNYO1FBQUEsSUFBSSxFQUFFLFFBQVE7UUFDZCxJQUFJLHdCQUFPLElBQUksQ0FBQyxNQUFNLENBQUssUUFBTSxDQUNqQztRQUFBLEtBQUssRUFBRSxzQkFBc0I7SUFBQSxpQkFFN0JBLDBEQUFDLGFBQVksRUFDWDtRQUFBLElBQUksRUFBRSxPQUFPO1FBQ2IsSUFBSSx3QkFBTyxJQUFJLENBQUMsS0FBSyxHQUFLLEtBQUssQ0FDL0I7UUFBQSxLQUFLLEVBQUUsdUJBQXVCO0lBQUEsQ0FFN0IsVUFBUSxDQUNJLENBQ0YsQ0FDRixDQUNGO0FBRW5CLENBQUM7OztRQTFCYyxVQUFVOzs7TUFUVCxrQkFBa0I7QUFxQzVCLHVCQUF3QixFQUk3Qjs7SUFIQyxZQUFRO0lBSVIsSUFBTSxJQUFJLEdBQUcsVUFBVSxFQUFFLENBQUM7SUFDMUIsT0FBTyxRQUFRLENBQUMsSUFBSSxDQUF3QixDQUFDO0FBQy9DOzs7Ozs7TUFQZ0IsYUFBYTtBQ3RON0IsSUFBTUMsTUFBSSxHQUFHLFVBQWlCLENBQUM7QUF5Qy9CQSxNQUFJLENBQUMsd0JBQXdCLEdBQUcsRUFBRSxDQUFDO0FBRW5CLHdCQUFlLENBQUMsT0FBZ0IsRUFBRSxJQUFpQjtJQUNqRUEsTUFBSSxDQUFDLHdCQUF3QixDQUFDLElBQUksQ0FBQztRQUFFLE9BQU87UUFBRSxJQUFJO0lBQUEsQ0FBRSxDQUFDLENBQUM7QUFDeEQ7QUMzQ2Esd0JBQW9CLGlCQUFHRCwwREFBbUIsQ0FFckQsU0FBUyxFQUFFO0FBRVAsK0JBQWdDLEtBSXJDOztJQUNTLGVBQVcsR0FBd0IsS0FBSyxZQUE3QixFQUFFLFFBQVEsR0FBYyxLQUFLLFNBQW5CLEVBQUUsT0FBTyxHQUFLLEtBQUssUUFBVixDQUFXO0lBQ2pELElBQU0sZUFBZTtJQUNyQixJQUFNLGlCQUFpQixHQUFHQSxvREFBYTs0REFDckM7WUFDRSxhQUFNLENBQUMsV0FBVyxDQUNoQixNQUFNLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUc7b0VBQUMsU0FBQyxFQUFVO3dCQUFULEdBQUcsVUFBRSxHQUFHO29CQUFNO3dCQUMxQyxFQUFHLG1CQUFXLEVBQUksZUFBRyxDQUFFO3dCQUN2QixHQUFHO3FCQUNKO2dCQUgyQyxDQUczQzs7UUFKSCxDQUtDOzJEQUNIO1FBQUMsV0FBVztRQUFFLE9BQU87S0FBQyxDQUN2QixDQUFDO0lBQ0YscUJBQ0VBLDBEQUFBLENBQUMsb0JBQW9CLENBQUMsUUFBUSxFQUM1QjtRQUFBLEtBQUssRUFDQSxxQ0FBZSxHQUNmLGlCQUFpQjtJQUFBLEdBR3JCLFFBQVEsQ0FDcUI7QUFFcEMsQ0FBQzs7O1FBckJ5QixnQkFBZ0I7OztNQU4xQixxQkFBcUI7Ozs7SUE4Qm5DLE9BQU8sTUFBQUEsdURBQWdCLENBQUMscUJBQW9CLENBQUMsS0FBSSwrQkFBRSxDQUFDO0FBQ3REO0tBRmdCLGdCQUFnQjtBQ25DaEMsSUFBTSxrQkFBa0IsaUJBQUdBLDBEQUFtQixDQUU1QyxTQUFTLENBQUMsQ0FBQzs7O0lBS1gsT0FBT0EsdURBQWdCLENBQUMsa0JBQWtCLENBQUMsQ0FBQztBQUM5QyxDQUFDO0tBSmUsbUJBQW1CO0FBTW5DLElBQU0sVUFBVSxpQkFBR0EsdURBQWdCLE9BQUMsU0FBUyxVQUFVLENBQ3JELEtBQWdDLEVBQ2hDLEdBQWlDO0lBRWpDLHFCQUFPQSwwREFBQUEsQ0FBQUEsS0FBQUEsU0FBQUEsQ0FBQUEsR0FBTyxLQUFLO1FBQUUsR0FBRyxFQUFFLEdBQUc7SUFBQSxHQUFJLENBQUM7QUFDcEMsQ0FBQyxDQUFDLENBQUM7Ozs7SUFLRCxJQUFNLElBQUksR0FBR0EsdURBQWdCLENBQUMsa0JBQWtCLENBQUMsQ0FBQztJQUNsRCxJQUFJLElBQUksRUFBRTtRQUNSLE9BQU8sSUFBSSxDQUFDO0lBQ2IsT0FBTTtRQUNMLE9BQU8sVUFBNEQsQ0FBQztJQUNyRTtBQUNILENBQUM7S0FUZSxjQUFjO0FBV3hCLFNBQVUsbUJBQW1CLENBQUMsS0FHbkM7SUFDUyxRQUFJLEdBQWUsS0FBSyxLQUFwQixFQUFFLFFBQVEsR0FBSyxLQUFLLFNBQVYsQ0FBVztJQUNqQyxxQkFDRUEsMERBQUEsQ0FBQyxrQkFBa0IsQ0FBQyxRQUFRO1FBQUMsS0FBSyxFQUFFLElBQUk7SUFBQSxHQUNyQyxRQUFRLENBQ21CO0FBRWxDOztBQzVCQSxJQUFNQyxNQUFJLEdBQUcsVUFBaUIsQ0FBQztBQTBIL0I7QUFDQTtBQUNhLG9CQUFnQixHQUE2QztJQUN4RSxVQUFVO0lBQ1YscUJBQXFCO0lBQ3JCLFVBQVU7RUFDVjtBQXdQRixJQUFJQSxNQUFJLENBQUMsMEJBQTBCLElBQUksSUFBSSxFQUFFO0lBQzNDQSxNQUFJLENBQUMsMEJBQTBCLEdBQUcsRUFBRSxDQUFDO0FBQ3RDO0FBRWEsU0FBVSxpQkFBaUIsQ0FDdkMsU0FBWSxFQUNaLElBQWdEOztJQUdoRCxJQUNFQSxNQUFJLENBQUMsMEJBQTBCLENBQUMsSUFBSSxDQUNsQyxTQUFDLENBQXdCO1FBQ3ZCLFFBQUMsQ0FBQyxTQUFTLEtBQUssU0FBUyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxLQUFLLElBQUksQ0FBQyxJQUFJO0lBQXRELENBQXNELENBQ3pELEVBQ0Q7UUFDQSxPQUFPO0lBQ1I7SUFDREEsTUFBSSxDQUFDLDBCQUEwQixDQUFDLElBQUksQ0FBQztRQUFFLFNBQVM7UUFBRSxJQUFJO0lBQUEsQ0FBRSxDQUFDLENBQUM7QUFDNUQ7QUN0WkEsSUFBTUEsTUFBSSxHQUFHLFVBQWlCLENBQUM7QUF1Sy9CLElBQUlBLE1BQUksQ0FBQywwQkFBMEIsSUFBSSxJQUFJLEVBQUU7SUFDM0NBLE1BQUksQ0FBQywwQkFBMEIsR0FBRyxFQUFFLENBQUM7QUFDdEM7QUFFYSxTQUFVLGdCQUFnQixDQUN0QyxFQUFLLEVBQ0wsSUFBMkI7O0lBRzNCLElBQ0VBLE1BQUksQ0FBQywwQkFBMEIsQ0FBQyxJQUFJLENBQ2xDLFNBQUMsQ0FBNkI7UUFDNUIsUUFBQyxDQUFDLFFBQVEsS0FBSyxFQUFFLElBQ2pCLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxLQUFLLElBQUksQ0FBQyxJQUFJLElBQ3pCLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxJQUFJLElBQUksQ0FBQyxTQUFTO0lBRmxDLENBRWtDLENBQ3JDLEVBQ0Q7UUFDQSxPQUFPO0lBQ1I7SUFDREEsTUFBSSxDQUFDLDBCQUEwQixDQUFDLElBQUksQ0FBQztRQUFFLFFBQVEsRUFBRSxFQUFFO1FBQUUsSUFBSTtJQUFBLENBQUUsQ0FBQyxDQUFDO0FBQy9EO0FDaExBLElBQU1BLE1BQUksR0FBRyxVQUFpQixDQUFDO0FBNkYvQixJQUFJQSxNQUFJLENBQUMsd0JBQXdCLElBQUksSUFBSSxFQUFFO0lBQ3pDQSxNQUFJLENBQUMsd0JBQXdCLEdBQUcsRUFBRSxDQUFDO0FBQ3BDO0FBRWEsU0FBVSxxQkFBcUIsQ0FFM0MsU0FBWSxFQUFFLElBQWdEOztJQUU5RCxJQUNFQSxNQUFJLENBQUMsd0JBQXdCLENBQUMsSUFBSSxDQUNoQyxTQUFDLENBQTRCO1FBQzNCLFFBQUMsQ0FBQyxTQUFTLEtBQUssU0FBUyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxLQUFLLElBQUksQ0FBQyxJQUFJO0lBQXRELENBQXNELENBQ3pELEVBQ0Q7UUFDQSxPQUFPO0lBQ1I7SUFDREEsTUFBSSxDQUFDLHdCQUF3QixDQUFDLElBQUksQ0FBQztRQUFFLFNBQVM7UUFBRSxJQUFJO0lBQUEsQ0FBRSxDQUFDLENBQUM7QUFDMUQ7QUMvRUEsSUFBTUEsTUFBSSxHQUFHLFVBQWlCLENBQUM7QUFFL0IsSUFBSUEsTUFBSSxDQUFDLHNCQUFzQixJQUFJLElBQUksRUFBRTtJQUN2Q0EsTUFBSSxDQUFDLHNCQUFzQixHQUFHLEVBQUUsQ0FBQztBQUNsQztBQUV1QixzQkFBYSxDQUFDLEtBQXdCO0lBQzVEQSxNQUFJLENBQUMsc0JBQXNCLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQzFDO0FDbERBLElBQU1BLE1BQUksR0FBRyxVQUFpQixDQUFDO0FBMEIvQixJQUFJQSxNQUFJLENBQUMsc0JBQXNCLElBQUksSUFBSSxFQUFFO0lBQ3ZDQSxNQUFJLENBQUMsc0JBQXNCLEdBQUcsRUFBRSxDQUFDO0FBQ2xDO0FBRWEsU0FBVSxhQUFhLENBQUMsS0FBYSxFQUFFLElBQWU7SUFDbEVBLE1BQUksQ0FBQyxzQkFBc0IsQ0FBQyxJQUFJLENBQUM7UUFDL0IsS0FBSztRQUNMLElBQUk7SUFDTCxFQUFDLENBQUM7QUFDTDs7QUNuQmMsU0FBVSxlQUFlLENBQUksS0FBdUIsRUFBRSxHQUFNO0lBQ3hFLE9BQU8saUJBQWlCLENBQUMsS0FBWSxFQUFFLEdBQUcsQ0FBQyxDQUFDO0FBQzlDLENBQUM7QUFFRCxJQUFJLGlCQUFpQixHQUEyQixTQUM5QyxLQUF1QixFQUN2QixHQUFRO0lBRVIsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxFQUFFO1FBQ3RCLE9BQU8sR0FBRyxDQUFDLEdBQUcsQ0FBQyxTQUFDLENBQUMsRUFBSztZQUFBLHdCQUFpQixDQUFDLEtBQVksRUFBRSxDQUFDLENBQUMsQ0FBbEM7UUFBQSxDQUFrQyxDQUFRLENBQUM7SUFDbEU7SUFDRCxJQUFJLEdBQUcsa0JBQUkscURBQWMsQ0FBQyxHQUFHLENBQUMsSUFBSSxPQUFPLEdBQUcsS0FBSyxRQUFRLEVBQUU7UUFDekQscUJBQU8sbURBQVksQ0FBQyxHQUFHLENBQVEsQ0FBQztJQUNqQztJQUNELE9BQU8sR0FBRyxDQUFDO0FBQ2IsQ0FBQyxDQUFDO0FBRUYsSUFBTUEsTUFBSSxHQUFHLFVBQWlCLENBQUM7QUFDeEIsSUFBTSxvQkFBb0IsR0FDL0IsY0FBQUEsTUFBSSxhQUFKQSxNQUFJLHVCQUFKQSxNQUFJLENBQUUsV0FBSyx3Q0FBRSwwQkFBb0IsNkJBQ2pDLFNBQVUsRUFBMEI7SUFDbEMsaUJBQWlCLEdBQUcsRUFBRSxDQUFDO0FBQ3pCLENBQUM7QUN0QlUsNEJBQXdCLGlCQUFHRCwwREFBbUIsQ0FFekQsU0FBUyxFQUFFOzs7SUFHWCxJQUFNLEVBQUUsR0FBR0EsdURBQWdCLENBQUMsd0JBQXdCLENBQUMsQ0FBQztJQUN0RCxJQUFNLFVBQVUsR0FBRyxFQUFFLEdBQ2pCLE9BQU8sRUFBRSxLQUFLLFVBQVUsR0FDdEIsRUFBRSxHQUNGLEVBQUUsQ0FBQyxVQUFVLEdBQ2YsU0FBUyxDQUFDO0lBQ2QsT0FBTyxVQUFVLENBQUM7QUFDcEI7S0FSZ0Isb0JBQW9COzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcEI3QixJQUFNLFdBQVcsR0FBRyxTQUFTOztBQ1lwQyxJQUFNLElBQUksR0FBRyxVQUFpQixDQUFDO0FBRS9CLElBQUksSUFBSSxDQUFDLEtBQUssSUFBSSxJQUFJLEVBQUU7Ozs7OztJQU10QixJQUFJLENBQUMsS0FBSztRQUNSLEtBQUs7UUFDTCxRQUFRO1FBQ1IsWUFBWTtRQUNaLFVBQVU7UUFDVixXQUFXO1FBQ1gsU0FBUyxFQUFFO1lBQ1Qsa0JBQWtCO1lBQ2xCLDJCQUEyQjtZQUMzQixvQkFBb0I7UUFDckI7O1FBR0Qsa0JBQWtCO1FBQ2xCLDJCQUEyQjtRQUMzQixvQkFBb0I7SUFBQSxHQUNqQixVQUFVLENBQ2QsQ0FBQztBQUNILE9BQU07SUFDTCxPQUFPLENBQUMsSUFBSSxDQUNWLHFEQUE4QyxJQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsaUJBQU8sV0FBVyxDQUFFLENBQ3pGLENBQUM7SUFDRixJQUFJLENBQUMsS0FBSyxDQUFDLHFCQUFxQixHQUFHLFVBQUksQ0FBQyxLQUFLLENBQUMsMkJBQXFCLDZCQUFJLEVBQUUsQ0FBQztJQUMxRSxJQUFJLENBQUMsS0FBSyxDQUFDLHFCQUFxQixDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztBQUNwRCIsInNvdXJjZXMiOlsiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvc3JjL2xhbmctdXRpbHMudHMiLCIvVXNlcnMvd29uZGVybGFuZG1pdGNoL0Nhc2NhZGVQcm9qZWN0cy9zcmMvdXNlRm9yY2VVcGRhdGUudHMiLCIvVXNlcnMvd29uZGVybGFuZG1pdGNoL0Nhc2NhZGVQcm9qZWN0cy9zcmMvY2FudmFzLWhvc3QudHN4IiwiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvc3JjL2NvbW1vbi50cyIsIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL3NyYy9kYXRhLnRzeCIsIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL3NyYy9mZXRjaGVyLnRzIiwiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvc3JjL2dsb2JhbC1hY3Rpb25zLnRzeCIsIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL3NyYy9saW5rLnRzeCIsIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL3NyYy9yZWdpc3RlckNvbXBvbmVudC50cyIsIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL3NyYy9yZWdpc3RlckZ1bmN0aW9uLnRzIiwiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvc3JjL3JlZ2lzdGVyR2xvYmFsQ29udGV4dC50cyIsIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL3NyYy9yZWdpc3RlclRva2VuLnRzIiwiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvc3JjL3JlZ2lzdGVyVHJhaXQudHMiLCIvVXNlcnMvd29uZGVybGFuZG1pdGNoL0Nhc2NhZGVQcm9qZWN0cy9zcmMvcmVwZWF0ZWRFbGVtZW50LnRzIiwiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvc3JjL3RyYW5zbGF0aW9uLnRzeCIsIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL3NyYy92ZXJzaW9uLnRzIiwiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvc3JjL2luZGV4LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGlzU3RyaW5nKHg6IGFueSk6IHggaXMgc3RyaW5nIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSBcInN0cmluZ1wiO1xufVxuXG50eXBlIFN0cmluZ0dlbiA9IHN0cmluZyB8ICgoKSA9PiBzdHJpbmcpO1xuXG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlPFQ+KHg6IFQgfCBudWxsIHwgdW5kZWZpbmVkLCBtc2c6IFN0cmluZ0dlbiA9IFwiXCIpOiBUIHtcbiAgaWYgKHggPT09IG51bGwgfHwgeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZGVidWdnZXI7XG4gICAgbXNnID0gKGlzU3RyaW5nKG1zZykgPyBtc2cgOiBtc2coKSkgfHwgXCJcIjtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgVmFsdWUgbXVzdCBub3QgYmUgdW5kZWZpbmVkIG9yIG51bGwke21zZyA/IGAtICR7bXNnfWAgOiBcIlwifWBcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB4O1xuICB9XG59XG4iLCJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXNlRm9yY2VVcGRhdGUoKSB7XG4gIGNvbnN0IFssIHNldFRpY2tdID0gdXNlU3RhdGUoMCk7XG4gIGNvbnN0IHVwZGF0ZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBzZXRUaWNrKCh0aWNrKSA9PiB0aWNrICsgMSk7XG4gIH0sIFtdKTtcbiAgcmV0dXJuIHVwZGF0ZTtcbn1cbiIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0ICogYXMgUmVhY3RET00gZnJvbSBcInJlYWN0LWRvbVwiO1xuaW1wb3J0IHsgZW5zdXJlIH0gZnJvbSBcIi4vbGFuZy11dGlsc1wiO1xuaW1wb3J0IHVzZUZvcmNlVXBkYXRlIGZyb20gXCIuL3VzZUZvcmNlVXBkYXRlXCI7XG5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgaW50ZXJmYWNlIFdpbmRvdyB7XG4gICAgX19QbGFzbWljSG9zdFZlcnNpb246IHN0cmluZztcbiAgfVxufVxuXG5pZiAoKGdsb2JhbFRoaXMgYXMgYW55KS5fX1BsYXNtaWNIb3N0VmVyc2lvbiA9PSBudWxsKSB7XG4gIChnbG9iYWxUaGlzIGFzIGFueSkuX19QbGFzbWljSG9zdFZlcnNpb24gPSBcIjNcIjtcbn1cblxuY29uc3Qgcm9vdENoYW5nZUxpc3RlbmVyczogKCgpID0+IHZvaWQpW10gPSBbXTtcbmNsYXNzIFBsYXNtaWNSb290Tm9kZVdyYXBwZXIge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHZhbHVlOiBudWxsIHwgUmVhY3QuUmVhY3RFbGVtZW50KSB7fVxuICBzZXQgPSAodmFsOiBudWxsIHwgUmVhY3QuUmVhY3RFbGVtZW50KSA9PiB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbDtcbiAgICByb290Q2hhbmdlTGlzdGVuZXJzLmZvckVhY2goKGYpID0+IGYoKSk7XG4gIH07XG4gIGdldCA9ICgpID0+IHRoaXMudmFsdWU7XG59XG5cbmNvbnN0IHBsYXNtaWNSb290Tm9kZSA9IG5ldyBQbGFzbWljUm9vdE5vZGVXcmFwcGVyKG51bGwpO1xuXG5mdW5jdGlvbiBnZXRIYXNoUGFyYW1zKCkge1xuICByZXR1cm4gbmV3IFVSTFNlYXJjaFBhcmFtcyhsb2NhdGlvbi5oYXNoLnJlcGxhY2UoL14jLywgXCI/XCIpKTtcbn1cblxuZnVuY3Rpb24gZ2V0UGxhc21pY09yaWdpbigpIHtcbiAgY29uc3QgcGFyYW1zID0gZ2V0SGFzaFBhcmFtcygpO1xuICByZXR1cm4gZW5zdXJlKFxuICAgIHBhcmFtcy5nZXQoXCJvcmlnaW5cIiksXG4gICAgXCJNaXNzaW5nIGluZm9ybWF0aW9uIGZyb20gUGxhc21pYyB3aW5kb3cuXCJcbiAgKTtcbn1cblxuZnVuY3Rpb24gZ2V0U3R1ZGlvSGFzaCgpIHtcbiAgY29uc3QgaGFzaFBhcmFtcyA9IGdldEhhc2hQYXJhbXMoKTtcbiAgaWYgKGhhc2hQYXJhbXMuaGFzKFwic3R1ZGlvSGFzaFwiKSkge1xuICAgIHJldHVybiBoYXNoUGFyYW1zLmdldChcInN0dWRpb0hhc2hcIik7XG4gIH1cbiAgY29uc3QgdXJsUGFyYW1zID0gbmV3IFVSTChsb2NhdGlvbi5ocmVmKS5zZWFyY2hQYXJhbXM7XG4gIHJldHVybiB1cmxQYXJhbXMuZ2V0KFwic3R1ZGlvLWhhc2hcIik7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclN0dWRpb0ludG9JZnJhbWUoKSB7XG4gIGNvbnN0IHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gIGNvbnN0IHBsYXNtaWNPcmlnaW4gPSBnZXRQbGFzbWljT3JpZ2luKCk7XG4gIGNvbnN0IGhhc2ggPSBnZXRTdHVkaW9IYXNoKCk7XG4gIHNjcmlwdC5zcmMgPSBgJHtwbGFzbWljT3JpZ2lufS9zdGF0aWMvanMvc3R1ZGlvJHtcbiAgICBoYXNoID8gYC4ke2hhc2h9LmpzYCA6IGAuanNgXG4gIH1gO1xuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjcmlwdCk7XG59XG5cbmxldCByZW5kZXJDb3VudCA9IDA7XG5leHBvcnQgZnVuY3Rpb24gc2V0UGxhc21pY1Jvb3ROb2RlKG5vZGU6IFJlYWN0LlJlYWN0RWxlbWVudCB8IG51bGwpIHtcbiAgLy8gS2VlcCB0cmFjayBvZiByZW5kZXJDb3VudCwgd2hpY2ggd2UgdXNlIGFzIGtleSB0byBFcnJvckJvdW5kYXJ5LCBzb1xuICAvLyB3ZSBjYW4gcmVzZXQgdGhlIGVycm9yIG9uIGVhY2ggcmVuZGVyXG4gIHJlbmRlckNvdW50Kys7XG4gIHBsYXNtaWNSb290Tm9kZS5zZXQobm9kZSk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGxhc21pY0NhbnZhc0NvbnRleHRWYWx1ZSB7XG4gIGNvbXBvbmVudE5hbWU6IHN0cmluZyB8IG51bGw7XG4gIGdsb2JhbFZhcmlhbnRzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICBpbnRlcmFjdGl2ZT86IGJvb2xlYW47XG59XG5cbi8qKlxuICogUmVhY3QgY29udGV4dCB0byBkZXRlY3Qgd2hldGhlciB0aGUgY29tcG9uZW50IGlzIHJlbmRlcmVkIG9uIFBsYXNtaWMgZWRpdG9yLlxuICogSWYgbm90LCByZXR1cm4gZmFsc2UuXG4gKiBJZiBzbywgcmV0dXJuIGFuIG9iamVjdCB3aXRoIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGNvbXBvbmVudFxuICovXG5leHBvcnQgY29uc3QgUGxhc21pY0NhbnZhc0NvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0PFxuICBQbGFzbWljQ2FudmFzQ29udGV4dFZhbHVlIHwgZmFsc2Vcbj4oZmFsc2UpO1xuZXhwb3J0IGNvbnN0IHVzZVBsYXNtaWNDYW52YXNDb250ZXh0ID0gKCkgPT5cbiAgUmVhY3QudXNlQ29udGV4dChQbGFzbWljQ2FudmFzQ29udGV4dCk7XG5cbmZ1bmN0aW9uIF9QbGFzbWljQ2FudmFzSG9zdCgpIHtcbiAgLy8gSWYgd2luZG93LnBhcmVudCBpcyBudWxsLCB0aGVuIHRoaXMgaXMgYSB3aW5kb3cgd2hvc2UgY29udGFpbmluZyBpZnJhbWVcbiAgLy8gaGFzIGJlZW4gZGV0YWNoZWQgZnJvbSB0aGUgRE9NIChmb3IgdGhlIHRvcCB3aW5kb3csIHdpbmRvdy5wYXJlbnQgPT09IHdpbmRvdykuXG4gIC8vIEluIHRoYXQgY2FzZSwgd2Ugc2hvdWxkbid0IGRvIGFueXRoaW5nLiAgSWYgd2luZG93LnBhcmVudCBpcyBudWxsLCBieSB0aGUgd2F5LFxuICAvLyBsb2NhdGlvbi5oYXNoIHdpbGwgYWxzbyBiZSBudWxsLlxuICBjb25zdCBpc0ZyYW1lQXR0YWNoZWQgPSAhIXdpbmRvdy5wYXJlbnQ7XG4gIGNvbnN0IGlzQ2FudmFzID0gISFsb2NhdGlvbi5oYXNoPy5tYXRjaCgvXFxiY2FudmFzPXRydWVcXGIvKTtcbiAgY29uc3QgaXNMaXZlID0gISFsb2NhdGlvbi5oYXNoPy5tYXRjaCgvXFxibGl2ZT10cnVlXFxiLykgfHwgIWlzRnJhbWVBdHRhY2hlZDtcbiAgY29uc3Qgc2hvdWxkUmVuZGVyU3R1ZGlvID1cbiAgICBpc0ZyYW1lQXR0YWNoZWQgJiZcbiAgICAhZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNwbGFzbWljLXN0dWRpby10YWdcIikgJiZcbiAgICAhaXNDYW52YXMgJiZcbiAgICAhaXNMaXZlO1xuICBjb25zdCBmb3JjZVVwZGF0ZSA9IHVzZUZvcmNlVXBkYXRlKCk7XG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgcm9vdENoYW5nZUxpc3RlbmVycy5wdXNoKGZvcmNlVXBkYXRlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc3QgaW5kZXggPSByb290Q2hhbmdlTGlzdGVuZXJzLmluZGV4T2YoZm9yY2VVcGRhdGUpO1xuICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgcm9vdENoYW5nZUxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtmb3JjZVVwZGF0ZV0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChzaG91bGRSZW5kZXJTdHVkaW8gJiYgaXNGcmFtZUF0dGFjaGVkICYmIHdpbmRvdy5wYXJlbnQgIT09IHdpbmRvdykge1xuICAgICAgcmVuZGVyU3R1ZGlvSW50b0lmcmFtZSgpO1xuICAgIH1cbiAgfSwgW3Nob3VsZFJlbmRlclN0dWRpbywgaXNGcmFtZUF0dGFjaGVkXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFzaG91bGRSZW5kZXJTdHVkaW8gJiYgIWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjZ2V0bGlic1wiKSAmJiBpc0xpdmUpIHtcbiAgICAgIGNvbnN0IHNjcmlwdEVsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICBzY3JpcHRFbHQuaWQgPSBcImdldGxpYnNcIjtcbiAgICAgIHNjcmlwdEVsdC5zcmMgPSBnZXRQbGFzbWljT3JpZ2luKCkgKyBcIi9zdGF0aWMvanMvZ2V0bGlicy5qc1wiO1xuICAgICAgc2NyaXB0RWx0LmFzeW5jID0gZmFsc2U7XG4gICAgICBzY3JpcHRFbHQub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAod2luZG93IGFzIGFueSkuX19HZXRsaWJzUmVhZHlSZXNvbHZlcj8uKCk7XG4gICAgICB9O1xuICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmQoc2NyaXB0RWx0KTtcbiAgICB9XG4gIH0sIFtzaG91bGRSZW5kZXJTdHVkaW9dKTtcblxuICBjb25zdCBbY2FudmFzQ29udGV4dFZhbHVlLCBzZXRDYW52YXNDb250ZXh0VmFsdWVdID0gUmVhY3QudXNlU3RhdGUoKCkgPT5cbiAgICBkZXJpdmVDYW52YXNDb250ZXh0VmFsdWUoKVxuICApO1xuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGlzQ2FudmFzKSB7XG4gICAgICBjb25zdCBsaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgICAgc2V0Q2FudmFzQ29udGV4dFZhbHVlKGRlcml2ZUNhbnZhc0NvbnRleHRWYWx1ZSgpKTtcbiAgICAgIH07XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImhhc2hjaGFuZ2VcIiwgbGlzdGVuZXIpO1xuICAgICAgcmV0dXJuICgpID0+IHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiaGFzaGNoYW5nZVwiLCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0sIFtpc0NhbnZhc10pO1xuICBpZiAoIWlzRnJhbWVBdHRhY2hlZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChpc0NhbnZhcyB8fCBpc0xpdmUpIHtcbiAgICBsZXQgYXBwRGl2ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNwbGFzbWljLWFwcC5fX3dhYl91c2VyLWJvZHlcIik7XG4gICAgaWYgKCFhcHBEaXYpIHtcbiAgICAgIGFwcERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBhcHBEaXYuaWQgPSBcInBsYXNtaWMtYXBwXCI7XG4gICAgICBhcHBEaXYuY2xhc3NMaXN0LmFkZChcIl9fd2FiX3VzZXItYm9keVwiKTtcbiAgICAgIGRvY3VtZW50LmJvZHkucHJlcGVuZChhcHBEaXYpO1xuICAgIH1cbiAgICByZXR1cm4gUmVhY3RET00uY3JlYXRlUG9ydGFsKFxuICAgICAgPEVycm9yQm91bmRhcnkga2V5PXtgJHtyZW5kZXJDb3VudH1gfT5cbiAgICAgICAgPFBsYXNtaWNDYW52YXNDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtjYW52YXNDb250ZXh0VmFsdWV9PlxuICAgICAgICAgIHtwbGFzbWljUm9vdE5vZGUuZ2V0KCl9XG4gICAgICAgIDwvUGxhc21pY0NhbnZhc0NvbnRleHQuUHJvdmlkZXI+XG4gICAgICA8L0Vycm9yQm91bmRhcnk+LFxuICAgICAgYXBwRGl2LFxuICAgICAgXCJwbGFzbWljLWFwcFwiXG4gICAgKTtcbiAgfVxuICBpZiAoc2hvdWxkUmVuZGVyU3R1ZGlvICYmIHdpbmRvdy5wYXJlbnQgPT09IHdpbmRvdykge1xuICAgIHJldHVybiAoXG4gICAgICA8aWZyYW1lXG4gICAgICAgIHNyYz17YGh0dHBzOi8vZG9jcy5wbGFzbWljLmFwcC9hcHAtY29udGVudC9hcHAtaG9zdC1yZWFkeSNhcHBIb3N0VXJsPSR7ZW5jb2RlVVJJQ29tcG9uZW50KFxuICAgICAgICAgIGxvY2F0aW9uLmhyZWZcbiAgICAgICAgKX1gfVxuICAgICAgICBzdHlsZT17e1xuICAgICAgICAgIHdpZHRoOiBcIjEwMHZ3XCIsXG4gICAgICAgICAgaGVpZ2h0OiBcIjEwMHZoXCIsXG4gICAgICAgICAgYm9yZGVyOiBcIm5vbmVcIixcbiAgICAgICAgICBwb3NpdGlvbjogXCJmaXhlZFwiLFxuICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgIHpJbmRleDogOTk5OTk5OTksXG4gICAgICAgIH19XG4gICAgICA+PC9pZnJhbWU+XG4gICAgKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuaW50ZXJmYWNlIFBsYXNtaWNDYW52YXNIb3N0UHJvcHMge1xuICAvKipcbiAgICogV2VicGFjayBobXIgdXNlcyBFdmVudFNvdXJjZSB0b1x0bGlzdGVuIHRvIGhvdCByZWxvYWRzLCBidXQgdGhhdFxuICAgKiByZXN1bHRzaW4gYSBwZXJzaXN0ZW50XHRjb25uZWN0aW9uIGZyb21cdGVhY2ggd2luZG93LiAgSW4gUGxhc21pY1xuICAgKiBTdHVkaW8sIGlmIGEgcHJvamVjdCBpcyBjb25maWd1cmVkIHRvIHVzZSBhcHAtaG9zdGluZyB3aXRoIGFcbiAgICogbmV4dGpzIG9yIGdhdHNieSBzZXJ2ZXIgcnVubmluZyBpbiBkZXYgbW9kZSwgZWFjaCBhcnRib2FyZCB3aWxsXG4gICAqIGJlIGhvbGRpbmcgYSBwZXJzaXN0ZW50IGNvbm5lY3Rpb24gdG8gdGhlIGRldiBzZXJ2ZXIuXG4gICAqIEJlY2F1c2UgYnJvd3NlcnNcdGhhdmUgYSBsaW1pdCB0b1x0aG93IG1hbnkgY29ubmVjdGlvbnMgY2FuXG4gICAqIGJlIGhlbGRcdGF0IGEgdGltZSBieSBkb21haW4sIHRoaXMgbWVhbnNcdGFmdGVyIFhcdGFydGJvYXJkcywgbmV3XG4gICAqIGFydGJvYXJkcyB3aWxsIGZyZWV6ZSBhbmQgbm90IGxvYWQuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIDxQbGFzbWljQ2FudmFzSG9zdCAvPiB3aWxsIGdsb2JhbGx5IG11dGF0ZVxuICAgKiB3aW5kb3cuRXZlbnRTb3VyY2UgdG8gYXZvaWQgdXNpbmcgRXZlbnRTb3VyY2UgZm9yIEhNUiwgd2hpY2ggeW91XG4gICAqIHR5cGljYWxseSBkb24ndCBuZWVkIGZvciB5b3VyIGN1c3RvbSBob3N0IHBhZ2UuICBJZiB5b3UgZG8gc3RpbGxcbiAgICogd2FudCB0byByZXRhaW4gSFJNLCB0aGVuIHlvdWMgYW4gcGFzcyBlbmFibGVXZWJwYWNrSG1yPXt0cnVlfS5cbiAgICovXG4gIGVuYWJsZVdlYnBhY2tIbXI/OiBib29sZWFuO1xufVxuXG5leHBvcnQgY29uc3QgUGxhc21pY0NhbnZhc0hvc3Q6IFJlYWN0LkZ1bmN0aW9uQ29tcG9uZW50PFxuICBQbGFzbWljQ2FudmFzSG9zdFByb3BzXG4+ID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHsgZW5hYmxlV2VicGFja0htciB9ID0gcHJvcHM7XG4gIGNvbnN0IFtub2RlLCBzZXROb2RlXSA9IFJlYWN0LnVzZVN0YXRlPFJlYWN0LlJlYWN0RWxlbWVudDxhbnksIGFueT4gfCBudWxsPihcbiAgICBudWxsXG4gICk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgc2V0Tm9kZSg8X1BsYXNtaWNDYW52YXNIb3N0IC8+KTtcbiAgfSwgW10pO1xuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICB7IWVuYWJsZVdlYnBhY2tIbXIgJiYgPERpc2FibGVXZWJwYWNrSG1yIC8+fVxuICAgICAge25vZGV9XG4gICAgPC8+XG4gICk7XG59O1xuXG50eXBlIFJlbmRlckVycm9yTGlzdGVuZXIgPSAoZXJyOiBFcnJvcikgPT4gdm9pZDtcbmNvbnN0IHJlbmRlckVycm9yTGlzdGVuZXJzOiBSZW5kZXJFcnJvckxpc3RlbmVyW10gPSBbXTtcbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlclJlbmRlckVycm9yTGlzdGVuZXIobGlzdGVuZXI6IFJlbmRlckVycm9yTGlzdGVuZXIpIHtcbiAgcmVuZGVyRXJyb3JMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgY29uc3QgaW5kZXggPSByZW5kZXJFcnJvckxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgcmVuZGVyRXJyb3JMaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gIH07XG59XG5cbmludGVyZmFjZSBFcnJvckJvdW5kYXJ5UHJvcHMge1xuICBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZTtcbn1cblxuaW50ZXJmYWNlIEVycm9yQm91bmRhcnlTdGF0ZSB7XG4gIGVycm9yPzogRXJyb3I7XG59XG5cbmNsYXNzIEVycm9yQm91bmRhcnkgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8XG4gIEVycm9yQm91bmRhcnlQcm9wcyxcbiAgRXJyb3JCb3VuZGFyeVN0YXRlXG4+IHtcbiAgY29uc3RydWN0b3IocHJvcHM6IEVycm9yQm91bmRhcnlQcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0ge307XG4gIH1cblxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yOiBFcnJvcikge1xuICAgIHJldHVybiB7IGVycm9yIH07XG4gIH1cblxuICBjb21wb25lbnREaWRDYXRjaChlcnJvcjogRXJyb3IpIHtcbiAgICByZW5kZXJFcnJvckxpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIoZXJyb3IpKTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5lcnJvcikge1xuICAgICAgcmV0dXJuIDxkaXY+RXJyb3I6IHtgJHt0aGlzLnN0YXRlLmVycm9yLm1lc3NhZ2V9YH08L2Rpdj47XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiA8Pnt0aGlzLnByb3BzLmNoaWxkcmVufTwvPjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gRGlzYWJsZVdlYnBhY2tIbXIoKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gKFxuICAgIDxzY3JpcHRcbiAgICAgIHR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIlxuICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw9e3tcbiAgICAgICAgX19odG1sOiBgXG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBjb25zdCBSZWFsRXZlbnRTb3VyY2UgPSB3aW5kb3cuRXZlbnRTb3VyY2U7XG4gICAgICAgIHdpbmRvdy5FdmVudFNvdXJjZSA9IGZ1bmN0aW9uKHVybCwgY29uZmlnKSB7XG4gICAgICAgICAgaWYgKC9bXmEtekEtWl1obXIoJHxbXmEtekEtWl0pLy50ZXN0KHVybCkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlBsYXNtaWM6IGRpc2FibGVkIEV2ZW50U291cmNlIHJlcXVlc3QgZm9yXCIsIHVybCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBvbmVycm9yKCkge30sIG9ubWVzc2FnZSgpIHt9LCBvbm9wZW4oKSB7fSwgY2xvc2UoKSB7fVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWFsRXZlbnRTb3VyY2UodXJsLCBjb25maWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYCxcbiAgICAgIH19XG4gICAgPjwvc2NyaXB0PlxuICApO1xufVxuXG5mdW5jdGlvbiBkZXJpdmVDYW52YXNDb250ZXh0VmFsdWUoKTogUGxhc21pY0NhbnZhc0NvbnRleHRWYWx1ZSB8IGZhbHNlIHtcbiAgY29uc3QgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuICBpZiAoaGFzaCAmJiBoYXNoLmxlbmd0aCA+IDApIHtcbiAgICAvLyBjcmVhdGUgVVJMc2VhcmNoUGFyYW1zIHNraXBwaW5nIHRoZSBpbml0aWFsICMgY2hhcmFjdGVyXG4gICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhoYXNoLnN1YnN0cmluZygxKSk7XG4gICAgaWYgKHBhcmFtcy5nZXQoXCJjYW52YXNcIikgPT09IFwidHJ1ZVwiKSB7XG4gICAgICBjb25zdCBnbG9iYWxWYXJpYW50cyA9IHBhcmFtcy5nZXQoXCJnbG9iYWxWYXJpYW50c1wiKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbXBvbmVudE5hbWU6IHBhcmFtcy5nZXQoXCJjb21wb25lbnROYW1lXCIpID8/IG51bGwsXG4gICAgICAgIGdsb2JhbFZhcmlhbnRzOiBnbG9iYWxWYXJpYW50cyA/IEpTT04ucGFyc2UoZ2xvYmFsVmFyaWFudHMpIDoge30sXG4gICAgICAgIGludGVyYWN0aXZlOiBwYXJhbXMuZ2V0KFwiaW50ZXJhY3RpdmVcIikgPT09IFwidHJ1ZVwiLFxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5jb25zdCBJTlRFUk5BTF9DQ19DQU5WQVNfU0VMRUNUSU9OX1BST1AgPSBcIl9fcGxhc21pY19zZWxlY3Rpb25fcHJvcF9fXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VQbGFzbWljQ2FudmFzQ29tcG9uZW50SW5mbyhwcm9wczogYW55KSB7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAvLyBJbnNpZGUgUGxhc21pYyBTdHVkaW8sIGNvZGUgY29tcG9uZW50cyB3aWxsIHJlY2VpdmUgYW4gYWRkaXRpb25hbCBwcm9wXG4gICAgLy8gdGhhdCBjb250YWlucyBzZWxlY3Rpb24gaW5mb3JtYXRpb24gZm9yIHRoYXQgc3BlY2lmaWMgY29kZSBjb21wb25lbnQuXG4gICAgLy8gVGhpcyBob29rIHdpbGwgcmV0dXJuIHRoYXQgc2VsZWN0aW9uIGluZm9ybWF0aW9uIHdoaWNoIGlzIHVzZWZ1bCBmb3JcbiAgICAvLyBjaGFuZ2luZyB0aGUgYmVoYXZpb3Igb2YgdGhlIGNvZGUgY29tcG9uZW50IHdoZW4gaXQgaXMgc2VsZWN0ZWQsIG1ha2luZ1xuICAgIC8vIGl0IGVhc2llciB0byBpbnRlcmFjdCB3aXRoIGNvZGUgY29tcG9uZW50cyBhbmQgc2xvdHMgdGhhdCBhcmVuJ3QgYWx3YXlzXG4gICAgLy8gdmlzaWJsZSBpbiB0aGUgY2FudmFzLiAoZS5nLiBhdXRvbWF0aWNhbGx5IG9wZW5pbmcgYSBtb2RhbCB3aGVuIGl0J3Mgc2VsZWN0ZWQpXG4gICAgY29uc3Qgc2VsZWN0aW9uSW5mbyA9IHByb3BzPy5bSU5URVJOQUxfQ0NfQ0FOVkFTX1NFTEVDVElPTl9QUk9QXTtcbiAgICBpZiAoc2VsZWN0aW9uSW5mbykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNTZWxlY3RlZDogc2VsZWN0aW9uSW5mby5pc1NlbGVjdGVkIGFzIGJvb2xlYW4sXG4gICAgICAgIHNlbGVjdGVkU2xvdE5hbWU6IHNlbGVjdGlvbkluZm8uc2VsZWN0ZWRTbG90TmFtZSBhcyBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSwgW3Byb3BzXSk7XG59XG4iLCJleHBvcnQgY29uc3QgdHVwbGUgPSA8VCBleHRlbmRzIGFueVtdPiguLi5hcmdzOiBUKTogVCA9PiBhcmdzO1xuIiwiaW1wb3J0IFJlYWN0LCB7XG4gIGNyZWF0ZUNvbnRleHQsXG4gIFJlYWN0RWxlbWVudCxcbiAgUmVhY3ROb2RlLFxuICB1c2VDb250ZXh0LFxufSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHR1cGxlIH0gZnJvbSBcIi4vY29tbW9uXCI7XG5cbmV4cG9ydCB0eXBlIERhdGFEaWN0ID0gUmVjb3JkPHN0cmluZywgYW55PjtcblxuZXhwb3J0IGNvbnN0IERhdGFDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxEYXRhRGljdCB8IHVuZGVmaW5lZD4odW5kZWZpbmVkKTtcblxuZXhwb3J0IHR5cGUgRGF0YU1ldGEgPSB7XG4gIGFkdmFuY2VkPzogYm9vbGVhbjtcbiAgaGlkZGVuPzogYm9vbGVhbjtcbiAgbGFiZWw/OiBzdHJpbmc7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gbWtNZXRhTmFtZShuYW1lOiBzdHJpbmcpIHtcbiAgcmV0dXJuIGBfX3BsYXNtaWNfbWV0YV8ke25hbWV9YDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1rTWV0YVZhbHVlKG1ldGE6IFBhcnRpYWw8RGF0YU1ldGE+KTogRGF0YU1ldGEge1xuICByZXR1cm4gbWV0YTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5U2VsZWN0b3IoXG4gIHJhd0RhdGE6IERhdGFEaWN0IHwgdW5kZWZpbmVkLFxuICBzZWxlY3Rvcjogc3RyaW5nIHwgdW5kZWZpbmVkXG4pOiBhbnkge1xuICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBsZXQgY3VyRGF0YSA9IHJhd0RhdGE7XG4gIGZvciAoY29uc3Qga2V5IG9mIHNlbGVjdG9yLnNwbGl0KFwiLlwiKSkge1xuICAgIGN1ckRhdGEgPSBjdXJEYXRhPy5ba2V5XTtcbiAgfVxuICByZXR1cm4gY3VyRGF0YTtcbn1cblxuZXhwb3J0IHR5cGUgU2VsZWN0b3JEaWN0ID0gUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgdW5kZWZpbmVkPjtcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVNlbGVjdG9yKHNlbGVjdG9yOiBzdHJpbmcgfCB1bmRlZmluZWQpOiBhbnkge1xuICBjb25zdCByYXdEYXRhID0gdXNlRGF0YUVudigpO1xuICByZXR1cm4gYXBwbHlTZWxlY3RvcihyYXdEYXRhLCBzZWxlY3Rvcik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VTZWxlY3RvcnMoc2VsZWN0b3JzOiBTZWxlY3RvckRpY3QgPSB7fSk6IGFueSB7XG4gIGNvbnN0IHJhd0RhdGEgPSB1c2VEYXRhRW52KCk7XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgT2JqZWN0LmVudHJpZXMoc2VsZWN0b3JzKVxuICAgICAgLmZpbHRlcigoW2tleSwgc2VsZWN0b3JdKSA9PiAhIWtleSAmJiAhIXNlbGVjdG9yKVxuICAgICAgLm1hcCgoW2tleSwgc2VsZWN0b3JdKSA9PiB0dXBsZShrZXksIGFwcGx5U2VsZWN0b3IocmF3RGF0YSwgc2VsZWN0b3IpKSlcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZURhdGFFbnYoKSB7XG4gIHJldHVybiB1c2VDb250ZXh0KERhdGFDb250ZXh0KTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEYXRhUHJvdmlkZXJQcm9wcyB7XG4gIC8qKlxuICAgKiBLZXkgdG8gc2V0IGluIGRhdGEgY29udGV4dC5cbiAgICovXG4gIG5hbWU/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBWYWx1ZSB0byBzZXQgZm9yIGBuYW1lYCBpbiBkYXRhIGNvbnRleHQuXG4gICAqL1xuICBkYXRhPzogYW55O1xuICAvKipcbiAgICogSWYgdHJ1ZSwgaGlkZSB0aGlzIGl0ZW0gaW4gc3R1ZGlvIGRhdGEgcGlja2VyLlxuICAgKi9cbiAgaGlkZGVuPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIElmIHRydWUsIG1hcmsgdGhpcyBpdGVtIGFzIGFkdmFuY2VkIGluIHN0dWRpby5cbiAgICovXG4gIGFkdmFuY2VkPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIExhYmVsIHRvIGJlIHNob3duIGluIHRoZSBzdHVkaW8gZGF0YSBwaWNrZXIgZm9yIGVhc2llciBuYXZpZ2F0aW9uIChkYXRhIGJpbmRpbmcpLlxuICAgKi9cbiAgbGFiZWw/OiBzdHJpbmc7XG4gIGNoaWxkcmVuPzogUmVhY3ROb2RlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gRGF0YVByb3ZpZGVyKHtcbiAgbmFtZSxcbiAgZGF0YSxcbiAgaGlkZGVuLFxuICBhZHZhbmNlZCxcbiAgbGFiZWwsXG4gIGNoaWxkcmVuLFxufTogRGF0YVByb3ZpZGVyUHJvcHMpIHtcbiAgY29uc3QgZXhpc3RpbmdFbnYgPSB1c2VEYXRhRW52KCkgPz8ge307XG4gIGlmICghbmFtZSkge1xuICAgIHJldHVybiA8PntjaGlsZHJlbn08Lz47XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxEYXRhQ29udGV4dC5Qcm92aWRlclxuICAgICAgICB2YWx1ZT17e1xuICAgICAgICAgIC4uLmV4aXN0aW5nRW52LFxuICAgICAgICAgIFtuYW1lXTogZGF0YSxcbiAgICAgICAgICBbbWtNZXRhTmFtZShuYW1lKV06IG1rTWV0YVZhbHVlKHsgaGlkZGVuLCBhZHZhbmNlZCwgbGFiZWwgfSksXG4gICAgICAgIH19XG4gICAgICA+XG4gICAgICAgIHtjaGlsZHJlbn1cbiAgICAgIDwvRGF0YUNvbnRleHQuUHJvdmlkZXI+XG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgdHJhbnNmb3JtcyBgeyBcIi4uLnNsdWdcIjogXCJhL2IvY1wiIH1gIGludG8gYHsgXCJzbHVnXCI6IFtcImFcIiwgXCJiXCIsIFwiY1wiXSB9LlxuICovXG5mdW5jdGlvbiBmaXhDYXRjaGFsbFBhcmFtcyhcbiAgcGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBzdHJpbmdbXSB8IHVuZGVmaW5lZD5cbikge1xuICBjb25zdCBuZXdQYXJhbXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IHN0cmluZ1tdPiA9IHt9O1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwYXJhbXMpKSB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChrZXkuc3RhcnRzV2l0aChcIi4uLlwiKSkge1xuICAgICAgbmV3UGFyYW1zW2tleS5zbGljZSgzKV0gPVxuICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICA/IHZhbHVlLnJlcGxhY2UoL15cXC98XFwvJC9nLCBcIlwiKS5zcGxpdChcIi9cIilcbiAgICAgICAgICA6IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdQYXJhbXNba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3UGFyYW1zO1xufVxuXG5mdW5jdGlvbiBta1BhdGhGcm9tUm91dGVBbmRQYXJhbXMoXG4gIHJvdXRlOiBzdHJpbmcsXG4gIHBhcmFtczogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgc3RyaW5nW10gfCB1bmRlZmluZWQ+XG4pIHtcbiAgaWYgKCFwYXJhbXMpIHtcbiAgICByZXR1cm4gcm91dGU7XG4gIH1cbiAgbGV0IHBhdGggPSByb3V0ZTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocGFyYW1zKSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoYFske2tleX1dYCwgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGlmIChwYXRoLmluY2x1ZGVzKGBbWy4uLiR7a2V5fV1dYCkpIHtcbiAgICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZShgW1suLi4ke2tleX1dXWAsIHZhbHVlLmpvaW4oXCIvXCIpKTtcbiAgICAgIH0gZWxzZSBpZiAocGF0aC5pbmNsdWRlcyhgWy4uLiR7a2V5fV1gKSkge1xuICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKGBbLi4uJHtrZXl9XWAsIHZhbHVlLmpvaW4oXCIvXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhdGg7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFnZVBhcmFtc1Byb3ZpZGVyUHJvcHMge1xuICBjaGlsZHJlbj86IFJlYWN0Tm9kZTtcblxuICAvKipcbiAgICogUGFnZSByb3V0ZSB3aXRob3V0IHBhcmFtcyBzdWJzdGl0dXRlZCAoZS5nLiAvcHJvZHVjdHMvW3NsdWddKS5cbiAgICovXG4gIHJvdXRlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBQYWdlIHBhcmFtcyAoZS5nLiB7IHNsdWc6IFwiamFja2V0XCIgfSlcbiAgICovXG4gIHBhcmFtcz86IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IHN0cmluZ1tdIHwgdW5kZWZpbmVkPjtcblxuICAvKipcbiAgICogUGFnZSBxdWVyeSBwYXJhbXMgKGUuZy4geyBxOiBcInNlYXJjaCB0ZXJtXCIgfSlcbiAgICovXG4gIHF1ZXJ5PzogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgc3RyaW5nW10gfCB1bmRlZmluZWQ+O1xuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYHJvdXRlYCBpbnN0ZWFkLlxuICAgKi9cbiAgcGF0aD86IHN0cmluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFBhZ2VQYXJhbXNQcm92aWRlcih7XG4gIGNoaWxkcmVuLFxuICByb3V0ZSxcbiAgcGF0aDogZGVwcmVjYXRlZFJvdXRlLFxuICBwYXJhbXMgPSB7fSxcbiAgcXVlcnkgPSB7fSxcbn06IFBhZ2VQYXJhbXNQcm92aWRlclByb3BzKSB7XG4gIHJvdXRlID0gcm91dGUgPz8gZGVwcmVjYXRlZFJvdXRlO1xuICBwYXJhbXMgPSBmaXhDYXRjaGFsbFBhcmFtcyhwYXJhbXMpO1xuICBjb25zdCAkY3R4ID0gdXNlRGF0YUVudigpIHx8IHt9O1xuICBjb25zdCBwYXRoID0gcm91dGUgPyBta1BhdGhGcm9tUm91dGVBbmRQYXJhbXMocm91dGUsIHBhcmFtcykgOiB1bmRlZmluZWQ7XG4gIHJldHVybiAoXG4gICAgPERhdGFQcm92aWRlclxuICAgICAgbmFtZT17XCJwYWdlUm91dGVcIn1cbiAgICAgIGRhdGE9e3JvdXRlfVxuICAgICAgbGFiZWw9e1wiUGFnZSByb3V0ZVwifVxuICAgICAgYWR2YW5jZWQ9e3RydWV9XG4gICAgPlxuICAgICAgPERhdGFQcm92aWRlciBuYW1lPXtcInBhZ2VQYXRoXCJ9IGRhdGE9e3BhdGh9IGxhYmVsPXtcIlBhZ2UgcGF0aFwifT5cbiAgICAgICAgPERhdGFQcm92aWRlclxuICAgICAgICAgIG5hbWU9e1wicGFyYW1zXCJ9XG4gICAgICAgICAgZGF0YT17eyAuLi4kY3R4LnBhcmFtcywgLi4ucGFyYW1zIH19XG4gICAgICAgICAgbGFiZWw9e1wiUGFnZSBVUkwgcGF0aCBwYXJhbXNcIn1cbiAgICAgICAgPlxuICAgICAgICAgIDxEYXRhUHJvdmlkZXJcbiAgICAgICAgICAgIG5hbWU9e1wicXVlcnlcIn1cbiAgICAgICAgICAgIGRhdGE9e3sgLi4uJGN0eC5xdWVyeSwgLi4ucXVlcnkgfX1cbiAgICAgICAgICAgIGxhYmVsPXtcIlBhZ2UgVVJMIHF1ZXJ5IHBhcmFtc1wifVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgICA8L0RhdGFQcm92aWRlcj5cbiAgICAgICAgPC9EYXRhUHJvdmlkZXI+XG4gICAgICA8L0RhdGFQcm92aWRlcj5cbiAgICA8L0RhdGFQcm92aWRlcj5cbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIERhdGFDdHhSZWFkZXIoe1xuICBjaGlsZHJlbixcbn06IHtcbiAgY2hpbGRyZW46ICgkY3R4OiBEYXRhRGljdCB8IHVuZGVmaW5lZCkgPT4gUmVhY3ROb2RlO1xufSkge1xuICBjb25zdCAkY3R4ID0gdXNlRGF0YUVudigpO1xuICByZXR1cm4gY2hpbGRyZW4oJGN0eCkgYXMgUmVhY3RFbGVtZW50IHwgbnVsbDtcbn1cbiIsImltcG9ydCB7IFByaW1pdGl2ZVR5cGUgfSBmcm9tIFwiLi9wcm9wLXR5cGVzXCI7XG5cbmNvbnN0IHJvb3QgPSBnbG9iYWxUaGlzIGFzIGFueTtcblxuZXhwb3J0IHR5cGUgRmV0Y2hlciA9ICguLi5hcmdzOiBhbnlbXSkgPT4gUHJvbWlzZTxhbnk+O1xuXG5leHBvcnQgaW50ZXJmYWNlIEZldGNoZXJNZXRhIHtcbiAgLyoqXG4gICAqIEFueSB1bmlxdWUgaWRlbnRpZnlpbmcgc3RyaW5nIGZvciB0aGlzIGZldGNoZXIuXG4gICAqL1xuICBuYW1lOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgU3R1ZGlvLXVzZXItZnJpZW5kbHkgZGlzcGxheSBuYW1lLlxuICAgKi9cbiAgZGlzcGxheU5hbWU/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgc3ltYm9sIHRvIGltcG9ydCBmcm9tIHRoZSBpbXBvcnRQYXRoLlxuICAgKi9cbiAgaW1wb3J0TmFtZT86IHN0cmluZztcbiAgYXJnczogeyBuYW1lOiBzdHJpbmc7IHR5cGU6IFByaW1pdGl2ZVR5cGUgfVtdO1xuICByZXR1cm5zOiBQcmltaXRpdmVUeXBlO1xuICAvKipcbiAgICogRWl0aGVyIHRoZSBwYXRoIHRvIHRoZSBmZXRjaGVyIHJlbGF0aXZlIHRvIGByb290RGlyYCBvciB0aGUgbnBtXG4gICAqIHBhY2thZ2UgbmFtZVxuICAgKi9cbiAgaW1wb3J0UGF0aDogc3RyaW5nO1xuICAvKipcbiAgICogV2hldGhlciBpdCdzIGEgZGVmYXVsdCBleHBvcnQgb3IgbmFtZWQgZXhwb3J0XG4gICAqL1xuICBpc0RlZmF1bHRFeHBvcnQ/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZldGNoZXJSZWdpc3RyYXRpb24ge1xuICBmZXRjaGVyOiBGZXRjaGVyO1xuICBtZXRhOiBGZXRjaGVyTWV0YTtcbn1cblxuZGVjbGFyZSBnbG9iYWwge1xuICBpbnRlcmZhY2UgV2luZG93IHtcbiAgICBfX1BsYXNtaWNGZXRjaGVyUmVnaXN0cnk6IEZldGNoZXJSZWdpc3RyYXRpb25bXTtcbiAgfVxufVxuXG5yb290Ll9fUGxhc21pY0ZldGNoZXJSZWdpc3RyeSA9IFtdO1xuXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJGZXRjaGVyKGZldGNoZXI6IEZldGNoZXIsIG1ldGE6IEZldGNoZXJNZXRhKSB7XG4gIHJvb3QuX19QbGFzbWljRmV0Y2hlclJlZ2lzdHJ5LnB1c2goeyBmZXRjaGVyLCBtZXRhIH0pO1xufVxuIiwiaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuXG5leHBvcnQgdHlwZSBHbG9iYWxBY3Rpb25EaWN0ID0gUmVjb3JkPHN0cmluZywgRnVuY3Rpb24+O1xuXG5leHBvcnQgY29uc3QgR2xvYmFsQWN0aW9uc0NvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0PFxuICBHbG9iYWxBY3Rpb25EaWN0IHwgdW5kZWZpbmVkXG4+KHVuZGVmaW5lZCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBHbG9iYWxBY3Rpb25zUHJvdmlkZXIocHJvcHM6IHtcbiAgY29udGV4dE5hbWU6IHN0cmluZztcbiAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGU7XG4gIGFjdGlvbnM6IEdsb2JhbEFjdGlvbkRpY3Q7XG59KSB7XG4gIGNvbnN0IHsgY29udGV4dE5hbWUsIGNoaWxkcmVuLCBhY3Rpb25zIH0gPSBwcm9wcztcbiAgY29uc3QgZXhpc3RpbmdBY3Rpb25zID0gdXNlR2xvYmFsQWN0aW9ucygpO1xuICBjb25zdCBuYW1lc3BhY2VkQWN0aW9ucyA9IFJlYWN0LnVzZU1lbW8oXG4gICAgKCkgPT5cbiAgICAgIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgT2JqZWN0LmVudHJpZXMoYWN0aW9ucykubWFwKChba2V5LCB2YWxdKSA9PiBbXG4gICAgICAgICAgYCR7Y29udGV4dE5hbWV9LiR7a2V5fWAsXG4gICAgICAgICAgdmFsLFxuICAgICAgICBdKVxuICAgICAgKSxcbiAgICBbY29udGV4dE5hbWUsIGFjdGlvbnNdXG4gICk7XG4gIHJldHVybiAoXG4gICAgPEdsb2JhbEFjdGlvbnNDb250ZXh0LlByb3ZpZGVyXG4gICAgICB2YWx1ZT17e1xuICAgICAgICAuLi5leGlzdGluZ0FjdGlvbnMsXG4gICAgICAgIC4uLm5hbWVzcGFjZWRBY3Rpb25zLFxuICAgICAgfX1cbiAgICA+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9HbG9iYWxBY3Rpb25zQ29udGV4dC5Qcm92aWRlcj5cbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUdsb2JhbEFjdGlvbnMoKSB7XG4gIHJldHVybiBSZWFjdC51c2VDb250ZXh0KEdsb2JhbEFjdGlvbnNDb250ZXh0KSA/PyB7fTtcbn1cbiIsImltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcblxuY29uc3QgUGxhc21pY0xpbmtDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dDxcbiAgUmVhY3QuQ29tcG9uZW50VHlwZTxhbnk+IHwgdW5kZWZpbmVkXG4+KHVuZGVmaW5lZCk7XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VQbGFzbWljTGlua01heWJlKCk6XG4gIHwgUmVhY3QuQ29tcG9uZW50VHlwZTxSZWFjdC5Db21wb25lbnRQcm9wczxcImFcIj4+XG4gIHwgdW5kZWZpbmVkIHtcbiAgcmV0dXJuIFJlYWN0LnVzZUNvbnRleHQoUGxhc21pY0xpbmtDb250ZXh0KTtcbn1cblxuY29uc3QgQW5jaG9yTGluayA9IFJlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gQW5jaG9yTGluayhcbiAgcHJvcHM6IFJlYWN0LkNvbXBvbmVudFByb3BzPFwiYVwiPixcbiAgcmVmOiBSZWFjdC5SZWY8SFRNTEFuY2hvckVsZW1lbnQ+XG4pIHtcbiAgcmV0dXJuIDxhIHsuLi5wcm9wc30gcmVmPXtyZWZ9IC8+O1xufSk7XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VQbGFzbWljTGluaygpOiBSZWFjdC5Db21wb25lbnRUeXBlPFxuICBSZWFjdC5Db21wb25lbnRQcm9wczxcImFcIj5cbj4ge1xuICBjb25zdCBMaW5rID0gUmVhY3QudXNlQ29udGV4dChQbGFzbWljTGlua0NvbnRleHQpO1xuICBpZiAoTGluaykge1xuICAgIHJldHVybiBMaW5rO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBBbmNob3JMaW5rIGFzIFJlYWN0LkNvbXBvbmVudFR5cGU8UmVhY3QuQ29tcG9uZW50UHJvcHM8XCJhXCI+PjtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gUGxhc21pY0xpbmtQcm92aWRlcihwcm9wczoge1xuICBMaW5rOiBSZWFjdC5Db21wb25lbnRUeXBlPGFueT4gfCB1bmRlZmluZWQ7XG4gIGNoaWxkcmVuPzogUmVhY3QuUmVhY3ROb2RlO1xufSkge1xuICBjb25zdCB7IExpbmssIGNoaWxkcmVuIH0gPSBwcm9wcztcbiAgcmV0dXJuIChcbiAgICA8UGxhc21pY0xpbmtDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtMaW5rfT5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L1BsYXNtaWNMaW5rQ29udGV4dC5Qcm92aWRlcj5cbiAgKTtcbn1cbiIsImltcG9ydCB7IENvZGVDb21wb25lbnRFbGVtZW50LCBDU1NQcm9wZXJ0aWVzIH0gZnJvbSBcIi4vZWxlbWVudC10eXBlc1wiO1xuaW1wb3J0IHtcbiAgQ29udGV4dERlcGVuZGVudENvbmZpZyxcbiAgSW5mZXJEYXRhVHlwZSxcbiAgUHJvamVjdERhdGEsXG4gIFByb3BUeXBlLFxuICBSZXN0cmljdFByb3BUeXBlLFxuICBTdHVkaW9PcHMsXG59IGZyb20gXCIuL3Byb3AtdHlwZXNcIjtcbmltcG9ydCB7IFR1cGxlVW5pb24gfSBmcm9tIFwiLi90eXBlLXV0aWxzXCI7XG5leHBvcnQgdHlwZSAqIGZyb20gXCIuL3Byb3AtdHlwZXNcIjtcblxuY29uc3Qgcm9vdCA9IGdsb2JhbFRoaXMgYXMgYW55O1xuXG5leHBvcnQgaW50ZXJmYWNlIEFjdGlvblByb3BzPFA+IHtcbiAgY29tcG9uZW50UHJvcHM6IFA7XG4gIC8qKlxuICAgKiBgY29udGV4dERhdGFgIGNhbiBiZSBgbnVsbGAgaWYgdGhlIHByb3AgY29udHJvbHMgYXJlIHJlbmRlcmluZyBiZWZvcmVcbiAgICogdGhlIGNvbXBvbmVudCBpbnN0YW5jZSBpdHNlbGYgKGl0IHdpbGwgcmUtcmVuZGVyIG9uY2UgdGhlIGNvbXBvbmVudFxuICAgKiBjYWxscyBgc2V0Q29udHJvbENvbnRleHREYXRhYClcbiAgICovXG4gIGNvbnRleHREYXRhOiBJbmZlckRhdGFUeXBlPFA+IHwgbnVsbDtcbiAgLyoqXG4gICAqIE9wZXJhdGlvbnMgYXZhaWxhYmxlIHRvIHRoZSBlZGl0b3IgdGhhdCBhbGxvdyBtb2RpZnlpbmcgdGhlIGVudGlyZSBjb21wb25lbnQuXG4gICAqL1xuICBzdHVkaW9PcHM6IFN0dWRpb09wcztcbiAgLyoqXG4gICAqIE1ldGFkYXRhIGZyb20gdGhlIHN0dWRpbyBwcm9qZWN0LlxuICAgKi9cbiAgcHJvamVjdERhdGE6IFByb2plY3REYXRhO1xuICAvKipcbiAgICogVGhlIGRvY3VtZW50IHRoYXQgdGhlIGNvbXBvbmVudCB3aWxsIGJlIHJlbmRlcmVkIGludG87IGluc3RlYWQgb2YgdXNpbmdcbiAgICogYGRvY3VtZW50YCBkaXJlY3RseSAoZm9yLCBzYXksIGBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKClgIGV0Yy4pLCB5b3VcbiAgICogc2hvdWxkIHVzZSB0aGlzIGluc3RlYWQuXG4gICAqL1xuICBzdHVkaW9Eb2N1bWVudDogdHlwZW9mIGRvY3VtZW50O1xufVxuXG5leHBvcnQgdHlwZSBBY3Rpb248UD4gPVxuICB8IHtcbiAgICAgIHR5cGU6IFwiYnV0dG9uLWFjdGlvblwiO1xuICAgICAgbGFiZWw6IHN0cmluZztcbiAgICAgIG9uQ2xpY2s6IChwcm9wczogQWN0aW9uUHJvcHM8UD4pID0+IHZvaWQ7XG4gICAgICBoaWRkZW4/OiBDb250ZXh0RGVwZW5kZW50Q29uZmlnPFAsIGJvb2xlYW4+O1xuICAgIH1cbiAgfCB7XG4gICAgICB0eXBlOiBcImN1c3RvbS1hY3Rpb25cIjtcbiAgICAgIGNvbnRyb2w6IFJlYWN0LkNvbXBvbmVudFR5cGU8QWN0aW9uUHJvcHM8UD4+O1xuICAgICAgaGlkZGVuPzogQ29udGV4dERlcGVuZGVudENvbmZpZzxQLCBib29sZWFuPjtcbiAgICB9O1xuXG50eXBlIERpc3RyaWJ1dGVkS2V5T2Y8VD4gPSBUIGV4dGVuZHMgYW55ID8ga2V5b2YgVCA6IG5ldmVyO1xuXG5pbnRlcmZhY2UgQ29tcG9uZW50VGVtcGxhdGU8UD5cbiAgZXh0ZW5kcyBPbWl0PENvZGVDb21wb25lbnRFbGVtZW50PFA+LCBcInR5cGVcIiB8IFwibmFtZVwiPiB7XG4gIC8qKlxuICAgKiBBIHByZXZpZXcgcGljdHVyZSBmb3IgdGhlIHRlbXBsYXRlLlxuICAgKi9cbiAgcHJldmlld0ltZz86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb21wb25lbnRUZW1wbGF0ZXM8UD4ge1xuICBbbmFtZTogc3RyaW5nXTogQ29tcG9uZW50VGVtcGxhdGU8UD47XG59XG5cbmV4cG9ydCB0eXBlIFN0YXRlU3BlYzxQPiA9IHtcbiAgb25DaGFuZ2VQcm9wOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIElmIHRydWUsIHdpbGwgaGlkZSB0aGUgc3RhdGUgb24gc3R1ZGlvLlxuICAgKi9cbiAgaGlkZGVuPzogQ29udGV4dERlcGVuZGVudENvbmZpZzxQLCBib29sZWFuPjtcblxuICAvKipcbiAgICogSWYgdHJ1ZSwgd2lsbCBoaWRlIHRoZSBzdGF0ZSBpbiBhIGNvbGxhcHNlZCBzZWN0aW9uOyBnb29kIGZvciBzdGF0ZXMgdGhhdFxuICAgKiBzaG91bGQgbm90IHVzdWFsbHkgYmUgdXNlZC5cbiAgICovXG4gIGFkdmFuY2VkPzogQ29udGV4dERlcGVuZGVudENvbmZpZzxQLCBib29sZWFuPjtcbn0gJiAoXG4gIHwge1xuICAgICAgdHlwZTogXCJyZWFkb25seVwiO1xuICAgICAgdmFyaWFibGVUeXBlOiBcInRleHRcIjtcbiAgICAgIGluaXRWYWw/OiBzdHJpbmc7XG4gICAgfVxuICB8IHtcbiAgICAgIHR5cGU6IFwicmVhZG9ubHlcIjtcbiAgICAgIHZhcmlhYmxlVHlwZTogXCJudW1iZXJcIjtcbiAgICAgIGluaXRWYWw/OiBudW1iZXI7XG4gICAgfVxuICB8IHtcbiAgICAgIHR5cGU6IFwicmVhZG9ubHlcIjtcbiAgICAgIHZhcmlhYmxlVHlwZTogXCJib29sZWFuXCI7XG4gICAgICBpbml0VmFsPzogYm9vbGVhbjtcbiAgICB9XG4gIHwge1xuICAgICAgdHlwZTogXCJyZWFkb25seVwiO1xuICAgICAgdmFyaWFibGVUeXBlOiBcImFycmF5XCI7XG4gICAgICBpbml0VmFsPzogYW55W107XG4gICAgfVxuICB8IHtcbiAgICAgIHR5cGU6IFwicmVhZG9ubHlcIjtcbiAgICAgIHZhcmlhYmxlVHlwZTogXCJvYmplY3RcIjtcbiAgICAgIGluaXRWYWw/OiBvYmplY3Q7XG4gICAgfVxuICB8IHtcbiAgICAgIHR5cGU6IFwicmVhZG9ubHlcIjtcbiAgICAgIHZhcmlhYmxlVHlwZTogXCJkYXRlU3RyaW5nXCI7XG4gICAgICBpbml0VmFsPzogc3RyaW5nO1xuICAgIH1cbiAgfCB7XG4gICAgICB0eXBlOiBcInJlYWRvbmx5XCI7XG4gICAgICB2YXJpYWJsZVR5cGU6IFwiZGF0ZVJhbmdlU3RyaW5nc1wiO1xuICAgICAgaW5pdFZhbD86IFtzdHJpbmcsIHN0cmluZ107XG4gICAgfVxuICB8IHtcbiAgICAgIHR5cGU6IFwid3JpdGFibGVcIjtcbiAgICAgIHZhcmlhYmxlVHlwZTpcbiAgICAgICAgfCBcInRleHRcIlxuICAgICAgICB8IFwibnVtYmVyXCJcbiAgICAgICAgfCBcImJvb2xlYW5cIlxuICAgICAgICB8IFwiYXJyYXlcIlxuICAgICAgICB8IFwib2JqZWN0XCJcbiAgICAgICAgfCBcImRhdGVTdHJpbmdcIlxuICAgICAgICB8IFwiZGF0ZVJhbmdlU3RyaW5nc1wiO1xuICAgICAgdmFsdWVQcm9wOiBzdHJpbmc7XG4gICAgfVxuKTtcblxuZXhwb3J0IGludGVyZmFjZSBTdGF0ZUhlbHBlcnM8UCwgVD4ge1xuICBpbml0RnVuYz86ICgkcHJvcHM6IFApID0+IFQ7XG4gIG9uQ2hhbmdlQXJnc1RvVmFsdWU/OiAoLi4uYXJnczogYW55KSA9PiBUO1xuICBvbk11dGF0ZT86IChzdGF0ZVZhbHVlOiBULCAkcmVmOiBhbnkpID0+IHZvaWQ7XG59XG5cbi8vIEEgY29tcGlsZS10aW1lIGVycm9yIHdpbGwgb2NjdXIgaWYgYSBuZXcgZmllbGQgaXMgYWRkZWQgdG8gdGhlIFN0YXRlSGVscGVyXG4vLyBpbnRlcmZhY2UgYnV0IG5vdCBpbmNsdWRlZCBpbiB0aGUga2V5cyBhcnJheSBvZiBzdGF0ZSBoZWxwZXIuXG5leHBvcnQgY29uc3Qgc3RhdGVIZWxwZXJzS2V5czogVHVwbGVVbmlvbjxrZXlvZiBTdGF0ZUhlbHBlcnM8YW55LCBhbnk+PiA9IFtcbiAgXCJpbml0RnVuY1wiLFxuICBcIm9uQ2hhbmdlQXJnc1RvVmFsdWVcIixcbiAgXCJvbk11dGF0ZVwiLFxuXTtcblxuZXhwb3J0IHR5cGUgQ29tcG9uZW50SGVscGVyczxQPiA9IHtcbiAgc3RhdGVzOiBSZWNvcmQ8c3RyaW5nLCBTdGF0ZUhlbHBlcnM8UCwgYW55Pj47XG59O1xuXG5leHBvcnQgdHlwZSBFeHRlcm5hbENvbXBvbmVudEhlbHBlcnM8UD4gPSB7XG4gIGhlbHBlcnM6IENvbXBvbmVudEhlbHBlcnM8UD47XG4gIGltcG9ydFBhdGg6IHN0cmluZztcbn0gJiAoXG4gIHwge1xuICAgICAgaW1wb3J0TmFtZTogc3RyaW5nO1xuICAgIH1cbiAgfCB7XG4gICAgICBpc0RlZmF1bHRFeHBvcnQ6IHRydWU7XG4gICAgfVxuKTtcblxuZXhwb3J0IHR5cGUgU3R5bGVTZWN0aW9uID1cbiAgfCBcInZpc2liaWxpdHlcIlxuICB8IFwidHlwb2dyYXBoeVwiXG4gIHwgXCJzaXppbmdcIlxuICB8IFwic3BhY2luZ1wiXG4gIHwgXCJiYWNrZ3JvdW5kXCJcbiAgfCBcInRyYW5zZm9ybVwiXG4gIHwgXCJ0cmFuc2l0aW9uc1wiXG4gIHwgXCJsYXlvdXRcIlxuICB8IFwib3ZlcmZsb3dcIlxuICB8IFwiYm9yZGVyXCJcbiAgfCBcInNoYWRvd3NcIlxuICB8IFwiZWZmZWN0c1wiO1xuXG5leHBvcnQgaW50ZXJmYWNlIENvZGVDb21wb25lbnRNZXRhPFA+IHtcbiAgLyoqXG4gICAqIEFueSB1bmlxdWUgc3RyaW5nIG5hbWUgdXNlZCB0byBpZGVudGlmeSB0aGF0IGNvbXBvbmVudC4gRWFjaCBjb21wb25lbnRcbiAgICogc2hvdWxkIGJlIHJlZ2lzdGVyZWQgd2l0aCBhIGRpZmZlcmVudCBgbWV0YS5uYW1lYCwgZXZlbiBpZiB0aGV5IGhhdmUgdGhlXG4gICAqIHNhbWUgbmFtZSBpbiB0aGUgY29kZS5cbiAgICovXG4gIG5hbWU6IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSBuYW1lIHRvIGJlIGRpc3BsYXllZCBmb3IgdGhlIGNvbXBvbmVudCBpbiBTdHVkaW8uIE9wdGlvbmFsOiBpZiBub3RcbiAgICogc3BlY2lmaWVkLCBgbWV0YS5uYW1lYCBpcyB1c2VkLlxuICAgKi9cbiAgZGlzcGxheU5hbWU/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgZGVzY3JpcHRpb24gb2YgdGhlIGNvbXBvbmVudCB0byBiZSBzaG93biBpbiBTdHVkaW8uXG4gICAqL1xuICBkZXNjcmlwdGlvbj86IHN0cmluZztcbiAgLyoqXG4gICAqIEEgc3BlY2lmaWMgc2VjdGlvbiB0byB3aGljaCB0aGUgY29tcG9uZW50IHNob3VsZCBiZSBkaXNwbGF5ZWQgaW4gU3R1ZGlvLiBCeSBkZWZhdWx0LCB0aGUgY29tcG9uZW50IHdpbGwgYmUgZGlzcGxheWVkIGluIHRoZSBcIkN1c3RvbSBDb21wb25lbnRzXCIgc2VjdGlvbi5cbiAgICogQSBuZXcgc2VjdGlvbiB3aWxsIGJlIGNyZWF0ZWQgdG8gZGlzcGxheSB0aGUgY29tcG9uZW50cyB3aXRoIHRoZSBzYW1lIGBzZWN0aW9uYCB2YWx1ZS5cbiAgICovXG4gIHNlY3Rpb24/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBBIGxpbmsgdG8gYW4gaW1hZ2UgdGhhdCB3aWxsIGJlIGRpc3BsYXllZCBhcyBhIHRodW1ibmFpbCBvZiB0aGUgY29tcG9uZW50IGluIHRoZSBTdHVkaW8sIGlmIHRoZSBjb21wb25lbnQgaGFzIGEgYHNlY3Rpb25gIHNwZWNpZmllZC5cbiAgICovXG4gIHRodW1ibmFpbFVybD86IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSBqYXZhc2NyaXB0IG5hbWUgdG8gYmUgdXNlZCB3aGVuIGdlbmVyYXRpbmcgY29kZS4gT3B0aW9uYWw6IGlmIG5vdFxuICAgKiBwcm92aWRlZCwgYG1ldGEubmFtZWAgaXMgdXNlZC5cbiAgICovXG4gIGltcG9ydE5hbWU/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBBbiBvYmplY3QgZGVzY3JpYmluZyB0aGUgY29tcG9uZW50IHByb3BlcnRpZXMgdG8gYmUgdXNlZCBpbiBTdHVkaW8uXG4gICAqIEZvciBlYWNoIGBwcm9wYCwgdGhlcmUgc2hvdWxkIGJlIGFuIGVudHJ5IGBtZXRhLnByb3BzW3Byb3BdYCBkZXNjcmliaW5nXG4gICAqIGl0cyB0eXBlLlxuICAgKi9cbiAgcHJvcHM6IHsgW3Byb3AgaW4gRGlzdHJpYnV0ZWRLZXlPZjxQPl0/OiBSZXN0cmljdFByb3BUeXBlPFBbcHJvcF0sIFA+IH0gJiB7XG4gICAgW3Byb3A6IHN0cmluZ106IFByb3BUeXBlPFA+O1xuICB9O1xuICAvKipcbiAgICogQW4gb2JqZWN0IGRlc2NyaWJpbmcgdGhlIGNvbXBvbmVudCBzdGF0ZXMgdG8gYmUgdXNlZCBpbiBTdHVkaW8uXG4gICAqL1xuICBzdGF0ZXM/OiBSZWNvcmQ8c3RyaW5nLCBTdGF0ZVNwZWM8UD4+O1xuICAvKipcbiAgICogQW4gb2JqZWN0IGRlc2NyaWJpbmcgdGhlIGNvbXBvbmVudHMgaGVscGVycyB0byBiZSB1c2VkIGluIFN0dWRpby5cbiAgICogICAxLiBzdGF0ZXMgaGVscGVyczogRWFjaCBzdGF0ZSBjYW4gcmVjZWl2ZSBhbiBcImluaXRGdW5jXCIgcHJvcCB0byBpbml0aWFsaXplXG4gICAqICAgICAgdGhlIGltcGxpY2l0IHN0YXRlIGluIFN0dWRpbywgYW5kIGFuIFwib25DaGFuZ2VBcmdzVG9WYWx1ZVwiIHByb3AgdG9cbiAgICogICAgICB0cmFuc2Zvcm0gdGhlIGV2ZW50IGhhbmRsZXIgYXJndW1lbnRzIGludG8gYSB2YWx1ZVxuICAgKi9cbiAgY29tcG9uZW50SGVscGVycz86IEV4dGVybmFsQ29tcG9uZW50SGVscGVyczxQPjtcbiAgLyoqXG4gICAqIEFuIGFycmF5IGRlc2NyaWJpbmcgdGhlIGNvbXBvbmVudCBhY3Rpb25zIHRvIGJlIHVzZWQgaW4gU3R1ZGlvLlxuICAgKi9cbiAgYWN0aW9ucz86IEFjdGlvbjxQPltdO1xuICAvKipcbiAgICogV2hldGhlciBzdHlsZSBzZWN0aW9ucyBzaG91bGQgYmUgc2hvd24gaW4gU3R1ZGlvLiBGb3Igc3R5bGVzIHRvIHdvcmssIHRoZVxuICAgKiBjb21wb25lbnQgbXVzdCBhY2NlcHQgYSBgY2xhc3NOYW1lYCBwcm9wLiBJZiB1bnNldCwgZGVmYXVsdHMgdG8gYWxsIHN0eWxlcy5cbiAgICogU2V0IHRvIGBmYWxzZWAgaWYgdGhpcyBjb21wb25lbnQgY2Fubm90IGJlIHN0eWxlZCAoZm9yIGV4YW1wbGUsIGlmIGl0IGRvZXNuJ3RcbiAgICogcmVuZGVyIGFueSBET00gZWxlbWVudHMpLlxuICAgKi9cbiAgc3R5bGVTZWN0aW9ucz86IFN0eWxlU2VjdGlvbltdIHwgYm9vbGVhbjtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIGVsZW1lbnQgY2FuIGJlIHJlcGVhdGVkIGluIFN0dWRpby4gSWYgdW5zZXQsIGRlZmF1bHRzIHRvIHRydWUuXG4gICAqL1xuICBpc1JlcGVhdGFibGU/OiBib29sZWFuO1xuICAvKipcbiAgICogVGhlIHBhdGggdG8gYmUgdXNlZCB3aGVuIGltcG9ydGluZyB0aGUgY29tcG9uZW50IGluIHRoZSBnZW5lcmF0ZWQgY29kZS5cbiAgICogSXQgY2FuIGJlIHRoZSBuYW1lIG9mIHRoZSBwYWNrYWdlIHRoYXQgY29udGFpbnMgdGhlIGNvbXBvbmVudCwgb3IgdGhlIHBhdGhcbiAgICogdG8gdGhlIGZpbGUgaW4gdGhlIHByb2plY3QgKHJlbGF0aXZlIHRvIHRoZSByb290IGRpcmVjdG9yeSkuXG4gICAqL1xuICBpbXBvcnRQYXRoOiBzdHJpbmc7XG4gIC8qKlxuICAgKiAgV2hldGhlciB0aGUgY29tcG9uZW50IGlzIHRoZSBkZWZhdWx0IGV4cG9ydCBmcm9tIHRoYXQgcGF0aC4gT3B0aW9uYWw6IGlmXG4gICAqIG5vdCBzcGVjaWZpZWQsIGl0J3MgY29uc2lkZXJlZCBgZmFsc2VgLlxuICAgKi9cbiAgaXNEZWZhdWx0RXhwb3J0PzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIFRoZSBwcm9wIHRoYXQgZXhwZWN0cyB0aGUgQ1NTIGNsYXNzZXMgd2l0aCBzdHlsZXMgdG8gYmUgYXBwbGllZCB0byB0aGVcbiAgICogY29tcG9uZW50LiBPcHRpb25hbDogaWYgbm90IHNwZWNpZmllZCwgUGxhc21pYyB3aWxsIGV4cGVjdCBpdCB0byBiZVxuICAgKiBgY2xhc3NOYW1lYC4gTm90aWNlIHRoYXQgaWYgdGhlIGNvbXBvbmVudCBkb2VzIG5vdCBhY2NlcHQgQ1NTIGNsYXNzZXMsIHRoZVxuICAgKiBjb21wb25lbnQgd2lsbCBub3QgYmUgYWJsZSB0byByZWNlaXZlIHN0eWxlcyBmcm9tIHRoZSBTdHVkaW8uXG4gICAqL1xuICBjbGFzc05hbWVQcm9wPzogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIHByb3AgdGhhdCByZWNlaXZlcyBhbmQgZm9yd2FyZHMgYSBSZWFjdCBgcmVmYC4gUGxhc21pYyBvbmx5IHVzZXMgYHJlZmBcbiAgICogdG8gaW50ZXJhY3Qgd2l0aCBjb21wb25lbnRzLCBzbyBpdCdzIG5vdCB1c2VkIGluIHRoZSBnZW5lcmF0ZWQgY29kZS5cbiAgICogT3B0aW9uYWw6IElmIG5vdCBwcm92aWRlZCwgdGhlIHVzdWFsIGByZWZgIGlzIHVzZWQuXG4gICAqL1xuICByZWZQcm9wPzogc3RyaW5nO1xuICAvKipcbiAgICogRGVmYXVsdCBzdHlsZXMgdG8gc3RhcnQgd2l0aCB3aGVuIGluc3RhbnRpYXRpbmcgdGhlIGNvbXBvbmVudCBpbiBQbGFzbWljLlxuICAgKi9cbiAgZGVmYXVsdFN0eWxlcz86IENTU1Byb3BlcnRpZXM7XG4gIC8qKlxuICAgKiBDb21wb25lbnQgdGVtcGxhdGVzIHRvIHN0YXJ0IHdpdGggb24gUGxhc21pYy5cbiAgICovXG4gIHRlbXBsYXRlcz86IENvbXBvbmVudFRlbXBsYXRlczxQPjtcbiAgLyoqXG4gICAqIFJlZ2lzdGVyZWQgbmFtZSBvZiBwYXJlbnQgY29tcG9uZW50LCB1c2VkIGZvciBncm91cGluZyByZWxhdGVkIGNvbXBvbmVudHMuXG4gICAqL1xuICBwYXJlbnRDb21wb25lbnROYW1lPzogc3RyaW5nO1xuICAvKipcbiAgICogV2hldGhlciB0aGUgY29tcG9uZW50IGNhbiBiZSB1c2VkIGFzIGFuIGF0dGFjaG1lbnQgdG8gYW4gZWxlbWVudC5cbiAgICovXG4gIGlzQXR0YWNobWVudD86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBjb21wb25lbnQgcHJvdmlkZXMgZGF0YSB0byBpdHMgc2xvdHMgdXNpbmcgRGF0YVByb3ZpZGVyLlxuICAgKi9cbiAgcHJvdmlkZXNEYXRhPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogSWYgc3BlY2lmaWVkLCB0aGVuIEZpZ21hIGNvbXBvbmVudHMgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWVzIHdpbGwgYmUgbWFwcGVkXG4gICAqIHRvIHRoaXMgY29tcG9uZW50IHdoZW4geW91IHBhc3RlIEZpZ21hIGNvbnRlbnQgaW50byBQbGFzbWljXG4gICAqL1xuICBmaWdtYU1hcHBpbmdzPzoge1xuICAgIGZpZ21hQ29tcG9uZW50TmFtZTogc3RyaW5nO1xuICB9W107XG5cbiAgLyoqXG4gICAqIElmIHNwZWNpZmllZCwgdGhlbiBGaWdtYSBjb21wb25lbnRzIHdpbGwgaGF2ZSB0aGVpciBwcm9wZXJ0aWVzIHRyYW5zZm9ybWVkXG4gICAqIGJlZm9yZSBiZWluZyBhcHBsaWVkIHRvIHRoaXMgY29tcG9uZW50LiBUaGlzIGlzIHVzZWZ1bCBmb3IgdHJhbnNmb3JtaW5nIEZpZ21hXG4gICAqIHByb3BlcnRpZXMgdG8gdGhlIGZvcm1hdCBleHBlY3RlZCBieSB0aGUgY29tcG9uZW50LlxuICAgKi9cbiAgZmlnbWFQcm9wc1RyYW5zZm9ybT86IChcbiAgICBwcm9wczogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbj5cbiAgKSA9PiBSZWNvcmQ8XG4gICAgc3RyaW5nLFxuICAgIHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBudWxsIHwgdW5rbm93bltdIHwgUmVjb3JkPHN0cmluZywgdW5rbm93bj5cbiAgPjtcblxuICAvKipcbiAgICogSWYgdHJ1ZSwgd2hlbiBhbiBpbnN0YW5jZSBvZiB0aGlzIGNvbXBvbmVudCBpcyBhZGRlZCwgdGhlIGVsZW1lbnRcbiAgICogd2lsbCBhbHdheXMgYmUgbmFtZWQgYnkgdGhlIG5hbWUgb2YgdGhpcyBjb21wb25lbnQuXG4gICAqL1xuICBhbHdheXNBdXRvTmFtZT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIElmIHRydWUsIHRoZW4gd29uJ3QgYmUgbGlzdGVkIGluIHRoZSBpbnNlcnQgbWVudSBmb3IgY29udGVudCBjcmVhdG9ycy5cbiAgICovXG4gIGhpZGVGcm9tQ29udGVudENyZWF0b3JzPzogYm9vbGVhbjtcblxuICByZWZBY3Rpb25zPzogUmVjb3JkPHN0cmluZywgUmVmQWN0aW9uUmVnaXN0cmF0aW9uPFA+PjtcblxuICAvKipcbiAgICogT3B0aW9uYWwgZnVuY3Rpb24gdGhhdCB0YWtlcyBpbiBjb21wb25lbnQgcHJvcHMgYW5kIGNvbnRleHQsIGFuZCByZXR1cm5zXG4gICAqIGEgc3RyaW5nIHRoYXQgd2lsbCBiZSB1c2VkIGZvciBsYWJlbGluZyB0aGlzIGVsZW1lbnQgaW4gdGhlIE91dGxpbmUgcGFuZWxcbiAgICogb24gdGhlIGxlZnQgb2YgdGhlIFN0dWRpby4gIFRoaXMgbWFrZXMgaXQgZWFzeSB0byBpZGVudGlmeSBhbiBlbGVtZW50IHdoZW5cbiAgICogbG9va2luZyBhdCB0aGUgdHJlZS5cbiAgICovXG4gIHRyZWVMYWJlbD86IENvbnRleHREZXBlbmRlbnRDb25maWc8UCwgc3RyaW5nPjtcblxuICAvKipcbiAgICogVGhlIHZhbHVlIG9mIHRoZSBDU1MgZGlzcGxheSBwcm9wZXJ0eSB1c2VkIGJ5IHRoaXMgY29tcG9uZW50LlxuICAgKiBQbGFzbWljIHBhc3NlcyBpbiBhIGNsYXNzIG5hbWUgcHJvcCB0byBjb21wb25lbnRzIHRvIGxldCB1c2VycyBzdHlsZSB0aGVtLFxuICAgKiBidXQgbm9ybWFsbHkgdGhpcyBkb2VzIG5vdCBpbmNsdWRlIGxheW91dCBwcm9wZXJ0aWVzIGxpa2UgZGlzcGxheS5cbiAgICogSG93ZXZlciwgaWYgdGhlIHVzZXIgaGFzIHNldCB0aGUgY29tcG9uZW50cyB2aXNpYmlsaXR5IHRvIGJlIHZpc2libGVcbiAgICogKGZvciBpbnN0YW5jZSwgaW4gdGhlIGJhc2UgdmFyaWFudCBpdCB3YXMgc2V0IHRvIG5vdCB2aXNpYmxlIGllIGRpc3BsYXkgbm9uZSxcbiAgICogYnV0IGluIGEgdmFyaWFudCBpdCdzIG92ZXJyaWRkZW4gdG8gYmUgdmlzaWJsZSksIHRoZW4gUGxhc21pYyBuZWVkcyB0byBrbm93XG4gICAqIHdoYXQgZGlzcGxheSBwcm9wZXJ0eSB0byBzZXQuXG4gICAqIERlZmF1bHRzIHRvIFwiZmxleFwiLlxuICAgKi9cbiAgZGVmYXVsdERpc3BsYXk/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFdoZW4gdHJ1ZSwgd2hlbiB5b3UgY2xpY2sgZm9yIHRoZSBmaXJzdCB0aW1lIGFueXdoZXJlIGluIHRoZSBjb21wb25lbnQgaW5jbHVkaW5nIGl0cyBzbG90cywgdGhlIGNvbXBvbmVudCBpdHNlbGYgaXNcbiAgICogc2VsZWN0ZWQsIG1ha2luZyBpdCBlYXNpZXIgdG8gc2VsZWN0IHRoZSBjb21wb25lbnQgaW5zdGVhZCBvZiBzbG90IGNvbnRlbnRzLiBTbyBmb3IgaW5zdGFuY2UsIHNldHRpbmcgdGhpcyBvbiBhXG4gICAqIEJ1dHRvbiBlbnN1cmVzIHRoYXQgY2xpY2tpbmcgb24gdGhlIEJ1dHRvbuKAmXMgdGV4dCB3aWxsIHN0aWxsIHNlbGVjdCB0aGUgQnV0dG9uIGFuZCBub3QgdGhlIHRleHQgZWxlbWVudCBpbiBpdHNcbiAgICogc2xvdC4gQ2xpY2tpbmcgYWdhaW4gd2lsbCBkZWVwLXNlbGVjdCB0aGUgc2xvdCBjb250ZW50LlxuICAgKi9cbiAgdHJhcHNGb2N1cz86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEFuIG9iamVjdCByZWdpc3RlcmluZyBjb2RlIGNvbXBvbmVudCdzIHZhcmlhbnRzIHRoYXQgc2hvdWxkIGJlIGFsbG93ZWQgaW4gU3R1ZGlvLCB3aGVuIHRoZSBjb21wb25lbnQgaXNcbiAgICogdXNlZCBhcyB0aGUgcm9vdCBvZiBhIFN0dWRpbyBjb21wb25lbnQuXG4gICAqL1xuICB2YXJpYW50cz86IFJlY29yZDxcbiAgICBzdHJpbmcsXG4gICAge1xuICAgICAgY3NzU2VsZWN0b3I6IHN0cmluZztcbiAgICAgIGRpc3BsYXlOYW1lOiBzdHJpbmc7XG4gICAgfVxuICA+O1xufVxuXG5leHBvcnQgdHlwZSBDb2RlQ29tcG9uZW50TW9kZSA9XG4gIHwgXCJhZHZhbmNlZFwiXG4gIHwgXCJzaW1wbGlmaWVkXCJcbiAgfCBcImRhdGFiYXNlLXNjaGVtYS1kcml2ZW5cIjtcblxuLyoqXG4gKiBAZGVwcmVjYXRlZCB1c2UgQ29kZUNvbXBvbmVudE1ldGEgaW5zdGVhZFxuICovXG5leHBvcnQgdHlwZSBDb21wb25lbnRNZXRhPFA+ID0gQ29kZUNvbXBvbmVudE1ldGE8UD47XG5cbmV4cG9ydCBpbnRlcmZhY2UgRnVuY3Rpb25QYXJhbTxQPiB7XG4gIG5hbWU6IHN0cmluZztcbiAgZGlzcGxheU5hbWU/OiBzdHJpbmc7XG4gIHR5cGU6IFByb3BUeXBlPFA+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlZkFjdGlvblJlZ2lzdHJhdGlvbjxQPiB7XG4gIGRpc3BsYXlOYW1lPzogc3RyaW5nO1xuICBkZXNjcmlwdGlvbj86IHN0cmluZztcbiAgYXJnVHlwZXM6IEZ1bmN0aW9uUGFyYW08UD5bXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb21wb25lbnRSZWdpc3RyYXRpb24ge1xuICBjb21wb25lbnQ6IFJlYWN0LkNvbXBvbmVudFR5cGU8YW55PjtcbiAgbWV0YTogQ29kZUNvbXBvbmVudE1ldGE8YW55Pjtcbn1cblxuZGVjbGFyZSBnbG9iYWwge1xuICBpbnRlcmZhY2UgV2luZG93IHtcbiAgICBfX1BsYXNtaWNDb21wb25lbnRSZWdpc3RyeTogQ29tcG9uZW50UmVnaXN0cmF0aW9uW107XG4gIH1cbn1cblxuaWYgKHJvb3QuX19QbGFzbWljQ29tcG9uZW50UmVnaXN0cnkgPT0gbnVsbCkge1xuICByb290Ll9fUGxhc21pY0NvbXBvbmVudFJlZ2lzdHJ5ID0gW107XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlZ2lzdGVyQ29tcG9uZW50PFQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnRUeXBlPGFueT4+KFxuICBjb21wb25lbnQ6IFQsXG4gIG1ldGE6IENvZGVDb21wb25lbnRNZXRhPFJlYWN0LkNvbXBvbmVudFByb3BzPFQ+PlxuKSB7XG4gIC8vIENoZWNrIGZvciBkdXBsaWNhdGVzXG4gIGlmIChcbiAgICByb290Ll9fUGxhc21pY0NvbXBvbmVudFJlZ2lzdHJ5LnNvbWUoXG4gICAgICAocjogQ29tcG9uZW50UmVnaXN0cmF0aW9uKSA9PlxuICAgICAgICByLmNvbXBvbmVudCA9PT0gY29tcG9uZW50ICYmIHIubWV0YS5uYW1lID09PSBtZXRhLm5hbWVcbiAgICApXG4gICkge1xuICAgIHJldHVybjtcbiAgfVxuICByb290Ll9fUGxhc21pY0NvbXBvbmVudFJlZ2lzdHJ5LnB1c2goeyBjb21wb25lbnQsIG1ldGEgfSk7XG59XG4iLCJjb25zdCByb290ID0gZ2xvYmFsVGhpcyBhcyBhbnk7XG5cbmV4cG9ydCB0eXBlIFN0cmluZ1R5cGU8VCBleHRlbmRzIHN0cmluZyA9IHN0cmluZz4gPSBcInN0cmluZ1wiIHwgYCcke1R9J2A7XG5cbmV4cG9ydCB0eXBlIE51bWJlclR5cGU8VCBleHRlbmRzIG51bWJlciA9IG51bWJlcj4gPVxuICB8IFwibnVtYmVyXCJcbiAgfCBgJHtudW1iZXIgZXh0ZW5kcyBUID8gbnVtYmVyIDogVH1gO1xuXG5leHBvcnQgdHlwZSBCb29sZWFuVHlwZTxUIGV4dGVuZHMgYm9vbGVhbiA9IGJvb2xlYW4+ID1cbiAgfCBcImJvb2xlYW5cIlxuICB8IGAke2Jvb2xlYW4gZXh0ZW5kcyBUID8gYm9vbGVhbiA6IFR9YDtcblxuZXhwb3J0IHR5cGUgTnVsbFR5cGUgPSBcIm51bGxcIjtcblxuZXhwb3J0IHR5cGUgVW5kZWZpbmVkVHlwZSA9IFwidW5kZWZpbmVkXCI7XG5cbmV4cG9ydCB0eXBlIEFycmF5VHlwZSA9IFwiYXJyYXlcIjtcblxuZXhwb3J0IHR5cGUgT2JqZWN0VHlwZSA9IFwib2JqZWN0XCI7XG5cbmV4cG9ydCB0eXBlIEFueVR5cGUgPSBcImFueVwiO1xuXG5leHBvcnQgdHlwZSBWb2lkVHlwZSA9IFwidm9pZFwiO1xuXG5leHBvcnQgdHlwZSBSZXN0cmljdGVkVHlwZTxUPiA9IFQgZXh0ZW5kcyBzdHJpbmdcbiAgPyBTdHJpbmdUeXBlPFQ+XG4gIDogVCBleHRlbmRzIG51bWJlclxuICA/IE51bWJlclR5cGU8VD5cbiAgOiBUIGV4dGVuZHMgYm9vbGVhblxuICA/IEJvb2xlYW5UeXBlPFQ+XG4gIDogVCBleHRlbmRzIG51bGxcbiAgPyBOdWxsVHlwZVxuICA6IFQgZXh0ZW5kcyB1bmRlZmluZWRcbiAgPyBVbmRlZmluZWRUeXBlXG4gIDogVCBleHRlbmRzIEFycmF5PGFueT5cbiAgPyBBcnJheVR5cGVcbiAgOiBUIGV4dGVuZHMgb2JqZWN0XG4gID8gT2JqZWN0VHlwZVxuICA6IEFueVR5cGU7XG5cbmV4cG9ydCB0eXBlIE9yVHlwZTxUPiA9IFJlc3RyaWN0ZWRUeXBlPFQ+W107XG5cbmV4cG9ydCB0eXBlIFBhcmFtVHlwZTxUPiA9IEFueVR5cGUgfCBSZXN0cmljdGVkVHlwZTxUPiB8IE9yVHlwZTxUPjtcblxuZXhwb3J0IGludGVyZmFjZSBCYXNlUGFyYW08VD4ge1xuICBuYW1lOiBzdHJpbmc7XG4gIHR5cGU/OiBQYXJhbVR5cGU8VD47XG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuICBpc09wdGlvbmFsPzogYm9vbGVhbjtcbiAgaXNSZXN0UGFyYW0/OiBib29sZWFuO1xufVxuXG4vLyBQYXJhbSBuYW1lIGFuZCBvcHRpb25hbGx5IHBhcmFtIHR5cGVcbmV4cG9ydCBpbnRlcmZhY2UgUmVxdWlyZWRQYXJhbTxUPiBleHRlbmRzIEJhc2VQYXJhbTxUPiB7XG4gIGlzT3B0aW9uYWw/OiBmYWxzZTtcbiAgaXNSZXN0UGFyYW1ldGVyPzogZmFsc2U7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3B0aW9uYWxQYXJhbTxUPiBleHRlbmRzIEJhc2VQYXJhbTxUIHwgdW5kZWZpbmVkPiB7XG4gIGlzUmVzdFBhcmFtZXRlcj86IGZhbHNlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlc3RQYXJhbTxUPiBleHRlbmRzIEJhc2VQYXJhbTxUPiB7XG4gIGlzT3B0aW9uYWw/OiBmYWxzZTtcbiAgaXNSZXN0UGFyYW1ldGVyOiB0cnVlO1xufVxuXG4vLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83MDY4NDAzMC9yZW1vdmUtYWxsLW9wdGlvbmFsLWl0ZW1zLWZyb20tYS10dXBsZS10eXBlXG50eXBlIFJlcXVpcmVkUGFyYW1zPFxuICBUIGV4dGVuZHMgYW55W10sXG4gIFUgZXh0ZW5kcyBhbnlbXSA9IFtdXG4+ID0gUGFydGlhbDxUPiBleHRlbmRzIFRcbiAgPyBVXG4gIDogVCBleHRlbmRzIFtpbmZlciBGLCAuLi5pbmZlciBSXVxuICA/IFJlcXVpcmVkUGFyYW1zPFIsIFsuLi5VLCBGXT5cbiAgOiBVO1xuXG50eXBlIE9wdGlvbmFsUGFyYW1zPFQgZXh0ZW5kcyBhbnlbXT4gPSBUIGV4dGVuZHMgW1xuICAuLi5SZXF1aXJlZFBhcmFtczxUPixcbiAgLi4uaW5mZXIgUlxuXVxuICA/IFsuLi5SXVxuICA6IFtdO1xuXG50eXBlIEhhbmRsZVJlcXVpcmVkUGFyYW1zPFAgZXh0ZW5kcyBhbnlbXT4gPSBQIGV4dGVuZHMgW2luZmVyIEgsIC4uLmluZmVyIFRdXG4gID8gW3N0cmluZyB8IFJlcXVpcmVkUGFyYW08SD4sIC4uLkhhbmRsZVJlcXVpcmVkUGFyYW1zPFQ+XVxuICA6IFtdO1xuXG50eXBlIEhhbmRsZU9wdGlvbmFsUGFyYW1zPFAgZXh0ZW5kcyBhbnlbXT4gPSBQIGV4dGVuZHMgW2luZmVyIEgsIC4uLmluZmVyIFRdXG4gID8gW10gfCBbc3RyaW5nIHwgT3B0aW9uYWxQYXJhbTxIIHwgdW5kZWZpbmVkPiwgLi4uSGFuZGxlT3B0aW9uYWxQYXJhbXM8VD5dXG4gIDogUCBleHRlbmRzIFtdXG4gID8gW11cbiAgOiBQIGV4dGVuZHMgQXJyYXk8aW5mZXIgVD5cbiAgPyBbXSB8IFtSZXN0UGFyYW08VFtdPl1cbiAgOiBbXTtcblxuZXhwb3J0IHR5cGUgSGFuZGxlUGFyYW1zPFAgZXh0ZW5kcyBhbnlbXT4gPSBbXG4gIC4uLkhhbmRsZVJlcXVpcmVkUGFyYW1zPFJlcXVpcmVkUGFyYW1zPFA+PixcbiAgLi4uSGFuZGxlT3B0aW9uYWxQYXJhbXM8UmVxdWlyZWQ8T3B0aW9uYWxQYXJhbXM8UD4+PlxuXTtcblxuZXhwb3J0IHR5cGUgSGFuZGxlUmV0dXJuVHlwZTxUPiA9IFZvaWRUeXBlIHwgUGFyYW1UeXBlPFQ+O1xuXG5leHBvcnQgaW50ZXJmYWNlIEN1c3RvbUZ1bmN0aW9uTWV0YTxGIGV4dGVuZHMgKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnk+IHtcbiAgLyoqXG4gICAqIFRoZSBqYXZhc2NyaXB0IG5hbWUgb2YgdGhlIGZ1bmN0aW9uLiBOb3RpY2UgaXQgbXVzdCBiZSB1bmlxdWUgYWNyb3NzIGFsbFxuICAgKiBvdGhlciBmdW5jdGlvbnMgYW5kIGZ1bmN0aW9uIG5hbWVzcGFjZXMuIElmIHR3byBmdW5jdGlvbnMgaGF2ZSB0aGUgc2FtZVxuICAgKiBuYW1lLCB0aGV5IHNob3VsZCBiZSByZWdpc3RlcmVkIHdpdGggZGlmZmVyZW50IGBtZXRhLm5hbWVzcGFjZWAuXG4gICAqL1xuICBuYW1lOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBBIG5hbWVzcGFjZSBmb3Igb3JnYW5pemluZyBncm91cHMgb2YgZnVuY3Rpb25zLiBJdCdzIGFsc28gdXNlZCB0byBoYW5kbGVcbiAgICogZnVuY3Rpb24gbmFtZSBjb2xsaXNpb25zLiBJZiBhIGZ1bmN0aW9uIGhhcyBhIG5hbWVzcGFjZSwgaXQgd2lsbCBiZSB1c2VkXG4gICAqIHdoZW5ldmVyIGFjY2Vzc2luZyB0aGUgZnVuY3Rpb24uXG4gICAqL1xuICBuYW1lc3BhY2U/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBEb2N1bWVudGF0aW9uIGZvciB0aGUgcmVnaXN0ZXJlZCBmdW5jdGlvbi5cbiAgICovXG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuICAvKipcbiAgICogQW4gYXJyYXkgY29udGFpbmluZyB0aGUgbGlzdCBvZiBwYXJhbWV0ZXJzIG5hbWVzIHRoZSBmdW5jdGlvbiB0YWtlcy5cbiAgICogT3B0aW9uYWxseSB0aGV5IGNhbiBhbHNvIGJlIHJlZ2lzdGVyZWQgd2l0aCB0aGUgZXhwZWN0ZWQgcGFyYW0gdHlwZXMuXG4gICAqL1xuICBwYXJhbXM/OiBIYW5kbGVQYXJhbXM8UGFyYW1ldGVyczxGPj47XG4gIC8qKlxuICAgKiBSZXR1cm4gdmFsdWUgaW5mb3JtYXRpb24uXG4gICAqL1xuICByZXR1cm5WYWx1ZT86IHtcbiAgICAvKipcbiAgICAgKiBUaGUgZnVuY3Rpb24gcmV0dXJuIHR5cGUuXG4gICAgICovXG4gICAgdHlwZT86IEhhbmRsZVJldHVyblR5cGU8UmV0dXJuVHlwZTxGPj47XG4gICAgLyoqXG4gICAgICogVGhlIGZ1bmN0aW9uIHJldHVybiB2YWx1ZSBkZXNjcmlwdGlvbi5cbiAgICAgKi9cbiAgICBkZXNjcmlwdGlvbj86IHN0cmluZztcbiAgfTtcbiAgLyoqXG4gICAqIFR5cGVzY3JpcHQgZnVuY3Rpb24gZGVjbGFyYXRpb24uIElmIHNwZWNpZmllZCwgaXQgaWdub3JlcyB0aGUgdHlwZXNcbiAgICogcHJvdmlkZWQgYnkgYHBhcmFtc2AgYW5kIGByZXR1cm5WYWx1ZWAuXG4gICAqL1xuICB0eXBlc2NyaXB0RGVjbGFyYXRpb24/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgcGF0aCB0byBiZSB1c2VkIHdoZW4gaW1wb3J0aW5nIHRoZSBmdW5jdGlvbiBpbiB0aGUgZ2VuZXJhdGVkIGNvZGUuXG4gICAqIEl0IGNhbiBiZSB0aGUgbmFtZSBvZiB0aGUgcGFja2FnZSB0aGF0IGNvbnRhaW5zIHRoZSBmdW5jdGlvbiwgb3IgdGhlIHBhdGhcbiAgICogdG8gdGhlIGZpbGUgaW4gdGhlIHByb2plY3QgKHJlbGF0aXZlIHRvIHRoZSByb290IGRpcmVjdG9yeSkuXG4gICAqL1xuICBpbXBvcnRQYXRoOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBmdW5jdGlvbiBpcyB0aGUgZGVmYXVsdCBleHBvcnQgZnJvbSB0aGF0IHBhdGguIE9wdGlvbmFsOiBpZlxuICAgKiBub3Qgc3BlY2lmaWVkLCBpdCdzIGNvbnNpZGVyZWQgYGZhbHNlYC5cbiAgICovXG4gIGlzRGVmYXVsdEV4cG9ydD86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ3VzdG9tRnVuY3Rpb25SZWdpc3RyYXRpb24ge1xuICBmdW5jdGlvbjogKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnk7XG4gIG1ldGE6IEN1c3RvbUZ1bmN0aW9uTWV0YTxhbnk+O1xufVxuXG5kZWNsYXJlIGdsb2JhbCB7XG4gIGludGVyZmFjZSBXaW5kb3cge1xuICAgIF9fUGxhc21pY0Z1bmN0aW9uc1JlZ2lzdHJ5OiBDdXN0b21GdW5jdGlvblJlZ2lzdHJhdGlvbltdO1xuICB9XG59XG5cbmlmIChyb290Ll9fUGxhc21pY0Z1bmN0aW9uc1JlZ2lzdHJ5ID09IG51bGwpIHtcbiAgcm9vdC5fX1BsYXNtaWNGdW5jdGlvbnNSZWdpc3RyeSA9IFtdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZWdpc3RlckZ1bmN0aW9uPEYgZXh0ZW5kcyAoLi4uYXJnczogYW55W10pID0+IGFueT4oXG4gIGZuOiBGLFxuICBtZXRhOiBDdXN0b21GdW5jdGlvbk1ldGE8Rj5cbikge1xuICAvLyBDaGVjayBmb3IgZHVwbGljYXRlc1xuICBpZiAoXG4gICAgcm9vdC5fX1BsYXNtaWNGdW5jdGlvbnNSZWdpc3RyeS5zb21lKFxuICAgICAgKHI6IEN1c3RvbUZ1bmN0aW9uUmVnaXN0cmF0aW9uKSA9PlxuICAgICAgICByLmZ1bmN0aW9uID09PSBmbiAmJlxuICAgICAgICByLm1ldGEubmFtZSA9PT0gbWV0YS5uYW1lICYmXG4gICAgICAgIHIubWV0YS5uYW1lc3BhY2UgPT0gbWV0YS5uYW1lc3BhY2VcbiAgICApXG4gICkge1xuICAgIHJldHVybjtcbiAgfVxuICByb290Ll9fUGxhc21pY0Z1bmN0aW9uc1JlZ2lzdHJ5LnB1c2goeyBmdW5jdGlvbjogZm4sIG1ldGEgfSk7XG59XG4iLCJpbXBvcnQge1xuICBCb29sZWFuVHlwZSxcbiAgQ2hvaWNlVHlwZSxcbiAgQ3VzdG9tVHlwZSxcbiAgRGF0YVNvdXJjZVR5cGUsXG4gIEpTT05MaWtlVHlwZSxcbiAgTnVtYmVyVHlwZSxcbiAgU3RyaW5nVHlwZSxcbn0gZnJvbSBcIi4vcHJvcC10eXBlc1wiO1xuaW1wb3J0IHsgRnVuY3Rpb25QYXJhbSB9IGZyb20gXCIuL3JlZ2lzdGVyQ29tcG9uZW50XCI7XG5cbmNvbnN0IHJvb3QgPSBnbG9iYWxUaGlzIGFzIGFueTtcblxuLy8gVXNpbmcganVzdCBhIHN1YnNldCBvZiB0eXBlcyBmcm9tIHByb3AtdHlwZXNcbmV4cG9ydCB0eXBlIFByb3BUeXBlPFA+ID1cbiAgfCBTdHJpbmdUeXBlPFA+XG4gIHwgQm9vbGVhblR5cGU8UD5cbiAgfCBOdW1iZXJUeXBlPFA+XG4gIHwgSlNPTkxpa2VUeXBlPFA+XG4gIHwgQ2hvaWNlVHlwZTxQPlxuICB8IERhdGFTb3VyY2VUeXBlPFA+XG4gIHwgQ3VzdG9tVHlwZTxQPjtcblxudHlwZSBSZXN0cmljdFByb3BUeXBlPFQsIFA+ID0gVCBleHRlbmRzIHN0cmluZ1xuICA/IFN0cmluZ1R5cGU8UD4gfCBDaG9pY2VUeXBlPFA+IHwgSlNPTkxpa2VUeXBlPFA+IHwgQ3VzdG9tVHlwZTxQPlxuICA6IFQgZXh0ZW5kcyBib29sZWFuXG4gID8gQm9vbGVhblR5cGU8UD4gfCBKU09OTGlrZVR5cGU8UD4gfCBDdXN0b21UeXBlPFA+XG4gIDogVCBleHRlbmRzIG51bWJlclxuICA/IE51bWJlclR5cGU8UD4gfCBKU09OTGlrZVR5cGU8UD4gfCBDdXN0b21UeXBlPFA+XG4gIDogUHJvcFR5cGU8UD47XG5cbnR5cGUgRGlzdHJpYnV0ZWRLZXlPZjxUPiA9IFQgZXh0ZW5kcyBhbnkgPyBrZXlvZiBUIDogbmV2ZXI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2xvYmFsQ29udGV4dE1ldGE8UD4ge1xuICAvKipcbiAgICogQW55IHVuaXF1ZSBzdHJpbmcgbmFtZSB1c2VkIHRvIGlkZW50aWZ5IHRoYXQgY29udGV4dC4gRWFjaCBjb250ZXh0XG4gICAqIHNob3VsZCBiZSByZWdpc3RlcmVkIHdpdGggYSBkaWZmZXJlbnQgYG1ldGEubmFtZWAsIGV2ZW4gaWYgdGhleSBoYXZlIHRoZVxuICAgKiBzYW1lIG5hbWUgaW4gdGhlIGNvZGUuXG4gICAqL1xuICBuYW1lOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgbmFtZSB0byBiZSBkaXNwbGF5ZWQgZm9yIHRoZSBjb250ZXh0IGluIFN0dWRpby4gT3B0aW9uYWw6IGlmIG5vdFxuICAgKiBzcGVjaWZpZWQsIGBtZXRhLm5hbWVgIGlzIHVzZWQuXG4gICAqL1xuICBkaXNwbGF5TmFtZT86IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgY29udGV4dCB0byBiZSBzaG93biBpbiBTdHVkaW8uXG4gICAqL1xuICBkZXNjcmlwdGlvbj86IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSBqYXZhc2NyaXB0IG5hbWUgdG8gYmUgdXNlZCB3aGVuIGdlbmVyYXRpbmcgY29kZS4gT3B0aW9uYWw6IGlmIG5vdFxuICAgKiBwcm92aWRlZCwgYG1ldGEubmFtZWAgaXMgdXNlZC5cbiAgICovXG4gIGltcG9ydE5hbWU/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBBbiBvYmplY3QgZGVzY3JpYmluZyB0aGUgY29udGV4dCBwcm9wZXJ0aWVzIHRvIGJlIHVzZWQgaW4gU3R1ZGlvLlxuICAgKiBGb3IgZWFjaCBgcHJvcGAsIHRoZXJlIHNob3VsZCBiZSBhbiBlbnRyeSBgbWV0YS5wcm9wc1twcm9wXWAgZGVzY3JpYmluZ1xuICAgKiBpdHMgdHlwZS5cbiAgICovXG4gIHByb3BzOiB7IFtwcm9wIGluIERpc3RyaWJ1dGVkS2V5T2Y8UD5dPzogUmVzdHJpY3RQcm9wVHlwZTxQW3Byb3BdLCBQPiB9ICYge1xuICAgIFtwcm9wOiBzdHJpbmddOiBQcm9wVHlwZTxQPjtcbiAgfTtcbiAgLyoqXG4gICAqIFRoZSBwYXRoIHRvIGJlIHVzZWQgd2hlbiBpbXBvcnRpbmcgdGhlIGNvbnRleHQgaW4gdGhlIGdlbmVyYXRlZCBjb2RlLlxuICAgKiBJdCBjYW4gYmUgdGhlIG5hbWUgb2YgdGhlIHBhY2thZ2UgdGhhdCBjb250YWlucyB0aGUgY29udGV4dCwgb3IgdGhlIHBhdGhcbiAgICogdG8gdGhlIGZpbGUgaW4gdGhlIHByb2plY3QgKHJlbGF0aXZlIHRvIHRoZSByb290IGRpcmVjdG9yeSkuXG4gICAqL1xuICBpbXBvcnRQYXRoOiBzdHJpbmc7XG4gIC8qKlxuICAgKiAgV2hldGhlciB0aGUgY29udGV4dCBpcyB0aGUgZGVmYXVsdCBleHBvcnQgZnJvbSB0aGF0IHBhdGguIE9wdGlvbmFsOiBpZlxuICAgKiBub3Qgc3BlY2lmaWVkLCBpdCdzIGNvbnNpZGVyZWQgYGZhbHNlYC5cbiAgICovXG4gIGlzRGVmYXVsdEV4cG9ydD86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBUaGUgcHJvcCB0aGF0IHJlY2VpdmVzIGFuZCBmb3J3YXJkcyBhIFJlYWN0IGByZWZgLiBQbGFzbWljIG9ubHkgdXNlcyBgcmVmYFxuICAgKiB0byBpbnRlcmFjdCB3aXRoIGNvbXBvbmVudHMsIHNvIGl0J3Mgbm90IHVzZWQgaW4gdGhlIGdlbmVyYXRlZCBjb2RlLlxuICAgKiBPcHRpb25hbDogSWYgbm90IHByb3ZpZGVkLCB0aGUgdXN1YWwgYHJlZmAgaXMgdXNlZC5cbiAgICovXG4gIHJlZlByb3A/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBnbG9iYWwgY29udGV4dCBwcm92aWRlcyBkYXRhIHRvIGl0cyBjaGlsZHJlbiB1c2luZyBEYXRhUHJvdmlkZXIuXG4gICAqL1xuICBwcm92aWRlc0RhdGE/OiBib29sZWFuO1xuXG4gIGdsb2JhbEFjdGlvbnM/OiBSZWNvcmQ8c3RyaW5nLCBHbG9iYWxBY3Rpb25SZWdpc3RyYXRpb248UD4+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdsb2JhbENvbnRleHRSZWdpc3RyYXRpb24ge1xuICBjb21wb25lbnQ6IFJlYWN0LkNvbXBvbmVudFR5cGU8YW55PjtcbiAgbWV0YTogR2xvYmFsQ29udGV4dE1ldGE8YW55Pjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHbG9iYWxBY3Rpb25SZWdpc3RyYXRpb248UD4ge1xuICBkaXNwbGF5TmFtZT86IHN0cmluZztcbiAgZGVzY3JpcHRpb24/OiBzdHJpbmc7XG4gIHBhcmFtZXRlcnM6IEZ1bmN0aW9uUGFyYW08UD5bXTtcbn1cblxuZGVjbGFyZSBnbG9iYWwge1xuICBpbnRlcmZhY2UgV2luZG93IHtcbiAgICBfX1BsYXNtaWNDb250ZXh0UmVnaXN0cnk6IEdsb2JhbENvbnRleHRSZWdpc3RyYXRpb25bXTtcbiAgfVxufVxuXG5pZiAocm9vdC5fX1BsYXNtaWNDb250ZXh0UmVnaXN0cnkgPT0gbnVsbCkge1xuICByb290Ll9fUGxhc21pY0NvbnRleHRSZWdpc3RyeSA9IFtdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZWdpc3Rlckdsb2JhbENvbnRleHQ8XG4gIFQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnRUeXBlPGFueT5cbj4oY29tcG9uZW50OiBULCBtZXRhOiBHbG9iYWxDb250ZXh0TWV0YTxSZWFjdC5Db21wb25lbnRQcm9wczxUPj4pIHtcbiAgLy8gQ2hlY2sgZm9yIGR1cGxpY2F0ZXNcbiAgaWYgKFxuICAgIHJvb3QuX19QbGFzbWljQ29udGV4dFJlZ2lzdHJ5LnNvbWUoXG4gICAgICAocjogR2xvYmFsQ29udGV4dFJlZ2lzdHJhdGlvbikgPT5cbiAgICAgICAgci5jb21wb25lbnQgPT09IGNvbXBvbmVudCAmJiByLm1ldGEubmFtZSA9PT0gbWV0YS5uYW1lXG4gICAgKVxuICApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcm9vdC5fX1BsYXNtaWNDb250ZXh0UmVnaXN0cnkucHVzaCh7IGNvbXBvbmVudCwgbWV0YSB9KTtcbn1cbiIsImV4cG9ydCB0eXBlIFRva2VuVHlwZSA9XG4gIHwgXCJjb2xvclwiXG4gIHwgXCJzcGFjaW5nXCJcbiAgfCBcImZvbnQtZmFtaWx5XCJcbiAgfCBcImZvbnQtc2l6ZVwiXG4gIHwgXCJsaW5lLWhlaWdodFwiXG4gIHwgXCJvcGFjaXR5XCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVG9rZW5SZWdpc3RyYXRpb24ge1xuICAvKipcbiAgICogTmFtZSBmb3IgdGhpcyB0b2tlbjsgc2hvdWxkIGJlIHN0YWJsZSBhY3Jvc3MgdXBkYXRlc1xuICAgKi9cbiAgbmFtZTogc3RyaW5nO1xuICAvKipcbiAgICogVmFsdWUgZm9yIHRoZSB0b2tlbiwgd2hpY2ggY2FuIGVpdGhlciBiZSBhIHZhbGlkIGNzcyB2YWx1ZSBvciBhIGNzcyByZWZlcmVuY2VcbiAgICogdG8gYSBjc3MgdmFyaWFibGUgcHJvdmlkZWQgYnkgeW91ciBob3N0IGFwcCwgbGlrZSBgdmFyKC0tbXktdG9rZW4pYFxuICAgKi9cbiAgdmFsdWU6IHN0cmluZztcbiAgLyoqXG4gICAqIFR5cGUgb2YgdG9rZW5cbiAgICovXG4gIHR5cGU6IFRva2VuVHlwZTtcbiAgLyoqXG4gICAqIE9wdGlvbmFsIGRpc3BsYXkgbmFtZSB0byB1c2UgZm9yIHRoaXMgdG9rZW4sIGlmIHlvdSdkIGxpa2UgdG8gdXNlIGEgZnJpZW5kbGllclxuICAgKiBuYW1lIHRvIGRpc3BsYXkgdG8gU3R1ZGlvIHVzZXJzXG4gICAqL1xuICBkaXNwbGF5TmFtZT86IHN0cmluZztcbiAgLyoqXG4gICAqIEJ5IGRlZmF1bHQsIGlmIHRoaXMgdG9rZW4gaXMgYSBjc3MgdmFyaWFibGUgcmVmZXJlbmNlIGxpa2UgYHZhcigtLW15LXRva2VuKWAsXG4gICAqIHRoZW4gaXQgaXMgYXNzdW1lZCB0aGF0IGAtLW15LXRva2VuYCBpcyBkZWZpbmVkIG9uIGA6cm9vdGAuICBJZiBpdCBpcyBkZWZpbmVkXG4gICAqIGluIGFub3RoZXIgZWxlbWVudCwgdGhlbiB5b3UgY2FuIHBhc3MgaW4gYSBzZWxlY3RvciBmb3IgdGhhdCBlbGVtZW50LFxuICAgKiBsaWtlIGAudGhlbWVSb290YC5cbiAgICovXG4gIHNlbGVjdG9yPzogc3RyaW5nO1xufVxuXG5kZWNsYXJlIGdsb2JhbCB7XG4gIGludGVyZmFjZSBXaW5kb3cge1xuICAgIF9fUGxhc21pY1Rva2VuUmVnaXN0cnk6IFRva2VuUmVnaXN0cmF0aW9uW107XG4gIH1cbn1cblxuY29uc3Qgcm9vdCA9IGdsb2JhbFRoaXMgYXMgYW55O1xuXG5pZiAocm9vdC5fX1BsYXNtaWNUb2tlblJlZ2lzdHJ5ID09IG51bGwpIHtcbiAgcm9vdC5fX1BsYXNtaWNUb2tlblJlZ2lzdHJ5ID0gW107XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlZ2lzdGVyVG9rZW4odG9rZW46IFRva2VuUmVnaXN0cmF0aW9uKSB7XG4gIHJvb3QuX19QbGFzbWljVG9rZW5SZWdpc3RyeS5wdXNoKHRva2VuKTtcbn1cbiIsImNvbnN0IHJvb3QgPSBnbG9iYWxUaGlzIGFzIGFueTtcblxuZXhwb3J0IGludGVyZmFjZSBCYXNpY1RyYWl0IHtcbiAgbGFiZWw/OiBzdHJpbmc7XG4gIHR5cGU6IFwidGV4dFwiIHwgXCJudW1iZXJcIiB8IFwiYm9vbGVhblwiO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENob2ljZVRyYWl0IHtcbiAgbGFiZWw/OiBzdHJpbmc7XG4gIHR5cGU6IFwiY2hvaWNlXCI7XG4gIG9wdGlvbnM6IHN0cmluZ1tdO1xufVxuXG5leHBvcnQgdHlwZSBUcmFpdE1ldGEgPSBCYXNpY1RyYWl0IHwgQ2hvaWNlVHJhaXQ7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhaXRSZWdpc3RyYXRpb24ge1xuICB0cmFpdDogc3RyaW5nO1xuICBtZXRhOiBUcmFpdE1ldGE7XG59XG5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgaW50ZXJmYWNlIFdpbmRvdyB7XG4gICAgX19QbGFzbWljVHJhaXRSZWdpc3RyeTogVHJhaXRSZWdpc3RyYXRpb25bXTtcbiAgfVxufVxuXG5pZiAocm9vdC5fX1BsYXNtaWNUcmFpdFJlZ2lzdHJ5ID09IG51bGwpIHtcbiAgcm9vdC5fX1BsYXNtaWNUcmFpdFJlZ2lzdHJ5ID0gW107XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlZ2lzdGVyVHJhaXQodHJhaXQ6IHN0cmluZywgbWV0YTogVHJhaXRNZXRhKSB7XG4gIHJvb3QuX19QbGFzbWljVHJhaXRSZWdpc3RyeS5wdXNoKHtcbiAgICB0cmFpdCxcbiAgICBtZXRhLFxuICB9KTtcbn1cbiIsImltcG9ydCB7IGNsb25lRWxlbWVudCwgaXNWYWxpZEVsZW1lbnQgfSBmcm9tIFwicmVhY3RcIjtcblxuLyoqXG4gKiBBbGxvd3MgZWxlbWVudHMgdG8gYmUgcmVwZWF0ZWQgaW4gUGxhc21pYyBTdHVkaW8uXG4gKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBjb3B5IChzdGFydGluZyBhdCAwKS5cbiAqIEBwYXJhbSBlbHQgdGhlIFJlYWN0IGVsZW1lbnQgdG8gYmUgcmVwZWF0ZWQgKG9yIGFuIGFycmF5IG9mIHN1Y2gpLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZXBlYXRlZEVsZW1lbnQ8VD4oaW5kZXg6IG51bWJlciwgZWx0OiBUKTogVDtcbi8qKlxuICogQWxsb3dzIGVsZW1lbnRzIHRvIGJlIHJlcGVhdGVkIGluIFBsYXNtaWMgU3R1ZGlvLlxuICogQHBhcmFtIGlzUHJpbWFyeSBzaG91bGQgYmUgdHJ1ZSBmb3IgYXQgbW9zdCBvbmUgaW5zdGFuY2Ugb2YgdGhlIGVsZW1lbnQsIGFuZFxuICogaW5kaWNhdGVzIHdoaWNoIGNvcHkgb2YgdGhlIGVsZW1lbnQgd2lsbCBiZSBoaWdobGlnaHRlZCB3aGVuIHRoZSBlbGVtZW50IGlzXG4gKiBzZWxlY3RlZCBpbiBTdHVkaW8uXG4gKiBAcGFyYW0gZWx0IHRoZSBSZWFjdCBlbGVtZW50IHRvIGJlIHJlcGVhdGVkIChvciBhbiBhcnJheSBvZiBzdWNoKS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVwZWF0ZWRFbGVtZW50PFQ+KGlzUHJpbWFyeTogYm9vbGVhbiwgZWx0OiBUKTogVDtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlcGVhdGVkRWxlbWVudDxUPihpbmRleDogYm9vbGVhbiB8IG51bWJlciwgZWx0OiBUKTogVCB7XG4gIHJldHVybiByZXBlYXRlZEVsZW1lbnRGbihpbmRleCBhcyBhbnksIGVsdCk7XG59XG5cbmxldCByZXBlYXRlZEVsZW1lbnRGbjogdHlwZW9mIHJlcGVhdGVkRWxlbWVudCA9IChcbiAgaW5kZXg6IGJvb2xlYW4gfCBudW1iZXIsXG4gIGVsdDogYW55XG4pID0+IHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZWx0KSkge1xuICAgIHJldHVybiBlbHQubWFwKCh2KSA9PiByZXBlYXRlZEVsZW1lbnRGbihpbmRleCBhcyBhbnksIHYpKSBhcyBhbnk7XG4gIH1cbiAgaWYgKGVsdCAmJiBpc1ZhbGlkRWxlbWVudChlbHQpICYmIHR5cGVvZiBlbHQgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gY2xvbmVFbGVtZW50KGVsdCkgYXMgYW55O1xuICB9XG4gIHJldHVybiBlbHQ7XG59O1xuXG5jb25zdCByb290ID0gZ2xvYmFsVGhpcyBhcyBhbnk7XG5leHBvcnQgY29uc3Qgc2V0UmVwZWF0ZWRFbGVtZW50Rm46IChmbjogdHlwZW9mIHJlcGVhdGVkRWxlbWVudCkgPT4gdm9pZCA9XG4gIHJvb3Q/Ll9fU3ViPy5zZXRSZXBlYXRlZEVsZW1lbnRGbiA/P1xuICBmdW5jdGlvbiAoZm46IHR5cGVvZiByZXBlYXRlZEVsZW1lbnQpIHtcbiAgICByZXBlYXRlZEVsZW1lbnRGbiA9IGZuO1xuICB9O1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuXG5leHBvcnQgdHlwZSBQbGFzbWljVHJhbnNsYXRvciA9IChcbiAgc3RyOiBzdHJpbmcsXG4gIG9wdHM/OiB7XG4gICAgY29tcG9uZW50cz86IHtcbiAgICAgIFtrZXk6IHN0cmluZ106IFJlYWN0LlJlYWN0RWxlbWVudDtcbiAgICB9O1xuICB9XG4pID0+IFJlYWN0LlJlYWN0Tm9kZTtcblxuZXhwb3J0IGludGVyZmFjZSBQbGFzbWljSTE4TkNvbnRleHRWYWx1ZSB7XG4gIHRyYW5zbGF0b3I/OiBQbGFzbWljVHJhbnNsYXRvcjtcbiAgdGFnUHJlZml4Pzogc3RyaW5nO1xufVxuXG5leHBvcnQgY29uc3QgUGxhc21pY1RyYW5zbGF0b3JDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dDxcbiAgUGxhc21pY0kxOE5Db250ZXh0VmFsdWUgfCBQbGFzbWljVHJhbnNsYXRvciB8IHVuZGVmaW5lZFxuPih1bmRlZmluZWQpO1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlUGxhc21pY1RyYW5zbGF0b3IoKSB7XG4gIGNvbnN0IF90ID0gUmVhY3QudXNlQ29udGV4dChQbGFzbWljVHJhbnNsYXRvckNvbnRleHQpO1xuICBjb25zdCB0cmFuc2xhdG9yID0gX3RcbiAgICA/IHR5cGVvZiBfdCA9PT0gXCJmdW5jdGlvblwiXG4gICAgICA/IF90XG4gICAgICA6IF90LnRyYW5zbGF0b3JcbiAgICA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIHRyYW5zbGF0b3I7XG59XG4iLCJleHBvcnQgY29uc3QgaG9zdFZlcnNpb24gPSBcIjEuMC4yMDhcIjtcbiIsImltcG9ydCAqIGFzIFBsYXNtaWNRdWVyeSBmcm9tIFwiQHBsYXNtaWNhcHAvcXVlcnlcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0ICogYXMgUmVhY3RET00gZnJvbSBcInJlYWN0LWRvbVwiO1xuaW1wb3J0IHsgcmVnaXN0ZXJSZW5kZXJFcnJvckxpc3RlbmVyLCBzZXRQbGFzbWljUm9vdE5vZGUgfSBmcm9tIFwiLi9jYW52YXMtaG9zdFwiO1xuaW1wb3J0ICogYXMgaG9zdE1vZHVsZSBmcm9tIFwiLi9leHBvcnRzXCI7XG5pbXBvcnQgeyBzZXRSZXBlYXRlZEVsZW1lbnRGbiB9IGZyb20gXCIuL3JlcGVhdGVkRWxlbWVudFwiO1xuLy8gdmVyc2lvbi50cyBpcyBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBieSBgeWFybiBidWlsZGAgYW5kIG5vdCBjb21taXR0ZWQuXG5pbXBvcnQgeyBob3N0VmVyc2lvbiB9IGZyb20gXCIuL3ZlcnNpb25cIjtcblxuLy8gQWxsIGV4cG9ydHMgbXVzdCBjb21lIGZyb20gXCIuL2V4cG9ydHNcIlxuZXhwb3J0ICogZnJvbSBcIi4vZXhwb3J0c1wiO1xuXG5jb25zdCByb290ID0gZ2xvYmFsVGhpcyBhcyBhbnk7XG5cbmlmIChyb290Ll9fU3ViID09IG51bGwpIHtcbiAgLy8gQ3JlYXRpbmcgYSBzaWRlIGVmZmVjdCBoZXJlIGJ5IGxvZ2dpbmcsIHNvIHRoYXQgdml0ZSB3b24ndFxuICAvLyBpZ25vcmUgdGhpcyBibG9jayBmb3Igd2hhdGV2ZXIgcmVhc29uLiBIaWRpbmcgdGhpcyBmb3Igbm93XG4gIC8vIGFzIHVzZXJzIGFyZSBjb21wbGFpbmluZzsgd2lsbCBoYXZlIHRvIGNoZWNrIGlmIHRoaXMgaGFzXG4gIC8vIGJlZW4gZml4ZWQgd2l0aCB2aXRlLlxuICAvLyBjb25zb2xlLmxvZyhcIlBsYXNtaWM6IFNldHRpbmcgdXAgYXBwIGhvc3QgZGVwZW5kZW5jaWVzXCIpO1xuICByb290Ll9fU3ViID0ge1xuICAgIFJlYWN0LFxuICAgIFJlYWN0RE9NLFxuICAgIFBsYXNtaWNRdWVyeSxcbiAgICBob3N0TW9kdWxlLFxuICAgIGhvc3RWZXJzaW9uLFxuICAgIGhvc3RVdGlsczoge1xuICAgICAgc2V0UGxhc21pY1Jvb3ROb2RlLFxuICAgICAgcmVnaXN0ZXJSZW5kZXJFcnJvckxpc3RlbmVyLFxuICAgICAgc2V0UmVwZWF0ZWRFbGVtZW50Rm4sXG4gICAgfSxcblxuICAgIC8vIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eTpcbiAgICBzZXRQbGFzbWljUm9vdE5vZGUsXG4gICAgcmVnaXN0ZXJSZW5kZXJFcnJvckxpc3RlbmVyLFxuICAgIHNldFJlcGVhdGVkRWxlbWVudEZuLFxuICAgIC4uLmhvc3RNb2R1bGUsXG4gIH07XG59IGVsc2Uge1xuICBjb25zb2xlLndhcm4oXG4gICAgYEVuY291bnRlcmVkIGxpa2VseSBkdXBsaWNhdGUgaG9zdCB2ZXJzaW9uOiAke3Jvb3QuX19TdWIuaG9zdFZlcnNpb259IHZzICR7aG9zdFZlcnNpb259YFxuICApO1xuICByb290Ll9fU3ViLmR1cGxpY2F0ZUhvc3RWZXJzaW9ucyA9IHJvb3QuX19TdWIuZHVwbGljYXRlSG9zdFZlcnNpb25zID8/IFtdO1xuICByb290Ll9fU3ViLmR1cGxpY2F0ZUhvc3RWZXJzaW9ucy5wdXNoKGhvc3RWZXJzaW9uKTtcbn1cbiJdLCJuYW1lcyI6WyJSZWFjdCIsInJvb3QiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@plasmicapp/host/dist/host.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@plasmicapp/isomorphic-unfetch/browser.js":
/*!****************************************************************!*\
  !*** ./node_modules/@plasmicapp/isomorphic-unfetch/browser.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("module.exports = self.fetch || (self.fetch = (__webpack_require__(/*! unfetch */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/fetch/index.js\")[\"default\"]) || __webpack_require__(/*! unfetch */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/fetch/index.js\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcGxhc21pY2FwcC9pc29tb3JwaGljLXVuZmV0Y2gvYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiQUFBQSw2Q0FBNkMsOEhBQTBCLElBQUksbUJBQU8sQ0FBQyw0RkFBUyIsInNvdXJjZXMiOlsiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvV29uZGVyVml0ZS1mcm9udGVuZC9ub2RlX21vZHVsZXMvQHBsYXNtaWNhcHAvaXNvbW9ycGhpYy11bmZldGNoL2Jyb3dzZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBzZWxmLmZldGNoIHx8IChzZWxmLmZldGNoID0gcmVxdWlyZSgndW5mZXRjaCcpLmRlZmF1bHQgfHwgcmVxdWlyZSgndW5mZXRjaCcpKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@plasmicapp/isomorphic-unfetch/browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@plasmicapp/loader-core/dist/index.esm.js":
/*!****************************************************************!*\
  !*** ./node_modules/@plasmicapp/loader-core/dist/index.esm.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Api: () => (/* reexport safe */ _plasmicapp_loader_fetcher__WEBPACK_IMPORTED_MODULE_0__.Api),\n/* harmony export */   PlasmicModulesFetcher: () => (/* reexport safe */ _plasmicapp_loader_fetcher__WEBPACK_IMPORTED_MODULE_0__.PlasmicModulesFetcher),\n/* harmony export */   PlasmicTracker: () => (/* binding */ PlasmicTracker),\n/* harmony export */   Registry: () => (/* binding */ Registry),\n/* harmony export */   getBundleSubset: () => (/* binding */ getBundleSubset)\n/* harmony export */ });\n/* harmony import */ var _plasmicapp_loader_fetcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @plasmicapp/loader-fetcher */ \"(app-pages-browser)/./node_modules/@plasmicapp/loader-fetcher/dist/index.esm.js\");\n/* harmony import */ var _plasmicapp_isomorphic_unfetch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @plasmicapp/isomorphic-unfetch */ \"(app-pages-browser)/./node_modules/@plasmicapp/isomorphic-unfetch/browser.js\");\n/* harmony import */ var _plasmicapp_isomorphic_unfetch__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_plasmicapp_isomorphic_unfetch__WEBPACK_IMPORTED_MODULE_1__);\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// src/index.ts\n\n\n// src/deps-graph.ts\nvar DepsGraph = class {\n  constructor(bundle, browserBuild) {\n    this.bundle = bundle;\n    this.browserBuild = browserBuild;\n    this.dependsOn = {};\n    this.dependedBy = {};\n    this.rebuildGraph();\n  }\n  getTransitiveDependers(name2) {\n    return this.transitiveCrawl(name2, this.dependedBy);\n  }\n  getTransitiveDeps(name2) {\n    if (!(name2 in this.dependsOn)) {\n      return [];\n    }\n    return this.transitiveCrawl(name2, this.dependsOn);\n  }\n  transitiveCrawl(name2, edges) {\n    const deps = /* @__PURE__ */ new Set();\n    const crawl = (dep2) => {\n      var _a;\n      if (deps.has(dep2)) {\n        return;\n      }\n      deps.add(dep2);\n      for (const subdep of (_a = edges[dep2]) != null ? _a : []) {\n        crawl(subdep);\n      }\n    };\n    for (const dep2 of edges[name2]) {\n      crawl(dep2);\n    }\n    return Array.from(deps);\n  }\n  rebuildGraph() {\n    this.dependedBy = {};\n    this.dependsOn = {};\n    for (const mod of this.browserBuild ? this.bundle.modules.browser : this.bundle.modules.server) {\n      if (mod.type === \"code\") {\n        for (const imported of mod.imports) {\n          if (!(mod.fileName in this.dependsOn)) {\n            this.dependsOn[mod.fileName] = [imported];\n          } else {\n            this.dependsOn[mod.fileName].push(imported);\n          }\n          if (!(imported in this.dependedBy)) {\n            this.dependedBy[imported] = [mod.fileName];\n          } else {\n            this.dependedBy[imported].push(mod.fileName);\n          }\n        }\n      }\n    }\n  }\n};\n\n// src/bundles.ts\nfunction getBundleSubset(bundle, names, opts2) {\n  var _a, _b;\n  const namesSet = new Set(names);\n  const target = (_a = opts2 == null ? void 0 : opts2.target) != null ? _a : \"browser\";\n  const forBrowser = target === \"browser\";\n  const graph = new DepsGraph(bundle, forBrowser);\n  const deps = new Set(names.flatMap((name2) => graph.getTransitiveDeps(name2)));\n  const isSubModule = (fileName) => deps.has(fileName) || namesSet.has(fileName);\n  const modules = bundle.modules[target];\n  const filteredModules = modules.filter((mod) => isSubModule(mod.fileName));\n  const filteredComponents = bundle.components.filter(\n    (c) => isSubModule(c.entry)\n  );\n  const filteredComponentsIds = new Set(filteredComponents.map((c) => c.id));\n  const filteredIds = Object.fromEntries(\n    Object.entries(bundle.filteredIds).map(([k, v]) => [k, [...v]])\n  );\n  bundle.components.filter((c) => !filteredComponentsIds.has(c.id)).forEach((component) => {\n    var _a2;\n    filteredIds[component.projectId] = (_a2 = filteredIds[component.projectId]) != null ? _a2 : [];\n    if (!filteredIds[component.projectId].includes(component.id)) {\n      filteredIds[component.projectId].push(component.id);\n    }\n  });\n  return {\n    modules: {\n      browser: forBrowser ? filteredModules : [],\n      server: forBrowser ? [] : filteredModules\n    },\n    components: filteredComponents,\n    globalGroups: bundle.globalGroups,\n    projects: bundle.projects,\n    activeSplits: bundle.activeSplits,\n    bundleKey: (_b = bundle.bundleKey) != null ? _b : null,\n    deferChunksByDefault: bundle.deferChunksByDefault,\n    disableRootLoadingBoundaryByDefault: bundle.disableRootLoadingBoundaryByDefault,\n    filteredIds\n  };\n}\n\n// src/registry.ts\nvar isBrowser = typeof window !== \"undefined\" && window != null && typeof window.document !== \"undefined\";\nfunction isModuleBundlePromiseSet(name2) {\n  return globalThis.__PlasmicBundlePromises && !!globalThis.__PlasmicBundlePromises[name2] && !!globalThis.__PlasmicBundlePromises[name2].then;\n}\nvar Registry = class {\n  constructor() {\n    this.loadedModules = {};\n    this.registeredModules = {};\n    this.modules = {};\n  }\n  register(name2, module) {\n    this.registeredModules[name2] = module;\n  }\n  isEmpty() {\n    return Object.keys(this.loadedModules).length === 0;\n  }\n  clear() {\n    this.loadedModules = {};\n  }\n  getRegisteredModule(name2) {\n    return this.registeredModules[name2];\n  }\n  hasModule(name2, opts2 = {}) {\n    if (name2 in this.registeredModules && !opts2.forceOriginal) {\n      return true;\n    }\n    if (name2 in this.modules) {\n      return true;\n    }\n    if (globalThis.__PLASMIC_CHUNKS && !!globalThis.__PLASMIC_CHUNKS[name2]) {\n      return true;\n    }\n    if (isModuleBundlePromiseSet(name2)) {\n      return true;\n    }\n    return false;\n  }\n  load(name, opts = {}) {\n    if (name in this.registeredModules && !opts.forceOriginal) {\n      return this.registeredModules[name];\n    }\n    if (name in this.loadedModules) {\n      return this.loadedModules[name];\n    }\n    if (!this.modules[name] && globalThis.__PLASMIC_CHUNKS && !!globalThis.__PLASMIC_CHUNKS[name]) {\n      this.modules[name] = globalThis.__PLASMIC_CHUNKS[name];\n    }\n    if (!this.modules[name] && isModuleBundlePromiseSet(name)) {\n      throw globalThis.__PlasmicBundlePromises[name];\n    }\n    if (!(name in this.modules)) {\n      throw new Error(`Unknown module ${name}`);\n    }\n    const code = this.modules[name];\n    const requireFn = isBrowser ? (dep2) => {\n      const normalizedDep = resolvePath(dep2, name);\n      return this.load(normalizedDep);\n    } : (dep) => {\n      try {\n        const normalizedDep = resolvePath(dep, name);\n        return this.load(normalizedDep);\n      } catch (err) {\n        try {\n          return eval(\"require\")(dep);\n        } catch (e) {\n          throw err;\n        }\n      }\n    };\n    let func;\n    try {\n      func = new Function(\"require\", \"exports\", code);\n    } catch (err2) {\n      throw new Error(`PLASMIC: Failed to create function for ${name}: ${err2}`);\n    }\n    const exports = {};\n    this.loadedModules[name] = exports;\n    try {\n      func(requireFn, exports);\n    } catch (err2) {\n      delete this.loadedModules[name];\n      if (!(err2 instanceof Error) && !!err2 && !!err2.then) {\n        throw err2;\n      }\n      throw new Error(`PLASMIC: Failed to load ${name}: ${err2}`);\n    }\n    return exports;\n  }\n  updateModules(bundle) {\n    let updated = false;\n    for (const mod of isBrowser ? bundle.modules.browser : bundle.modules.server) {\n      if (mod.type === \"code\" && !!mod.code && mod.code !== this.modules[mod.fileName]) {\n        this.modules[mod.fileName] = mod.code;\n        if (!globalThis.__PLASMIC_CHUNKS) {\n          globalThis.__PLASMIC_CHUNKS = {};\n        }\n        globalThis.__PLASMIC_CHUNKS[mod.fileName] = mod.code;\n        updated = true;\n      }\n    }\n    if (updated) {\n      this.clear();\n    }\n  }\n};\nfunction resolvePath(path, from) {\n  const fromParts = from.split(\"/\");\n  const pathParts = path.split(\"/\");\n  if (pathParts.length === 0) {\n    return path;\n  }\n  if (pathParts[0] === \".\") {\n    return [\n      ...fromParts.slice(0, fromParts.length - 1),\n      ...pathParts.slice(1)\n    ].join(\"/\");\n  } else if (pathParts[0] === \"..\") {\n    let count = 0;\n    for (const part of pathParts) {\n      if (part === \"..\") {\n        count += 1;\n      } else {\n        break;\n      }\n    }\n    return [\n      ...fromParts.slice(0, fromParts.length - count - 1),\n      ...pathParts.slice(count)\n    ].join(\"/\");\n  } else {\n    return path;\n  }\n}\n\n// src/tracker/index.ts\n\n\n// src/tracker/utils.ts\nvar isBrowser2 = typeof window !== \"undefined\" && window != null && typeof window.document !== \"undefined\";\nfunction getPlasmicCookieValues() {\n  if (!isBrowser2) {\n    return {};\n  }\n  return Object.fromEntries(\n    document.cookie.split(\"; \").filter((cookie) => cookie.includes(\"plasmic:\")).map((cookie) => cookie.split(\"=\")).map(([key, value]) => [key.split(\":\")[1], value])\n  );\n}\nfunction getVariationCookieValues() {\n  const cookies = getPlasmicCookieValues();\n  return Object.fromEntries(\n    Object.keys(cookies).map((key) => [key.split(\".\")[1], cookies[key]]).filter((val) => !!val[0])\n  );\n}\nfunction getDistinctId() {\n  if (!isBrowser2) {\n    return \"LOADER-SERVER\";\n  }\n  return \"LOADER-CLIENT\";\n}\nfunction getCampaignParams() {\n  const { location } = window;\n  const params = {};\n  try {\n    const url = new URL(location.href);\n    const CAMPAIGN_KEYWORDS = [\n      \"utm_source\",\n      \"utm_medium\",\n      \"utm_campaign\",\n      \"utm_content\",\n      \"utm_term\",\n      \"gclid\"\n    ];\n    CAMPAIGN_KEYWORDS.forEach((keyword) => {\n      const value = url.searchParams.get(keyword);\n      if (value) {\n        params[keyword] = value;\n      }\n    });\n  } catch (err2) {\n  }\n  return params;\n}\nfunction getLocationMeta() {\n  const { location } = window;\n  const { referrer } = document;\n  return __spreadValues({\n    url: location.href,\n    host: location.host,\n    pathname: location.pathname,\n    referrer\n  }, getCampaignParams());\n}\nfunction getScreenMeta() {\n  const { screen } = window;\n  return {\n    screen_height: screen.height,\n    screen_width: screen.width,\n    viewport_height: window.innerHeight,\n    viewport_width: window.innerWidth\n  };\n}\nfunction getOS(userAgent) {\n  if (/Windows/i.test(userAgent)) {\n    if (/Phone/.test(userAgent) || /WPDesktop/.test(userAgent)) {\n      return \"Windows Phone\";\n    }\n    return \"Windows\";\n  } else if (/(iPhone|iPad|iPod)/.test(userAgent)) {\n    return \"iOS\";\n  } else if (/Android/.test(userAgent)) {\n    return \"Android\";\n  } else if (/(BlackBerry|PlayBook|BB10)/i.test(userAgent)) {\n    return \"BlackBerry\";\n  } else if (/Mac/i.test(userAgent)) {\n    return \"Mac OS X\";\n  } else if (/Linux/.test(userAgent)) {\n    return \"Linux\";\n  } else if (/CrOS/.test(userAgent)) {\n    return \"Chrome OS\";\n  } else {\n    return \"\";\n  }\n}\nfunction getDeviceInfo(userAgent) {\n  const PATTERNS = [\n    {\n      device: \"iPhone\",\n      patterns: [/iPhone/]\n    },\n    {\n      device: \"iPad\",\n      patterns: [/iPad/]\n    },\n    {\n      device: \"iPod Touch\",\n      patterns: [/iPod/]\n    },\n    {\n      device: \"Windows Phone\",\n      patterns: [/Windows Phone/i, /WPDesktop/]\n    },\n    {\n      device: \"Android\",\n      patterns: [/Android/]\n    }\n  ];\n  const match = PATTERNS.find(\n    (pattern) => pattern.patterns.some((expr) => expr.test(userAgent))\n  );\n  const device = match == null ? void 0 : match.device;\n  return {\n    device: device != null ? device : \"\",\n    deviceType: device ? \"Mobile\" : \"Desktop\",\n    os: getOS(userAgent)\n  };\n}\nfunction getUserAgentMeta() {\n  const { navigator } = window;\n  const { userAgent } = navigator;\n  return __spreadValues({}, getDeviceInfo(userAgent));\n}\nfunction getWindowMeta() {\n  if (!isBrowser2) {\n    return {};\n  }\n  return __spreadValues(__spreadValues(__spreadValues({}, getLocationMeta()), getScreenMeta()), getUserAgentMeta());\n}\nvar isProduction = \"development\" === \"production\";\nfunction getEnvMeta() {\n  return {\n    isBrowser: isBrowser2,\n    isProduction\n  };\n}\nfunction rawSplitVariation(variation) {\n  const rawVariations = {};\n  Object.keys(variation).forEach((variationKey) => {\n    const [, splitId] = variationKey.split(\".\");\n    if (splitId) {\n      rawVariations[splitId] = variation[variationKey];\n    }\n  });\n  return rawVariations;\n}\nvar POLL_TIME = 5e3;\nfunction throttled(func2) {\n  let timerId = void 0;\n  return (param) => {\n    if (timerId) {\n      return;\n    }\n    if (isBrowser2) {\n      timerId = window.requestAnimationFrame(() => {\n        timerId = void 0;\n        func2(param);\n      });\n    } else {\n      timerId = setTimeout(() => {\n        timerId = void 0;\n        func2(param);\n      }, POLL_TIME);\n    }\n  };\n}\n\n// src/tracker/index.ts\nvar API_ENDPOINT = \"https://analytics.plasmic.app/capture\";\nvar API_PUBLIC_KEY = \"phc_BRvYTAoMoam9fDHfrIneF67KdtMJagLVVCM6ELNYd4n\";\nvar TRACKER_VERSION = 4;\nvar PlasmicTracker = class {\n  constructor(opts2) {\n    this.opts = opts2;\n    this.eventQueue = [];\n    this.sendEvents = throttled((transport) => __async(this, null, function* () {\n      if (this.eventQueue.length === 0) {\n        return;\n      }\n      const events = [...this.eventQueue];\n      this.eventQueue.length = 0;\n      const body = {\n        api_key: API_PUBLIC_KEY,\n        batch: events\n      };\n      try {\n        const stringBody = JSON.stringify(body);\n        if (transport === \"beacon\") {\n          window.navigator.sendBeacon(API_ENDPOINT, stringBody);\n        } else {\n          this.fetch(API_ENDPOINT, {\n            method: \"POST\",\n            headers: {\n              Accept: \"application/json\"\n            },\n            body: stringBody\n          }).then(() => {\n          }).catch(() => {\n          });\n        }\n      } catch (err2) {\n      }\n    }));\n    this.fetch = (opts2.nativeFetch && globalThis.fetch ? globalThis.fetch : (_plasmicapp_isomorphic_unfetch__WEBPACK_IMPORTED_MODULE_1___default())).bind(globalThis);\n  }\n  trackRender(opts2) {\n    var _a, _b;\n    this.enqueue({\n      event: \"$render\",\n      properties: __spreadValues(__spreadValues(__spreadValues({}, this.getProperties()), (_a = opts2 == null ? void 0 : opts2.renderCtx) != null ? _a : {}), rawSplitVariation((_b = opts2 == null ? void 0 : opts2.variation) != null ? _b : {}))\n    });\n  }\n  trackFetch() {\n    this.enqueue({\n      event: \"$fetch\",\n      properties: this.getProperties()\n    });\n  }\n  trackConversion(value = 0) {\n    this.enqueue({\n      event: \"$conversion\",\n      properties: __spreadProps(__spreadValues({}, this.getProperties()), {\n        value\n      })\n    });\n  }\n  getProperties() {\n    var _a;\n    return __spreadProps(__spreadValues(__spreadValues(__spreadValues(__spreadValues({\n      distinct_id: getDistinctId()\n    }, getWindowMeta()), getEnvMeta()), this.getContextMeta()), getVariationCookieValues()), {\n      timestamp: (_a = Date.now()) != null ? _a : +/* @__PURE__ */ new Date(),\n      trackerVersion: TRACKER_VERSION\n    });\n  }\n  enqueue(event) {\n    if (this.opts.__plasmicTrackerDisabled) {\n      return;\n    }\n    this.eventQueue.push(event);\n    this.sendEvents(\"fetch\");\n  }\n  getContextMeta() {\n    return {\n      platform: this.opts.platform,\n      preview: this.opts.preview,\n      projectIds: this.opts.projectIds\n    };\n  }\n};\n\n//# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcGxhc21pY2FwcC9sb2FkZXItY29yZS9kaXN0L2luZGV4LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ3dFOztBQUV4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLEtBQUs7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixnRUFBZ0UsS0FBSyxJQUFJLEtBQUs7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxLQUFLLElBQUksS0FBSztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDcUQ7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsV0FBVztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFdBQVc7QUFDckIsVUFBVSxXQUFXO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLFVBQVUsU0FBUztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCLFVBQVUsWUFBWTtBQUN0QiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBLG1CQUFtQixhQUFvQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWCxXQUFXO0FBQ1gsV0FBVztBQUNYO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsS0FBSztBQUNMLDZFQUE2RSx1RUFBTztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLDBGQUEwRixzRkFBc0Y7QUFDalAsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9FO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL1dvbmRlclZpdGUtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BwbGFzbWljYXBwL2xvYWRlci1jb3JlL2Rpc3QvaW5kZXguZXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZQcm9wcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzO1xudmFyIF9fZ2V0T3duUHJvcERlc2NzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbnZhciBfX3NwcmVhZFByb3BzID0gKGEsIGIpID0+IF9fZGVmUHJvcHMoYSwgX19nZXRPd25Qcm9wRGVzY3MoYikpO1xudmFyIF9fYXN5bmMgPSAoX190aGlzLCBfX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgdmFyIGZ1bGZpbGxlZCA9ICh2YWx1ZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgcmVqZWN0ZWQgPSAodmFsdWUpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yLnRocm93KHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBzdGVwID0gKHgpID0+IHguZG9uZSA/IHJlc29sdmUoeC52YWx1ZSkgOiBQcm9taXNlLnJlc29sdmUoeC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTtcbiAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkoX190aGlzLCBfX2FyZ3VtZW50cykpLm5leHQoKSk7XG4gIH0pO1xufTtcblxuLy8gc3JjL2luZGV4LnRzXG5pbXBvcnQgeyBBcGksIFBsYXNtaWNNb2R1bGVzRmV0Y2hlciB9IGZyb20gXCJAcGxhc21pY2FwcC9sb2FkZXItZmV0Y2hlclwiO1xuXG4vLyBzcmMvZGVwcy1ncmFwaC50c1xudmFyIERlcHNHcmFwaCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoYnVuZGxlLCBicm93c2VyQnVpbGQpIHtcbiAgICB0aGlzLmJ1bmRsZSA9IGJ1bmRsZTtcbiAgICB0aGlzLmJyb3dzZXJCdWlsZCA9IGJyb3dzZXJCdWlsZDtcbiAgICB0aGlzLmRlcGVuZHNPbiA9IHt9O1xuICAgIHRoaXMuZGVwZW5kZWRCeSA9IHt9O1xuICAgIHRoaXMucmVidWlsZEdyYXBoKCk7XG4gIH1cbiAgZ2V0VHJhbnNpdGl2ZURlcGVuZGVycyhuYW1lMikge1xuICAgIHJldHVybiB0aGlzLnRyYW5zaXRpdmVDcmF3bChuYW1lMiwgdGhpcy5kZXBlbmRlZEJ5KTtcbiAgfVxuICBnZXRUcmFuc2l0aXZlRGVwcyhuYW1lMikge1xuICAgIGlmICghKG5hbWUyIGluIHRoaXMuZGVwZW5kc09uKSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50cmFuc2l0aXZlQ3Jhd2wobmFtZTIsIHRoaXMuZGVwZW5kc09uKTtcbiAgfVxuICB0cmFuc2l0aXZlQ3Jhd2wobmFtZTIsIGVkZ2VzKSB7XG4gICAgY29uc3QgZGVwcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29uc3QgY3Jhd2wgPSAoZGVwMikgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKGRlcHMuaGFzKGRlcDIpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGRlcHMuYWRkKGRlcDIpO1xuICAgICAgZm9yIChjb25zdCBzdWJkZXAgb2YgKF9hID0gZWRnZXNbZGVwMl0pICE9IG51bGwgPyBfYSA6IFtdKSB7XG4gICAgICAgIGNyYXdsKHN1YmRlcCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IGRlcDIgb2YgZWRnZXNbbmFtZTJdKSB7XG4gICAgICBjcmF3bChkZXAyKTtcbiAgICB9XG4gICAgcmV0dXJuIEFycmF5LmZyb20oZGVwcyk7XG4gIH1cbiAgcmVidWlsZEdyYXBoKCkge1xuICAgIHRoaXMuZGVwZW5kZWRCeSA9IHt9O1xuICAgIHRoaXMuZGVwZW5kc09uID0ge307XG4gICAgZm9yIChjb25zdCBtb2Qgb2YgdGhpcy5icm93c2VyQnVpbGQgPyB0aGlzLmJ1bmRsZS5tb2R1bGVzLmJyb3dzZXIgOiB0aGlzLmJ1bmRsZS5tb2R1bGVzLnNlcnZlcikge1xuICAgICAgaWYgKG1vZC50eXBlID09PSBcImNvZGVcIikge1xuICAgICAgICBmb3IgKGNvbnN0IGltcG9ydGVkIG9mIG1vZC5pbXBvcnRzKSB7XG4gICAgICAgICAgaWYgKCEobW9kLmZpbGVOYW1lIGluIHRoaXMuZGVwZW5kc09uKSkge1xuICAgICAgICAgICAgdGhpcy5kZXBlbmRzT25bbW9kLmZpbGVOYW1lXSA9IFtpbXBvcnRlZF07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVwZW5kc09uW21vZC5maWxlTmFtZV0ucHVzaChpbXBvcnRlZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghKGltcG9ydGVkIGluIHRoaXMuZGVwZW5kZWRCeSkpIHtcbiAgICAgICAgICAgIHRoaXMuZGVwZW5kZWRCeVtpbXBvcnRlZF0gPSBbbW9kLmZpbGVOYW1lXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZXBlbmRlZEJ5W2ltcG9ydGVkXS5wdXNoKG1vZC5maWxlTmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvYnVuZGxlcy50c1xuZnVuY3Rpb24gZ2V0QnVuZGxlU3Vic2V0KGJ1bmRsZSwgbmFtZXMsIG9wdHMyKSB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IG5hbWVzU2V0ID0gbmV3IFNldChuYW1lcyk7XG4gIGNvbnN0IHRhcmdldCA9IChfYSA9IG9wdHMyID09IG51bGwgPyB2b2lkIDAgOiBvcHRzMi50YXJnZXQpICE9IG51bGwgPyBfYSA6IFwiYnJvd3NlclwiO1xuICBjb25zdCBmb3JCcm93c2VyID0gdGFyZ2V0ID09PSBcImJyb3dzZXJcIjtcbiAgY29uc3QgZ3JhcGggPSBuZXcgRGVwc0dyYXBoKGJ1bmRsZSwgZm9yQnJvd3Nlcik7XG4gIGNvbnN0IGRlcHMgPSBuZXcgU2V0KG5hbWVzLmZsYXRNYXAoKG5hbWUyKSA9PiBncmFwaC5nZXRUcmFuc2l0aXZlRGVwcyhuYW1lMikpKTtcbiAgY29uc3QgaXNTdWJNb2R1bGUgPSAoZmlsZU5hbWUpID0+IGRlcHMuaGFzKGZpbGVOYW1lKSB8fCBuYW1lc1NldC5oYXMoZmlsZU5hbWUpO1xuICBjb25zdCBtb2R1bGVzID0gYnVuZGxlLm1vZHVsZXNbdGFyZ2V0XTtcbiAgY29uc3QgZmlsdGVyZWRNb2R1bGVzID0gbW9kdWxlcy5maWx0ZXIoKG1vZCkgPT4gaXNTdWJNb2R1bGUobW9kLmZpbGVOYW1lKSk7XG4gIGNvbnN0IGZpbHRlcmVkQ29tcG9uZW50cyA9IGJ1bmRsZS5jb21wb25lbnRzLmZpbHRlcihcbiAgICAoYykgPT4gaXNTdWJNb2R1bGUoYy5lbnRyeSlcbiAgKTtcbiAgY29uc3QgZmlsdGVyZWRDb21wb25lbnRzSWRzID0gbmV3IFNldChmaWx0ZXJlZENvbXBvbmVudHMubWFwKChjKSA9PiBjLmlkKSk7XG4gIGNvbnN0IGZpbHRlcmVkSWRzID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIE9iamVjdC5lbnRyaWVzKGJ1bmRsZS5maWx0ZXJlZElkcykubWFwKChbaywgdl0pID0+IFtrLCBbLi4udl1dKVxuICApO1xuICBidW5kbGUuY29tcG9uZW50cy5maWx0ZXIoKGMpID0+ICFmaWx0ZXJlZENvbXBvbmVudHNJZHMuaGFzKGMuaWQpKS5mb3JFYWNoKChjb21wb25lbnQpID0+IHtcbiAgICB2YXIgX2EyO1xuICAgIGZpbHRlcmVkSWRzW2NvbXBvbmVudC5wcm9qZWN0SWRdID0gKF9hMiA9IGZpbHRlcmVkSWRzW2NvbXBvbmVudC5wcm9qZWN0SWRdKSAhPSBudWxsID8gX2EyIDogW107XG4gICAgaWYgKCFmaWx0ZXJlZElkc1tjb21wb25lbnQucHJvamVjdElkXS5pbmNsdWRlcyhjb21wb25lbnQuaWQpKSB7XG4gICAgICBmaWx0ZXJlZElkc1tjb21wb25lbnQucHJvamVjdElkXS5wdXNoKGNvbXBvbmVudC5pZCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBtb2R1bGVzOiB7XG4gICAgICBicm93c2VyOiBmb3JCcm93c2VyID8gZmlsdGVyZWRNb2R1bGVzIDogW10sXG4gICAgICBzZXJ2ZXI6IGZvckJyb3dzZXIgPyBbXSA6IGZpbHRlcmVkTW9kdWxlc1xuICAgIH0sXG4gICAgY29tcG9uZW50czogZmlsdGVyZWRDb21wb25lbnRzLFxuICAgIGdsb2JhbEdyb3VwczogYnVuZGxlLmdsb2JhbEdyb3VwcyxcbiAgICBwcm9qZWN0czogYnVuZGxlLnByb2plY3RzLFxuICAgIGFjdGl2ZVNwbGl0czogYnVuZGxlLmFjdGl2ZVNwbGl0cyxcbiAgICBidW5kbGVLZXk6IChfYiA9IGJ1bmRsZS5idW5kbGVLZXkpICE9IG51bGwgPyBfYiA6IG51bGwsXG4gICAgZGVmZXJDaHVua3NCeURlZmF1bHQ6IGJ1bmRsZS5kZWZlckNodW5rc0J5RGVmYXVsdCxcbiAgICBkaXNhYmxlUm9vdExvYWRpbmdCb3VuZGFyeUJ5RGVmYXVsdDogYnVuZGxlLmRpc2FibGVSb290TG9hZGluZ0JvdW5kYXJ5QnlEZWZhdWx0LFxuICAgIGZpbHRlcmVkSWRzXG4gIH07XG59XG5cbi8vIHNyYy9yZWdpc3RyeS50c1xudmFyIGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93ICE9IG51bGwgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIjtcbmZ1bmN0aW9uIGlzTW9kdWxlQnVuZGxlUHJvbWlzZVNldChuYW1lMikge1xuICByZXR1cm4gZ2xvYmFsVGhpcy5fX1BsYXNtaWNCdW5kbGVQcm9taXNlcyAmJiAhIWdsb2JhbFRoaXMuX19QbGFzbWljQnVuZGxlUHJvbWlzZXNbbmFtZTJdICYmICEhZ2xvYmFsVGhpcy5fX1BsYXNtaWNCdW5kbGVQcm9taXNlc1tuYW1lMl0udGhlbjtcbn1cbnZhciBSZWdpc3RyeSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5sb2FkZWRNb2R1bGVzID0ge307XG4gICAgdGhpcy5yZWdpc3RlcmVkTW9kdWxlcyA9IHt9O1xuICAgIHRoaXMubW9kdWxlcyA9IHt9O1xuICB9XG4gIHJlZ2lzdGVyKG5hbWUyLCBtb2R1bGUpIHtcbiAgICB0aGlzLnJlZ2lzdGVyZWRNb2R1bGVzW25hbWUyXSA9IG1vZHVsZTtcbiAgfVxuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmxvYWRlZE1vZHVsZXMpLmxlbmd0aCA9PT0gMDtcbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLmxvYWRlZE1vZHVsZXMgPSB7fTtcbiAgfVxuICBnZXRSZWdpc3RlcmVkTW9kdWxlKG5hbWUyKSB7XG4gICAgcmV0dXJuIHRoaXMucmVnaXN0ZXJlZE1vZHVsZXNbbmFtZTJdO1xuICB9XG4gIGhhc01vZHVsZShuYW1lMiwgb3B0czIgPSB7fSkge1xuICAgIGlmIChuYW1lMiBpbiB0aGlzLnJlZ2lzdGVyZWRNb2R1bGVzICYmICFvcHRzMi5mb3JjZU9yaWdpbmFsKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG5hbWUyIGluIHRoaXMubW9kdWxlcykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChnbG9iYWxUaGlzLl9fUExBU01JQ19DSFVOS1MgJiYgISFnbG9iYWxUaGlzLl9fUExBU01JQ19DSFVOS1NbbmFtZTJdKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGlzTW9kdWxlQnVuZGxlUHJvbWlzZVNldChuYW1lMikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbG9hZChuYW1lLCBvcHRzID0ge30pIHtcbiAgICBpZiAobmFtZSBpbiB0aGlzLnJlZ2lzdGVyZWRNb2R1bGVzICYmICFvcHRzLmZvcmNlT3JpZ2luYWwpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlZ2lzdGVyZWRNb2R1bGVzW25hbWVdO1xuICAgIH1cbiAgICBpZiAobmFtZSBpbiB0aGlzLmxvYWRlZE1vZHVsZXMpIHtcbiAgICAgIHJldHVybiB0aGlzLmxvYWRlZE1vZHVsZXNbbmFtZV07XG4gICAgfVxuICAgIGlmICghdGhpcy5tb2R1bGVzW25hbWVdICYmIGdsb2JhbFRoaXMuX19QTEFTTUlDX0NIVU5LUyAmJiAhIWdsb2JhbFRoaXMuX19QTEFTTUlDX0NIVU5LU1tuYW1lXSkge1xuICAgICAgdGhpcy5tb2R1bGVzW25hbWVdID0gZ2xvYmFsVGhpcy5fX1BMQVNNSUNfQ0hVTktTW25hbWVdO1xuICAgIH1cbiAgICBpZiAoIXRoaXMubW9kdWxlc1tuYW1lXSAmJiBpc01vZHVsZUJ1bmRsZVByb21pc2VTZXQobmFtZSkpIHtcbiAgICAgIHRocm93IGdsb2JhbFRoaXMuX19QbGFzbWljQnVuZGxlUHJvbWlzZXNbbmFtZV07XG4gICAgfVxuICAgIGlmICghKG5hbWUgaW4gdGhpcy5tb2R1bGVzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIG1vZHVsZSAke25hbWV9YCk7XG4gICAgfVxuICAgIGNvbnN0IGNvZGUgPSB0aGlzLm1vZHVsZXNbbmFtZV07XG4gICAgY29uc3QgcmVxdWlyZUZuID0gaXNCcm93c2VyID8gKGRlcDIpID0+IHtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWREZXAgPSByZXNvbHZlUGF0aChkZXAyLCBuYW1lKTtcbiAgICAgIHJldHVybiB0aGlzLmxvYWQobm9ybWFsaXplZERlcCk7XG4gICAgfSA6IChkZXApID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWREZXAgPSByZXNvbHZlUGF0aChkZXAsIG5hbWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5sb2FkKG5vcm1hbGl6ZWREZXApO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGV2YWwoXCJyZXF1aXJlXCIpKGRlcCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGxldCBmdW5jO1xuICAgIHRyeSB7XG4gICAgICBmdW5jID0gbmV3IEZ1bmN0aW9uKFwicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgY29kZSk7XG4gICAgfSBjYXRjaCAoZXJyMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBQTEFTTUlDOiBGYWlsZWQgdG8gY3JlYXRlIGZ1bmN0aW9uIGZvciAke25hbWV9OiAke2VycjJ9YCk7XG4gICAgfVxuICAgIGNvbnN0IGV4cG9ydHMgPSB7fTtcbiAgICB0aGlzLmxvYWRlZE1vZHVsZXNbbmFtZV0gPSBleHBvcnRzO1xuICAgIHRyeSB7XG4gICAgICBmdW5jKHJlcXVpcmVGbiwgZXhwb3J0cyk7XG4gICAgfSBjYXRjaCAoZXJyMikge1xuICAgICAgZGVsZXRlIHRoaXMubG9hZGVkTW9kdWxlc1tuYW1lXTtcbiAgICAgIGlmICghKGVycjIgaW5zdGFuY2VvZiBFcnJvcikgJiYgISFlcnIyICYmICEhZXJyMi50aGVuKSB7XG4gICAgICAgIHRocm93IGVycjI7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFBMQVNNSUM6IEZhaWxlZCB0byBsb2FkICR7bmFtZX06ICR7ZXJyMn1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGV4cG9ydHM7XG4gIH1cbiAgdXBkYXRlTW9kdWxlcyhidW5kbGUpIHtcbiAgICBsZXQgdXBkYXRlZCA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgbW9kIG9mIGlzQnJvd3NlciA/IGJ1bmRsZS5tb2R1bGVzLmJyb3dzZXIgOiBidW5kbGUubW9kdWxlcy5zZXJ2ZXIpIHtcbiAgICAgIGlmIChtb2QudHlwZSA9PT0gXCJjb2RlXCIgJiYgISFtb2QuY29kZSAmJiBtb2QuY29kZSAhPT0gdGhpcy5tb2R1bGVzW21vZC5maWxlTmFtZV0pIHtcbiAgICAgICAgdGhpcy5tb2R1bGVzW21vZC5maWxlTmFtZV0gPSBtb2QuY29kZTtcbiAgICAgICAgaWYgKCFnbG9iYWxUaGlzLl9fUExBU01JQ19DSFVOS1MpIHtcbiAgICAgICAgICBnbG9iYWxUaGlzLl9fUExBU01JQ19DSFVOS1MgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBnbG9iYWxUaGlzLl9fUExBU01JQ19DSFVOS1NbbW9kLmZpbGVOYW1lXSA9IG1vZC5jb2RlO1xuICAgICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHVwZGF0ZWQpIHtcbiAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiByZXNvbHZlUGF0aChwYXRoLCBmcm9tKSB7XG4gIGNvbnN0IGZyb21QYXJ0cyA9IGZyb20uc3BsaXQoXCIvXCIpO1xuICBjb25zdCBwYXRoUGFydHMgPSBwYXRoLnNwbGl0KFwiL1wiKTtcbiAgaWYgKHBhdGhQYXJ0cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gcGF0aDtcbiAgfVxuICBpZiAocGF0aFBhcnRzWzBdID09PSBcIi5cIikge1xuICAgIHJldHVybiBbXG4gICAgICAuLi5mcm9tUGFydHMuc2xpY2UoMCwgZnJvbVBhcnRzLmxlbmd0aCAtIDEpLFxuICAgICAgLi4ucGF0aFBhcnRzLnNsaWNlKDEpXG4gICAgXS5qb2luKFwiL1wiKTtcbiAgfSBlbHNlIGlmIChwYXRoUGFydHNbMF0gPT09IFwiLi5cIikge1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhdGhQYXJ0cykge1xuICAgICAgaWYgKHBhcnQgPT09IFwiLi5cIikge1xuICAgICAgICBjb3VudCArPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICAuLi5mcm9tUGFydHMuc2xpY2UoMCwgZnJvbVBhcnRzLmxlbmd0aCAtIGNvdW50IC0gMSksXG4gICAgICAuLi5wYXRoUGFydHMuc2xpY2UoY291bnQpXG4gICAgXS5qb2luKFwiL1wiKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcGF0aDtcbiAgfVxufVxuXG4vLyBzcmMvdHJhY2tlci9pbmRleC50c1xuaW1wb3J0IHVuZmV0Y2ggZnJvbSBcIkBwbGFzbWljYXBwL2lzb21vcnBoaWMtdW5mZXRjaFwiO1xuXG4vLyBzcmMvdHJhY2tlci91dGlscy50c1xudmFyIGlzQnJvd3NlcjIgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdyAhPSBudWxsICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCI7XG5mdW5jdGlvbiBnZXRQbGFzbWljQ29va2llVmFsdWVzKCkge1xuICBpZiAoIWlzQnJvd3NlcjIpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBkb2N1bWVudC5jb29raWUuc3BsaXQoXCI7IFwiKS5maWx0ZXIoKGNvb2tpZSkgPT4gY29va2llLmluY2x1ZGVzKFwicGxhc21pYzpcIikpLm1hcCgoY29va2llKSA9PiBjb29raWUuc3BsaXQoXCI9XCIpKS5tYXAoKFtrZXksIHZhbHVlXSkgPT4gW2tleS5zcGxpdChcIjpcIilbMV0sIHZhbHVlXSlcbiAgKTtcbn1cbmZ1bmN0aW9uIGdldFZhcmlhdGlvbkNvb2tpZVZhbHVlcygpIHtcbiAgY29uc3QgY29va2llcyA9IGdldFBsYXNtaWNDb29raWVWYWx1ZXMoKTtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBPYmplY3Qua2V5cyhjb29raWVzKS5tYXAoKGtleSkgPT4gW2tleS5zcGxpdChcIi5cIilbMV0sIGNvb2tpZXNba2V5XV0pLmZpbHRlcigodmFsKSA9PiAhIXZhbFswXSlcbiAgKTtcbn1cbmZ1bmN0aW9uIGdldERpc3RpbmN0SWQoKSB7XG4gIGlmICghaXNCcm93c2VyMikge1xuICAgIHJldHVybiBcIkxPQURFUi1TRVJWRVJcIjtcbiAgfVxuICByZXR1cm4gXCJMT0FERVItQ0xJRU5UXCI7XG59XG5mdW5jdGlvbiBnZXRDYW1wYWlnblBhcmFtcygpIHtcbiAgY29uc3QgeyBsb2NhdGlvbiB9ID0gd2luZG93O1xuICBjb25zdCBwYXJhbXMgPSB7fTtcbiAgdHJ5IHtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGxvY2F0aW9uLmhyZWYpO1xuICAgIGNvbnN0IENBTVBBSUdOX0tFWVdPUkRTID0gW1xuICAgICAgXCJ1dG1fc291cmNlXCIsXG4gICAgICBcInV0bV9tZWRpdW1cIixcbiAgICAgIFwidXRtX2NhbXBhaWduXCIsXG4gICAgICBcInV0bV9jb250ZW50XCIsXG4gICAgICBcInV0bV90ZXJtXCIsXG4gICAgICBcImdjbGlkXCJcbiAgICBdO1xuICAgIENBTVBBSUdOX0tFWVdPUkRTLmZvckVhY2goKGtleXdvcmQpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdXJsLnNlYXJjaFBhcmFtcy5nZXQoa2V5d29yZCk7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgcGFyYW1zW2tleXdvcmRdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycjIpIHtcbiAgfVxuICByZXR1cm4gcGFyYW1zO1xufVxuZnVuY3Rpb24gZ2V0TG9jYXRpb25NZXRhKCkge1xuICBjb25zdCB7IGxvY2F0aW9uIH0gPSB3aW5kb3c7XG4gIGNvbnN0IHsgcmVmZXJyZXIgfSA9IGRvY3VtZW50O1xuICByZXR1cm4gX19zcHJlYWRWYWx1ZXMoe1xuICAgIHVybDogbG9jYXRpb24uaHJlZixcbiAgICBob3N0OiBsb2NhdGlvbi5ob3N0LFxuICAgIHBhdGhuYW1lOiBsb2NhdGlvbi5wYXRobmFtZSxcbiAgICByZWZlcnJlclxuICB9LCBnZXRDYW1wYWlnblBhcmFtcygpKTtcbn1cbmZ1bmN0aW9uIGdldFNjcmVlbk1ldGEoKSB7XG4gIGNvbnN0IHsgc2NyZWVuIH0gPSB3aW5kb3c7XG4gIHJldHVybiB7XG4gICAgc2NyZWVuX2hlaWdodDogc2NyZWVuLmhlaWdodCxcbiAgICBzY3JlZW5fd2lkdGg6IHNjcmVlbi53aWR0aCxcbiAgICB2aWV3cG9ydF9oZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodCxcbiAgICB2aWV3cG9ydF93aWR0aDogd2luZG93LmlubmVyV2lkdGhcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldE9TKHVzZXJBZ2VudCkge1xuICBpZiAoL1dpbmRvd3MvaS50ZXN0KHVzZXJBZ2VudCkpIHtcbiAgICBpZiAoL1Bob25lLy50ZXN0KHVzZXJBZ2VudCkgfHwgL1dQRGVza3RvcC8udGVzdCh1c2VyQWdlbnQpKSB7XG4gICAgICByZXR1cm4gXCJXaW5kb3dzIFBob25lXCI7XG4gICAgfVxuICAgIHJldHVybiBcIldpbmRvd3NcIjtcbiAgfSBlbHNlIGlmICgvKGlQaG9uZXxpUGFkfGlQb2QpLy50ZXN0KHVzZXJBZ2VudCkpIHtcbiAgICByZXR1cm4gXCJpT1NcIjtcbiAgfSBlbHNlIGlmICgvQW5kcm9pZC8udGVzdCh1c2VyQWdlbnQpKSB7XG4gICAgcmV0dXJuIFwiQW5kcm9pZFwiO1xuICB9IGVsc2UgaWYgKC8oQmxhY2tCZXJyeXxQbGF5Qm9va3xCQjEwKS9pLnRlc3QodXNlckFnZW50KSkge1xuICAgIHJldHVybiBcIkJsYWNrQmVycnlcIjtcbiAgfSBlbHNlIGlmICgvTWFjL2kudGVzdCh1c2VyQWdlbnQpKSB7XG4gICAgcmV0dXJuIFwiTWFjIE9TIFhcIjtcbiAgfSBlbHNlIGlmICgvTGludXgvLnRlc3QodXNlckFnZW50KSkge1xuICAgIHJldHVybiBcIkxpbnV4XCI7XG4gIH0gZWxzZSBpZiAoL0NyT1MvLnRlc3QodXNlckFnZW50KSkge1xuICAgIHJldHVybiBcIkNocm9tZSBPU1wiO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG59XG5mdW5jdGlvbiBnZXREZXZpY2VJbmZvKHVzZXJBZ2VudCkge1xuICBjb25zdCBQQVRURVJOUyA9IFtcbiAgICB7XG4gICAgICBkZXZpY2U6IFwiaVBob25lXCIsXG4gICAgICBwYXR0ZXJuczogWy9pUGhvbmUvXVxuICAgIH0sXG4gICAge1xuICAgICAgZGV2aWNlOiBcImlQYWRcIixcbiAgICAgIHBhdHRlcm5zOiBbL2lQYWQvXVxuICAgIH0sXG4gICAge1xuICAgICAgZGV2aWNlOiBcImlQb2QgVG91Y2hcIixcbiAgICAgIHBhdHRlcm5zOiBbL2lQb2QvXVxuICAgIH0sXG4gICAge1xuICAgICAgZGV2aWNlOiBcIldpbmRvd3MgUGhvbmVcIixcbiAgICAgIHBhdHRlcm5zOiBbL1dpbmRvd3MgUGhvbmUvaSwgL1dQRGVza3RvcC9dXG4gICAgfSxcbiAgICB7XG4gICAgICBkZXZpY2U6IFwiQW5kcm9pZFwiLFxuICAgICAgcGF0dGVybnM6IFsvQW5kcm9pZC9dXG4gICAgfVxuICBdO1xuICBjb25zdCBtYXRjaCA9IFBBVFRFUk5TLmZpbmQoXG4gICAgKHBhdHRlcm4pID0+IHBhdHRlcm4ucGF0dGVybnMuc29tZSgoZXhwcikgPT4gZXhwci50ZXN0KHVzZXJBZ2VudCkpXG4gICk7XG4gIGNvbnN0IGRldmljZSA9IG1hdGNoID09IG51bGwgPyB2b2lkIDAgOiBtYXRjaC5kZXZpY2U7XG4gIHJldHVybiB7XG4gICAgZGV2aWNlOiBkZXZpY2UgIT0gbnVsbCA/IGRldmljZSA6IFwiXCIsXG4gICAgZGV2aWNlVHlwZTogZGV2aWNlID8gXCJNb2JpbGVcIiA6IFwiRGVza3RvcFwiLFxuICAgIG9zOiBnZXRPUyh1c2VyQWdlbnQpXG4gIH07XG59XG5mdW5jdGlvbiBnZXRVc2VyQWdlbnRNZXRhKCkge1xuICBjb25zdCB7IG5hdmlnYXRvciB9ID0gd2luZG93O1xuICBjb25zdCB7IHVzZXJBZ2VudCB9ID0gbmF2aWdhdG9yO1xuICByZXR1cm4gX19zcHJlYWRWYWx1ZXMoe30sIGdldERldmljZUluZm8odXNlckFnZW50KSk7XG59XG5mdW5jdGlvbiBnZXRXaW5kb3dNZXRhKCkge1xuICBpZiAoIWlzQnJvd3NlcjIpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgcmV0dXJuIF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBnZXRMb2NhdGlvbk1ldGEoKSksIGdldFNjcmVlbk1ldGEoKSksIGdldFVzZXJBZ2VudE1ldGEoKSk7XG59XG52YXIgaXNQcm9kdWN0aW9uID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiO1xuZnVuY3Rpb24gZ2V0RW52TWV0YSgpIHtcbiAgcmV0dXJuIHtcbiAgICBpc0Jyb3dzZXI6IGlzQnJvd3NlcjIsXG4gICAgaXNQcm9kdWN0aW9uXG4gIH07XG59XG5mdW5jdGlvbiByYXdTcGxpdFZhcmlhdGlvbih2YXJpYXRpb24pIHtcbiAgY29uc3QgcmF3VmFyaWF0aW9ucyA9IHt9O1xuICBPYmplY3Qua2V5cyh2YXJpYXRpb24pLmZvckVhY2goKHZhcmlhdGlvbktleSkgPT4ge1xuICAgIGNvbnN0IFssIHNwbGl0SWRdID0gdmFyaWF0aW9uS2V5LnNwbGl0KFwiLlwiKTtcbiAgICBpZiAoc3BsaXRJZCkge1xuICAgICAgcmF3VmFyaWF0aW9uc1tzcGxpdElkXSA9IHZhcmlhdGlvblt2YXJpYXRpb25LZXldO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByYXdWYXJpYXRpb25zO1xufVxudmFyIFBPTExfVElNRSA9IDVlMztcbmZ1bmN0aW9uIHRocm90dGxlZChmdW5jMikge1xuICBsZXQgdGltZXJJZCA9IHZvaWQgMDtcbiAgcmV0dXJuIChwYXJhbSkgPT4ge1xuICAgIGlmICh0aW1lcklkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpc0Jyb3dzZXIyKSB7XG4gICAgICB0aW1lcklkID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIHRpbWVySWQgPSB2b2lkIDA7XG4gICAgICAgIGZ1bmMyKHBhcmFtKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aW1lcklkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRpbWVySWQgPSB2b2lkIDA7XG4gICAgICAgIGZ1bmMyKHBhcmFtKTtcbiAgICAgIH0sIFBPTExfVElNRSk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdHJhY2tlci9pbmRleC50c1xudmFyIEFQSV9FTkRQT0lOVCA9IFwiaHR0cHM6Ly9hbmFseXRpY3MucGxhc21pYy5hcHAvY2FwdHVyZVwiO1xudmFyIEFQSV9QVUJMSUNfS0VZID0gXCJwaGNfQlJ2WVRBb01vYW05ZkRIZnJJbmVGNjdLZHRNSmFnTFZWQ002RUxOWWQ0blwiO1xudmFyIFRSQUNLRVJfVkVSU0lPTiA9IDQ7XG52YXIgUGxhc21pY1RyYWNrZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdHMyKSB7XG4gICAgdGhpcy5vcHRzID0gb3B0czI7XG4gICAgdGhpcy5ldmVudFF1ZXVlID0gW107XG4gICAgdGhpcy5zZW5kRXZlbnRzID0gdGhyb3R0bGVkKCh0cmFuc3BvcnQpID0+IF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICh0aGlzLmV2ZW50UXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGV2ZW50cyA9IFsuLi50aGlzLmV2ZW50UXVldWVdO1xuICAgICAgdGhpcy5ldmVudFF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgICBjb25zdCBib2R5ID0ge1xuICAgICAgICBhcGlfa2V5OiBBUElfUFVCTElDX0tFWSxcbiAgICAgICAgYmF0Y2g6IGV2ZW50c1xuICAgICAgfTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHN0cmluZ0JvZHkgPSBKU09OLnN0cmluZ2lmeShib2R5KTtcbiAgICAgICAgaWYgKHRyYW5zcG9ydCA9PT0gXCJiZWFjb25cIikge1xuICAgICAgICAgIHdpbmRvdy5uYXZpZ2F0b3Iuc2VuZEJlYWNvbihBUElfRU5EUE9JTlQsIHN0cmluZ0JvZHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZmV0Y2goQVBJX0VORFBPSU5ULCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICBBY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYm9keTogc3RyaW5nQm9keVxuICAgICAgICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIH0pLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyMikge1xuICAgICAgfVxuICAgIH0pKTtcbiAgICB0aGlzLmZldGNoID0gKG9wdHMyLm5hdGl2ZUZldGNoICYmIGdsb2JhbFRoaXMuZmV0Y2ggPyBnbG9iYWxUaGlzLmZldGNoIDogdW5mZXRjaCkuYmluZChnbG9iYWxUaGlzKTtcbiAgfVxuICB0cmFja1JlbmRlcihvcHRzMikge1xuICAgIHZhciBfYSwgX2I7XG4gICAgdGhpcy5lbnF1ZXVlKHtcbiAgICAgIGV2ZW50OiBcIiRyZW5kZXJcIixcbiAgICAgIHByb3BlcnRpZXM6IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCB0aGlzLmdldFByb3BlcnRpZXMoKSksIChfYSA9IG9wdHMyID09IG51bGwgPyB2b2lkIDAgOiBvcHRzMi5yZW5kZXJDdHgpICE9IG51bGwgPyBfYSA6IHt9KSwgcmF3U3BsaXRWYXJpYXRpb24oKF9iID0gb3B0czIgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMyLnZhcmlhdGlvbikgIT0gbnVsbCA/IF9iIDoge30pKVxuICAgIH0pO1xuICB9XG4gIHRyYWNrRmV0Y2goKSB7XG4gICAgdGhpcy5lbnF1ZXVlKHtcbiAgICAgIGV2ZW50OiBcIiRmZXRjaFwiLFxuICAgICAgcHJvcGVydGllczogdGhpcy5nZXRQcm9wZXJ0aWVzKClcbiAgICB9KTtcbiAgfVxuICB0cmFja0NvbnZlcnNpb24odmFsdWUgPSAwKSB7XG4gICAgdGhpcy5lbnF1ZXVlKHtcbiAgICAgIGV2ZW50OiBcIiRjb252ZXJzaW9uXCIsXG4gICAgICBwcm9wZXJ0aWVzOiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCB0aGlzLmdldFByb3BlcnRpZXMoKSksIHtcbiAgICAgICAgdmFsdWVcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbiAgZ2V0UHJvcGVydGllcygpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgZGlzdGluY3RfaWQ6IGdldERpc3RpbmN0SWQoKVxuICAgIH0sIGdldFdpbmRvd01ldGEoKSksIGdldEVudk1ldGEoKSksIHRoaXMuZ2V0Q29udGV4dE1ldGEoKSksIGdldFZhcmlhdGlvbkNvb2tpZVZhbHVlcygpKSwge1xuICAgICAgdGltZXN0YW1wOiAoX2EgPSBEYXRlLm5vdygpKSAhPSBudWxsID8gX2EgOiArLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksXG4gICAgICB0cmFja2VyVmVyc2lvbjogVFJBQ0tFUl9WRVJTSU9OXG4gICAgfSk7XG4gIH1cbiAgZW5xdWV1ZShldmVudCkge1xuICAgIGlmICh0aGlzLm9wdHMuX19wbGFzbWljVHJhY2tlckRpc2FibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZXZlbnRRdWV1ZS5wdXNoKGV2ZW50KTtcbiAgICB0aGlzLnNlbmRFdmVudHMoXCJmZXRjaFwiKTtcbiAgfVxuICBnZXRDb250ZXh0TWV0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGxhdGZvcm06IHRoaXMub3B0cy5wbGF0Zm9ybSxcbiAgICAgIHByZXZpZXc6IHRoaXMub3B0cy5wcmV2aWV3LFxuICAgICAgcHJvamVjdElkczogdGhpcy5vcHRzLnByb2plY3RJZHNcbiAgICB9O1xuICB9XG59O1xuZXhwb3J0IHtcbiAgQXBpLFxuICBQbGFzbWljTW9kdWxlc0ZldGNoZXIsXG4gIFBsYXNtaWNUcmFja2VyLFxuICBSZWdpc3RyeSxcbiAgZ2V0QnVuZGxlU3Vic2V0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@plasmicapp/loader-core/dist/index.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@plasmicapp/loader-fetcher/dist/index.esm.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@plasmicapp/loader-fetcher/dist/index.esm.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Api: () => (/* binding */ Api),\n/* harmony export */   PlasmicModulesFetcher: () => (/* binding */ PlasmicModulesFetcher),\n/* harmony export */   internal_getCachedBundleInNodeServer: () => (/* binding */ internal_getCachedBundleInNodeServer)\n/* harmony export */ });\n/* harmony import */ var _plasmicapp_isomorphic_unfetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @plasmicapp/isomorphic-unfetch */ \"(app-pages-browser)/./node_modules/@plasmicapp/isomorphic-unfetch/browser.js\");\n/* harmony import */ var _plasmicapp_isomorphic_unfetch__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_plasmicapp_isomorphic_unfetch__WEBPACK_IMPORTED_MODULE_0__);\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/../../node_modules/process/browser.js\");\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// src/api.ts\n\nvar VERSION = \"10\";\nvar isBrowser = typeof window !== \"undefined\" && window != null && typeof window.document !== \"undefined\";\nfunction transformApiLoaderBundleOutput(bundle) {\n  return __spreadProps(__spreadValues({}, bundle), {\n    filteredIds: Object.fromEntries(bundle.projects.map((p) => [p.id, []]))\n  });\n}\nvar Api = class {\n  constructor(opts) {\n    this.opts = opts;\n    this.lastResponse = void 0;\n    var _a;\n    this.host = (_a = opts.host) != null ? _a : \"https://codegen.plasmic.app\";\n    this.fetch = (opts.nativeFetch && globalThis.fetch ? globalThis.fetch : (_plasmicapp_isomorphic_unfetch__WEBPACK_IMPORTED_MODULE_0___default())).bind(globalThis);\n  }\n  fetchLoaderData(projectIds, opts) {\n    return __async(this, null, function* () {\n      var _a, _b, _c, _d, _e, _f, _g, _h, _i;\n      const { platform, preview } = opts;\n      const query = new URLSearchParams([\n        [\"platform\", platform != null ? platform : \"react\"],\n        ...((_b = (_a = opts.platformOptions) == null ? void 0 : _a.nextjs) == null ? void 0 : _b.appDir) ? [[\"nextjsAppDir\", \"true\"]] : [],\n        ...projectIds.map((projectId) => [\"projectId\", projectId]),\n        ...opts.browserOnly ? [[\"browserOnly\", \"true\"]] : [],\n        ...opts.i18nKeyScheme ? [[\"i18nKeyScheme\", opts.i18nKeyScheme]] : [],\n        ...opts.i18nTagPrefix ? [[\"i18nTagPrefix\", opts.i18nTagPrefix]] : [],\n        ...opts.skipHead ? [[\"skipHead\", \"true\"]] : []\n      ]).toString();\n      const url = `${this.host}/api/v1/loader/code/${preview ? \"preview\" : \"published\"}?${query}`;\n      const useLastReponse = (\n        // We consider that manualRedirect is true by default, only by setting it to false\n        // we disable it.\n        !(this.opts.manualRedirect === false) && !preview && !isBrowser\n      );\n      if (useLastReponse) {\n        const redirectResp = yield this.fetch(url, {\n          method: \"GET\",\n          headers: this.makeGetHeaders(),\n          redirect: \"manual\"\n        });\n        if (redirectResp.status !== 301 && redirectResp.status !== 302) {\n          const error = yield this.parseJsonResponse(redirectResp);\n          throw new Error(\n            `Error fetching loader data, a redirect was expected: ${(_d = (_c = error == null ? void 0 : error.error) == null ? void 0 : _c.message) != null ? _d : redirectResp.statusText}`\n          );\n        }\n        const nextLocation = redirectResp.headers.get(\"location\");\n        if (!nextLocation) {\n          throw new Error(\n            `Error fetching loader data, a redirect was expected but no location header was found`\n          );\n        }\n        if (((_e = this.lastResponse) == null ? void 0 : _e.key) === nextLocation) {\n          return this.lastResponse.bundle;\n        }\n        const resp2 = yield this.fetch(`${this.host}${nextLocation}`, {\n          method: \"GET\",\n          headers: this.makeGetHeaders()\n        });\n        if (resp2.status >= 400) {\n          const error = yield this.parseJsonResponse(resp2);\n          throw new Error(\n            `Error fetching loader data: ${(_g = (_f = error == null ? void 0 : error.error) == null ? void 0 : _f.message) != null ? _g : resp2.statusText}`\n          );\n        }\n        const json2 = transformApiLoaderBundleOutput(\n          yield this.parseJsonResponse(resp2)\n        );\n        this.lastResponse = {\n          bundle: json2,\n          key: nextLocation\n        };\n        return json2;\n      }\n      const resp = yield this.fetch(url, {\n        method: \"GET\",\n        headers: this.makeGetHeaders()\n      });\n      if (resp.status >= 400) {\n        const error = yield this.parseJsonResponse(resp);\n        throw new Error(\n          `Error fetching loader data: ${(_i = (_h = error == null ? void 0 : error.error) == null ? void 0 : _h.message) != null ? _i : resp.statusText}`\n        );\n      }\n      const json = yield this.parseJsonResponse(resp);\n      return transformApiLoaderBundleOutput(json);\n    });\n  }\n  parseJsonResponse(resp) {\n    return __async(this, null, function* () {\n      const text = yield resp.text();\n      try {\n        return JSON.parse(text);\n      } catch (err) {\n        throw new Error(\n          `Error parsing JSON response: ${err}; status: ${resp.status}; response: ${text}`\n        );\n      }\n    });\n  }\n  fetchHtmlData(opts) {\n    return __async(this, null, function* () {\n      const { projectId, component, embedHydrate, hydrate } = opts;\n      const query = new URLSearchParams([\n        [\"projectId\", projectId],\n        [\"component\", component],\n        [\"embedHydrate\", embedHydrate ? \"1\" : \"0\"],\n        [\"hydrate\", hydrate ? \"1\" : \"0\"]\n      ]).toString();\n      const resp = yield this.fetch(`${this.host}/api/v1/loader/html?${query}`, {\n        method: \"GET\",\n        headers: this.makeGetHeaders()\n      });\n      const json = yield resp.json();\n      return json;\n    });\n  }\n  makeGetHeaders() {\n    return __spreadValues({\n      \"x-plasmic-loader-version\": VERSION\n    }, this.makeAuthHeaders());\n  }\n  makeAuthHeaders() {\n    const tokens = this.opts.projects.map((p) => `${p.id}:${p.token}`).join(\",\");\n    return {\n      \"x-plasmic-api-project-tokens\": tokens\n    };\n  }\n  getChunksUrl(bundle, modules) {\n    var _a;\n    return `${this.host}/api/v1/loader/chunks?bundleKey=${encodeURIComponent(\n      (_a = bundle.bundleKey) != null ? _a : \"null\"\n    )}&fileName=${encodeURIComponent(\n      modules.map((m) => m.fileName).sort().join(\",\")\n    )}`;\n  }\n};\n\n// src/fetcher.ts\nvar PlasmicModulesFetcher = class {\n  constructor(opts) {\n    this.opts = opts;\n    this.curFetch = void 0;\n    this.api = new Api({\n      projects: opts.projects,\n      host: opts.host,\n      nativeFetch: opts.nativeFetch,\n      manualRedirect: opts.manualRedirect\n    });\n  }\n  getChunksUrl(bundle, modules) {\n    return this.api.getChunksUrl(bundle, modules);\n  }\n  fetchAllData() {\n    return __async(this, null, function* () {\n      const bundle = yield this.getCachedOrFetch();\n      this.cacheBundleInNodeServer(bundle);\n      return bundle;\n    });\n  }\n  getCachedOrFetch() {\n    return __async(this, null, function* () {\n      var _a;\n      if (this.opts.cache) {\n        const cachedData = yield this.opts.cache.get();\n        if (cachedData) {\n          return cachedData;\n        }\n      }\n      if (this.curFetch) {\n        return yield this.curFetch;\n      }\n      if (typeof process === \"undefined\" || !((_a = process.env) == null ? void 0 : _a.PLASMIC_QUIET)) {\n        console.debug(\"Plasmic: doing a fresh fetch...\");\n      }\n      const fetchPromise = this.doFetch();\n      this.curFetch = fetchPromise;\n      try {\n        const data = yield fetchPromise;\n        return data;\n      } finally {\n        if (this.curFetch === fetchPromise) {\n          this.curFetch = void 0;\n        }\n      }\n    });\n  }\n  doFetch() {\n    return __async(this, null, function* () {\n      var _a, _b, _c, _d;\n      const data = yield this.api.fetchLoaderData(\n        this.opts.projects.map(\n          (p) => p.version ? `${p.id}@${p.version}` : p.id\n        ),\n        {\n          platform: this.opts.platform,\n          platformOptions: this.opts.platformOptions,\n          preview: this.opts.preview,\n          i18nKeyScheme: (_b = (_a = this.opts.i18n) == null ? void 0 : _a.keyScheme) != null ? _b : this.opts.i18nKeyScheme,\n          i18nTagPrefix: (_c = this.opts.i18n) == null ? void 0 : _c.tagPrefix,\n          browserOnly: isBrowser,\n          skipHead: this.opts.skipHead\n        }\n      );\n      if (this.opts.cache) {\n        yield this.opts.cache.set(data);\n      }\n      if (typeof process === \"undefined\" || !((_d = process.env) == null ? void 0 : _d.PLASMIC_QUIET)) {\n        console.debug(\n          `Plasmic: fetched designs for ${data.projects.map((p) => `\"${p.name}\" (${p.id}@${p.version})`).join(\", \")}`\n        );\n      }\n      return data;\n    });\n  }\n  cacheBundleInNodeServer(bundle) {\n    if (isBrowser) {\n      return;\n    }\n    const global = globalThis;\n    if (global.__PLASMIC_BUNDLES === void 0) {\n      global.__PLASMIC_BUNDLES = {};\n    }\n    global.__PLASMIC_BUNDLES[getBundleKey(this.opts)] = bundle;\n  }\n};\nfunction internal_getCachedBundleInNodeServer(opts) {\n  var _a;\n  if (isBrowser) {\n    throw new Error(`Should not be consulting Node server cache in browser`);\n  }\n  const global = globalThis;\n  return (_a = global.__PLASMIC_BUNDLES) == null ? void 0 : _a[getBundleKey(opts)];\n}\nfunction getBundleKey({\n  host,\n  platform,\n  i18nKeyScheme,\n  preview,\n  projects,\n  skipHead\n}) {\n  return JSON.stringify({\n    host,\n    platform,\n    i18nKeyScheme,\n    preview,\n    projects,\n    skipHead\n  });\n}\n\n//# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcGxhc21pY2FwcC9sb2FkZXItZmV0Y2hlci9kaXN0L2luZGV4LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsdUVBQU87QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG9CQUFvQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsVUFBVSxzQkFBc0Isa0NBQWtDLEdBQUcsTUFBTTtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxvRUFBb0Usd0hBQXdIO0FBQzVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsVUFBVSxFQUFFLGFBQWE7QUFDbkU7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsaUhBQWlIO0FBQzVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGdIQUFnSDtBQUN6SjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSwwQ0FBMEMsTUFBTSxVQUFVLGNBQWMsWUFBWSxLQUFLO0FBQ3pGO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsY0FBYyw4Q0FBOEM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFVBQVUsc0JBQXNCLE1BQU07QUFDN0U7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxvREFBb0QsS0FBSyxHQUFHLFFBQVE7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxVQUFVLGtDQUFrQztBQUMxRDtBQUNBLE1BQU0sWUFBWTtBQUNsQjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxLQUFLLEdBQUcsVUFBVTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQSwwQ0FBMEMsNkJBQTZCLE9BQU8sS0FBSyxLQUFLLEdBQUcsVUFBVSxlQUFlO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFLRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvd29uZGVybGFuZG1pdGNoL0Nhc2NhZGVQcm9qZWN0cy9Xb25kZXJWaXRlLWZyb250ZW5kL25vZGVfbW9kdWxlcy9AcGxhc21pY2FwcC9sb2FkZXItZmV0Y2hlci9kaXN0L2luZGV4LmVzbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbnZhciBfX2dldE93blByb3BEZXNjcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG52YXIgX19zcHJlYWRQcm9wcyA9IChhLCBiKSA9PiBfX2RlZlByb3BzKGEsIF9fZ2V0T3duUHJvcERlc2NzKGIpKTtcbnZhciBfX2FzeW5jID0gKF9fdGhpcywgX19hcmd1bWVudHMsIGdlbmVyYXRvcikgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHZhciBmdWxmaWxsZWQgPSAodmFsdWUpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHJlamVjdGVkID0gKHZhbHVlKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvci50aHJvdyh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgc3RlcCA9ICh4KSA9PiB4LmRvbmUgPyByZXNvbHZlKHgudmFsdWUpIDogUHJvbWlzZS5yZXNvbHZlKHgudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7XG4gICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KF9fdGhpcywgX19hcmd1bWVudHMpKS5uZXh0KCkpO1xuICB9KTtcbn07XG5cbi8vIHNyYy9hcGkudHNcbmltcG9ydCB1bmZldGNoIGZyb20gXCJAcGxhc21pY2FwcC9pc29tb3JwaGljLXVuZmV0Y2hcIjtcbnZhciBWRVJTSU9OID0gXCIxMFwiO1xudmFyIGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93ICE9IG51bGwgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIjtcbmZ1bmN0aW9uIHRyYW5zZm9ybUFwaUxvYWRlckJ1bmRsZU91dHB1dChidW5kbGUpIHtcbiAgcmV0dXJuIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIGJ1bmRsZSksIHtcbiAgICBmaWx0ZXJlZElkczogT2JqZWN0LmZyb21FbnRyaWVzKGJ1bmRsZS5wcm9qZWN0cy5tYXAoKHApID0+IFtwLmlkLCBbXV0pKVxuICB9KTtcbn1cbnZhciBBcGkgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICAgIHRoaXMubGFzdFJlc3BvbnNlID0gdm9pZCAwO1xuICAgIHZhciBfYTtcbiAgICB0aGlzLmhvc3QgPSAoX2EgPSBvcHRzLmhvc3QpICE9IG51bGwgPyBfYSA6IFwiaHR0cHM6Ly9jb2RlZ2VuLnBsYXNtaWMuYXBwXCI7XG4gICAgdGhpcy5mZXRjaCA9IChvcHRzLm5hdGl2ZUZldGNoICYmIGdsb2JhbFRoaXMuZmV0Y2ggPyBnbG9iYWxUaGlzLmZldGNoIDogdW5mZXRjaCkuYmluZChnbG9iYWxUaGlzKTtcbiAgfVxuICBmZXRjaExvYWRlckRhdGEocHJvamVjdElkcywgb3B0cykge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaTtcbiAgICAgIGNvbnN0IHsgcGxhdGZvcm0sIHByZXZpZXcgfSA9IG9wdHM7XG4gICAgICBjb25zdCBxdWVyeSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoW1xuICAgICAgICBbXCJwbGF0Zm9ybVwiLCBwbGF0Zm9ybSAhPSBudWxsID8gcGxhdGZvcm0gOiBcInJlYWN0XCJdLFxuICAgICAgICAuLi4oKF9iID0gKF9hID0gb3B0cy5wbGF0Zm9ybU9wdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5uZXh0anMpID09IG51bGwgPyB2b2lkIDAgOiBfYi5hcHBEaXIpID8gW1tcIm5leHRqc0FwcERpclwiLCBcInRydWVcIl1dIDogW10sXG4gICAgICAgIC4uLnByb2plY3RJZHMubWFwKChwcm9qZWN0SWQpID0+IFtcInByb2plY3RJZFwiLCBwcm9qZWN0SWRdKSxcbiAgICAgICAgLi4ub3B0cy5icm93c2VyT25seSA/IFtbXCJicm93c2VyT25seVwiLCBcInRydWVcIl1dIDogW10sXG4gICAgICAgIC4uLm9wdHMuaTE4bktleVNjaGVtZSA/IFtbXCJpMThuS2V5U2NoZW1lXCIsIG9wdHMuaTE4bktleVNjaGVtZV1dIDogW10sXG4gICAgICAgIC4uLm9wdHMuaTE4blRhZ1ByZWZpeCA/IFtbXCJpMThuVGFnUHJlZml4XCIsIG9wdHMuaTE4blRhZ1ByZWZpeF1dIDogW10sXG4gICAgICAgIC4uLm9wdHMuc2tpcEhlYWQgPyBbW1wic2tpcEhlYWRcIiwgXCJ0cnVlXCJdXSA6IFtdXG4gICAgICBdKS50b1N0cmluZygpO1xuICAgICAgY29uc3QgdXJsID0gYCR7dGhpcy5ob3N0fS9hcGkvdjEvbG9hZGVyL2NvZGUvJHtwcmV2aWV3ID8gXCJwcmV2aWV3XCIgOiBcInB1Ymxpc2hlZFwifT8ke3F1ZXJ5fWA7XG4gICAgICBjb25zdCB1c2VMYXN0UmVwb25zZSA9IChcbiAgICAgICAgLy8gV2UgY29uc2lkZXIgdGhhdCBtYW51YWxSZWRpcmVjdCBpcyB0cnVlIGJ5IGRlZmF1bHQsIG9ubHkgYnkgc2V0dGluZyBpdCB0byBmYWxzZVxuICAgICAgICAvLyB3ZSBkaXNhYmxlIGl0LlxuICAgICAgICAhKHRoaXMub3B0cy5tYW51YWxSZWRpcmVjdCA9PT0gZmFsc2UpICYmICFwcmV2aWV3ICYmICFpc0Jyb3dzZXJcbiAgICAgICk7XG4gICAgICBpZiAodXNlTGFzdFJlcG9uc2UpIHtcbiAgICAgICAgY29uc3QgcmVkaXJlY3RSZXNwID0geWllbGQgdGhpcy5mZXRjaCh1cmwsIHtcbiAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgaGVhZGVyczogdGhpcy5tYWtlR2V0SGVhZGVycygpLFxuICAgICAgICAgIHJlZGlyZWN0OiBcIm1hbnVhbFwiXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmVkaXJlY3RSZXNwLnN0YXR1cyAhPT0gMzAxICYmIHJlZGlyZWN0UmVzcC5zdGF0dXMgIT09IDMwMikge1xuICAgICAgICAgIGNvbnN0IGVycm9yID0geWllbGQgdGhpcy5wYXJzZUpzb25SZXNwb25zZShyZWRpcmVjdFJlc3ApO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBFcnJvciBmZXRjaGluZyBsb2FkZXIgZGF0YSwgYSByZWRpcmVjdCB3YXMgZXhwZWN0ZWQ6ICR7KF9kID0gKF9jID0gZXJyb3IgPT0gbnVsbCA/IHZvaWQgMCA6IGVycm9yLmVycm9yKSA9PSBudWxsID8gdm9pZCAwIDogX2MubWVzc2FnZSkgIT0gbnVsbCA/IF9kIDogcmVkaXJlY3RSZXNwLnN0YXR1c1RleHR9YFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV4dExvY2F0aW9uID0gcmVkaXJlY3RSZXNwLmhlYWRlcnMuZ2V0KFwibG9jYXRpb25cIik7XG4gICAgICAgIGlmICghbmV4dExvY2F0aW9uKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEVycm9yIGZldGNoaW5nIGxvYWRlciBkYXRhLCBhIHJlZGlyZWN0IHdhcyBleHBlY3RlZCBidXQgbm8gbG9jYXRpb24gaGVhZGVyIHdhcyBmb3VuZGBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoKF9lID0gdGhpcy5sYXN0UmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfZS5rZXkpID09PSBuZXh0TG9jYXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5sYXN0UmVzcG9uc2UuYnVuZGxlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3AyID0geWllbGQgdGhpcy5mZXRjaChgJHt0aGlzLmhvc3R9JHtuZXh0TG9jYXRpb259YCwge1xuICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICBoZWFkZXJzOiB0aGlzLm1ha2VHZXRIZWFkZXJzKClcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChyZXNwMi5zdGF0dXMgPj0gNDAwKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSB5aWVsZCB0aGlzLnBhcnNlSnNvblJlc3BvbnNlKHJlc3AyKTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgRXJyb3IgZmV0Y2hpbmcgbG9hZGVyIGRhdGE6ICR7KF9nID0gKF9mID0gZXJyb3IgPT0gbnVsbCA/IHZvaWQgMCA6IGVycm9yLmVycm9yKSA9PSBudWxsID8gdm9pZCAwIDogX2YubWVzc2FnZSkgIT0gbnVsbCA/IF9nIDogcmVzcDIuc3RhdHVzVGV4dH1gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBqc29uMiA9IHRyYW5zZm9ybUFwaUxvYWRlckJ1bmRsZU91dHB1dChcbiAgICAgICAgICB5aWVsZCB0aGlzLnBhcnNlSnNvblJlc3BvbnNlKHJlc3AyKVxuICAgICAgICApO1xuICAgICAgICB0aGlzLmxhc3RSZXNwb25zZSA9IHtcbiAgICAgICAgICBidW5kbGU6IGpzb24yLFxuICAgICAgICAgIGtleTogbmV4dExvY2F0aW9uXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBqc29uMjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3AgPSB5aWVsZCB0aGlzLmZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgIGhlYWRlcnM6IHRoaXMubWFrZUdldEhlYWRlcnMoKVxuICAgICAgfSk7XG4gICAgICBpZiAocmVzcC5zdGF0dXMgPj0gNDAwKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0geWllbGQgdGhpcy5wYXJzZUpzb25SZXNwb25zZShyZXNwKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBFcnJvciBmZXRjaGluZyBsb2FkZXIgZGF0YTogJHsoX2kgPSAoX2ggPSBlcnJvciA9PSBudWxsID8gdm9pZCAwIDogZXJyb3IuZXJyb3IpID09IG51bGwgPyB2b2lkIDAgOiBfaC5tZXNzYWdlKSAhPSBudWxsID8gX2kgOiByZXNwLnN0YXR1c1RleHR9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3QganNvbiA9IHlpZWxkIHRoaXMucGFyc2VKc29uUmVzcG9uc2UocmVzcCk7XG4gICAgICByZXR1cm4gdHJhbnNmb3JtQXBpTG9hZGVyQnVuZGxlT3V0cHV0KGpzb24pO1xuICAgIH0pO1xuICB9XG4gIHBhcnNlSnNvblJlc3BvbnNlKHJlc3ApIHtcbiAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgdGV4dCA9IHlpZWxkIHJlc3AudGV4dCgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodGV4dCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBFcnJvciBwYXJzaW5nIEpTT04gcmVzcG9uc2U6ICR7ZXJyfTsgc3RhdHVzOiAke3Jlc3Auc3RhdHVzfTsgcmVzcG9uc2U6ICR7dGV4dH1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZmV0Y2hIdG1sRGF0YShvcHRzKSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHsgcHJvamVjdElkLCBjb21wb25lbnQsIGVtYmVkSHlkcmF0ZSwgaHlkcmF0ZSB9ID0gb3B0cztcbiAgICAgIGNvbnN0IHF1ZXJ5ID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhbXG4gICAgICAgIFtcInByb2plY3RJZFwiLCBwcm9qZWN0SWRdLFxuICAgICAgICBbXCJjb21wb25lbnRcIiwgY29tcG9uZW50XSxcbiAgICAgICAgW1wiZW1iZWRIeWRyYXRlXCIsIGVtYmVkSHlkcmF0ZSA/IFwiMVwiIDogXCIwXCJdLFxuICAgICAgICBbXCJoeWRyYXRlXCIsIGh5ZHJhdGUgPyBcIjFcIiA6IFwiMFwiXVxuICAgICAgXSkudG9TdHJpbmcoKTtcbiAgICAgIGNvbnN0IHJlc3AgPSB5aWVsZCB0aGlzLmZldGNoKGAke3RoaXMuaG9zdH0vYXBpL3YxL2xvYWRlci9odG1sPyR7cXVlcnl9YCwge1xuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgIGhlYWRlcnM6IHRoaXMubWFrZUdldEhlYWRlcnMoKVxuICAgICAgfSk7XG4gICAgICBjb25zdCBqc29uID0geWllbGQgcmVzcC5qc29uKCk7XG4gICAgICByZXR1cm4ganNvbjtcbiAgICB9KTtcbiAgfVxuICBtYWtlR2V0SGVhZGVycygpIHtcbiAgICByZXR1cm4gX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgXCJ4LXBsYXNtaWMtbG9hZGVyLXZlcnNpb25cIjogVkVSU0lPTlxuICAgIH0sIHRoaXMubWFrZUF1dGhIZWFkZXJzKCkpO1xuICB9XG4gIG1ha2VBdXRoSGVhZGVycygpIHtcbiAgICBjb25zdCB0b2tlbnMgPSB0aGlzLm9wdHMucHJvamVjdHMubWFwKChwKSA9PiBgJHtwLmlkfToke3AudG9rZW59YCkuam9pbihcIixcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIFwieC1wbGFzbWljLWFwaS1wcm9qZWN0LXRva2Vuc1wiOiB0b2tlbnNcbiAgICB9O1xuICB9XG4gIGdldENodW5rc1VybChidW5kbGUsIG1vZHVsZXMpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIGAke3RoaXMuaG9zdH0vYXBpL3YxL2xvYWRlci9jaHVua3M/YnVuZGxlS2V5PSR7ZW5jb2RlVVJJQ29tcG9uZW50KFxuICAgICAgKF9hID0gYnVuZGxlLmJ1bmRsZUtleSkgIT0gbnVsbCA/IF9hIDogXCJudWxsXCJcbiAgICApfSZmaWxlTmFtZT0ke2VuY29kZVVSSUNvbXBvbmVudChcbiAgICAgIG1vZHVsZXMubWFwKChtKSA9PiBtLmZpbGVOYW1lKS5zb3J0KCkuam9pbihcIixcIilcbiAgICApfWA7XG4gIH1cbn07XG5cbi8vIHNyYy9mZXRjaGVyLnRzXG52YXIgUGxhc21pY01vZHVsZXNGZXRjaGVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICB0aGlzLmN1ckZldGNoID0gdm9pZCAwO1xuICAgIHRoaXMuYXBpID0gbmV3IEFwaSh7XG4gICAgICBwcm9qZWN0czogb3B0cy5wcm9qZWN0cyxcbiAgICAgIGhvc3Q6IG9wdHMuaG9zdCxcbiAgICAgIG5hdGl2ZUZldGNoOiBvcHRzLm5hdGl2ZUZldGNoLFxuICAgICAgbWFudWFsUmVkaXJlY3Q6IG9wdHMubWFudWFsUmVkaXJlY3RcbiAgICB9KTtcbiAgfVxuICBnZXRDaHVua3NVcmwoYnVuZGxlLCBtb2R1bGVzKSB7XG4gICAgcmV0dXJuIHRoaXMuYXBpLmdldENodW5rc1VybChidW5kbGUsIG1vZHVsZXMpO1xuICB9XG4gIGZldGNoQWxsRGF0YSgpIHtcbiAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgYnVuZGxlID0geWllbGQgdGhpcy5nZXRDYWNoZWRPckZldGNoKCk7XG4gICAgICB0aGlzLmNhY2hlQnVuZGxlSW5Ob2RlU2VydmVyKGJ1bmRsZSk7XG4gICAgICByZXR1cm4gYnVuZGxlO1xuICAgIH0pO1xuICB9XG4gIGdldENhY2hlZE9yRmV0Y2goKSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmICh0aGlzLm9wdHMuY2FjaGUpIHtcbiAgICAgICAgY29uc3QgY2FjaGVkRGF0YSA9IHlpZWxkIHRoaXMub3B0cy5jYWNoZS5nZXQoKTtcbiAgICAgICAgaWYgKGNhY2hlZERhdGEpIHtcbiAgICAgICAgICByZXR1cm4gY2FjaGVkRGF0YTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY3VyRmV0Y2gpIHtcbiAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuY3VyRmV0Y2g7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwidW5kZWZpbmVkXCIgfHwgISgoX2EgPSBwcm9jZXNzLmVudikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLlBMQVNNSUNfUVVJRVQpKSB7XG4gICAgICAgIGNvbnNvbGUuZGVidWcoXCJQbGFzbWljOiBkb2luZyBhIGZyZXNoIGZldGNoLi4uXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgZmV0Y2hQcm9taXNlID0gdGhpcy5kb0ZldGNoKCk7XG4gICAgICB0aGlzLmN1ckZldGNoID0gZmV0Y2hQcm9taXNlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIGZldGNoUHJvbWlzZTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAodGhpcy5jdXJGZXRjaCA9PT0gZmV0Y2hQcm9taXNlKSB7XG4gICAgICAgICAgdGhpcy5jdXJGZXRjaCA9IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGRvRmV0Y2goKSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgIGNvbnN0IGRhdGEgPSB5aWVsZCB0aGlzLmFwaS5mZXRjaExvYWRlckRhdGEoXG4gICAgICAgIHRoaXMub3B0cy5wcm9qZWN0cy5tYXAoXG4gICAgICAgICAgKHApID0+IHAudmVyc2lvbiA/IGAke3AuaWR9QCR7cC52ZXJzaW9ufWAgOiBwLmlkXG4gICAgICAgICksXG4gICAgICAgIHtcbiAgICAgICAgICBwbGF0Zm9ybTogdGhpcy5vcHRzLnBsYXRmb3JtLFxuICAgICAgICAgIHBsYXRmb3JtT3B0aW9uczogdGhpcy5vcHRzLnBsYXRmb3JtT3B0aW9ucyxcbiAgICAgICAgICBwcmV2aWV3OiB0aGlzLm9wdHMucHJldmlldyxcbiAgICAgICAgICBpMThuS2V5U2NoZW1lOiAoX2IgPSAoX2EgPSB0aGlzLm9wdHMuaTE4bikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmtleVNjaGVtZSkgIT0gbnVsbCA/IF9iIDogdGhpcy5vcHRzLmkxOG5LZXlTY2hlbWUsXG4gICAgICAgICAgaTE4blRhZ1ByZWZpeDogKF9jID0gdGhpcy5vcHRzLmkxOG4pID09IG51bGwgPyB2b2lkIDAgOiBfYy50YWdQcmVmaXgsXG4gICAgICAgICAgYnJvd3Nlck9ubHk6IGlzQnJvd3NlcixcbiAgICAgICAgICBza2lwSGVhZDogdGhpcy5vcHRzLnNraXBIZWFkXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBpZiAodGhpcy5vcHRzLmNhY2hlKSB7XG4gICAgICAgIHlpZWxkIHRoaXMub3B0cy5jYWNoZS5zZXQoZGF0YSk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwidW5kZWZpbmVkXCIgfHwgISgoX2QgPSBwcm9jZXNzLmVudikgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLlBMQVNNSUNfUVVJRVQpKSB7XG4gICAgICAgIGNvbnNvbGUuZGVidWcoXG4gICAgICAgICAgYFBsYXNtaWM6IGZldGNoZWQgZGVzaWducyBmb3IgJHtkYXRhLnByb2plY3RzLm1hcCgocCkgPT4gYFwiJHtwLm5hbWV9XCIgKCR7cC5pZH1AJHtwLnZlcnNpb259KWApLmpvaW4oXCIsIFwiKX1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9KTtcbiAgfVxuICBjYWNoZUJ1bmRsZUluTm9kZVNlcnZlcihidW5kbGUpIHtcbiAgICBpZiAoaXNCcm93c2VyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGdsb2JhbCA9IGdsb2JhbFRoaXM7XG4gICAgaWYgKGdsb2JhbC5fX1BMQVNNSUNfQlVORExFUyA9PT0gdm9pZCAwKSB7XG4gICAgICBnbG9iYWwuX19QTEFTTUlDX0JVTkRMRVMgPSB7fTtcbiAgICB9XG4gICAgZ2xvYmFsLl9fUExBU01JQ19CVU5ETEVTW2dldEJ1bmRsZUtleSh0aGlzLm9wdHMpXSA9IGJ1bmRsZTtcbiAgfVxufTtcbmZ1bmN0aW9uIGludGVybmFsX2dldENhY2hlZEJ1bmRsZUluTm9kZVNlcnZlcihvcHRzKSB7XG4gIHZhciBfYTtcbiAgaWYgKGlzQnJvd3Nlcikge1xuICAgIHRocm93IG5ldyBFcnJvcihgU2hvdWxkIG5vdCBiZSBjb25zdWx0aW5nIE5vZGUgc2VydmVyIGNhY2hlIGluIGJyb3dzZXJgKTtcbiAgfVxuICBjb25zdCBnbG9iYWwgPSBnbG9iYWxUaGlzO1xuICByZXR1cm4gKF9hID0gZ2xvYmFsLl9fUExBU01JQ19CVU5ETEVTKSA9PSBudWxsID8gdm9pZCAwIDogX2FbZ2V0QnVuZGxlS2V5KG9wdHMpXTtcbn1cbmZ1bmN0aW9uIGdldEJ1bmRsZUtleSh7XG4gIGhvc3QsXG4gIHBsYXRmb3JtLFxuICBpMThuS2V5U2NoZW1lLFxuICBwcmV2aWV3LFxuICBwcm9qZWN0cyxcbiAgc2tpcEhlYWRcbn0pIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICBob3N0LFxuICAgIHBsYXRmb3JtLFxuICAgIGkxOG5LZXlTY2hlbWUsXG4gICAgcHJldmlldyxcbiAgICBwcm9qZWN0cyxcbiAgICBza2lwSGVhZFxuICB9KTtcbn1cbmV4cG9ydCB7XG4gIEFwaSxcbiAgUGxhc21pY01vZHVsZXNGZXRjaGVyLFxuICBpbnRlcm5hbF9nZXRDYWNoZWRCdW5kbGVJbk5vZGVTZXJ2ZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lc20uanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@plasmicapp/loader-fetcher/dist/index.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@plasmicapp/loader-react/dist/index.esm.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@plasmicapp/loader-react/dist/index.esm.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7___namespace_cache;\nvar react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_6___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DataCtxReader: () => (/* reexport safe */ _plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.DataCtxReader),\n/* harmony export */   DataProvider: () => (/* reexport safe */ _plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.DataProvider),\n/* harmony export */   GlobalActionsContext: () => (/* reexport safe */ _plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.GlobalActionsContext),\n/* harmony export */   GlobalActionsProvider: () => (/* reexport safe */ _plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.GlobalActionsProvider),\n/* harmony export */   InternalPlasmicComponentLoader: () => (/* binding */ InternalPlasmicComponentLoader),\n/* harmony export */   PageParamsProvider: () => (/* reexport safe */ _plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.PageParamsProvider),\n/* harmony export */   PlasmicCanvasContext: () => (/* reexport safe */ _plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.PlasmicCanvasContext),\n/* harmony export */   PlasmicCanvasHost: () => (/* reexport safe */ _plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.PlasmicCanvasHost),\n/* harmony export */   PlasmicComponent: () => (/* binding */ PlasmicComponent),\n/* harmony export */   PlasmicComponentLoader: () => (/* binding */ PlasmicComponentLoader),\n/* harmony export */   PlasmicRootProvider: () => (/* binding */ PlasmicRootProvider),\n/* harmony export */   PlasmicTranslatorContext: () => (/* reexport safe */ _plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.PlasmicTranslatorContext),\n/* harmony export */   convertBundlesToComponentRenderData: () => (/* binding */ convertBundlesToComponentRenderData),\n/* harmony export */   extractPlasmicQueryData: () => (/* binding */ extractPlasmicQueryData),\n/* harmony export */   extractPlasmicQueryDataFromElement: () => (/* binding */ extractPlasmicQueryDataFromElement),\n/* harmony export */   hydrateFromElement: () => (/* binding */ hydrateFromElement),\n/* harmony export */   initPlasmicLoader: () => (/* binding */ initPlasmicLoader),\n/* harmony export */   matchesPagePath: () => (/* binding */ matchesPagePath),\n/* harmony export */   plasmicPrepass: () => (/* binding */ plasmicPrepass),\n/* harmony export */   renderToElement: () => (/* binding */ renderToElement),\n/* harmony export */   renderToString: () => (/* binding */ renderToString),\n/* harmony export */   repeatedElement: () => (/* reexport safe */ _plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.repeatedElement),\n/* harmony export */   useDataEnv: () => (/* reexport safe */ _plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.useDataEnv),\n/* harmony export */   usePlasmicCanvasContext: () => (/* reexport safe */ _plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.usePlasmicCanvasContext),\n/* harmony export */   usePlasmicComponent: () => (/* binding */ usePlasmicComponent),\n/* harmony export */   usePlasmicQueryData: () => (/* reexport safe */ _plasmicapp_query__WEBPACK_IMPORTED_MODULE_3__.usePlasmicQueryData),\n/* harmony export */   useSelector: () => (/* reexport safe */ _plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.useSelector),\n/* harmony export */   useSelectors: () => (/* reexport safe */ _plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.useSelectors)\n/* harmony export */ });\n/* harmony import */ var _plasmicapp_data_sources_context__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @plasmicapp/data-sources-context */ \"(app-pages-browser)/./node_modules/@plasmicapp/data-sources-context/dist/index.esm.js\");\n/* harmony import */ var _plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @plasmicapp/host */ \"(app-pages-browser)/./node_modules/@plasmicapp/host/dist/host.esm.js\");\n/* harmony import */ var _plasmicapp_loader_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @plasmicapp/loader-core */ \"(app-pages-browser)/./node_modules/@plasmicapp/loader-core/dist/index.esm.js\");\n/* harmony import */ var _plasmicapp_query__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @plasmicapp/query */ \"(app-pages-browser)/./node_modules/@plasmicapp/query/dist/index.esm.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\n/* harmony import */ var pascalcase__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! pascalcase */ \"(app-pages-browser)/./node_modules/pascalcase/index.js\");\n/* harmony import */ var pascalcase__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(pascalcase__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var _plasmicapp_loader_fetcher__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @plasmicapp/loader-fetcher */ \"(app-pages-browser)/./node_modules/@plasmicapp/loader-fetcher/dist/index.esm.js\");\n/* harmony import */ var _plasmicapp_loader_splits__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @plasmicapp/loader-splits */ \"(app-pages-browser)/./node_modules/@plasmicapp/loader-splits/dist/index.esm.js\");\n/* harmony import */ var _plasmicapp_prepass__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @plasmicapp/prepass */ \"(app-pages-browser)/./node_modules/@plasmicapp/prepass/dist/index.esm.js\");\n/* harmony import */ var react_dom_server__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! react-dom/server */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/server.browser.js\");\n/* __next_internal_client_entry_do_not_use__ DataCtxReader,DataProvider,GlobalActionsContext,GlobalActionsProvider,InternalPlasmicComponentLoader,PageParamsProvider,PlasmicCanvasContext,PlasmicCanvasHost,PlasmicComponent,PlasmicComponentLoader,PlasmicRootProvider,PlasmicTranslatorContext,convertBundlesToComponentRenderData,extractPlasmicQueryData,extractPlasmicQueryDataFromElement,hydrateFromElement,initPlasmicLoader,matchesPagePath,plasmicPrepass,renderToElement,renderToString,repeatedElement,useDataEnv,usePlasmicCanvasContext,usePlasmicComponent,usePlasmicQueryData,useSelector,useSelectors auto */ var _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$(), _s3 = $RefreshSig$(), _s4 = $RefreshSig$(), _s5 = $RefreshSig$(), _s6 = $RefreshSig$(), _s7 = $RefreshSig$(), _s8 = $RefreshSig$();\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __spreadValues = (a, b)=>{\n    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){\n        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n    }\n    return a;\n};\nvar __spreadProps = (a, b)=>__defProps(a, __getOwnPropDescs(b));\nvar __objRest = (source, exclude)=>{\n    var target = {};\n    for(var prop in source)if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];\n    if (source != null && __getOwnPropSymbols) for (var prop of __getOwnPropSymbols(source)){\n        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop)) target[prop] = source[prop];\n    }\n    return target;\n};\nvar __async = (__this, __arguments, generator)=>{\n    return new Promise((resolve, reject)=>{\n        var fulfilled = (value)=>{\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        };\n        var rejected = (value)=>{\n            try {\n                step(generator.throw(value));\n            } catch (e) {\n                reject(e);\n            }\n        };\n        var step = (x)=>x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n        step((generator = generator.apply(__this, __arguments)).next());\n    });\n};\n// src/loader-client.ts\n\n\n\n\n\n\n\n\n\n// src/PlasmicRootProvider.tsx\n\n\n\n// src/utils.tsx\n\n\nvar isBrowser = typeof window !== \"undefined\";\nfunction useForceUpdate() {\n    _s();\n    const [, setTick] = react__WEBPACK_IMPORTED_MODULE_4__.useState(0);\n    const update = react__WEBPACK_IMPORTED_MODULE_4__.useCallback({\n        \"useForceUpdate.useCallback[update]\": ()=>{\n            setTick({\n                \"useForceUpdate.useCallback[update]\": (tick)=>tick + 1\n            }[\"useForceUpdate.useCallback[update]\"]);\n        }\n    }[\"useForceUpdate.useCallback[update]\"], []);\n    return update;\n}\n_s(useForceUpdate, \"C/PHpCb03UdT1Zvs8guPjcg6YZY=\");\nfunction useStableLookupSpec(spec) {\n    _s1();\n    return useStableLookupSpecs(spec)[0];\n}\n_s1(useStableLookupSpec, \"HFvYPr5zeCv0cLCnjMv8hqiU/Ck=\", false, function() {\n    return [\n        useStableLookupSpecs\n    ];\n});\nfunction useStableLookupSpecs() {\n    for(var _len = arguments.length, specs = new Array(_len), _key = 0; _key < _len; _key++){\n        specs[_key] = arguments[_key];\n    }\n    _s2();\n    const [stableSpecs, setStableSpecs] = react__WEBPACK_IMPORTED_MODULE_4__.useState(specs);\n    react__WEBPACK_IMPORTED_MODULE_4__.useEffect({\n        \"useStableLookupSpecs.useEffect\": ()=>{\n            if (specs.length !== stableSpecs.length || specs.some({\n                \"useStableLookupSpecs.useEffect\": (s, i)=>!areLookupSpecsEqual(s, stableSpecs[i])\n            }[\"useStableLookupSpecs.useEffect\"])) {\n                setStableSpecs(specs);\n            }\n        }\n    }[\"useStableLookupSpecs.useEffect\"], [\n        specs,\n        stableSpecs\n    ]);\n    return stableSpecs;\n}\n_s2(useStableLookupSpecs, \"IoQEQ7wNY56zvz0p+WwkUiILMw8=\");\nfunction areLookupSpecsEqual(spec1, spec2) {\n    if (spec1 === spec2) {\n        return true;\n    }\n    if (typeof spec1 !== typeof spec2) {\n        return false;\n    }\n    const fullSpec1 = toFullLookup(spec1);\n    const fullSpec2 = toFullLookup(spec2);\n    return (isNameSpec(fullSpec1) && isNameSpec(fullSpec2) && fullSpec1.name === fullSpec2.name && fullSpec1.isCode === fullSpec2.isCode || isPathSpec(fullSpec1) && isPathSpec(fullSpec2) && fullSpec1.path === fullSpec2.path) && fullSpec1.projectId === fullSpec2.projectId;\n}\nfunction isNameSpec(lookup) {\n    return \"name\" in lookup;\n}\nfunction isPathSpec(lookup) {\n    return \"path\" in lookup;\n}\nfunction toFullLookup(lookup) {\n    const namePart = typeof lookup === \"string\" ? lookup : lookup.name;\n    const projectId = typeof lookup === \"string\" ? void 0 : lookup.projectId;\n    const codeComponent = typeof lookup === \"string\" ? void 0 : lookup.isCode;\n    if (codeComponent !== true && namePart.startsWith(\"/\")) {\n        return {\n            path: normalizePath(namePart),\n            projectId\n        };\n    } else {\n        return {\n            name: codeComponent ? namePart : normalizeName(namePart),\n            rawName: namePart.trim(),\n            projectId,\n            isCode: codeComponent\n        };\n    }\n}\nfunction normalizePath(path) {\n    return path.trim();\n}\nfunction normalizeName(name) {\n    return pascalcase__WEBPACK_IMPORTED_MODULE_8___default()(name).trim();\n}\nfunction useIsMounted() {\n    _s3();\n    const ref = react__WEBPACK_IMPORTED_MODULE_4__.useRef(false);\n    const isMounted = react__WEBPACK_IMPORTED_MODULE_4__.useCallback({\n        \"useIsMounted.useCallback[isMounted]\": ()=>ref.current\n    }[\"useIsMounted.useCallback[isMounted]\"], []);\n    react__WEBPACK_IMPORTED_MODULE_4__.useEffect({\n        \"useIsMounted.useEffect\": ()=>{\n            ref.current = true;\n            return ({\n                \"useIsMounted.useEffect\": ()=>{\n                    ref.current = false;\n                }\n            })[\"useIsMounted.useEffect\"];\n        }\n    }[\"useIsMounted.useEffect\"], []);\n    return isMounted;\n}\n_s3(useIsMounted, \"iZs9+d0MEO9kZwZeL/SNgPrPmtA=\");\nfunction matchesPagePath(pattern, path) {\n    const normalizedPattern = \"/\" + pattern.replace(/^\\/|\\/$/g, \"\");\n    const normalizedPath = \"/\" + path.replace(/^\\/|\\/$/g, \"\");\n    const regexString = normalizedPattern.replace(/\\/\\[\\[\\.\\.\\.([^\\]^]+)]]/g, \"(?:/([^]*))?\").replace(/\\/\\[\\.\\.\\.([^\\]^]+)]/g, \"/([^]*)\").replace(/\\[([^\\]^]+)]/g, \"([^/]+)\").replace(/\\//g, \"\\\\/\");\n    const regex = new RegExp(\"^/?\".concat(regexString, \"$\"));\n    const match = normalizedPath.match(regex);\n    if (!match) return false;\n    const slugNames = [\n        ...pattern.matchAll(/\\[\\.?\\.?\\.?([^[\\]]+)]/g)\n    ].map((m)=>m[1]);\n    const params = {};\n    for(let i = 0; i < slugNames.length; i++){\n        const slugName = slugNames[i];\n        const value = match[i + 1];\n        if (pattern.includes(\"[[...\".concat(slugName, \"]]\"))) {\n            params[slugName] = value ? value.split(\"/\").filter(Boolean) : [];\n        } else if (pattern.includes(\"[...\".concat(slugName, \"]\"))) {\n            params[slugName] = value.split(\"/\").filter(Boolean);\n        } else if (value !== void 0) {\n            params[slugName] = value;\n        }\n    }\n    return {\n        params\n    };\n}\nfunction isDynamicPagePath(path) {\n    return !!path.match(/\\[[^/]*\\]/);\n}\nfunction matchesCompMeta(lookup, meta) {\n    if (lookup.projectId && meta.projectId !== lookup.projectId) {\n        return false;\n    }\n    return isNameSpec(lookup) ? (lookup.name === meta.name || lookup.rawName === meta.name || lookup.rawName === meta.displayName) && (lookup.isCode == null || lookup.isCode === meta.isCode) : !!(meta.path && matchesPagePath(meta.path, lookup.path));\n}\nfunction getCompMetas(metas, lookup) {\n    const full = toFullLookup(lookup);\n    return metas.filter((meta)=>matchesCompMeta(full, meta)).map((meta)=>{\n        if (isNameSpec(full) || !meta.path) {\n            return meta;\n        }\n        const match = matchesPagePath(meta.path, full.path);\n        if (!match) {\n            return meta;\n        }\n        return __spreadProps(__spreadValues({}, meta), {\n            params: match.params\n        });\n    }).sort((meta1, meta2)=>// We sort the matched component metas by the number of path params, so\n        // if there are two pages `/products/foo` and `/products/[slug]`,\n        // the first one will have higher precedence.\n        Array.from(Object.keys(meta1.params || {})).length - Array.from(Object.keys(meta2.params || {})).length);\n}\nfunction getLookupSpecName(lookup) {\n    if (typeof lookup === \"string\") {\n        return lookup;\n    } else if (lookup.projectId) {\n        return \"\".concat(lookup.name, \" (project \").concat(lookup.projectId, \")\");\n    } else {\n        return lookup.name;\n    }\n}\nfunction MaybeWrap(props) {\n    return props.cond ? props.wrapper(props.children) : props.children;\n}\n_c = MaybeWrap;\nfunction uniq(elements) {\n    return Array.from(new Set(elements));\n}\nfunction intersect(a, b) {\n    const setB = new Set(b);\n    return a.filter((elt)=>setB.has(elt));\n}\n// src/variation.ts\nfunction getPlasmicCookieValues() {\n    return Object.fromEntries(document.cookie.split(\"; \").filter((cookie)=>cookie.includes(\"plasmic:\")).map((cookie)=>cookie.split(\"=\")).map((param)=>{\n        let [key, value] = param;\n        return [\n            key.split(\":\")[1],\n            value\n        ];\n    }));\n}\nfunction updatePlasmicCookieValue(key, value) {\n    document.cookie = \"plasmic:\".concat(key, \"=\").concat(value);\n}\nfunction ensureVariationCookies() {\n    let variation = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    Object.keys(variation).map((variationKey)=>{\n        const sliceId = variation[variationKey];\n        updatePlasmicCookieValue(variationKey, sliceId);\n    });\n}\nvar getGlobalVariantsFromSplits = (splits, variation)=>{\n    const globalVariants = [];\n    Object.keys(variation).map((variationKey)=>{\n        const [_type, splitId] = variationKey.split(\".\");\n        const sliceId = variation[variationKey];\n        const split = splits.find((s)=>s.id === splitId || s.externalId === splitId);\n        if (split) {\n            const slice = split.slices.find((s)=>s.id === sliceId || s.externalId === sliceId);\n            if (slice) {\n                slice.contents.map((x)=>{\n                    globalVariants.push({\n                        name: x.group,\n                        value: x.variant,\n                        projectId: x.projectId\n                    });\n                });\n            }\n        }\n    });\n    return globalVariants;\n};\nvar mergeGlobalVariantsSpec = (target, from)=>{\n    let result = [\n        ...target\n    ];\n    const existingGlobalVariants = new Set(target.map((t)=>{\n        var _a;\n        return \"\".concat(t.name, \"-\").concat((_a = t.projectId) != null ? _a : \"\");\n    }));\n    const newGlobals = from.filter((t)=>{\n        var _a;\n        return !existingGlobalVariants.has(\"\".concat(t.name, \"-\").concat((_a = t.projectId) != null ? _a : \"\"));\n    });\n    if (newGlobals.length > 0) {\n        result = [\n            ...result,\n            ...newGlobals\n        ];\n    }\n    return result;\n};\n// src/PlasmicRootProvider.tsx\nvar PlasmicRootContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.createContext(void 0);\nfunction PlasmicRootProvider(props) {\n    _s4();\n    const { globalVariants, prefetchedData, children, skipCss, skipFonts, prefetchedQueryData, suspenseForQueryData, globalContextsProps, variation, translator, Head, Link, pageRoute, pageParams, pageQuery, suspenseFallback, disableLoadingBoundary, disableRootLoadingBoundary } = props;\n    const loader = props.loader.__internal;\n    if (prefetchedData) {\n        loader.registerPrefetchedBundle(prefetchedData.bundle);\n    }\n    const [splits, setSplits] = react__WEBPACK_IMPORTED_MODULE_4__.useState(loader.getActiveSplits());\n    const forceUpdate = useForceUpdate();\n    const watcher = react__WEBPACK_IMPORTED_MODULE_4__.useMemo({\n        \"PlasmicRootProvider.useMemo[watcher]\": ()=>({\n                onDataFetched: ({\n                    \"PlasmicRootProvider.useMemo[watcher]\": ()=>{\n                        setSplits(loader.getActiveSplits());\n                        forceUpdate();\n                    }\n                })[\"PlasmicRootProvider.useMemo[watcher]\"]\n            })\n    }[\"PlasmicRootProvider.useMemo[watcher]\"], [\n        loader,\n        forceUpdate\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_4__.useEffect({\n        \"PlasmicRootProvider.useEffect\": ()=>{\n            loader.subscribePlasmicRoot(watcher);\n            return ({\n                \"PlasmicRootProvider.useEffect\": ()=>loader.unsubscribePlasmicRoot(watcher)\n            })[\"PlasmicRootProvider.useEffect\"];\n        }\n    }[\"PlasmicRootProvider.useEffect\"], [\n        watcher,\n        loader\n    ]);\n    const currentContextValue = react__WEBPACK_IMPORTED_MODULE_4__.useContext(PlasmicRootContext);\n    const { user, userAuthToken, isUserLoading, authRedirectUri } = props;\n    const value = react__WEBPACK_IMPORTED_MODULE_4__.useMemo({\n        \"PlasmicRootProvider.useMemo[value]\": ()=>{\n            var _a, _b, _c;\n            const withCurrentContextValueFallback = {\n                \"PlasmicRootProvider.useMemo[value].withCurrentContextValueFallback\": (v, key)=>{\n                    return v !== void 0 ? v : currentContextValue == null ? void 0 : currentContextValue[key];\n                }\n            }[\"PlasmicRootProvider.useMemo[value].withCurrentContextValueFallback\"];\n            return {\n                globalVariants: [\n                    ...mergeGlobalVariantsSpec(globalVariants != null ? globalVariants : [], getGlobalVariantsFromSplits(splits, variation != null ? variation : {})),\n                    ...(_a = currentContextValue == null ? void 0 : currentContextValue.globalVariants) != null ? _a : []\n                ],\n                globalContextsProps: __spreadValues(__spreadValues({}, (_b = currentContextValue == null ? void 0 : currentContextValue.globalContextsProps) != null ? _b : {}), globalContextsProps != null ? globalContextsProps : {}),\n                loader: withCurrentContextValueFallback(loader, \"loader\"),\n                variation: __spreadValues(__spreadValues({}, (_c = currentContextValue == null ? void 0 : currentContextValue.variation) != null ? _c : {}), variation != null ? variation : {}),\n                translator: withCurrentContextValueFallback(translator, \"translator\"),\n                Head: withCurrentContextValueFallback(Head, \"Head\"),\n                Link: withCurrentContextValueFallback(Link, \"Link\"),\n                user: withCurrentContextValueFallback(user, \"user\"),\n                userAuthToken: withCurrentContextValueFallback(userAuthToken, \"userAuthToken\"),\n                isUserLoading: withCurrentContextValueFallback(isUserLoading, \"isUserLoading\"),\n                authRedirectUri: withCurrentContextValueFallback(authRedirectUri, \"authRedirectUri\"),\n                suspenseFallback: withCurrentContextValueFallback(suspenseFallback, \"suspenseFallback\"),\n                disableLoadingBoundary: withCurrentContextValueFallback(disableLoadingBoundary, \"disableLoadingBoundary\")\n            };\n        }\n    }[\"PlasmicRootProvider.useMemo[value]\"], [\n        globalVariants,\n        variation,\n        globalContextsProps,\n        loader,\n        splits,\n        translator,\n        Head,\n        Link,\n        user,\n        userAuthToken,\n        isUserLoading,\n        authRedirectUri,\n        suspenseFallback,\n        disableLoadingBoundary,\n        currentContextValue\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_4__.useEffect({\n        \"PlasmicRootProvider.useEffect\": ()=>{\n            ensureVariationCookies(variation);\n            loader.trackRender({\n                renderCtx: {\n                    // We track the provider as a single entity\n                    rootComponentId: \"provider\",\n                    teamIds: loader.getTeamIds(),\n                    projectIds: loader.getProjectIds()\n                },\n                variation: value.variation\n            });\n        }\n    }[\"PlasmicRootProvider.useEffect\"], [\n        loader,\n        value\n    ]);\n    const reactMajorVersion = +react__WEBPACK_IMPORTED_MODULE_4__.version.split(\".\")[0];\n    const shouldDisableRootLoadingBoundary = disableRootLoadingBoundary != null ? disableRootLoadingBoundary : loader.getBundle().disableRootLoadingBoundaryByDefault;\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.createElement(_plasmicapp_query__WEBPACK_IMPORTED_MODULE_3__.PlasmicQueryDataProvider, {\n        prefetchedCache: prefetchedQueryData,\n        suspense: suspenseForQueryData\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.createElement(PlasmicRootContext.Provider, {\n        value\n    }, !skipCss && /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.createElement(PlasmicCss, {\n        loader,\n        prefetchedData,\n        skipFonts\n    }), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.createElement(_plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.PageParamsProvider, {\n        route: pageRoute,\n        params: pageParams,\n        query: pageQuery\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.createElement(MaybeWrap, {\n        cond: !shouldDisableRootLoadingBoundary && reactMajorVersion >= 18,\n        wrapper: (contents)=>/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.createElement(react__WEBPACK_IMPORTED_MODULE_4__.Suspense, {\n                fallback: suspenseFallback != null ? suspenseFallback : \"Loading...\"\n            }, contents)\n    }, children))));\n}\n_s4(PlasmicRootProvider, \"dp8/avAt8ZU0QNcmxi4hS8dat6g=\", false, function() {\n    return [\n        useForceUpdate\n    ];\n});\n_c1 = PlasmicRootProvider;\nvar PlasmicCss = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.memo(_s5(function PlasmicCss2(props) {\n    _s5();\n    const { loader, prefetchedData, skipFonts } = props;\n    const [useScopedCss, setUseScopedCss] = react__WEBPACK_IMPORTED_MODULE_4__.useState(!!prefetchedData);\n    const builtCss = buildCss(loader, {\n        scopedCompMetas: useScopedCss && prefetchedData ? prefetchedData.bundle.components : void 0,\n        skipFonts\n    });\n    const forceUpdate = useForceUpdate();\n    const watcher = react__WEBPACK_IMPORTED_MODULE_4__.useMemo({\n        \"PlasmicCss.PlasmicCss2.useMemo[watcher]\": ()=>({\n                onDataFetched: ({\n                    \"PlasmicCss.PlasmicCss2.useMemo[watcher]\": ()=>{\n                        setUseScopedCss(false);\n                        forceUpdate();\n                    }\n                })[\"PlasmicCss.PlasmicCss2.useMemo[watcher]\"]\n            })\n    }[\"PlasmicCss.PlasmicCss2.useMemo[watcher]\"], [\n        loader,\n        forceUpdate\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_4__.useEffect({\n        \"PlasmicCss.PlasmicCss2.useEffect\": ()=>{\n            loader.subscribePlasmicRoot(watcher);\n            return ({\n                \"PlasmicCss.PlasmicCss2.useEffect\": ()=>loader.unsubscribePlasmicRoot(watcher)\n            })[\"PlasmicCss.PlasmicCss2.useEffect\"];\n        }\n    }[\"PlasmicCss.PlasmicCss2.useEffect\"], [\n        watcher,\n        loader\n    ]);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.createElement(\"style\", {\n        dangerouslySetInnerHTML: {\n            __html: builtCss\n        }\n    });\n}, \"MDgZenSi1JmA/5Y20FQ3EhF/enk=\", false, function() {\n    return [\n        useForceUpdate\n    ];\n}));\n_c2 = PlasmicCss;\nfunction buildCss(loader, opts) {\n    const { scopedCompMetas, skipFonts } = opts;\n    const cssFiles = scopedCompMetas && /* @__PURE__ */ new Set([\n        \"entrypoint.css\",\n        ...scopedCompMetas.map((c)=>c.cssFile)\n    ]);\n    const cssModules = loader.getLookup().getCss().filter((f)=>!cssFiles || cssFiles.has(f.fileName));\n    const getPri = (fileName)=>fileName === \"entrypoint.css\" ? 0 : 1;\n    const compareModules = (a, b)=>getPri(a.fileName) !== getPri(b.fileName) ? getPri(a.fileName) - getPri(b.fileName) : a.fileName.localeCompare(b.fileName);\n    cssModules.sort(compareModules);\n    const remoteFonts = loader.getLookup().getRemoteFonts();\n    return \"\\n    \".concat(skipFonts ? \"\" : remoteFonts.map((f)=>\"@import url('\".concat(f.url, \"');\")).join(\"\\n\"), \"\\n    \").concat(cssModules.map((mod)=>mod.source).join(\"\\n\"), \"\\n  \");\n}\nfunction usePlasmicRootContext() {\n    _s6();\n    return react__WEBPACK_IMPORTED_MODULE_4__.useContext(PlasmicRootContext);\n}\n_s6(usePlasmicRootContext, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\n// src/global-variants.ts\nfunction createUseGlobalVariant(name, projectId) {\n    var _s = $RefreshSig$();\n    return _s(()=>{\n        _s();\n        var _a;\n        const rootContext = usePlasmicRootContext();\n        if (!rootContext) {\n            return void 0;\n        }\n        const loader = rootContext.loader;\n        const spec = [\n            ...loader.getGlobalVariants(),\n            ...(_a = rootContext.globalVariants) != null ? _a : []\n        ].find((spec2)=>spec2.name === name && (!spec2.projectId || spec2.projectId === projectId));\n        return spec ? spec.value : void 0;\n    }, \"NwTWBEGEYONzizV71x69W2d766M=\", false, function() {\n        return [\n            usePlasmicRootContext\n        ];\n    });\n}\n// src/loader-shared.ts\n\n\n\n// src/bundles.ts\n\nfunction getUsedComps(allComponents, entryCompIds) {\n    const q = [\n        ...entryCompIds\n    ];\n    const seenIds = new Set(entryCompIds);\n    const componentMetaById = new Map(allComponents.map((meta)=>[\n            meta.id,\n            meta\n        ]));\n    const usedComps = [];\n    while(q.length > 0){\n        const [id] = q.splice(0, 1);\n        const meta = componentMetaById.get(id);\n        if (!meta) {\n            continue;\n        }\n        usedComps.push(meta);\n        meta.usedComponents.forEach((usedCompId)=>{\n            if (!seenIds.has(usedCompId)) {\n                seenIds.add(usedCompId);\n                q.push(usedCompId);\n            }\n        });\n    }\n    return usedComps;\n}\nfunction prepComponentData(bundle, compMetas, opts) {\n    if (compMetas.length === 0) {\n        return {\n            entryCompMetas: bundle.components,\n            bundle,\n            remoteFontUrls: []\n        };\n    }\n    const usedComps = getUsedComps(bundle.components, compMetas.map((compMeta)=>compMeta.id));\n    const compPaths = usedComps.map((compMeta)=>compMeta.entry);\n    const subBundle = (0,_plasmicapp_loader_core__WEBPACK_IMPORTED_MODULE_2__.getBundleSubset)(bundle, [\n        \"entrypoint.css\",\n        ...compPaths,\n        \"root-provider.js\",\n        ...bundle.projects.map((x)=>x.globalContextsProviderFileName).filter((x)=>!!x),\n        // We need to explicitly include global context provider components\n        // to make sure they are kept in bundle.components. That's because\n        // for esbuild, just the globalContextsProviderFileName is not enough,\n        // because it will import a chunk that includes the global context\n        // component, instead of importing that global context component's\n        // entry file. And because nothing depends on the global context component's\n        // entry file, we end up excluding the global context component from\n        // bundle.components, which then makes its substitution not work.\n        // Instead, we forcibly include it here (we'll definitely need it anyway!).\n        ...bundle.components.filter((c)=>c.isGlobalContextProvider).map((c)=>c.entry),\n        ...bundle.globalGroups.map((g)=>g.contextFile)\n    ], opts);\n    const remoteFontUrls = [];\n    subBundle.projects.forEach((p)=>remoteFontUrls.push(...p.remoteFonts.map((f)=>f.url)));\n    return {\n        entryCompMetas: compMetas,\n        bundle: subBundle,\n        remoteFontUrls\n    };\n}\nfunction mergeBundles(target, from) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const existingProjects = new Set(target.projects.map((p)=>p.id));\n    const newProjects = from.projects.filter((p)=>!existingProjects.has(p.id));\n    if (newProjects.length > 0) {\n        target = __spreadProps(__spreadValues({}, target), {\n            projects: [\n                ...target.projects,\n                ...newProjects\n            ]\n        });\n    }\n    const existingCompIds = new Set(target.components.map((c)=>c.id));\n    function shouldIncludeComponentInBundle(c) {\n        var _a2;\n        if (existingCompIds.has(c.id)) {\n            return false;\n        }\n        if (!existingProjects.has(c.projectId)) {\n            return true;\n        }\n        const targetBundleFilteredIds = (_a2 = target.filteredIds[c.projectId]) != null ? _a2 : [];\n        return targetBundleFilteredIds.includes(c.id);\n    }\n    const newCompMetas = from.components.filter((m)=>shouldIncludeComponentInBundle(m));\n    if (newCompMetas.length > 0) {\n        target = __spreadProps(__spreadValues({}, target), {\n            components: [\n                ...target.components,\n                ...newCompMetas\n            ]\n        });\n        target.filteredIds = Object.fromEntries(Object.entries(target.filteredIds).map((param)=>{\n            let [k, v] = param;\n            return [\n                k,\n                [\n                    ...v\n                ]\n            ];\n        }));\n        from.projects.forEach((fromProject)=>{\n            var _a2, _b2;\n            const projectId = fromProject.id;\n            const fromBundleFilteredIds = (_a2 = from.filteredIds[projectId]) != null ? _a2 : [];\n            if (!existingProjects.has(projectId)) {\n                target.filteredIds[projectId] = [\n                    ...fromBundleFilteredIds\n                ];\n            } else {\n                target.filteredIds[projectId] = intersect((_b2 = target.filteredIds[projectId]) != null ? _b2 : [], fromBundleFilteredIds);\n            }\n        });\n    }\n    const existingModules = {\n        browser: new Set(target.modules.browser.map((m)=>m.fileName)),\n        server: new Set(target.modules.server.map((m)=>m.fileName))\n    };\n    const newModules = {\n        browser: from.modules.browser.filter((m)=>!existingModules.browser.has(m.fileName)),\n        server: from.modules.server.filter((m)=>!existingModules.server.has(m.fileName))\n    };\n    if (newModules.browser.length > 0 || newModules.server.length > 0) {\n        target = __spreadProps(__spreadValues({}, target), {\n            modules: {\n                browser: [\n                    ...target.modules.browser,\n                    ...newModules.browser\n                ],\n                server: [\n                    ...target.modules.server,\n                    ...newModules.server\n                ]\n            }\n        });\n    }\n    const existingGlobalIds = new Set(target.globalGroups.map((g)=>g.id));\n    const newGlobals = from.globalGroups.filter((g)=>!existingGlobalIds.has(g.id));\n    if (newGlobals.length > 0) {\n        target = __spreadProps(__spreadValues({}, target), {\n            globalGroups: [\n                ...target.globalGroups,\n                ...newGlobals\n            ]\n        });\n    }\n    const existingSplitIds = new Set(target.activeSplits.map((s)=>s.id));\n    const newSplits = (_a = from.activeSplits.filter(// Don't include splits belonging to projects already present\n    // in the target bundle\n    (s)=>!existingSplitIds.has(s.id) && !existingProjects.has(s.projectId))) != null ? _a : [];\n    if (newSplits.length > 0) {\n        target = __spreadProps(__spreadValues({}, target), {\n            activeSplits: [\n                ...target.activeSplits,\n                ...newSplits\n            ]\n        });\n    }\n    target.bundleKey = (_c = (_b = target.bundleKey) != null ? _b : from.bundleKey) != null ? _c : null;\n    target.deferChunksByDefault = (_e = (_d = target.deferChunksByDefault) != null ? _d : from.deferChunksByDefault) != null ? _e : false;\n    target.disableRootLoadingBoundaryByDefault = (_g = (_f = target.disableRootLoadingBoundaryByDefault) != null ? _f : from.disableRootLoadingBoundaryByDefault) != null ? _g : false;\n    return target;\n}\nvar convertBundlesToComponentRenderData = (bundles, compMetas)=>{\n    if (bundles.length === 0) {\n        return null;\n    }\n    const mergedBundles = bundles.reduce((prev, cur)=>mergeBundles(prev, cur));\n    return prepComponentData(mergedBundles, compMetas);\n};\n// src/component-lookup.ts\nfunction getFirstCompMeta(metas, lookup) {\n    const filtered = getCompMetas(metas, lookup);\n    return filtered.length === 0 ? void 0 : filtered[0];\n}\nvar ComponentLookup = class {\n    getComponentMeta(spec) {\n        const compMeta = getFirstCompMeta(this.bundle.components, spec);\n        return compMeta;\n    }\n    getComponent(spec) {\n        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        const compMeta = getFirstCompMeta(this.bundle.components, spec);\n        if (!compMeta) {\n            throw new Error(\"Component not found: \".concat(spec));\n        }\n        const moduleName = compMeta.entry;\n        if (!this.registry.hasModule(moduleName, opts)) {\n            throw new Error(\"Component not yet fetched: \".concat(compMeta.name));\n        }\n        const entry = this.registry.load(moduleName, {\n            forceOriginal: opts.forceOriginal\n        });\n        return !opts.forceOriginal && typeof (entry == null ? void 0 : entry.getPlasmicComponent) === \"function\" ? entry.getPlasmicComponent() : entry.default;\n    }\n    hasComponent(spec) {\n        const compMeta = getFirstCompMeta(this.bundle.components, spec);\n        if (compMeta) {\n            return this.registry.hasModule(compMeta.entry);\n        }\n        return false;\n    }\n    getGlobalContexts() {\n        const customGlobalMetas = this.bundle.globalGroups.filter((m)=>m.type === \"global-user-defined\");\n        return customGlobalMetas.map((meta)=>({\n                meta,\n                context: this.registry.load(meta.contextFile).default\n            }));\n    }\n    getGlobalContextsProvider(spec) {\n        const compMeta = getFirstCompMeta(this.bundle.components, spec);\n        const projectMeta = compMeta ? this.bundle.projects.find((x)=>x.id === compMeta.projectId) : void 0;\n        if (!projectMeta || !projectMeta.globalContextsProviderFileName || !this.registry.hasModule(projectMeta.globalContextsProviderFileName)) {\n            return void 0;\n        }\n        const entry = this.registry.load(projectMeta.globalContextsProviderFileName);\n        return typeof (entry == null ? void 0 : entry.getPlasmicComponent) === \"function\" ? entry.getPlasmicComponent() : entry.default;\n    }\n    getRootProvider() {\n        const entry = this.registry.load(\"root-provider.js\");\n        return entry.default;\n    }\n    getCss() {\n        return this.bundle.modules.browser.filter((mod)=>mod.type === \"asset\" && mod.fileName.endsWith(\"css\"));\n    }\n    getRemoteFonts() {\n        return this.bundle.projects.flatMap((p)=>p.remoteFonts);\n    }\n    constructor(bundle, registry){\n        this.bundle = bundle;\n        this.registry = registry;\n    }\n};\n// src/loader-shared.ts\nvar SUBSTITUTED_COMPONENTS = {};\nvar REGISTERED_CODE_COMPONENT_HELPERS = {};\nvar SUBSTITUTED_GLOBAL_VARIANT_HOOKS = {};\nvar REGISTERED_CUSTOM_FUNCTIONS = {};\nfunction customFunctionImportAlias(meta) {\n    const customFunctionPrefix = \"__fn_\";\n    return meta.namespace ? \"\".concat(customFunctionPrefix).concat(meta.namespace, \"__\").concat(meta.name) : \"\".concat(customFunctionPrefix).concat(meta.name);\n}\nfunction parseFetchComponentDataArgs() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    let specs;\n    let opts;\n    if (Array.isArray(args[0])) {\n        specs = args[0];\n        opts = args[1];\n    } else {\n        specs = args;\n        opts = void 0;\n    }\n    return {\n        specs,\n        opts\n    };\n}\nvar BaseInternalPlasmicComponentLoader = class {\n    maybeGetCompMetas() {\n        for(var _len = arguments.length, specs = new Array(_len), _key = 0; _key < _len; _key++){\n            specs[_key] = arguments[_key];\n        }\n        const found = /* @__PURE__ */ new Set();\n        const missing = [];\n        for (const spec of specs){\n            const filteredMetas = getCompMetas(this.bundle.components, spec);\n            if (filteredMetas.length > 0) {\n                filteredMetas.forEach((meta)=>found.add(meta));\n            } else {\n                missing.push(spec);\n            }\n        }\n        return {\n            found: Array.from(found.keys()),\n            missing\n        };\n    }\n    maybeFetchComponentData() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        return __async(this, null, function*() {\n            const { specs, opts } = parseFetchComponentDataArgs(...args);\n            const returnWithSpecsToFetch = (specsToFetch)=>__async(this, null, function*() {\n                    yield this.fetchMissingData({\n                        missingSpecs: specsToFetch\n                    });\n                    const { found: existingMetas2, missing: missingSpecs2 } = this.maybeGetCompMetas(...specs);\n                    if (missingSpecs2.length > 0) {\n                        return null;\n                    }\n                    return prepComponentData(this.bundle, existingMetas2, opts);\n                });\n            if (this.opts.alwaysFresh) {\n                return yield returnWithSpecsToFetch(specs);\n            }\n            const { found: existingMetas, missing: missingSpecs } = this.maybeGetCompMetas(...specs);\n            if (missingSpecs.length === 0) {\n                return prepComponentData(this.bundle, existingMetas, opts);\n            }\n            return yield returnWithSpecsToFetch(missingSpecs);\n        });\n    }\n    fetchComponentData() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        return __async(this, null, function*() {\n            const { specs, opts } = parseFetchComponentDataArgs(...args);\n            const data = yield this.maybeFetchComponentData(specs, opts);\n            if (!data) {\n                const { missing: missingSpecs } = this.maybeGetCompMetas(...specs);\n                throw new Error(\"Unable to find components \".concat(missingSpecs.map(getLookupSpecName).join(\", \")));\n            }\n            return data;\n        });\n    }\n    fetchPages(opts) {\n        return __async(this, null, function*() {\n            this.maybeReportClientSideFetch(()=>\"Plasmic: fetching all page metadata in the browser\");\n            const data = yield this.fetchAllData();\n            return data.components.filter((comp)=>comp.isPage && comp.path && ((opts == null ? void 0 : opts.includeDynamicPages) || !isDynamicPagePath(comp.path)));\n        });\n    }\n    fetchComponents() {\n        return __async(this, null, function*() {\n            this.maybeReportClientSideFetch(()=>\"Plasmic: fetching all component metadata in the browser\");\n            const data = yield this.fetchAllData();\n            return data.components;\n        });\n    }\n    getActiveSplits() {\n        return this.bundle.activeSplits;\n    }\n    getChunksUrl(bundle, modules) {\n        return this.fetcher.getChunksUrl(bundle, modules);\n    }\n    fetchMissingData(opts) {\n        return __async(this, null, function*() {\n            this.maybeReportClientSideFetch(()=>\"Plasmic: fetching missing components in the browser: \".concat(opts.missingSpecs.map((spec)=>getLookupSpecName(spec)).join(\", \")));\n            return this.fetchAllData();\n        });\n    }\n    maybeReportClientSideFetch(mkMsg) {\n        if (isBrowser && this.opts.onClientSideFetch) {\n            const msg = mkMsg();\n            if (this.opts.onClientSideFetch === \"warn\") {\n                console.warn(msg);\n            } else {\n                throw new Error(msg);\n            }\n        }\n    }\n    fetchAllData() {\n        return __async(this, null, function*() {\n            var _a;\n            const bundle = yield this.fetcher.fetchAllData();\n            this.tracker.trackFetch();\n            this.mergeBundle(bundle);\n            (_a = this.onBundleFetched) == null ? void 0 : _a.call(this);\n            return bundle;\n        });\n    }\n    mergeBundle(newBundle) {\n        var _a, _b;\n        newBundle.bundleKey = (_a = newBundle.bundleKey) != null ? _a : null;\n        if (newBundle.bundleKey && this.bundle.bundleKey && newBundle.bundleKey !== this.bundle.bundleKey) {\n            console.warn(\"Plasmic Error: Different code export hashes. This can happen if your app is using different loaders with different project IDs or project versions.\\nConflicting values:\\n\".concat(newBundle.bundleKey, \"\\n\").concat(this.bundle.bundleKey));\n        }\n        this.bundle = mergeBundles(newBundle, this.bundle);\n        (_b = this.onBundleMerged) == null ? void 0 : _b.call(this);\n    }\n    getBundle() {\n        return this.bundle;\n    }\n    clearCache() {\n        this.bundle = {\n            modules: {\n                browser: [],\n                server: []\n            },\n            components: [],\n            globalGroups: [],\n            projects: [],\n            activeSplits: [],\n            bundleKey: null,\n            deferChunksByDefault: false,\n            disableRootLoadingBoundaryByDefault: false,\n            filteredIds: {}\n        };\n        this.registry.clear();\n    }\n    registerModules(modules) {\n        if (Object.keys(modules).some((name)=>this.registry.getRegisteredModule(name) !== modules[name])) {\n            if (!this.registry.isEmpty()) {\n                console.warn(\"Calling PlasmicComponentLoader.registerModules() after Plasmic component has rendered; starting over.\");\n                this.registry.clear();\n            }\n            for (const key of Object.keys(modules)){\n                this.registry.register(key, modules[key]);\n            }\n        }\n    }\n    substituteComponent(component, name) {\n        this.internalSubstituteComponent(component, name, void 0);\n    }\n    internalSubstituteComponent(component, name, codeComponentHelpers) {\n        if (!this.isRegistryEmpty()) {\n            console.warn(\"Calling PlasmicComponentLoader.registerSubstitution() after Plasmic component has rendered; starting over.\");\n            this.clearRegistry();\n        }\n        this.subs.push({\n            lookup: name,\n            component,\n            codeComponentHelpers\n        });\n    }\n    refreshRegistry() {\n        for (const sub of this.subs){\n            const metas = getCompMetas(this.getBundle().components, sub.lookup);\n            metas.forEach((meta)=>{\n                SUBSTITUTED_COMPONENTS[meta.id] = sub.component;\n                if (sub.codeComponentHelpers) {\n                    REGISTERED_CODE_COMPONENT_HELPERS[meta.id] = sub.codeComponentHelpers;\n                }\n            });\n        }\n        this.registry.updateModules(this.getBundle());\n    }\n    isRegistryEmpty() {\n        return this.registry.isEmpty();\n    }\n    clearRegistry() {\n        this.registry.clear();\n    }\n    setGlobalVariants(globalVariants) {\n        this.globalVariants = globalVariants;\n    }\n    getGlobalVariants() {\n        return this.globalVariants;\n    }\n    registerPrefetchedBundle(bundle) {\n        if (!isBrowser) {\n            const cachedBundle = (0,_plasmicapp_loader_fetcher__WEBPACK_IMPORTED_MODULE_9__.internal_getCachedBundleInNodeServer)(this.opts);\n            if (cachedBundle) {\n                this.mergeBundle(cachedBundle);\n            }\n        }\n        this.mergeBundle(bundle);\n    }\n    getLookup() {\n        return new ComponentLookup(this.getBundle(), this.registry);\n    }\n    trackConversion() {\n        let value = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;\n        this.tracker.trackConversion(value);\n    }\n    getActiveVariation(opts) {\n        return __async(this, null, function*() {\n            yield this.fetchComponents();\n            return (0,_plasmicapp_loader_splits__WEBPACK_IMPORTED_MODULE_10__.getActiveVariation)(__spreadProps(__spreadValues({}, opts), {\n                splits: this.getBundle().activeSplits\n            }));\n        });\n    }\n    getTeamIds() {\n        return uniq(this.getBundle().projects.map((p)=>p.teamId ? \"\".concat(p.teamId).concat(p.indirect ? \"@indirect\" : \"\") : null).filter((x)=>!!x));\n    }\n    getProjectIds() {\n        return uniq(this.getBundle().projects.map((p)=>\"\".concat(p.id).concat(p.indirect ? \"@indirect\" : \"\")));\n    }\n    trackRender(opts) {\n        this.tracker.trackRender(opts);\n    }\n    constructor(args){\n        this.registry = new _plasmicapp_loader_core__WEBPACK_IMPORTED_MODULE_2__.Registry();\n        this.globalVariants = [];\n        this.subs = [];\n        this.bundle = {\n            modules: {\n                browser: [],\n                server: []\n            },\n            components: [],\n            globalGroups: [],\n            projects: [],\n            activeSplits: [],\n            bundleKey: null,\n            deferChunksByDefault: false,\n            disableRootLoadingBoundaryByDefault: false,\n            filteredIds: {}\n        };\n        this.opts = args.opts;\n        this.fetcher = args.fetcher;\n        this.tracker = args.tracker;\n        this.onBundleMerged = args.onBundleMerged;\n        this.onBundleFetched = args.onBundleFetched;\n        this.registerModules(args.builtinModules);\n    }\n};\nvar PlasmicComponentLoader = class {\n    /**\n   * Sets global variants to be used for all components.  Note that\n   * this is not reactive, and will not re-render all components\n   * already mounted; instead, it should be used to activate global\n   * variants that should always be activated for the lifetime of this\n   * app.  If you'd like to reactively change the global variants,\n   * you should specify them via <PlasmicRootProvider />\n   */ setGlobalVariants(globalVariants) {\n        this.__internal.setGlobalVariants(globalVariants);\n    }\n    registerModules(modules) {\n        this.__internal.registerModules(modules);\n    }\n    /**\n   * Register custom components that should be swapped in for\n   * components defined in your project.  You can use this to\n   * swap in / substitute a Plasmic component with a \"real\" component.\n   */ substituteComponent(component, name) {\n        this.__internal.substituteComponent(component, name);\n    }\n    registerComponent(component, metaOrName) {\n        if (metaOrName && typeof metaOrName === \"object\" && \"props\" in metaOrName) {\n            this.__internal.registerComponent(component, metaOrName);\n        } else {\n            if ( true && !this.warnedRegisterComponent) {\n                console.warn(\"PlasmicLoader: Using deprecated method `registerComponent` for component substitution. Please consider using `substituteComponent` instead.\");\n                this.warnedRegisterComponent = true;\n            }\n            this.substituteComponent(component, metaOrName);\n        }\n    }\n    registerFunction(fn, meta) {\n        this.__internal.registerFunction(fn, meta);\n    }\n    registerGlobalContext(context, meta) {\n        this.__internal.registerGlobalContext(context, meta);\n    }\n    registerTrait(trait, meta) {\n        this.__internal.registerTrait(trait, meta);\n    }\n    registerToken(token) {\n        this.__internal.registerToken(token);\n    }\n    fetchComponentData() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        return this.__internal.fetchComponentData(...args);\n    }\n    maybeFetchComponentData() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        return __async(this, null, function*() {\n            return this.__internal.maybeFetchComponentData(...args);\n        });\n    }\n    /**\n   * Returns all the page component metadata for these projects.\n   */ fetchPages(opts) {\n        return __async(this, null, function*() {\n            return this.__internal.fetchPages(opts);\n        });\n    }\n    /**\n   * Returns all components metadata for these projects.\n   */ fetchComponents() {\n        return __async(this, null, function*() {\n            return this.__internal.fetchComponents();\n        });\n    }\n    _getActiveVariation(opts) {\n        return __async(this, null, function*() {\n            return this.__internal.getActiveVariation(opts);\n        });\n    }\n    getActiveVariation(opts) {\n        return __async(this, null, function*() {\n            return this._getActiveVariation({\n                traits: opts.traits,\n                getKnownValue: (key)=>{\n                    if (opts.known) {\n                        return opts.known[key];\n                    } else {\n                        const cookies = getPlasmicCookieValues();\n                        return cookies[key];\n                    }\n                },\n                updateKnownValue: (key, value)=>{\n                    if (!opts.known) {\n                        updatePlasmicCookieValue(key, value);\n                    }\n                }\n            });\n        });\n    }\n    getChunksUrl(bundle, modules) {\n        return this.__internal.getChunksUrl(bundle, modules);\n    }\n    getExternalVariation(variation, filters) {\n        return (0,_plasmicapp_loader_splits__WEBPACK_IMPORTED_MODULE_10__.getExternalIds)(this.getActiveSplits(), variation, filters);\n    }\n    getActiveSplits() {\n        return this.__internal.getActiveSplits();\n    }\n    trackConversion() {\n        let value = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;\n        this.__internal.trackConversion(value);\n    }\n    clearCache() {\n        return this.__internal.clearCache();\n    }\n    constructor(internal){\n        this.warnedRegisterComponent = false;\n        this.__internal = internal;\n    }\n};\n// src/loader-client.ts\nvar InternalPlasmicComponentLoader = class extends BaseInternalPlasmicComponentLoader {\n    registerComponent(component, meta) {\n        var _a, _b;\n        const stateHelpers = Object.fromEntries(Object.entries((_a = meta.states) != null ? _a : {}).filter((param)=>{\n            let [_, stateSpec] = param;\n            return Object.keys(stateSpec).some((key)=>_plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.stateHelpersKeys.includes(key));\n        }).map((param)=>{\n            let [stateName, stateSpec] = param;\n            return [\n                stateName,\n                Object.fromEntries(_plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.stateHelpersKeys.filter((key)=>key in stateSpec).map((key)=>[\n                        key,\n                        stateSpec[key]\n                    ]))\n            ];\n        }));\n        const helpers = {\n            states: stateHelpers\n        };\n        this.internalSubstituteComponent(component, {\n            name: meta.name,\n            isCode: true\n        }, Object.keys(stateHelpers).length > 0 ? helpers : void 0);\n        (0,_plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.registerComponent)(component, __spreadValues(__spreadProps(__spreadValues({}, meta), {\n            // Import path is not used as we will use component substitution\n            importPath: (_b = meta.importPath) != null ? _b : \"\"\n        }), Object.keys(stateHelpers).length > 0 ? {\n            componentHelpers: {\n                helpers,\n                importPath: \"\",\n                importName: \"\"\n            }\n        } : {}));\n    }\n    registerFunction(fn, meta) {\n        var _a;\n        (0,_plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.registerFunction)(fn, __spreadProps(__spreadValues({}, meta), {\n            importPath: (_a = meta.importPath) != null ? _a : \"\"\n        }));\n        REGISTERED_CUSTOM_FUNCTIONS[customFunctionImportAlias(meta)] = fn;\n    }\n    registerGlobalContext(context, meta) {\n        var _a;\n        this.substituteComponent(context, {\n            name: meta.name,\n            isCode: true\n        });\n        (0,_plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.registerGlobalContext)(context, __spreadProps(__spreadValues({}, meta), {\n            importPath: (_a = meta.importPath) != null ? _a : \"\"\n        }));\n    }\n    registerTrait(trait, meta) {\n        (0,_plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.registerTrait)(trait, meta);\n    }\n    registerToken(token) {\n        (0,_plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.registerToken)(token);\n    }\n    subscribePlasmicRoot(watcher) {\n        this.roots.push(watcher);\n    }\n    unsubscribePlasmicRoot(watcher) {\n        const index = this.roots.indexOf(watcher);\n        if (index >= 0) {\n            this.roots.splice(index, 1);\n        }\n    }\n    refreshRegistry() {\n        for (const globalGroup of this.getBundle().globalGroups){\n            if (globalGroup.type !== \"global-screen\") {\n                SUBSTITUTED_GLOBAL_VARIANT_HOOKS[globalGroup.id] = createUseGlobalVariant(globalGroup.name, globalGroup.projectId);\n            }\n        }\n        super.refreshRegistry();\n    }\n    constructor(opts){\n        const tracker = new _plasmicapp_loader_core__WEBPACK_IMPORTED_MODULE_2__.PlasmicTracker(__spreadProps(__spreadValues({}, opts), {\n            projectIds: opts.projects.map((p)=>p.id)\n        }));\n        super({\n            opts,\n            tracker,\n            fetcher: new _plasmicapp_loader_core__WEBPACK_IMPORTED_MODULE_2__.PlasmicModulesFetcher(opts),\n            onBundleMerged: ()=>{\n                this.refreshRegistry();\n            },\n            onBundleFetched: ()=>{\n                this.roots.forEach((watcher)=>{\n                    var _a;\n                    return (_a = watcher.onDataFetched) == null ? void 0 : _a.call(watcher);\n                });\n            },\n            builtinModules: {\n                react: (react__WEBPACK_IMPORTED_MODULE_4___default()),\n                \"react-dom\": react_dom__WEBPACK_IMPORTED_MODULE_5__,\n                \"react/jsx-runtime\": /*#__PURE__*/ (react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7___namespace_cache || (react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7___namespace_cache = __webpack_require__.t(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__, 2))),\n                \"react/jsx-dev-runtime\": /*#__PURE__*/ (react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_6___namespace_cache || (react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_6___namespace_cache = __webpack_require__.t(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_6__, 2))),\n                // Also inject @plasmicapp/query and @plasmicapp/host to use the\n                // same contexts here and in loader-downloaded code.\n                \"@plasmicapp/query\": _plasmicapp_query__WEBPACK_IMPORTED_MODULE_3__,\n                \"@plasmicapp/data-sources-context\": _plasmicapp_data_sources_context__WEBPACK_IMPORTED_MODULE_0__,\n                \"@plasmicapp/host\": _plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__,\n                \"@plasmicapp/loader-runtime-registry\": {\n                    components: SUBSTITUTED_COMPONENTS,\n                    globalVariantHooks: SUBSTITUTED_GLOBAL_VARIANT_HOOKS,\n                    codeComponentHelpers: REGISTERED_CODE_COMPONENT_HELPERS,\n                    functions: REGISTERED_CUSTOM_FUNCTIONS\n                }\n            }\n        });\n        this.roots = [];\n    }\n};\n// src/index.ts\n\n\n// src/PlasmicComponent.tsx\n\n// src/usePlasmicComponent.tsx\n\nfunction usePlasmicComponent(spec) {\n    let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    _s7();\n    const rootContext = usePlasmicRootContext();\n    if (!rootContext) {\n        throw new Error(\"You can only use usePlasmicComponent if wrapped in <PlasmicRootProvider />\");\n    }\n    const loader = rootContext.loader;\n    const lookup = loader.getLookup();\n    const component = lookup.hasComponent(spec) ? lookup.getComponent(spec, opts) : void 0;\n    const stableSpec = useStableLookupSpec(spec);\n    const isMounted = useIsMounted();\n    const forceUpdate = useForceUpdate();\n    react__WEBPACK_IMPORTED_MODULE_4__.useEffect({\n        \"usePlasmicComponent.useEffect\": ()=>{\n            if (!component) {\n                ({\n                    \"usePlasmicComponent.useEffect\": ()=>__async(this, null, {\n                            \"usePlasmicComponent.useEffect\": function*() {\n                                yield loader.fetchComponentData(stableSpec);\n                                if (isMounted()) {\n                                    forceUpdate();\n                                }\n                            }\n                        }[\"usePlasmicComponent.useEffect\"])\n                })[\"usePlasmicComponent.useEffect\"]();\n            }\n        }\n    }[\"usePlasmicComponent.useEffect\"], [\n        component,\n        stableSpec\n    ]);\n    return component;\n}\n_s7(usePlasmicComponent, \"FeEpXtobzEbq0vmiNGAG7AddZL4=\", false, function() {\n    return [\n        usePlasmicRootContext,\n        useStableLookupSpec,\n        useIsMounted,\n        useForceUpdate\n    ];\n});\n// src/PlasmicComponent.tsx\nvar PlasmicComponentContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.createContext(false);\nfunction PlasmicComponent(props) {\n    _s8();\n    const { component, projectId, componentProps, forceOriginal } = props;\n    const rootContext = usePlasmicRootContext();\n    const isRootLoader = !react__WEBPACK_IMPORTED_MODULE_4__.useContext(PlasmicComponentContext);\n    if (!rootContext) {\n        throw new Error(\"You must use <PlasmicRootProvider/> at the root of your app\");\n    }\n    const _a = rootContext, { loader, globalContextsProps, variation, userAuthToken, isUserLoading, authRedirectUri, translator } = _a, rest = __objRest(_a, [\n        \"loader\",\n        \"globalContextsProps\",\n        \"variation\",\n        \"userAuthToken\",\n        \"isUserLoading\",\n        \"authRedirectUri\",\n        \"translator\"\n    ]);\n    const Component = usePlasmicComponent({\n        name: component,\n        projectId,\n        isCode: false\n    }, {\n        forceOriginal\n    });\n    react__WEBPACK_IMPORTED_MODULE_4__.useEffect({\n        \"PlasmicComponent.useEffect\": ()=>{\n            if (isRootLoader) {\n                const meta = loader.getLookup().getComponentMeta({\n                    name: component,\n                    projectId\n                });\n                if (meta) {\n                    loader.trackRender({\n                        renderCtx: {\n                            rootProjectId: meta.projectId,\n                            rootComponentId: meta.id,\n                            rootComponentName: component,\n                            teamIds: loader.getTeamIds(),\n                            projectIds: loader.getProjectIds()\n                        },\n                        variation\n                    });\n                }\n            }\n        }\n    }[\"PlasmicComponent.useEffect\"], [\n        component,\n        projectId,\n        loader,\n        variation\n    ]);\n    const element = react__WEBPACK_IMPORTED_MODULE_4__.useMemo({\n        \"PlasmicComponent.useMemo[element]\": ()=>{\n            var _a2;\n            if (!Component) {\n                return null;\n            }\n            let elt = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.createElement(Component, __spreadValues({}, componentProps));\n            if (isRootLoader) {\n                const lookup = loader.getLookup();\n                const ReactWebRootProvider = lookup.getRootProvider();\n                const GlobalContextsProvider = lookup.getGlobalContextsProvider({\n                    name: component,\n                    projectId\n                });\n                elt = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.createElement(ReactWebRootProvider, __spreadProps(__spreadValues({}, rest), {\n                    userAuthToken,\n                    isUserLoading,\n                    authRedirectUri,\n                    i18n: {\n                        translator,\n                        tagPrefix: (_a2 = loader.opts.i18n) == null ? void 0 : _a2.tagPrefix\n                    }\n                }), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.createElement(MaybeWrap, {\n                    cond: !!GlobalContextsProvider,\n                    wrapper: {\n                        \"PlasmicComponent.useMemo[element]\": (children)=>/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.createElement(GlobalContextsProvider, __spreadValues({}, globalContextsProps), children)\n                    }[\"PlasmicComponent.useMemo[element]\"]\n                }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.createElement(PlasmicComponentContext.Provider, {\n                    value: true\n                }, elt)));\n            }\n            return elt;\n        }\n    }[\"PlasmicComponent.useMemo[element]\"], [\n        Component,\n        componentProps,\n        loader,\n        isRootLoader,\n        component,\n        projectId,\n        globalContextsProps,\n        userAuthToken,\n        // Just use the token to memo, `user` should be derived from it\n        isUserLoading,\n        authRedirectUri\n    ]);\n    return element;\n}\n_s8(PlasmicComponent, \"hI/qIiAnnqPTF07xuvnrvNXv/fY=\", false, function() {\n    return [\n        usePlasmicRootContext,\n        usePlasmicComponent\n    ];\n});\n_c3 = PlasmicComponent;\n// src/prepass-client.ts\n\nfunction extractPlasmicQueryData(element) {\n    return (0,_plasmicapp_prepass__WEBPACK_IMPORTED_MODULE_11__.extractPlasmicQueryData)(element);\n}\nfunction plasmicPrepass(element) {\n    return (0,_plasmicapp_prepass__WEBPACK_IMPORTED_MODULE_11__.plasmicPrepass)(element);\n}\n// src/render.tsx\n\n\n\n\nfunction renderToElement(_0, _1, _2) {\n    return __async(this, arguments, function*(loader, target, lookup) {\n        let opts = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n        return new Promise((resolve)=>{\n            const element = makeElement(loader, lookup, opts);\n            react_dom__WEBPACK_IMPORTED_MODULE_5__.render(element, target, ()=>resolve());\n        });\n    });\n}\nfunction renderToString(loader, lookup) {\n    let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    const element = makeElement(loader, lookup, opts);\n    return (0,react_dom_server__WEBPACK_IMPORTED_MODULE_12__.renderToString)(element);\n}\nfunction extractPlasmicQueryDataFromElement(_0, _1) {\n    return __async(this, arguments, function*(loader, lookup) {\n        let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        const element = makeElement(loader, lookup, opts);\n        return (0,_plasmicapp_prepass__WEBPACK_IMPORTED_MODULE_11__.extractPlasmicQueryData)(element);\n    });\n}\nfunction hydrateFromElement(_0, _1, _2) {\n    return __async(this, arguments, function*(loader, target, lookup) {\n        let opts = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n        return new Promise((resolve)=>{\n            const element = makeElement(loader, lookup, opts);\n            react_dom__WEBPACK_IMPORTED_MODULE_5__.hydrate(element, target, ()=>resolve());\n        });\n    });\n}\nfunction makeElement(loader, lookup) {\n    let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4___default().createElement(PlasmicRootProvider, {\n        loader,\n        prefetchedData: opts.prefetchedData,\n        globalVariants: opts.globalVariants,\n        prefetchedQueryData: opts.prefetchedQueryData,\n        pageParams: opts.pageParams,\n        pageQuery: opts.pageQuery\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4___default().createElement(PlasmicComponent, {\n        component: typeof lookup === \"string\" ? lookup : lookup.name,\n        projectId: typeof lookup === \"string\" ? void 0 : lookup.projectId,\n        componentProps: opts.componentProps\n    }));\n}\n// src/index.ts\nfunction initPlasmicLoader(opts) {\n    const internal = new InternalPlasmicComponentLoader(opts);\n    return new PlasmicComponentLoader(internal);\n}\n //# sourceMappingURL=index.esm.js.map\nvar _c, _c1, _c2, _c3;\n$RefreshReg$(_c, \"MaybeWrap\");\n$RefreshReg$(_c1, \"PlasmicRootProvider\");\n$RefreshReg$(_c2, \"PlasmicCss\");\n$RefreshReg$(_c3, \"PlasmicComponent\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcGxhc21pY2FwcC9sb2FkZXItcmVhY3QvZGlzdC9pbmRleC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMkM7QUFFZDtBQVd0QjtBQUMrQztBQUN4QjtBQUNaO0FBQ0c7QUFDVTtBQUNIOztBQ2xCTztBQUVNO0FBQ2xCOztBQ0hBO0FBQ0E7QUFFaEIsSUFBTSxZQUFZLE9BQU8sV0FBVztBQW9CcEMsU0FBUyxpQkFBaUI7O0lBQy9CLE1BQU0sQ0FBQyxFQUFFLE9BQU8sSUFBVSw0Q0FBUyxDQUFDO0lBQ3BDLE1BQU0sU0FBZTs4Q0FBWTtZQUMvQjtzREFBUSxDQUFDLE9BQVMsT0FBTyxDQUFDOztRQUM1Qjs2Q0FBRyxDQUFDLENBQUM7SUFDTCxPQUFPO0FBQ1Q7O0FBRU8sNkJBQTZCLE1BQTJCOztJQUM3RCw0QkFBNEIsSUFBSSxFQUFFLENBQUM7QUFDckM7SUFGZ0I7O1FBQ1A7OztBQUdGO0lBQVM7Y0FBQSx1QkFBd0I7OztJQUN0QyxNQUFNLENBQUMsYUFBYSxjQUFjLElBQVUsNENBQVMsS0FBSztJQUVwRDswQ0FBVTtZQUNkLElBQ0UsTUFBTSxXQUFXLFlBQVksVUFDN0IsTUFBTTtrREFBSyxDQUFDLEdBQUcsSUFBTSxDQUFDLG9CQUFvQixHQUFHLFlBQVksQ0FBQyxDQUFDLENBQUM7a0RBQzVEO2dCQUNBLGVBQWUsS0FBSztZQUN0QjtRQUNGO3lDQUFHO1FBQUM7UUFBTyxXQUFXO0tBQUM7SUFDdkIsT0FBTztBQUNUO0lBWmdCO0FBY2hCLFNBQVMsb0JBQ1AsT0FDQSxPQUNBO0lBQ0EsSUFBSSxVQUFVLE9BQU87UUFDbkIsT0FBTztJQUNUO0lBQ0EsSUFBSSxPQUFPLFVBQVUsT0FBTyxPQUFPO1FBQ2pDLE9BQU87SUFDVDtJQUVBLE1BQU0sWUFBWSxhQUFhLEtBQUs7SUFDcEMsTUFBTSxZQUFZLGFBQWEsS0FBSztJQUNwQyxRQUNJLFdBQVcsU0FBUyxLQUNwQixXQUFXLFNBQVMsS0FDcEIsVUFBVSxTQUFTLFVBQVUsUUFDN0IsVUFBVSxXQUFXLFVBQVUsVUFDOUIsV0FBVyxTQUFTLEtBQ25CLFdBQVcsU0FBUyxLQUNwQixVQUFVLFNBQVMsVUFBVSxTQUNqQyxVQUFVLGNBQWMsVUFBVTtBQUV0QztBQUVBLFNBQVMsV0FBVyxRQUFzRDtJQUN4RSxPQUFPLFVBQVU7QUFDbkI7QUFFQSxTQUFTLFdBQVcsUUFBc0Q7SUFDeEUsT0FBTyxVQUFVO0FBQ25CO0FBRUEsU0FBUyxhQUFhLFFBQTZDO0lBQ2pFLE1BQU0sV0FBVyxPQUFPLFdBQVcsV0FBVyxTQUFTLE9BQU87SUFDOUQsTUFBTSxZQUFZLE9BQU8sV0FBVyxXQUFXLFNBQVksT0FBTztJQUNsRSxNQUFNLGdCQUFnQixPQUFPLFdBQVcsV0FBVyxTQUFZLE9BQU87SUFFdEUsSUFBSSxrQkFBa0IsUUFBUSxTQUFTLFdBQVcsR0FBRyxHQUFHO1FBQ3RELE9BQU87WUFBRSxNQUFNLGNBQWMsUUFBUTtZQUFHO1FBQVU7SUFDcEQsT0FBTztRQUNMLE9BQU87WUFDTCxNQUFNLGdCQUFnQixXQUFXLGNBQWMsUUFBUTtZQUN2RCxTQUFTLFNBQVMsS0FBSztZQUN2QjtZQUNBLFFBQVE7UUFDVjtJQUNGO0FBQ0Y7QUFFQSxTQUFTLGNBQWMsTUFBYztJQUNuQyxPQUFPLEtBQUssS0FBSztBQUNuQjtBQUVBLFNBQVMsY0FBYyxNQUFjO0lBRW5DLE9BQU8saURBQVUsQ0FBQyxJQUFJLEVBQUUsS0FBSztBQUMvQjtBQUVPOztJQUNMLE1BQU0sTUFBWSwwQ0FBZ0IsS0FBSztJQUN2QyxNQUFNLFlBQWtCOytDQUFZLElBQU0sSUFBSTs4Q0FBUyxDQUFDLENBQUM7SUFFbkQ7a0NBQVU7WUFDZCxJQUFJLFVBQVU7WUFDZDswQ0FBTztvQkFDTCxJQUFJLFVBQVU7Z0JBQ2hCOztRQUNGO2lDQUFHLENBQUMsQ0FBQztJQUVMLE9BQU87QUFDVDtJQVpnQixlQUE4QjtBQTBCdkMsU0FBUyxnQkFBZ0IsU0FBaUIsTUFBYztJQUk3RCxNQUFNLG9CQUFvQixNQUFNLFFBQVEsUUFBUSxZQUFZLEVBQUU7SUFDOUQsTUFBTSxpQkFBaUIsTUFBTSxLQUFLLFFBQVEsWUFBWSxFQUFFO0lBR3hELE1BQU0sY0FBYyxrQkFDakIsUUFBUSw0QkFBNEIsY0FBYyxFQUNsRCxRQUFRLHlCQUF5QixTQUFTLEVBQzFDLFFBQVEsaUJBQWlCLFNBQVMsRUFDbEMsUUFBUSxPQUFPLEtBQUs7SUFFdkIsTUFBTSxRQUFRLElBQUksT0FBTyxNQUFNLHNCQUFjO0lBQzdDLE1BQU0sUUFBUSxlQUFlLE1BQU0sS0FBSztJQUV4QyxJQUFJLENBQUMsT0FBTyxPQUFPO0lBR25CLE1BQU0sWUFBWSxDQUFDO1dBQUcsUUFBUSxTQUFTLHdCQUF3QixDQUFDO0tBQUEsQ0FBRSxJQUNoRSxDQUFDLElBQU0sRUFBRSxDQUFDO0lBSVosTUFBTSxTQUE0QyxDQUFDO0lBQ25ELFFBQVMsSUFBSSxHQUFHLElBQUksVUFBVSxRQUFRLElBQUs7UUFDekMsTUFBTSxXQUFXLFVBQVUsQ0FBQztRQUM1QixNQUFNLFFBQVEsTUFBTSxJQUFJLENBQUM7UUFFekIsSUFBSSxRQUFRLFNBQVMsUUFBUSxHQUFZLElBQVosa0JBQWU7WUFFMUMsT0FBTyxRQUFRLElBQUksUUFBUSxNQUFNLE1BQU0sR0FBRyxFQUFFLE9BQU8sT0FBTyxJQUFJLENBQUM7UUFDakUsV0FBVyxRQUFRLFNBQVMsT0FBTyxtQkFBVyxLQUFHO1lBRS9DLE9BQU8sUUFBUSxJQUFJLE1BQU0sTUFBTSxHQUFHLEVBQUUsT0FBTyxPQUFPO1FBQ3BELFdBQVcsVUFBVSxRQUFXO1lBRTlCLE9BQU8sUUFBUSxJQUFJO1FBQ3JCO0lBQ0Y7SUFFQSxPQUFPO1FBQUU7SUFBTztBQUNsQjtBQUVPLFNBQVMsa0JBQWtCLE1BQXVCO0lBQ3ZELE9BQU8sQ0FBQyxDQUFDLEtBQUssTUFBTSxXQUFXO0FBQ2pDO0FBRUEsU0FBUyxnQkFBZ0IsUUFBd0IsTUFBcUI7SUFDcEUsSUFBSSxPQUFPLGFBQWEsS0FBSyxjQUFjLE9BQU8sV0FBVztRQUMzRCxPQUFPO0lBQ1Q7SUFFQSxPQUFPLFdBQVcsTUFBTSxLQUNuQixPQUFPLFNBQVMsS0FBSyxRQUNwQixPQUFPLFlBQVksS0FBSyxRQUN4QixPQUFPLFlBQVksS0FBSyxpQkFDdkIsT0FBTyxVQUFVLFFBQVEsT0FBTyxXQUFXLEtBQUssVUFDbkQsQ0FBQyxFQUFFLEtBQUssUUFBUSxnQkFBZ0IsS0FBSyxNQUFNLE9BQU8sS0FBSTtBQUM1RDtBQUVPLFNBQVMsYUFDZCxPQUNBLFFBQ0E7SUFDQSxNQUFNLE9BQU8sYUFBYSxNQUFNO0lBQ2hDLE9BQU8sTUFDSixPQUFPLENBQUMsT0FBUyxnQkFBZ0IsTUFBTSxJQUFJLENBQUMsRUFDNUMsSUFDQyxDQUFDO1FBQ0MsSUFBSSxXQUFXLElBQUksS0FBSyxDQUFDLEtBQUssTUFBTTtZQUNsQyxPQUFPO1FBQ1Q7UUFFQSxNQUFNLFFBQVEsZ0JBQWdCLEtBQUssTUFBTSxLQUFLLElBQUk7UUFDbEQsSUFBSSxDQUFDLE9BQU87WUFDVixPQUFPO1FBQ1Q7UUFFQSxPQUFPLGlDQUFLLE9BQUw7WUFBVyxRQUFRLE1BQU07UUFBTztJQUN6QyxHQUVELEtBQ0MsQ0FBQyxPQUFPO1FBQUE7UUFBQTtRQUlOLE1BQU0sS0FBSyxPQUFPLEtBQUssTUFBTSxVQUFVLENBQUMsQ0FBQyxDQUFDLEVBQUUsU0FDNUMsTUFBTSxLQUFLLE9BQU8sS0FBSyxNQUFNLFVBQVUsQ0FBQyxDQUFDLENBQUMsRUFBRTtBQUVwRDtBQUVPLFNBQVMsa0JBQWtCLFFBQTZCO0lBQzdELElBQUksT0FBTyxXQUFXLFVBQVU7UUFDOUIsT0FBTztJQUNULFdBQVcsT0FBTyxXQUFXO1FBQzNCLE9BQU8sVUFBRyxPQUFPLG9CQUF3QixPQUFQLE9BQU87SUFDM0MsT0FBTztRQUNMLE9BQU8sT0FBTztJQUNoQjtBQUNGO0FBRU8sbUJBQW1CLE9BSXZCO0lBQ0QsT0FDRSxNQUFNLE9BQU8sTUFBTSxRQUFRLE1BQU0sUUFBUSxJQUFJLE1BQU07QUFFdkQ7S0FSZ0I7QUFVVCxTQUFTLEtBQVEsVUFBb0I7SUFDMUMsT0FBTyxNQUFNLEtBQUssSUFBSSxJQUFJLFFBQVEsQ0FBQztBQUNyQztBQWVPLFNBQVMsVUFBYSxHQUFRLEdBQWE7SUFDaEQsTUFBTSxPQUFPLElBQUksSUFBSSxDQUFDO0lBQ3RCLE9BQU8sRUFBRSxPQUFPLENBQUMsTUFBUSxLQUFLLElBQUksR0FBRyxDQUFDO0FBQ3hDOztBQ3JRTyxTQUFTLHlCQUF5QjtJQUN2QyxPQUFPLE9BQU8sWUFDWixTQUFTLE9BQ04sTUFBTSxJQUFJLEVBQ1YsT0FBTyxDQUFDLFNBQVcsT0FBTyxTQUFTLFVBQVUsQ0FBQyxFQUM5QyxJQUFJLENBQUMsU0FBVyxPQUFPLE1BQU0sR0FBRyxDQUFDLEVBQ2pDLElBQUk7WUFBQyxDQUFDLEtBQUssS0FBSztlQUFNO1lBQUMsSUFBSSxNQUFNLEdBQUcsRUFBRSxDQUFDO1lBQUcsS0FBSztTQUFDOztBQUV2RDtBQUVPLFNBQVMseUJBQXlCLEtBQWEsT0FBZTtJQUNuRSxTQUFTLFNBQVMsa0JBQVcsVUFBTztBQUN0QztBQUVPLFNBQVM7b0JBQXVCLGlFQUFvQyxDQUFDO0lBQzFFLE9BQU8sS0FBSyxTQUFTLEVBQUUsSUFBSSxDQUFDO1FBQzFCLE1BQU0sVUFBVSxVQUFVLFlBQVk7UUFDdEMseUJBQXlCLGNBQWMsT0FBTztJQUNoRCxDQUFDO0FBQ0g7QUFFTyxJQUFNLDhCQUE4QixDQUN6QyxRQUNBO0lBRUEsTUFBTSxpQkFBc0MsQ0FBQztJQUU3QyxPQUFPLEtBQUssU0FBUyxFQUFFLElBQUksQ0FBQztRQUMxQixNQUFNLENBQUMsT0FBTyxPQUFPLElBQUksYUFBYSxNQUFNLEdBQUc7UUFDL0MsTUFBTSxVQUFVLFVBQVUsWUFBWTtRQUN0QyxNQUFNLFFBQVEsT0FBTyxLQUNuQixDQUFDLElBQU0sRUFBRSxPQUFPLFdBQVcsRUFBRSxlQUFlO1FBRTlDLElBQUksT0FBTztZQUNULE1BQU0sUUFDSixNQUFNLE9BQ04sS0FBSyxDQUFDLElBQVcsRUFBRSxPQUFPLFdBQVcsRUFBRSxlQUFlLE9BQU87WUFDL0QsSUFBSSxPQUFPO2dCQUNULE1BQU0sU0FBUyxJQUFJLENBQUM7b0JBQ2xCLGVBQWUsS0FBSzt3QkFDbEIsTUFBTSxFQUFFO3dCQUNSLE9BQU8sRUFBRTt3QkFDVCxXQUFXLEVBQUU7b0JBQ2YsQ0FBQztnQkFDSCxDQUFDO1lBQ0g7UUFDRjtJQUNGLENBQUM7SUFFRCxPQUFPO0FBQ1Q7QUFFTyxJQUFNLDBCQUEwQixDQUNyQyxRQUNBO0lBRUEsSUFBSSxTQUFTLENBQUM7V0FBRyxNQUFNO0tBQUE7SUFDdkIsTUFBTSx5QkFBeUIsSUFBSSxJQUNqQyxPQUFPLElBQUksQ0FBQztRQWpFaEI7UUFpRXNCLFVBQUssT0FBRixFQUFFLFdBQXVCLE9BQXZCLENBQVEsT0FBRSxjQUFGLFlBQWU7SUFBQSxDQUFJO0lBRXBELE1BQU0sYUFBYSxLQUFLLE9BQ3RCLENBQUM7UUFwRUw7UUFvRVcsUUFBQyx1QkFBdUIsSUFBSSxHQUFLLE9BQUYsRUFBRSxXQUF1QixDQUFJLE1BQTNCLENBQVEsT0FBRSxjQUFGLFlBQWU7SUFBSTtJQUdyRSxJQUFJLFdBQVcsU0FBUyxHQUFHO1FBQ3pCLFNBQVMsQ0FBQztlQUFHO2VBQVcsVUFBVTtTQUFBO0lBQ3BDO0lBRUEsT0FBTztBQUNUOztBRmxEQSxJQUFNLG1DQUEyQixpREFFL0IsTUFBUztBQXFCSiw2QkFDTCxPQXFHQTs7SUFDQSxNQUFNLEVBQ0osZ0JBQ0EsZ0JBQ0EsVUFDQSxTQUNBLFdBQ0EscUJBQ0Esc0JBQ0EscUJBQ0EsV0FDQSxZQUNBLE1BQ0EsTUFDQSxXQUNBLFlBQ0EsV0FDQSxrQkFDQSx3QkFDQSw0QkFDRixHQUFJO0lBQ0osTUFBTSxTQUFVLE1BQU0sT0FDbkI7SUFFSCxJQUFJLGdCQUFnQjtRQUNsQixPQUFPLHlCQUF5QixlQUFlLE1BQU07SUFDdkQ7SUFFQSxNQUFNLENBQUMsUUFBUSxTQUFTLElBQVUsNENBQWtCLE9BQU8sZ0JBQWdCLENBQUM7SUFDNUUsTUFBTTtJQUNOLE1BQU0sVUFBZ0I7Z0RBQ3BCLEtBQU87Z0JBQ0w7NERBQWU7d0JBQ2IsVUFBVSxPQUFPLGdCQUFnQixDQUFDO3dCQUNsQyxZQUFZO29CQUNkOzthQUNGOytDQUNBO1FBQUM7UUFBUSxXQUFXO0tBQUE7SUFHaEI7eUNBQVU7WUFDZCxPQUFPLHFCQUFxQixPQUFPO1lBQ25DO2lEQUFPLElBQU0sT0FBTyx1QkFBdUIsT0FBTzs7UUFDcEQ7d0NBQUc7UUFBQztRQUFTLE1BQU07S0FBQztJQUVwQixNQUFNLHNCQUE0Qiw4Q0FBVyxrQkFBa0I7SUFFL0QsTUFBTSxFQUFFLE1BQU0sZUFBZSxlQUFlLGdCQUFnQixJQUFJO0lBRWhFLE1BQU0sUUFBYzs4Q0FBaUM7WUF4TXZEO1lBME1JLE1BQU07c0ZBQWtDLENBR3RDLEdBQ0E7b0JBRUEsT0FBUSxNQUFNLFNBQVksSUFBSSwyREFBc0I7Z0JBQ3REOztZQUNBLE9BQU87Z0JBQ0wsZ0JBQWdCO3VCQUNYLHdCQUNELDBDQUFrQixDQUFDLEdBQ25CLDRCQUE0QixRQUFRLGdDQUFhLENBQUMsQ0FBQzt1QkFFakQsaUVBQXFCLG1CQUFyQixZQUF1QyxDQUFDO2lCQUM5QztnQkFDQSxxQkFBcUIsbUNBQ2YsZ0VBQXFCLHdCQUFyQixZQUE0QyxDQUFDLElBQzdDLG9EQUF1QixDQUFDO2dCQUU5QixRQUFRLGdDQUFnQyxRQUFRLFFBQVE7Z0JBQ3hELFdBQVcsbUNBQ0wsZ0VBQXFCLGNBQXJCLFlBQWtDLENBQUMsSUFDbkMsZ0NBQWEsQ0FBQztnQkFFcEIsWUFBWSxnQ0FBZ0MsWUFBWSxZQUFZO2dCQUNwRSxNQUFNLGdDQUFnQyxNQUFNLE1BQU07Z0JBQ2xELE1BQU0sZ0NBQWdDLE1BQU0sTUFBTTtnQkFDbEQsTUFBTSxnQ0FBZ0MsTUFBTSxNQUFNO2dCQUNsRCxlQUFlLGdDQUNiLGVBQ0E7Z0JBRUYsZUFBZSxnQ0FDYixlQUNBO2dCQUVGLGlCQUFpQixnQ0FDZixpQkFDQTtnQkFFRixrQkFBa0IsZ0NBQ2hCLGtCQUNBO2dCQUVGLHdCQUF3QixnQ0FDdEIsd0JBQ0E7WUFFSjtRQUNGOzZDQUFHO1FBQ0Q7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO0tBQ0Q7SUFFSzt5Q0FBVTtZQUNkLHVCQUF1QixTQUFTO1lBQ2hDLE9BQU8sWUFBWTtnQkFDakIsV0FBVztvQkFBQTtvQkFFVCxpQkFBaUI7b0JBQ2pCLFNBQVMsT0FBTyxXQUFXO29CQUMzQixZQUFZLE9BQU8sY0FBYztnQkFDbkM7Z0JBQ0EsV0FBVyxNQUFNO1lBQ25CLENBQUM7UUFDSDt3Q0FBRztRQUFDO1FBQVEsS0FBSztLQUFDO0lBRWxCLE1BQU0sb0JBQW9CLENBQU8sMkNBQVEsTUFBTSxHQUFHLEVBQUUsQ0FBQztJQUVyRCxNQUFNLG1DQUNKLGtFQUNBLE9BQU8sVUFBVSxFQUFFO0lBRXJCLE9BQ0UsK0VBQUMsdUVBQXdCLEVBQXhCO1FBQ0MsaUJBQWlCO1FBQ2pCLFVBQVU7SUFBQSxHQUVWLCtFQUFDLG1CQUFtQixVQUFuQjtRQUE0QjtJQUFBLEdBQzFCLENBQUMsV0FDQSwrRUFBQztRQUNDO1FBQ0E7UUFDQTtJQUFBLElBR0osK0VBQUMsZ0VBQWtCLEVBQWxCO1FBQ0MsT0FBTztRQUNQLFFBQVE7UUFDUixPQUFPO0lBQUEsR0FFUCwrRUFBQztRQUNDLE1BQU0sQ0FBQyxvQ0FBb0MscUJBQXFCO1FBQ2hFLFNBQVMsQ0FBQyxXQUNSLCtFQUFPLDZDQUFOO2dCQUFlLFVBQVUsOENBQW9CO1lBQUEsR0FDM0MsUUFDSDtJQUFBLEdBR0Q7QUFNYjs7O1FBN0lzQjs7O01BbklOO0FBc1JoQiwrQkFBeUIsNENBQUssU0FBU0csWUFBVyxPQUkvQzs7SUFDRCxNQUFNLEVBQUUsUUFBUSxnQkFBZ0IsVUFBVSxJQUFJO0lBQzlDLE1BQU0sQ0FBQyxjQUFjLGVBQWUsSUFBVSw0Q0FBUyxDQUFDLENBQUMsY0FBYztJQUN2RSxNQUFNLFdBQVcsU0FBUyxRQUFRO1FBQ2hDLGlCQUNFLGdCQUFnQixpQkFDWixlQUFlLE9BQU8sYUFDdEI7UUFDTjtJQUNGLENBQUM7SUFDRCxNQUFNO0lBQ04sTUFBTSxVQUFnQjttREFDcEIsS0FBTztnQkFDTDsrREFBZTt3QkFFYixnQkFBZ0IsS0FBSzt3QkFDckIsWUFBWTtvQkFDZDs7YUFDRjtrREFDQTtRQUFDO1FBQVEsV0FBVztLQUFBO0lBR2hCOzRDQUFVO1lBQ2QsT0FBTyxxQkFBcUIsT0FBTztZQUNuQztvREFBTyxJQUFNLE9BQU8sdUJBQXVCLE9BQU87O1FBQ3BEOzJDQUFHO1FBQUM7UUFBUyxNQUFNO0tBQUM7SUFFcEIsT0FBTywrRUFBQztRQUFNLHlCQUF5QjtZQUFFLFFBQVE7UUFBUztJQUFBLENBQUc7QUFDL0QsQ0FBQzs7UUFsQnFCOzs7TUFkaEI7QUFrQ04sU0FBUyxTQUNQLFFBQ0EsTUFJQTtJQUNBLE1BQU0sRUFBRSxpQkFBaUIsVUFBVSxJQUFJO0lBQ3ZDLE1BQU0sV0FDSixtQkFDQSxvQkFBSSxJQUFZO1FBQ2Q7V0FDRyxnQkFBZ0IsSUFBSSxDQUFDLElBQU0sRUFBRSxPQUFPO0tBQ3hDO0lBQ0gsTUFBTSxhQUFhLE9BQ2hCLFVBQVUsRUFDVixPQUFPLEVBQ1AsT0FBTyxDQUFDLElBQU0sQ0FBQyxZQUFZLFNBQVMsSUFBSSxFQUFFLFFBQVEsQ0FBQztJQUV0RCxNQUFNLFNBQVMsQ0FBQyxXQUFzQixhQUFhLG1CQUFtQixJQUFJO0lBQzFFLE1BQU0saUJBQWlCLENBQUMsR0FBZ0IsSUFDdEMsT0FBTyxFQUFFLFFBQVEsTUFBTSxPQUFPLEVBQUUsUUFBUSxJQUNwQyxPQUFPLEVBQUUsUUFBUSxJQUFJLE9BQU8sRUFBRSxRQUFRLElBQ3RDLEVBQUUsU0FBUyxjQUFjLEVBQUUsUUFBUTtJQUN6QyxXQUFXLEtBQUssY0FBYztJQUU5QixNQUFNLGNBQWMsT0FBTyxVQUFVLEVBQUUsZUFBZTtJQUd0RCxPQUFPLFNBTUgsT0FKQSxZQUNJLEtBQ0EsWUFBWSxJQUFJLENBQUMsSUFBTSxnQkFBa0IsT0FBRixFQUFFLFNBQVEsSUFBRSxLQUFLLElBQUksYUFFbkIsa0JBQWxDLElBQUksQ0FBQyxNQUFRLElBQUksTUFBTSxFQUFFLEtBQUssSUFBSTtBQUVuRDtBQUVPOztJQUNMLE9BQWEsOENBQVcsa0JBQWtCO0FBQzVDO0lBRmdCLHdCQUF3Qjs7QUdoWWpDLFNBQVMsdUJBQXVCLE1BQWMsV0FBbUI7O0lBQ3RFLFVBQU87O1FBakJUO1FBa0JJLE1BQU0sY0FBYyxzQkFBc0I7UUFDMUMsSUFBSSxDQUFDLGFBQWE7WUFDaEIsT0FBTztRQUNUO1FBRUEsTUFBTSxTQUFTLFlBQVk7UUFDM0IsTUFBTSxPQUFPO2VBQ1IsT0FBTyxrQkFBa0I7ZUFDNUIsQ0FBSSxpQkFBWSxtQkFBWixZQUE4QixDQUFDO1NBQ3JDLENBQUUsS0FDQSxDQUFDLFFBQ0MsTUFBTSxTQUFTLFNBQ2QsQ0FBQyxNQUFNLGFBQWEsTUFBTSxjQUFjO1FBRTdDLE9BQU8sT0FBTyxLQUFLLFFBQVE7SUFDN0I7Ozs7O0FBQ0Y7O0FDYk87QUFNQTtBQUM0Qzs7QUN4QjVDO0FBSVAsU0FBUyxhQUFhLGVBQWdDLGNBQXdCO0lBQzVFLE1BQU0sSUFBYyxDQUFDO1dBQUcsWUFBWTtLQUFBO0lBQ3BDLE1BQU0sVUFBVSxJQUFJLElBQVksWUFBWTtJQUM1QyxNQUFNLG9CQUFvQixJQUFJLElBQzVCLGNBQWMsSUFBSSxDQUFDLE9BQVM7WUFBQyxLQUFLO1lBQUksSUFBSTtTQUFDO0lBRTdDLE1BQU0sWUFBNkIsQ0FBQztJQUNwQyxNQUFPLEVBQUUsU0FBUyxFQUFHO1FBQ25CLE1BQU0sQ0FBQyxFQUFFLElBQUksRUFBRSxPQUFPLEdBQUcsQ0FBQztRQUMxQixNQUFNLE9BQU8sa0JBQWtCLElBQUksRUFBRTtRQUNyQyxJQUFJLENBQUMsTUFBTTtZQUNUO1FBQ0Y7UUFDQSxVQUFVLEtBQUssSUFBSTtRQUNuQixLQUFLLGVBQWUsUUFBUSxDQUFDO1lBQzNCLElBQUksQ0FBQyxRQUFRLElBQUksVUFBVSxHQUFHO2dCQUM1QixRQUFRLElBQUksVUFBVTtnQkFDdEIsRUFBRSxLQUFLLFVBQVU7WUFDbkI7UUFDRixDQUFDO0lBQ0g7SUFDQSxPQUFPO0FBQ1Q7QUFFTyxTQUFTLGtCQUNkLFFBQ0EsV0FDQSxNQUdxQjtJQUNyQixJQUFJLFVBQVUsV0FBVyxHQUFHO1FBQzFCLE9BQU87WUFDTCxnQkFBZ0IsT0FBTztZQUN2QjtZQUNBLGdCQUFnQixDQUFDO1FBQ25CO0lBQ0Y7SUFFQSxNQUFNLFlBQVksYUFDaEIsT0FBTyxZQUNQLFVBQVUsSUFBSSxDQUFDLFdBQWEsU0FBUyxFQUFFO0lBRXpDLE1BQU0sWUFBWSxVQUFVLElBQUksQ0FBQyxXQUFhLFNBQVMsS0FBSztJQUM1RCxNQUFNLFlBQVksd0VBQWUsQ0FDL0IsUUFDQTtRQUNFO1dBQ0c7UUFDSDtXQUNHLE9BQU8sU0FDUCxJQUFJLENBQUMsSUFBTSxFQUFFLDhCQUE4QixFQUMzQyxPQUFPLENBQUMsSUFBTSxDQUFDLENBQUMsQ0FBQztRQUFBO1FBQUE7UUFBQTtRQUFBO1FBQUE7UUFBQTtRQUFBO1FBQUE7UUFBQTtXQVVqQixPQUFPLFdBQ1AsT0FBTyxDQUFDLElBQU0sRUFBRSx1QkFBdUIsRUFDdkMsSUFBSSxDQUFDLElBQU0sRUFBRSxLQUFLO1dBQ2xCLE9BQU8sYUFBYSxJQUFJLENBQUMsSUFBTSxFQUFFLFdBQVc7S0FDakQsRUFDQTtJQUdGLE1BQU0saUJBQTJCLENBQUM7SUFDbEMsVUFBVSxTQUFTLFFBQVEsQ0FBQyxJQUMxQixlQUFlLEtBQUssR0FBRyxFQUFFLFlBQVksSUFBSSxDQUFDLElBQU0sRUFBRSxHQUFHLENBQUM7SUFHeEQsT0FBTztRQUNMLGdCQUFnQjtRQUNoQixRQUFRO1FBQ1I7SUFDRjtBQUNGO0FBS08sU0FBUyxhQUNkLFFBQ0EsTUFDQTtJQWhHRjtJQWlHRSxNQUFNLG1CQUFtQixJQUFJLElBQUksT0FBTyxTQUFTLElBQUksQ0FBQyxJQUFNLEVBQUUsRUFBRSxDQUFDO0lBQ2pFLE1BQU0sY0FBYyxLQUFLLFNBQVMsT0FBTyxDQUFDLElBQU0sQ0FBQyxpQkFBaUIsSUFBSSxFQUFFLEVBQUUsQ0FBQztJQUMzRSxJQUFJLFlBQVksU0FBUyxHQUFHO1FBQzFCLFNBQVMsaUNBQ0osU0FESTtZQUVQLFVBQVUsQ0FBQzttQkFBRyxPQUFPO21CQUFhLFdBQVc7YUFBQTtRQUMvQztJQUNGO0lBRUEsTUFBTSxrQkFBa0IsSUFBSSxJQUFJLE9BQU8sV0FBVyxJQUFJLENBQUMsSUFBTSxFQUFFLEVBQUUsQ0FBQztJQUVsRSxTQUFTLCtCQUErQixHQUFrQjtRQTVHNUQsSUFBQUM7UUE4R0ksSUFBSSxnQkFBZ0IsSUFBSSxFQUFFLEVBQUUsR0FBRztZQUM3QixPQUFPO1FBQ1Q7UUFHQSxJQUFJLENBQUMsaUJBQWlCLElBQUksRUFBRSxTQUFTLEdBQUc7WUFDdEMsT0FBTztRQUNUO1FBSUEsTUFBTSwyQkFBMEJBLE1BQUEsT0FBTyxZQUFZLEVBQUUsVUFBUyxLQUE5QixPQUFBQSxNQUFtQyxDQUFDO1FBQ3BFLE9BQU8sd0JBQXdCLFNBQVMsRUFBRSxFQUFFO0lBQzlDO0lBRUEsTUFBTSxlQUFlLEtBQUssV0FBVyxPQUFPLENBQUMsSUFDM0MsK0JBQStCLENBQUM7SUFFbEMsSUFBSSxhQUFhLFNBQVMsR0FBRztRQUMzQixTQUFTLGlDQUNKLFNBREk7WUFFUCxZQUFZLENBQUM7bUJBQUcsT0FBTzttQkFBZSxZQUFZO2FBQUE7UUFDcEQ7UUFHQSxPQUFPLGNBQWMsT0FBTyxZQUMxQixPQUFPLFFBQVEsT0FBTyxXQUFXLEVBQUUsSUFBSTtnQkFBQyxDQUFDLEdBQUcsQ0FBQzttQkFBTTtnQkFBQztnQkFBRyxDQUFDO3VCQUFHLENBQUM7aUJBQUM7YUFBQzs7UUFHaEUsS0FBSyxTQUFTLFFBQVEsQ0FBQztZQTNJM0IsSUFBQUEsS0FBQUM7WUE0SU0sTUFBTSxZQUFZLFlBQVk7WUFDOUIsTUFBTSx5QkFBd0JELE1BQUEsS0FBSyxZQUFZLFVBQVMsS0FBMUIsT0FBQUEsTUFBK0IsQ0FBQztZQUM5RCxJQUFJLENBQUMsaUJBQWlCLElBQUksU0FBUyxHQUFHO2dCQUNwQyxPQUFPLFlBQVksU0FBUyxJQUFJLENBQUM7dUJBQUcscUJBQXFCO2lCQUFBO1lBQzNELE9BQU87Z0JBQ0wsT0FBTyxZQUFZLFNBQVMsSUFBSSxXQUM5QkMsTUFBQSxPQUFPLFlBQVksVUFBUyxLQUE1QixPQUFBQSxNQUFpQyxDQUFDLEdBQ2xDO1lBRUo7UUFDRixDQUFDO0lBQ0g7SUFFQSxNQUFNLGtCQUFrQjtRQUN0QixTQUFTLElBQUksSUFBSSxPQUFPLFFBQVEsUUFBUSxJQUFJLENBQUMsSUFBTSxFQUFFLFFBQVEsQ0FBQztRQUM5RCxRQUFRLElBQUksSUFBSSxPQUFPLFFBQVEsT0FBTyxJQUFJLENBQUMsSUFBTSxFQUFFLFFBQVEsQ0FBQztJQUM5RDtJQUNBLE1BQU0sYUFBYTtRQUNqQixTQUFTLEtBQUssUUFBUSxRQUFRLE9BQzVCLENBQUMsSUFBTSxDQUFDLGdCQUFnQixRQUFRLElBQUksRUFBRSxRQUFRO1FBRWhELFFBQVEsS0FBSyxRQUFRLE9BQU8sT0FDMUIsQ0FBQyxJQUFNLENBQUMsZ0JBQWdCLE9BQU8sSUFBSSxFQUFFLFFBQVE7SUFFakQ7SUFDQSxJQUFJLFdBQVcsUUFBUSxTQUFTLEtBQUssV0FBVyxPQUFPLFNBQVMsR0FBRztRQUNqRSxTQUFTLGlDQUNKLFNBREk7WUFFUCxTQUFTO2dCQUNQLFNBQVMsQ0FBQzt1QkFBRyxPQUFPLFFBQVE7dUJBQVksV0FBVyxPQUFPO2lCQUFBO2dCQUMxRCxRQUFRLENBQUM7dUJBQUcsT0FBTyxRQUFRO3VCQUFXLFdBQVcsTUFBTTtpQkFBQTtZQUN6RDtRQUNGO0lBQ0Y7SUFFQSxNQUFNLG9CQUFvQixJQUFJLElBQUksT0FBTyxhQUFhLElBQUksQ0FBQyxJQUFNLEVBQUUsRUFBRSxDQUFDO0lBQ3RFLE1BQU0sYUFBYSxLQUFLLGFBQWEsT0FDbkMsQ0FBQyxJQUFNLENBQUMsa0JBQWtCLElBQUksRUFBRSxFQUFFO0lBRXBDLElBQUksV0FBVyxTQUFTLEdBQUc7UUFDekIsU0FBUyxpQ0FDSixTQURJO1lBRVAsY0FBYyxDQUFDO21CQUFHLE9BQU87bUJBQWlCLFVBQVU7YUFBQTtRQUN0RDtJQUNGO0lBRUEsTUFBTSxtQkFBbUIsSUFBSSxJQUFJLE9BQU8sYUFBYSxJQUFJLENBQUMsSUFBTSxFQUFFLEVBQUUsQ0FBQztJQUNyRSxNQUFNLGFBQ0osVUFBSyxhQUFhO0lBQUE7SUFHaEIsQ0FBQyxJQUFNLENBQUMsaUJBQWlCLElBQUksRUFBRSxFQUFFLEtBQUssQ0FBQyxpQkFBaUIsSUFBSSxFQUFFLFNBQVMsRUFDekUsS0FKQSxZQUlLLENBQUM7SUFDUixJQUFJLFVBQVUsU0FBUyxHQUFHO1FBQ3hCLFNBQVMsaUNBQ0osU0FESTtZQUVQLGNBQWMsQ0FBQzttQkFBRyxPQUFPO21CQUFpQixTQUFTO2FBQUE7UUFDckQ7SUFDRjtJQUdBLE9BQU8sYUFBWSxrQkFBTyxjQUFQLFlBQW9CLEtBQUssY0FBekIsWUFBc0M7SUFDekQsT0FBTyx3QkFDTCxrQkFBTyx5QkFBUCxZQUErQixLQUFLLHlCQUFwQyxZQUE0RDtJQUU5RCxPQUFPLHVDQUNMLGtCQUFPLHdDQUFQLFlBQ0EsS0FBSyx3Q0FETCxZQUVBO0lBRUYsT0FBTztBQUNUO0FBRU8sSUFBTSxzQ0FBc0MsQ0FDakQsU0FDQTtJQUVBLElBQUksUUFBUSxXQUFXLEdBQUc7UUFDeEIsT0FBTztJQUNUO0lBRUEsTUFBTSxnQkFBZ0IsUUFBUSxPQUFPLENBQUMsTUFBTSxNQUFRLGFBQWEsTUFBTSxHQUFHLENBQUM7SUFDM0UsT0FBTyxrQkFBa0IsZUFBZSxTQUFTO0FBQ25EOztBQ3BOQSxTQUFTLGlCQUFpQixPQUF3QixRQUE2QjtJQUM3RSxNQUFNLFdBQVcsYUFBYSxPQUFPLE1BQU07SUFDM0MsT0FBTyxTQUFTLFdBQVcsSUFBSSxTQUFZLFNBQVMsQ0FBQztBQUN2RDtBQUVPLElBQU0sa0JBQU4sTUFBc0I7SUFHM0IsaUJBQWlCLE1BQXNEO1FBQ3JFLE1BQU0sV0FBVyxpQkFBaUIsS0FBSyxPQUFPLFlBQVksSUFBSTtRQUM5RCxPQUFPO0lBQ1Q7SUFFQSxhQUNFLE1BRUE7WUFEQSx3RUFBb0MsQ0FBQztRQUVyQyxNQUFNLFdBQVcsaUJBQWlCLEtBQUssT0FBTyxZQUFZLElBQUk7UUFDOUQsSUFBSSxDQUFDLFVBQVU7WUFDYixNQUFNLElBQUksTUFBTSx3QkFBd0IsQ0FBTSxNQUFOO1FBQzFDO1FBQ0EsTUFBTSxhQUFhLFNBQVM7UUFDNUIsSUFBSSxDQUFDLEtBQUssU0FBUyxVQUFVLFlBQVksSUFBSSxHQUFHO1lBQzlDLE1BQU0sSUFBSSxNQUFNLDhCQUF1QyxDQUFNLE1BQWYsU0FBUztRQUN6RDtRQUNBLE1BQU0sUUFBUSxLQUFLLFNBQVMsS0FBSyxZQUFZO1lBQzNDLGVBQWUsS0FBSztRQUN0QixDQUFDO1FBQ0QsT0FBTyxDQUFDLEtBQUssaUJBQ1gsT0FBTyxnQ0FBTyx5QkFBd0IsYUFDcEMsTUFBTSxvQkFBb0IsSUFDekIsTUFBTTtJQUNiO0lBRUEsYUFBYSxNQUEyQjtRQUN0QyxNQUFNLFdBQVcsaUJBQWlCLEtBQUssT0FBTyxZQUFZLElBQUk7UUFDOUQsSUFBSSxVQUFVO1lBQ1osT0FBTyxLQUFLLFNBQVMsVUFBVSxTQUFTLEtBQUs7UUFDL0M7UUFDQSxPQUFPO0lBQ1Q7SUFFQSxvQkFBK0Q7UUFDN0QsTUFBTSxvQkFBb0IsS0FBSyxPQUFPLGFBQWEsT0FDakQsQ0FBQyxJQUFNLEVBQUUsU0FBUztRQUVwQixPQUFPLGtCQUFrQixJQUFJLENBQUMsUUFBVTtnQkFDdEM7Z0JBQ0EsU0FBUyxLQUFLLFNBQVMsS0FBSyxLQUFLLFdBQVcsRUFBRTthQUNoRCxFQUFFO0lBQ0o7SUFFQSwwQkFBMEIsTUFBMkI7UUFDbkQsTUFBTSxXQUFXLGlCQUFpQixLQUFLLE9BQU8sWUFBWSxJQUFJO1FBQzlELE1BQU0sY0FBYyxXQUNoQixLQUFLLE9BQU8sU0FBUyxLQUFLLENBQUMsSUFBTSxFQUFFLE9BQU8sU0FBUyxTQUFTLElBQzVEO1FBRUosSUFDRSxDQUFDLGVBQ0QsQ0FBQyxZQUFZLGtDQUNiLENBQUMsS0FBSyxTQUFTLFVBQVUsWUFBWSw4QkFBOEIsR0FDbkU7WUFDQSxPQUFPO1FBQ1Q7UUFDQSxNQUFNLFFBQVEsS0FBSyxTQUFTLEtBQzFCLFlBQVk7UUFHZCxPQUFPLFFBQU8sK0JBQU8seUJBQXdCLGFBQ3pDLE1BQU0sb0JBQW9CLElBQzFCLE1BQU07SUFDWjtJQUVBLGtCQUFrQjtRQUNoQixNQUFNLFFBQVEsS0FBSyxTQUFTLEtBQUssa0JBQWtCO1FBQ25ELE9BQU8sTUFBTTtJQUNmO0lBRUEsU0FBd0I7UUFFdEIsT0FBTyxLQUFLLE9BQU8sUUFBUSxRQUFRLE9BQ2pDLENBQUMsTUFBUSxJQUFJLFNBQVMsV0FBVyxJQUFJLFNBQVMsU0FBUyxLQUFLO0lBRWhFO0lBRUEsaUJBQTZCO1FBQzNCLE9BQU8sS0FBSyxPQUFPLFNBQVMsUUFBUSxDQUFDLElBQU0sRUFBRSxXQUFXO0lBQzFEO0lBbEZBLFlBQW9CLFFBQW9DLFNBQW9CO1FBQXhEO1FBQW9DO0lBQXFCO0FBbUYvRTs7QUYwSU8sSUFBTSx5QkFHVCxDQUFDO0FBQ0UsSUFBTSxvQ0FHVCxDQUFDO0FBQ0UsSUFBTSxtQ0FBOEQsQ0FBQztBQUNyRSxJQUFNLDhCQUdULENBQUM7QUFFRSxTQUFTLDBCQUNkLE1BQ0E7SUFDQSxNQUFNLHVCQUF1QjtJQUM3QixPQUFPLEtBQUssWUFDUixVQUFHLDZCQUF1QixLQUFLLGlCQUFtQixPQUFMLEtBQUssUUFDbEQsVUFBRyxzQkFBNEIsT0FBTCxLQUFLO0FBQ3JDO0FBNENBLFNBQVM7SUFBQTtRQUErQixLQUEvQix1QkFBK0I7O0lBQ3RDLElBQUk7SUFDSixJQUFJO0lBQ0osSUFBSSxNQUFNLFFBQVEsS0FBSyxDQUFDLENBQUMsR0FBRztRQUMxQixRQUFRLEtBQUssQ0FBQztRQUNkLE9BQU8sS0FBSyxDQUFDO0lBQ2YsT0FBTztRQUNMLFFBQVE7UUFDUixPQUFPO0lBQ1Q7SUFDQSxPQUFPO1FBQUU7UUFBTztJQUFLO0FBQ3ZCO0FBR08sSUFBZSxxQ0FBZixNQUFrRDtJQTJDL0Msb0JBQW1EO1FBQW5EO2tCQUFBLHVCQUFxQjs7UUFDM0IsTUFBTSxRQUFRLG9CQUFJLElBQW1CO1FBQ3JDLE1BQU0sVUFBaUMsQ0FBQztRQUN4QyxXQUFXLFFBQVEsTUFBTztZQUN4QixNQUFNLGdCQUFnQixhQUFhLEtBQUssT0FBTyxZQUFZLElBQUk7WUFDL0QsSUFBSSxjQUFjLFNBQVMsR0FBRztnQkFDNUIsY0FBYyxRQUFRLENBQUMsT0FBUyxNQUFNLElBQUksSUFBSSxDQUFDO1lBQ2pELE9BQU87Z0JBQ0wsUUFBUSxLQUFLLElBQUk7WUFDbkI7UUFDRjtRQUNBLE9BQU87WUFBRSxPQUFPLE1BQU0sS0FBSyxNQUFNLEtBQUssQ0FBQztZQUFHO1FBQVE7SUFDcEQ7SUFTTSwwQkFFaUM7UUFGakM7WUFDRCxLQURDLHVCQUNEOztRQUNrQztZQUNyQyxNQUFNLEVBQUUsT0FBTyxLQUFLLElBQUksNEJBQTRCLEdBQUcsSUFBSTtZQUMzRCxNQUFNLHlCQUF5QixDQUM3QixlQUNHO29CQUNILE1BQU0sS0FBSyxpQkFBaUI7d0JBQUUsY0FBYztvQkFBYSxDQUFDO29CQUMxRCxNQUFNLEVBQUUsT0FBTyxnQkFBZ0IsU0FBUyxjQUFjLElBQ3BELEtBQUssa0JBQWtCLEdBQUcsS0FBSztvQkFDakMsSUFBSSxjQUFjLFNBQVMsR0FBRzt3QkFDNUIsT0FBTztvQkFDVDtvQkFFQSxPQUFPLGtCQUFrQixLQUFLLFFBQVEsZ0JBQWdCLElBQUk7Z0JBQzVEO1lBRUEsSUFBSSxLQUFLLEtBQUssYUFBYTtnQkFFekIsT0FBTyxNQUFNLHVCQUF1QixLQUFLO1lBQzNDO1lBR0EsTUFBTSxFQUFFLE9BQU8sZUFBZSxTQUFTLGFBQWEsSUFDbEQsS0FBSyxrQkFBa0IsR0FBRyxLQUFLO1lBQ2pDLElBQUksYUFBYSxXQUFXLEdBQUc7Z0JBQzdCLE9BQU8sa0JBQWtCLEtBQUssUUFBUSxlQUFlLElBQUk7WUFDM0Q7WUFFQSxPQUFPLE1BQU0sdUJBQXVCLFlBQVk7UUFDbEQ7SUFBQTtJQVNNLHFCQUFpRTtRQUFqRTtZQUFzQixLQUF0Qix1QkFBc0I7O1FBQTJDO1lBQ3JFLE1BQU0sRUFBRSxPQUFPLEtBQUssSUFBSSw0QkFBNEIsR0FBRyxJQUFJO1lBQzNELE1BQU0sT0FBTyxNQUFNLEtBQUssd0JBQXdCLE9BQU8sSUFBSTtZQUUzRCxJQUFJLENBQUMsTUFBTTtnQkFDVCxNQUFNLEVBQUUsU0FBUyxhQUFhLElBQUksS0FBSyxrQkFBa0IsR0FBRyxLQUFLO2dCQUNqRSxNQUFNLElBQUksTUFDUiw2QkFFWSxPQUZpQixhQUMxQixJQUFJLGlCQUFpQixFQUNyQixLQUFLLElBQUk7WUFFaEI7WUFFQSxPQUFPO1FBQ1Q7SUFBQTtJQUVNLFdBQVcsTUFBdUI7UUFBQTtZQUN0QyxLQUFLLDJCQUNILElBQU07WUFFUixNQUFNLE9BQU8sTUFBTSxLQUFLLGFBQWE7WUFDckMsT0FBTyxLQUFLLFdBQVcsT0FDckIsQ0FBQyxPQUNDLEtBQUssVUFDTCxLQUFLLFVBQ0osNkJBQU0sd0JBQXVCLENBQUMsa0JBQWtCLEtBQUssS0FBSTtRQUVoRTtJQUFBO0lBRU0sa0JBQWtCO1FBQUE7WUFDdEIsS0FBSywyQkFDSCxJQUFNO1lBRVIsTUFBTSxPQUFPLE1BQU0sS0FBSyxhQUFhO1lBQ3JDLE9BQU8sS0FBSztRQUNkO0lBQUE7SUFFQSxrQkFBa0I7UUFDaEIsT0FBTyxLQUFLLE9BQU87SUFDckI7SUFFQSxhQUFhLFFBQTRCLFNBQXVCO1FBQzlELE9BQU8sS0FBSyxRQUFRLGFBQWEsUUFBUSxPQUFPO0lBQ2xEO0lBRWMsaUJBQWlCLE1BRTVCO1FBQUE7WUFFRCxLQUFLLDJCQUNILElBQ0Usd0RBRVksT0FGNEMsS0FBSyxhQUMxRCxJQUFJLENBQUMsT0FBUyxrQkFBa0IsSUFBSSxDQUFDLEVBQ3JDLEtBQUssSUFBSTtZQUVoQixPQUFPLEtBQUssYUFBYTtRQUMzQjtJQUFBO0lBRVEsMkJBQTJCLE9BQXFCO1FBQ3RELElBQUksYUFBYSxLQUFLLEtBQUssbUJBQW1CO1lBQzVDLE1BQU0sTUFBTSxNQUFNO1lBQ2xCLElBQUksS0FBSyxLQUFLLHNCQUFzQixRQUFRO2dCQUMxQyxRQUFRLEtBQUssR0FBRztZQUNsQixPQUFPO2dCQUNMLE1BQU0sSUFBSSxNQUFNLEdBQUc7WUFDckI7UUFDRjtJQUNGO0lBRWMsZUFBZTtRQUFBO1lBemUvQjtZQTBlSSxNQUFNLFNBQVMsTUFBTSxLQUFLLFFBQVEsYUFBYTtZQUMvQyxLQUFLLFFBQVEsV0FBVztZQUN4QixLQUFLLFlBQVksTUFBTTtZQUN2QixXQUFLLG9CQUFMO1lBQ0EsT0FBTztRQUNUO0lBQUE7SUFFQSxZQUFZLFdBQStCO1FBamY3QztRQWtmSSxVQUFVLGtCQUFZLFVBQVUsY0FBVixZQUF1QjtRQUM3QyxJQUNFLFVBQVUsYUFDVixLQUFLLE9BQU8sYUFDWixVQUFVLGNBQWMsS0FBSyxPQUFPLFdBQ3BDO1lBQ0EsUUFBUSxLQUNOLG9MQUVOLFVBQVUsaUJBQ0UsT0FBWixLQUFLLE9BQU87UUFFVjtRQUlBLEtBQUssU0FBUyxhQUFhLFdBQVcsS0FBSyxNQUFNO1FBRWpELFdBQUssbUJBQUw7SUFDRjtJQUVBLFlBQWdDO1FBQzlCLE9BQU8sS0FBSztJQUNkO0lBRUEsYUFBYTtRQUNYLEtBQUssU0FBUztZQUNaLFNBQVM7Z0JBQ1AsU0FBUyxDQUFDO2dCQUNWLFFBQVEsQ0FBQztZQUNYO1lBQ0EsWUFBWSxDQUFDO1lBQ2IsY0FBYyxDQUFDO1lBQ2YsVUFBVSxDQUFDO1lBQ1gsY0FBYyxDQUFDO1lBQ2YsV0FBVztZQUNYLHNCQUFzQjtZQUN0QixxQ0FBcUM7WUFDckMsYUFBYSxDQUFDO1FBQ2hCO1FBQ0EsS0FBSyxTQUFTLE1BQU07SUFDdEI7SUFFQSxnQkFBZ0IsU0FBOEI7UUFDNUMsSUFDRSxPQUFPLEtBQUssT0FBTyxFQUFFLEtBQ25CLENBQUMsT0FBUyxLQUFLLFNBQVMsb0JBQW9CLElBQUksTUFBTSxRQUFRLElBQUksSUFFcEU7WUFDQSxJQUFJLENBQUMsS0FBSyxTQUFTLFFBQVEsR0FBRztnQkFDNUIsUUFBUSxLQUNOO2dCQUVGLEtBQUssU0FBUyxNQUFNO1lBQ3RCO1lBQ0EsV0FBVyxPQUFPLE9BQU8sS0FBSyxPQUFPLEVBQUc7Z0JBQ3RDLEtBQUssU0FBUyxTQUFTLEtBQUssUUFBUSxHQUFHLENBQUM7WUFDMUM7UUFDRjtJQUNGO0lBRUEsb0JBQ0UsV0FDQSxNQUNBO1FBQ0EsS0FBSyw0QkFBNEIsV0FBVyxNQUFNLE1BQVM7SUFDN0Q7SUFFVSw0QkFDUixXQUNBLE1BQ0Esc0JBS0E7UUFDQSxJQUFJLENBQUMsS0FBSyxnQkFBZ0IsR0FBRztZQUMzQixRQUFRLEtBQ047WUFFRixLQUFLLGNBQWM7UUFDckI7UUFDQSxLQUFLLEtBQUssS0FBSztZQUFFLFFBQVE7WUFBTTtZQUFXO1FBQXFCLENBQUM7SUFDbEU7SUFpQlUsa0JBQWtCO1FBSzFCLFdBQVcsT0FBTyxLQUFLLEtBQU07WUFDM0IsTUFBTSxRQUFRLGFBQWEsS0FBSyxVQUFVLEVBQUUsWUFBWSxJQUFJLE1BQU07WUFDbEUsTUFBTSxRQUFRLENBQUM7Z0JBQ2IsdUJBQXVCLEtBQUssRUFBRSxJQUFJLElBQUk7Z0JBQ3RDLElBQUksSUFBSSxzQkFBc0I7b0JBQzVCLGtDQUFrQyxLQUFLLEVBQUUsSUFBSSxJQUFJO2dCQUNuRDtZQUNGLENBQUM7UUFDSDtRQUVBLEtBQUssU0FBUyxjQUFjLEtBQUssVUFBVSxDQUFDO0lBQzlDO0lBRUEsa0JBQWtCO1FBQ2hCLE9BQU8sS0FBSyxTQUFTLFFBQVE7SUFDL0I7SUFFQSxnQkFBZ0I7UUFDZCxLQUFLLFNBQVMsTUFBTTtJQUN0QjtJQUVBLGtCQUFrQixnQkFBcUM7UUFDckQsS0FBSyxpQkFBaUI7SUFDeEI7SUFFQSxvQkFBb0I7UUFDbEIsT0FBTyxLQUFLO0lBQ2Q7SUFFQSx5QkFBeUIsUUFBNEI7UUFPbkQsSUFBSSxDQUFDLFdBQVc7WUFFZCxNQUFNLGVBQWUsZ0dBQW9DLENBQUMsS0FBSyxJQUFJO1lBQ25FLElBQUksY0FBYztnQkFFaEIsS0FBSyxZQUFZLFlBQVk7WUFDL0I7UUFDRjtRQUNBLEtBQUssWUFBWSxNQUFNO0lBQ3pCO0lBRUEsWUFBWTtRQUNWLE9BQU8sSUFBSSxnQkFBZ0IsS0FBSyxVQUFVLEdBQUcsS0FBSyxRQUFRO0lBQzVEO0lBRUEsa0JBQTJCO29CQUFYLGlFQUFRO1FBQ3RCLEtBQUssUUFBUSxnQkFBZ0IsS0FBSztJQUNwQztJQUVhLG1CQUNYLE1BQ0E7UUFBQTtZQUNBLE1BQU0sS0FBSyxnQkFBZ0I7WUFDM0IsT0FBTyw4RUFBa0IsQ0FBQyxpQ0FDckIsT0FEcUI7Z0JBRXhCLFFBQVEsS0FBSyxVQUFVLEVBQUU7WUFDM0IsRUFBQztRQUNIO0lBQUE7SUFFTyxhQUF1QjtRQUM1QixPQUFPLEtBQ0wsS0FBSyxVQUFVLEVBQ1osU0FBUyxJQUFJLENBQUMsSUFDYixFQUFFLFNBQVMsVUFBRyxFQUFFLFFBQW9DLE9BQTNCLEVBQUUsV0FBVyxjQUFjLE1BQU8sTUFFNUQsT0FBTyxDQUFDLElBQW1CLENBQUMsQ0FBQyxDQUFDO0lBRXJDO0lBRU8sZ0JBQTBCO1FBQy9CLE9BQU8sS0FDTCxLQUFLLFVBQVUsRUFBRSxTQUFTLElBQ3hCLENBQUMsSUFBTSxVQUFHLEVBQUUsSUFBZ0MsT0FBM0IsRUFBRSxXQUFXLGNBQWM7SUFHbEQ7SUFFTyxZQUFZLE1BQTJCO1FBQzVDLEtBQUssUUFBUSxZQUFZLElBQUk7SUFDL0I7SUEzVkEsWUFBWSxLQVNUO1FBaENILEtBQWlCLFdBQVcsSUFBSSw2REFBUSxDQUFDO1FBS3pDLEtBQVEsaUJBQXNDLENBQUM7UUFDL0MsS0FBUSxPQUFvQyxDQUFDO1FBRTdDLEtBQVEsU0FBNkI7WUFDbkMsU0FBUztnQkFDUCxTQUFTLENBQUM7Z0JBQ1YsUUFBUSxDQUFDO1lBQ1g7WUFDQSxZQUFZLENBQUM7WUFDYixjQUFjLENBQUM7WUFDZixVQUFVLENBQUM7WUFDWCxjQUFjLENBQUM7WUFDZixXQUFXO1lBQ1gsc0JBQXNCO1lBQ3RCLHFDQUFxQztZQUNyQyxhQUFhLENBQUM7UUFDaEI7UUFZRSxLQUFLLE9BQU8sS0FBSztRQUNqQixLQUFLLFVBQVUsS0FBSztRQUNwQixLQUFLLFVBQVUsS0FBSztRQUNwQixLQUFLLGlCQUFpQixLQUFLO1FBQzNCLEtBQUssa0JBQWtCLEtBQUs7UUFDNUIsS0FBSyxnQkFBZ0IsS0FBSyxjQUFjO0lBQzFDO0FBNFVGO0FBTU8sSUFBTSx5QkFBTixNQUE2QjtJQUtsQzs7Ozs7OztHQUFBLEdBVUEsa0JBQWtCLGdCQUFxQztRQUNyRCxLQUFLLFdBQVcsa0JBQWtCLGNBQWM7SUFDbEQ7SUFFQSxnQkFBZ0IsU0FBOEI7UUFDNUMsS0FBSyxXQUFXLGdCQUFnQixPQUFPO0lBQ3pDO0lBQUE7Ozs7R0FBQSxHQU9BLG9CQUNFLFdBQ0EsTUFDQTtRQUNBLEtBQUssV0FBVyxvQkFBb0IsV0FBVyxJQUFJO0lBQ3JEO0lBc0JBLGtCQUNFLFdBQ0EsWUFDQTtRQUVBLElBQUksY0FBYyxPQUFPLGVBQWUsWUFBWSxXQUFXLFlBQVk7WUFDekUsS0FBSyxXQUFXLGtCQUFrQixXQUFXLFVBQVU7UUFDekQsT0FBTztZQUVMLElBQ0UsS0FBc0MsSUFDdEMsQ0FBQyxLQUFLLHlCQUNOO2dCQUNBLFFBQVEsS0FDTjtnQkFHRixLQUFLLDBCQUEwQjtZQUNqQztZQUNBLEtBQUssb0JBQW9CLFdBQVcsVUFBVTtRQUNoRDtJQUNGO0lBR0EsaUJBQ0UsSUFDQSxNQUNBO1FBQ0EsS0FBSyxXQUFXLGlCQUFpQixJQUFJLElBQUk7SUFDM0M7SUFFQSxzQkFDRSxTQUNBLE1BQ0E7UUFDQSxLQUFLLFdBQVcsc0JBQXNCLFNBQVMsSUFBSTtJQUNyRDtJQUVBLGNBQWMsT0FBZSxNQUFpQjtRQUM1QyxLQUFLLFdBQVcsY0FBYyxPQUFPLElBQUk7SUFDM0M7SUFFQSxjQUFjLE9BQTBCO1FBQ3RDLEtBQUssV0FBVyxjQUFjLEtBQUs7SUFDckM7SUF3QkEscUJBQWlFO1FBQWpFO1lBQXNCLEtBQXRCLHVCQUFzQjs7UUFDcEIsT0FBTyxLQUFLLFdBQVcsbUJBQW1CLEdBQUcsSUFBSTtJQUNuRDtJQWNNLDBCQUVpQztRQUZqQztpQkFBQSx1QkFDRDs7UUFDa0M7WUFDckMsT0FBTyxLQUFLLFdBQVcsd0JBQXdCLEdBQUcsSUFBSTtRQUN4RDtJQUFBO0lBQUE7O0dBQUEsR0FLTSxXQUFXLE1BQXVCO1FBQUE7WUFDdEMsT0FBTyxLQUFLLFdBQVcsV0FBVyxJQUFJO1FBQ3hDO0lBQUE7SUFBQTs7R0FBQSxHQUtNLGtCQUFrQjtRQUFBO1lBQ3RCLE9BQU8sS0FBSyxXQUFXLGdCQUFnQjtRQUN6QztJQUFBO0lBRWdCLG9CQUNkLE1BQ0E7UUFBQTtZQUNBLE9BQU8sS0FBSyxXQUFXLG1CQUFtQixJQUFJO1FBQ2hEO0lBQUE7SUFFTSxtQkFBbUIsTUFHdEI7UUFBQTtZQUNELE9BQU8sS0FBSyxvQkFBb0I7Z0JBQzlCLFFBQVEsS0FBSztnQkFDYixlQUFlLENBQUM7b0JBQ2QsSUFBSSxLQUFLLE9BQU87d0JBQ2QsT0FBTyxLQUFLLE1BQU0sR0FBRztvQkFDdkIsT0FBTzt3QkFDTCxNQUFNLFVBQVUsdUJBQXVCO3dCQUN2QyxPQUFPLFFBQVEsR0FBRztvQkFDcEI7Z0JBQ0Y7Z0JBQ0Esa0JBQWtCLENBQUMsS0FBYTtvQkFDOUIsSUFBSSxDQUFDLEtBQUssT0FBTzt3QkFDZix5QkFBeUIsS0FBSyxLQUFLO29CQUNyQztnQkFDRjtZQUNGLENBQUM7UUFDSDtJQUFBO0lBRUEsYUFBYSxRQUE0QixTQUF1QjtRQUM5RCxPQUFPLEtBQUssV0FBVyxhQUFhLFFBQVEsT0FBTztJQUNyRDtJQUVBLHFCQUNFLFdBQ0EsU0FDQTtRQUNBLE9BQU8sMEVBQWMsQ0FBQyxLQUFLLGdCQUFnQixHQUFHLFdBQVcsT0FBTztJQUNsRTtJQUVBLGtCQUFrQjtRQUNoQixPQUFPLEtBQUssV0FBVyxnQkFBZ0I7SUFDekM7SUFFQSxrQkFBMkI7b0JBQVgsaUVBQVE7UUFDdEIsS0FBSyxXQUFXLGdCQUFnQixLQUFLO0lBQ3ZDO0lBRUEsYUFBYTtRQUNYLE9BQU8sS0FBSyxXQUFXLFdBQVc7SUFDcEM7SUE3TUEsWUFBWSxTQUE4QztRQTBFMUQsS0FBUSwwQkFBMEI7UUF6RWhDLEtBQUssYUFBYTtJQUNwQjtBQTRNRjs7QUx0MkJPLElBQU0saUNBQU4sY0FBNkMsbUNBQW1DO0lBdUNyRixrQkFDRSxXQUNBLE1BQ0E7UUE3RUo7UUErRUksTUFBTSxlQUFlLE9BQU8sWUFDMUIsT0FBTyxTQUFRLFVBQUssV0FBTCxZQUFlLENBQUMsQ0FBQyxFQUU3QixPQUFPO2dCQUFDLENBQUMsR0FBRyxTQUFTO21CQUNwQixPQUFPLEtBQUssU0FBUyxFQUFFLEtBQUssQ0FBQyxNQUFRLDhEQUFnQixDQUFDLFNBQVMsR0FBRyxDQUFDO1dBRXBFLElBQUk7Z0JBQUMsQ0FBQyxXQUFXLFNBQVM7bUJBQU07Z0JBQy9CO2dCQUNBLE9BQU8sWUFDTCw4REFBZ0IsQ0FDYixPQUFPLENBQUMsTUFBUSxPQUFPLFNBQVMsRUFDaEMsSUFBSSxDQUFDLE1BQVE7d0JBQUM7d0JBQUssVUFBVSxHQUFHLENBQUM7cUJBQUM7YUFFeEM7O1FBRUwsTUFBTSxVQUFVO1lBQUUsUUFBUTtRQUFhO1FBQ3ZDLEtBQUssNEJBQ0gsV0FDQTtZQUFFLE1BQU0sS0FBSztZQUFNLFFBQVE7UUFBSyxHQUNoQyxPQUFPLEtBQUssWUFBWSxFQUFFLFNBQVMsSUFBSSxVQUFVO1FBRW5ELG1FQUFpQixDQUFDLFdBQVcsZ0RBQ3hCLE9BRHdCO1lBQUE7WUFHM0IsYUFBWSxVQUFLLGVBQUwsWUFBbUI7UUFBQSxJQUMzQixPQUFPLEtBQUssWUFBWSxFQUFFLFNBQVMsSUFDbkM7WUFDRSxrQkFBa0I7Z0JBQ2hCO2dCQUNBLFlBQVk7Z0JBQ1osWUFBWTtZQUNkO1FBQ0YsSUFDQSxDQUFDLEVBQ047SUFDSDtJQUVBLGlCQUNFLElBQ0EsTUFDQTtRQXZISjtRQXdISSxrRUFBZ0IsQ0FBQyxJQUFJLGlDQUNoQixPQURnQjtZQUVuQixhQUFZLFVBQUssZUFBTCxZQUFtQjtRQUNqQyxFQUFDO1FBQ0QsNEJBQTRCLDBCQUEwQixJQUFJLENBQUMsSUFBSTtJQUNqRTtJQUVBLHNCQUNFLFNBQ0EsTUFDQTtRQWxJSjtRQW1JSSxLQUFLLG9CQUFvQixTQUFTO1lBQUUsTUFBTSxLQUFLO1lBQU0sUUFBUTtRQUFLLENBQUM7UUFFbkUsdUVBQXFCLENBQUMsU0FBUyxpQ0FDMUIsT0FEMEI7WUFFN0IsYUFBWSxVQUFLLGVBQUwsWUFBbUI7UUFDakMsRUFBQztJQUNIO0lBRUEsY0FBYyxPQUFlLE1BQWlCO1FBQzVDLCtEQUFhLENBQUMsT0FBTyxJQUFJO0lBQzNCO0lBRUEsY0FBYyxPQUEwQjtRQUN0QywrREFBYSxDQUFDLEtBQUs7SUFDckI7SUFFQSxxQkFBcUIsU0FBNkI7UUFDaEQsS0FBSyxNQUFNLEtBQUssT0FBTztJQUN6QjtJQUVBLHVCQUF1QixTQUE2QjtRQUNsRCxNQUFNLFFBQVEsS0FBSyxNQUFNLFFBQVEsT0FBTztRQUN4QyxJQUFJLFNBQVMsR0FBRztZQUNkLEtBQUssTUFBTSxPQUFPLE9BQU8sQ0FBQztRQUM1QjtJQUNGO0lBRUEsa0JBQWtCO1FBT2hCLFdBQVcsZUFBZSxLQUFLLFVBQVUsRUFBRSxhQUFjO1lBQ3ZELElBQUksWUFBWSxTQUFTLGlCQUFpQjtnQkFDeEMsaUNBQWlDLFlBQVksRUFBRSxJQUM3Qyx1QkFBdUIsWUFBWSxNQUFNLFlBQVksU0FBUztZQUNsRTtRQUNGO1FBQ0EsTUFBTSxnQkFBZ0I7SUFDeEI7SUF0SUEsWUFBWSxLQUFtQjtRQUM3QixNQUFNLFVBQVUsSUFBSUUsbUVBQUFOLENBQWUsaUNBQzlCLE9BRDhCO1lBRWpDLFlBQVksS0FBSyxTQUFTLElBQUksQ0FBQyxJQUFNLEVBQUUsRUFBRTtRQUMzQyxFQUFDO1FBQ0QsTUFBTTtZQUNKO1lBQ0E7WUFDQSxTQUFTLElBQUlPLDBFQUFBUixDQUFzQixJQUFJO1lBQ3ZDLGdCQUFnQjtnQkFDZCxLQUFLLGdCQUFnQjtZQUN2QjtZQUNBLGlCQUFpQjtnQkFDZixLQUFLLE1BQU0sUUFBUSxDQUFDO29CQW5ENUI7b0JBbUR3QyxxQkFBUSxrQkFBUjtnQkFBQSxDQUF5QjtZQUMzRDtZQUNBLGdCQUFnQjtnQkFDZCxPQUFPLDhDQUFBRTtnQkFDUCxhQUFhLHNDQUFRO2dCQUNyQixxQkFBcUIsNk5BQVU7Z0JBQy9CLHlCQUF5Qix5T0FBYTtnQkFBYjtnQkFBQTtnQkFJekIscUJBQXFCLDhDQUFZO2dCQUNqQyxvQ0FBb0MsNkRBQXlCO2dCQUM3RCxvQkFBb0IsNkNBQVc7Z0JBQy9CLHVDQUF1QztvQkFDckMsWUFBWTtvQkFDWixvQkFBb0I7b0JBQ3BCLHNCQUFzQjtvQkFDdEIsV0FBVztnQkFDYjtZQUNGO1FBQ0YsQ0FBQztRQW5DSCxLQUFpQixRQUE4QixDQUFDO0lBb0NoRDtBQXFHRjs7QVF2Sk87QUFFNkI7O0FDeEJiOztBQ0FBO0FBbUJoQiw2QkFDTDtRQUNBLHdFQUFvQyxDQUFDOztJQUVyQyxNQUFNO0lBQ04sSUFBSSxDQUFDLGFBQWE7UUFDaEIsTUFBTSxJQUFJLE1BQ1I7SUFFSjtJQUVBLE1BQU0sU0FBUyxZQUFZO0lBQzNCLE1BQU0sU0FBUyxPQUFPLFVBQVU7SUFFaEMsTUFBTSxZQUFZLE9BQU8sYUFBYSxJQUFJLElBQ3RDLE9BQU8sYUFBYSxNQUFNLElBQUksSUFDOUI7SUFFSixNQUFNLGFBQWEsb0JBQW9CLElBQUk7SUFDM0MsTUFBTTtJQUNOLE1BQU0sY0FBYyxlQUFlO0lBRTdCO3lDQUFVO1lBQ2QsSUFBSSxDQUFDLFdBQVc7Z0JBQ2Q7cURBQUMsSUFBWTs2REFBQTtnQ0FDWCxNQUFNLE9BQU8sbUJBQW1CLFVBQVU7Z0NBQzFDLElBQUksVUFBVSxHQUFHO29DQUNmLFlBQVk7Z0NBQ2Q7NEJBQ0Y7OztZQUNGO1FBQ0Y7d0NBQUc7UUFBQztRQUFXLFVBQVU7S0FBQztJQUUxQixPQUFPO0FBQ1Q7SUFsQ2dCOztRQUlNLHNCQUFzQjs7UUFleEIsYUFBYTs7Ozs7QURqQ2pDLElBQU0sd0NBQWdDLGlEQUFjLEtBQUs7QUFFbEQsMEJBQTBCLE9BaUJIOztJQUM1QixNQUFNLEVBQUUsV0FBVyxXQUFXLGdCQUFnQixjQUFjLElBQUk7SUFFaEUsTUFBTTtJQUNOLE1BQU0sZUFBZSxDQUFPLDhDQUFXLHVCQUF1QjtJQUU5RCxJQUFJLENBQUMsYUFBYTtRQUVoQixNQUFNLElBQUksTUFDUjtJQUVKO0lBRUEsTUFTSSxrQkFSRixVQUNBLHFCQUNBLFdBQ0EsZUFDQSxlQUNBLGlCQUNBLFlBNUNKLEdBOENNLElBREMsaUJBQ0QsSUFEQztRQVBIO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO0tBQUE7SUFJRixNQUFNLGdDQUNKO1FBQUUsTUFBTTtRQUFXO1FBQVcsUUFBUTtJQUFNLEdBQzVDO1FBQUU7SUFBYztJQUdaO3NDQUFVO1lBQ2QsSUFBSSxjQUFjO2dCQUNoQixNQUFNLE9BQU8sT0FDVixVQUFVLEVBQ1YsaUJBQWlCO29CQUFFLE1BQU07b0JBQVc7Z0JBQVUsQ0FBQztnQkFFbEQsSUFBSSxNQUFNO29CQUNSLE9BQU8sWUFBWTt3QkFDakIsV0FBVzs0QkFDVCxlQUFlLEtBQUs7NEJBQ3BCLGlCQUFpQixLQUFLOzRCQUN0QixtQkFBbUI7NEJBQ25CLFNBQVMsT0FBTyxXQUFXOzRCQUMzQixZQUFZLE9BQU8sY0FBYzt3QkFDbkM7d0JBQ0E7b0JBQ0YsQ0FBQztnQkFDSDtZQUNGO1FBQ0Y7cUNBQUc7UUFBQztRQUFXO1FBQVc7UUFBUSxTQUFTO0tBQUM7SUFFNUMsTUFBTSxVQUFnQjs2Q0FBUTtZQTFFaEMsSUFBQUU7WUEyRUksSUFBSSxDQUFDLFdBQVc7Z0JBQ2QsT0FBTztZQUNUO1lBRUEsSUFBSSxNQUFNLCtFQUFDLDhCQUFjLGVBQWdCO1lBRXpDLElBQUksY0FBYztnQkFTaEIsTUFBTSxTQUFTLE9BQU8sVUFBVTtnQkFDaEMsTUFBTSx1QkFBdUIsT0FBTyxnQkFBZ0I7Z0JBQ3BELE1BQU0seUJBQXlCLE9BQU8sMEJBQTBCO29CQUM5RCxNQUFNO29CQUNOO2dCQUNGLENBQUM7Z0JBQ0QsTUFDRSwrRUFBQyx1REFDSyxPQURMO29CQUVDO29CQUNBO29CQUNBO29CQUNBLE1BQU07d0JBQ0o7d0JBQ0Esa0JBQVcsT0FBTyxLQUFLLFNBQVosZ0JBQUFBLElBQWtCO29CQUMvQjtnQkFBQSxJQUVBLCtFQUFDO29CQUNDLE1BQU0sQ0FBQyxDQUFDO29CQUNSOzZEQUFTLENBQUMsV0FDUiwrRUFBQywyQ0FBMkIsc0JBQ3pCLFFBQ0g7O2dCQUFBLEdBR0YsK0VBQUMsd0JBQXdCLFVBQXhCO29CQUFpQyxPQUFPO2dCQUFBLEdBQ3RDLEdBQ0g7WUFJUjtZQUNBLE9BQU87UUFDVDs0Q0FBRztRQUNEO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFBQTtRQUNBO1FBQ0E7S0FDRDtJQUNELE9BQU87QUFDVDs7O1FBN0dzQixzQkFBc0I7UUFxQnhCOzs7TUF6Q0o7O0FFSlQ7QUFzQ0EsU0FBUyx3QkFDZCxTQUM4QjtJQUM5QixPQUFPLDZFQUF3QixDQUFDLE9BQU87QUFDekM7QUFLTyxTQUFTLGVBQWUsU0FBNEM7SUFDekUsT0FBTyxvRUFBc0IsQ0FBQyxPQUFPO0FBQ3ZDOztBQ3BEd0M7QUFDdEI7QUFDRztBQUNpQztBQU10RCxTQUFzQixnQkFDcEIsSUFDQSxJQUNBLElBU0E7SUFBQSwwQ0FYQSxRQUNBLFFBQ0E7bUJBQ0EsaUVBT0ksQ0FBQztRQUVMLE9BQU8sSUFBSSxRQUFjLENBQUM7WUFDeEIsTUFBTSxVQUFVLFlBQVksUUFBUSxRQUFRLElBQUk7WUFDaEQsc0NBQUFJLENBQVMsT0FBTyxTQUFTLFFBQVEsSUFBTSxRQUFRLENBQUM7UUFDbEQsQ0FBQztJQUNIO0FBQUE7QUFFTyxTQUFTLGVBQ2QsUUFDQTtlQUNBLGlFQUtJLENBQUM7SUFFTCxNQUFNLFVBQVUsWUFBWSxRQUFRLFFBQVEsSUFBSTtJQUNoRCxPQUFPLGlFQUFtQixDQUFDLE9BQU87QUFDcEM7QUFFQSxTQUFzQixtQ0FDcEIsSUFDQSxJQU9BO0lBQUEsMENBUkEsUUFDQTttQkFDQSxpRUFLSSxDQUFDO1FBRUwsTUFBTSxVQUFVLFlBQVksUUFBUSxRQUFRLElBQUk7UUFDaEQsT0FBTyw2RUFBQUQsQ0FBd0IsT0FBTztJQUN4QztBQUFBO0FBRUEsU0FBc0IsbUJBQ3BCLElBQ0EsSUFDQSxJQU9BO0lBQUEsMENBVEEsUUFDQSxRQUNBO21CQUNBLGlFQUtJLENBQUM7UUFFTCxPQUFPLElBQUksUUFBYyxDQUFDO1lBQ3hCLE1BQU0sVUFBVSxZQUFZLFFBQVEsUUFBUSxJQUFJO1lBQ2hELHNDQUFBQyxDQUFTLFFBQVEsU0FBUyxRQUFRLElBQU0sUUFBUSxDQUFDO1FBQ25ELENBQUM7SUFDSDtBQUFBO0FBRUEsU0FBUyxZQUNQLFFBQ0E7ZUFDQSxpRUFPSSxDQUFDO0lBRUwsT0FDRSx5RkFBQztRQUNDO1FBQ0EsZ0JBQWdCLEtBQUs7UUFDckIsZ0JBQWdCLEtBQUs7UUFDckIscUJBQXFCLEtBQUs7UUFDMUIsWUFBWSxLQUFLO1FBQ2pCLFdBQVcsS0FBSztJQUFBLEdBRWhCLHlGQUFDO1FBQ0MsV0FBVyxPQUFPLFdBQVcsV0FBVyxTQUFTLE9BQU87UUFDeEQsV0FBVyxPQUFPLFdBQVcsV0FBVyxTQUFZLE9BQU87UUFDM0QsZ0JBQWdCLEtBQUs7SUFBQTtBQUk3Qjs7QUp6RE8sU0FBUyxrQkFBa0IsTUFBMkM7SUFDM0UsTUFBTSxXQUFXLElBQUksK0JBQStCLElBQUk7SUFDeEQsT0FBTyxJQUFJLHVCQUF1QixRQUFRO0FBQzVDIiwic291cmNlcyI6WyIvVXNlcnMvd29uZGVybGFuZG1pdGNoL0Nhc2NhZGVQcm9qZWN0cy9zcmMvbG9hZGVyLWNsaWVudC50cyIsIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL3NyYy9QbGFzbWljUm9vdFByb3ZpZGVyLnRzeCIsIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL3NyYy91dGlscy50c3giLCIvVXNlcnMvd29uZGVybGFuZG1pdGNoL0Nhc2NhZGVQcm9qZWN0cy9zcmMvdmFyaWF0aW9uLnRzIiwiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvc3JjL2dsb2JhbC12YXJpYW50cy50cyIsIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL3NyYy9sb2FkZXItc2hhcmVkLnRzIiwiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvc3JjL2J1bmRsZXMudHMiLCIvVXNlcnMvd29uZGVybGFuZG1pdGNoL0Nhc2NhZGVQcm9qZWN0cy9zcmMvY29tcG9uZW50LWxvb2t1cC50cyIsIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL3NyYy9pbmRleC50cyIsIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL3NyYy9QbGFzbWljQ29tcG9uZW50LnRzeCIsIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL3NyYy91c2VQbGFzbWljQ29tcG9uZW50LnRzeCIsIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL3NyYy9wcmVwYXNzLWNsaWVudC50cyIsIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL3NyYy9yZW5kZXIudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFBsYXNtaWNEYXRhU291cmNlc0NvbnRleHQgZnJvbSBcIkBwbGFzbWljYXBwL2RhdGEtc291cmNlcy1jb250ZXh0XCI7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1pbXBvcnRzXG5pbXBvcnQgKiBhcyBQbGFzbWljSG9zdCBmcm9tIFwiQHBsYXNtaWNhcHAvaG9zdFwiO1xuaW1wb3J0IHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtaW1wb3J0c1xuICByZWdpc3RlckNvbXBvbmVudCxcbiAgcmVnaXN0ZXJGdW5jdGlvbixcbiAgcmVnaXN0ZXJHbG9iYWxDb250ZXh0LFxuICByZWdpc3RlclRva2VuLFxuICByZWdpc3RlclRyYWl0LFxuICBzdGF0ZUhlbHBlcnNLZXlzLFxuICBUb2tlblJlZ2lzdHJhdGlvbixcbiAgVHJhaXRNZXRhLFxufSBmcm9tIFwiQHBsYXNtaWNhcHAvaG9zdFwiO1xuaW1wb3J0IHsgUGxhc21pY01vZHVsZXNGZXRjaGVyLCBQbGFzbWljVHJhY2tlciB9IGZyb20gXCJAcGxhc21pY2FwcC9sb2FkZXItY29yZVwiO1xuaW1wb3J0ICogYXMgUGxhc21pY1F1ZXJ5IGZyb20gXCJAcGxhc21pY2FwcC9xdWVyeVwiO1xuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gXCJyZWFjdC1kb21cIjtcbmltcG9ydCAqIGFzIGpzeERldlJ1bnRpbWUgZnJvbSBcInJlYWN0L2pzeC1kZXYtcnVudGltZVwiO1xuaW1wb3J0ICogYXMganN4UnVudGltZSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmltcG9ydCB7IGNyZWF0ZVVzZUdsb2JhbFZhcmlhbnQgfSBmcm9tIFwiLi9nbG9iYWwtdmFyaWFudHNcIjtcbmltcG9ydCB7XG4gIEJhc2VJbnRlcm5hbFBsYXNtaWNDb21wb25lbnRMb2FkZXIsXG4gIENvZGVDb21wb25lbnRNZXRhLFxuICBjdXN0b21GdW5jdGlvbkltcG9ydEFsaWFzLFxuICBDdXN0b21GdW5jdGlvbk1ldGEsXG4gIEdsb2JhbENvbnRleHRNZXRhLFxuICBJbml0T3B0aW9ucyxcbiAgUGxhc21pY1Jvb3RXYXRjaGVyLFxuICBSRUdJU1RFUkVEX0NPREVfQ09NUE9ORU5UX0hFTFBFUlMsXG4gIFJFR0lTVEVSRURfQ1VTVE9NX0ZVTkNUSU9OUyxcbiAgU1VCU1RJVFVURURfQ09NUE9ORU5UUyxcbiAgU1VCU1RJVFVURURfR0xPQkFMX1ZBUklBTlRfSE9PS1MsXG59IGZyb20gXCIuL2xvYWRlci1zaGFyZWRcIjtcblxuZXhwb3J0IGNsYXNzIEludGVybmFsUGxhc21pY0NvbXBvbmVudExvYWRlciBleHRlbmRzIEJhc2VJbnRlcm5hbFBsYXNtaWNDb21wb25lbnRMb2FkZXIge1xuICBwcml2YXRlIHJlYWRvbmx5IHJvb3RzOiBQbGFzbWljUm9vdFdhdGNoZXJbXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKG9wdHM6IEluaXRPcHRpb25zKSB7XG4gICAgY29uc3QgdHJhY2tlciA9IG5ldyBQbGFzbWljVHJhY2tlcih7XG4gICAgICAuLi5vcHRzLFxuICAgICAgcHJvamVjdElkczogb3B0cy5wcm9qZWN0cy5tYXAoKHApID0+IHAuaWQpLFxuICAgIH0pO1xuICAgIHN1cGVyKHtcbiAgICAgIG9wdHMsXG4gICAgICB0cmFja2VyLFxuICAgICAgZmV0Y2hlcjogbmV3IFBsYXNtaWNNb2R1bGVzRmV0Y2hlcihvcHRzKSxcbiAgICAgIG9uQnVuZGxlTWVyZ2VkOiAoKSA9PiB7XG4gICAgICAgIHRoaXMucmVmcmVzaFJlZ2lzdHJ5KCk7XG4gICAgICB9LFxuICAgICAgb25CdW5kbGVGZXRjaGVkOiAoKSA9PiB7XG4gICAgICAgIHRoaXMucm9vdHMuZm9yRWFjaCgod2F0Y2hlcikgPT4gd2F0Y2hlci5vbkRhdGFGZXRjaGVkPy4oKSk7XG4gICAgICB9LFxuICAgICAgYnVpbHRpbk1vZHVsZXM6IHtcbiAgICAgICAgcmVhY3Q6IFJlYWN0LFxuICAgICAgICBcInJlYWN0LWRvbVwiOiBSZWFjdERPTSxcbiAgICAgICAgXCJyZWFjdC9qc3gtcnVudGltZVwiOiBqc3hSdW50aW1lLFxuICAgICAgICBcInJlYWN0L2pzeC1kZXYtcnVudGltZVwiOiBqc3hEZXZSdW50aW1lLFxuXG4gICAgICAgIC8vIEFsc28gaW5qZWN0IEBwbGFzbWljYXBwL3F1ZXJ5IGFuZCBAcGxhc21pY2FwcC9ob3N0IHRvIHVzZSB0aGVcbiAgICAgICAgLy8gc2FtZSBjb250ZXh0cyBoZXJlIGFuZCBpbiBsb2FkZXItZG93bmxvYWRlZCBjb2RlLlxuICAgICAgICBcIkBwbGFzbWljYXBwL3F1ZXJ5XCI6IFBsYXNtaWNRdWVyeSxcbiAgICAgICAgXCJAcGxhc21pY2FwcC9kYXRhLXNvdXJjZXMtY29udGV4dFwiOiBQbGFzbWljRGF0YVNvdXJjZXNDb250ZXh0LFxuICAgICAgICBcIkBwbGFzbWljYXBwL2hvc3RcIjogUGxhc21pY0hvc3QsXG4gICAgICAgIFwiQHBsYXNtaWNhcHAvbG9hZGVyLXJ1bnRpbWUtcmVnaXN0cnlcIjoge1xuICAgICAgICAgIGNvbXBvbmVudHM6IFNVQlNUSVRVVEVEX0NPTVBPTkVOVFMsXG4gICAgICAgICAgZ2xvYmFsVmFyaWFudEhvb2tzOiBTVUJTVElUVVRFRF9HTE9CQUxfVkFSSUFOVF9IT09LUyxcbiAgICAgICAgICBjb2RlQ29tcG9uZW50SGVscGVyczogUkVHSVNURVJFRF9DT0RFX0NPTVBPTkVOVF9IRUxQRVJTLFxuICAgICAgICAgIGZ1bmN0aW9uczogUkVHSVNURVJFRF9DVVNUT01fRlVOQ1RJT05TLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIHJlZ2lzdGVyQ29tcG9uZW50PFQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnRUeXBlPGFueT4+KFxuICAgIGNvbXBvbmVudDogVCxcbiAgICBtZXRhOiBDb2RlQ29tcG9uZW50TWV0YTxSZWFjdC5Db21wb25lbnRQcm9wczxUPj5cbiAgKSB7XG4gICAgLy8gbWFraW5nIHRoZSBjb21wb25lbnQgbWV0YSBjb25zaXN0ZW50IGJldHdlZW4gY29kZWdlbiBhbmQgbG9hZGVyXG4gICAgY29uc3Qgc3RhdGVIZWxwZXJzID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgT2JqZWN0LmVudHJpZXMobWV0YS5zdGF0ZXMgPz8ge30pXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgLmZpbHRlcigoW18sIHN0YXRlU3BlY10pID0+XG4gICAgICAgICAgT2JqZWN0LmtleXMoc3RhdGVTcGVjKS5zb21lKChrZXkpID0+IHN0YXRlSGVscGVyc0tleXMuaW5jbHVkZXMoa2V5KSlcbiAgICAgICAgKVxuICAgICAgICAubWFwKChbc3RhdGVOYW1lLCBzdGF0ZVNwZWNdKSA9PiBbXG4gICAgICAgICAgc3RhdGVOYW1lLFxuICAgICAgICAgIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgICAgIHN0YXRlSGVscGVyc0tleXNcbiAgICAgICAgICAgICAgLmZpbHRlcigoa2V5KSA9PiBrZXkgaW4gc3RhdGVTcGVjKVxuICAgICAgICAgICAgICAubWFwKChrZXkpID0+IFtrZXksIHN0YXRlU3BlY1trZXldXSlcbiAgICAgICAgICApLFxuICAgICAgICBdKVxuICAgICk7XG4gICAgY29uc3QgaGVscGVycyA9IHsgc3RhdGVzOiBzdGF0ZUhlbHBlcnMgfTtcbiAgICB0aGlzLmludGVybmFsU3Vic3RpdHV0ZUNvbXBvbmVudChcbiAgICAgIGNvbXBvbmVudCxcbiAgICAgIHsgbmFtZTogbWV0YS5uYW1lLCBpc0NvZGU6IHRydWUgfSxcbiAgICAgIE9iamVjdC5rZXlzKHN0YXRlSGVscGVycykubGVuZ3RoID4gMCA/IGhlbHBlcnMgOiB1bmRlZmluZWRcbiAgICApO1xuICAgIHJlZ2lzdGVyQ29tcG9uZW50KGNvbXBvbmVudCwge1xuICAgICAgLi4ubWV0YSxcbiAgICAgIC8vIEltcG9ydCBwYXRoIGlzIG5vdCB1c2VkIGFzIHdlIHdpbGwgdXNlIGNvbXBvbmVudCBzdWJzdGl0dXRpb25cbiAgICAgIGltcG9ydFBhdGg6IG1ldGEuaW1wb3J0UGF0aCA/PyBcIlwiLFxuICAgICAgLi4uKE9iamVjdC5rZXlzKHN0YXRlSGVscGVycykubGVuZ3RoID4gMFxuICAgICAgICA/IHtcbiAgICAgICAgICAgIGNvbXBvbmVudEhlbHBlcnM6IHtcbiAgICAgICAgICAgICAgaGVscGVycyxcbiAgICAgICAgICAgICAgaW1wb3J0UGF0aDogXCJcIixcbiAgICAgICAgICAgICAgaW1wb3J0TmFtZTogXCJcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfVxuICAgICAgICA6IHt9KSxcbiAgICB9KTtcbiAgfVxuXG4gIHJlZ2lzdGVyRnVuY3Rpb248RiBleHRlbmRzICguLi5hcmdzOiBhbnlbXSkgPT4gYW55PihcbiAgICBmbjogRixcbiAgICBtZXRhOiBDdXN0b21GdW5jdGlvbk1ldGE8Rj5cbiAgKSB7XG4gICAgcmVnaXN0ZXJGdW5jdGlvbihmbiwge1xuICAgICAgLi4ubWV0YSxcbiAgICAgIGltcG9ydFBhdGg6IG1ldGEuaW1wb3J0UGF0aCA/PyBcIlwiLFxuICAgIH0pO1xuICAgIFJFR0lTVEVSRURfQ1VTVE9NX0ZVTkNUSU9OU1tjdXN0b21GdW5jdGlvbkltcG9ydEFsaWFzKG1ldGEpXSA9IGZuO1xuICB9XG5cbiAgcmVnaXN0ZXJHbG9iYWxDb250ZXh0PFQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnRUeXBlPGFueT4+KFxuICAgIGNvbnRleHQ6IFQsXG4gICAgbWV0YTogR2xvYmFsQ29udGV4dE1ldGE8UmVhY3QuQ29tcG9uZW50UHJvcHM8VD4+XG4gICkge1xuICAgIHRoaXMuc3Vic3RpdHV0ZUNvbXBvbmVudChjb250ZXh0LCB7IG5hbWU6IG1ldGEubmFtZSwgaXNDb2RlOiB0cnVlIH0pO1xuICAgIC8vIEltcG9ydCBwYXRoIGlzIG5vdCB1c2VkIGFzIHdlIHdpbGwgdXNlIGNvbXBvbmVudCBzdWJzdGl0dXRpb25cbiAgICByZWdpc3Rlckdsb2JhbENvbnRleHQoY29udGV4dCwge1xuICAgICAgLi4ubWV0YSxcbiAgICAgIGltcG9ydFBhdGg6IG1ldGEuaW1wb3J0UGF0aCA/PyBcIlwiLFxuICAgIH0pO1xuICB9XG5cbiAgcmVnaXN0ZXJUcmFpdCh0cmFpdDogc3RyaW5nLCBtZXRhOiBUcmFpdE1ldGEpIHtcbiAgICByZWdpc3RlclRyYWl0KHRyYWl0LCBtZXRhKTtcbiAgfVxuXG4gIHJlZ2lzdGVyVG9rZW4odG9rZW46IFRva2VuUmVnaXN0cmF0aW9uKSB7XG4gICAgcmVnaXN0ZXJUb2tlbih0b2tlbik7XG4gIH1cblxuICBzdWJzY3JpYmVQbGFzbWljUm9vdCh3YXRjaGVyOiBQbGFzbWljUm9vdFdhdGNoZXIpIHtcbiAgICB0aGlzLnJvb3RzLnB1c2god2F0Y2hlcik7XG4gIH1cblxuICB1bnN1YnNjcmliZVBsYXNtaWNSb290KHdhdGNoZXI6IFBsYXNtaWNSb290V2F0Y2hlcikge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5yb290cy5pbmRleE9mKHdhdGNoZXIpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB0aGlzLnJvb3RzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICB9XG5cbiAgcmVmcmVzaFJlZ2lzdHJ5KCkge1xuICAgIC8vIFdlIHN3YXAgZ2xvYmFsIHZhcmlhbnRzJyB1c2VYWFhHbG9iYWxWYXJpYW50KCkgaG9vayB3aXRoXG4gICAgLy8gYSBmYWtlIG9uZSB0aGF0IGp1c3QgcmVhZHMgZnJvbSB0aGUgUGxhc21pY1Jvb3RDb250ZXh0LiBCZWNhdXNlXG4gICAgLy8gZ2xvYmFsIHZhcmlhbnQgdmFsdWVzIGFyZSBub3Qgc3VwcGxpZWQgYnkgdGhlIGdlbmVyYXRlZCBnbG9iYWwgdmFyaWFudFxuICAgIC8vIGNvbnRleHQgcHJvdmlkZXJzLCBidXQgaW5zdGVhZCBieSA8UGxhc21pY1Jvb3RQcm92aWRlci8+IGFuZCBieVxuICAgIC8vIFBsYXNtaWNDb21wb25lbnRMb2FkZXIuc2V0R2xvYmFsVmFyaWFudHMoKSwgd2UgcmVkaXJlY3QgdGhlc2VcbiAgICAvLyBob29rcyB0byByZWFkIGZyb20gdGhlbSBpbnN0ZWFkLlxuICAgIGZvciAoY29uc3QgZ2xvYmFsR3JvdXAgb2YgdGhpcy5nZXRCdW5kbGUoKS5nbG9iYWxHcm91cHMpIHtcbiAgICAgIGlmIChnbG9iYWxHcm91cC50eXBlICE9PSBcImdsb2JhbC1zY3JlZW5cIikge1xuICAgICAgICBTVUJTVElUVVRFRF9HTE9CQUxfVkFSSUFOVF9IT09LU1tnbG9iYWxHcm91cC5pZF0gPVxuICAgICAgICAgIGNyZWF0ZVVzZUdsb2JhbFZhcmlhbnQoZ2xvYmFsR3JvdXAubmFtZSwgZ2xvYmFsR3JvdXAucHJvamVjdElkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3VwZXIucmVmcmVzaFJlZ2lzdHJ5KCk7XG4gIH1cbn1cbiIsImltcG9ydCB7IFBsYXNtaWNEYXRhU291cmNlQ29udGV4dFZhbHVlIH0gZnJvbSBcIkBwbGFzbWljYXBwL2RhdGEtc291cmNlcy1jb250ZXh0XCI7XG5pbXBvcnQgeyBQYWdlUGFyYW1zUHJvdmlkZXIgfSBmcm9tIFwiQHBsYXNtaWNhcHAvaG9zdFwiO1xuaW1wb3J0IHsgQXNzZXRNb2R1bGUsIENvbXBvbmVudE1ldGEsIFNwbGl0IH0gZnJvbSBcIkBwbGFzbWljYXBwL2xvYWRlci1jb3JlXCI7XG5pbXBvcnQgeyBQbGFzbWljUXVlcnlEYXRhUHJvdmlkZXIgfSBmcm9tIFwiQHBsYXNtaWNhcHAvcXVlcnlcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgSW50ZXJuYWxQbGFzbWljQ29tcG9uZW50TG9hZGVyIH0gZnJvbSBcIi4vbG9hZGVyLWNsaWVudFwiO1xuaW1wb3J0IHsgQ29tcG9uZW50UmVuZGVyRGF0YSwgUGxhc21pY0NvbXBvbmVudExvYWRlciB9IGZyb20gXCIuL2xvYWRlci1zaGFyZWRcIjtcbmltcG9ydCB7IE1heWJlV3JhcCwgdXNlRm9yY2VVcGRhdGUgfSBmcm9tIFwiLi91dGlsc1wiO1xuaW1wb3J0IHtcbiAgZW5zdXJlVmFyaWF0aW9uQ29va2llcyxcbiAgZ2V0R2xvYmFsVmFyaWFudHNGcm9tU3BsaXRzLFxuICBtZXJnZUdsb2JhbFZhcmlhbnRzU3BlYyxcbn0gZnJvbSBcIi4vdmFyaWF0aW9uXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGxhc21pY1Jvb3RDb250ZXh0VmFsdWUgZXh0ZW5kcyBQbGFzbWljRGF0YVNvdXJjZUNvbnRleHRWYWx1ZSB7XG4gIGdsb2JhbFZhcmlhbnRzPzogR2xvYmFsVmFyaWFudFNwZWNbXTtcbiAgZ2xvYmFsQ29udGV4dHNQcm9wcz86IFJlY29yZDxzdHJpbmcsIGFueT47XG4gIGxvYWRlcjogSW50ZXJuYWxQbGFzbWljQ29tcG9uZW50TG9hZGVyO1xuICB2YXJpYXRpb24/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICB0cmFuc2xhdG9yPzogUGxhc21pY1RyYW5zbGF0b3I7XG4gIEhlYWQ/OiBSZWFjdC5Db21wb25lbnRUeXBlPGFueT47XG4gIExpbms/OiBSZWFjdC5Db21wb25lbnRUeXBlPGFueT47XG4gIGRpc2FibGVMb2FkaW5nQm91bmRhcnk/OiBib29sZWFuO1xuICBzdXNwZW5zZUZhbGxiYWNrPzogUmVhY3QuUmVhY3ROb2RlO1xufVxuXG5jb25zdCBQbGFzbWljUm9vdENvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0PFxuICBQbGFzbWljUm9vdENvbnRleHRWYWx1ZSB8IHVuZGVmaW5lZFxuPih1bmRlZmluZWQpO1xuXG5leHBvcnQgaW50ZXJmYWNlIEdsb2JhbFZhcmlhbnRTcGVjIHtcbiAgbmFtZTogc3RyaW5nO1xuICBwcm9qZWN0SWQ/OiBzdHJpbmc7XG4gIHZhbHVlOiBhbnk7XG59XG5cbmV4cG9ydCB0eXBlIFBsYXNtaWNUcmFuc2xhdG9yID0gKFxuICBzdHI6IHN0cmluZyxcbiAgb3B0cz86IHtcbiAgICBjb21wb25lbnRzPzoge1xuICAgICAgW2tleTogc3RyaW5nXTogUmVhY3QuUmVhY3RFbGVtZW50IHwgUmVhY3QuUmVhY3RGcmFnbWVudDtcbiAgICB9O1xuICB9XG4pID0+IFJlYWN0LlJlYWN0Tm9kZTtcblxuLyoqXG4gKiBQbGFzbWljUm9vdFByb3ZpZGVyIHNob3VsZCBiZSB1c2VkIGF0IHRoZSByb290IG9mIHlvdXIgcGFnZVxuICogb3IgYXBwbGljYXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBQbGFzbWljUm9vdFByb3ZpZGVyKFxuICBwcm9wczoge1xuICAgIC8qKlxuICAgICAqIFRoZSBnbG9iYWwgUGxhc21pY0NvbXBvbmVudExvYWRlciBpbnN0YW5jZSB5b3UgY3JlYXRlZCB2aWFcbiAgICAgKiBpbml0UGxhc21pY0xvYWRlcigpLlxuICAgICAqL1xuICAgIGxvYWRlcjogUGxhc21pY0NvbXBvbmVudExvYWRlcjtcblxuICAgIC8qKlxuICAgICAqIEdsb2JhbCB2YXJpYW50cyB0byBhY3RpdmF0ZSBmb3IgUGxhc21pYyBjb21wb25lbnRzXG4gICAgICovXG4gICAgZ2xvYmFsVmFyaWFudHM/OiBHbG9iYWxWYXJpYW50U3BlY1tdO1xuXG4gICAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGU7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCB3aWxsIHNraXAgcmVuZGVyaW5nIGNzc1xuICAgICAqL1xuICAgIHNraXBDc3M/OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgd2lsbCBza2lwIGluc3RhbGxpbmcgZm9udHNcbiAgICAgKi9cbiAgICBza2lwRm9udHM/OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogSWYgeW91IGhhdmUgcHJlLWZldGNoZWQgY29tcG9uZW50IGRhdGEgdmlhIFBsYXNtaWNDb21wb25lbnRMb2FkZXIsXG4gICAgICogeW91IGNhbiBwYXNzIHRoZW0gaW4gaGVyZTsgUGxhc21pY0NvbXBvbmVudCB3aWxsIGF2b2lkIGZldGNoaW5nXG4gICAgICogY29tcG9uZW50IGRhdGEgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBwcmUtZmV0Y2hlZC5cbiAgICAgKi9cbiAgICBwcmVmZXRjaGVkRGF0YT86IENvbXBvbmVudFJlbmRlckRhdGE7XG5cbiAgICAvKipcbiAgICAgKiBJZiB5b3UgaGF2ZSBwcmUtZmV0Y2hlZCBkYXRhIHRoYXQgYXJlIG5lZWRlZCBieSB1c2VQbGFzbWljUXVlcnlEYXRhKCksXG4gICAgICogdGhlbiBwYXNzIGluIHRoZSBwcmUtZmV0Y2hlZCBjYWNoZSBoZXJlLCBtYXBwaW5nIHF1ZXJ5IGtleSB0byBmZXRjaGVkIGRhdGEuXG4gICAgICovXG4gICAgcHJlZmV0Y2hlZFF1ZXJ5RGF0YT86IFJlY29yZDxzdHJpbmcsIGFueT47XG5cbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgd2hldGhlciB1c2VQbGFzbWljUXVlcnlEYXRhKCkgc2hvdWxkIGJlIG9wZXJhdGluZyBpbiBzdXNwZW5zZSBtb2RlXG4gICAgICogKHRocm93aW5nIHByb21pc2VzKS5cbiAgICAgKi9cbiAgICBzdXNwZW5zZUZvclF1ZXJ5RGF0YT86IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB5b3VyIEdsb2JhbCBDb250ZXh0cyBQcm92aWRlciBwcm9wcy4gVGhpcyBpcyBhIG1hcCBmcm9tXG4gICAgICogZ2xvYmFsQ29udGV4dENvbXBvbmVudE5hbWVQcm9wcyB0byBvYmplY3Qgb2YgcHJvcHMgdG8gdXNlIGZvciB0aGF0XG4gICAgICogY29tcG9uZW50LlxuICAgICAqL1xuICAgIGdsb2JhbENvbnRleHRzUHJvcHM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuXG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIGEgbWFwcGluZyBvZiBzcGxpdCBpZCB0byBzbGljZSBpZCB0aGF0IHNob3VsZCBiZSBhY3RpdmF0ZWRcbiAgICAgKi9cbiAgICB2YXJpYXRpb24/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuXG4gICAgLyoqXG4gICAgICogVHJhbnNsYXRvciBmdW5jdGlvbiB0byBiZSB1c2VkIGZvciB0ZXh0IGJsb2Nrc1xuICAgICAqL1xuICAgIHRyYW5zbGF0b3I/OiBQbGFzbWljVHJhbnNsYXRvcjtcblxuICAgIC8qKlxuICAgICAqIEhlYWQgY29tcG9uZW50IHRvIHVzZSBpbiBQbGFzbWljSGVhZCBjb21wb25lbnQgKGUuZy4gSGVhZCBmcm9tIG5leHQvaGVhZFxuICAgICAqIG9yIEhlbG1ldCBmcm9tIHJlYWN0LWhlbG1ldCkuXG4gICAgICovXG4gICAgSGVhZD86IFJlYWN0LkNvbXBvbmVudFR5cGU8YW55PjtcblxuICAgIC8qKlxuICAgICAqIExpbmsgY29tcG9uZW50IHRvIHVzZS4gQ2FuIGJlIGFueSBjb21wb25lbnQgdGhhdCB0YWtlcyBpbiBwcm9wcyBwYXNzZWRcbiAgICAgKiB0byBhbiA8YS8+IHRhZy5cbiAgICAgKi9cbiAgICBMaW5rPzogUmVhY3QuQ29tcG9uZW50VHlwZTxhbnk+O1xuXG4gICAgLyoqXG4gICAgICogUGFnZSByb3V0ZSB3aXRob3V0IHBhcmFtcyBzdWJzdGl0dXRpb24gKGUuZy4gL3Byb2R1Y3RzL1tzbHVnXSkuXG4gICAgICovXG4gICAgcGFnZVJvdXRlPzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogUGFnZSBwYXRoIHBhcmFtZXRlcnMgKGUuZy4ge3NsdWc6IFwiZm9vXCJ9IGlmIHBhZ2UgcGF0aCBpc1xuICAgICAqIC9wcm9kdWN0cy9bc2x1Z10gYW5kIFVSSSBpcyAvcHJvZHVjdHMvZm9vKS5cbiAgICAgKi9cbiAgICBwYWdlUGFyYW1zPzogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgc3RyaW5nW10gfCB1bmRlZmluZWQ+O1xuXG4gICAgLyoqXG4gICAgICogUGFnZSBxdWVyeSBwYXJhbWV0ZXJzIChlLmcuIHtxOiBcImZvb1wifSBpZiBwYWdlIHBhdGggaXNcbiAgICAgKiAvc29tZS9wYXRoP3E9Zm9vKS5cbiAgICAgKi9cbiAgICBwYWdlUXVlcnk/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBzdHJpbmdbXSB8IHVuZGVmaW5lZD47XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgaW50ZXJuYWwgUGxhc21pYyBSZWFjdC5TdXNwZW5zZSBib3VuZGFyaWVzIHNob3VsZCBiZSByZW1vdmVkXG4gICAgICovXG4gICAgZGlzYWJsZUxvYWRpbmdCb3VuZGFyeT86IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgcm9vdCBSZWFjdC5TdXNwZW5zZSBib3VuZGFyeSBzaG91bGQgYmUgcmVtb3ZlZFxuICAgICAqL1xuICAgIGRpc2FibGVSb290TG9hZGluZ0JvdW5kYXJ5PzogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBGYWxsYmFjayB2YWx1ZSBmb3IgUmVhY3QuU3VzcGVuc2UgYm91bmRhcnlcbiAgICAgKi9cbiAgICBzdXNwZW5zZUZhbGxiYWNrPzogUmVhY3QuUmVhY3ROb2RlO1xuICB9ICYgUGxhc21pY0RhdGFTb3VyY2VDb250ZXh0VmFsdWVcbikge1xuICBjb25zdCB7XG4gICAgZ2xvYmFsVmFyaWFudHMsXG4gICAgcHJlZmV0Y2hlZERhdGEsXG4gICAgY2hpbGRyZW4sXG4gICAgc2tpcENzcyxcbiAgICBza2lwRm9udHMsXG4gICAgcHJlZmV0Y2hlZFF1ZXJ5RGF0YSxcbiAgICBzdXNwZW5zZUZvclF1ZXJ5RGF0YSxcbiAgICBnbG9iYWxDb250ZXh0c1Byb3BzLFxuICAgIHZhcmlhdGlvbixcbiAgICB0cmFuc2xhdG9yLFxuICAgIEhlYWQsXG4gICAgTGluayxcbiAgICBwYWdlUm91dGUsXG4gICAgcGFnZVBhcmFtcyxcbiAgICBwYWdlUXVlcnksXG4gICAgc3VzcGVuc2VGYWxsYmFjayxcbiAgICBkaXNhYmxlTG9hZGluZ0JvdW5kYXJ5LFxuICAgIGRpc2FibGVSb290TG9hZGluZ0JvdW5kYXJ5LFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGxvYWRlciA9IChwcm9wcy5sb2FkZXIgYXMgYW55KVxuICAgIC5fX2ludGVybmFsIGFzIEludGVybmFsUGxhc21pY0NvbXBvbmVudExvYWRlcjtcblxuICBpZiAocHJlZmV0Y2hlZERhdGEpIHtcbiAgICBsb2FkZXIucmVnaXN0ZXJQcmVmZXRjaGVkQnVuZGxlKHByZWZldGNoZWREYXRhLmJ1bmRsZSk7XG4gIH1cblxuICBjb25zdCBbc3BsaXRzLCBzZXRTcGxpdHNdID0gUmVhY3QudXNlU3RhdGU8U3BsaXRbXT4obG9hZGVyLmdldEFjdGl2ZVNwbGl0cygpKTtcbiAgY29uc3QgZm9yY2VVcGRhdGUgPSB1c2VGb3JjZVVwZGF0ZSgpO1xuICBjb25zdCB3YXRjaGVyID0gUmVhY3QudXNlTWVtbyhcbiAgICAoKSA9PiAoe1xuICAgICAgb25EYXRhRmV0Y2hlZDogKCkgPT4ge1xuICAgICAgICBzZXRTcGxpdHMobG9hZGVyLmdldEFjdGl2ZVNwbGl0cygpKTtcbiAgICAgICAgZm9yY2VVcGRhdGUoKTtcbiAgICAgIH0sXG4gICAgfSksXG4gICAgW2xvYWRlciwgZm9yY2VVcGRhdGVdXG4gICk7XG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBsb2FkZXIuc3Vic2NyaWJlUGxhc21pY1Jvb3Qod2F0Y2hlcik7XG4gICAgcmV0dXJuICgpID0+IGxvYWRlci51bnN1YnNjcmliZVBsYXNtaWNSb290KHdhdGNoZXIpO1xuICB9LCBbd2F0Y2hlciwgbG9hZGVyXSk7XG5cbiAgY29uc3QgY3VycmVudENvbnRleHRWYWx1ZSA9IFJlYWN0LnVzZUNvbnRleHQoUGxhc21pY1Jvb3RDb250ZXh0KTtcblxuICBjb25zdCB7IHVzZXIsIHVzZXJBdXRoVG9rZW4sIGlzVXNlckxvYWRpbmcsIGF1dGhSZWRpcmVjdFVyaSB9ID0gcHJvcHM7XG5cbiAgY29uc3QgdmFsdWUgPSBSZWFjdC51c2VNZW1vPFBsYXNtaWNSb290Q29udGV4dFZhbHVlPigoKSA9PiB7XG4gICAgLy8gRmFsbGJhY2sgdG8gdGhlIHZhbHVlIGluIGBjdXJyZW50Q29udGV4dFZhbHVlYCBpZiBub25lIGlzIHByb3ZpZGVkXG4gICAgY29uc3Qgd2l0aEN1cnJlbnRDb250ZXh0VmFsdWVGYWxsYmFjayA9IDxcbiAgICAgIEsgZXh0ZW5kcyBrZXlvZiBQbGFzbWljUm9vdENvbnRleHRWYWx1ZVxuICAgID4oXG4gICAgICB2OiBQbGFzbWljUm9vdENvbnRleHRWYWx1ZVtLXSxcbiAgICAgIGtleTogS1xuICAgICk6IFBsYXNtaWNSb290Q29udGV4dFZhbHVlW0tdID0+IHtcbiAgICAgIHJldHVybiAodiAhPT0gdW5kZWZpbmVkID8gdiA6IGN1cnJlbnRDb250ZXh0VmFsdWU/LltrZXldKSE7XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgZ2xvYmFsVmFyaWFudHM6IFtcbiAgICAgICAgLi4ubWVyZ2VHbG9iYWxWYXJpYW50c1NwZWMoXG4gICAgICAgICAgZ2xvYmFsVmFyaWFudHMgPz8gW10sXG4gICAgICAgICAgZ2V0R2xvYmFsVmFyaWFudHNGcm9tU3BsaXRzKHNwbGl0cywgdmFyaWF0aW9uID8/IHt9KVxuICAgICAgICApLFxuICAgICAgICAuLi4oY3VycmVudENvbnRleHRWYWx1ZT8uZ2xvYmFsVmFyaWFudHMgPz8gW10pLFxuICAgICAgXSxcbiAgICAgIGdsb2JhbENvbnRleHRzUHJvcHM6IHtcbiAgICAgICAgLi4uKGN1cnJlbnRDb250ZXh0VmFsdWU/Lmdsb2JhbENvbnRleHRzUHJvcHMgPz8ge30pLFxuICAgICAgICAuLi4oZ2xvYmFsQ29udGV4dHNQcm9wcyA/PyB7fSksXG4gICAgICB9LFxuICAgICAgbG9hZGVyOiB3aXRoQ3VycmVudENvbnRleHRWYWx1ZUZhbGxiYWNrKGxvYWRlciwgXCJsb2FkZXJcIiksXG4gICAgICB2YXJpYXRpb246IHtcbiAgICAgICAgLi4uKGN1cnJlbnRDb250ZXh0VmFsdWU/LnZhcmlhdGlvbiA/PyB7fSksXG4gICAgICAgIC4uLih2YXJpYXRpb24gPz8ge30pLFxuICAgICAgfSxcbiAgICAgIHRyYW5zbGF0b3I6IHdpdGhDdXJyZW50Q29udGV4dFZhbHVlRmFsbGJhY2sodHJhbnNsYXRvciwgXCJ0cmFuc2xhdG9yXCIpLFxuICAgICAgSGVhZDogd2l0aEN1cnJlbnRDb250ZXh0VmFsdWVGYWxsYmFjayhIZWFkLCBcIkhlYWRcIiksXG4gICAgICBMaW5rOiB3aXRoQ3VycmVudENvbnRleHRWYWx1ZUZhbGxiYWNrKExpbmssIFwiTGlua1wiKSxcbiAgICAgIHVzZXI6IHdpdGhDdXJyZW50Q29udGV4dFZhbHVlRmFsbGJhY2sodXNlciwgXCJ1c2VyXCIpLFxuICAgICAgdXNlckF1dGhUb2tlbjogd2l0aEN1cnJlbnRDb250ZXh0VmFsdWVGYWxsYmFjayhcbiAgICAgICAgdXNlckF1dGhUb2tlbixcbiAgICAgICAgXCJ1c2VyQXV0aFRva2VuXCJcbiAgICAgICksXG4gICAgICBpc1VzZXJMb2FkaW5nOiB3aXRoQ3VycmVudENvbnRleHRWYWx1ZUZhbGxiYWNrKFxuICAgICAgICBpc1VzZXJMb2FkaW5nLFxuICAgICAgICBcImlzVXNlckxvYWRpbmdcIlxuICAgICAgKSxcbiAgICAgIGF1dGhSZWRpcmVjdFVyaTogd2l0aEN1cnJlbnRDb250ZXh0VmFsdWVGYWxsYmFjayhcbiAgICAgICAgYXV0aFJlZGlyZWN0VXJpLFxuICAgICAgICBcImF1dGhSZWRpcmVjdFVyaVwiXG4gICAgICApLFxuICAgICAgc3VzcGVuc2VGYWxsYmFjazogd2l0aEN1cnJlbnRDb250ZXh0VmFsdWVGYWxsYmFjayhcbiAgICAgICAgc3VzcGVuc2VGYWxsYmFjayxcbiAgICAgICAgXCJzdXNwZW5zZUZhbGxiYWNrXCJcbiAgICAgICksXG4gICAgICBkaXNhYmxlTG9hZGluZ0JvdW5kYXJ5OiB3aXRoQ3VycmVudENvbnRleHRWYWx1ZUZhbGxiYWNrKFxuICAgICAgICBkaXNhYmxlTG9hZGluZ0JvdW5kYXJ5LFxuICAgICAgICBcImRpc2FibGVMb2FkaW5nQm91bmRhcnlcIlxuICAgICAgKSxcbiAgICB9O1xuICB9LCBbXG4gICAgZ2xvYmFsVmFyaWFudHMsXG4gICAgdmFyaWF0aW9uLFxuICAgIGdsb2JhbENvbnRleHRzUHJvcHMsXG4gICAgbG9hZGVyLFxuICAgIHNwbGl0cyxcbiAgICB0cmFuc2xhdG9yLFxuICAgIEhlYWQsXG4gICAgTGluayxcbiAgICB1c2VyLFxuICAgIHVzZXJBdXRoVG9rZW4sXG4gICAgaXNVc2VyTG9hZGluZyxcbiAgICBhdXRoUmVkaXJlY3RVcmksXG4gICAgc3VzcGVuc2VGYWxsYmFjayxcbiAgICBkaXNhYmxlTG9hZGluZ0JvdW5kYXJ5LFxuICAgIGN1cnJlbnRDb250ZXh0VmFsdWUsXG4gIF0pO1xuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgZW5zdXJlVmFyaWF0aW9uQ29va2llcyh2YXJpYXRpb24pO1xuICAgIGxvYWRlci50cmFja1JlbmRlcih7XG4gICAgICByZW5kZXJDdHg6IHtcbiAgICAgICAgLy8gV2UgdHJhY2sgdGhlIHByb3ZpZGVyIGFzIGEgc2luZ2xlIGVudGl0eVxuICAgICAgICByb290Q29tcG9uZW50SWQ6IFwicHJvdmlkZXJcIixcbiAgICAgICAgdGVhbUlkczogbG9hZGVyLmdldFRlYW1JZHMoKSxcbiAgICAgICAgcHJvamVjdElkczogbG9hZGVyLmdldFByb2plY3RJZHMoKSxcbiAgICAgIH0sXG4gICAgICB2YXJpYXRpb246IHZhbHVlLnZhcmlhdGlvbixcbiAgICB9KTtcbiAgfSwgW2xvYWRlciwgdmFsdWVdKTtcblxuICBjb25zdCByZWFjdE1ham9yVmVyc2lvbiA9ICtSZWFjdC52ZXJzaW9uLnNwbGl0KFwiLlwiKVswXTtcblxuICBjb25zdCBzaG91bGREaXNhYmxlUm9vdExvYWRpbmdCb3VuZGFyeSA9XG4gICAgZGlzYWJsZVJvb3RMb2FkaW5nQm91bmRhcnkgPz9cbiAgICBsb2FkZXIuZ2V0QnVuZGxlKCkuZGlzYWJsZVJvb3RMb2FkaW5nQm91bmRhcnlCeURlZmF1bHQ7XG5cbiAgcmV0dXJuIChcbiAgICA8UGxhc21pY1F1ZXJ5RGF0YVByb3ZpZGVyXG4gICAgICBwcmVmZXRjaGVkQ2FjaGU9e3ByZWZldGNoZWRRdWVyeURhdGF9XG4gICAgICBzdXNwZW5zZT17c3VzcGVuc2VGb3JRdWVyeURhdGF9XG4gICAgPlxuICAgICAgPFBsYXNtaWNSb290Q29udGV4dC5Qcm92aWRlciB2YWx1ZT17dmFsdWV9PlxuICAgICAgICB7IXNraXBDc3MgJiYgKFxuICAgICAgICAgIDxQbGFzbWljQ3NzXG4gICAgICAgICAgICBsb2FkZXI9e2xvYWRlcn1cbiAgICAgICAgICAgIHByZWZldGNoZWREYXRhPXtwcmVmZXRjaGVkRGF0YX1cbiAgICAgICAgICAgIHNraXBGb250cz17c2tpcEZvbnRzfVxuICAgICAgICAgIC8+XG4gICAgICAgICl9XG4gICAgICAgIDxQYWdlUGFyYW1zUHJvdmlkZXJcbiAgICAgICAgICByb3V0ZT17cGFnZVJvdXRlfVxuICAgICAgICAgIHBhcmFtcz17cGFnZVBhcmFtc31cbiAgICAgICAgICBxdWVyeT17cGFnZVF1ZXJ5fVxuICAgICAgICA+XG4gICAgICAgICAgPE1heWJlV3JhcFxuICAgICAgICAgICAgY29uZD17IXNob3VsZERpc2FibGVSb290TG9hZGluZ0JvdW5kYXJ5ICYmIHJlYWN0TWFqb3JWZXJzaW9uID49IDE4fVxuICAgICAgICAgICAgd3JhcHBlcj17KGNvbnRlbnRzKSA9PiAoXG4gICAgICAgICAgICAgIDxSZWFjdC5TdXNwZW5zZSBmYWxsYmFjaz17c3VzcGVuc2VGYWxsYmFjayA/PyBcIkxvYWRpbmcuLi5cIn0+XG4gICAgICAgICAgICAgICAge2NvbnRlbnRzfVxuICAgICAgICAgICAgICA8L1JlYWN0LlN1c3BlbnNlPlxuICAgICAgICAgICAgKX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgICAgPC9NYXliZVdyYXA+XG4gICAgICAgIDwvUGFnZVBhcmFtc1Byb3ZpZGVyPlxuICAgICAgPC9QbGFzbWljUm9vdENvbnRleHQuUHJvdmlkZXI+XG4gICAgPC9QbGFzbWljUXVlcnlEYXRhUHJvdmlkZXI+XG4gICk7XG59XG5cbi8qKlxuICogSW5qZWN0IGFsbCBjc3MgbW9kdWxlcyBhcyA8c3R5bGUvPiB0YWdzLiBXZSBjYW4ndCB1c2UgdGhlIHVzdWFsIHN0eWxlSW5qZWN0b3IgcG9zdGNzc1xuICogdXNlcyBiZWNhdXNlIHRoYXQgZG9lc24ndCB3b3JrIG9uIHRoZSBzZXJ2ZXIgc2lkZSBmb3IgU1NSLlxuICovXG5jb25zdCBQbGFzbWljQ3NzID0gUmVhY3QubWVtbyhmdW5jdGlvbiBQbGFzbWljQ3NzKHByb3BzOiB7XG4gIGxvYWRlcjogSW50ZXJuYWxQbGFzbWljQ29tcG9uZW50TG9hZGVyO1xuICBwcmVmZXRjaGVkRGF0YT86IENvbXBvbmVudFJlbmRlckRhdGE7XG4gIHNraXBGb250cz86IGJvb2xlYW47XG59KSB7XG4gIGNvbnN0IHsgbG9hZGVyLCBwcmVmZXRjaGVkRGF0YSwgc2tpcEZvbnRzIH0gPSBwcm9wcztcbiAgY29uc3QgW3VzZVNjb3BlZENzcywgc2V0VXNlU2NvcGVkQ3NzXSA9IFJlYWN0LnVzZVN0YXRlKCEhcHJlZmV0Y2hlZERhdGEpO1xuICBjb25zdCBidWlsdENzcyA9IGJ1aWxkQ3NzKGxvYWRlciwge1xuICAgIHNjb3BlZENvbXBNZXRhczpcbiAgICAgIHVzZVNjb3BlZENzcyAmJiBwcmVmZXRjaGVkRGF0YVxuICAgICAgICA/IHByZWZldGNoZWREYXRhLmJ1bmRsZS5jb21wb25lbnRzXG4gICAgICAgIDogdW5kZWZpbmVkLFxuICAgIHNraXBGb250cyxcbiAgfSk7XG4gIGNvbnN0IGZvcmNlVXBkYXRlID0gdXNlRm9yY2VVcGRhdGUoKTtcbiAgY29uc3Qgd2F0Y2hlciA9IFJlYWN0LnVzZU1lbW8oXG4gICAgKCkgPT4gKHtcbiAgICAgIG9uRGF0YUZldGNoZWQ6ICgpID0+IHtcbiAgICAgICAgLy8gSWYgbmV3IGRhdGEgaGFzIGJlZW4gZmV0Y2hlZCwgdGhlbiB1c2UgYWxsIHRoZSBmZXRjaGVkIGNzc1xuICAgICAgICBzZXRVc2VTY29wZWRDc3MoZmFsc2UpO1xuICAgICAgICBmb3JjZVVwZGF0ZSgpO1xuICAgICAgfSxcbiAgICB9KSxcbiAgICBbbG9hZGVyLCBmb3JjZVVwZGF0ZV1cbiAgKTtcblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxvYWRlci5zdWJzY3JpYmVQbGFzbWljUm9vdCh3YXRjaGVyKTtcbiAgICByZXR1cm4gKCkgPT4gbG9hZGVyLnVuc3Vic2NyaWJlUGxhc21pY1Jvb3Qod2F0Y2hlcik7XG4gIH0sIFt3YXRjaGVyLCBsb2FkZXJdKTtcblxuICByZXR1cm4gPHN0eWxlIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MPXt7IF9faHRtbDogYnVpbHRDc3MgfX0gLz47XG59KTtcblxuZnVuY3Rpb24gYnVpbGRDc3MoXG4gIGxvYWRlcjogSW50ZXJuYWxQbGFzbWljQ29tcG9uZW50TG9hZGVyLFxuICBvcHRzOiB7XG4gICAgc2NvcGVkQ29tcE1ldGFzPzogQ29tcG9uZW50TWV0YVtdO1xuICAgIHNraXBGb250cz86IGJvb2xlYW47XG4gIH1cbikge1xuICBjb25zdCB7IHNjb3BlZENvbXBNZXRhcywgc2tpcEZvbnRzIH0gPSBvcHRzO1xuICBjb25zdCBjc3NGaWxlcyA9XG4gICAgc2NvcGVkQ29tcE1ldGFzICYmXG4gICAgbmV3IFNldDxzdHJpbmc+KFtcbiAgICAgIFwiZW50cnlwb2ludC5jc3NcIixcbiAgICAgIC4uLnNjb3BlZENvbXBNZXRhcy5tYXAoKGMpID0+IGMuY3NzRmlsZSksXG4gICAgXSk7XG4gIGNvbnN0IGNzc01vZHVsZXMgPSBsb2FkZXJcbiAgICAuZ2V0TG9va3VwKClcbiAgICAuZ2V0Q3NzKClcbiAgICAuZmlsdGVyKChmKSA9PiAhY3NzRmlsZXMgfHwgY3NzRmlsZXMuaGFzKGYuZmlsZU5hbWUpKTtcblxuICBjb25zdCBnZXRQcmkgPSAoZmlsZU5hbWU6IHN0cmluZykgPT4gKGZpbGVOYW1lID09PSBcImVudHJ5cG9pbnQuY3NzXCIgPyAwIDogMSk7XG4gIGNvbnN0IGNvbXBhcmVNb2R1bGVzID0gKGE6IEFzc2V0TW9kdWxlLCBiOiBBc3NldE1vZHVsZSkgPT5cbiAgICBnZXRQcmkoYS5maWxlTmFtZSkgIT09IGdldFByaShiLmZpbGVOYW1lKVxuICAgICAgPyBnZXRQcmkoYS5maWxlTmFtZSkgLSBnZXRQcmkoYi5maWxlTmFtZSlcbiAgICAgIDogYS5maWxlTmFtZS5sb2NhbGVDb21wYXJlKGIuZmlsZU5hbWUpO1xuICBjc3NNb2R1bGVzLnNvcnQoY29tcGFyZU1vZHVsZXMpO1xuXG4gIGNvbnN0IHJlbW90ZUZvbnRzID0gbG9hZGVyLmdldExvb2t1cCgpLmdldFJlbW90ZUZvbnRzKCk7XG5cbiAgLy8gTWFrZSBzdXJlIHRoZSBAaW1wb3J0IHN0YXRlbWVudHMgY29tZSBhdCB0aGUgZnJvbnQgb2YgY3NzXG4gIHJldHVybiBgXG4gICAgJHtcbiAgICAgIHNraXBGb250c1xuICAgICAgICA/IFwiXCJcbiAgICAgICAgOiByZW1vdGVGb250cy5tYXAoKGYpID0+IGBAaW1wb3J0IHVybCgnJHtmLnVybH0nKTtgKS5qb2luKFwiXFxuXCIpXG4gICAgfVxuICAgICR7Y3NzTW9kdWxlcy5tYXAoKG1vZCkgPT4gbW9kLnNvdXJjZSkuam9pbihcIlxcblwiKX1cbiAgYDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVBsYXNtaWNSb290Q29udGV4dCgpIHtcbiAgcmV0dXJuIFJlYWN0LnVzZUNvbnRleHQoUGxhc21pY1Jvb3RDb250ZXh0KTtcbn1cbiIsImltcG9ydCB7IENvbXBvbmVudE1ldGEgfSBmcm9tIFwiQHBsYXNtaWNhcHAvbG9hZGVyLWNvcmVcIjtcbmltcG9ydCBwYXNjYWxjYXNlIGZyb20gXCJwYXNjYWxjYXNlXCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcblxuZXhwb3J0IGNvbnN0IGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCI7XG5cbmV4cG9ydCB0eXBlIENvbXBvbmVudExvb2t1cFNwZWMgPVxuICB8IHN0cmluZ1xuICB8IHsgbmFtZTogc3RyaW5nOyBwcm9qZWN0SWQ/OiBzdHJpbmc7IGlzQ29kZT86IGJvb2xlYW4gfTtcblxuaW50ZXJmYWNlIEZ1bGxOYW1lTG9va3VwU3BlYyB7XG4gIG5hbWU6IHN0cmluZztcbiAgcmF3TmFtZT86IHN0cmluZztcbiAgcHJvamVjdElkPzogc3RyaW5nO1xuICBpc0NvZGU/OiBib29sZWFuO1xufVxuXG5pbnRlcmZhY2UgRnVsbFBhdGhMb29rdXBTcGVjIHtcbiAgcGF0aDogc3RyaW5nO1xuICBwcm9qZWN0SWQ/OiBzdHJpbmc7XG59XG5cbnR5cGUgRnVsbExvb2t1cFNwZWMgPSBGdWxsTmFtZUxvb2t1cFNwZWMgfCBGdWxsUGF0aExvb2t1cFNwZWM7XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VGb3JjZVVwZGF0ZSgpIHtcbiAgY29uc3QgWywgc2V0VGlja10gPSBSZWFjdC51c2VTdGF0ZSgwKTtcbiAgY29uc3QgdXBkYXRlID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHNldFRpY2soKHRpY2spID0+IHRpY2sgKyAxKTtcbiAgfSwgW10pO1xuICByZXR1cm4gdXBkYXRlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlU3RhYmxlTG9va3VwU3BlYyhzcGVjOiBDb21wb25lbnRMb29rdXBTcGVjKSB7XG4gIHJldHVybiB1c2VTdGFibGVMb29rdXBTcGVjcyhzcGVjKVswXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVN0YWJsZUxvb2t1cFNwZWNzKC4uLnNwZWNzOiBDb21wb25lbnRMb29rdXBTcGVjW10pIHtcbiAgY29uc3QgW3N0YWJsZVNwZWNzLCBzZXRTdGFibGVTcGVjc10gPSBSZWFjdC51c2VTdGF0ZShzcGVjcyk7XG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoXG4gICAgICBzcGVjcy5sZW5ndGggIT09IHN0YWJsZVNwZWNzLmxlbmd0aCB8fFxuICAgICAgc3BlY3Muc29tZSgocywgaSkgPT4gIWFyZUxvb2t1cFNwZWNzRXF1YWwocywgc3RhYmxlU3BlY3NbaV0pKVxuICAgICkge1xuICAgICAgc2V0U3RhYmxlU3BlY3Moc3BlY3MpO1xuICAgIH1cbiAgfSwgW3NwZWNzLCBzdGFibGVTcGVjc10pO1xuICByZXR1cm4gc3RhYmxlU3BlY3M7XG59XG5cbmZ1bmN0aW9uIGFyZUxvb2t1cFNwZWNzRXF1YWwoXG4gIHNwZWMxOiBDb21wb25lbnRMb29rdXBTcGVjLFxuICBzcGVjMjogQ29tcG9uZW50TG9va3VwU3BlY1xuKSB7XG4gIGlmIChzcGVjMSA9PT0gc3BlYzIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodHlwZW9mIHNwZWMxICE9PSB0eXBlb2Ygc3BlYzIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBmdWxsU3BlYzEgPSB0b0Z1bGxMb29rdXAoc3BlYzEpO1xuICBjb25zdCBmdWxsU3BlYzIgPSB0b0Z1bGxMb29rdXAoc3BlYzIpO1xuICByZXR1cm4gKFxuICAgICgoaXNOYW1lU3BlYyhmdWxsU3BlYzEpICYmXG4gICAgICBpc05hbWVTcGVjKGZ1bGxTcGVjMikgJiZcbiAgICAgIGZ1bGxTcGVjMS5uYW1lID09PSBmdWxsU3BlYzIubmFtZSAmJlxuICAgICAgZnVsbFNwZWMxLmlzQ29kZSA9PT0gZnVsbFNwZWMyLmlzQ29kZSkgfHxcbiAgICAgIChpc1BhdGhTcGVjKGZ1bGxTcGVjMSkgJiZcbiAgICAgICAgaXNQYXRoU3BlYyhmdWxsU3BlYzIpICYmXG4gICAgICAgIGZ1bGxTcGVjMS5wYXRoID09PSBmdWxsU3BlYzIucGF0aCkpICYmXG4gICAgZnVsbFNwZWMxLnByb2plY3RJZCA9PT0gZnVsbFNwZWMyLnByb2plY3RJZFxuICApO1xufVxuXG5mdW5jdGlvbiBpc05hbWVTcGVjKGxvb2t1cDogRnVsbExvb2t1cFNwZWMpOiBsb29rdXAgaXMgRnVsbE5hbWVMb29rdXBTcGVjIHtcbiAgcmV0dXJuIFwibmFtZVwiIGluIGxvb2t1cDtcbn1cblxuZnVuY3Rpb24gaXNQYXRoU3BlYyhsb29rdXA6IEZ1bGxMb29rdXBTcGVjKTogbG9va3VwIGlzIEZ1bGxQYXRoTG9va3VwU3BlYyB7XG4gIHJldHVybiBcInBhdGhcIiBpbiBsb29rdXA7XG59XG5cbmZ1bmN0aW9uIHRvRnVsbExvb2t1cChsb29rdXA6IENvbXBvbmVudExvb2t1cFNwZWMpOiBGdWxsTG9va3VwU3BlYyB7XG4gIGNvbnN0IG5hbWVQYXJ0ID0gdHlwZW9mIGxvb2t1cCA9PT0gXCJzdHJpbmdcIiA/IGxvb2t1cCA6IGxvb2t1cC5uYW1lO1xuICBjb25zdCBwcm9qZWN0SWQgPSB0eXBlb2YgbG9va3VwID09PSBcInN0cmluZ1wiID8gdW5kZWZpbmVkIDogbG9va3VwLnByb2plY3RJZDtcbiAgY29uc3QgY29kZUNvbXBvbmVudCA9IHR5cGVvZiBsb29rdXAgPT09IFwic3RyaW5nXCIgPyB1bmRlZmluZWQgOiBsb29rdXAuaXNDb2RlO1xuXG4gIGlmIChjb2RlQ29tcG9uZW50ICE9PSB0cnVlICYmIG5hbWVQYXJ0LnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgcmV0dXJuIHsgcGF0aDogbm9ybWFsaXplUGF0aChuYW1lUGFydCksIHByb2plY3RJZCB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBjb2RlQ29tcG9uZW50ID8gbmFtZVBhcnQgOiBub3JtYWxpemVOYW1lKG5hbWVQYXJ0KSxcbiAgICAgIHJhd05hbWU6IG5hbWVQYXJ0LnRyaW0oKSxcbiAgICAgIHByb2plY3RJZCxcbiAgICAgIGlzQ29kZTogY29kZUNvbXBvbmVudCxcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVBhdGgocGF0aDogc3RyaW5nKSB7XG4gIHJldHVybiBwYXRoLnRyaW0oKTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplTmFtZShuYW1lOiBzdHJpbmcpIHtcbiAgLy8gTm90IGEgZnVsbCBub3JtYWxpemF0aW9uLCBidXQgc2hvdWxkIGJlIGdvb2QgZW5vdWdoXG4gIHJldHVybiBwYXNjYWxjYXNlKG5hbWUpLnRyaW0oKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUlzTW91bnRlZCgpOiAoKSA9PiBib29sZWFuIHtcbiAgY29uc3QgcmVmID0gUmVhY3QudXNlUmVmPGJvb2xlYW4+KGZhbHNlKTtcbiAgY29uc3QgaXNNb3VudGVkID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4gcmVmLmN1cnJlbnQsIFtdKTtcblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9O1xuICB9LCBbXSk7XG5cbiAgcmV0dXJuIGlzTW91bnRlZDtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBgbG9va3VwYCByZXNvbHZlcyB0byBgcGFnZVBhdGhgLiBJZiBpdCdzIGEgbWF0Y2gsIHJldHVybiBhbiBvYmplY3RcbiAqIGNvbnRhaW5pbmcgcGF0aCBwYXJhbXM7IG90aGVyd2lzZSwgcmV0dXJuIGZhbHNlLlxuICpcbiAqIEZvciBleGFtcGxlLFxuICogLSBgbWF0Y2hlc1BhZ2VQYXRoKFwiL2hlbGxvL1tuYW1lXVwiLCBcIi9oZWxsby93b3JsZFwiKWAgLT4gYHtwYXJhbXM6IHtuYW1lOlxuICogICBcIndvcmxkXCJ9fWBcbiAqIC0gYG1hdGNoZXNQYWdlUGF0aChcIi9oZWxsby9bbmFtZV1cIiwgXCIvXCIpYCAtPiBgZmFsc2VgXG4gKiAtIGBtYXRjaGVzUGFnZVBhdGgoXCIvaGVsbG8vWy4uLmNhdGNoYWxsXVwiLCBcIi9oZWxsby9hL2IvY1wiKWAgLT4gYHtwYXJhbXM6IHtjYXRjaGFsbDogW1wiYVwiLCBcImJcIiwgXCJjXCJdfX1gXG4gKiAtIGBtYXRjaGVzUGFnZVBhdGgoXCIvaGVsbG8vW1suLi5jYXRjaGFsbF1dXCIsIFwiL2hlbGxvL1wiKWAgLT4gYHtwYXJhbXM6IHtjYXRjaGFsbDogW119fWBcbiAqIC0gYG1hdGNoZXNQYWdlUGF0aChcIi9cIiwgXCJcIilgIC0+IGB7cGFyYW1zOiB7fX1gXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXRjaGVzUGFnZVBhdGgocGF0dGVybjogc3RyaW5nLCBwYXRoOiBzdHJpbmcpIHtcbiAgLy8gKGdlbmVyYXRlZCBieSBDaGF0R1BUIDQgZnJvbSB0aGUgdGVzdCBjYXNlcylcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGggYW5kIHBhdHRlcm4gYnkgZW5zdXJpbmcgdGhleSBib3RoIHN0YXJ0IGFuZCBlbmQgd2l0aG91dCBzbGFzaGVzXG4gIGNvbnN0IG5vcm1hbGl6ZWRQYXR0ZXJuID0gXCIvXCIgKyBwYXR0ZXJuLnJlcGxhY2UoL15cXC98XFwvJC9nLCBcIlwiKTtcbiAgY29uc3Qgbm9ybWFsaXplZFBhdGggPSBcIi9cIiArIHBhdGgucmVwbGFjZSgvXlxcL3xcXC8kL2csIFwiXCIpO1xuXG4gIC8vIE1vZGlmeSB0aGUgcmVnZXggdG8gbWF0Y2ggb3B0aW9uYWwgbGVhZGluZyBzbGFzaGVzXG4gIGNvbnN0IHJlZ2V4U3RyaW5nID0gbm9ybWFsaXplZFBhdHRlcm5cbiAgICAucmVwbGFjZSgvXFwvXFxbXFxbXFwuXFwuXFwuKFteXFxdXl0rKV1dL2csIFwiKD86LyhbXl0qKSk/XCIpIC8vIE9wdGlvbmFsIGNhdGNoLWFsbFxuICAgIC5yZXBsYWNlKC9cXC9cXFtcXC5cXC5cXC4oW15cXF1eXSspXS9nLCBcIi8oW15dKilcIikgLy8gQ2F0Y2gtYWxsXG4gICAgLnJlcGxhY2UoL1xcWyhbXlxcXV5dKyldL2csIFwiKFteL10rKVwiKSAvLyBOb3JtYWwgc2x1Z1xuICAgIC5yZXBsYWNlKC9cXC8vZywgXCJcXFxcL1wiKTsgLy8gRXNjYXBlIGZvcndhcmQgc2xhc2hlc1xuXG4gIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChgXi8/JHtyZWdleFN0cmluZ30kYCk7IC8vIEFsbG93IG9wdGlvbmFsIGxlYWRpbmcgc2xhc2hcbiAgY29uc3QgbWF0Y2ggPSBub3JtYWxpemVkUGF0aC5tYXRjaChyZWdleCk7XG5cbiAgaWYgKCFtYXRjaCkgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIEV4dHJhY3Qgc2x1ZyBuYW1lcyBmcm9tIHBhdHRlcm5cbiAgY29uc3Qgc2x1Z05hbWVzID0gWy4uLnBhdHRlcm4ubWF0Y2hBbGwoL1xcW1xcLj9cXC4/XFwuPyhbXltcXF1dKyldL2cpXS5tYXAoXG4gICAgKG0pID0+IG1bMV1cbiAgKTtcblxuICAvLyBDb25zdHJ1Y3QgcGFyYW1zIG9iamVjdFxuICBjb25zdCBwYXJhbXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IHN0cmluZ1tdPiA9IHt9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNsdWdOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNsdWdOYW1lID0gc2x1Z05hbWVzW2ldO1xuICAgIGNvbnN0IHZhbHVlID0gbWF0Y2hbaSArIDFdO1xuXG4gICAgaWYgKHBhdHRlcm4uaW5jbHVkZXMoYFtbLi4uJHtzbHVnTmFtZX1dXWApKSB7XG4gICAgICAvLyBIYW5kbGUgb3B0aW9uYWwgY2F0Y2hhbGwgc2x1Z3NcbiAgICAgIHBhcmFtc1tzbHVnTmFtZV0gPSB2YWx1ZSA/IHZhbHVlLnNwbGl0KFwiL1wiKS5maWx0ZXIoQm9vbGVhbikgOiBbXTtcbiAgICB9IGVsc2UgaWYgKHBhdHRlcm4uaW5jbHVkZXMoYFsuLi4ke3NsdWdOYW1lfV1gKSkge1xuICAgICAgLy8gSGFuZGxlIG1hbmRhdG9yeSBjYXRjaGFsbCBzbHVnc1xuICAgICAgcGFyYW1zW3NsdWdOYW1lXSA9IHZhbHVlLnNwbGl0KFwiL1wiKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBIYW5kbGUgbm9ybWFsIHNsdWdzXG4gICAgICBwYXJhbXNbc2x1Z05hbWVdID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHsgcGFyYW1zIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0R5bmFtaWNQYWdlUGF0aChwYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuICEhcGF0aC5tYXRjaCgvXFxbW14vXSpcXF0vKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlc0NvbXBNZXRhKGxvb2t1cDogRnVsbExvb2t1cFNwZWMsIG1ldGE6IENvbXBvbmVudE1ldGEpIHtcbiAgaWYgKGxvb2t1cC5wcm9qZWN0SWQgJiYgbWV0YS5wcm9qZWN0SWQgIT09IGxvb2t1cC5wcm9qZWN0SWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNOYW1lU3BlYyhsb29rdXApXG4gICAgPyAobG9va3VwLm5hbWUgPT09IG1ldGEubmFtZSB8fFxuICAgICAgICBsb29rdXAucmF3TmFtZSA9PT0gbWV0YS5uYW1lIHx8XG4gICAgICAgIGxvb2t1cC5yYXdOYW1lID09PSBtZXRhLmRpc3BsYXlOYW1lKSAmJlxuICAgICAgICAobG9va3VwLmlzQ29kZSA9PSBudWxsIHx8IGxvb2t1cC5pc0NvZGUgPT09IG1ldGEuaXNDb2RlKVxuICAgIDogISEobWV0YS5wYXRoICYmIG1hdGNoZXNQYWdlUGF0aChtZXRhLnBhdGgsIGxvb2t1cC5wYXRoKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb21wTWV0YXMoXG4gIG1ldGFzOiBDb21wb25lbnRNZXRhW10sXG4gIGxvb2t1cDogQ29tcG9uZW50TG9va3VwU3BlY1xuKSB7XG4gIGNvbnN0IGZ1bGwgPSB0b0Z1bGxMb29rdXAobG9va3VwKTtcbiAgcmV0dXJuIG1ldGFzXG4gICAgLmZpbHRlcigobWV0YSkgPT4gbWF0Y2hlc0NvbXBNZXRhKGZ1bGwsIG1ldGEpKVxuICAgIC5tYXA8Q29tcG9uZW50TWV0YSAmIHsgcGFyYW1zPzogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgc3RyaW5nW10+IH0+KFxuICAgICAgKG1ldGEpID0+IHtcbiAgICAgICAgaWYgKGlzTmFtZVNwZWMoZnVsbCkgfHwgIW1ldGEucGF0aCkge1xuICAgICAgICAgIHJldHVybiBtZXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbWF0Y2ggPSBtYXRjaGVzUGFnZVBhdGgobWV0YS5wYXRoLCBmdWxsLnBhdGgpO1xuICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgcmV0dXJuIG1ldGE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyAuLi5tZXRhLCBwYXJhbXM6IG1hdGNoLnBhcmFtcyB9O1xuICAgICAgfVxuICAgIClcbiAgICAuc29ydChcbiAgICAgIChtZXRhMSwgbWV0YTIpID0+XG4gICAgICAgIC8vIFdlIHNvcnQgdGhlIG1hdGNoZWQgY29tcG9uZW50IG1ldGFzIGJ5IHRoZSBudW1iZXIgb2YgcGF0aCBwYXJhbXMsIHNvXG4gICAgICAgIC8vIGlmIHRoZXJlIGFyZSB0d28gcGFnZXMgYC9wcm9kdWN0cy9mb29gIGFuZCBgL3Byb2R1Y3RzL1tzbHVnXWAsXG4gICAgICAgIC8vIHRoZSBmaXJzdCBvbmUgd2lsbCBoYXZlIGhpZ2hlciBwcmVjZWRlbmNlLlxuICAgICAgICBBcnJheS5mcm9tKE9iamVjdC5rZXlzKG1ldGExLnBhcmFtcyB8fCB7fSkpLmxlbmd0aCAtXG4gICAgICAgIEFycmF5LmZyb20oT2JqZWN0LmtleXMobWV0YTIucGFyYW1zIHx8IHt9KSkubGVuZ3RoXG4gICAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldExvb2t1cFNwZWNOYW1lKGxvb2t1cDogQ29tcG9uZW50TG9va3VwU3BlYykge1xuICBpZiAodHlwZW9mIGxvb2t1cCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBsb29rdXA7XG4gIH0gZWxzZSBpZiAobG9va3VwLnByb2plY3RJZCkge1xuICAgIHJldHVybiBgJHtsb29rdXAubmFtZX0gKHByb2plY3QgJHtsb29rdXAucHJvamVjdElkfSlgO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsb29rdXAubmFtZTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gTWF5YmVXcmFwKHByb3BzOiB7XG4gIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGU7XG4gIGNvbmQ6IGJvb2xlYW47XG4gIHdyYXBwZXI6IChjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlKSA9PiBSZWFjdC5SZWFjdEVsZW1lbnQ7XG59KSB7XG4gIHJldHVybiAoXG4gICAgcHJvcHMuY29uZCA/IHByb3BzLndyYXBwZXIocHJvcHMuY2hpbGRyZW4pIDogcHJvcHMuY2hpbGRyZW5cbiAgKSBhcyBSZWFjdC5SZWFjdEVsZW1lbnQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bmlxPFQ+KGVsZW1lbnRzOiBUW10pOiBUW10ge1xuICByZXR1cm4gQXJyYXkuZnJvbShuZXcgU2V0KGVsZW1lbnRzKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bmlxQnk8VCwgSz4oZWxlbWVudHM6IFRbXSwgaXRlcmF0b3I6IChlbHQ6IFQpID0+IEspOiBUW10ge1xuICBjb25zdCB2aXMgPSBuZXcgU2V0PEs+KCk7XG4gIGNvbnN0IGZpbHRlcmVkOiBUW10gPSBbXTtcbiAgZm9yIChjb25zdCBlbHQgb2YgZWxlbWVudHMpIHtcbiAgICBjb25zdCBrZXkgPSBpdGVyYXRvcihlbHQpO1xuICAgIGlmICghdmlzLmhhcyhrZXkpKSB7XG4gICAgICB2aXMuYWRkKGtleSk7XG4gICAgICBmaWx0ZXJlZC5wdXNoKGVsdCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBmaWx0ZXJlZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdDxUPihhOiBUW10sIGI6IFRbXSk6IFRbXSB7XG4gIGNvbnN0IHNldEIgPSBuZXcgU2V0KGIpO1xuICByZXR1cm4gYS5maWx0ZXIoKGVsdCkgPT4gc2V0Qi5oYXMoZWx0KSk7XG59XG4iLCJpbXBvcnQgdHlwZSB7XG4gIEV4cGVyaW1lbnRTbGljZSxcbiAgU2VnbWVudFNsaWNlLFxuICBTcGxpdCxcbn0gZnJvbSBcIkBwbGFzbWljYXBwL2xvYWRlci1jb3JlXCI7XG5pbXBvcnQgdHlwZSB7IEdsb2JhbFZhcmlhbnRTcGVjIH0gZnJvbSBcIi4vUGxhc21pY1Jvb3RQcm92aWRlclwiO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGxhc21pY0Nvb2tpZVZhbHVlcygpIHtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBkb2N1bWVudC5jb29raWVcbiAgICAgIC5zcGxpdChcIjsgXCIpXG4gICAgICAuZmlsdGVyKChjb29raWUpID0+IGNvb2tpZS5pbmNsdWRlcyhcInBsYXNtaWM6XCIpKVxuICAgICAgLm1hcCgoY29va2llKSA9PiBjb29raWUuc3BsaXQoXCI9XCIpKVxuICAgICAgLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBba2V5LnNwbGl0KFwiOlwiKVsxXSwgdmFsdWVdKVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlUGxhc21pY0Nvb2tpZVZhbHVlKGtleTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKSB7XG4gIGRvY3VtZW50LmNvb2tpZSA9IGBwbGFzbWljOiR7a2V5fT0ke3ZhbHVlfWA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVWYXJpYXRpb25Db29raWVzKHZhcmlhdGlvbjogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9KSB7XG4gIE9iamVjdC5rZXlzKHZhcmlhdGlvbikubWFwKCh2YXJpYXRpb25LZXkpID0+IHtcbiAgICBjb25zdCBzbGljZUlkID0gdmFyaWF0aW9uW3ZhcmlhdGlvbktleV07XG4gICAgdXBkYXRlUGxhc21pY0Nvb2tpZVZhbHVlKHZhcmlhdGlvbktleSwgc2xpY2VJZCk7XG4gIH0pO1xufVxuXG5leHBvcnQgY29uc3QgZ2V0R2xvYmFsVmFyaWFudHNGcm9tU3BsaXRzID0gKFxuICBzcGxpdHM6IFNwbGl0W10sXG4gIHZhcmlhdGlvbjogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuKSA9PiB7XG4gIGNvbnN0IGdsb2JhbFZhcmlhbnRzOiBHbG9iYWxWYXJpYW50U3BlY1tdID0gW107XG5cbiAgT2JqZWN0LmtleXModmFyaWF0aW9uKS5tYXAoKHZhcmlhdGlvbktleTogc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgW190eXBlLCBzcGxpdElkXSA9IHZhcmlhdGlvbktleS5zcGxpdChcIi5cIik7XG4gICAgY29uc3Qgc2xpY2VJZCA9IHZhcmlhdGlvblt2YXJpYXRpb25LZXldO1xuICAgIGNvbnN0IHNwbGl0ID0gc3BsaXRzLmZpbmQoXG4gICAgICAocykgPT4gcy5pZCA9PT0gc3BsaXRJZCB8fCBzLmV4dGVybmFsSWQgPT09IHNwbGl0SWRcbiAgICApO1xuICAgIGlmIChzcGxpdCkge1xuICAgICAgY29uc3Qgc2xpY2U6IEV4cGVyaW1lbnRTbGljZSB8IFNlZ21lbnRTbGljZSB8IHVuZGVmaW5lZCA9IChcbiAgICAgICAgc3BsaXQuc2xpY2VzIGFzIEFycmF5PEV4cGVyaW1lbnRTbGljZSB8IFNlZ21lbnRTbGljZT5cbiAgICAgICkuZmluZCgoczogYW55KSA9PiBzLmlkID09PSBzbGljZUlkIHx8IHMuZXh0ZXJuYWxJZCA9PT0gc2xpY2VJZCk7XG4gICAgICBpZiAoc2xpY2UpIHtcbiAgICAgICAgc2xpY2UuY29udGVudHMubWFwKCh4KSA9PiB7XG4gICAgICAgICAgZ2xvYmFsVmFyaWFudHMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiB4Lmdyb3VwLFxuICAgICAgICAgICAgdmFsdWU6IHgudmFyaWFudCxcbiAgICAgICAgICAgIHByb2plY3RJZDogeC5wcm9qZWN0SWQsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGdsb2JhbFZhcmlhbnRzO1xufTtcblxuZXhwb3J0IGNvbnN0IG1lcmdlR2xvYmFsVmFyaWFudHNTcGVjID0gKFxuICB0YXJnZXQ6IEdsb2JhbFZhcmlhbnRTcGVjW10sXG4gIGZyb206IEdsb2JhbFZhcmlhbnRTcGVjW11cbikgPT4ge1xuICBsZXQgcmVzdWx0ID0gWy4uLnRhcmdldF07XG4gIGNvbnN0IGV4aXN0aW5nR2xvYmFsVmFyaWFudHMgPSBuZXcgU2V0KFxuICAgIHRhcmdldC5tYXAoKHQpID0+IGAke3QubmFtZX0tJHt0LnByb2plY3RJZCA/PyBcIlwifWApXG4gICk7XG4gIGNvbnN0IG5ld0dsb2JhbHMgPSBmcm9tLmZpbHRlcihcbiAgICAodCkgPT4gIWV4aXN0aW5nR2xvYmFsVmFyaWFudHMuaGFzKGAke3QubmFtZX0tJHt0LnByb2plY3RJZCA/PyBcIlwifWApXG4gICk7XG5cbiAgaWYgKG5ld0dsb2JhbHMubGVuZ3RoID4gMCkge1xuICAgIHJlc3VsdCA9IFsuLi5yZXN1bHQsIC4uLm5ld0dsb2JhbHNdO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIvKipcbiAqIFdlIGRvbid0IGFjdHVhbGx5IG1ha2UgdXNlIG9mIHRoZSBnbG9iYWwgdmFyaWFudCBSZWFjdCBjb250ZXh0cyBnZW5lcmF0ZWRcbiAqIGluIHRoZSBidW5kbGUuICBUaGF0J3MgYmVjYXVzZSB3ZSB3b3VsZCBoYXZlIHRvIHdhaXQgdW50aWwgdGhlIGRhdGEgaXNcbiAqIGxvYWRlZCBiZWZvcmUgd2UgY2FuIHNldCB1cCB0aGUgY29udGV4dCBwcm92aWRlcnMsIGJ1dCBzZXR0aW5nIHVwIGNvbnRleHRcbiAqIHByb3ZpZGVycyB3aWxsIG11dGF0ZSB0aGUgUmVhY3QgdHJlZSBhbmQgaW52YWxpZGF0ZSBhbGwgdGhlIGNoaWxkcmVuLiBUaGF0IG1lYW5zXG4gKiBvbmNlIGRhdGEgY29tZXMgaW4sIHdlJ2xsIHJlLXJlbmRlciB0aGUgUmVhY3QgdHJlZSBmcm9tIHRoZSBwcm92aWRlcnMgZG93blxuICogaW4gYSB3YXkgdGhhdCB3aWxsIGxvc2UgYWxsIGV4aXN0aW5nIFJlYWN0IHN0YXRlLiAgVGhlcmVmb3JlLCBpbnN0ZWFkLFxuICogd2UgYWx3YXlzIGhhdmUgYSBzaW5nbGUgY29udGV4dCBwcm92aWRlZCAtLSB0aGUgUGxhc21pY1Jvb3RDb250ZXh0IC0tIGFuZCB3ZVxuICogY3JlYXRlIHRoZXNlIGZha2UgdXNlR2xvYmFsVmFyaWFudCgpIGhvb2tzIHRoYXQganVzdCByZWFkIGZyb20gdGhhdFxuICogUGxhc21pY1Jvb3RDb250ZXh0LiAgVGhpcyBhbGxvd3MgdXMgdG8gaGF2ZSBhIHN0YWJsZSBSZWFjdCB0cmVlIGJlZm9yZSBhbmRcbiAqIGFmdGVyIHRoZSBkYXRhIGxvYWQuXG4gKi9cblxuaW1wb3J0IHsgSW50ZXJuYWxQbGFzbWljQ29tcG9uZW50TG9hZGVyIH0gZnJvbSBcIi4vbG9hZGVyLWNsaWVudFwiO1xuaW1wb3J0IHsgdXNlUGxhc21pY1Jvb3RDb250ZXh0IH0gZnJvbSBcIi4vUGxhc21pY1Jvb3RQcm92aWRlclwiO1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVXNlR2xvYmFsVmFyaWFudChuYW1lOiBzdHJpbmcsIHByb2plY3RJZDogc3RyaW5nKSB7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgY29uc3Qgcm9vdENvbnRleHQgPSB1c2VQbGFzbWljUm9vdENvbnRleHQoKTtcbiAgICBpZiAoIXJvb3RDb250ZXh0KSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNvbnN0IGxvYWRlciA9IHJvb3RDb250ZXh0LmxvYWRlciBhcyBJbnRlcm5hbFBsYXNtaWNDb21wb25lbnRMb2FkZXI7XG4gICAgY29uc3Qgc3BlYyA9IFtcbiAgICAgIC4uLmxvYWRlci5nZXRHbG9iYWxWYXJpYW50cygpLFxuICAgICAgLi4uKHJvb3RDb250ZXh0Lmdsb2JhbFZhcmlhbnRzID8/IFtdKSxcbiAgICBdLmZpbmQoXG4gICAgICAoc3BlYzIpID0+XG4gICAgICAgIHNwZWMyLm5hbWUgPT09IG5hbWUgJiZcbiAgICAgICAgKCFzcGVjMi5wcm9qZWN0SWQgfHwgc3BlYzIucHJvamVjdElkID09PSBwcm9qZWN0SWQpXG4gICAgKTtcbiAgICByZXR1cm4gc3BlYyA/IHNwZWMudmFsdWUgOiB1bmRlZmluZWQ7XG4gIH07XG59XG4iLCJpbXBvcnQgdHlwZSB7XG4gIENvbXBvbmVudEhlbHBlcnMsXG4gIENvbXBvbmVudEhlbHBlcnMgYXMgSW50ZXJuYWxDb2RlQ29tcG9uZW50SGVscGVycyxcbiAgQ29kZUNvbXBvbmVudE1ldGEgYXMgSW50ZXJuYWxDb2RlQ29tcG9uZW50TWV0YSxcbiAgQ3VzdG9tRnVuY3Rpb25NZXRhIGFzIEludGVybmFsQ3VzdG9tRnVuY3Rpb25NZXRhLFxuICBHbG9iYWxDb250ZXh0TWV0YSBhcyBJbnRlcm5hbEdsb2JhbENvbnRleHRNZXRhLFxuICBTdGF0ZUhlbHBlcnMsXG4gIFN0YXRlU3BlYyxcbiAgVG9rZW5SZWdpc3RyYXRpb24sXG4gIFRyYWl0TWV0YSxcbiAgdXNlRGF0YUVudixcbiAgdXNlU2VsZWN0b3IsXG4gIHVzZVNlbGVjdG9ycyxcbn0gZnJvbSBcIkBwbGFzbWljYXBwL2hvc3RcIjtcbmltcG9ydCB7XG4gIExvYWRlckJ1bmRsZUNhY2hlLFxuICBQYWdlTWV0YSxcbiAgUGxhc21pY01vZHVsZXNGZXRjaGVyLFxuICBQbGFzbWljVHJhY2tlcixcbiAgUmVnaXN0cnksXG4gIFRyYWNrUmVuZGVyT3B0aW9ucyxcbn0gZnJvbSBcIkBwbGFzbWljYXBwL2xvYWRlci1jb3JlXCI7XG5pbXBvcnQge1xuICBDb2RlTW9kdWxlLFxuICBDb21wb25lbnRNZXRhLFxuICBMb2FkZXJCdW5kbGVPdXRwdXQsXG4gIGludGVybmFsX2dldENhY2hlZEJ1bmRsZUluTm9kZVNlcnZlcixcbn0gZnJvbSBcIkBwbGFzbWljYXBwL2xvYWRlci1mZXRjaGVyXCI7XG5pbXBvcnQgeyBnZXRBY3RpdmVWYXJpYXRpb24sIGdldEV4dGVybmFsSWRzIH0gZnJvbSBcIkBwbGFzbWljYXBwL2xvYWRlci1zcGxpdHNcIjtcbmltcG9ydCB0eXBlIHsgdXNlTXV0YWJsZVBsYXNtaWNRdWVyeURhdGEgfSBmcm9tIFwiQHBsYXNtaWNhcHAvcXVlcnlcIjtcbmltcG9ydCB0eXBlIHsgR2xvYmFsVmFyaWFudFNwZWMgfSBmcm9tIFwiLi9QbGFzbWljUm9vdFByb3ZpZGVyXCI7XG5pbXBvcnQgeyBtZXJnZUJ1bmRsZXMsIHByZXBDb21wb25lbnREYXRhIH0gZnJvbSBcIi4vYnVuZGxlc1wiO1xuaW1wb3J0IHsgQ29tcG9uZW50TG9va3VwIH0gZnJvbSBcIi4vY29tcG9uZW50LWxvb2t1cFwiO1xuaW1wb3J0IHtcbiAgQ29tcG9uZW50TG9va3VwU3BlYyxcbiAgZ2V0Q29tcE1ldGFzLFxuICBnZXRMb29rdXBTcGVjTmFtZSxcbiAgaXNCcm93c2VyLFxuICBpc0R5bmFtaWNQYWdlUGF0aCxcbiAgdW5pcSxcbn0gZnJvbSBcIi4vdXRpbHNcIjtcbmltcG9ydCB7IGdldFBsYXNtaWNDb29raWVWYWx1ZXMsIHVwZGF0ZVBsYXNtaWNDb29raWVWYWx1ZSB9IGZyb20gXCIuL3ZhcmlhdGlvblwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIEluaXRPcHRpb25zIHtcbiAgcHJvamVjdHM6IHtcbiAgICBpZDogc3RyaW5nO1xuICAgIHRva2VuOiBzdHJpbmc7XG4gICAgdmVyc2lvbj86IHN0cmluZztcbiAgfVtdO1xuICBjYWNoZT86IExvYWRlckJ1bmRsZUNhY2hlO1xuICBwbGF0Zm9ybT86IFwicmVhY3RcIiB8IFwibmV4dGpzXCIgfCBcImdhdHNieVwiO1xuICBwbGF0Zm9ybU9wdGlvbnM/OiB7XG4gICAgbmV4dGpzPzoge1xuICAgICAgYXBwRGlyOiBib29sZWFuO1xuICAgIH07XG4gIH07XG4gIHByZXZpZXc/OiBib29sZWFuO1xuICBob3N0Pzogc3RyaW5nO1xuICBvbkNsaWVudFNpZGVGZXRjaD86IFwid2FyblwiIHwgXCJlcnJvclwiO1xuICBpMThuPzoge1xuICAgIGtleVNjaGVtZTogXCJjb250ZW50XCIgfCBcImhhc2hcIiB8IFwicGF0aFwiO1xuICAgIHRhZ1ByZWZpeD86IHN0cmluZztcbiAgfTtcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBpMThuLmtleVNjaGVtZSBpbnN0ZWFkXG4gICAqL1xuICBpMThuS2V5U2NoZW1lPzogXCJjb250ZW50XCIgfCBcImhhc2hcIjtcblxuICAvKipcbiAgICogQnkgZGVmYXVsdCwgZmV0Y2hDb21wb25lbnREYXRhKCkgYW5kIGZldGNoUGFnZXMoKSBjYWxscyBjYWNoZWQgaW4gbWVtb3J5XG4gICAqIHdpdGggdGhlIFBsYXNtaWNDb21wb25lbnRMb2FkZXIgaW5zdGFuY2UuICBJZiBhbHdheXNGcmVzaCBpcyB0cnVlLCB0aGVuXG4gICAqIGRhdGEgaXMgYWx3YXlzIGZyZXNobHkgZmV0Y2hlZCBvdmVyIHRoZSBuZXR3b3JrLlxuICAgKi9cbiAgYWx3YXlzRnJlc2g/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBJZiB0cnVlLCBnZW5lcmF0ZWQgY29kZSBmcm9tIHRoZSBzZXJ2ZXIgd29uJ3QgaW5jbHVkZSBwYWdlIG1ldGFkYXRhIHRhZ3NcbiAgICovXG4gIHNraXBIZWFkPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogSWYgdHJ1ZSwgdXNlcyBicm93c2VyIC8gbm9kZSdzIG5hdGl2ZSBmZXRjaFxuICAgKi9cbiAgbmF0aXZlRmV0Y2g/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBJZiB0cnVlLCB3aWxsIG5vdCByZWRpcmVjdCB0byB0aGUgY29kZWdlbiBzZXJ2ZXIgYXV0b21hdGljYWxseSwgYW5kIHdpbGxcbiAgICogdHJ5IHRvIHJldXNlIHRoZSBleGlzdGluZyBidW5kbGUgaW4gdGhlIGNhY2hlLlxuICAgKi9cbiAgbWFudWFsUmVkaXJlY3Q/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbXBvbmVudFJlbmRlckRhdGEge1xuICBlbnRyeUNvbXBNZXRhczogKENvbXBvbmVudE1ldGEgJiB7IHBhcmFtcz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gfSlbXTtcbiAgYnVuZGxlOiBMb2FkZXJCdW5kbGVPdXRwdXQ7XG4gIHJlbW90ZUZvbnRVcmxzOiBzdHJpbmdbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb21wb25lbnRTdWJzdGl0dXRpb25TcGVjIHtcbiAgbG9va3VwOiBDb21wb25lbnRMb29rdXBTcGVjO1xuICBjb21wb25lbnQ6IFJlYWN0LkNvbXBvbmVudFR5cGU8YW55PjtcbiAgY29kZUNvbXBvbmVudEhlbHBlcnM/OiBJbnRlcm5hbENvZGVDb21wb25lbnRIZWxwZXJzPFxuICAgIFJlYWN0LkNvbXBvbmVudFByb3BzPGFueT5cbiAgPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQbGFzbWljUm9vdFdhdGNoZXIge1xuICBvbkRhdGFGZXRjaGVkPzogKCkgPT4gdm9pZDtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb25zIHRvIGRlc2NyaWJlIGNvZGUgY29tcG9uZW50IGJlaGF2aW9ycywgaW4gb3JkZXIgdG8gYWxsb3dcbiAqIGRhdGEgZXh0cmFjdGlvbiBpbiBSU0MgLyBOZXh0LmpzIEFwcCByb3V0aW5nLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlYWN0U2VydmVyT3BzIHtcbiAgcmVhZERhdGFFbnY6IHR5cGVvZiB1c2VEYXRhRW52O1xuICByZWFkRGF0YVNlbGVjdG9yOiB0eXBlb2YgdXNlU2VsZWN0b3I7XG4gIHJlYWREYXRhU2VsZWN0b3JzOiB0eXBlb2YgdXNlU2VsZWN0b3JzO1xuICAvKipcbiAgICogVGhlIGNvbnRleHRzIGFyZSBwYXNzZWQgdXNpbmcgYSBrZXkgaW5zdGVhZCBvZiB0aGUgY29udGV4dCBwcm92aWRlclxuICAgKiBOb3RpY2UgaXQgY2Fubm90IGFjY2VzcyB0aGUgZGVmYXVsdCBjb250ZXh0IHZhbHVlIGlmIG5vbmUgaGFzIGJlZW4gcHJvdmlkZWQsXG4gICAqIHNpbmNlIFJlYWN0IHNlcnZlciBjb21wb25lbnRzIGNhbm5vdCBjcmVhdGUgY29udGV4dHMuXG4gICAqL1xuICByZWFkQ29udGV4dDogKGNvbnRleHRLZXk6IHN0cmluZykgPT4gYW55O1xuICAvKipcbiAgICogQWxsb3dzIGRhdGEgZmV0Y2hpbmcgZnJvbSB0aGUgY29kZSBjb21wb25lbnQgYW5kIGNhY2hpbmcgdGhlIHJlc3VsdCxcbiAgICogd2hpY2ggd2lsbCBiZSBzdG9yZWQgaW4gdGhlIGBxdWVyeUNhY2hlYCByZXR1cm5lZCBieVxuICAgKiBgZXh0cmFjdFBsYXNtaWNRdWVyeURhdGFgLlxuICAgKi9cbiAgZmV0Y2hEYXRhOiB0eXBlb2YgdXNlTXV0YWJsZVBsYXNtaWNRdWVyeURhdGE7XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBkYXRhIHByb3ZpZGVkIGJ5IGEgY29kZSBjb21wb25lbnQgdmlhIGBEYXRhUHJvdmlkZXJgXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2VydmVyUHJvdmlkZWREYXRhIHtcbiAgbmFtZTogc3RyaW5nO1xuICBkYXRhOiBhbnk7XG59XG5cbi8qKlxuICogUHJvdmlkZXMgYSBuZXcgdmFsdWUgZm9yIGEgZ2l2ZW4gY29udGV4dCBrZXksIHNpbWlsYXIgdG8gQ29udGV4dC5Qcm92aWRlci5cbiAqIFRoZSBjb250ZXh0IGl0c2VsZiBpcyBub3QgYXZhaWxhYmxlIChSU0MgZG9lc24ndCBhbGxvdyBjYWxsaW5nXG4gKiBgY3JlYXRlQ29udGV4dGApIHNvIGVhY2ggY29udGV4dCB3aWxsIG5lZWQgdG8gYmUgcmVwcmVzZW50ZWQgYXMgYSB1bmlxdWVcbiAqIFwiY29udGV4dCBrZXlcIi4gQWxzbyBpdCBtZWFucyB0aGUgZGVmYXVsdCBjb250ZXh0IHZhbHVlIGlzIG5vdCBhdmFpbGFibGVcbiAqIGluIGNhc2Ugbm8gdmFsdWUgaXMgcGFzc2VkIChhbmQgcmVhZGluZyB0aGF0IGNvbnRleHQgd2lsbCByZXR1cm4gYHVuZGVmaW5lZGApXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2VydmVyUHJvdmlkZWRDb250ZXh0IHtcbiAgLyoqXG4gICAqIElkZW50aWZpZXIgdG8gdGhlIGNvbnRleHQsIHJlcXVpcmVkIHRvIHJlYWQgaXQgbGF0ZXIgdmlhXG4gICAqIGBSZWFjdFNlcnZlck9wcy5yZWFkQ29udGV4dCgpYC5cbiAgICovXG4gIGNvbnRleHRLZXk6IHN0cmluZztcbiAgLyoqXG4gICAqIENvbnRleHQgdmFsdWUgYmVpbmcgcHJvdmlkZWQgKHNpbWlsYXIgdG8gYENvbnRleHQuUHJvdmlkZXJgKS5cbiAgICovXG4gIHZhbHVlOiBhbnk7XG59XG5cbi8qKlxuICogIEVhY2ggY2hpbGQgb2YgYSBjb2RlIGNvbXBvbmVudCBtaWdodCByZWNlaXZlIHNlcGFyYXRlIGBEYXRhUHJvdmlkZXJgIGFuZFxuICogIENvbnRleHQgdmFsdWVzLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFNlcnZlckNoaWxkRGF0YSB7XG4gIHByb3ZpZGVkRGF0YT86IFNlcnZlclByb3ZpZGVkRGF0YSB8IFNlcnZlclByb3ZpZGVkRGF0YVtdO1xuICBwcm92aWRlZENvbnRleHRzPzogU2VydmVyUHJvdmlkZWRDb250ZXh0IHwgU2VydmVyUHJvdmlkZWRDb250ZXh0W107XG4gIG5vZGU6IFJlYWN0LlJlYWN0Tm9kZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTZXJ2ZXJJbmZvIHtcbiAgLyoqXG4gICAqIE9wdGlvbmFsOiBJbmRpY2F0ZXMgdGhlIFJlYWN0IE5vZGVzIGNyZWF0ZWQgYnkgdGhlIGNvbXBvbmVudCBhbmQgdGhlXG4gICAqIHJlc3BlY3RpdmUgY29udGV4dHMgcHJvdmlkZWQgdG8gdGhlbS4gSWYgbm90IHNwZWNpZmllZCwgaXQgd2lsbCByZW5kZXIgdGhlXG4gICAqIGNoaWxkcmVuIHBhc3NlZCB0byB0aGUgY29tcG9uZW50IGFzIHByb3BzLlxuICAgKi9cbiAgY2hpbGRyZW4/OiBTZXJ2ZXJDaGlsZERhdGEgfCBTZXJ2ZXJDaGlsZERhdGFbXTtcbiAgcHJvdmlkZWREYXRhPzogU2VydmVyUHJvdmlkZWREYXRhIHwgU2VydmVyUHJvdmlkZWREYXRhW107XG4gIHByb3ZpZGVkQ29udGV4dHM/OiBTZXJ2ZXJQcm92aWRlZENvbnRleHQgfCBTZXJ2ZXJQcm92aWRlZENvbnRleHRbXTtcbn1cblxuZXhwb3J0IHR5cGUgQ29kZUNvbXBvbmVudE1ldGE8UD4gPSBPbWl0PFxuICBJbnRlcm5hbENvZGVDb21wb25lbnRNZXRhPFA+LFxuICBcImltcG9ydFBhdGhcIiB8IFwiY29tcG9uZW50SGVscGVyc1wiIHwgXCJzdGF0ZXNcIlxuPiAmIHtcbiAgLyoqXG4gICAqIFRoZSBwYXRoIHRvIGJlIHVzZWQgd2hlbiBpbXBvcnRpbmcgdGhlIGNvbXBvbmVudCBpbiB0aGUgZ2VuZXJhdGVkIGNvZGUuXG4gICAqIEl0IGNhbiBiZSB0aGUgbmFtZSBvZiB0aGUgcGFja2FnZSB0aGF0IGNvbnRhaW5zIHRoZSBjb21wb25lbnQsIG9yIHRoZSBwYXRoXG4gICAqIHRvIHRoZSBmaWxlIGluIHRoZSBwcm9qZWN0IChyZWxhdGl2ZSB0byB0aGUgcm9vdCBkaXJlY3RvcnkpLlxuICAgKiBPcHRpb25hbDogbm90IHVzZWQgYnkgUGxhc21pYyBoZWFkbGVzcyBBUEksIG9ubHkgYnkgY29kZWdlbi5cbiAgICovXG4gIGltcG9ydFBhdGg/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgc3RhdGVzIGhlbHBlcnMgYXJlIHJlZ2lzdGVyZWQgdG9nZXRoZXIgd2l0aCB0aGUgc3RhdGVzIGZvciB0aGUgUGxhc21pYyBoZWFkbGVzcyBBUElcbiAgICovXG4gIHN0YXRlcz86IFJlY29yZDxzdHJpbmcsIFN0YXRlU3BlYzxQPiAmIFN0YXRlSGVscGVyczxQLCBhbnk+PjtcblxuICAvKipcbiAgICogSGVscGVyIGZ1bmN0aW9uIHRvIGVuYWJsZSBkYXRhIGV4dHJhY3Rpb24gd2hlbiBydW5uaW5nIFBsYXNtaWMgZnJvbVxuICAgKiBOZXh0LmpzIEFwcCBSb3V0ZXIuXG4gICAqL1xuICBnZXRTZXJ2ZXJJbmZvPzogKHByb3BzOiBQLCBvcHM6IFJlYWN0U2VydmVyT3BzKSA9PiBTZXJ2ZXJJbmZvO1xufTtcblxuZXhwb3J0IHR5cGUgR2xvYmFsQ29udGV4dE1ldGE8UD4gPSBPbWl0PFxuICBJbnRlcm5hbEdsb2JhbENvbnRleHRNZXRhPFA+LFxuICBcImltcG9ydFBhdGhcIlxuPiAmIHtcbiAgLyoqXG4gICAqIFRoZSBwYXRoIHRvIGJlIHVzZWQgd2hlbiBpbXBvcnRpbmcgdGhlIGNvbXBvbmVudCBpbiB0aGUgZ2VuZXJhdGVkIGNvZGUuXG4gICAqIEl0IGNhbiBiZSB0aGUgbmFtZSBvZiB0aGUgcGFja2FnZSB0aGF0IGNvbnRhaW5zIHRoZSBjb21wb25lbnQsIG9yIHRoZSBwYXRoXG4gICAqIHRvIHRoZSBmaWxlIGluIHRoZSBwcm9qZWN0IChyZWxhdGl2ZSB0byB0aGUgcm9vdCBkaXJlY3RvcnkpLlxuICAgKiBPcHRpb25hbDogbm90IHVzZWQgYnkgUGxhc21pYyBoZWFkbGVzcyBBUEksIG9ubHkgYnkgY29kZWdlbi5cbiAgICovXG4gIGltcG9ydFBhdGg/OiBzdHJpbmc7XG59O1xuXG5leHBvcnQgdHlwZSBDdXN0b21GdW5jdGlvbk1ldGE8RiBleHRlbmRzICguLi5hcmdzOiBhbnlbXSkgPT4gYW55PiA9IE9taXQ8XG4gIEludGVybmFsQ3VzdG9tRnVuY3Rpb25NZXRhPEY+LFxuICBcImltcG9ydFBhdGhcIlxuPiAmIHtcbiAgLyoqXG4gICAqIFRoZSBwYXRoIHRvIGJlIHVzZWQgd2hlbiBpbXBvcnRpbmcgdGhlIGZ1bmN0aW9uIGluIHRoZSBnZW5lcmF0ZWQgY29kZS5cbiAgICogSXQgY2FuIGJlIHRoZSBuYW1lIG9mIHRoZSBwYWNrYWdlIHRoYXQgY29udGFpbnMgdGhlIGZ1bmN0aW9uLCBvciB0aGUgcGF0aFxuICAgKiB0byB0aGUgZmlsZSBpbiB0aGUgcHJvamVjdCAocmVsYXRpdmUgdG8gdGhlIHJvb3QgZGlyZWN0b3J5KS5cbiAgICogT3B0aW9uYWw6IG5vdCB1c2VkIGJ5IFBsYXNtaWMgaGVhZGxlc3MgQVBJLCBvbmx5IGJ5IGNvZGVnZW4uXG4gICAqL1xuICBpbXBvcnRQYXRoPzogc3RyaW5nO1xufTtcblxuZXhwb3J0IHR5cGUgRmV0Y2hQYWdlc09wdHMgPSB7XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGluY2x1ZGUgZHluYW1pYyBwYWdlcyBpbiBmZXRjaFBhZ2VzKCkgb3V0cHV0LiBBIHBhZ2UgaXNcbiAgICogY29uc2lkZXJlZCBkeW5hbWljIGlmIGl0cyBwYXRoIGNvbnRhaW5zIHNvbWUgcGFyYW0gYmV0d2VlbiBicmFja2V0cyxcbiAgICogZS5nLiBcIltzbHVnXVwiLlxuICAgKi9cbiAgaW5jbHVkZUR5bmFtaWNQYWdlcz86IGJvb2xlYW47XG59O1xuXG5leHBvcnQgY29uc3QgU1VCU1RJVFVURURfQ09NUE9ORU5UUzogUmVjb3JkPFxuICBzdHJpbmcsXG4gIFJlYWN0LkNvbXBvbmVudFR5cGU8YW55PlxuPiA9IHt9O1xuZXhwb3J0IGNvbnN0IFJFR0lTVEVSRURfQ09ERV9DT01QT05FTlRfSEVMUEVSUzogUmVjb3JkPFxuICBzdHJpbmcsXG4gIEludGVybmFsQ29kZUNvbXBvbmVudEhlbHBlcnM8UmVhY3QuQ29tcG9uZW50UHJvcHM8YW55Pj5cbj4gPSB7fTtcbmV4cG9ydCBjb25zdCBTVUJTVElUVVRFRF9HTE9CQUxfVkFSSUFOVF9IT09LUzogUmVjb3JkPHN0cmluZywgKCkgPT4gYW55PiA9IHt9O1xuZXhwb3J0IGNvbnN0IFJFR0lTVEVSRURfQ1VTVE9NX0ZVTkNUSU9OUzogUmVjb3JkPFxuICBzdHJpbmcsXG4gICguLi5hcmdzOiBhbnlbXSkgPT4gYW55XG4+ID0ge307XG5cbmV4cG9ydCBmdW5jdGlvbiBjdXN0b21GdW5jdGlvbkltcG9ydEFsaWFzPEYgZXh0ZW5kcyAoLi4uYXJnczogYW55W10pID0+IGFueT4oXG4gIG1ldGE6IEN1c3RvbUZ1bmN0aW9uTWV0YTxGPlxuKSB7XG4gIGNvbnN0IGN1c3RvbUZ1bmN0aW9uUHJlZml4ID0gYF9fZm5fYDtcbiAgcmV0dXJuIG1ldGEubmFtZXNwYWNlXG4gICAgPyBgJHtjdXN0b21GdW5jdGlvblByZWZpeH0ke21ldGEubmFtZXNwYWNlfV9fJHttZXRhLm5hbWV9YFxuICAgIDogYCR7Y3VzdG9tRnVuY3Rpb25QcmVmaXh9JHttZXRhLm5hbWV9YDtcbn1cblxuaW50ZXJmYWNlIEJ1aWx0aW5SZWdpc3RlcmVkTW9kdWxlcyB7XG4gIHJlYWN0OiB0eXBlb2YgaW1wb3J0KFwicmVhY3RcIik7XG4gIFwicmVhY3QtZG9tXCI6IHR5cGVvZiBpbXBvcnQoXCJyZWFjdC1kb21cIik7XG4gIFwicmVhY3QvanN4LXJ1bnRpbWVcIjogdHlwZW9mIGltcG9ydChcInJlYWN0L2pzeC1ydW50aW1lXCIpO1xuICBcInJlYWN0L2pzeC1kZXYtcnVudGltZVwiOiB0eXBlb2YgaW1wb3J0KFwicmVhY3QvanN4LWRldi1ydW50aW1lXCIpO1xuICBcIkBwbGFzbWljYXBwL3F1ZXJ5XCI6IHR5cGVvZiBpbXBvcnQoXCJAcGxhc21pY2FwcC9xdWVyeVwiKTtcbiAgXCJAcGxhc21pY2FwcC9kYXRhLXNvdXJjZXMtY29udGV4dFwiOiB0eXBlb2YgaW1wb3J0KFwiQHBsYXNtaWNhcHAvZGF0YS1zb3VyY2VzLWNvbnRleHRcIik7XG4gIFwiQHBsYXNtaWNhcHAvaG9zdFwiOiB0eXBlb2YgaW1wb3J0KFwiQHBsYXNtaWNhcHAvaG9zdFwiKTtcbiAgXCJAcGxhc21pY2FwcC9sb2FkZXItcnVudGltZS1yZWdpc3RyeVwiOiB7XG4gICAgY29tcG9uZW50czogUmVjb3JkPHN0cmluZywgUmVhY3QuQ29tcG9uZW50VHlwZTxhbnk+PjtcbiAgICBnbG9iYWxWYXJpYW50SG9va3M6IFJlY29yZDxzdHJpbmcsICgpID0+IGFueT47XG4gICAgY29kZUNvbXBvbmVudEhlbHBlcnM6IFJlY29yZDxzdHJpbmcsIENvbXBvbmVudEhlbHBlcnM8YW55Pj47XG4gICAgZnVuY3Rpb25zOiBSZWNvcmQ8c3RyaW5nLCAoLi4uYXJnczogYW55W10pID0+IGFueT47XG4gIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmV0Y2hDb21wb25lbnREYXRhT3B0cyB7XG4gIC8qKlxuICAgKiBXaWxsIGZldGNoIGVpdGhlciBjb2RlIHRhcmdldGluZyBTU1Igb3IgYnJvd3NlciBoeWRyYXRpb24gaW4gdGhlXG4gICAqIHJldHVybmVkIGJ1bmRsZS5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgdGhlIHRhcmdldCBpcyBicm93c2VyLiBUaGF0J3Mgb2theSwgYmVjYXVzZSBldmVuIHdoZW5cbiAgICogZG9pbmcgU1NSLCBhcyBsb25nIGFzIHlvdSBhcmUgdXNpbmcgdGhlIHNhbWUgaW5zdGFuY2Ugb2YgUGxhc21pY0xvYWRlclxuICAgKiB0aGF0IHdhcyB1c2VkIHRvIGZldGNoIGNvbXBvbmVudCBkYXRhLCBpdCB3aWxsIHN0aWxsIGtub3cgaG93IHRvIGdldCBhdFxuICAgKiB0aGUgc2VydmVyIGNvZGUuXG4gICAqXG4gICAqIEJ1dCwgaWYgeW91IGFyZSBidWlsZGluZyB5b3VyIG93biBTU1Igc29sdXRpb24sIHdoZXJlIGZldGNoaW5nIGFuZCByZW5kZXJpbmdcbiAgICogYXJlIHVzaW5nIGRpZmZlcmVudCBpbnN0YW5jZXMgb2YgUGxhc21pY0xvYWRlciwgdGhlbiB5b3UnbGwgd2FudCB0byBtYWtlXG4gICAqIHN1cmUgdGhhdCB3aGVuIHlvdSBmZXRjaCwgeW91IGFyZSBmZXRjaGluZyB0aGUgcmlnaHQgb25lIHRvIGJlIHVzZWQgaW4gdGhlXG4gICAqIHJpZ2h0IGVudmlyb25tZW50IGZvciBlaXRoZXIgU1NSIG9yIGJyb3dzZXIgaHlkcmF0aW9uLlxuICAgKi9cbiAgdGFyZ2V0PzogXCJzZXJ2ZXJcIiB8IFwiYnJvd3NlclwiO1xufVxuXG5mdW5jdGlvbiBwYXJzZUZldGNoQ29tcG9uZW50RGF0YUFyZ3MoXG4gIHNwZWNzOiBDb21wb25lbnRMb29rdXBTcGVjW10sXG4gIG9wdHM/OiBGZXRjaENvbXBvbmVudERhdGFPcHRzXG4pOiB7IHNwZWNzOiBDb21wb25lbnRMb29rdXBTcGVjW107IG9wdHM/OiBGZXRjaENvbXBvbmVudERhdGFPcHRzIH07XG5mdW5jdGlvbiBwYXJzZUZldGNoQ29tcG9uZW50RGF0YUFyZ3MoLi4uc3BlY3M6IENvbXBvbmVudExvb2t1cFNwZWNbXSk6IHtcbiAgc3BlY3M6IENvbXBvbmVudExvb2t1cFNwZWNbXTtcbiAgb3B0cz86IEZldGNoQ29tcG9uZW50RGF0YU9wdHM7XG59O1xuZnVuY3Rpb24gcGFyc2VGZXRjaENvbXBvbmVudERhdGFBcmdzKC4uLmFyZ3M6IGFueVtdKSB7XG4gIGxldCBzcGVjczogQ29tcG9uZW50TG9va3VwU3BlY1tdO1xuICBsZXQgb3B0czogRmV0Y2hDb21wb25lbnREYXRhT3B0cyB8IHVuZGVmaW5lZDtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJnc1swXSkpIHtcbiAgICBzcGVjcyA9IGFyZ3NbMF07XG4gICAgb3B0cyA9IGFyZ3NbMV07XG4gIH0gZWxzZSB7XG4gICAgc3BlY3MgPSBhcmdzO1xuICAgIG9wdHMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIHsgc3BlY3MsIG9wdHMgfTtcbn1cblxuLyoqIFN1YnNldCBvZiBsb2FkZXIgZnVuY3Rpb25hbGl0eSB0aGF0IHdvcmtzIG9uIENsaWVudCBhbmQgUmVhY3QgU2VydmVyIENvbXBvbmVudHMuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFzZUludGVybmFsUGxhc21pY0NvbXBvbmVudExvYWRlciB7XG4gIHB1YmxpYyByZWFkb25seSBvcHRzOiBJbml0T3B0aW9ucztcbiAgcHJpdmF0ZSByZWFkb25seSByZWdpc3RyeSA9IG5ldyBSZWdpc3RyeSgpO1xuICBwcml2YXRlIHJlYWRvbmx5IHRyYWNrZXI6IFBsYXNtaWNUcmFja2VyO1xuICBwcml2YXRlIHJlYWRvbmx5IGZldGNoZXI6IFBsYXNtaWNNb2R1bGVzRmV0Y2hlcjtcbiAgcHJpdmF0ZSByZWFkb25seSBvbkJ1bmRsZU1lcmdlZD86ICgpID0+IHZvaWQ7XG4gIHByaXZhdGUgcmVhZG9ubHkgb25CdW5kbGVGZXRjaGVkPzogKCkgPT4gdm9pZDtcbiAgcHJpdmF0ZSBnbG9iYWxWYXJpYW50czogR2xvYmFsVmFyaWFudFNwZWNbXSA9IFtdO1xuICBwcml2YXRlIHN1YnM6IENvbXBvbmVudFN1YnN0aXR1dGlvblNwZWNbXSA9IFtdO1xuXG4gIHByaXZhdGUgYnVuZGxlOiBMb2FkZXJCdW5kbGVPdXRwdXQgPSB7XG4gICAgbW9kdWxlczoge1xuICAgICAgYnJvd3NlcjogW10sXG4gICAgICBzZXJ2ZXI6IFtdLFxuICAgIH0sXG4gICAgY29tcG9uZW50czogW10sXG4gICAgZ2xvYmFsR3JvdXBzOiBbXSxcbiAgICBwcm9qZWN0czogW10sXG4gICAgYWN0aXZlU3BsaXRzOiBbXSxcbiAgICBidW5kbGVLZXk6IG51bGwsXG4gICAgZGVmZXJDaHVua3NCeURlZmF1bHQ6IGZhbHNlLFxuICAgIGRpc2FibGVSb290TG9hZGluZ0JvdW5kYXJ5QnlEZWZhdWx0OiBmYWxzZSxcbiAgICBmaWx0ZXJlZElkczoge30sXG4gIH07XG5cbiAgY29uc3RydWN0b3IoYXJnczoge1xuICAgIG9wdHM6IEluaXRPcHRpb25zO1xuICAgIGZldGNoZXI6IFBsYXNtaWNNb2R1bGVzRmV0Y2hlcjtcbiAgICB0cmFja2VyOiBQbGFzbWljVHJhY2tlcjtcbiAgICAvKiogQ2FsbGVkIGFmdGVyIGBtZXJnZUJ1bmRsZWAgKGluY2x1ZGluZyBgZmV0Y2hgIGNhbGxzKS4gKi9cbiAgICBvbkJ1bmRsZU1lcmdlZD86ICgpID0+IHZvaWQ7XG4gICAgLyoqIENhbGxlZCBhZnRlciBhbnkgYGZldGNoYCBjYWxscy4gKi9cbiAgICBvbkJ1bmRsZUZldGNoZWQ/OiAoKSA9PiB2b2lkO1xuICAgIGJ1aWx0aW5Nb2R1bGVzOiBCdWlsdGluUmVnaXN0ZXJlZE1vZHVsZXM7XG4gIH0pIHtcbiAgICB0aGlzLm9wdHMgPSBhcmdzLm9wdHM7XG4gICAgdGhpcy5mZXRjaGVyID0gYXJncy5mZXRjaGVyO1xuICAgIHRoaXMudHJhY2tlciA9IGFyZ3MudHJhY2tlcjtcbiAgICB0aGlzLm9uQnVuZGxlTWVyZ2VkID0gYXJncy5vbkJ1bmRsZU1lcmdlZDtcbiAgICB0aGlzLm9uQnVuZGxlRmV0Y2hlZCA9IGFyZ3Mub25CdW5kbGVGZXRjaGVkO1xuICAgIHRoaXMucmVnaXN0ZXJNb2R1bGVzKGFyZ3MuYnVpbHRpbk1vZHVsZXMpO1xuICB9XG5cbiAgcHJpdmF0ZSBtYXliZUdldENvbXBNZXRhcyguLi5zcGVjczogQ29tcG9uZW50TG9va3VwU3BlY1tdKSB7XG4gICAgY29uc3QgZm91bmQgPSBuZXcgU2V0PENvbXBvbmVudE1ldGE+KCk7XG4gICAgY29uc3QgbWlzc2luZzogQ29tcG9uZW50TG9va3VwU3BlY1tdID0gW107XG4gICAgZm9yIChjb25zdCBzcGVjIG9mIHNwZWNzKSB7XG4gICAgICBjb25zdCBmaWx0ZXJlZE1ldGFzID0gZ2V0Q29tcE1ldGFzKHRoaXMuYnVuZGxlLmNvbXBvbmVudHMsIHNwZWMpO1xuICAgICAgaWYgKGZpbHRlcmVkTWV0YXMubGVuZ3RoID4gMCkge1xuICAgICAgICBmaWx0ZXJlZE1ldGFzLmZvckVhY2goKG1ldGEpID0+IGZvdW5kLmFkZChtZXRhKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtaXNzaW5nLnB1c2goc3BlYyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGZvdW5kOiBBcnJheS5mcm9tKGZvdW5kLmtleXMoKSksIG1pc3NpbmcgfTtcbiAgfVxuXG4gIGFzeW5jIG1heWJlRmV0Y2hDb21wb25lbnREYXRhKFxuICAgIHNwZWNzOiBDb21wb25lbnRMb29rdXBTcGVjW10sXG4gICAgb3B0cz86IEZldGNoQ29tcG9uZW50RGF0YU9wdHNcbiAgKTogUHJvbWlzZTxDb21wb25lbnRSZW5kZXJEYXRhIHwgbnVsbD47XG4gIGFzeW5jIG1heWJlRmV0Y2hDb21wb25lbnREYXRhKFxuICAgIC4uLnNwZWNzOiBDb21wb25lbnRMb29rdXBTcGVjW11cbiAgKTogUHJvbWlzZTxDb21wb25lbnRSZW5kZXJEYXRhIHwgbnVsbD47XG4gIGFzeW5jIG1heWJlRmV0Y2hDb21wb25lbnREYXRhKFxuICAgIC4uLmFyZ3M6IGFueVtdXG4gICk6IFByb21pc2U8Q29tcG9uZW50UmVuZGVyRGF0YSB8IG51bGw+IHtcbiAgICBjb25zdCB7IHNwZWNzLCBvcHRzIH0gPSBwYXJzZUZldGNoQ29tcG9uZW50RGF0YUFyZ3MoLi4uYXJncyk7XG4gICAgY29uc3QgcmV0dXJuV2l0aFNwZWNzVG9GZXRjaCA9IGFzeW5jIChcbiAgICAgIHNwZWNzVG9GZXRjaDogQ29tcG9uZW50TG9va3VwU3BlY1tdXG4gICAgKSA9PiB7XG4gICAgICBhd2FpdCB0aGlzLmZldGNoTWlzc2luZ0RhdGEoeyBtaXNzaW5nU3BlY3M6IHNwZWNzVG9GZXRjaCB9KTtcbiAgICAgIGNvbnN0IHsgZm91bmQ6IGV4aXN0aW5nTWV0YXMyLCBtaXNzaW5nOiBtaXNzaW5nU3BlY3MyIH0gPVxuICAgICAgICB0aGlzLm1heWJlR2V0Q29tcE1ldGFzKC4uLnNwZWNzKTtcbiAgICAgIGlmIChtaXNzaW5nU3BlY3MyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmVwQ29tcG9uZW50RGF0YSh0aGlzLmJ1bmRsZSwgZXhpc3RpbmdNZXRhczIsIG9wdHMpO1xuICAgIH07XG5cbiAgICBpZiAodGhpcy5vcHRzLmFsd2F5c0ZyZXNoKSB7XG4gICAgICAvLyBJZiBhbHdheXNGcmVzaCwgdGhlbiB3ZSB0cmVhdCBhbGwgc3BlY3MgYXMgbWlzc2luZ1xuICAgICAgcmV0dXJuIGF3YWl0IHJldHVybldpdGhTcGVjc1RvRmV0Y2goc3BlY3MpO1xuICAgIH1cblxuICAgIC8vIEVsc2Ugd2Ugb25seSBmZXRjaCBhY3R1YWxseSBtaXNzaW5nIHNwZWNzXG4gICAgY29uc3QgeyBmb3VuZDogZXhpc3RpbmdNZXRhcywgbWlzc2luZzogbWlzc2luZ1NwZWNzIH0gPVxuICAgICAgdGhpcy5tYXliZUdldENvbXBNZXRhcyguLi5zcGVjcyk7XG4gICAgaWYgKG1pc3NpbmdTcGVjcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBwcmVwQ29tcG9uZW50RGF0YSh0aGlzLmJ1bmRsZSwgZXhpc3RpbmdNZXRhcywgb3B0cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGF3YWl0IHJldHVybldpdGhTcGVjc1RvRmV0Y2gobWlzc2luZ1NwZWNzKTtcbiAgfVxuXG4gIGFzeW5jIGZldGNoQ29tcG9uZW50RGF0YShcbiAgICBzcGVjczogQ29tcG9uZW50TG9va3VwU3BlY1tdLFxuICAgIG9wdHM/OiBGZXRjaENvbXBvbmVudERhdGFPcHRzXG4gICk6IFByb21pc2U8Q29tcG9uZW50UmVuZGVyRGF0YT47XG4gIGFzeW5jIGZldGNoQ29tcG9uZW50RGF0YShcbiAgICAuLi5zcGVjczogQ29tcG9uZW50TG9va3VwU3BlY1tdXG4gICk6IFByb21pc2U8Q29tcG9uZW50UmVuZGVyRGF0YT47XG4gIGFzeW5jIGZldGNoQ29tcG9uZW50RGF0YSguLi5hcmdzOiBhbnlbXSk6IFByb21pc2U8Q29tcG9uZW50UmVuZGVyRGF0YT4ge1xuICAgIGNvbnN0IHsgc3BlY3MsIG9wdHMgfSA9IHBhcnNlRmV0Y2hDb21wb25lbnREYXRhQXJncyguLi5hcmdzKTtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5tYXliZUZldGNoQ29tcG9uZW50RGF0YShzcGVjcywgb3B0cyk7XG5cbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIGNvbnN0IHsgbWlzc2luZzogbWlzc2luZ1NwZWNzIH0gPSB0aGlzLm1heWJlR2V0Q29tcE1ldGFzKC4uLnNwZWNzKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFVuYWJsZSB0byBmaW5kIGNvbXBvbmVudHMgJHttaXNzaW5nU3BlY3NcbiAgICAgICAgICAubWFwKGdldExvb2t1cFNwZWNOYW1lKVxuICAgICAgICAgIC5qb2luKFwiLCBcIil9YFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIGFzeW5jIGZldGNoUGFnZXMob3B0cz86IEZldGNoUGFnZXNPcHRzKSB7XG4gICAgdGhpcy5tYXliZVJlcG9ydENsaWVudFNpZGVGZXRjaChcbiAgICAgICgpID0+IGBQbGFzbWljOiBmZXRjaGluZyBhbGwgcGFnZSBtZXRhZGF0YSBpbiB0aGUgYnJvd3NlcmBcbiAgICApO1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmZldGNoQWxsRGF0YSgpO1xuICAgIHJldHVybiBkYXRhLmNvbXBvbmVudHMuZmlsdGVyKFxuICAgICAgKGNvbXApID0+XG4gICAgICAgIGNvbXAuaXNQYWdlICYmXG4gICAgICAgIGNvbXAucGF0aCAmJlxuICAgICAgICAob3B0cz8uaW5jbHVkZUR5bmFtaWNQYWdlcyB8fCAhaXNEeW5hbWljUGFnZVBhdGgoY29tcC5wYXRoKSlcbiAgICApIGFzIFBhZ2VNZXRhW107XG4gIH1cblxuICBhc3luYyBmZXRjaENvbXBvbmVudHMoKSB7XG4gICAgdGhpcy5tYXliZVJlcG9ydENsaWVudFNpZGVGZXRjaChcbiAgICAgICgpID0+IGBQbGFzbWljOiBmZXRjaGluZyBhbGwgY29tcG9uZW50IG1ldGFkYXRhIGluIHRoZSBicm93c2VyYFxuICAgICk7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuZmV0Y2hBbGxEYXRhKCk7XG4gICAgcmV0dXJuIGRhdGEuY29tcG9uZW50cztcbiAgfVxuXG4gIGdldEFjdGl2ZVNwbGl0cygpIHtcbiAgICByZXR1cm4gdGhpcy5idW5kbGUuYWN0aXZlU3BsaXRzO1xuICB9XG5cbiAgZ2V0Q2h1bmtzVXJsKGJ1bmRsZTogTG9hZGVyQnVuZGxlT3V0cHV0LCBtb2R1bGVzOiBDb2RlTW9kdWxlW10pIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaGVyLmdldENodW5rc1VybChidW5kbGUsIG1vZHVsZXMpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBmZXRjaE1pc3NpbmdEYXRhKG9wdHM6IHtcbiAgICBtaXNzaW5nU3BlY3M6IENvbXBvbmVudExvb2t1cFNwZWNbXTtcbiAgfSkge1xuICAgIC8vIFRPRE86IGRvIGJldHRlciB0aGFuIGp1c3QgZmV0Y2hpbmcgZXZlcnl0aGluZ1xuICAgIHRoaXMubWF5YmVSZXBvcnRDbGllbnRTaWRlRmV0Y2goXG4gICAgICAoKSA9PlxuICAgICAgICBgUGxhc21pYzogZmV0Y2hpbmcgbWlzc2luZyBjb21wb25lbnRzIGluIHRoZSBicm93c2VyOiAke29wdHMubWlzc2luZ1NwZWNzXG4gICAgICAgICAgLm1hcCgoc3BlYykgPT4gZ2V0TG9va3VwU3BlY05hbWUoc3BlYykpXG4gICAgICAgICAgLmpvaW4oXCIsIFwiKX1gXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEFsbERhdGEoKTtcbiAgfVxuXG4gIHByaXZhdGUgbWF5YmVSZXBvcnRDbGllbnRTaWRlRmV0Y2gobWtNc2c6ICgpID0+IHN0cmluZykge1xuICAgIGlmIChpc0Jyb3dzZXIgJiYgdGhpcy5vcHRzLm9uQ2xpZW50U2lkZUZldGNoKSB7XG4gICAgICBjb25zdCBtc2cgPSBta01zZygpO1xuICAgICAgaWYgKHRoaXMub3B0cy5vbkNsaWVudFNpZGVGZXRjaCA9PT0gXCJ3YXJuXCIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGZldGNoQWxsRGF0YSgpIHtcbiAgICBjb25zdCBidW5kbGUgPSBhd2FpdCB0aGlzLmZldGNoZXIuZmV0Y2hBbGxEYXRhKCk7XG4gICAgdGhpcy50cmFja2VyLnRyYWNrRmV0Y2goKTtcbiAgICB0aGlzLm1lcmdlQnVuZGxlKGJ1bmRsZSk7XG4gICAgdGhpcy5vbkJ1bmRsZUZldGNoZWQ/LigpO1xuICAgIHJldHVybiBidW5kbGU7XG4gIH1cblxuICBtZXJnZUJ1bmRsZShuZXdCdW5kbGU6IExvYWRlckJ1bmRsZU91dHB1dCkge1xuICAgIG5ld0J1bmRsZS5idW5kbGVLZXkgPSBuZXdCdW5kbGUuYnVuZGxlS2V5ID8/IG51bGw7XG4gICAgaWYgKFxuICAgICAgbmV3QnVuZGxlLmJ1bmRsZUtleSAmJlxuICAgICAgdGhpcy5idW5kbGUuYnVuZGxlS2V5ICYmXG4gICAgICBuZXdCdW5kbGUuYnVuZGxlS2V5ICE9PSB0aGlzLmJ1bmRsZS5idW5kbGVLZXlcbiAgICApIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYFBsYXNtaWMgRXJyb3I6IERpZmZlcmVudCBjb2RlIGV4cG9ydCBoYXNoZXMuIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3VyIGFwcCBpcyB1c2luZyBkaWZmZXJlbnQgbG9hZGVycyB3aXRoIGRpZmZlcmVudCBwcm9qZWN0IElEcyBvciBwcm9qZWN0IHZlcnNpb25zLlxuQ29uZmxpY3RpbmcgdmFsdWVzOlxuJHtuZXdCdW5kbGUuYnVuZGxlS2V5fVxuJHt0aGlzLmJ1bmRsZS5idW5kbGVLZXl9YFxuICAgICAgKTtcbiAgICB9XG4gICAgLy8gTWVyZ2UgdGhlIG9sZCBidW5kbGUgaW50byB0aGUgbmV3IGJ1bmRsZSwgdGhpcyB3YXlcbiAgICAvLyB0aGUgbmV3IGJ1bmRsZSB3aWxsIGVuZm9yY2UgdGhlIGxhdGVzdCBkYXRhIGZyb20gdGhlIHNlcnZlclxuICAgIC8vIGFsbG93aW5nIGVsZW1lbnRzIHRvIGJlIGRlbGV0ZWQgYnkgbmV3ZXIgYnVuZGxlc1xuICAgIHRoaXMuYnVuZGxlID0gbWVyZ2VCdW5kbGVzKG5ld0J1bmRsZSwgdGhpcy5idW5kbGUpO1xuXG4gICAgdGhpcy5vbkJ1bmRsZU1lcmdlZD8uKCk7XG4gIH1cblxuICBnZXRCdW5kbGUoKTogTG9hZGVyQnVuZGxlT3V0cHV0IHtcbiAgICByZXR1cm4gdGhpcy5idW5kbGU7XG4gIH1cblxuICBjbGVhckNhY2hlKCkge1xuICAgIHRoaXMuYnVuZGxlID0ge1xuICAgICAgbW9kdWxlczoge1xuICAgICAgICBicm93c2VyOiBbXSxcbiAgICAgICAgc2VydmVyOiBbXSxcbiAgICAgIH0sXG4gICAgICBjb21wb25lbnRzOiBbXSxcbiAgICAgIGdsb2JhbEdyb3VwczogW10sXG4gICAgICBwcm9qZWN0czogW10sXG4gICAgICBhY3RpdmVTcGxpdHM6IFtdLFxuICAgICAgYnVuZGxlS2V5OiBudWxsLFxuICAgICAgZGVmZXJDaHVua3NCeURlZmF1bHQ6IGZhbHNlLFxuICAgICAgZGlzYWJsZVJvb3RMb2FkaW5nQm91bmRhcnlCeURlZmF1bHQ6IGZhbHNlLFxuICAgICAgZmlsdGVyZWRJZHM6IHt9LFxuICAgIH07XG4gICAgdGhpcy5yZWdpc3RyeS5jbGVhcigpO1xuICB9XG5cbiAgcmVnaXN0ZXJNb2R1bGVzKG1vZHVsZXM6IFJlY29yZDxzdHJpbmcsIGFueT4pIHtcbiAgICBpZiAoXG4gICAgICBPYmplY3Qua2V5cyhtb2R1bGVzKS5zb21lKFxuICAgICAgICAobmFtZSkgPT4gdGhpcy5yZWdpc3RyeS5nZXRSZWdpc3RlcmVkTW9kdWxlKG5hbWUpICE9PSBtb2R1bGVzW25hbWVdXG4gICAgICApXG4gICAgKSB7XG4gICAgICBpZiAoIXRoaXMucmVnaXN0cnkuaXNFbXB0eSgpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBcIkNhbGxpbmcgUGxhc21pY0NvbXBvbmVudExvYWRlci5yZWdpc3Rlck1vZHVsZXMoKSBhZnRlciBQbGFzbWljIGNvbXBvbmVudCBoYXMgcmVuZGVyZWQ7IHN0YXJ0aW5nIG92ZXIuXCJcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5yZWdpc3RyeS5jbGVhcigpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMobW9kdWxlcykpIHtcbiAgICAgICAgdGhpcy5yZWdpc3RyeS5yZWdpc3RlcihrZXksIG1vZHVsZXNba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc3Vic3RpdHV0ZUNvbXBvbmVudDxQPihcbiAgICBjb21wb25lbnQ6IFJlYWN0LkNvbXBvbmVudFR5cGU8UD4sXG4gICAgbmFtZTogQ29tcG9uZW50TG9va3VwU3BlY1xuICApIHtcbiAgICB0aGlzLmludGVybmFsU3Vic3RpdHV0ZUNvbXBvbmVudChjb21wb25lbnQsIG5hbWUsIHVuZGVmaW5lZCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgaW50ZXJuYWxTdWJzdGl0dXRlQ29tcG9uZW50PFA+KFxuICAgIGNvbXBvbmVudDogUmVhY3QuQ29tcG9uZW50VHlwZTxQPixcbiAgICBuYW1lOiBDb21wb25lbnRMb29rdXBTcGVjLFxuICAgIGNvZGVDb21wb25lbnRIZWxwZXJzOlxuICAgICAgfCBJbnRlcm5hbENvZGVDb21wb25lbnRIZWxwZXJzPFxuICAgICAgICAgIFJlYWN0LkNvbXBvbmVudFByb3BzPFJlYWN0LkNvbXBvbmVudFR5cGU8UD4+XG4gICAgICAgID5cbiAgICAgIHwgdW5kZWZpbmVkXG4gICkge1xuICAgIGlmICghdGhpcy5pc1JlZ2lzdHJ5RW1wdHkoKSkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBcIkNhbGxpbmcgUGxhc21pY0NvbXBvbmVudExvYWRlci5yZWdpc3RlclN1YnN0aXR1dGlvbigpIGFmdGVyIFBsYXNtaWMgY29tcG9uZW50IGhhcyByZW5kZXJlZDsgc3RhcnRpbmcgb3Zlci5cIlxuICAgICAgKTtcbiAgICAgIHRoaXMuY2xlYXJSZWdpc3RyeSgpO1xuICAgIH1cbiAgICB0aGlzLnN1YnMucHVzaCh7IGxvb2t1cDogbmFtZSwgY29tcG9uZW50LCBjb2RlQ29tcG9uZW50SGVscGVycyB9KTtcbiAgfVxuXG4gIGFic3RyYWN0IHJlZ2lzdGVyQ29tcG9uZW50PFQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnRUeXBlPGFueT4+KFxuICAgIGNvbXBvbmVudDogVCxcbiAgICBtZXRhOiBDb2RlQ29tcG9uZW50TWV0YTxSZWFjdC5Db21wb25lbnRQcm9wczxUPj5cbiAgKTogdm9pZDtcbiAgYWJzdHJhY3QgcmVnaXN0ZXJGdW5jdGlvbjxGIGV4dGVuZHMgKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnk+KFxuICAgIGZuOiBGLFxuICAgIG1ldGE6IEN1c3RvbUZ1bmN0aW9uTWV0YTxGPlxuICApOiB2b2lkO1xuICBhYnN0cmFjdCByZWdpc3Rlckdsb2JhbENvbnRleHQ8VCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudFR5cGU8YW55Pj4oXG4gICAgY29udGV4dDogVCxcbiAgICBtZXRhOiBHbG9iYWxDb250ZXh0TWV0YTxSZWFjdC5Db21wb25lbnRQcm9wczxUPj5cbiAgKTogdm9pZDtcbiAgYWJzdHJhY3QgcmVnaXN0ZXJUcmFpdCh0cmFpdDogc3RyaW5nLCBtZXRhOiBUcmFpdE1ldGEpOiB2b2lkO1xuICBhYnN0cmFjdCByZWdpc3RlclRva2VuKHRva2VuOiBUb2tlblJlZ2lzdHJhdGlvbik6IHZvaWQ7XG5cbiAgcHJvdGVjdGVkIHJlZnJlc2hSZWdpc3RyeSgpIHtcbiAgICAvLyBPbmNlIHdlIGhhdmUgcmVjZWl2ZWQgZGF0YSwgd2UgcmVnaXN0ZXIgY29tcG9uZW50cyB0b1xuICAgIC8vIHN1YnN0aXR1dGUuICBXZSBoYWQgdG8gd2FpdCBmb3IgZGF0YSB0byBkbyB0aGlzIHNvXG4gICAgLy8gdGhhdCB3ZSBjYW4gbG9vayB1cCB0aGUgcmlnaHQgbW9kdWxlIG5hbWUgdG8gc3Vic3RpdHV0ZVxuICAgIC8vIGluIGNvbXBvbmVudCBtZXRhLlxuICAgIGZvciAoY29uc3Qgc3ViIG9mIHRoaXMuc3Vicykge1xuICAgICAgY29uc3QgbWV0YXMgPSBnZXRDb21wTWV0YXModGhpcy5nZXRCdW5kbGUoKS5jb21wb25lbnRzLCBzdWIubG9va3VwKTtcbiAgICAgIG1ldGFzLmZvckVhY2goKG1ldGEpID0+IHtcbiAgICAgICAgU1VCU1RJVFVURURfQ09NUE9ORU5UU1ttZXRhLmlkXSA9IHN1Yi5jb21wb25lbnQ7XG4gICAgICAgIGlmIChzdWIuY29kZUNvbXBvbmVudEhlbHBlcnMpIHtcbiAgICAgICAgICBSRUdJU1RFUkVEX0NPREVfQ09NUE9ORU5UX0hFTFBFUlNbbWV0YS5pZF0gPSBzdWIuY29kZUNvbXBvbmVudEhlbHBlcnM7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMucmVnaXN0cnkudXBkYXRlTW9kdWxlcyh0aGlzLmdldEJ1bmRsZSgpKTtcbiAgfVxuXG4gIGlzUmVnaXN0cnlFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWdpc3RyeS5pc0VtcHR5KCk7XG4gIH1cblxuICBjbGVhclJlZ2lzdHJ5KCkge1xuICAgIHRoaXMucmVnaXN0cnkuY2xlYXIoKTtcbiAgfVxuXG4gIHNldEdsb2JhbFZhcmlhbnRzKGdsb2JhbFZhcmlhbnRzOiBHbG9iYWxWYXJpYW50U3BlY1tdKSB7XG4gICAgdGhpcy5nbG9iYWxWYXJpYW50cyA9IGdsb2JhbFZhcmlhbnRzO1xuICB9XG5cbiAgZ2V0R2xvYmFsVmFyaWFudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2xvYmFsVmFyaWFudHM7XG4gIH1cblxuICByZWdpc3RlclByZWZldGNoZWRCdW5kbGUoYnVuZGxlOiBMb2FkZXJCdW5kbGVPdXRwdXQpIHtcbiAgICAvLyBGb3IgUmVhY3QgU2VydmVyIENvbXBvbmVudHMgKE5leHQuanMgMTMrKSxcbiAgICAvLyB3ZSBuZWVkIHRvIHBhc3Mgc2VydmVyIG1vZHVsZXMgaW4gTG9hZGVyQnVuZGxlT3V0cHV0IGZyb20gU2VydmVyIENvbXBvbmVudHMgdG8gQ2xpZW50IENvbXBvbmVudHMuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBwYXNzIHRoZW0gdmlhIG5vcm1hbCBwYWdlIHByb3BzIGJlY2F1c2UgdGhhdCB3aWxsIGJlIHNlcmlhbGl6ZWQgdG8gdGhlIGJyb3dzZXIuXG4gICAgLy8gSW5zdGVhZCwgd2UgcGFzcyB0aGUgYnVuZGxlIChpbmNsdWRpbmcgdGhlIHNlcnZlciBtb2R1bGVzKSB2aWEgdGhlIE5vZGUgYGdsb2JhbGAgdmFyaWFibGUuXG4gICAgLy9cbiAgICAvLyBUaGlzIGlzIHRoZSBjb2RlIHRoYXQgcmVhZHMgdGhlIHN0b3JlZCBidW5kbGUgYW5kIG1lcmdlcyBpdCBiYWNrIGludG8gdGhlIGxvYWRlci5cbiAgICBpZiAoIWlzQnJvd3Nlcikge1xuICAgICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSBhIGNhY2hlZCBidW5kbGUgb24gdGhpcyBOb2RlIHNlcnZlci5cbiAgICAgIGNvbnN0IGNhY2hlZEJ1bmRsZSA9IGludGVybmFsX2dldENhY2hlZEJ1bmRsZUluTm9kZVNlcnZlcih0aGlzLm9wdHMpO1xuICAgICAgaWYgKGNhY2hlZEJ1bmRsZSkge1xuICAgICAgICAvLyBJZiBpdCdzIHRoZXJlLCBtZXJnZSB0aGUgY2FjaGVkIGJ1bmRsZSBmaXJzdC5cbiAgICAgICAgdGhpcy5tZXJnZUJ1bmRsZShjYWNoZWRCdW5kbGUpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm1lcmdlQnVuZGxlKGJ1bmRsZSk7XG4gIH1cblxuICBnZXRMb29rdXAoKSB7XG4gICAgcmV0dXJuIG5ldyBDb21wb25lbnRMb29rdXAodGhpcy5nZXRCdW5kbGUoKSwgdGhpcy5yZWdpc3RyeSk7XG4gIH1cblxuICB0cmFja0NvbnZlcnNpb24odmFsdWUgPSAwKSB7XG4gICAgdGhpcy50cmFja2VyLnRyYWNrQ29udmVyc2lvbih2YWx1ZSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZ2V0QWN0aXZlVmFyaWF0aW9uKFxuICAgIG9wdHM6IE9taXQ8UGFyYW1ldGVyczx0eXBlb2YgZ2V0QWN0aXZlVmFyaWF0aW9uPlswXSwgXCJzcGxpdHNcIj5cbiAgKSB7XG4gICAgYXdhaXQgdGhpcy5mZXRjaENvbXBvbmVudHMoKTtcbiAgICByZXR1cm4gZ2V0QWN0aXZlVmFyaWF0aW9uKHtcbiAgICAgIC4uLm9wdHMsXG4gICAgICBzcGxpdHM6IHRoaXMuZ2V0QnVuZGxlKCkuYWN0aXZlU3BsaXRzLFxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGdldFRlYW1JZHMoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiB1bmlxKFxuICAgICAgdGhpcy5nZXRCdW5kbGUoKVxuICAgICAgICAucHJvamVjdHMubWFwKChwKSA9PlxuICAgICAgICAgIHAudGVhbUlkID8gYCR7cC50ZWFtSWR9JHtwLmluZGlyZWN0ID8gXCJAaW5kaXJlY3RcIiA6IFwiXCJ9YCA6IG51bGxcbiAgICAgICAgKVxuICAgICAgICAuZmlsdGVyKCh4KTogeCBpcyBzdHJpbmcgPT4gISF4KVxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgZ2V0UHJvamVjdElkcygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHVuaXEoXG4gICAgICB0aGlzLmdldEJ1bmRsZSgpLnByb2plY3RzLm1hcChcbiAgICAgICAgKHApID0+IGAke3AuaWR9JHtwLmluZGlyZWN0ID8gXCJAaW5kaXJlY3RcIiA6IFwiXCJ9YFxuICAgICAgKVxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgdHJhY2tSZW5kZXIob3B0cz86IFRyYWNrUmVuZGVyT3B0aW9ucykge1xuICAgIHRoaXMudHJhY2tlci50cmFja1JlbmRlcihvcHRzKTtcbiAgfVxufVxuXG4vKipcbiAqIExpYnJhcnkgZm9yIGZldGNoaW5nIGNvbXBvbmVudCBkYXRhLCBhbmQgcmVnaXN0ZXJpbmdcbiAqIGN1c3RvbSBjb21wb25lbnRzLlxuICovXG5leHBvcnQgY2xhc3MgUGxhc21pY0NvbXBvbmVudExvYWRlciB7XG4gIHByaXZhdGUgX19pbnRlcm5hbDogQmFzZUludGVybmFsUGxhc21pY0NvbXBvbmVudExvYWRlcjtcblxuICBjb25zdHJ1Y3RvcihpbnRlcm5hbDogQmFzZUludGVybmFsUGxhc21pY0NvbXBvbmVudExvYWRlcikge1xuICAgIHRoaXMuX19pbnRlcm5hbCA9IGludGVybmFsO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgZ2xvYmFsIHZhcmlhbnRzIHRvIGJlIHVzZWQgZm9yIGFsbCBjb21wb25lbnRzLiAgTm90ZSB0aGF0XG4gICAqIHRoaXMgaXMgbm90IHJlYWN0aXZlLCBhbmQgd2lsbCBub3QgcmUtcmVuZGVyIGFsbCBjb21wb25lbnRzXG4gICAqIGFscmVhZHkgbW91bnRlZDsgaW5zdGVhZCwgaXQgc2hvdWxkIGJlIHVzZWQgdG8gYWN0aXZhdGUgZ2xvYmFsXG4gICAqIHZhcmlhbnRzIHRoYXQgc2hvdWxkIGFsd2F5cyBiZSBhY3RpdmF0ZWQgZm9yIHRoZSBsaWZldGltZSBvZiB0aGlzXG4gICAqIGFwcC4gIElmIHlvdSdkIGxpa2UgdG8gcmVhY3RpdmVseSBjaGFuZ2UgdGhlIGdsb2JhbCB2YXJpYW50cyxcbiAgICogeW91IHNob3VsZCBzcGVjaWZ5IHRoZW0gdmlhIDxQbGFzbWljUm9vdFByb3ZpZGVyIC8+XG4gICAqL1xuICBzZXRHbG9iYWxWYXJpYW50cyhnbG9iYWxWYXJpYW50czogR2xvYmFsVmFyaWFudFNwZWNbXSkge1xuICAgIHRoaXMuX19pbnRlcm5hbC5zZXRHbG9iYWxWYXJpYW50cyhnbG9iYWxWYXJpYW50cyk7XG4gIH1cblxuICByZWdpc3Rlck1vZHVsZXMobW9kdWxlczogUmVjb3JkPHN0cmluZywgYW55Pikge1xuICAgIHRoaXMuX19pbnRlcm5hbC5yZWdpc3Rlck1vZHVsZXMobW9kdWxlcyk7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgY3VzdG9tIGNvbXBvbmVudHMgdGhhdCBzaG91bGQgYmUgc3dhcHBlZCBpbiBmb3JcbiAgICogY29tcG9uZW50cyBkZWZpbmVkIGluIHlvdXIgcHJvamVjdC4gIFlvdSBjYW4gdXNlIHRoaXMgdG9cbiAgICogc3dhcCBpbiAvIHN1YnN0aXR1dGUgYSBQbGFzbWljIGNvbXBvbmVudCB3aXRoIGEgXCJyZWFsXCIgY29tcG9uZW50LlxuICAgKi9cbiAgc3Vic3RpdHV0ZUNvbXBvbmVudDxQPihcbiAgICBjb21wb25lbnQ6IFJlYWN0LkNvbXBvbmVudFR5cGU8UD4sXG4gICAgbmFtZTogQ29tcG9uZW50TG9va3VwU3BlY1xuICApIHtcbiAgICB0aGlzLl9faW50ZXJuYWwuc3Vic3RpdHV0ZUNvbXBvbmVudChjb21wb25lbnQsIG5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGNvZGUgY29tcG9uZW50cyB0byBiZSB1c2VkIG9uIFBsYXNtaWMgRWRpdG9yLlxuICAgKi9cbiAgcmVnaXN0ZXJDb21wb25lbnQ8VCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudFR5cGU8YW55Pj4oXG4gICAgY29tcG9uZW50OiBULFxuICAgIG1ldGE6IENvZGVDb21wb25lbnRNZXRhPFJlYWN0LkNvbXBvbmVudFByb3BzPFQ+PlxuICApOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBbW2RlcHJlY2F0ZWRdXSBQbGVhc2UgdXNlIGBzdWJzdGl0dXRlQ29tcG9uZW50YCBpbnN0ZWFkIGZvciBjb21wb25lbnRcbiAgICogc3Vic3RpdHV0aW9uLCBvciB0aGUgb3RoZXIgYHJlZ2lzdGVyQ29tcG9uZW50YCBvdmVybG9hZCB0byByZWdpc3RlclxuICAgKiBjb2RlIGNvbXBvbmVudHMgdG8gYmUgdXNlZCBvbiBQbGFzbWljIEVkaXRvci5cbiAgICpcbiAgICogQHNlZSBgc3Vic3RpdHV0ZUNvbXBvbmVudGBcbiAgICovXG4gIHJlZ2lzdGVyQ29tcG9uZW50PFQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnRUeXBlPGFueT4+KFxuICAgIGNvbXBvbmVudDogVCxcbiAgICBuYW1lOiBDb21wb25lbnRMb29rdXBTcGVjXG4gICk6IHZvaWQ7XG5cbiAgcmVnaXN0ZXJDb21wb25lbnQ8VCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudFR5cGU8YW55Pj4oXG4gICAgY29tcG9uZW50OiBULFxuICAgIG1ldGFPck5hbWU6IENvbXBvbmVudExvb2t1cFNwZWMgfCBDb2RlQ29tcG9uZW50TWV0YTxSZWFjdC5Db21wb25lbnRQcm9wczxUPj5cbiAgKSB7XG4gICAgLy8gJ3Byb3BzJyBpcyBhIHJlcXVpcmVkIGZpZWxkIGluIENvZGVDb21wb25lbnRNZXRhXG4gICAgaWYgKG1ldGFPck5hbWUgJiYgdHlwZW9mIG1ldGFPck5hbWUgPT09IFwib2JqZWN0XCIgJiYgXCJwcm9wc1wiIGluIG1ldGFPck5hbWUpIHtcbiAgICAgIHRoaXMuX19pbnRlcm5hbC5yZWdpc3RlckNvbXBvbmVudChjb21wb25lbnQsIG1ldGFPck5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEZXByZWNhdGVkIGNhbGxcbiAgICAgIGlmIChcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIiAmJlxuICAgICAgICAhdGhpcy53YXJuZWRSZWdpc3RlckNvbXBvbmVudFxuICAgICAgKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBgUGxhc21pY0xvYWRlcjogVXNpbmcgZGVwcmVjYXRlZCBtZXRob2QgXFxgcmVnaXN0ZXJDb21wb25lbnRcXGAgZm9yIGNvbXBvbmVudCBzdWJzdGl0dXRpb24uIGAgK1xuICAgICAgICAgICAgYFBsZWFzZSBjb25zaWRlciB1c2luZyBcXGBzdWJzdGl0dXRlQ29tcG9uZW50XFxgIGluc3RlYWQuYFxuICAgICAgICApO1xuICAgICAgICB0aGlzLndhcm5lZFJlZ2lzdGVyQ29tcG9uZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3Vic3RpdHV0ZUNvbXBvbmVudChjb21wb25lbnQsIG1ldGFPck5hbWUpO1xuICAgIH1cbiAgfVxuICBwcml2YXRlIHdhcm5lZFJlZ2lzdGVyQ29tcG9uZW50ID0gZmFsc2U7XG5cbiAgcmVnaXN0ZXJGdW5jdGlvbjxGIGV4dGVuZHMgKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnk+KFxuICAgIGZuOiBGLFxuICAgIG1ldGE6IEN1c3RvbUZ1bmN0aW9uTWV0YTxGPlxuICApIHtcbiAgICB0aGlzLl9faW50ZXJuYWwucmVnaXN0ZXJGdW5jdGlvbihmbiwgbWV0YSk7XG4gIH1cblxuICByZWdpc3Rlckdsb2JhbENvbnRleHQ8VCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudFR5cGU8YW55Pj4oXG4gICAgY29udGV4dDogVCxcbiAgICBtZXRhOiBHbG9iYWxDb250ZXh0TWV0YTxSZWFjdC5Db21wb25lbnRQcm9wczxUPj5cbiAgKSB7XG4gICAgdGhpcy5fX2ludGVybmFsLnJlZ2lzdGVyR2xvYmFsQ29udGV4dChjb250ZXh0LCBtZXRhKTtcbiAgfVxuXG4gIHJlZ2lzdGVyVHJhaXQodHJhaXQ6IHN0cmluZywgbWV0YTogVHJhaXRNZXRhKSB7XG4gICAgdGhpcy5fX2ludGVybmFsLnJlZ2lzdGVyVHJhaXQodHJhaXQsIG1ldGEpO1xuICB9XG5cbiAgcmVnaXN0ZXJUb2tlbih0b2tlbjogVG9rZW5SZWdpc3RyYXRpb24pIHtcbiAgICB0aGlzLl9faW50ZXJuYWwucmVnaXN0ZXJUb2tlbih0b2tlbik7XG4gIH1cblxuICAvKipcbiAgICogUHJlLWZldGNoZXMgY29tcG9uZW50IGRhdGEgbmVlZGVkIHRvIGZvciBQbGFzbWljTG9hZGVyIHRvIHJlbmRlclxuICAgKiB0aGVzZSBjb21wb25lbnRzLiAgU2hvdWxkIGJlIHBhc3NlZCBpbnRvIFBsYXNtaWNSb290UHJvdmlkZXIgYXNcbiAgICogdGhlIHByZWZldGNoZWREYXRhIHByb3AuXG4gICAqXG4gICAqIFlvdSBjYW4gbG9vayB1cCBhIGNvbXBvbmVudCBlaXRoZXIgYnk6XG4gICAqIC0gdGhlIG5hbWUgb2YgdGhlIGNvbXBvbmVudFxuICAgKiAtIHRoZSBwYXRoIGZvciBhIHBhZ2UgY29tcG9uZW50XG4gICAqIC0gYW4gYXJyYXkgb2Ygc3RyaW5ncyB0aGF0IG1ha2UgdXAgcGFydHMgb2YgdGhlIHBhdGhcbiAgICogLSBvYmplY3QgeyBuYW1lOiBcIm5hbWVfb3JfcGF0aFwiLCBwcm9qZWN0SWQ6IC4uLn0sIHRvIHNwZWNpZnkgd2hpY2ggcHJvamVjdFxuICAgKiAgIHRvIHVzZSwgaWYgbXVsdGlwbGUgcHJvamVjdHMgaGF2ZSB0aGUgc2FtZSBjb21wb25lbnQgbmFtZVxuICAgKlxuICAgKiBUaHJvd3MgYW4gRXJyb3IgaWYgYSBzcGVjaWZpZWQgY29tcG9uZW50IHRvIGZldGNoIGRvZXMgbm90IGV4aXN0IGluXG4gICAqIHRoZSBQbGFzbWljIHByb2plY3QuXG4gICAqL1xuICBmZXRjaENvbXBvbmVudERhdGEoXG4gICAgLi4uc3BlY3M6IENvbXBvbmVudExvb2t1cFNwZWNbXVxuICApOiBQcm9taXNlPENvbXBvbmVudFJlbmRlckRhdGE+O1xuICBmZXRjaENvbXBvbmVudERhdGEoXG4gICAgc3BlY3M6IENvbXBvbmVudExvb2t1cFNwZWNbXSxcbiAgICBvcHRzPzogRmV0Y2hDb21wb25lbnREYXRhT3B0c1xuICApOiBQcm9taXNlPENvbXBvbmVudFJlbmRlckRhdGE+O1xuICBmZXRjaENvbXBvbmVudERhdGEoLi4uYXJnczogYW55W10pOiBQcm9taXNlPENvbXBvbmVudFJlbmRlckRhdGE+IHtcbiAgICByZXR1cm4gdGhpcy5fX2ludGVybmFsLmZldGNoQ29tcG9uZW50RGF0YSguLi5hcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaWtlIGZldGNoQ29tcG9uZW50RGF0YSgpLCBidXQgcmV0dXJucyBudWxsIGluc3RlYWQgb2YgdGhyb3dpbmcgYW4gRXJyb3JcbiAgICogd2hlbiBhIGNvbXBvbmVudCBpcyBub3QgZm91bmQuICBVc2VmdWwgd2hlbiB5b3UgYXJlIGltcGxlbWVudGluZyBhIGNhdGNoLWFsbFxuICAgKiBwYWdlIGFuZCB3YW50IHRvIGNoZWNrIGlmIGEgc3BlY2lmaWMgcGF0aCBoYWQgYmVlbiBkZWZpbmVkIGZvciBQbGFzbWljLlxuICAgKi9cbiAgYXN5bmMgbWF5YmVGZXRjaENvbXBvbmVudERhdGEoXG4gICAgLi4uc3BlY3M6IENvbXBvbmVudExvb2t1cFNwZWNbXVxuICApOiBQcm9taXNlPENvbXBvbmVudFJlbmRlckRhdGEgfCBudWxsPjtcbiAgYXN5bmMgbWF5YmVGZXRjaENvbXBvbmVudERhdGEoXG4gICAgc3BlY3M6IENvbXBvbmVudExvb2t1cFNwZWNbXSxcbiAgICBvcHRzPzogRmV0Y2hDb21wb25lbnREYXRhT3B0c1xuICApOiBQcm9taXNlPENvbXBvbmVudFJlbmRlckRhdGEgfCBudWxsPjtcbiAgYXN5bmMgbWF5YmVGZXRjaENvbXBvbmVudERhdGEoXG4gICAgLi4uYXJnczogYW55W11cbiAgKTogUHJvbWlzZTxDb21wb25lbnRSZW5kZXJEYXRhIHwgbnVsbD4ge1xuICAgIHJldHVybiB0aGlzLl9faW50ZXJuYWwubWF5YmVGZXRjaENvbXBvbmVudERhdGEoLi4uYXJncyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbGwgdGhlIHBhZ2UgY29tcG9uZW50IG1ldGFkYXRhIGZvciB0aGVzZSBwcm9qZWN0cy5cbiAgICovXG4gIGFzeW5jIGZldGNoUGFnZXMob3B0cz86IEZldGNoUGFnZXNPcHRzKSB7XG4gICAgcmV0dXJuIHRoaXMuX19pbnRlcm5hbC5mZXRjaFBhZ2VzKG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIGNvbXBvbmVudHMgbWV0YWRhdGEgZm9yIHRoZXNlIHByb2plY3RzLlxuICAgKi9cbiAgYXN5bmMgZmV0Y2hDb21wb25lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9faW50ZXJuYWwuZmV0Y2hDb21wb25lbnRzKCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgX2dldEFjdGl2ZVZhcmlhdGlvbihcbiAgICBvcHRzOiBQYXJhbWV0ZXJzPHR5cGVvZiB0aGlzLl9faW50ZXJuYWwuZ2V0QWN0aXZlVmFyaWF0aW9uPlswXVxuICApIHtcbiAgICByZXR1cm4gdGhpcy5fX2ludGVybmFsLmdldEFjdGl2ZVZhcmlhdGlvbihvcHRzKTtcbiAgfVxuXG4gIGFzeW5jIGdldEFjdGl2ZVZhcmlhdGlvbihvcHRzOiB7XG4gICAga25vd24/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICAgIHRyYWl0czogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbj47XG4gIH0pIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0QWN0aXZlVmFyaWF0aW9uKHtcbiAgICAgIHRyYWl0czogb3B0cy50cmFpdHMsXG4gICAgICBnZXRLbm93blZhbHVlOiAoa2V5OiBzdHJpbmcpID0+IHtcbiAgICAgICAgaWYgKG9wdHMua25vd24pIHtcbiAgICAgICAgICByZXR1cm4gb3B0cy5rbm93bltrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGNvb2tpZXMgPSBnZXRQbGFzbWljQ29va2llVmFsdWVzKCk7XG4gICAgICAgICAgcmV0dXJuIGNvb2tpZXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVwZGF0ZUtub3duVmFsdWU6IChrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZykgPT4ge1xuICAgICAgICBpZiAoIW9wdHMua25vd24pIHtcbiAgICAgICAgICB1cGRhdGVQbGFzbWljQ29va2llVmFsdWUoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICBnZXRDaHVua3NVcmwoYnVuZGxlOiBMb2FkZXJCdW5kbGVPdXRwdXQsIG1vZHVsZXM6IENvZGVNb2R1bGVbXSkge1xuICAgIHJldHVybiB0aGlzLl9faW50ZXJuYWwuZ2V0Q2h1bmtzVXJsKGJ1bmRsZSwgbW9kdWxlcyk7XG4gIH1cblxuICBnZXRFeHRlcm5hbFZhcmlhdGlvbihcbiAgICB2YXJpYXRpb246IFJlY29yZDxzdHJpbmcsIHN0cmluZz4sXG4gICAgZmlsdGVycz86IFBhcmFtZXRlcnM8dHlwZW9mIGdldEV4dGVybmFsSWRzPlsyXVxuICApIHtcbiAgICByZXR1cm4gZ2V0RXh0ZXJuYWxJZHModGhpcy5nZXRBY3RpdmVTcGxpdHMoKSwgdmFyaWF0aW9uLCBmaWx0ZXJzKTtcbiAgfVxuXG4gIGdldEFjdGl2ZVNwbGl0cygpIHtcbiAgICByZXR1cm4gdGhpcy5fX2ludGVybmFsLmdldEFjdGl2ZVNwbGl0cygpO1xuICB9XG5cbiAgdHJhY2tDb252ZXJzaW9uKHZhbHVlID0gMCkge1xuICAgIHRoaXMuX19pbnRlcm5hbC50cmFja0NvbnZlcnNpb24odmFsdWUpO1xuICB9XG5cbiAgY2xlYXJDYWNoZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fX2ludGVybmFsLmNsZWFyQ2FjaGUoKTtcbiAgfVxufVxuIiwiaW1wb3J0IHtcbiAgQ29tcG9uZW50TWV0YSxcbiAgZ2V0QnVuZGxlU3Vic2V0LFxuICBMb2FkZXJCdW5kbGVPdXRwdXQsXG59IGZyb20gXCJAcGxhc21pY2FwcC9sb2FkZXItY29yZVwiO1xuaW1wb3J0IHR5cGUgeyBDb21wb25lbnRSZW5kZXJEYXRhIH0gZnJvbSBcIi4vbG9hZGVyLXNoYXJlZFwiO1xuaW1wb3J0IHsgaW50ZXJzZWN0IH0gZnJvbSBcIi4vdXRpbHNcIjtcblxuZnVuY3Rpb24gZ2V0VXNlZENvbXBzKGFsbENvbXBvbmVudHM6IENvbXBvbmVudE1ldGFbXSwgZW50cnlDb21wSWRzOiBzdHJpbmdbXSkge1xuICBjb25zdCBxOiBzdHJpbmdbXSA9IFsuLi5lbnRyeUNvbXBJZHNdO1xuICBjb25zdCBzZWVuSWRzID0gbmV3IFNldDxzdHJpbmc+KGVudHJ5Q29tcElkcyk7XG4gIGNvbnN0IGNvbXBvbmVudE1ldGFCeUlkID0gbmV3IE1hcDxzdHJpbmcsIENvbXBvbmVudE1ldGE+KFxuICAgIGFsbENvbXBvbmVudHMubWFwKChtZXRhKSA9PiBbbWV0YS5pZCwgbWV0YV0pXG4gICk7XG4gIGNvbnN0IHVzZWRDb21wczogQ29tcG9uZW50TWV0YVtdID0gW107XG4gIHdoaWxlIChxLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBbaWRdID0gcS5zcGxpY2UoMCwgMSk7XG4gICAgY29uc3QgbWV0YSA9IGNvbXBvbmVudE1ldGFCeUlkLmdldChpZCk7XG4gICAgaWYgKCFtZXRhKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdXNlZENvbXBzLnB1c2gobWV0YSk7XG4gICAgbWV0YS51c2VkQ29tcG9uZW50cy5mb3JFYWNoKCh1c2VkQ29tcElkKSA9PiB7XG4gICAgICBpZiAoIXNlZW5JZHMuaGFzKHVzZWRDb21wSWQpKSB7XG4gICAgICAgIHNlZW5JZHMuYWRkKHVzZWRDb21wSWQpO1xuICAgICAgICBxLnB1c2godXNlZENvbXBJZCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHVzZWRDb21wcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByZXBDb21wb25lbnREYXRhKFxuICBidW5kbGU6IExvYWRlckJ1bmRsZU91dHB1dCxcbiAgY29tcE1ldGFzOiBDb21wb25lbnRNZXRhW10sXG4gIG9wdHM/OiB7XG4gICAgdGFyZ2V0PzogXCJicm93c2VyXCIgfCBcInNlcnZlclwiO1xuICB9XG4pOiBDb21wb25lbnRSZW5kZXJEYXRhIHtcbiAgaWYgKGNvbXBNZXRhcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4ge1xuICAgICAgZW50cnlDb21wTWV0YXM6IGJ1bmRsZS5jb21wb25lbnRzLFxuICAgICAgYnVuZGxlOiBidW5kbGUsXG4gICAgICByZW1vdGVGb250VXJsczogW10sXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IHVzZWRDb21wcyA9IGdldFVzZWRDb21wcyhcbiAgICBidW5kbGUuY29tcG9uZW50cyxcbiAgICBjb21wTWV0YXMubWFwKChjb21wTWV0YSkgPT4gY29tcE1ldGEuaWQpXG4gICk7XG4gIGNvbnN0IGNvbXBQYXRocyA9IHVzZWRDb21wcy5tYXAoKGNvbXBNZXRhKSA9PiBjb21wTWV0YS5lbnRyeSk7XG4gIGNvbnN0IHN1YkJ1bmRsZSA9IGdldEJ1bmRsZVN1YnNldChcbiAgICBidW5kbGUsXG4gICAgW1xuICAgICAgXCJlbnRyeXBvaW50LmNzc1wiLFxuICAgICAgLi4uY29tcFBhdGhzLFxuICAgICAgXCJyb290LXByb3ZpZGVyLmpzXCIsXG4gICAgICAuLi5idW5kbGUucHJvamVjdHNcbiAgICAgICAgLm1hcCgoeCkgPT4geC5nbG9iYWxDb250ZXh0c1Byb3ZpZGVyRmlsZU5hbWUpXG4gICAgICAgIC5maWx0ZXIoKHgpID0+ICEheCksXG4gICAgICAvLyBXZSBuZWVkIHRvIGV4cGxpY2l0bHkgaW5jbHVkZSBnbG9iYWwgY29udGV4dCBwcm92aWRlciBjb21wb25lbnRzXG4gICAgICAvLyB0byBtYWtlIHN1cmUgdGhleSBhcmUga2VwdCBpbiBidW5kbGUuY29tcG9uZW50cy4gVGhhdCdzIGJlY2F1c2VcbiAgICAgIC8vIGZvciBlc2J1aWxkLCBqdXN0IHRoZSBnbG9iYWxDb250ZXh0c1Byb3ZpZGVyRmlsZU5hbWUgaXMgbm90IGVub3VnaCxcbiAgICAgIC8vIGJlY2F1c2UgaXQgd2lsbCBpbXBvcnQgYSBjaHVuayB0aGF0IGluY2x1ZGVzIHRoZSBnbG9iYWwgY29udGV4dFxuICAgICAgLy8gY29tcG9uZW50LCBpbnN0ZWFkIG9mIGltcG9ydGluZyB0aGF0IGdsb2JhbCBjb250ZXh0IGNvbXBvbmVudCdzXG4gICAgICAvLyBlbnRyeSBmaWxlLiBBbmQgYmVjYXVzZSBub3RoaW5nIGRlcGVuZHMgb24gdGhlIGdsb2JhbCBjb250ZXh0IGNvbXBvbmVudCdzXG4gICAgICAvLyBlbnRyeSBmaWxlLCB3ZSBlbmQgdXAgZXhjbHVkaW5nIHRoZSBnbG9iYWwgY29udGV4dCBjb21wb25lbnQgZnJvbVxuICAgICAgLy8gYnVuZGxlLmNvbXBvbmVudHMsIHdoaWNoIHRoZW4gbWFrZXMgaXRzIHN1YnN0aXR1dGlvbiBub3Qgd29yay5cbiAgICAgIC8vIEluc3RlYWQsIHdlIGZvcmNpYmx5IGluY2x1ZGUgaXQgaGVyZSAod2UnbGwgZGVmaW5pdGVseSBuZWVkIGl0IGFueXdheSEpLlxuICAgICAgLi4uYnVuZGxlLmNvbXBvbmVudHNcbiAgICAgICAgLmZpbHRlcigoYykgPT4gYy5pc0dsb2JhbENvbnRleHRQcm92aWRlcilcbiAgICAgICAgLm1hcCgoYykgPT4gYy5lbnRyeSksXG4gICAgICAuLi5idW5kbGUuZ2xvYmFsR3JvdXBzLm1hcCgoZykgPT4gZy5jb250ZXh0RmlsZSksXG4gICAgXSxcbiAgICBvcHRzXG4gICk7XG5cbiAgY29uc3QgcmVtb3RlRm9udFVybHM6IHN0cmluZ1tdID0gW107XG4gIHN1YkJ1bmRsZS5wcm9qZWN0cy5mb3JFYWNoKChwKSA9PlxuICAgIHJlbW90ZUZvbnRVcmxzLnB1c2goLi4ucC5yZW1vdGVGb250cy5tYXAoKGYpID0+IGYudXJsKSlcbiAgKTtcblxuICByZXR1cm4ge1xuICAgIGVudHJ5Q29tcE1ldGFzOiBjb21wTWV0YXMsXG4gICAgYnVuZGxlOiBzdWJCdW5kbGUsXG4gICAgcmVtb3RlRm9udFVybHMsXG4gIH07XG59XG5cbi8vIEl0J3MgaW1wb3J0YW50IHRvIGRlZXAgY2xvbmUgYW55IGF0dHJpYnV0ZXMgdGhhdCBhcmUgZ29pbmcgdG8gYmUgY2hhbmdlZCBpbiB0aGVcbi8vIHRhcmdldCBidW5kbGUsIHNpbmNlIHRoZSBidWlsZCBvZiBwYWdlcyBjYW4gYmUgZG9uZSBpbiBtdWx0aXBsZSBzdGFnZXMvcHJvY2Vzc2VzXG4vLyB3ZSBkb24ndCB3YW50IHRvIG11dGF0ZSB0aGUgb3JpZ2luYWwgYnVuZGxlLCB3aGljaCBjYW4gaW1wYWN0IG90aGVyIHBhZ2VzLlxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlQnVuZGxlcyhcbiAgdGFyZ2V0OiBMb2FkZXJCdW5kbGVPdXRwdXQsXG4gIGZyb206IExvYWRlckJ1bmRsZU91dHB1dFxuKSB7XG4gIGNvbnN0IGV4aXN0aW5nUHJvamVjdHMgPSBuZXcgU2V0KHRhcmdldC5wcm9qZWN0cy5tYXAoKHApID0+IHAuaWQpKTtcbiAgY29uc3QgbmV3UHJvamVjdHMgPSBmcm9tLnByb2plY3RzLmZpbHRlcigocCkgPT4gIWV4aXN0aW5nUHJvamVjdHMuaGFzKHAuaWQpKTtcbiAgaWYgKG5ld1Byb2plY3RzLmxlbmd0aCA+IDApIHtcbiAgICB0YXJnZXQgPSB7XG4gICAgICAuLi50YXJnZXQsXG4gICAgICBwcm9qZWN0czogWy4uLnRhcmdldC5wcm9qZWN0cywgLi4ubmV3UHJvamVjdHNdLFxuICAgIH07XG4gIH1cblxuICBjb25zdCBleGlzdGluZ0NvbXBJZHMgPSBuZXcgU2V0KHRhcmdldC5jb21wb25lbnRzLm1hcCgoYykgPT4gYy5pZCkpO1xuXG4gIGZ1bmN0aW9uIHNob3VsZEluY2x1ZGVDb21wb25lbnRJbkJ1bmRsZShjOiBDb21wb25lbnRNZXRhKSB7XG4gICAgLy8gSWYgdGhlIGNvbXBvbmVudCBpcyBhbHJlYWR5IHByZXNlbnQgaW4gdGhlIHRhcmdldCBidW5kbGUsIGRvbid0IGluY2x1ZGUgaXRcbiAgICBpZiAoZXhpc3RpbmdDb21wSWRzLmhhcyhjLmlkKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgY29tcG9uZW50IGJlbG9uZ3MgdG8gYSBwcm9qZWN0IHRoYXQgaXMgbm90IHByZXNlbnQgaW4gdGhlIHRhcmdldCBidW5kbGUsXG4gICAgLy8gaW5jbHVkZSBpdFxuICAgIGlmICghZXhpc3RpbmdQcm9qZWN0cy5oYXMoYy5wcm9qZWN0SWQpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gSWYgdGhlIGNvbXBvbmVudCBpcyBwcmVzZW50IGluIHRoZSBmaWx0ZXJlZElkcyBvZiB0aGUgcHJvamVjdCBpdCBiZWxvbmdzIHRvLFxuICAgIC8vIGluIHRoZSB0YXJnZXQgYnVuZGxlLCB3ZSBjb25zaWRlciB0aGF0IHRoZSBjb21wb25lbnQgd2FzIG5vdCBkZWxldGVkIGluIHRoZSB0YXJnZXRcbiAgICAvLyBidW5kbGUsIHNvIHdlIGNhbiBpbmNsdWRlIGl0XG4gICAgY29uc3QgdGFyZ2V0QnVuZGxlRmlsdGVyZWRJZHMgPSB0YXJnZXQuZmlsdGVyZWRJZHNbYy5wcm9qZWN0SWRdID8/IFtdO1xuICAgIHJldHVybiB0YXJnZXRCdW5kbGVGaWx0ZXJlZElkcy5pbmNsdWRlcyhjLmlkKTtcbiAgfVxuXG4gIGNvbnN0IG5ld0NvbXBNZXRhcyA9IGZyb20uY29tcG9uZW50cy5maWx0ZXIoKG0pID0+XG4gICAgc2hvdWxkSW5jbHVkZUNvbXBvbmVudEluQnVuZGxlKG0pXG4gICk7XG4gIGlmIChuZXdDb21wTWV0YXMubGVuZ3RoID4gMCkge1xuICAgIHRhcmdldCA9IHtcbiAgICAgIC4uLnRhcmdldCxcbiAgICAgIGNvbXBvbmVudHM6IFsuLi50YXJnZXQuY29tcG9uZW50cywgLi4ubmV3Q29tcE1ldGFzXSxcbiAgICB9O1xuXG4gICAgLy8gRGVlcCBjbG9uZSB0aGUgZmlsdGVyZWRJZHMgb2JqZWN0IHRvIGF2b2lkIG11dGF0aW5nIHRoZSBvcmlnaW5hbCBidW5kbGVcbiAgICB0YXJnZXQuZmlsdGVyZWRJZHMgPSBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICBPYmplY3QuZW50cmllcyh0YXJnZXQuZmlsdGVyZWRJZHMpLm1hcCgoW2ssIHZdKSA9PiBbaywgWy4uLnZdXSlcbiAgICApO1xuXG4gICAgZnJvbS5wcm9qZWN0cy5mb3JFYWNoKChmcm9tUHJvamVjdCkgPT4ge1xuICAgICAgY29uc3QgcHJvamVjdElkID0gZnJvbVByb2plY3QuaWQ7XG4gICAgICBjb25zdCBmcm9tQnVuZGxlRmlsdGVyZWRJZHMgPSBmcm9tLmZpbHRlcmVkSWRzW3Byb2plY3RJZF0gPz8gW107XG4gICAgICBpZiAoIWV4aXN0aW5nUHJvamVjdHMuaGFzKHByb2plY3RJZCkpIHtcbiAgICAgICAgdGFyZ2V0LmZpbHRlcmVkSWRzW3Byb2plY3RJZF0gPSBbLi4uZnJvbUJ1bmRsZUZpbHRlcmVkSWRzXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldC5maWx0ZXJlZElkc1twcm9qZWN0SWRdID0gaW50ZXJzZWN0KFxuICAgICAgICAgIHRhcmdldC5maWx0ZXJlZElkc1twcm9qZWN0SWRdID8/IFtdLFxuICAgICAgICAgIGZyb21CdW5kbGVGaWx0ZXJlZElkc1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgY29uc3QgZXhpc3RpbmdNb2R1bGVzID0ge1xuICAgIGJyb3dzZXI6IG5ldyBTZXQodGFyZ2V0Lm1vZHVsZXMuYnJvd3Nlci5tYXAoKG0pID0+IG0uZmlsZU5hbWUpKSxcbiAgICBzZXJ2ZXI6IG5ldyBTZXQodGFyZ2V0Lm1vZHVsZXMuc2VydmVyLm1hcCgobSkgPT4gbS5maWxlTmFtZSkpLFxuICB9O1xuICBjb25zdCBuZXdNb2R1bGVzID0ge1xuICAgIGJyb3dzZXI6IGZyb20ubW9kdWxlcy5icm93c2VyLmZpbHRlcihcbiAgICAgIChtKSA9PiAhZXhpc3RpbmdNb2R1bGVzLmJyb3dzZXIuaGFzKG0uZmlsZU5hbWUpXG4gICAgKSxcbiAgICBzZXJ2ZXI6IGZyb20ubW9kdWxlcy5zZXJ2ZXIuZmlsdGVyKFxuICAgICAgKG0pID0+ICFleGlzdGluZ01vZHVsZXMuc2VydmVyLmhhcyhtLmZpbGVOYW1lKVxuICAgICksXG4gIH07XG4gIGlmIChuZXdNb2R1bGVzLmJyb3dzZXIubGVuZ3RoID4gMCB8fCBuZXdNb2R1bGVzLnNlcnZlci5sZW5ndGggPiAwKSB7XG4gICAgdGFyZ2V0ID0ge1xuICAgICAgLi4udGFyZ2V0LFxuICAgICAgbW9kdWxlczoge1xuICAgICAgICBicm93c2VyOiBbLi4udGFyZ2V0Lm1vZHVsZXMuYnJvd3NlciwgLi4ubmV3TW9kdWxlcy5icm93c2VyXSxcbiAgICAgICAgc2VydmVyOiBbLi4udGFyZ2V0Lm1vZHVsZXMuc2VydmVyLCAuLi5uZXdNb2R1bGVzLnNlcnZlcl0sXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICBjb25zdCBleGlzdGluZ0dsb2JhbElkcyA9IG5ldyBTZXQodGFyZ2V0Lmdsb2JhbEdyb3Vwcy5tYXAoKGcpID0+IGcuaWQpKTtcbiAgY29uc3QgbmV3R2xvYmFscyA9IGZyb20uZ2xvYmFsR3JvdXBzLmZpbHRlcihcbiAgICAoZykgPT4gIWV4aXN0aW5nR2xvYmFsSWRzLmhhcyhnLmlkKVxuICApO1xuICBpZiAobmV3R2xvYmFscy5sZW5ndGggPiAwKSB7XG4gICAgdGFyZ2V0ID0ge1xuICAgICAgLi4udGFyZ2V0LFxuICAgICAgZ2xvYmFsR3JvdXBzOiBbLi4udGFyZ2V0Lmdsb2JhbEdyb3VwcywgLi4ubmV3R2xvYmFsc10sXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IGV4aXN0aW5nU3BsaXRJZHMgPSBuZXcgU2V0KHRhcmdldC5hY3RpdmVTcGxpdHMubWFwKChzKSA9PiBzLmlkKSk7XG4gIGNvbnN0IG5ld1NwbGl0cyA9XG4gICAgZnJvbS5hY3RpdmVTcGxpdHMuZmlsdGVyKFxuICAgICAgLy8gRG9uJ3QgaW5jbHVkZSBzcGxpdHMgYmVsb25naW5nIHRvIHByb2plY3RzIGFscmVhZHkgcHJlc2VudFxuICAgICAgLy8gaW4gdGhlIHRhcmdldCBidW5kbGVcbiAgICAgIChzKSA9PiAhZXhpc3RpbmdTcGxpdElkcy5oYXMocy5pZCkgJiYgIWV4aXN0aW5nUHJvamVjdHMuaGFzKHMucHJvamVjdElkKVxuICAgICkgPz8gW107XG4gIGlmIChuZXdTcGxpdHMubGVuZ3RoID4gMCkge1xuICAgIHRhcmdldCA9IHtcbiAgICAgIC4uLnRhcmdldCxcbiAgICAgIGFjdGl2ZVNwbGl0czogWy4uLnRhcmdldC5hY3RpdmVTcGxpdHMsIC4uLm5ld1NwbGl0c10sXG4gICAgfTtcbiAgfVxuXG4gIC8vIEF2b2lkIGB1bmRlZmluZWRgIGFzIGl0IGNhbm5vdCBiZSBzZXJpYWxpemVkIGFzIEpTT05cbiAgdGFyZ2V0LmJ1bmRsZUtleSA9IHRhcmdldC5idW5kbGVLZXkgPz8gZnJvbS5idW5kbGVLZXkgPz8gbnVsbDtcbiAgdGFyZ2V0LmRlZmVyQ2h1bmtzQnlEZWZhdWx0ID1cbiAgICB0YXJnZXQuZGVmZXJDaHVua3NCeURlZmF1bHQgPz8gZnJvbS5kZWZlckNodW5rc0J5RGVmYXVsdCA/PyBmYWxzZTtcblxuICB0YXJnZXQuZGlzYWJsZVJvb3RMb2FkaW5nQm91bmRhcnlCeURlZmF1bHQgPVxuICAgIHRhcmdldC5kaXNhYmxlUm9vdExvYWRpbmdCb3VuZGFyeUJ5RGVmYXVsdCA/P1xuICAgIGZyb20uZGlzYWJsZVJvb3RMb2FkaW5nQm91bmRhcnlCeURlZmF1bHQgPz9cbiAgICBmYWxzZTtcblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5leHBvcnQgY29uc3QgY29udmVydEJ1bmRsZXNUb0NvbXBvbmVudFJlbmRlckRhdGEgPSAoXG4gIGJ1bmRsZXM6IExvYWRlckJ1bmRsZU91dHB1dFtdLFxuICBjb21wTWV0YXM6IENvbXBvbmVudE1ldGFbXVxuKTogQ29tcG9uZW50UmVuZGVyRGF0YSB8IG51bGwgPT4ge1xuICBpZiAoYnVuZGxlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IG1lcmdlZEJ1bmRsZXMgPSBidW5kbGVzLnJlZHVjZSgocHJldiwgY3VyKSA9PiBtZXJnZUJ1bmRsZXMocHJldiwgY3VyKSk7XG4gIHJldHVybiBwcmVwQ29tcG9uZW50RGF0YShtZXJnZWRCdW5kbGVzLCBjb21wTWV0YXMpO1xufTtcbiIsImltcG9ydCB7XG4gIEFzc2V0TW9kdWxlLFxuICBDb21wb25lbnRNZXRhLFxuICBGb250TWV0YSxcbiAgR2xvYmFsR3JvdXBNZXRhLFxuICBMb2FkZXJCdW5kbGVPdXRwdXQsXG4gIFJlZ2lzdHJ5LFxufSBmcm9tICdAcGxhc21pY2FwcC9sb2FkZXItY29yZSc7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBDb21wb25lbnRMb29rdXBTcGVjLCBnZXRDb21wTWV0YXMgfSBmcm9tICcuL3V0aWxzJztcblxuZnVuY3Rpb24gZ2V0Rmlyc3RDb21wTWV0YShtZXRhczogQ29tcG9uZW50TWV0YVtdLCBsb29rdXA6IENvbXBvbmVudExvb2t1cFNwZWMpIHtcbiAgY29uc3QgZmlsdGVyZWQgPSBnZXRDb21wTWV0YXMobWV0YXMsIGxvb2t1cCk7XG4gIHJldHVybiBmaWx0ZXJlZC5sZW5ndGggPT09IDAgPyB1bmRlZmluZWQgOiBmaWx0ZXJlZFswXTtcbn1cblxuZXhwb3J0IGNsYXNzIENvbXBvbmVudExvb2t1cCB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgYnVuZGxlOiBMb2FkZXJCdW5kbGVPdXRwdXQsIHByaXZhdGUgcmVnaXN0cnk6IFJlZ2lzdHJ5KSB7fVxuXG4gIGdldENvbXBvbmVudE1ldGEoc3BlYzogQ29tcG9uZW50TG9va3VwU3BlYyk6IENvbXBvbmVudE1ldGEgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IGNvbXBNZXRhID0gZ2V0Rmlyc3RDb21wTWV0YSh0aGlzLmJ1bmRsZS5jb21wb25lbnRzLCBzcGVjKTtcbiAgICByZXR1cm4gY29tcE1ldGE7XG4gIH1cblxuICBnZXRDb21wb25lbnQ8UCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudFR5cGUgPSBhbnk+KFxuICAgIHNwZWM6IENvbXBvbmVudExvb2t1cFNwZWMsXG4gICAgb3B0czogeyBmb3JjZU9yaWdpbmFsPzogYm9vbGVhbiB9ID0ge31cbiAgKSB7XG4gICAgY29uc3QgY29tcE1ldGEgPSBnZXRGaXJzdENvbXBNZXRhKHRoaXMuYnVuZGxlLmNvbXBvbmVudHMsIHNwZWMpO1xuICAgIGlmICghY29tcE1ldGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ29tcG9uZW50IG5vdCBmb3VuZDogJHtzcGVjfWApO1xuICAgIH1cbiAgICBjb25zdCBtb2R1bGVOYW1lID0gY29tcE1ldGEuZW50cnk7XG4gICAgaWYgKCF0aGlzLnJlZ2lzdHJ5Lmhhc01vZHVsZShtb2R1bGVOYW1lLCBvcHRzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb21wb25lbnQgbm90IHlldCBmZXRjaGVkOiAke2NvbXBNZXRhLm5hbWV9YCk7XG4gICAgfVxuICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5yZWdpc3RyeS5sb2FkKG1vZHVsZU5hbWUsIHtcbiAgICAgIGZvcmNlT3JpZ2luYWw6IG9wdHMuZm9yY2VPcmlnaW5hbCxcbiAgICB9KTtcbiAgICByZXR1cm4gIW9wdHMuZm9yY2VPcmlnaW5hbCAmJlxuICAgICAgdHlwZW9mIGVudHJ5Py5nZXRQbGFzbWljQ29tcG9uZW50ID09PSAnZnVuY3Rpb24nXG4gICAgICA/IGVudHJ5LmdldFBsYXNtaWNDb21wb25lbnQoKVxuICAgICAgOiAoZW50cnkuZGVmYXVsdCBhcyBQKTtcbiAgfVxuXG4gIGhhc0NvbXBvbmVudChzcGVjOiBDb21wb25lbnRMb29rdXBTcGVjKSB7XG4gICAgY29uc3QgY29tcE1ldGEgPSBnZXRGaXJzdENvbXBNZXRhKHRoaXMuYnVuZGxlLmNvbXBvbmVudHMsIHNwZWMpO1xuICAgIGlmIChjb21wTWV0YSkge1xuICAgICAgcmV0dXJuIHRoaXMucmVnaXN0cnkuaGFzTW9kdWxlKGNvbXBNZXRhLmVudHJ5KTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZ2V0R2xvYmFsQ29udGV4dHMoKTogeyBtZXRhOiBHbG9iYWxHcm91cE1ldGE7IGNvbnRleHQ6IGFueSB9W10ge1xuICAgIGNvbnN0IGN1c3RvbUdsb2JhbE1ldGFzID0gdGhpcy5idW5kbGUuZ2xvYmFsR3JvdXBzLmZpbHRlcihcbiAgICAgIChtKSA9PiBtLnR5cGUgPT09ICdnbG9iYWwtdXNlci1kZWZpbmVkJ1xuICAgICk7XG4gICAgcmV0dXJuIGN1c3RvbUdsb2JhbE1ldGFzLm1hcCgobWV0YSkgPT4gKHtcbiAgICAgIG1ldGEsXG4gICAgICBjb250ZXh0OiB0aGlzLnJlZ2lzdHJ5LmxvYWQobWV0YS5jb250ZXh0RmlsZSkuZGVmYXVsdCxcbiAgICB9KSk7XG4gIH1cblxuICBnZXRHbG9iYWxDb250ZXh0c1Byb3ZpZGVyKHNwZWM6IENvbXBvbmVudExvb2t1cFNwZWMpIHtcbiAgICBjb25zdCBjb21wTWV0YSA9IGdldEZpcnN0Q29tcE1ldGEodGhpcy5idW5kbGUuY29tcG9uZW50cywgc3BlYyk7XG4gICAgY29uc3QgcHJvamVjdE1ldGEgPSBjb21wTWV0YVxuICAgICAgPyB0aGlzLmJ1bmRsZS5wcm9qZWN0cy5maW5kKCh4KSA9PiB4LmlkID09PSBjb21wTWV0YS5wcm9qZWN0SWQpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChcbiAgICAgICFwcm9qZWN0TWV0YSB8fFxuICAgICAgIXByb2plY3RNZXRhLmdsb2JhbENvbnRleHRzUHJvdmlkZXJGaWxlTmFtZSB8fFxuICAgICAgIXRoaXMucmVnaXN0cnkuaGFzTW9kdWxlKHByb2plY3RNZXRhLmdsb2JhbENvbnRleHRzUHJvdmlkZXJGaWxlTmFtZSlcbiAgICApIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5yZWdpc3RyeS5sb2FkKFxuICAgICAgcHJvamVjdE1ldGEuZ2xvYmFsQ29udGV4dHNQcm92aWRlckZpbGVOYW1lXG4gICAgKTtcblxuICAgIHJldHVybiB0eXBlb2YgZW50cnk/LmdldFBsYXNtaWNDb21wb25lbnQgPT09ICdmdW5jdGlvbidcbiAgICAgID8gZW50cnkuZ2V0UGxhc21pY0NvbXBvbmVudCgpXG4gICAgICA6IGVudHJ5LmRlZmF1bHQ7XG4gIH1cblxuICBnZXRSb290UHJvdmlkZXIoKSB7XG4gICAgY29uc3QgZW50cnkgPSB0aGlzLnJlZ2lzdHJ5LmxvYWQoJ3Jvb3QtcHJvdmlkZXIuanMnKTtcbiAgICByZXR1cm4gZW50cnkuZGVmYXVsdDtcbiAgfVxuXG4gIGdldENzcygpOiBBc3NldE1vZHVsZVtdIHtcbiAgICAvLyBXZSBjYW4gcHJvYmFibHkgYWx3YXlzIGdldCB0aGUgbW9kdWxlcyBmcm9tIHRoZSBicm93c2VyIGJ1aWxkXG4gICAgcmV0dXJuIHRoaXMuYnVuZGxlLm1vZHVsZXMuYnJvd3Nlci5maWx0ZXIoXG4gICAgICAobW9kKSA9PiBtb2QudHlwZSA9PT0gJ2Fzc2V0JyAmJiBtb2QuZmlsZU5hbWUuZW5kc1dpdGgoJ2NzcycpXG4gICAgKSBhcyBBc3NldE1vZHVsZVtdO1xuICB9XG5cbiAgZ2V0UmVtb3RlRm9udHMoKTogRm9udE1ldGFbXSB7XG4gICAgcmV0dXJuIHRoaXMuYnVuZGxlLnByb2plY3RzLmZsYXRNYXAoKHApID0+IHAucmVtb3RlRm9udHMpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBJbnRlcm5hbFBsYXNtaWNDb21wb25lbnRMb2FkZXIgfSBmcm9tIFwiLi9sb2FkZXItY2xpZW50XCI7XG5pbXBvcnQge1xuICBDb2RlQ29tcG9uZW50TWV0YSxcbiAgRmV0Y2hDb21wb25lbnREYXRhT3B0cyxcbiAgSW5pdE9wdGlvbnMsXG4gIFBsYXNtaWNDb21wb25lbnRMb2FkZXIsXG59IGZyb20gXCIuL2xvYWRlci1zaGFyZWRcIjtcblxuZXhwb3J0IHtcbiAgRGF0YUN0eFJlYWRlcixcbiAgRGF0YVByb3ZpZGVyLFxuICBHbG9iYWxBY3Rpb25zQ29udGV4dCxcbiAgR2xvYmFsQWN0aW9uc1Byb3ZpZGVyLFxuICBQYWdlUGFyYW1zUHJvdmlkZXIsXG4gIFBsYXNtaWNDYW52YXNDb250ZXh0LFxuICBQbGFzbWljQ2FudmFzSG9zdCxcbiAgUGxhc21pY1RyYW5zbGF0b3JDb250ZXh0LFxuICByZXBlYXRlZEVsZW1lbnQsXG4gIHVzZURhdGFFbnYsXG4gIHVzZVBsYXNtaWNDYW52YXNDb250ZXh0LFxuICB1c2VTZWxlY3RvcixcbiAgdXNlU2VsZWN0b3JzLFxufSBmcm9tIFwiQHBsYXNtaWNhcHAvaG9zdFwiO1xuZXhwb3J0IHR5cGUgeyBQcm9wVHlwZSwgVG9rZW5SZWdpc3RyYXRpb24gfSBmcm9tIFwiQHBsYXNtaWNhcHAvaG9zdFwiO1xuZXhwb3J0IHsgdXNlUGxhc21pY1F1ZXJ5RGF0YSB9IGZyb20gXCJAcGxhc21pY2FwcC9xdWVyeVwiO1xuZXhwb3J0IHsgUGxhc21pY0NvbXBvbmVudCB9IGZyb20gXCIuL1BsYXNtaWNDb21wb25lbnRcIjtcbmV4cG9ydCB7IFBsYXNtaWNSb290UHJvdmlkZXIgfSBmcm9tIFwiLi9QbGFzbWljUm9vdFByb3ZpZGVyXCI7XG5leHBvcnQgdHlwZSB7XG4gIEdsb2JhbFZhcmlhbnRTcGVjLFxuICBQbGFzbWljVHJhbnNsYXRvcixcbn0gZnJvbSBcIi4vUGxhc21pY1Jvb3RQcm92aWRlclwiO1xuZXhwb3J0IHsgZXh0cmFjdFBsYXNtaWNRdWVyeURhdGEsIHBsYXNtaWNQcmVwYXNzIH0gZnJvbSBcIi4vcHJlcGFzcy1jbGllbnRcIjtcbmV4cG9ydCB7XG4gIGV4dHJhY3RQbGFzbWljUXVlcnlEYXRhRnJvbUVsZW1lbnQsXG4gIGh5ZHJhdGVGcm9tRWxlbWVudCxcbiAgcmVuZGVyVG9FbGVtZW50LFxuICByZW5kZXJUb1N0cmluZyxcbn0gZnJvbSBcIi4vcmVuZGVyXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9zaGFyZWQtZXhwb3J0c1wiO1xuZXhwb3J0IHsgdXNlUGxhc21pY0NvbXBvbmVudCB9IGZyb20gXCIuL3VzZVBsYXNtaWNDb21wb25lbnRcIjtcbmV4cG9ydCB0eXBlIHsgQ29tcG9uZW50TG9va3VwU3BlYyB9IGZyb20gXCIuL3V0aWxzXCI7XG5leHBvcnQgeyBJbnRlcm5hbFBsYXNtaWNDb21wb25lbnRMb2FkZXIsIFBsYXNtaWNDb21wb25lbnRMb2FkZXIgfTtcbmV4cG9ydCB0eXBlIHsgQ29kZUNvbXBvbmVudE1ldGEsIEZldGNoQ29tcG9uZW50RGF0YU9wdHMgfTtcblxuZXhwb3J0IGZ1bmN0aW9uIGluaXRQbGFzbWljTG9hZGVyKG9wdHM6IEluaXRPcHRpb25zKTogUGxhc21pY0NvbXBvbmVudExvYWRlciB7XG4gIGNvbnN0IGludGVybmFsID0gbmV3IEludGVybmFsUGxhc21pY0NvbXBvbmVudExvYWRlcihvcHRzKTtcbiAgcmV0dXJuIG5ldyBQbGFzbWljQ29tcG9uZW50TG9hZGVyKGludGVybmFsKTtcbn1cbiIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdXNlUGxhc21pY1Jvb3RDb250ZXh0IH0gZnJvbSBcIi4vUGxhc21pY1Jvb3RQcm92aWRlclwiO1xuaW1wb3J0IHsgdXNlUGxhc21pY0NvbXBvbmVudCB9IGZyb20gXCIuL3VzZVBsYXNtaWNDb21wb25lbnRcIjtcbmltcG9ydCB7IE1heWJlV3JhcCB9IGZyb20gXCIuL3V0aWxzXCI7XG5cbmNvbnN0IFBsYXNtaWNDb21wb25lbnRDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChmYWxzZSk7XG5cbmV4cG9ydCBmdW5jdGlvbiBQbGFzbWljQ29tcG9uZW50KHByb3BzOiB7XG4gIC8qKlxuICAgKiBOYW1lIG9mIHRoZSBjb21wb25lbnQgdG8gcmVuZGVyLCBvciB0aGUgcGF0aCBvZiB0aGUgcGFnZSBjb21wb25lbnRcbiAgICovXG4gIGNvbXBvbmVudDogc3RyaW5nO1xuICAvKipcbiAgICogT3B0aW9uYWxseSBzcGVjaWZ5IGEgcHJvamVjdElkIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSBjb21wb25lbnRzXG4gICAqIG9mIHRoZSBzYW1lIG5hbWUgZnJvbSBkaWZmZXJlbnQgcHJvamVjdHNcbiAgICovXG4gIHByb2plY3RJZD86IHN0cmluZztcbiAgLyoqXG4gICAqIElmIHlvdSB1c2VkIHJlZ2lzdGVyQ29tcG9uZW50KCksIHRoZW4gaWYgdGhlIG5hbWUgbWF0Y2hlcyBhIHJlZ2lzdGVyZWRcbiAgICogY29tcG9uZW50LCB0aGF0IGNvbXBvbmVudCBpcyB1c2VkLiAgSWYgeW91IHdhbnQgdGhlIFBsYXNtaWMtZ2VuZXJhdGVkXG4gICAqIGNvbXBvbmVudCBpbnN0ZWFkLCBzcGVjaWZ5IGZvcmNlT3JpZ2luYWwuXG4gICAqL1xuICBmb3JjZU9yaWdpbmFsPzogYm9vbGVhbjtcbiAgY29tcG9uZW50UHJvcHM/OiBhbnk7XG59KTogUmVhY3QuUmVhY3RFbGVtZW50IHwgbnVsbCB7XG4gIGNvbnN0IHsgY29tcG9uZW50LCBwcm9qZWN0SWQsIGNvbXBvbmVudFByb3BzLCBmb3JjZU9yaWdpbmFsIH0gPSBwcm9wcztcblxuICBjb25zdCByb290Q29udGV4dCA9IHVzZVBsYXNtaWNSb290Q29udGV4dCgpO1xuICBjb25zdCBpc1Jvb3RMb2FkZXIgPSAhUmVhY3QudXNlQ29udGV4dChQbGFzbWljQ29tcG9uZW50Q29udGV4dCk7XG5cbiAgaWYgKCFyb290Q29udGV4dCkge1xuICAgIC8vIG5vIGV4aXN0aW5nIFBsYXNtaWNSb290UHJvdmlkZXJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgWW91IG11c3QgdXNlIDxQbGFzbWljUm9vdFByb3ZpZGVyLz4gYXQgdGhlIHJvb3Qgb2YgeW91ciBhcHBgXG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IHtcbiAgICBsb2FkZXIsXG4gICAgZ2xvYmFsQ29udGV4dHNQcm9wcyxcbiAgICB2YXJpYXRpb24sXG4gICAgdXNlckF1dGhUb2tlbixcbiAgICBpc1VzZXJMb2FkaW5nLFxuICAgIGF1dGhSZWRpcmVjdFVyaSxcbiAgICB0cmFuc2xhdG9yLFxuICAgIC4uLnJlc3RcbiAgfSA9IHJvb3RDb250ZXh0O1xuXG4gIGNvbnN0IENvbXBvbmVudCA9IHVzZVBsYXNtaWNDb21wb25lbnQoXG4gICAgeyBuYW1lOiBjb21wb25lbnQsIHByb2plY3RJZCwgaXNDb2RlOiBmYWxzZSB9LFxuICAgIHsgZm9yY2VPcmlnaW5hbCB9XG4gICk7XG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaXNSb290TG9hZGVyKSB7XG4gICAgICBjb25zdCBtZXRhID0gbG9hZGVyXG4gICAgICAgIC5nZXRMb29rdXAoKVxuICAgICAgICAuZ2V0Q29tcG9uZW50TWV0YSh7IG5hbWU6IGNvbXBvbmVudCwgcHJvamVjdElkIH0pO1xuXG4gICAgICBpZiAobWV0YSkge1xuICAgICAgICBsb2FkZXIudHJhY2tSZW5kZXIoe1xuICAgICAgICAgIHJlbmRlckN0eDoge1xuICAgICAgICAgICAgcm9vdFByb2plY3RJZDogbWV0YS5wcm9qZWN0SWQsXG4gICAgICAgICAgICByb290Q29tcG9uZW50SWQ6IG1ldGEuaWQsXG4gICAgICAgICAgICByb290Q29tcG9uZW50TmFtZTogY29tcG9uZW50LFxuICAgICAgICAgICAgdGVhbUlkczogbG9hZGVyLmdldFRlYW1JZHMoKSxcbiAgICAgICAgICAgIHByb2plY3RJZHM6IGxvYWRlci5nZXRQcm9qZWN0SWRzKCksXG4gICAgICAgICAgfSxcbiAgICAgICAgICB2YXJpYXRpb24sXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW2NvbXBvbmVudCwgcHJvamVjdElkLCBsb2FkZXIsIHZhcmlhdGlvbl0pO1xuXG4gIGNvbnN0IGVsZW1lbnQgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoIUNvbXBvbmVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgbGV0IGVsdCA9IDxDb21wb25lbnQgey4uLmNvbXBvbmVudFByb3BzfSAvPjtcblxuICAgIGlmIChpc1Jvb3RMb2FkZXIpIHtcbiAgICAgIC8vIElmIHRoaXMgaXMgdGhlIHJvb3QgUGxhc21pY0NvbXBvbmVudCwgdGhlbiB3cmFwIHRoZSBjb250ZW50IHdpdGggdGhlXG4gICAgICAvLyByZWFjdC13ZWIncyBQbGFzbWljUm9vdFByb3ZpZGVyLiAgV2UgYXJlIGRvaW5nIHRoaXMgaGVyZSwgaW5zdGVhZCBvZlxuICAgICAgLy8gc2F5IFBsYXNtaWNSb290UHJvdmlkZXIsIGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSBhY2Nlc3MgdG8gdGhpcyBjb250ZXh0XG4gICAgICAvLyBwcm92aWRlciB1bnRpbCBkYXRhIGhhcyBiZWVuIGxvYWRlZC4gIElmIHdlIGluc2VydCB0aGlzIHByb3ZpZGVyIGludG9cbiAgICAgIC8vIHRoZSB0cmVlIGF0IHRoZSByb290IGFmdGVyIGRhdGEgaXMgbG9hZGVkLCB0aGVuIHdlJ2xsIGludmFsaWRhdGUgdGhlXG4gICAgICAvLyBSZWFjdCB0cmVlIGFuZCB0cmVlIHN0YXRlLCB3aGljaCBpcyBiYWQuICBJbnN0ZWFkLCB3ZSBkbyBpdCBhdCB0aGVcbiAgICAgIC8vIFwicm9vdC1tb3N0IFBsYXNtaWNDb21wb25lbnRcIjsgd2Ugd29uJ3QgcmlzayBpbnZhbGlkYXRpbmcgdGhlIHN1Yi10cmVlXG4gICAgICAvLyBoZXJlIGJlY2F1c2UgdGhlcmUgd2VyZSBubyBjaGlsZHJlbiBiZWZvcmUgdGhlIGRhdGEgY2FtZSBpbi5cbiAgICAgIGNvbnN0IGxvb2t1cCA9IGxvYWRlci5nZXRMb29rdXAoKTtcbiAgICAgIGNvbnN0IFJlYWN0V2ViUm9vdFByb3ZpZGVyID0gbG9va3VwLmdldFJvb3RQcm92aWRlcigpO1xuICAgICAgY29uc3QgR2xvYmFsQ29udGV4dHNQcm92aWRlciA9IGxvb2t1cC5nZXRHbG9iYWxDb250ZXh0c1Byb3ZpZGVyKHtcbiAgICAgICAgbmFtZTogY29tcG9uZW50LFxuICAgICAgICBwcm9qZWN0SWQsXG4gICAgICB9KTtcbiAgICAgIGVsdCA9IChcbiAgICAgICAgPFJlYWN0V2ViUm9vdFByb3ZpZGVyXG4gICAgICAgICAgey4uLnJlc3R9XG4gICAgICAgICAgdXNlckF1dGhUb2tlbj17dXNlckF1dGhUb2tlbn1cbiAgICAgICAgICBpc1VzZXJMb2FkaW5nPXtpc1VzZXJMb2FkaW5nfVxuICAgICAgICAgIGF1dGhSZWRpcmVjdFVyaT17YXV0aFJlZGlyZWN0VXJpfVxuICAgICAgICAgIGkxOG49e3tcbiAgICAgICAgICAgIHRyYW5zbGF0b3IsXG4gICAgICAgICAgICB0YWdQcmVmaXg6IGxvYWRlci5vcHRzLmkxOG4/LnRhZ1ByZWZpeCxcbiAgICAgICAgICB9fVxuICAgICAgICA+XG4gICAgICAgICAgPE1heWJlV3JhcFxuICAgICAgICAgICAgY29uZD17ISFHbG9iYWxDb250ZXh0c1Byb3ZpZGVyfVxuICAgICAgICAgICAgd3JhcHBlcj17KGNoaWxkcmVuKSA9PiAoXG4gICAgICAgICAgICAgIDxHbG9iYWxDb250ZXh0c1Byb3ZpZGVyIHsuLi5nbG9iYWxDb250ZXh0c1Byb3BzfT5cbiAgICAgICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgICAgICAgIDwvR2xvYmFsQ29udGV4dHNQcm92aWRlcj5cbiAgICAgICAgICAgICl9XG4gICAgICAgICAgPlxuICAgICAgICAgICAgPFBsYXNtaWNDb21wb25lbnRDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt0cnVlfT5cbiAgICAgICAgICAgICAge2VsdH1cbiAgICAgICAgICAgIDwvUGxhc21pY0NvbXBvbmVudENvbnRleHQuUHJvdmlkZXI+XG4gICAgICAgICAgPC9NYXliZVdyYXA+XG4gICAgICAgIDwvUmVhY3RXZWJSb290UHJvdmlkZXI+XG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gZWx0O1xuICB9LCBbXG4gICAgQ29tcG9uZW50LFxuICAgIGNvbXBvbmVudFByb3BzLFxuICAgIGxvYWRlcixcbiAgICBpc1Jvb3RMb2FkZXIsXG4gICAgY29tcG9uZW50LFxuICAgIHByb2plY3RJZCxcbiAgICBnbG9iYWxDb250ZXh0c1Byb3BzLFxuICAgIHVzZXJBdXRoVG9rZW4sIC8vIEp1c3QgdXNlIHRoZSB0b2tlbiB0byBtZW1vLCBgdXNlcmAgc2hvdWxkIGJlIGRlcml2ZWQgZnJvbSBpdFxuICAgIGlzVXNlckxvYWRpbmcsXG4gICAgYXV0aFJlZGlyZWN0VXJpLFxuICBdKTtcbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG4iLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VQbGFzbWljUm9vdENvbnRleHQgfSBmcm9tICcuL1BsYXNtaWNSb290UHJvdmlkZXInO1xuaW1wb3J0IHtcbiAgQ29tcG9uZW50TG9va3VwU3BlYyxcbiAgdXNlRm9yY2VVcGRhdGUsXG4gIHVzZUlzTW91bnRlZCxcbiAgdXNlU3RhYmxlTG9va3VwU3BlYyxcbn0gZnJvbSAnLi91dGlscyc7XG5cbi8qKlxuICogSG9vayB0aGF0IGZldGNoZXMgYW5kIHJldHVybnMgYSBSZWFjdCBjb21wb25lbnQgZm9yIHJlbmRlcmluZyB0aGUgYXJndW1lbnRcbiAqIFBsYXNtaWMgY29tcG9uZW50LiAgUmV0dXJucyB1bmRlZmluZWQgaWYgdGhlIGNvbXBvbmVudCBkYXRhIGlzIHN0aWxsXG4gKiBiZWluZyBmZXRjaGVkLlxuICpcbiAqIEBwYXJhbSBvcHRzLmZvcmNlT3JpZ2luYWwgaWYgeW91IHVzZWQgUGxhc21pY0NvbXBvbmVudExvYWRlci5yZWdpc3RlckNvbXBvbmVudCxcbiAqICAgdGhlbiBub3JtYWxseSB1c2VQbGFzbWljQ29tcG9uZW50IHdpbGwgcmV0dXJuIHRoZSByZWdpc3RlcmVkIGNvbXBvbmVudC5cbiAqICAgWW91IGNhbiBzZXQgZm9yY2VPcmlnaW5hbCB0byB0cnVlIGlmIHlvdSB3YW50IHRvIHJldHVybiB0aGUgUGxhc21pYy1nZW5lcmF0ZWRcbiAqICAgY29tcG9uZW50IGluc3RlYWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VQbGFzbWljQ29tcG9uZW50PFAgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnRUeXBlID0gYW55PihcbiAgc3BlYzogQ29tcG9uZW50TG9va3VwU3BlYyxcbiAgb3B0czogeyBmb3JjZU9yaWdpbmFsPzogYm9vbGVhbiB9ID0ge31cbikge1xuICBjb25zdCByb290Q29udGV4dCA9IHVzZVBsYXNtaWNSb290Q29udGV4dCgpO1xuICBpZiAoIXJvb3RDb250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFlvdSBjYW4gb25seSB1c2UgdXNlUGxhc21pY0NvbXBvbmVudCBpZiB3cmFwcGVkIGluIDxQbGFzbWljUm9vdFByb3ZpZGVyIC8+YFxuICAgICk7XG4gIH1cblxuICBjb25zdCBsb2FkZXIgPSByb290Q29udGV4dC5sb2FkZXI7XG4gIGNvbnN0IGxvb2t1cCA9IGxvYWRlci5nZXRMb29rdXAoKTtcblxuICBjb25zdCBjb21wb25lbnQgPSBsb29rdXAuaGFzQ29tcG9uZW50KHNwZWMpXG4gICAgPyBsb29rdXAuZ2V0Q29tcG9uZW50KHNwZWMsIG9wdHMpXG4gICAgOiB1bmRlZmluZWQ7XG5cbiAgY29uc3Qgc3RhYmxlU3BlYyA9IHVzZVN0YWJsZUxvb2t1cFNwZWMoc3BlYyk7XG4gIGNvbnN0IGlzTW91bnRlZCA9IHVzZUlzTW91bnRlZCgpO1xuICBjb25zdCBmb3JjZVVwZGF0ZSA9IHVzZUZvcmNlVXBkYXRlKCk7XG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWNvbXBvbmVudCkge1xuICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgbG9hZGVyLmZldGNoQ29tcG9uZW50RGF0YShzdGFibGVTcGVjKTtcbiAgICAgICAgaWYgKGlzTW91bnRlZCgpKSB7XG4gICAgICAgICAgZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfSkoKTtcbiAgICB9XG4gIH0sIFtjb21wb25lbnQsIHN0YWJsZVNwZWNdKTtcblxuICByZXR1cm4gY29tcG9uZW50IGFzIFA7XG59XG4iLCJpbXBvcnQge1xuICBleHRyYWN0UGxhc21pY1F1ZXJ5RGF0YSBhcyBpbnRlcm5hbEV4dHJhY3RRdWVyeURhdGEsXG4gIHBsYXNtaWNQcmVwYXNzIGFzIGludGVybmFsUGxhc21pY1ByZXBhc3MsXG59IGZyb20gXCJAcGxhc21pY2FwcC9wcmVwYXNzXCI7XG5cbi8qKlxuICogUGVyZm9ybXMgYSBwcmVwYXNzIG92ZXIgUGxhc21pYyBjb250ZW50LCBraWNraW5nIG9mZiB0aGUgbmVjZXNzYXJ5XG4gKiBkYXRhIGZldGNoZXMsIGFuZCBwb3B1bGF0aW5nIHRoZSBmZXRjaGVkIGRhdGEgaW50byBhIGNhY2hlLiAgVGhpc1xuICogY2FjaGUgY2FuIGJlIHBhc3NlZCBhcyBwcmVmZXRjaGVkUXVlcnlEYXRhIGludG8gUGxhc21pY1Jvb3RQcm92aWRlci5cbiAqXG4gKiBUbyBsaW1pdCByZW5kZXJpbmcgZXJyb3JzIHRoYXQgY2FuIG9jY3VyIHdoZW4geW91IGRvIHRoaXMsIHdlIHJlY29tbWVuZFxuICogdGhhdCB5b3UgcGFzcyBpbiBfb25seV8gdGhlIFBsYXNtaWNDb21wb25lbnRzIHRoYXQgeW91IGFyZSBwbGFubmluZyB0byB1c2VcbiAqIGFzIHRoZSBhcmd1bWVudC4gIEZvciBleGFtcGxlOlxuICpcbiAqICAgY29uc3QgY2FjaGUgPSBhd2FpdCBleHRyYWN0UGxhc21pY1F1ZXJ5RGF0YShcbiAqICAgICA8UGxhc21pY1Jvb3RQcm92aWRlciBsb2FkZXI9e1BMQVNNSUN9IHByZWZldGNoZWREYXRhPXtwbGFzbWljRGF0YX0+XG4gKiAgICAgICA8UGxhc21pY0NvbXBvbmVudCBjb21wb25lbnQ9XCJIb21lXCIgY29tcG9uZW50UHJvcHM9e3tcbiAqICAgICAgICAgLy8gU3BlY2lmeSB0aGUgY29tcG9uZW50IHByb3Agb3ZlcnJpZGVzIHlvdSBhcmUgcGxhbm5pbmcgdG8gdXNlXG4gKiAgICAgICAgIC8vIHRvIHJlbmRlciB0aGUgcGFnZSwgYXMgdGhleSBtYXkgY2hhbmdlIHdoYXQgZGF0YSBpcyBmZXRjaGVkLlxuICogICAgICAgICAuLi5cbiAqICAgICAgIH19IC8+XG4gKiAgICAgICA8UGxhc21pY0NvbXBvbmVudCBjb21wb25lbnQ9XCJOYXZCYXJcIiBjb21wb25lbnRQcm9wcz17e1xuICogICAgICAgICAuLi5cbiAqICAgICAgIH19IC8+XG4gKiAgICAgICAuLi5cbiAqICAgICA8L1BsYXNtaWNSb290UHJvdmlkZXI+XG4gKiAgICk7XG4gKlxuICogSWYgeW91ciBQbGFzbWljQ29tcG9uZW50IHdpbGwgYmUgd3JhcHBpbmcgY29tcG9uZW50cyB0aGF0IHJlcXVpcmUgc3BlY2lhbFxuICogY29udGV4dCBzZXQgdXAsIHlvdSBzaG91bGQgYWxzbyB3cmFwIHRoZSBlbGVtZW50IGFib3ZlIHdpdGggdGhvc2UgY29udGV4dFxuICogcHJvdmlkZXJzLlxuICpcbiAqIFlvdSBzaG91bGQgYXZvaWQgcGFzc2luZyBpbiBlbGVtZW50cyB0aGF0IGFyZSBub3QgcmVsYXRlZCB0byBQbGFzbWljLCBhcyBhbnlcbiAqIHJlbmRlcmluZyBlcnJvcnMgZnJvbSB0aG9zZSBlbGVtZW50cyBkdXJpbmcgdGhlIHByZXBhc3MgbWF5IHJlc3VsdCBpbiBkYXRhXG4gKiBub3QgYmVpbmcgcG9wdWxhdGVkIGluIHRoZSBjYWNoZS5cbiAqXG4gKiBAcGFyYW0gZWxlbWVudCBhIFJlYWN0IGVsZW1lbnQgY29udGFpbmluZyBpbnN0YW5jZXMgb2YgUGxhc21pY0NvbXBvbmVudC5cbiAqICAgV2lsbCBhdHRlbXB0IHRvIHNhdGlzZnkgYWxsIGRhdGEgbmVlZHMgZnJvbSB1c2VQbGFzbWljRGF0YVF1ZXJ5KClcbiAqICAgaW4gdGhpcyBlbGVtZW50IHRyZWUuXG4gKiBAcmV0dXJucyBhbiBvYmplY3QgbWFwcGluZyBxdWVyeSBrZXkgdG8gZmV0Y2hlZCBkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0UGxhc21pY1F1ZXJ5RGF0YShcbiAgZWxlbWVudDogUmVhY3QuUmVhY3RFbGVtZW50XG4pOiBQcm9taXNlPFJlY29yZDxzdHJpbmcsIGFueT4+IHtcbiAgcmV0dXJuIGludGVybmFsRXh0cmFjdFF1ZXJ5RGF0YShlbGVtZW50KTtcbn1cblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBNYWludGFpbmVkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGxhc21pY1ByZXBhc3MoZWxlbWVudDogUmVhY3QuUmVhY3RFbGVtZW50KTogUHJvbWlzZTx2b2lkPiB7XG4gIHJldHVybiBpbnRlcm5hbFBsYXNtaWNQcmVwYXNzKGVsZW1lbnQpO1xufVxuIiwiaW1wb3J0IHsgZXh0cmFjdFBsYXNtaWNRdWVyeURhdGEgfSBmcm9tIFwiQHBsYXNtaWNhcHAvcHJlcGFzc1wiO1xuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gXCJyZWFjdC1kb21cIjtcbmltcG9ydCB7IHJlbmRlclRvU3RyaW5nIGFzIHJlYWN0UmVuZGVyVG9TdHJpbmcgfSBmcm9tIFwicmVhY3QtZG9tL3NlcnZlclwiO1xuaW1wb3J0IHsgQ29tcG9uZW50UmVuZGVyRGF0YSwgUGxhc21pY0NvbXBvbmVudExvYWRlciB9IGZyb20gXCIuL2xvYWRlci1zaGFyZWRcIjtcbmltcG9ydCB7IFBsYXNtaWNDb21wb25lbnQgfSBmcm9tIFwiLi9QbGFzbWljQ29tcG9uZW50XCI7XG5pbXBvcnQgeyBHbG9iYWxWYXJpYW50U3BlYywgUGxhc21pY1Jvb3RQcm92aWRlciB9IGZyb20gXCIuL1BsYXNtaWNSb290UHJvdmlkZXJcIjtcbmltcG9ydCB7IENvbXBvbmVudExvb2t1cFNwZWMgfSBmcm9tIFwiLi91dGlsc1wiO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVuZGVyVG9FbGVtZW50KFxuICBsb2FkZXI6IFBsYXNtaWNDb21wb25lbnRMb2FkZXIsXG4gIHRhcmdldDogSFRNTEVsZW1lbnQsXG4gIGxvb2t1cDogQ29tcG9uZW50TG9va3VwU3BlYyxcbiAgb3B0czoge1xuICAgIHByZWZldGNoZWREYXRhPzogQ29tcG9uZW50UmVuZGVyRGF0YTtcbiAgICBjb21wb25lbnRQcm9wcz86IGFueTtcbiAgICBnbG9iYWxWYXJpYW50cz86IEdsb2JhbFZhcmlhbnRTcGVjW107XG4gICAgcHJlZmV0Y2hlZFF1ZXJ5RGF0YT86IFJlY29yZDxzdHJpbmcsIGFueT47XG4gICAgcGFnZVBhcmFtcz86IFJlY29yZDxzdHJpbmcsIGFueT47XG4gICAgcGFnZVF1ZXJ5PzogUmVjb3JkPHN0cmluZywgYW55PjtcbiAgfSA9IHt9XG4pIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlKSA9PiB7XG4gICAgY29uc3QgZWxlbWVudCA9IG1ha2VFbGVtZW50KGxvYWRlciwgbG9va3VwLCBvcHRzKTtcbiAgICBSZWFjdERPTS5yZW5kZXIoZWxlbWVudCwgdGFyZ2V0LCAoKSA9PiByZXNvbHZlKCkpO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlclRvU3RyaW5nKFxuICBsb2FkZXI6IFBsYXNtaWNDb21wb25lbnRMb2FkZXIsXG4gIGxvb2t1cDogQ29tcG9uZW50TG9va3VwU3BlYyxcbiAgb3B0czoge1xuICAgIHByZWZldGNoZWREYXRhPzogQ29tcG9uZW50UmVuZGVyRGF0YTtcbiAgICBjb21wb25lbnRQcm9wcz86IGFueTtcbiAgICBnbG9iYWxWYXJpYW50cz86IEdsb2JhbFZhcmlhbnRTcGVjW107XG4gICAgcHJlZmV0Y2hlZFF1ZXJ5RGF0YT86IFJlY29yZDxzdHJpbmcsIGFueT47XG4gIH0gPSB7fVxuKSB7XG4gIGNvbnN0IGVsZW1lbnQgPSBtYWtlRWxlbWVudChsb2FkZXIsIGxvb2t1cCwgb3B0cyk7XG4gIHJldHVybiByZWFjdFJlbmRlclRvU3RyaW5nKGVsZW1lbnQpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZXh0cmFjdFBsYXNtaWNRdWVyeURhdGFGcm9tRWxlbWVudChcbiAgbG9hZGVyOiBQbGFzbWljQ29tcG9uZW50TG9hZGVyLFxuICBsb29rdXA6IENvbXBvbmVudExvb2t1cFNwZWMsXG4gIG9wdHM6IHtcbiAgICBwcmVmZXRjaGVkRGF0YT86IENvbXBvbmVudFJlbmRlckRhdGE7XG4gICAgY29tcG9uZW50UHJvcHM/OiBhbnk7XG4gICAgZ2xvYmFsVmFyaWFudHM/OiBHbG9iYWxWYXJpYW50U3BlY1tdO1xuICAgIHByZWZldGNoZWRRdWVyeURhdGE/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuICB9ID0ge31cbikge1xuICBjb25zdCBlbGVtZW50ID0gbWFrZUVsZW1lbnQobG9hZGVyLCBsb29rdXAsIG9wdHMpO1xuICByZXR1cm4gZXh0cmFjdFBsYXNtaWNRdWVyeURhdGEoZWxlbWVudCk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBoeWRyYXRlRnJvbUVsZW1lbnQoXG4gIGxvYWRlcjogUGxhc21pY0NvbXBvbmVudExvYWRlcixcbiAgdGFyZ2V0OiBIVE1MRWxlbWVudCxcbiAgbG9va3VwOiBDb21wb25lbnRMb29rdXBTcGVjLFxuICBvcHRzOiB7XG4gICAgcHJlZmV0Y2hlZERhdGE/OiBDb21wb25lbnRSZW5kZXJEYXRhO1xuICAgIGNvbXBvbmVudFByb3BzPzogYW55O1xuICAgIGdsb2JhbFZhcmlhbnRzPzogR2xvYmFsVmFyaWFudFNwZWNbXTtcbiAgICBwcmVmZXRjaGVkUXVlcnlEYXRhPzogUmVjb3JkPHN0cmluZywgYW55PjtcbiAgfSA9IHt9XG4pIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlKSA9PiB7XG4gICAgY29uc3QgZWxlbWVudCA9IG1ha2VFbGVtZW50KGxvYWRlciwgbG9va3VwLCBvcHRzKTtcbiAgICBSZWFjdERPTS5oeWRyYXRlKGVsZW1lbnQsIHRhcmdldCwgKCkgPT4gcmVzb2x2ZSgpKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG1ha2VFbGVtZW50KFxuICBsb2FkZXI6IFBsYXNtaWNDb21wb25lbnRMb2FkZXIsXG4gIGxvb2t1cDogQ29tcG9uZW50TG9va3VwU3BlYyxcbiAgb3B0czoge1xuICAgIHByZWZldGNoZWREYXRhPzogQ29tcG9uZW50UmVuZGVyRGF0YTtcbiAgICBjb21wb25lbnRQcm9wcz86IGFueTtcbiAgICBnbG9iYWxWYXJpYW50cz86IEdsb2JhbFZhcmlhbnRTcGVjW107XG4gICAgcHJlZmV0Y2hlZFF1ZXJ5RGF0YT86IFJlY29yZDxzdHJpbmcsIGFueT47XG4gICAgcGFnZVBhcmFtcz86IFJlY29yZDxzdHJpbmcsIGFueT47XG4gICAgcGFnZVF1ZXJ5PzogUmVjb3JkPHN0cmluZywgYW55PjtcbiAgfSA9IHt9XG4pIHtcbiAgcmV0dXJuIChcbiAgICA8UGxhc21pY1Jvb3RQcm92aWRlclxuICAgICAgbG9hZGVyPXtsb2FkZXJ9XG4gICAgICBwcmVmZXRjaGVkRGF0YT17b3B0cy5wcmVmZXRjaGVkRGF0YX1cbiAgICAgIGdsb2JhbFZhcmlhbnRzPXtvcHRzLmdsb2JhbFZhcmlhbnRzfVxuICAgICAgcHJlZmV0Y2hlZFF1ZXJ5RGF0YT17b3B0cy5wcmVmZXRjaGVkUXVlcnlEYXRhfVxuICAgICAgcGFnZVBhcmFtcz17b3B0cy5wYWdlUGFyYW1zfVxuICAgICAgcGFnZVF1ZXJ5PXtvcHRzLnBhZ2VRdWVyeX1cbiAgICA+XG4gICAgICA8UGxhc21pY0NvbXBvbmVudFxuICAgICAgICBjb21wb25lbnQ9e3R5cGVvZiBsb29rdXAgPT09IFwic3RyaW5nXCIgPyBsb29rdXAgOiBsb29rdXAubmFtZX1cbiAgICAgICAgcHJvamVjdElkPXt0eXBlb2YgbG9va3VwID09PSBcInN0cmluZ1wiID8gdW5kZWZpbmVkIDogbG9va3VwLnByb2plY3RJZH1cbiAgICAgICAgY29tcG9uZW50UHJvcHM9e29wdHMuY29tcG9uZW50UHJvcHN9XG4gICAgICAvPlxuICAgIDwvUGxhc21pY1Jvb3RQcm92aWRlcj5cbiAgKTtcbn1cbiJdLCJuYW1lcyI6WyJQbGFzbWljTW9kdWxlc0ZldGNoZXIiLCJQbGFzbWljVHJhY2tlciIsIlJlYWN0IiwiUGxhc21pY0NzcyIsIl9hIiwiX2IiLCJQYWdlUGFyYW1zUHJvdmlkZXIiLCJleHRyYWN0UGxhc21pY1F1ZXJ5RGF0YSIsIlJlYWN0RE9NIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@plasmicapp/loader-react/dist/index.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@plasmicapp/loader-splits/dist/index.esm.js":
/*!******************************************************************!*\
  !*** ./node_modules/@plasmicapp/loader-splits/dist/index.esm.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   describeVariation: () => (/* binding */ describeVariation),\n/* harmony export */   describeVariationForKey: () => (/* binding */ describeVariationForKey),\n/* harmony export */   getActiveVariation: () => (/* binding */ getActiveVariation),\n/* harmony export */   getExternalIds: () => (/* binding */ getExternalIds),\n/* harmony export */   getSeededRandomFunction: () => (/* binding */ getSeededRandomFunction),\n/* harmony export */   getSplitKey: () => (/* binding */ getSplitKey)\n/* harmony export */ });\n/* harmony import */ var json_logic_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! json-logic-js */ \"(app-pages-browser)/./node_modules/json-logic-js/logic.js\");\n/* harmony import */ var json_logic_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(json_logic_js__WEBPACK_IMPORTED_MODULE_0__);\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\n\n// src/random.ts\nvar getSeededRandomFunction = (strSeed) => {\n  function cyrb128(str) {\n    let h1 = 1779033703, h2 = 3144134277, h3 = 1013904242, h4 = 2773480762;\n    for (let i = 0, k; i < str.length; i++) {\n      k = str.charCodeAt(i);\n      h1 = h2 ^ Math.imul(h1 ^ k, 597399067);\n      h2 = h3 ^ Math.imul(h2 ^ k, 2869860233);\n      h3 = h4 ^ Math.imul(h3 ^ k, 951274213);\n      h4 = h1 ^ Math.imul(h4 ^ k, 2716044179);\n    }\n    h1 = Math.imul(h3 ^ h1 >>> 18, 597399067);\n    h2 = Math.imul(h4 ^ h2 >>> 22, 2869860233);\n    h3 = Math.imul(h1 ^ h3 >>> 17, 951274213);\n    h4 = Math.imul(h2 ^ h4 >>> 19, 2716044179);\n    return [\n      (h1 ^ h2 ^ h3 ^ h4) >>> 0,\n      (h2 ^ h1) >>> 0,\n      (h3 ^ h1) >>> 0,\n      (h4 ^ h1) >>> 0\n    ];\n  }\n  function sfc32(a, b, c, d) {\n    return function() {\n      a >>>= 0;\n      b >>>= 0;\n      c >>>= 0;\n      d >>>= 0;\n      let t = a + b | 0;\n      a = b ^ b >>> 9;\n      b = c + (c << 3) | 0;\n      c = c << 21 | c >>> 11;\n      d = d + 1 | 0;\n      t = t + d | 0;\n      c = c + t | 0;\n      return (t >>> 0) / 4294967296;\n    };\n  }\n  const seed = cyrb128(strSeed);\n  const rand = sfc32(seed[0], seed[1], seed[2], seed[3]);\n  return rand;\n};\n\n// src/variation.ts\n\nvar isBrowser = typeof window !== \"undefined\" && window != null && typeof window.document !== \"undefined\";\nvar PLASMIC_SEED = \"plasmic_seed\";\nvar BUILTIN_TRAITS_UNKNOWN = {\n  pageUrl: \"unknown\"\n};\nvar getBrowserBuiltinTraits = () => {\n  if (!isBrowser) {\n    return {};\n  }\n  return {\n    pageUrl: document.location.href\n  };\n};\nvar getSplitKey = (split) => {\n  return `${split.type === \"experiment\" ? \"exp.\" : \"seg.\"}${split.id}`;\n};\nfunction getActiveVariation(opts) {\n  const { splits, getKnownValue, updateKnownValue } = opts;\n  const getRandomValue = (key) => {\n    var _a;\n    if (opts.getRandomValue) {\n      return opts.getRandomValue(key);\n    }\n    if (opts.traits[PLASMIC_SEED]) {\n      const rand = getSeededRandomFunction(\n        ((_a = opts.traits[PLASMIC_SEED]) != null ? _a : \"\") + key\n      );\n      return rand();\n    }\n    if (!opts.enableUnseededExperiments) {\n      return 0;\n    }\n    return Math.random();\n  };\n  const variation = {};\n  splits.forEach((split) => {\n    var _a;\n    const key = getSplitKey(split);\n    const knownVal = getKnownValue == null ? void 0 : getKnownValue(key);\n    if (knownVal) {\n      variation[key] = knownVal;\n      return;\n    }\n    const numSlices = split.slices.length;\n    let chosenSlice = void 0;\n    if (split.type === \"experiment\") {\n      if (opts.useSeedBucketing) {\n        const seed = opts.traits[PLASMIC_SEED];\n        const buckets = [];\n        const totalBuckets = (_a = opts.seedRange) != null ? _a : 1;\n        let avaiableBuckets = totalBuckets;\n        for (let i = 0; i < numSlices; i++) {\n          const slice = split.slices[i];\n          const numBuckets = Math.min(\n            Math.floor(slice.prob * totalBuckets),\n            avaiableBuckets\n          );\n          for (let j = 0; j < numBuckets; j++) {\n            buckets.push(slice.id);\n          }\n          avaiableBuckets -= numBuckets;\n        }\n        if (buckets.length > 0) {\n          const shuffleRand = getSeededRandomFunction(split.id);\n          for (let i = 0; i < buckets.length; i++) {\n            const j = Math.floor(shuffleRand() * (i + 1));\n            [buckets[i], buckets[j]] = [buckets[j], buckets[i]];\n          }\n          const sliceIdx = +(seed != null ? seed : \"0\") % buckets.length;\n          chosenSlice = split.slices.find((s) => s.id === buckets[sliceIdx]);\n        } else {\n          chosenSlice = split.slices[numSlices - 1];\n        }\n      } else {\n        let p = getRandomValue(split.id);\n        chosenSlice = split.slices[numSlices - 1];\n        for (let i = 0; i < numSlices; i++) {\n          if (p - split.slices[i].prob <= 0) {\n            chosenSlice = split.slices[i];\n            break;\n          }\n          p -= split.slices[i].prob;\n        }\n      }\n    } else if (split.type === \"segment\") {\n      for (let i = 0; i < numSlices; i++) {\n        if (json_logic_js__WEBPACK_IMPORTED_MODULE_0___default().apply(split.slices[i].cond, __spreadValues(__spreadValues(__spreadValues({\n          time: (/* @__PURE__ */ new Date()).toISOString()\n        }, BUILTIN_TRAITS_UNKNOWN), getBrowserBuiltinTraits()), opts.traits))) {\n          chosenSlice = split.slices[i];\n        }\n      }\n    }\n    if (chosenSlice) {\n      variation[key] = chosenSlice.id;\n      if (split.externalId && chosenSlice.externalId) {\n        variation[`ext.${split.externalId}`] = chosenSlice.externalId;\n      }\n      if (split.type === \"experiment\") {\n        updateKnownValue == null ? void 0 : updateKnownValue(key, chosenSlice.id);\n      }\n    }\n  });\n  return variation;\n}\nfunction getExternalIds(splits, variation, filters) {\n  const externalVariation = {};\n  function shouldIncludeSplit(split) {\n    if (!filters) {\n      return true;\n    }\n    if (filters.projectIds && !filters.projectIds.includes(split.projectId)) {\n      return false;\n    }\n    if (filters.customFilter && !filters.customFilter(split)) {\n      return false;\n    }\n    return true;\n  }\n  Object.keys(variation).forEach((variationKey) => {\n    const [, splitId] = variationKey.split(\".\");\n    const sliceId = variation[variationKey];\n    const split = splits.find(\n      (s) => s.id === splitId || s.externalId === splitId\n    );\n    if (split && split.externalId && shouldIncludeSplit(split)) {\n      const slice = split.slices.find((s) => s.id === sliceId || s.externalId === sliceId);\n      if (slice == null ? void 0 : slice.externalId) {\n        externalVariation[`${split.externalId}`] = slice.externalId;\n      }\n    }\n  });\n  return externalVariation;\n}\nfunction describeVariationForKey(splits, key, value) {\n  const [, splitId] = key.split(\".\");\n  const split = splits.find(\n    (s) => s.id === splitId || s.externalId === splitId\n  );\n  if (!split) {\n    throw new Error(`Split not found for key \"${key}\"`);\n  }\n  const sliceIndex = split.slices.findIndex(\n    (s) => s.id === value || s.externalId === value\n  );\n  if (sliceIndex === -1) {\n    throw new Error(`Invalid split value \"${value}\" for key \"${key}\"`);\n  }\n  return {\n    name: split.name,\n    description: split.description,\n    pagesPaths: split.pagesPaths,\n    type: sliceIndex === 0 ? \"original\" : \"override\",\n    chosenValue: value,\n    externalIdGroup: split.externalId,\n    externalIdValue: sliceIndex >= 0 && split.slices[sliceIndex].externalId ? split.slices[sliceIndex].externalId : void 0\n  };\n}\nfunction describeVariation(splits, variation) {\n  return Object.fromEntries(\n    Object.entries(variation).map(([key, value]) => {\n      return [key, describeVariationForKey(splits, key, value)];\n    })\n  );\n}\n\n//# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcGxhc21pY2FwcC9sb2FkZXItc3BsaXRzL2Rpc3QvaW5kZXguZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOENBQThDLEVBQUUsU0FBUztBQUNyRTtBQUNBO0FBQ0EsVUFBVSwwQ0FBMEM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixnQkFBZ0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG9CQUFvQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHNCQUFzQixlQUFlO0FBQ3JDLFlBQVksMERBQWU7QUFDM0I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsaUJBQWlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsaUJBQWlCO0FBQzlDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxJQUFJO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsTUFBTSxhQUFhLElBQUk7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFRRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvd29uZGVybGFuZG1pdGNoL0Nhc2NhZGVQcm9qZWN0cy9Xb25kZXJWaXRlLWZyb250ZW5kL25vZGVfbW9kdWxlcy9AcGxhc21pY2FwcC9sb2FkZXItc3BsaXRzL2Rpc3QvaW5kZXguZXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcblxuLy8gc3JjL3JhbmRvbS50c1xudmFyIGdldFNlZWRlZFJhbmRvbUZ1bmN0aW9uID0gKHN0clNlZWQpID0+IHtcbiAgZnVuY3Rpb24gY3lyYjEyOChzdHIpIHtcbiAgICBsZXQgaDEgPSAxNzc5MDMzNzAzLCBoMiA9IDMxNDQxMzQyNzcsIGgzID0gMTAxMzkwNDI0MiwgaDQgPSAyNzczNDgwNzYyO1xuICAgIGZvciAobGV0IGkgPSAwLCBrOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICBoMSA9IGgyIF4gTWF0aC5pbXVsKGgxIF4gaywgNTk3Mzk5MDY3KTtcbiAgICAgIGgyID0gaDMgXiBNYXRoLmltdWwoaDIgXiBrLCAyODY5ODYwMjMzKTtcbiAgICAgIGgzID0gaDQgXiBNYXRoLmltdWwoaDMgXiBrLCA5NTEyNzQyMTMpO1xuICAgICAgaDQgPSBoMSBeIE1hdGguaW11bChoNCBeIGssIDI3MTYwNDQxNzkpO1xuICAgIH1cbiAgICBoMSA9IE1hdGguaW11bChoMyBeIGgxID4+PiAxOCwgNTk3Mzk5MDY3KTtcbiAgICBoMiA9IE1hdGguaW11bChoNCBeIGgyID4+PiAyMiwgMjg2OTg2MDIzMyk7XG4gICAgaDMgPSBNYXRoLmltdWwoaDEgXiBoMyA+Pj4gMTcsIDk1MTI3NDIxMyk7XG4gICAgaDQgPSBNYXRoLmltdWwoaDIgXiBoNCA+Pj4gMTksIDI3MTYwNDQxNzkpO1xuICAgIHJldHVybiBbXG4gICAgICAoaDEgXiBoMiBeIGgzIF4gaDQpID4+PiAwLFxuICAgICAgKGgyIF4gaDEpID4+PiAwLFxuICAgICAgKGgzIF4gaDEpID4+PiAwLFxuICAgICAgKGg0IF4gaDEpID4+PiAwXG4gICAgXTtcbiAgfVxuICBmdW5jdGlvbiBzZmMzMihhLCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgYSA+Pj49IDA7XG4gICAgICBiID4+Pj0gMDtcbiAgICAgIGMgPj4+PSAwO1xuICAgICAgZCA+Pj49IDA7XG4gICAgICBsZXQgdCA9IGEgKyBiIHwgMDtcbiAgICAgIGEgPSBiIF4gYiA+Pj4gOTtcbiAgICAgIGIgPSBjICsgKGMgPDwgMykgfCAwO1xuICAgICAgYyA9IGMgPDwgMjEgfCBjID4+PiAxMTtcbiAgICAgIGQgPSBkICsgMSB8IDA7XG4gICAgICB0ID0gdCArIGQgfCAwO1xuICAgICAgYyA9IGMgKyB0IHwgMDtcbiAgICAgIHJldHVybiAodCA+Pj4gMCkgLyA0Mjk0OTY3Mjk2O1xuICAgIH07XG4gIH1cbiAgY29uc3Qgc2VlZCA9IGN5cmIxMjgoc3RyU2VlZCk7XG4gIGNvbnN0IHJhbmQgPSBzZmMzMihzZWVkWzBdLCBzZWVkWzFdLCBzZWVkWzJdLCBzZWVkWzNdKTtcbiAgcmV0dXJuIHJhbmQ7XG59O1xuXG4vLyBzcmMvdmFyaWF0aW9uLnRzXG5pbXBvcnQganNvbkxvZ2ljIGZyb20gXCJqc29uLWxvZ2ljLWpzXCI7XG52YXIgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cgIT0gbnVsbCAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiO1xudmFyIFBMQVNNSUNfU0VFRCA9IFwicGxhc21pY19zZWVkXCI7XG52YXIgQlVJTFRJTl9UUkFJVFNfVU5LTk9XTiA9IHtcbiAgcGFnZVVybDogXCJ1bmtub3duXCJcbn07XG52YXIgZ2V0QnJvd3NlckJ1aWx0aW5UcmFpdHMgPSAoKSA9PiB7XG4gIGlmICghaXNCcm93c2VyKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgcGFnZVVybDogZG9jdW1lbnQubG9jYXRpb24uaHJlZlxuICB9O1xufTtcbnZhciBnZXRTcGxpdEtleSA9IChzcGxpdCkgPT4ge1xuICByZXR1cm4gYCR7c3BsaXQudHlwZSA9PT0gXCJleHBlcmltZW50XCIgPyBcImV4cC5cIiA6IFwic2VnLlwifSR7c3BsaXQuaWR9YDtcbn07XG5mdW5jdGlvbiBnZXRBY3RpdmVWYXJpYXRpb24ob3B0cykge1xuICBjb25zdCB7IHNwbGl0cywgZ2V0S25vd25WYWx1ZSwgdXBkYXRlS25vd25WYWx1ZSB9ID0gb3B0cztcbiAgY29uc3QgZ2V0UmFuZG9tVmFsdWUgPSAoa2V5KSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChvcHRzLmdldFJhbmRvbVZhbHVlKSB7XG4gICAgICByZXR1cm4gb3B0cy5nZXRSYW5kb21WYWx1ZShrZXkpO1xuICAgIH1cbiAgICBpZiAob3B0cy50cmFpdHNbUExBU01JQ19TRUVEXSkge1xuICAgICAgY29uc3QgcmFuZCA9IGdldFNlZWRlZFJhbmRvbUZ1bmN0aW9uKFxuICAgICAgICAoKF9hID0gb3B0cy50cmFpdHNbUExBU01JQ19TRUVEXSkgIT0gbnVsbCA/IF9hIDogXCJcIikgKyBrZXlcbiAgICAgICk7XG4gICAgICByZXR1cm4gcmFuZCgpO1xuICAgIH1cbiAgICBpZiAoIW9wdHMuZW5hYmxlVW5zZWVkZWRFeHBlcmltZW50cykge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpO1xuICB9O1xuICBjb25zdCB2YXJpYXRpb24gPSB7fTtcbiAgc3BsaXRzLmZvckVhY2goKHNwbGl0KSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGtleSA9IGdldFNwbGl0S2V5KHNwbGl0KTtcbiAgICBjb25zdCBrbm93blZhbCA9IGdldEtub3duVmFsdWUgPT0gbnVsbCA/IHZvaWQgMCA6IGdldEtub3duVmFsdWUoa2V5KTtcbiAgICBpZiAoa25vd25WYWwpIHtcbiAgICAgIHZhcmlhdGlvbltrZXldID0ga25vd25WYWw7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG51bVNsaWNlcyA9IHNwbGl0LnNsaWNlcy5sZW5ndGg7XG4gICAgbGV0IGNob3NlblNsaWNlID0gdm9pZCAwO1xuICAgIGlmIChzcGxpdC50eXBlID09PSBcImV4cGVyaW1lbnRcIikge1xuICAgICAgaWYgKG9wdHMudXNlU2VlZEJ1Y2tldGluZykge1xuICAgICAgICBjb25zdCBzZWVkID0gb3B0cy50cmFpdHNbUExBU01JQ19TRUVEXTtcbiAgICAgICAgY29uc3QgYnVja2V0cyA9IFtdO1xuICAgICAgICBjb25zdCB0b3RhbEJ1Y2tldHMgPSAoX2EgPSBvcHRzLnNlZWRSYW5nZSkgIT0gbnVsbCA/IF9hIDogMTtcbiAgICAgICAgbGV0IGF2YWlhYmxlQnVja2V0cyA9IHRvdGFsQnVja2V0cztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1TbGljZXM7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHNsaWNlID0gc3BsaXQuc2xpY2VzW2ldO1xuICAgICAgICAgIGNvbnN0IG51bUJ1Y2tldHMgPSBNYXRoLm1pbihcbiAgICAgICAgICAgIE1hdGguZmxvb3Ioc2xpY2UucHJvYiAqIHRvdGFsQnVja2V0cyksXG4gICAgICAgICAgICBhdmFpYWJsZUJ1Y2tldHNcbiAgICAgICAgICApO1xuICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbnVtQnVja2V0czsgaisrKSB7XG4gICAgICAgICAgICBidWNrZXRzLnB1c2goc2xpY2UuaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhdmFpYWJsZUJ1Y2tldHMgLT0gbnVtQnVja2V0cztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnVja2V0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3Qgc2h1ZmZsZVJhbmQgPSBnZXRTZWVkZWRSYW5kb21GdW5jdGlvbihzcGxpdC5pZCk7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWNrZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBqID0gTWF0aC5mbG9vcihzaHVmZmxlUmFuZCgpICogKGkgKyAxKSk7XG4gICAgICAgICAgICBbYnVja2V0c1tpXSwgYnVja2V0c1tqXV0gPSBbYnVja2V0c1tqXSwgYnVja2V0c1tpXV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHNsaWNlSWR4ID0gKyhzZWVkICE9IG51bGwgPyBzZWVkIDogXCIwXCIpICUgYnVja2V0cy5sZW5ndGg7XG4gICAgICAgICAgY2hvc2VuU2xpY2UgPSBzcGxpdC5zbGljZXMuZmluZCgocykgPT4gcy5pZCA9PT0gYnVja2V0c1tzbGljZUlkeF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNob3NlblNsaWNlID0gc3BsaXQuc2xpY2VzW251bVNsaWNlcyAtIDFdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgcCA9IGdldFJhbmRvbVZhbHVlKHNwbGl0LmlkKTtcbiAgICAgICAgY2hvc2VuU2xpY2UgPSBzcGxpdC5zbGljZXNbbnVtU2xpY2VzIC0gMV07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtU2xpY2VzOyBpKyspIHtcbiAgICAgICAgICBpZiAocCAtIHNwbGl0LnNsaWNlc1tpXS5wcm9iIDw9IDApIHtcbiAgICAgICAgICAgIGNob3NlblNsaWNlID0gc3BsaXQuc2xpY2VzW2ldO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHAgLT0gc3BsaXQuc2xpY2VzW2ldLnByb2I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNwbGl0LnR5cGUgPT09IFwic2VnbWVudFwiKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVNsaWNlczsgaSsrKSB7XG4gICAgICAgIGlmIChqc29uTG9naWMuYXBwbHkoc3BsaXQuc2xpY2VzW2ldLmNvbmQsIF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgICAgICB0aW1lOiAoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgfSwgQlVJTFRJTl9UUkFJVFNfVU5LTk9XTiksIGdldEJyb3dzZXJCdWlsdGluVHJhaXRzKCkpLCBvcHRzLnRyYWl0cykpKSB7XG4gICAgICAgICAgY2hvc2VuU2xpY2UgPSBzcGxpdC5zbGljZXNbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNob3NlblNsaWNlKSB7XG4gICAgICB2YXJpYXRpb25ba2V5XSA9IGNob3NlblNsaWNlLmlkO1xuICAgICAgaWYgKHNwbGl0LmV4dGVybmFsSWQgJiYgY2hvc2VuU2xpY2UuZXh0ZXJuYWxJZCkge1xuICAgICAgICB2YXJpYXRpb25bYGV4dC4ke3NwbGl0LmV4dGVybmFsSWR9YF0gPSBjaG9zZW5TbGljZS5leHRlcm5hbElkO1xuICAgICAgfVxuICAgICAgaWYgKHNwbGl0LnR5cGUgPT09IFwiZXhwZXJpbWVudFwiKSB7XG4gICAgICAgIHVwZGF0ZUtub3duVmFsdWUgPT0gbnVsbCA/IHZvaWQgMCA6IHVwZGF0ZUtub3duVmFsdWUoa2V5LCBjaG9zZW5TbGljZS5pZCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHZhcmlhdGlvbjtcbn1cbmZ1bmN0aW9uIGdldEV4dGVybmFsSWRzKHNwbGl0cywgdmFyaWF0aW9uLCBmaWx0ZXJzKSB7XG4gIGNvbnN0IGV4dGVybmFsVmFyaWF0aW9uID0ge307XG4gIGZ1bmN0aW9uIHNob3VsZEluY2x1ZGVTcGxpdChzcGxpdCkge1xuICAgIGlmICghZmlsdGVycykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChmaWx0ZXJzLnByb2plY3RJZHMgJiYgIWZpbHRlcnMucHJvamVjdElkcy5pbmNsdWRlcyhzcGxpdC5wcm9qZWN0SWQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChmaWx0ZXJzLmN1c3RvbUZpbHRlciAmJiAhZmlsdGVycy5jdXN0b21GaWx0ZXIoc3BsaXQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIE9iamVjdC5rZXlzKHZhcmlhdGlvbikuZm9yRWFjaCgodmFyaWF0aW9uS2V5KSA9PiB7XG4gICAgY29uc3QgWywgc3BsaXRJZF0gPSB2YXJpYXRpb25LZXkuc3BsaXQoXCIuXCIpO1xuICAgIGNvbnN0IHNsaWNlSWQgPSB2YXJpYXRpb25bdmFyaWF0aW9uS2V5XTtcbiAgICBjb25zdCBzcGxpdCA9IHNwbGl0cy5maW5kKFxuICAgICAgKHMpID0+IHMuaWQgPT09IHNwbGl0SWQgfHwgcy5leHRlcm5hbElkID09PSBzcGxpdElkXG4gICAgKTtcbiAgICBpZiAoc3BsaXQgJiYgc3BsaXQuZXh0ZXJuYWxJZCAmJiBzaG91bGRJbmNsdWRlU3BsaXQoc3BsaXQpKSB7XG4gICAgICBjb25zdCBzbGljZSA9IHNwbGl0LnNsaWNlcy5maW5kKChzKSA9PiBzLmlkID09PSBzbGljZUlkIHx8IHMuZXh0ZXJuYWxJZCA9PT0gc2xpY2VJZCk7XG4gICAgICBpZiAoc2xpY2UgPT0gbnVsbCA/IHZvaWQgMCA6IHNsaWNlLmV4dGVybmFsSWQpIHtcbiAgICAgICAgZXh0ZXJuYWxWYXJpYXRpb25bYCR7c3BsaXQuZXh0ZXJuYWxJZH1gXSA9IHNsaWNlLmV4dGVybmFsSWQ7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGV4dGVybmFsVmFyaWF0aW9uO1xufVxuZnVuY3Rpb24gZGVzY3JpYmVWYXJpYXRpb25Gb3JLZXkoc3BsaXRzLCBrZXksIHZhbHVlKSB7XG4gIGNvbnN0IFssIHNwbGl0SWRdID0ga2V5LnNwbGl0KFwiLlwiKTtcbiAgY29uc3Qgc3BsaXQgPSBzcGxpdHMuZmluZChcbiAgICAocykgPT4gcy5pZCA9PT0gc3BsaXRJZCB8fCBzLmV4dGVybmFsSWQgPT09IHNwbGl0SWRcbiAgKTtcbiAgaWYgKCFzcGxpdCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgU3BsaXQgbm90IGZvdW5kIGZvciBrZXkgXCIke2tleX1cImApO1xuICB9XG4gIGNvbnN0IHNsaWNlSW5kZXggPSBzcGxpdC5zbGljZXMuZmluZEluZGV4KFxuICAgIChzKSA9PiBzLmlkID09PSB2YWx1ZSB8fCBzLmV4dGVybmFsSWQgPT09IHZhbHVlXG4gICk7XG4gIGlmIChzbGljZUluZGV4ID09PSAtMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzcGxpdCB2YWx1ZSBcIiR7dmFsdWV9XCIgZm9yIGtleSBcIiR7a2V5fVwiYCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBzcGxpdC5uYW1lLFxuICAgIGRlc2NyaXB0aW9uOiBzcGxpdC5kZXNjcmlwdGlvbixcbiAgICBwYWdlc1BhdGhzOiBzcGxpdC5wYWdlc1BhdGhzLFxuICAgIHR5cGU6IHNsaWNlSW5kZXggPT09IDAgPyBcIm9yaWdpbmFsXCIgOiBcIm92ZXJyaWRlXCIsXG4gICAgY2hvc2VuVmFsdWU6IHZhbHVlLFxuICAgIGV4dGVybmFsSWRHcm91cDogc3BsaXQuZXh0ZXJuYWxJZCxcbiAgICBleHRlcm5hbElkVmFsdWU6IHNsaWNlSW5kZXggPj0gMCAmJiBzcGxpdC5zbGljZXNbc2xpY2VJbmRleF0uZXh0ZXJuYWxJZCA/IHNwbGl0LnNsaWNlc1tzbGljZUluZGV4XS5leHRlcm5hbElkIDogdm9pZCAwXG4gIH07XG59XG5mdW5jdGlvbiBkZXNjcmliZVZhcmlhdGlvbihzcGxpdHMsIHZhcmlhdGlvbikge1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIE9iamVjdC5lbnRyaWVzKHZhcmlhdGlvbikubWFwKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIHJldHVybiBba2V5LCBkZXNjcmliZVZhcmlhdGlvbkZvcktleShzcGxpdHMsIGtleSwgdmFsdWUpXTtcbiAgICB9KVxuICApO1xufVxuZXhwb3J0IHtcbiAgZGVzY3JpYmVWYXJpYXRpb24sXG4gIGRlc2NyaWJlVmFyaWF0aW9uRm9yS2V5LFxuICBnZXRBY3RpdmVWYXJpYXRpb24sXG4gIGdldEV4dGVybmFsSWRzLFxuICBnZXRTZWVkZWRSYW5kb21GdW5jdGlvbixcbiAgZ2V0U3BsaXRLZXlcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lc20uanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@plasmicapp/loader-splits/dist/index.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@plasmicapp/prepass/dist/index.esm.js":
/*!************************************************************!*\
  !*** ./node_modules/@plasmicapp/prepass/dist/index.esm.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   extractPlasmicQueryData: () => (/* binding */ extractPlasmicQueryData),\n/* harmony export */   plasmicPrepass: () => (/* binding */ plasmicPrepass),\n/* harmony export */   plasmicPrepassExtract: () => (/* binding */ plasmicPrepassExtract)\n/* harmony export */ });\n/* harmony import */ var _plasmicapp_query__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @plasmicapp/query */ \"(app-pages-browser)/./node_modules/@plasmicapp/query/dist/index.esm.js\");\n/* harmony import */ var _plasmicapp_react_ssr_prepass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @plasmicapp/react-ssr-prepass */ \"(app-pages-browser)/./node_modules/@plasmicapp/react-ssr-prepass/dist/react-ssr-prepass.es.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\nasync function plasmicPrepassExtract(element, onClientComponentRef) {\n  const cache = /* @__PURE__ */ new Map();\n  const headMetadata = {};\n  try {\n    await plasmicPrepass(\n      /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_plasmicapp_query__WEBPACK_IMPORTED_MODULE_0__.PlasmicPrepassContext, { cache }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_plasmicapp_query__WEBPACK_IMPORTED_MODULE_0__.HeadMetadataContext.Provider, { value: headMetadata }, element)),\n      onClientComponentRef\n    );\n  } catch (err) {\n    console.warn(`PLASMIC: Error encountered while pre-rendering`, err);\n  }\n  const filteredCache = Object.fromEntries(\n    Array.from(cache.entries()).filter(\n      ([key, val]) => !key.startsWith(\"$swr$\") && !key.startsWith(\"$csq$\") && val !== void 0\n    )\n  );\n  const queryData = (() => {\n    try {\n      return JSON.parse(\n        JSON.stringify(\n          filteredCache,\n          (_key, value) => value !== void 0 ? value : null\n        )\n      );\n    } catch {\n      return filteredCache;\n    }\n  })();\n  return {\n    queryData,\n    headMetadata\n  };\n}\nasync function extractPlasmicQueryData(element, onClientComponentRef) {\n  return (await plasmicPrepassExtract(element, onClientComponentRef)).queryData;\n}\nasync function plasmicPrepass(element, onClientComponentRef) {\n  await (0,_plasmicapp_react_ssr_prepass__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(element, void 0, onClientComponentRef);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcGxhc21pY2FwcC9wcmVwYXNzL2Rpc3QvaW5kZXguZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFHMkI7QUFDeUI7QUFDMUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwwREFBbUIsQ0FBQyxvRUFBcUIsSUFBSSxPQUFPLGtCQUFrQiwwREFBbUIsQ0FBQyxrRUFBbUIsYUFBYSxxQkFBcUI7QUFDcks7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlFQUFPO0FBQ2Y7QUFLRSIsInNvdXJjZXMiOlsiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvV29uZGVyVml0ZS1mcm9udGVuZC9ub2RlX21vZHVsZXMvQHBsYXNtaWNhcHAvcHJlcGFzcy9kaXN0L2luZGV4LmVzbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBIZWFkTWV0YWRhdGFDb250ZXh0LFxuICBQbGFzbWljUHJlcGFzc0NvbnRleHRcbn0gZnJvbSBcIkBwbGFzbWljYXBwL3F1ZXJ5XCI7XG5pbXBvcnQgcHJlcGFzcyBmcm9tIFwiQHBsYXNtaWNhcHAvcmVhY3Qtc3NyLXByZXBhc3NcIjtcbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmFzeW5jIGZ1bmN0aW9uIHBsYXNtaWNQcmVwYXNzRXh0cmFjdChlbGVtZW50LCBvbkNsaWVudENvbXBvbmVudFJlZikge1xuICBjb25zdCBjYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IGhlYWRNZXRhZGF0YSA9IHt9O1xuICB0cnkge1xuICAgIGF3YWl0IHBsYXNtaWNQcmVwYXNzKFxuICAgICAgLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUGxhc21pY1ByZXBhc3NDb250ZXh0LCB7IGNhY2hlIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KEhlYWRNZXRhZGF0YUNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGhlYWRNZXRhZGF0YSB9LCBlbGVtZW50KSksXG4gICAgICBvbkNsaWVudENvbXBvbmVudFJlZlxuICAgICk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUud2FybihgUExBU01JQzogRXJyb3IgZW5jb3VudGVyZWQgd2hpbGUgcHJlLXJlbmRlcmluZ2AsIGVycik7XG4gIH1cbiAgY29uc3QgZmlsdGVyZWRDYWNoZSA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBBcnJheS5mcm9tKGNhY2hlLmVudHJpZXMoKSkuZmlsdGVyKFxuICAgICAgKFtrZXksIHZhbF0pID0+ICFrZXkuc3RhcnRzV2l0aChcIiRzd3IkXCIpICYmICFrZXkuc3RhcnRzV2l0aChcIiRjc3EkXCIpICYmIHZhbCAhPT0gdm9pZCAwXG4gICAgKVxuICApO1xuICBjb25zdCBxdWVyeURhdGEgPSAoKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgZmlsdGVyZWRDYWNoZSxcbiAgICAgICAgICAoX2tleSwgdmFsdWUpID0+IHZhbHVlICE9PSB2b2lkIDAgPyB2YWx1ZSA6IG51bGxcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBmaWx0ZXJlZENhY2hlO1xuICAgIH1cbiAgfSkoKTtcbiAgcmV0dXJuIHtcbiAgICBxdWVyeURhdGEsXG4gICAgaGVhZE1ldGFkYXRhXG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiBleHRyYWN0UGxhc21pY1F1ZXJ5RGF0YShlbGVtZW50LCBvbkNsaWVudENvbXBvbmVudFJlZikge1xuICByZXR1cm4gKGF3YWl0IHBsYXNtaWNQcmVwYXNzRXh0cmFjdChlbGVtZW50LCBvbkNsaWVudENvbXBvbmVudFJlZikpLnF1ZXJ5RGF0YTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHBsYXNtaWNQcmVwYXNzKGVsZW1lbnQsIG9uQ2xpZW50Q29tcG9uZW50UmVmKSB7XG4gIGF3YWl0IHByZXBhc3MoZWxlbWVudCwgdm9pZCAwLCBvbkNsaWVudENvbXBvbmVudFJlZik7XG59XG5leHBvcnQge1xuICBleHRyYWN0UGxhc21pY1F1ZXJ5RGF0YSxcbiAgcGxhc21pY1ByZXBhc3MsXG4gIHBsYXNtaWNQcmVwYXNzRXh0cmFjdFxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@plasmicapp/prepass/dist/index.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@plasmicapp/query/dist/index.esm.js":
/*!**********************************************************!*\
  !*** ./node_modules/@plasmicapp/query/dist/index.esm.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HeadMetadataContext: () => (/* binding */ HeadMetadataContext),\n/* harmony export */   PlasmicPrepassContext: () => (/* binding */ PlasmicPrepassContext),\n/* harmony export */   PlasmicQueryDataProvider: () => (/* binding */ PlasmicQueryDataProvider),\n/* harmony export */   addLoadingStateListener: () => (/* binding */ addLoadingStateListener),\n/* harmony export */   isPlasmicPrepass: () => (/* binding */ isPlasmicPrepass),\n/* harmony export */   useMutablePlasmicQueryData: () => (/* binding */ useMutablePlasmicQueryData),\n/* harmony export */   usePlasmicDataConfig: () => (/* binding */ usePlasmicDataConfig),\n/* harmony export */   usePlasmicQueryData: () => (/* binding */ usePlasmicQueryData),\n/* harmony export */   useSWRConfig: () => (/* reexport safe */ swr__WEBPACK_IMPORTED_MODULE_1__.useSWRConfig),\n/* harmony export */   wrapLoadingFetcher: () => (/* binding */ wrapLoadingFetcher)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var swr__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! swr */ \"(app-pages-browser)/./node_modules/swr/dist/index.mjs\");\n/* __next_internal_client_entry_do_not_use__ HeadMetadataContext,PlasmicPrepassContext,PlasmicQueryDataProvider,addLoadingStateListener,isPlasmicPrepass,useMutablePlasmicQueryData,usePlasmicDataConfig,usePlasmicQueryData,useSWRConfig,wrapLoadingFetcher auto */ var _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$();\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __spreadValues = (a, b)=>{\n    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){\n        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n    }\n    return a;\n};\nvar __async = (__this, __arguments, generator)=>{\n    return new Promise((resolve, reject)=>{\n        var fulfilled = (value)=>{\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        };\n        var rejected = (value)=>{\n            try {\n                step(generator.throw(value));\n            } catch (e) {\n                reject(e);\n            }\n        };\n        var step = (x)=>x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n        step((generator = generator.apply(__this, __arguments)).next());\n    });\n};\n// src/query-data.tsx\n\n\nvar __SWRConfig = void 0;\nvar mutateKeys = (invalidateKey)=>{\n    if (__SWRConfig) {\n        const { cache, mutate } = __SWRConfig;\n        (invalidateKey != null ? [\n            invalidateKey\n        ] : Array.from(cache.keys())).forEach((key)=>{\n            mutate(key);\n        });\n    }\n};\nfunction getPlasmicDefaultSWROptions(opts) {\n    return {\n        revalidateIfStale: !!(opts == null ? void 0 : opts.isMutable),\n        revalidateOnFocus: false,\n        revalidateOnReconnect: false\n    };\n}\nfunction usePlasmicQueryData(key, fetcher) {\n    _s();\n    const prepassCtx = react__WEBPACK_IMPORTED_MODULE_0___default().useContext(PrepassContext);\n    const opts = getPlasmicDefaultSWROptions();\n    if (prepassCtx) {\n        opts.suspense = true;\n    }\n    const config = (0,swr__WEBPACK_IMPORTED_MODULE_1__.useSWRConfig)();\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect({\n        \"usePlasmicQueryData.useEffect\": ()=>{\n            __SWRConfig = config;\n        }\n    }[\"usePlasmicQueryData.useEffect\"], [\n        config\n    ]);\n    const wrappedFetcher = react__WEBPACK_IMPORTED_MODULE_0___default().useMemo({\n        \"usePlasmicQueryData.useMemo[wrappedFetcher]\": ()=>wrapLoadingFetcher(fetcher)\n    }[\"usePlasmicQueryData.useMemo[wrappedFetcher]\"], [\n        fetcher\n    ]);\n    const resp = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(key, wrappedFetcher, opts);\n    if (resp.data !== void 0) {\n        return {\n            data: resp.data\n        };\n    } else if (resp.error) {\n        return {\n            error: resp.error\n        };\n    } else {\n        return {\n            isLoading: true\n        };\n    }\n}\n_s(usePlasmicQueryData, \"8+QA3h8VczVwC0vYeiaS9BicWUA=\", false, function() {\n    return [\n        swr__WEBPACK_IMPORTED_MODULE_1__.useSWRConfig,\n        swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\n    ];\n});\nfunction useMutablePlasmicQueryData(key, fetcher, options) {\n    var _this = this;\n    _s1();\n    const prepassCtx = react__WEBPACK_IMPORTED_MODULE_0___default().useContext(PrepassContext);\n    const opts = __spreadValues(__spreadValues({}, getPlasmicDefaultSWROptions({\n        isMutable: true\n    })), options);\n    if (prepassCtx) {\n        opts.suspense = true;\n    }\n    const config = (0,swr__WEBPACK_IMPORTED_MODULE_1__.useSWRConfig)();\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect({\n        \"useMutablePlasmicQueryData.useEffect\": ()=>{\n            __SWRConfig = config;\n        }\n    }[\"useMutablePlasmicQueryData.useEffect\"], [\n        config\n    ]);\n    const [isLoading, setIsLoading] = react__WEBPACK_IMPORTED_MODULE_0___default().useState(false);\n    const fetcherWrapper = react__WEBPACK_IMPORTED_MODULE_0___default().useCallback({\n        \"useMutablePlasmicQueryData.useCallback[fetcherWrapper]\": function() {\n            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                args[_key] = arguments[_key];\n            }\n            return __async(_this, null, {\n                \"useMutablePlasmicQueryData.useCallback[fetcherWrapper]\": function*() {\n                    setIsLoading(true);\n                    try {\n                        return yield wrapLoadingFetcher(fetcher)(...args);\n                    } finally{\n                        setIsLoading(false);\n                    }\n                }\n            }[\"useMutablePlasmicQueryData.useCallback[fetcherWrapper]\"]);\n        }\n    }[\"useMutablePlasmicQueryData.useCallback[fetcherWrapper]\"], [\n        fetcher\n    ]);\n    const laggyDataRef = react__WEBPACK_IMPORTED_MODULE_0___default().useRef();\n    const { isValidating, mutate, data, error } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(key, fetcherWrapper, opts);\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect({\n        \"useMutablePlasmicQueryData.useEffect\": ()=>{\n            if (data !== void 0) {\n                laggyDataRef.current = data;\n            }\n        }\n    }[\"useMutablePlasmicQueryData.useEffect\"], [\n        data\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0___default().useMemo({\n        \"useMutablePlasmicQueryData.useMemo\": ()=>__spreadValues(__spreadValues({\n                isValidating,\n                mutate,\n                isLoading: data === void 0 && error === void 0 || isLoading\n            }, data !== void 0 ? {\n                data\n            } : error === void 0 && laggyDataRef.current ? // Show previous data if available\n            {\n                data: laggyDataRef.current,\n                isLagging: true\n            } : {}), error !== void 0 ? {\n                error\n            } : {})\n    }[\"useMutablePlasmicQueryData.useMemo\"], [\n        isValidating,\n        mutate,\n        data,\n        error,\n        isLoading\n    ]);\n}\n_s1(useMutablePlasmicQueryData, \"THGuHwXpSRGhsCMin+AvW8MjD2c=\", false, function() {\n    return [\n        swr__WEBPACK_IMPORTED_MODULE_1__.useSWRConfig,\n        swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\n    ];\n});\nfunction PlasmicQueryDataProvider(props) {\n    _s2();\n    const { children, suspense, prefetchedCache } = props;\n    const prepass = react__WEBPACK_IMPORTED_MODULE_0___default().useContext(PrepassContext);\n    if (prepass) {\n        return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), null, children);\n    } else {\n        return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(swr__WEBPACK_IMPORTED_MODULE_1__.SWRConfig, {\n            value: {\n                fallback: prefetchedCache != null ? prefetchedCache : {},\n                suspense\n            }\n        }, children);\n    }\n}\n_s2(PlasmicQueryDataProvider, \"dc64/unfZaC9mPUXtd0iLAXND+E=\");\n_c = PlasmicQueryDataProvider;\nvar PrepassContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext(false);\nfunction PlasmicPrepassContext(props) {\n    const { cache, children } = props;\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(PrepassContext.Provider, {\n        value: true\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(swr__WEBPACK_IMPORTED_MODULE_1__.SWRConfig, {\n        value: {\n            provider: ()=>cache,\n            suspense: true,\n            fallback: {}\n        }\n    }, children));\n}\n_c1 = PlasmicPrepassContext;\nvar usePlasmicDataConfig = swr__WEBPACK_IMPORTED_MODULE_1__.useSWRConfig;\nvar loadingCount = 0;\nvar listeners = [];\nfunction addLoadingStateListener(listener, opts) {\n    listeners.push(listener);\n    if (opts == null ? void 0 : opts.immediate) {\n        listener(loadingCount > 0);\n    }\n    return ()=>{\n        listeners.splice(listeners.indexOf(listener), 1);\n    };\n}\nfunction wrapLoadingFetcher(fetcher) {\n    var _this = this;\n    return function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        return __async(_this, null, function*() {\n            if (loadingCount === 0) {\n                listeners.forEach((listener)=>listener(true));\n            }\n            loadingCount += 1;\n            try {\n                const res = fetcher(...args);\n                return isPromiseLike(res) ? yield res : res;\n            } finally{\n                loadingCount -= 1;\n                if (loadingCount === 0) {\n                    listeners.forEach((listener)=>listener(false));\n                }\n            }\n        });\n    };\n}\nfunction isPromiseLike(x) {\n    return !!x && typeof x === \"object\" && \"then\" in x && typeof x.then === \"function\";\n}\nfunction isPlasmicPrepass() {\n    var _a, _b, _c;\n    return !!((_c = (_b = (_a = (react__WEBPACK_IMPORTED_MODULE_0___default().__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED)) == null ? void 0 : _a.ReactCurrentDispatcher) == null ? void 0 : _b.current) == null ? void 0 : _c.isPlasmicPrepass);\n}\nvar HeadMetadataContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext({});\n// src/index.tsx\n\nif (typeof window !== \"undefined\") {\n    const root = window;\n    const maybeExistingMutateAllKeys = root.__SWRMutateAllKeys;\n    root.__SWRMutateAllKeys = (invalidateKey)=>{\n        mutateKeys(invalidateKey);\n        if (typeof maybeExistingMutateAllKeys === \"function\") {\n            maybeExistingMutateAllKeys(invalidateKey);\n        }\n    };\n}\n //# sourceMappingURL=index.esm.js.map\nvar _c, _c1;\n$RefreshReg$(_c, \"PlasmicQueryDataProvider\");\n$RefreshReg$(_c1, \"PlasmicPrepassContext\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcGxhc21pY2FwcC9xdWVyeS9kaXN0L2luZGV4LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXlDO0FBUWxDO0FBSVAsSUFBSSxjQUEyRDtBQUN4RCxJQUFNLGFBQWEsQ0FBQztJQUN6QixJQUFJLGFBQWE7UUFDZixNQUFNLEVBQUUsT0FBTyxPQUFPLElBQUk7U0FDekIsaUJBQWlCLE9BQ2Q7WUFBQyxhQUFhO1NBQUEsR0FDZCxNQUFNLEtBQU0sTUFBMkIsS0FBSyxFQUFDLEVBQy9DLFFBQVEsQ0FBQztZQUNULE9BQU8sR0FBRztRQUNaLENBQUM7SUFDSDtBQUNGO0FBSUEsU0FBUyw0QkFBNEIsTUFFaEI7SUFDbkIsT0FBTztRQUNMLG1CQUFtQixDQUFDLEVBQUMsNkJBQU07UUFDM0IsbUJBQW1CO1FBQ25CLHVCQUF1QjtJQUN6QjtBQUNGO0FBWU8sNkJBQ0wsS0FDQSxTQUNrRDs7SUFDbEQsTUFBTSxhQUFhLHVEQUFNLENBQVcsY0FBYztJQUVsRCxNQUFNLE9BQU8sNEJBQTRCO0lBQ3pDLElBQUksWUFBWTtRQUdkLEtBQUssV0FBVztJQUNsQjtJQUVBLE1BQU0sU0FBUyxpREFBWTtJQUMzQixzREFBTTt5Q0FBVTtZQUNkLGNBQWM7UUFDaEI7d0NBQUc7UUFBQyxNQUFNO0tBQUM7SUFFWCxNQUFNLGlCQUFpQixvREFBTTt1REFDM0IsSUFBTSxtQkFBbUIsT0FBTztzREFDaEM7UUFBQyxPQUFPO0tBQUE7SUFHVixNQUFNLE9BQU8sK0NBQU0sQ0FBQyxLQUFLLGdCQUFnQixJQUFJO0lBQzdDLElBQUksS0FBSyxTQUFTLFFBQVc7UUFDM0IsT0FBTztZQUFFLE1BQU0sS0FBSztRQUFLO0lBQzNCLFdBQVcsS0FBSyxPQUFPO1FBQ3JCLE9BQU87WUFBRSxPQUFPLEtBQUs7UUFBTTtJQUM3QixPQUFPO1FBQ0wsT0FBTztZQUFFLFdBQVc7UUFBSztJQUMzQjtBQUNGO0dBL0JnQjs7UUFhQyw2Q0FBWSxDQUFDO1FBVWYsMkNBQU07OztBQW9CZCxvQ0FDTCxLQUNBLFNBQ0EsU0FDa0U7OztJQUNsRSxNQUFNLGFBQWEsdURBQU0sQ0FBVyxjQUFjO0lBRWxELE1BQU0sT0FBTyxrQ0FDUiw0QkFBNEI7UUFBRSxXQUFXO0lBQUssQ0FBQyxJQUMvQztJQUVMLElBQUksWUFBWTtRQUNkLEtBQUssV0FBVztJQUNsQjtJQUVBLE1BQU0sU0FBUyxpREFBWTtJQUMzQixzREFBTTtnREFBVTtZQUNkLGNBQWM7UUFDaEI7K0NBQUc7UUFBQyxNQUFNO0tBQUM7SUFFWCxNQUFNLENBQUMsV0FBVyxZQUFZLElBQUkscURBQU0sQ0FBUyxLQUFLO0lBQ3RELE1BQU0saUJBQWlCLHdEQUFNO2tFQUMzQjs7Z0JBQVU7O21CQUFnQjswRUFBQTtvQkFDeEIsYUFBYSxJQUFJO29CQUNqQixJQUFJO3dCQUNGLE9BQU8sTUFBTSxtQkFBbUIsT0FBTyxFQUFFLEdBQUcsSUFBSTtvQkFDbEQsU0FBRTt3QkFDQSxhQUFhLEtBQUs7b0JBQ3BCO2dCQUNGOzs7aUVBQ0E7UUFBQyxPQUFPO0tBQUE7SUFJVixNQUFNLGVBQWUsbURBQU0sQ0FBWTtJQUV2QyxNQUFNLEVBQUUsY0FBYyxRQUFRLE1BQU0sTUFBTSxvREFDeEMsS0FDQSxnQkFDQTtJQUdGLHNEQUFNO2dEQUFVO1lBQ2QsSUFBSSxTQUFTLFFBQVc7Z0JBQ3RCLGFBQWEsVUFBVTtZQUN6QjtRQUNGOytDQUFHO1FBQUMsSUFBSTtLQUFDO0lBRVQsT0FBTyxvREFBTTs4Q0FDWCxJQUFPO2dCQUNMO2dCQUNBO2dCQUNBLFdBQVksU0FBUyxVQUFhLFVBQVUsVUFBYztZQUFBLEdBQ3RELFNBQVMsU0FDVDtnQkFBRTtZQUFLLElBQ1AsVUFBVSxVQUFhLGFBQWE7WUFFcEM7Z0JBQUUsTUFBTSxhQUFhO2dCQUFTLFdBQVc7WUFBSyxJQUM5QyxDQUFDLElBQ0QsVUFBVSxTQUFZO2dCQUFFO1lBQU0sSUFBSSxDQUFDOzZDQUV6QztRQUFDO1FBQWM7UUFBUTtRQUFNO1FBQU8sU0FBUztLQUFBO0FBRWpEO0lBL0RnQjs7UUFlQyw2Q0FBWSxDQUFDO1FBcUJrQiwyQ0FBTTs7O0FBNkIvQyxrQ0FBa0MsT0FJdEM7O0lBQ0QsTUFBTSxFQUFFLFVBQVUsVUFBVSxnQkFBZ0IsSUFBSTtJQUNoRCxNQUFNLFVBQVUsdURBQU0sQ0FBVyxjQUFjO0lBQy9DLElBQUksU0FBUztRQUdYLE9BQU8sd0pBQUcsUUFBUztJQUNyQixPQUFPO1FBQ0wsT0FDRSx5RkFBQywwQ0FBUyxFQUFUO1lBQ0MsT0FBTztnQkFDTCxVQUFVLDRDQUFtQixDQUFDO2dCQUM5QjtZQUNGO1FBQUEsR0FFQztJQUdQO0FBQ0Y7O0tBdkJnQjtBQXlCaEIsSUFBTSwrQkFBaUIsMERBQU0sQ0FBdUIsS0FBSztBQUVsRCwrQkFDTCxPQUdBO0lBQ0EsTUFBTSxFQUFFLE9BQU8sU0FBUyxJQUFJO0lBQzVCLE9BQ0UseUZBQUMsZUFBZSxVQUFmO1FBQXdCLE9BQU87SUFBQSxHQUM5Qix5RkFBQywwQ0FBUyxFQUFUO1FBQ0MsT0FBTztZQUNMLFVBQVUsSUFBTTtZQUNoQixVQUFVO1lBQ1YsVUFBVSxDQUFDO1FBQ2I7SUFBQSxHQUVDO0FBSVQ7TUFuQmdCO0FBcUJULElBQU0sdUJBQTRDLDZDQUFZO0FBRXJFLElBQUksZUFBZTtBQUVuQixJQUFNLFlBQW9DLENBQUM7QUFNcEMsU0FBUyx3QkFDZCxVQUNBLE1BQ0E7SUFDQSxVQUFVLEtBQUssUUFBUTtJQUN2QixJQUFJLDZCQUFNLFdBQVc7UUFDbkIsU0FBUyxlQUFlLENBQUM7SUFDM0I7SUFDQSxPQUFPO1FBQ0wsVUFBVSxPQUFPLFVBQVUsUUFBUSxRQUFRLEdBQUcsQ0FBQztJQUNqRDtBQUNGO0FBT08sU0FBUyxtQkFFZCxTQUFlOztJQUNmLE9BQVE7O1lBQVU7O2VBQWM7WUFDOUIsSUFBSSxpQkFBaUIsR0FBRztnQkFDdEIsVUFBVSxRQUFRLENBQUMsV0FBYSxTQUFTLElBQUksQ0FBQztZQUNoRDtZQUNBLGdCQUFnQjtZQUNoQixJQUFJO2dCQUNGLE1BQU0sTUFBTSxRQUFRLEdBQUcsSUFBSTtnQkFDM0IsT0FBTyxjQUFjLEdBQUcsSUFBSSxNQUFNLE1BQU07WUFDMUMsU0FBRTtnQkFDQSxnQkFBZ0I7Z0JBQ2hCLElBQUksaUJBQWlCLEdBQUc7b0JBQ3RCLFVBQVUsUUFBUSxDQUFDLFdBQWEsU0FBUyxLQUFLLENBQUM7Z0JBQ2pEO1lBQ0Y7UUFDRjs7QUFDRjtBQUVBLFNBQVMsY0FBYyxHQUFRO0lBQzdCLE9BQ0UsQ0FBQyxDQUFDLEtBQUssT0FBTyxNQUFNLFlBQVksVUFBVSxLQUFLLE9BQU8sRUFBRSxTQUFTO0FBRXJFO0FBRU8sU0FBUyxtQkFBbUI7SUFqUW5DO0lBa1FFLE9BQU8sQ0FBQyxHQUFFLGtIQUFjLEtBQWQsbUJBQ04sMkJBRE0sbUJBQ2tCLFlBRGxCLG1CQUMyQjtBQUN2QztBQVNPLElBQU0sb0NBQXNCLDBEQUFNLENBQTRCLENBQUMsQ0FBQzs7QUM1UTFDO0FBa0I3QixJQUFJLE9BQU8sV0FBVyxhQUFhO0lBQ2pDLE1BQU0sT0FBTztJQUNiLE1BQU0sNkJBQTZCLEtBQUs7SUFDeEMsS0FBSyxxQkFBcUIsQ0FBQztRQUN6QixXQUFXLGFBQWE7UUFDeEIsSUFBSSxPQUFPLCtCQUErQixZQUFZO1lBQ3BELDJCQUEyQixhQUFhO1FBQzFDO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvc3JjL3F1ZXJ5LWRhdGEudHN4IiwiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvc3JjL2luZGV4LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgUHJvcHNXaXRoQ2hpbGRyZW4gfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB1c2VTV1IsIHtcbiAgRmV0Y2hlcixcbiAgS2V5LFxuICBTV1JDb25maWcsXG4gIFNXUkNvbmZpZ3VyYXRpb24sXG4gIFNXUlJlc3BvbnNlLFxuICB1c2VTV1JDb25maWcsXG59IGZyb20gXCJzd3JcIjtcblxuZXhwb3J0IHR5cGUgeyBTV1JSZXNwb25zZSB9IGZyb20gXCJzd3JcIjtcblxubGV0IF9fU1dSQ29uZmlnOiBSZXR1cm5UeXBlPHR5cGVvZiB1c2VTV1JDb25maWc+IHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuZXhwb3J0IGNvbnN0IG11dGF0ZUtleXMgPSAoaW52YWxpZGF0ZUtleT86IHN0cmluZykgPT4ge1xuICBpZiAoX19TV1JDb25maWcpIHtcbiAgICBjb25zdCB7IGNhY2hlLCBtdXRhdGUgfSA9IF9fU1dSQ29uZmlnO1xuICAgIChpbnZhbGlkYXRlS2V5ICE9IG51bGxcbiAgICAgID8gW2ludmFsaWRhdGVLZXldXG4gICAgICA6IEFycmF5LmZyb20oKGNhY2hlIGFzIE1hcDxzdHJpbmcsIGFueT4pLmtleXMoKSlcbiAgICApLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgbXV0YXRlKGtleSk7XG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIEBwbGFzbWljYXBwL3F1ZXJ5IGlzIG9wdGltaXplZCBmb3IgU1NSLCBzbyB3ZSBkbyBub3QgcmV2YWxpZGF0ZVxuLy8gYXV0b21hdGljYWxseSB1cG9uIGh5ZHJhdGlvbjsgYXMgaWYgdGhlIGRhdGEgaXMgaW1tdXRhYmxlLlxuZnVuY3Rpb24gZ2V0UGxhc21pY0RlZmF1bHRTV1JPcHRpb25zKG9wdHM/OiB7XG4gIGlzTXV0YWJsZT86IGJvb2xlYW47XG59KTogU1dSQ29uZmlndXJhdGlvbiB7XG4gIHJldHVybiB7XG4gICAgcmV2YWxpZGF0ZUlmU3RhbGU6ICEhb3B0cz8uaXNNdXRhYmxlLFxuICAgIHJldmFsaWRhdGVPbkZvY3VzOiBmYWxzZSxcbiAgICByZXZhbGlkYXRlT25SZWNvbm5lY3Q6IGZhbHNlLFxuICB9O1xufVxuXG4vKipcbiAqIEZldGNoZXMgZGF0YSBhc3luY2hyb25vdXNseS4gVGhpcyBkYXRhIHNob3VsZCBiZSBjb25zaWRlcmVkIGltbXV0YWJsZSBmb3IgdGhlXG4gKiBzZXNzaW9uIC0tIHRoZXJlIGlzIG5vIHdheSB0byBpbnZhbGlkYXRlIG9yIHJlLWZldGNoIHRoaXMgZGF0YS5cbiAqXG4gKiBAcGFyYW0ga2V5IGEgdW5pcXVlIGtleSBmb3IgdGhpcyBkYXRhIGZldGNoOyBpZiBkYXRhIGFscmVhZHkgZXhpc3RzIHVuZGVyIHRoaXNcbiAqICAga2V5LCB0aGF0IGRhdGEgaXMgcmV0dXJuZWQgaW1tZWRpYXRlbHkuXG4gKiBAcGFyYW0gZmV0Y2hlciBhbiBhc3luYyBmdW5jdGlvbiB0aGF0IHJlc29sdmVzIHRvIHRoZSBmZXRjaGVkIGRhdGEuXG4gKiBAcmV0dXJucyBhbiBvYmplY3Qgd2l0aCBlaXRoZXIgYSBcImRhdGFcIiBrZXkgd2l0aCB0aGUgZmV0Y2hlZCBkYXRhIGlmIHRoZSBmZXRjaFxuICogICB3YXMgc3VjY2Vzc2Z1bCwgb3IgYW4gXCJlcnJvclwiIGtleSB3aXRoIHRoZSB0aHJvd24gRXJyb3IgaWYgdGhlIGZldGNoIGZhaWxlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVBsYXNtaWNRdWVyeURhdGE8VD4oXG4gIGtleTogS2V5LFxuICBmZXRjaGVyOiBGZXRjaGVyPFQ+XG4pOiB7IGRhdGE/OiBUOyBlcnJvcj86IEVycm9yOyBpc0xvYWRpbmc/OiBib29sZWFuIH0ge1xuICBjb25zdCBwcmVwYXNzQ3R4ID0gUmVhY3QudXNlQ29udGV4dChQcmVwYXNzQ29udGV4dCk7XG5cbiAgY29uc3Qgb3B0cyA9IGdldFBsYXNtaWNEZWZhdWx0U1dST3B0aW9ucygpO1xuICBpZiAocHJlcGFzc0N0eCkge1xuICAgIC8vIElmIHdlJ3JlIGRvaW5nIHByZXBhc3MsIHRoZW4gd2UgYXJlIGFsd2F5cyBpbiBzdXNwZW5zZSBtb2RlLCBiZWNhdXNlXG4gICAgLy8gcmVhY3Qtc3NyLXByZXBhc3Mgb25seSB3b3JrcyB3aXRoIHN1c3BlbnNlLXRocm93aW5nIGRhdGEgZmV0Y2hpbmcuXG4gICAgb3B0cy5zdXNwZW5zZSA9IHRydWU7XG4gIH1cblxuICBjb25zdCBjb25maWcgPSB1c2VTV1JDb25maWcoKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBfX1NXUkNvbmZpZyA9IGNvbmZpZztcbiAgfSwgW2NvbmZpZ10pO1xuXG4gIGNvbnN0IHdyYXBwZWRGZXRjaGVyID0gUmVhY3QudXNlTWVtbyhcbiAgICAoKSA9PiB3cmFwTG9hZGluZ0ZldGNoZXIoZmV0Y2hlciksXG4gICAgW2ZldGNoZXJdXG4gICk7XG5cbiAgY29uc3QgcmVzcCA9IHVzZVNXUihrZXksIHdyYXBwZWRGZXRjaGVyLCBvcHRzKTtcbiAgaWYgKHJlc3AuZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHsgZGF0YTogcmVzcC5kYXRhIH07XG4gIH0gZWxzZSBpZiAocmVzcC5lcnJvcikge1xuICAgIHJldHVybiB7IGVycm9yOiByZXNwLmVycm9yIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHsgaXNMb2FkaW5nOiB0cnVlIH07XG4gIH1cbn1cblxuLyoqXG4gKiBGZXRjaGVzIGRhdGEgYXN5bmNocm9ub3VzbHkgdXNpbmcgU1dSIEhvb2sgKGh0dHBzOi8vc3dyLnZlcmNlbC5hcHAvKVxuICpcbiAqIEBwYXJhbSBrZXkgYSB1bmlxdWUga2V5IGZvciB0aGlzIGRhdGEgZmV0Y2g7IGlmIGRhdGEgYWxyZWFkeSBleGlzdHMgdW5kZXIgdGhpc1xuICogICBrZXksIHRoYXQgZGF0YSBpcyByZXR1cm5lZCBpbW1lZGlhdGVseS5cbiAqIEBwYXJhbSBmZXRjaGVyIGFuIGFzeW5jIGZ1bmN0aW9uIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGZldGNoZWQgZGF0YS5cbiAqIEBwYXJhbSBvcHRpb25zIChvcHRpb25hbCkgYW4gb2JqZWN0IG9mIG9wdGlvbnMgZm9yIHRoaXMgaG9vayAoaHR0cHM6Ly9zd3IudmVyY2VsLmFwcC9kb2NzL29wdGlvbnMpLlxuICogQHJldHVybnMgYW4gb2JqZWN0IHdpdGggZWl0aGVyIGEgXCJkYXRhXCIga2V5IHdpdGggdGhlIGZldGNoZWQgZGF0YSBpZiB0aGUgZmV0Y2hcbiAqICAgd2FzIHN1Y2Nlc3NmdWwsIG9yIGFuIFwiZXJyb3JcIiBrZXkgd2l0aCB0aGUgdGhyb3duIEVycm9yIGlmIHRoZSBmZXRjaCBmYWlsZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VNdXRhYmxlUGxhc21pY1F1ZXJ5RGF0YTxULCBFPihcbiAga2V5OiBLZXksXG4gIGZldGNoZXI6IEZldGNoZXI8VD4sXG4gIG9wdGlvbnM/OiBTV1JDb25maWd1cmF0aW9uPFQsIEU+XG4pOiBTV1JSZXNwb25zZTxULCBFPiAmIHsgaXNMb2FkaW5nPzogYm9vbGVhbjsgaXNMYWdnaW5nPzogYm9vbGVhbiB9IHtcbiAgY29uc3QgcHJlcGFzc0N0eCA9IFJlYWN0LnVzZUNvbnRleHQoUHJlcGFzc0NvbnRleHQpO1xuXG4gIGNvbnN0IG9wdHMgPSB7XG4gICAgLi4uZ2V0UGxhc21pY0RlZmF1bHRTV1JPcHRpb25zKHsgaXNNdXRhYmxlOiB0cnVlIH0pLFxuICAgIC4uLm9wdGlvbnMsXG4gIH07XG4gIGlmIChwcmVwYXNzQ3R4KSB7XG4gICAgb3B0cy5zdXNwZW5zZSA9IHRydWU7XG4gIH1cblxuICBjb25zdCBjb25maWcgPSB1c2VTV1JDb25maWcoKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBfX1NXUkNvbmZpZyA9IGNvbmZpZztcbiAgfSwgW2NvbmZpZ10pO1xuXG4gIGNvbnN0IFtpc0xvYWRpbmcsIHNldElzTG9hZGluZ10gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IGZldGNoZXJXcmFwcGVyID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKC4uLmFyZ3M6IGFueVtdKSA9PiB7XG4gICAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgd3JhcExvYWRpbmdGZXRjaGVyKGZldGNoZXIpKC4uLmFyZ3MpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFtmZXRjaGVyXVxuICApO1xuXG4gIC8vIEJhc2VkIG9uIGh0dHBzOi8vc3dyLnZlcmNlbC5hcHAvZG9jcy9taWRkbGV3YXJlI2tlZXAtcHJldmlvdXMtcmVzdWx0XG4gIGNvbnN0IGxhZ2d5RGF0YVJlZiA9IFJlYWN0LnVzZVJlZjxhbnk+KCk7XG5cbiAgY29uc3QgeyBpc1ZhbGlkYXRpbmcsIG11dGF0ZSwgZGF0YSwgZXJyb3IgfSA9IHVzZVNXUihcbiAgICBrZXksXG4gICAgZmV0Y2hlcldyYXBwZXIsXG4gICAgb3B0c1xuICApO1xuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbGFnZ3lEYXRhUmVmLmN1cnJlbnQgPSBkYXRhO1xuICAgIH1cbiAgfSwgW2RhdGFdKTtcblxuICByZXR1cm4gUmVhY3QudXNlTWVtbyhcbiAgICAoKSA9PiAoe1xuICAgICAgaXNWYWxpZGF0aW5nLFxuICAgICAgbXV0YXRlLFxuICAgICAgaXNMb2FkaW5nOiAoZGF0YSA9PT0gdW5kZWZpbmVkICYmIGVycm9yID09PSB1bmRlZmluZWQpIHx8IGlzTG9hZGluZyxcbiAgICAgIC4uLihkYXRhICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyB7IGRhdGEgfVxuICAgICAgICA6IGVycm9yID09PSB1bmRlZmluZWQgJiYgbGFnZ3lEYXRhUmVmLmN1cnJlbnRcbiAgICAgICAgPyAvLyBTaG93IHByZXZpb3VzIGRhdGEgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgeyBkYXRhOiBsYWdneURhdGFSZWYuY3VycmVudCwgaXNMYWdnaW5nOiB0cnVlIH1cbiAgICAgICAgOiB7fSksXG4gICAgICAuLi4oZXJyb3IgIT09IHVuZGVmaW5lZCA/IHsgZXJyb3IgfSA6IHt9KSxcbiAgICB9KSxcbiAgICBbaXNWYWxpZGF0aW5nLCBtdXRhdGUsIGRhdGEsIGVycm9yLCBpc0xvYWRpbmddXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBQbGFzbWljUXVlcnlEYXRhUHJvdmlkZXIocHJvcHM6IHtcbiAgc3VzcGVuc2U/OiBib29sZWFuO1xuICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlO1xuICBwcmVmZXRjaGVkQ2FjaGU/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xufSkge1xuICBjb25zdCB7IGNoaWxkcmVuLCBzdXNwZW5zZSwgcHJlZmV0Y2hlZENhY2hlIH0gPSBwcm9wcztcbiAgY29uc3QgcHJlcGFzcyA9IFJlYWN0LnVzZUNvbnRleHQoUHJlcGFzc0NvbnRleHQpO1xuICBpZiAocHJlcGFzcykge1xuICAgIC8vIElmIHdlJ3JlIGluIHByZXBhc3MsIHRoZW4gdGhlcmUncyBhbHJlYWR5IGEgd3JhcHBpZ24gU1dSQ29uZmlnO1xuICAgIC8vIGRvbid0IGludGVyZmVyZSB3aXRoIGl0LlxuICAgIHJldHVybiA8PntjaGlsZHJlbn08Lz47XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxTV1JDb25maWdcbiAgICAgICAgdmFsdWU9e3tcbiAgICAgICAgICBmYWxsYmFjazogcHJlZmV0Y2hlZENhY2hlID8/IHt9LFxuICAgICAgICAgIHN1c3BlbnNlLFxuICAgICAgICB9fVxuICAgICAgPlxuICAgICAgICB7Y2hpbGRyZW59XG4gICAgICA8L1NXUkNvbmZpZz5cbiAgICApO1xuICB9XG59XG5cbmNvbnN0IFByZXBhc3NDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dDxib29sZWFuPihmYWxzZSk7XG5cbmV4cG9ydCBmdW5jdGlvbiBQbGFzbWljUHJlcGFzc0NvbnRleHQoXG4gIHByb3BzOiBQcm9wc1dpdGhDaGlsZHJlbjx7XG4gICAgY2FjaGU6IE1hcDxzdHJpbmcsIGFueT47XG4gIH0+XG4pIHtcbiAgY29uc3QgeyBjYWNoZSwgY2hpbGRyZW4gfSA9IHByb3BzO1xuICByZXR1cm4gKFxuICAgIDxQcmVwYXNzQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17dHJ1ZX0+XG4gICAgICA8U1dSQ29uZmlnXG4gICAgICAgIHZhbHVlPXt7XG4gICAgICAgICAgcHJvdmlkZXI6ICgpID0+IGNhY2hlLFxuICAgICAgICAgIHN1c3BlbnNlOiB0cnVlLFxuICAgICAgICAgIGZhbGxiYWNrOiB7fSxcbiAgICAgICAgfX1cbiAgICAgID5cbiAgICAgICAge2NoaWxkcmVufVxuICAgICAgPC9TV1JDb25maWc+XG4gICAgPC9QcmVwYXNzQ29udGV4dC5Qcm92aWRlcj5cbiAgKTtcbn1cblxuZXhwb3J0IGNvbnN0IHVzZVBsYXNtaWNEYXRhQ29uZmlnOiB0eXBlb2YgdXNlU1dSQ29uZmlnID0gdXNlU1dSQ29uZmlnO1xuXG5sZXQgbG9hZGluZ0NvdW50ID0gMDtcbmV4cG9ydCB0eXBlIExvYWRpbmdTdGF0ZUxpc3RlbmVyID0gKGlzTG9hZGluZzogYm9vbGVhbikgPT4gdm9pZDtcbmNvbnN0IGxpc3RlbmVyczogTG9hZGluZ1N0YXRlTGlzdGVuZXJbXSA9IFtdO1xuXG4vKipcbiAqIFN1YnNjcmliZXMgdG8gd2hldGhlciBhbnkgbG9hZGluZyBpcyBoYXBwZW5pbmcgdmlhIEBwbGFzbWljYXBwL3F1ZXJ5LlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVuc3Vic2NyaWJlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkTG9hZGluZ1N0YXRlTGlzdGVuZXIoXG4gIGxpc3RlbmVyOiBMb2FkaW5nU3RhdGVMaXN0ZW5lcixcbiAgb3B0cz86IHsgaW1tZWRpYXRlPzogYm9vbGVhbiB9XG4pIHtcbiAgbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICBpZiAob3B0cz8uaW1tZWRpYXRlKSB7XG4gICAgbGlzdGVuZXIobG9hZGluZ0NvdW50ID4gMCk7XG4gIH1cbiAgcmV0dXJuICgpID0+IHtcbiAgICBsaXN0ZW5lcnMuc3BsaWNlKGxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKSwgMSk7XG4gIH07XG59XG5cbi8qKlxuICogSW5zdHJ1bWVudHMgYW4gYXN5bmMgZnVuY3Rpb24gdG8gaW5jcmVtZW50IGFuZCBkZWNyZW1lbnQgdGhlIG51bWJlciBvZlxuICogc2ltdWx0YW5lb3VzIGFzeW5jIGxvYWRzLiBZb3UgY2FuIHRoZW4gc3Vic2NyaWJlIHRvIHdoZXRoZXIgdGhlcmVcbiAqIGFyZSBhbnkgbG9hZHMgaGFwcGVuaW5nIHZpYSBhZGRMb2FkaW5nU3RhdGVMaXN0ZW5lcigpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gd3JhcExvYWRpbmdGZXRjaGVyPFxuICBUIGV4dGVuZHMgKC4uLmFyZ3M6IGFueVtdKSA9PiBQcm9taXNlPGFueT4gfCBhbnlcbj4oZmV0Y2hlcjogVCk6IFQge1xuICByZXR1cm4gKGFzeW5jICguLi5hcmdzOiBhbnkpID0+IHtcbiAgICBpZiAobG9hZGluZ0NvdW50ID09PSAwKSB7XG4gICAgICBsaXN0ZW5lcnMuZm9yRWFjaCgobGlzdGVuZXIpID0+IGxpc3RlbmVyKHRydWUpKTtcbiAgICB9XG4gICAgbG9hZGluZ0NvdW50ICs9IDE7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlcyA9IGZldGNoZXIoLi4uYXJncyk7XG4gICAgICByZXR1cm4gaXNQcm9taXNlTGlrZShyZXMpID8gYXdhaXQgcmVzIDogcmVzO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBsb2FkaW5nQ291bnQgLT0gMTtcbiAgICAgIGlmIChsb2FkaW5nQ291bnQgPT09IDApIHtcbiAgICAgICAgbGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKSA9PiBsaXN0ZW5lcihmYWxzZSkpO1xuICAgICAgfVxuICAgIH1cbiAgfSkgYXMgVDtcbn1cblxuZnVuY3Rpb24gaXNQcm9taXNlTGlrZSh4OiBhbnkpIHtcbiAgcmV0dXJuIChcbiAgICAhIXggJiYgdHlwZW9mIHggPT09IFwib2JqZWN0XCIgJiYgXCJ0aGVuXCIgaW4geCAmJiB0eXBlb2YgeC50aGVuID09PSBcImZ1bmN0aW9uXCJcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUGxhc21pY1ByZXBhc3MoKSB7XG4gIHJldHVybiAhIShSZWFjdCBhcyBhbnkpLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEXG4gICAgPy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyPy5jdXJyZW50Py5pc1BsYXNtaWNQcmVwYXNzO1xufVxuXG5leHBvcnQgdHlwZSBIZWFkTWV0YWRhdGEgPSB7XG4gIHRpdGxlPzogc3RyaW5nO1xuICBkZXNjcmlwdGlvbj86IHN0cmluZztcbiAgaW1hZ2U/OiBzdHJpbmc7XG4gIGNhbm9uaWNhbD86IHN0cmluZztcbn07XG5cbmV4cG9ydCBjb25zdCBIZWFkTWV0YWRhdGFDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dDxIZWFkTWV0YWRhdGE+KHt9KTtcbiIsImltcG9ydCB7IG11dGF0ZUtleXMgfSBmcm9tIFwiLi9xdWVyeS1kYXRhXCI7XG5leHBvcnQgeyB1c2VTV1JDb25maWcgfSBmcm9tIFwic3dyXCI7XG5leHBvcnQge1xuICBhZGRMb2FkaW5nU3RhdGVMaXN0ZW5lcixcbiAgSGVhZE1ldGFkYXRhQ29udGV4dCxcbiAgaXNQbGFzbWljUHJlcGFzcyxcbiAgUGxhc21pY1ByZXBhc3NDb250ZXh0LFxuICBQbGFzbWljUXVlcnlEYXRhUHJvdmlkZXIsXG4gIHVzZU11dGFibGVQbGFzbWljUXVlcnlEYXRhLFxuICB1c2VQbGFzbWljRGF0YUNvbmZpZyxcbiAgdXNlUGxhc21pY1F1ZXJ5RGF0YSxcbiAgd3JhcExvYWRpbmdGZXRjaGVyLFxufSBmcm9tIFwiLi9xdWVyeS1kYXRhXCI7XG5leHBvcnQgdHlwZSB7XG4gIEhlYWRNZXRhZGF0YSxcbiAgTG9hZGluZ1N0YXRlTGlzdGVuZXIsXG4gIFNXUlJlc3BvbnNlLFxufSBmcm9tIFwiLi9xdWVyeS1kYXRhXCI7XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIGNvbnN0IHJvb3QgPSB3aW5kb3cgYXMgYW55O1xuICBjb25zdCBtYXliZUV4aXN0aW5nTXV0YXRlQWxsS2V5cyA9IHJvb3QuX19TV1JNdXRhdGVBbGxLZXlzO1xuICByb290Ll9fU1dSTXV0YXRlQWxsS2V5cyA9IChpbnZhbGlkYXRlS2V5Pzogc3RyaW5nKSA9PiB7XG4gICAgbXV0YXRlS2V5cyhpbnZhbGlkYXRlS2V5KTtcbiAgICBpZiAodHlwZW9mIG1heWJlRXhpc3RpbmdNdXRhdGVBbGxLZXlzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIG1heWJlRXhpc3RpbmdNdXRhdGVBbGxLZXlzKGludmFsaWRhdGVLZXkpO1xuICAgIH1cbiAgfTtcbn1cbiJdLCJuYW1lcyI6WyJ1c2VTV1JDb25maWciXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@plasmicapp/query/dist/index.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@plasmicapp/react-ssr-prepass/dist/react-ssr-prepass.es.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@plasmicapp/react-ssr-prepass/dist/react-ssr-prepass.es.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ renderPrepass)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\nfunction _extends() {\n  return _extends = Object.assign ? Object.assign.bind() : function(n) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n      for (var r in t) {\n        ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n      }\n    }\n    return n;\n  }, _extends.apply(null, arguments);\n}\n\nvar Element = 60103;\n\nvar TransitionalElement = 60103;\n\nvar Portal = 60106;\n\nvar Fragment = 60107;\n\nvar StrictMode = 60108;\n\nvar Profiler = 60114;\n\nvar ContextProvider = 60109;\n\nvar ContextConsumer = undefined;\n\nvar Context = 60110;\n\nvar ConcurrentMode = 60111;\n\nvar ForwardRef = 60112;\n\nvar Suspense = 60113;\n\nvar Memo = 60115;\n\nvar Lazy = 60116;\n\nvar ClientReferenceTag = undefined;\n\nif (typeof Symbol === \"function\" && Symbol.for) {\n  var symbolFor = Symbol.for;\n  Element = symbolFor(\"react.element\");\n  TransitionalElement = symbolFor(\"react.transitional.element\");\n  Portal = symbolFor(\"react.portal\");\n  Fragment = symbolFor(\"react.fragment\");\n  StrictMode = symbolFor(\"react.strict_mode\");\n  Profiler = symbolFor(\"react.profiler\");\n  ContextProvider = symbolFor(\"react.provider\");\n  ContextConsumer = symbolFor(\"react.consumer\");\n  Context = symbolFor(\"react.context\");\n  ConcurrentMode = symbolFor(\"react.concurrent_mode\");\n  ForwardRef = symbolFor(\"react.forward_ref\");\n  Suspense = symbolFor(\"react.suspense\");\n  Memo = symbolFor(\"react.memo\");\n  Lazy = symbolFor(\"react.lazy\");\n  ClientReferenceTag = symbolFor(\"react.client.reference\");\n}\n\nvar REACT_ELEMENT_TYPE = Element;\n\nvar REACT_TRANSITIONAL_ELEMENT_TYPE = TransitionalElement;\n\nvar REACT_PORTAL_TYPE = Portal;\n\nvar REACT_FRAGMENT_TYPE = Fragment;\n\nvar REACT_STRICT_MODE_TYPE = StrictMode;\n\nvar REACT_PROFILER_TYPE = Profiler;\n\nvar REACT_PROVIDER_TYPE = ContextProvider;\n\nvar REACT_CONSUMER_TYPE = ContextConsumer;\n\nvar REACT_CONTEXT_TYPE = Context;\n\nvar REACT_CONCURRENT_MODE_TYPE = ConcurrentMode;\n\nvar REACT_FORWARD_REF_TYPE = ForwardRef;\n\nvar REACT_SUSPENSE_TYPE = Suspense;\n\nvar REACT_MEMO_TYPE = Memo;\n\nvar REACT_LAZY_TYPE = Lazy;\n\nvar CLIENT_REFERENCE_TAG = ClientReferenceTag;\n\nfunction isClientReference(reference) {\n  return reference.$$typeof === CLIENT_REFERENCE_TAG;\n}\n\nvar getComponentName = function(type) {\n  if (isClientReference(type)) {\n    return undefined;\n  }\n  if (type.displayName) {\n    return type.displayName;\n  }\n  if (shouldConstruct(type)) {\n    return type.constructor.name;\n  } else {\n    return type.name;\n  }\n};\n\nfunction isReact19() {\n  return !(react__WEBPACK_IMPORTED_MODULE_0___default().__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED);\n}\n\nvar shouldConstruct = function(Comp) {\n  return Comp.prototype && Comp.prototype.isReactComponent;\n};\n\nvar typeOf = function(x) {\n  switch (x.$$typeof) {\n   case REACT_PORTAL_TYPE:\n    return REACT_PORTAL_TYPE;\n\n   case REACT_ELEMENT_TYPE:\n   case REACT_TRANSITIONAL_ELEMENT_TYPE:\n    switch (x.type) {\n     case REACT_CONCURRENT_MODE_TYPE:\n      return REACT_CONCURRENT_MODE_TYPE;\n\n     case REACT_FRAGMENT_TYPE:\n      return REACT_FRAGMENT_TYPE;\n\n     case REACT_PROFILER_TYPE:\n      return REACT_PROFILER_TYPE;\n\n     case REACT_STRICT_MODE_TYPE:\n      return REACT_STRICT_MODE_TYPE;\n\n     case REACT_SUSPENSE_TYPE:\n      return REACT_SUSPENSE_TYPE;\n\n     default:\n      {\n        switch (x.type && x.type.$$typeof) {\n         case REACT_LAZY_TYPE:\n          return REACT_LAZY_TYPE;\n\n         case REACT_MEMO_TYPE:\n          return REACT_MEMO_TYPE;\n\n         case REACT_CONSUMER_TYPE:\n          return REACT_CONSUMER_TYPE;\n\n         case REACT_CONTEXT_TYPE:\n          return isReact19() ? REACT_PROVIDER_TYPE : REACT_CONSUMER_TYPE;\n\n         case REACT_PROVIDER_TYPE:\n          return REACT_PROVIDER_TYPE;\n\n         case REACT_FORWARD_REF_TYPE:\n          return REACT_FORWARD_REF_TYPE;\n\n         default:\n          return REACT_ELEMENT_TYPE;\n        }\n      }\n    }\n\n   default:\n    return undefined;\n  }\n};\n\nvar toArray = react__WEBPACK_IMPORTED_MODULE_0__.Children.toArray;\n\nvar isAbstractElement = function(node) {\n  return node !== null && typeof node === \"object\";\n};\n\nvar getChildrenArray = function(node) {\n  return toArray(node).filter(isAbstractElement);\n};\n\nvar computeProps = function(props, defaultProps) {\n  return typeof defaultProps === \"object\" ? _extends({}, defaultProps, props) : props;\n};\n\nvar currentContextStore = new Map;\n\nvar currentContextMap = {};\n\nvar prevContextMap = undefined;\n\nvar prevContextEntry = undefined;\n\nvar getCurrentContextMap = function() {\n  return _extends({}, currentContextMap);\n};\n\nvar getCurrentContextStore = function() {\n  return new Map(currentContextStore);\n};\n\nvar flushPrevContextMap = function() {\n  var prev = prevContextMap;\n  prevContextMap = undefined;\n  return prev;\n};\n\nvar flushPrevContextStore = function() {\n  var prev = prevContextEntry;\n  prevContextEntry = undefined;\n  return prev;\n};\n\nvar restoreContextMap = function(prev) {\n  if (prev !== undefined) {\n    _extends(currentContextMap, prev);\n  }\n};\n\nvar restoreContextStore = function(prev) {\n  if (prev !== undefined) {\n    currentContextStore.set(prev[0], prev[1]);\n  }\n};\n\nvar setCurrentContextMap = function(map) {\n  prevContextMap = undefined;\n  currentContextMap = map;\n};\n\nvar setCurrentContextStore = function(store) {\n  prevContextEntry = undefined;\n  currentContextStore = store;\n};\n\nvar assignContextMap = function(map) {\n  prevContextMap = {};\n  for (var name in map) {\n    prevContextMap[name] = currentContextMap[name];\n    currentContextMap[name] = map[name];\n  }\n};\n\nvar setContextValue = function(context, value) {\n  prevContextEntry = [ context, currentContextStore.get(context) ];\n  currentContextStore.set(context, value);\n};\n\nvar readContextValue = function(context) {\n  var value = currentContextStore.get(context);\n  if (value !== undefined) {\n    return value;\n  }\n  return context._currentValue;\n};\n\nvar emptyContext = {};\n\nvar maskContext = function(type) {\n  var contextType = type.contextType;\n  var contextTypes = type.contextTypes;\n  if (contextType) {\n    return readContextValue(contextType);\n  } else if (!contextTypes) {\n    return emptyContext;\n  }\n  var maskedContext = {};\n  for (var name in contextTypes) {\n    maskedContext[name] = currentContextMap[name];\n  }\n  return maskedContext;\n};\n\nvar currentErrorFrame = null;\n\nvar getCurrentErrorFrame = function() {\n  return currentErrorFrame;\n};\n\nvar setCurrentErrorFrame = function(frame) {\n  currentErrorFrame = frame || null;\n};\n\nvar rendererStateRef = {\n  current: {\n    uniqueID: 0\n  }\n};\n\nvar initRendererState = function() {\n  return rendererStateRef.current = {\n    uniqueID: 0\n  };\n};\n\nvar setCurrentRendererState = function(state) {\n  return rendererStateRef.current = state;\n};\n\nfunction is(x, y) {\n  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;\n}\n\nvar objectIs = typeof Object.is === \"function\" ? Object.is : is;\n\nvar is$1 = objectIs;\n\nvar currentIdentity = null;\n\nvar makeIdentity = function() {\n  return {};\n};\n\nvar setCurrentIdentity = function(id) {\n  currentIdentity = id;\n};\n\nvar getCurrentIdentity = function() {\n  if (currentIdentity === null) {\n    throw new Error(\"[react-ssr-prepass] Hooks can only be called inside the body of a function component. \" + \"(https://fb.me/react-invalid-hook-call)\");\n  }\n  return currentIdentity;\n};\n\nvar firstWorkInProgressHook = null;\n\nvar workInProgressHook = null;\n\nvar didScheduleRenderPhaseUpdate = false;\n\nvar renderPhaseUpdates = null;\n\nvar numberOfReRenders = 0;\n\nvar RE_RENDER_LIMIT$1 = 25;\n\nvar getFirstHook = function() {\n  return firstWorkInProgressHook;\n};\n\nvar setFirstHook = function(hook) {\n  firstWorkInProgressHook = hook;\n};\n\nfunction areHookInputsEqual(nextDeps, prevDeps) {\n  if (prevDeps === null) {\n    return false;\n  }\n  for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) {\n    if (!is$1(nextDeps[i], prevDeps[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction createHook() {\n  return {\n    memoizedState: null,\n    queue: null,\n    next: null\n  };\n}\n\nfunction createWorkInProgressHook() {\n  if (workInProgressHook === null) {\n    if (firstWorkInProgressHook === null) {\n      return firstWorkInProgressHook = workInProgressHook = createHook();\n    } else {\n      return workInProgressHook = firstWorkInProgressHook;\n    }\n  } else {\n    if (workInProgressHook.next === null) {\n      return workInProgressHook = workInProgressHook.next = createHook();\n    } else {\n      return workInProgressHook = workInProgressHook.next;\n    }\n  }\n}\n\nfunction renderWithHooks(Component, props, refOrContext) {\n  workInProgressHook = null;\n  var children = Component(props, refOrContext);\n  while (numberOfReRenders < RE_RENDER_LIMIT$1 && didScheduleRenderPhaseUpdate) {\n    didScheduleRenderPhaseUpdate = false;\n    numberOfReRenders += 1;\n    workInProgressHook = null;\n    children = Component(props, refOrContext);\n  }\n  numberOfReRenders = 0;\n  renderPhaseUpdates = null;\n  workInProgressHook = null;\n  return children;\n}\n\nfunction readContext(context, _) {\n  return readContextValue(context);\n}\n\nfunction useContext(context, _) {\n  getCurrentIdentity();\n  return readContextValue(context);\n}\n\nfunction basicStateReducer(state, action) {\n  return typeof action === \"function\" ? action(state) : action;\n}\n\nfunction useState(initialState) {\n  return useReducer(basicStateReducer, initialState);\n}\n\nfunction useReducer(reducer, initialArg, init) {\n  var id = getCurrentIdentity();\n  workInProgressHook = createWorkInProgressHook();\n  if (workInProgressHook.queue === null) {\n    var initialState;\n    if (reducer === basicStateReducer) {\n      initialState = typeof initialArg === \"function\" ? initialArg() : initialArg;\n    } else {\n      initialState = init !== undefined ? init(initialArg) : initialArg;\n    }\n    workInProgressHook.memoizedState = initialState;\n  }\n  var queue = workInProgressHook.queue || (workInProgressHook.queue = {\n    last: null,\n    dispatch: null\n  });\n  var dispatch = queue.dispatch || (queue.dispatch = dispatchAction.bind(null, id, queue));\n  if (renderPhaseUpdates !== null) {\n    var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);\n    if (firstRenderPhaseUpdate !== undefined) {\n      renderPhaseUpdates.delete(queue);\n      var newState = workInProgressHook.memoizedState;\n      var update = firstRenderPhaseUpdate;\n      do {\n        var action = update.action;\n        newState = reducer(newState, action);\n        update = update.next;\n      } while (update !== null);\n      workInProgressHook.memoizedState = newState;\n    }\n  }\n  return [ workInProgressHook.memoizedState, dispatch ];\n}\n\nfunction useMemo(nextCreate, deps) {\n  getCurrentIdentity();\n  workInProgressHook = createWorkInProgressHook();\n  var nextDeps = deps === undefined ? null : deps;\n  var prevState = workInProgressHook.memoizedState;\n  if (prevState !== null && nextDeps !== null) {\n    var prevDeps = prevState[1];\n    if (areHookInputsEqual(nextDeps, prevDeps)) {\n      return prevState[0];\n    }\n  }\n  var nextValue = nextCreate();\n  workInProgressHook.memoizedState = [ nextValue, nextDeps ];\n  return nextValue;\n}\n\nfunction useRef(initialValue) {\n  getCurrentIdentity();\n  workInProgressHook = createWorkInProgressHook();\n  var previousRef = workInProgressHook.memoizedState;\n  if (previousRef === null) {\n    var ref = {\n      current: initialValue\n    };\n    workInProgressHook.memoizedState = ref;\n    return ref;\n  } else {\n    return previousRef;\n  }\n}\n\nfunction useOpaqueIdentifier() {\n  getCurrentIdentity();\n  workInProgressHook = createWorkInProgressHook();\n  if (!workInProgressHook.memoizedState) {\n    workInProgressHook.memoizedState = \"R:\" + (rendererStateRef.current.uniqueID++).toString(36);\n  }\n  return workInProgressHook.memoizedState;\n}\n\nfunction dispatchAction(componentIdentity, queue, action) {\n  if (componentIdentity === currentIdentity) {\n    didScheduleRenderPhaseUpdate = true;\n    var update = {\n      action: action,\n      next: null\n    };\n    if (renderPhaseUpdates === null) {\n      renderPhaseUpdates = new Map;\n    }\n    var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);\n    if (firstRenderPhaseUpdate === undefined) {\n      renderPhaseUpdates.set(queue, update);\n    } else {\n      var lastRenderPhaseUpdate = firstRenderPhaseUpdate;\n      while (lastRenderPhaseUpdate.next !== null) {\n        lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;\n      }\n      lastRenderPhaseUpdate.next = update;\n    }\n  }\n}\n\nfunction useCallback(callback, deps) {\n  return useMemo((function() {\n    return callback;\n  }), deps);\n}\n\nfunction useMutableSource(source, getSnapshot, _subscribe) {\n  getCurrentIdentity();\n  return getSnapshot(source._source);\n}\n\nfunction noop() {}\n\nfunction _ref$3(callback) {\n  callback();\n}\n\nfunction useTransition() {\n  var startTransition = _ref$3;\n  return [ startTransition, false ];\n}\n\nfunction useDeferredValue(input) {\n  return input;\n}\n\nfunction useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n  return getSnapshot();\n}\n\nvar Dispatcher = {\n  readContext: readContext,\n  useSyncExternalStore: useSyncExternalStore,\n  useContext: useContext,\n  useMemo: useMemo,\n  useReducer: useReducer,\n  useRef: useRef,\n  useState: useState,\n  useCallback: useCallback,\n  useMutableSource: useMutableSource,\n  useTransition: useTransition,\n  useDeferredValue: useDeferredValue,\n  useOpaqueIdentifier: useOpaqueIdentifier,\n  useId: useOpaqueIdentifier,\n  unstable_useId: useOpaqueIdentifier,\n  unstable_useOpaqueIdentifier: useOpaqueIdentifier,\n  useLayoutEffect: noop,\n  useImperativeHandle: noop,\n  useEffect: noop,\n  useDebugValue: noop,\n  useInsertionEffect: noop,\n  isPlasmicPrepass: true\n};\n\nvar resolve = function(type) {\n  var payload = type._payload || type;\n  if (payload._status === 0) {\n    return payload._result;\n  } else if (payload._status === 1) {\n    return Promise.resolve(payload._result);\n  } else if (payload._status === 2) {\n    return Promise.reject(payload._result);\n  }\n  payload._status = 0;\n  return payload._result = (payload._ctor || payload._result)().then((function(Component) {\n    payload._result = Component;\n    if (typeof Component === \"function\") {\n      payload._status = 1;\n    } else if (Component !== null && typeof Component === \"object\" && typeof Component.default === \"function\") {\n      payload._result = Component.default;\n      payload._status = 1;\n    } else {\n      payload._status = 2;\n    }\n  })).catch((function(error) {\n    payload._status = 2;\n    payload._result = error;\n    return Promise.reject(error);\n  }));\n};\n\nvar makeFrame$2 = function(type, props, thenable) {\n  return {\n    kind: \"frame.lazy\",\n    contextMap: getCurrentContextMap(),\n    contextStore: getCurrentContextStore(),\n    errorFrame: getCurrentErrorFrame(),\n    thenable: thenable,\n    props: props,\n    type: type\n  };\n};\n\nvar render$4 = function(type, props, queue) {\n  var payload = type._payload || type;\n  if (payload._status === 1 && payload._result) {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(payload._result, props);\n  }\n  try {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(type._init(type._payload), props);\n  } catch (err) {\n    if (!!err && typeof err.then === \"function\") {\n      queue.push(makeFrame$2(type, props, err));\n    }\n    return null;\n  }\n};\n\nvar mount$3 = function(type, props, queue) {\n  var payload = type._payload || type;\n  if (payload._status != null && payload._status <= 0) {\n    queue.push(makeFrame$2(type, props, resolve(type)));\n    return null;\n  }\n  return render$4(type, props, queue);\n};\n\nvar update$4 = function(queue, frame) {\n  setCurrentIdentity(null);\n  setCurrentContextMap(frame.contextMap);\n  setCurrentContextStore(frame.contextStore);\n  setCurrentErrorFrame(frame.errorFrame);\n  return render$4(frame.type, frame.props, queue);\n};\n\nvar makeFrame$1 = function(type, props, thenable) {\n  return {\n    contextMap: getCurrentContextMap(),\n    contextStore: getCurrentContextStore(),\n    id: getCurrentIdentity(),\n    hook: getFirstHook(),\n    kind: \"frame.hooks\",\n    errorFrame: getCurrentErrorFrame(),\n    thenable: thenable,\n    props: props,\n    type: type\n  };\n};\n\nvar render$3 = function(type, props, queue) {\n  try {\n    return renderWithHooks(type, computeProps(props, type.defaultProps), maskContext(type));\n  } catch (error) {\n    if (typeof error.then !== \"function\") {\n      console.warn(\"PLASMIC: Encountered error when pre-rendering \" + getComponentName(type) + \": \" + error);\n      return null;\n    }\n    queue.push(makeFrame$1(type, props, error));\n    return null;\n  }\n};\n\nvar mount$2 = function(type, props, queue, visitor, element) {\n  setFirstHook(null);\n  setCurrentIdentity(makeIdentity());\n  var promise = visitor(element);\n  if (promise) {\n    queue.push(makeFrame$1(type, props, promise));\n    return null;\n  }\n  return render$3(type, props, queue);\n};\n\nvar update$3 = function(queue, frame) {\n  setFirstHook(frame.hook);\n  setCurrentIdentity(frame.id);\n  setCurrentContextMap(frame.contextMap);\n  setCurrentContextStore(frame.contextStore);\n  setCurrentErrorFrame(frame.errorFrame);\n  return render$3(frame.type, frame.props, queue);\n};\n\nvar RE_RENDER_LIMIT = 25;\n\nfunction _ref$2() {\n  return false;\n}\n\nfunction _ref2$1() {\n  return null;\n}\n\nvar createUpdater = function() {\n  var queue = [];\n  return {\n    _thrown: 0,\n    queue: queue,\n    isMounted: _ref$2,\n    enqueueForceUpdate: _ref2$1,\n    enqueueReplaceState: function(instance, completeState) {\n      if (instance._isMounted) {\n        queue.length = 0;\n        queue.push(completeState);\n      }\n    },\n    enqueueSetState: function(instance, currentPartialState) {\n      if (instance._isMounted) {\n        queue.push(currentPartialState);\n      }\n    }\n  };\n};\n\nvar flushEnqueuedState = function(instance) {\n  var queue = instance.updater.queue;\n  if (queue.length > 0) {\n    var nextState = _extends({}, instance.state);\n    for (var i = 0, l = queue.length; i < l; i++) {\n      var partial = queue[i];\n      var partialState = typeof partial === \"function\" ? partial.call(instance, nextState, instance.props, instance.context) : partial;\n      if (partialState !== null) {\n        _extends(nextState, partialState);\n      }\n    }\n    instance.state = nextState;\n    queue.length = 0;\n  }\n};\n\nvar createInstance = function(type, props) {\n  var updater = createUpdater();\n  var computedProps = computeProps(props, type.defaultProps);\n  var context = maskContext(type);\n  var instance = new type(computedProps, context, updater);\n  instance.props = computedProps;\n  instance.context = context;\n  instance.updater = updater;\n  instance._isMounted = true;\n  if (instance.state === undefined) {\n    instance.state = null;\n  }\n  if (typeof instance.componentDidCatch === \"function\" || typeof type.getDerivedStateFromError === \"function\") {\n    var frame = makeFrame(type, instance, null);\n    frame.errorFrame = frame;\n    setCurrentErrorFrame(frame);\n  }\n  if (typeof type.getDerivedStateFromProps === \"function\") {\n    var getDerivedStateFromProps = type.getDerivedStateFromProps;\n    var state = getDerivedStateFromProps(instance.props, instance.state);\n    if (state !== null && state !== undefined) {\n      instance.state = _extends({}, instance.state, state);\n    }\n  } else if (typeof instance.componentWillMount === \"function\") {\n    instance.componentWillMount();\n  } else if (typeof instance.UNSAFE_componentWillMount === \"function\") {\n    instance.UNSAFE_componentWillMount();\n  }\n  return instance;\n};\n\nvar makeFrame = function(type, instance, thenable) {\n  return {\n    contextMap: getCurrentContextMap(),\n    contextStore: getCurrentContextStore(),\n    errorFrame: getCurrentErrorFrame(),\n    thenable: thenable,\n    kind: \"frame.class\",\n    error: null,\n    instance: instance,\n    type: type\n  };\n};\n\nvar render$2 = function(type, instance, queue) {\n  flushEnqueuedState(instance);\n  var child = null;\n  try {\n    child = instance.render();\n  } catch (error) {\n    if (typeof error.then !== \"function\") {\n      console.warn(\"PLASMIC: Encountered error when pre-rendering component \" + getComponentName(type) + \". This is fine as long as you are not fetching data with @plasmicapp/query inside this component.  Error: \" + error);\n      return null;\n    }\n    queue.push(makeFrame(type, instance, error));\n    return null;\n  }\n  if (type.childContextTypes !== undefined && typeof instance.getChildContext === \"function\") {\n    var childContext = instance.getChildContext();\n    if (childContext !== null && typeof childContext === \"object\") {\n      assignContextMap(childContext);\n    }\n  }\n  if (typeof instance.getDerivedStateFromProps !== \"function\" && (typeof instance.componentWillMount === \"function\" || typeof instance.UNSAFE_componentWillMount === \"function\") && typeof instance.componentWillUnmount === \"function\") {\n    try {\n      instance.componentWillUnmount();\n    } catch (_err) {}\n  }\n  instance._isMounted = false;\n  return child;\n};\n\nvar mount$1 = function(type, props, queue, visitor, element) {\n  setCurrentIdentity(null);\n  var instance = createInstance(type, props);\n  var promise = visitor(element, instance);\n  if (promise) {\n    queue.push(makeFrame(type, instance, promise));\n    return null;\n  }\n  return render$2(type, instance, queue);\n};\n\nvar update$2 = function(queue, frame) {\n  setCurrentIdentity(null);\n  setCurrentContextMap(frame.contextMap);\n  setCurrentContextStore(frame.contextStore);\n  setCurrentErrorFrame(frame.errorFrame);\n  if (frame.error) {\n    if (++frame.instance.updater._thrown >= RE_RENDER_LIMIT) {\n      return null;\n    }\n    frame.instance._isMounted = true;\n    if (typeof frame.instance.componentDidCatch === \"function\") {\n      frame.instance.componentDidCatch(frame.error);\n    }\n    if (typeof frame.type.getDerivedStateFromError === \"function\") {\n      frame.instance.updater.enqueueSetState(frame.instance, frame.type.getDerivedStateFromError(frame.error));\n    }\n  }\n  return render$2(frame.type, frame.instance, queue);\n};\n\nfunction _ref$1(elt) {\n  return elt && typeof elt === \"object\" && typeOf(elt);\n}\n\nvar render$1 = function(type, props, queue, clientRefVisitor, element) {\n  try {\n    var node = clientRefVisitor(element);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), {}, [].concat(node ? getChildrenArray(node) : Object.values(props).flat(Infinity).filter(_ref$1)));\n  } catch (error) {\n    if (typeof error.then !== \"function\") {\n      console.warn(\"PLASMIC: Encountered error when pre-rendering client reference: \" + error);\n      return null;\n    }\n    queue.push({\n      contextMap: getCurrentContextMap(),\n      contextStore: getCurrentContextStore(),\n      errorFrame: getCurrentErrorFrame(),\n      id: getCurrentIdentity(),\n      hook: getFirstHook(),\n      thenable: error,\n      kind: \"client-ref\",\n      type: type,\n      props: props,\n      element: element,\n      clientRefVisitor: clientRefVisitor\n    });\n    return null;\n  }\n};\n\nvar mount = function(type, props, queue, clientRefVisitor, element) {\n  setFirstHook(null);\n  setCurrentIdentity(makeIdentity());\n  return render$1(type, props, queue, clientRefVisitor, element);\n};\n\nvar update$1 = function(queue, frame) {\n  setFirstHook(frame.hook);\n  setCurrentIdentity(frame.id);\n  setCurrentContextMap(frame.contextMap);\n  setCurrentContextStore(frame.contextStore);\n  setCurrentErrorFrame(frame.errorFrame);\n  return render$1(frame.type, frame.props, queue, frame.clientRefVisitor, frame.element);\n};\n\nvar REACT_INTERNALS = (react__WEBPACK_IMPORTED_MODULE_0___default().__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) || (react__WEBPACK_IMPORTED_MODULE_0___default().__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE) || (react__WEBPACK_IMPORTED_MODULE_0___default().__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE);\n\nvar ReactCurrentDispatcher = REACT_INTERNALS.ReactCurrentDispatcher || REACT_INTERNALS;\n\nvar getReactCurrentDispatcher = function() {\n  return ReactCurrentDispatcher.current || ReactCurrentDispatcher.H;\n};\n\nvar injectReactCurrentDispatcher = function(newDispatcher) {\n  if (!isReact19()) {\n    ReactCurrentDispatcher.current = newDispatcher;\n  } else {\n    ReactCurrentDispatcher.H = newDispatcher;\n  }\n};\n\nvar SHOULD_YIELD = typeof setImmediate === \"function\";\n\nvar YIELD_AFTER_MS = 5;\n\nvar render = function(type, props, queue, visitor, clientRefVisitor, element) {\n  if (isClientReference(type)) {\n    return mount(type, props, queue, clientRefVisitor, element);\n  }\n  return shouldConstruct(type) ? mount$1(type, props, queue, visitor, element) : mount$2(type, props, queue, visitor, element);\n};\n\nvar visitElement = function(element, queue, visitor, clientRefVisitor) {\n  switch (typeOf(element)) {\n   case REACT_SUSPENSE_TYPE:\n   case REACT_STRICT_MODE_TYPE:\n   case REACT_CONCURRENT_MODE_TYPE:\n   case REACT_PROFILER_TYPE:\n   case REACT_FRAGMENT_TYPE:\n    {\n      var fragmentElement = element;\n      return getChildrenArray(fragmentElement.props.children);\n    }\n\n   case REACT_PROVIDER_TYPE:\n    {\n      var providerElement = element;\n      var ref = providerElement.props;\n      var value = ref.value;\n      var children = ref.children;\n      var type = providerElement.type;\n      var context = typeof type._context === \"object\" ? type._context : type;\n      setContextValue(context, value);\n      return getChildrenArray(children);\n    }\n\n   case REACT_CONSUMER_TYPE:\n    {\n      var consumerElement = element;\n      var ref$1 = consumerElement.props;\n      var children$1 = ref$1.children;\n      if (typeof children$1 === \"function\") {\n        var type$1 = consumerElement.type;\n        var context$1 = typeof type$1._context === \"object\" ? type$1._context : type$1;\n        var value$1 = readContextValue(context$1);\n        return getChildrenArray(children$1(value$1));\n      } else {\n        return [];\n      }\n    }\n\n   case REACT_LAZY_TYPE:\n    {\n      var lazyElement = element;\n      var type$2 = lazyElement.type;\n      var child = mount$3(type$2, lazyElement.props, queue);\n      return getChildrenArray(child);\n    }\n\n   case REACT_MEMO_TYPE:\n    {\n      var memoElement = element;\n      var ref$2 = memoElement.type;\n      var type$3 = ref$2.type;\n      var child$1 = (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(type$3, memoElement.props);\n      return getChildrenArray(child$1);\n    }\n\n   case REACT_FORWARD_REF_TYPE:\n    {\n      var refElement = element;\n      var ref$3 = refElement.type;\n      var type$4 = ref$3.render;\n      var defaultProps = ref$3.defaultProps;\n      var props = computeProps(refElement.props, defaultProps);\n      var child$2 = (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(type$4, props);\n      return getChildrenArray(child$2);\n    }\n\n   case REACT_ELEMENT_TYPE:\n    {\n      var el = element;\n      if (typeof el.type === \"string\") {\n        return getChildrenArray(el.props.children);\n      } else {\n        var userElement = element;\n        var type$5 = userElement.type;\n        var props$1 = userElement.props;\n        var child$3 = render(type$5, props$1, queue, visitor, clientRefVisitor, userElement);\n        return getChildrenArray(child$3);\n      }\n    }\n\n   case REACT_PORTAL_TYPE:\n   default:\n    return [];\n  }\n};\n\nvar visitLoop = function(traversalChildren, traversalMap, traversalStore, traversalErrorFrame, queue, visitor, clientRefVisitor) {\n  var prevDispatcher = getReactCurrentDispatcher();\n  var start = Date.now();\n  try {\n    injectReactCurrentDispatcher(Dispatcher);\n    while (traversalChildren.length > 0) {\n      var element = traversalChildren[traversalChildren.length - 1].shift();\n      if (element !== undefined) {\n        var children = visitElement(element, queue, visitor, clientRefVisitor);\n        traversalChildren.push(children);\n        traversalMap.push(flushPrevContextMap());\n        traversalStore.push(flushPrevContextStore());\n        traversalErrorFrame.push(getCurrentErrorFrame());\n      } else {\n        traversalChildren.pop();\n        restoreContextMap(traversalMap.pop());\n        restoreContextStore(traversalStore.pop());\n        setCurrentErrorFrame(traversalErrorFrame.pop());\n      }\n      if (SHOULD_YIELD && Date.now() - start > YIELD_AFTER_MS) {\n        return true;\n      }\n    }\n    return false;\n  } catch (error) {\n    var errorFrame = getCurrentErrorFrame();\n    if (!errorFrame) {\n      throw error;\n    }\n    errorFrame.error = error;\n    queue.unshift(errorFrame);\n    return false;\n  } finally {\n    injectReactCurrentDispatcher(prevDispatcher);\n  }\n};\n\nvar makeYieldFrame = function(traversalChildren, traversalMap, traversalStore, traversalErrorFrame) {\n  return {\n    contextMap: getCurrentContextMap(),\n    contextStore: getCurrentContextStore(),\n    errorFrame: getCurrentErrorFrame(),\n    thenable: null,\n    kind: \"frame.yield\",\n    traversalChildren: traversalChildren,\n    traversalMap: traversalMap,\n    traversalStore: traversalStore,\n    traversalErrorFrame: traversalErrorFrame\n  };\n};\n\nvar visit = function(init, queue, visitor, clientRefVisitor) {\n  var traversalChildren = [ init ];\n  var traversalMap = [ flushPrevContextMap() ];\n  var traversalStore = [ flushPrevContextStore() ];\n  var traversalErrorFrame = [ getCurrentErrorFrame() ];\n  var hasYielded = visitLoop(traversalChildren, traversalMap, traversalStore, traversalErrorFrame, queue, visitor, clientRefVisitor);\n  if (hasYielded) {\n    queue.unshift(makeYieldFrame(traversalChildren, traversalMap, traversalStore, traversalErrorFrame));\n  }\n};\n\nvar update = function(frame, queue, visitor, clientRefVisitor) {\n  if (frame.kind === \"frame.yield\") {\n    setCurrentIdentity(null);\n    setCurrentContextMap(frame.contextMap);\n    setCurrentContextStore(frame.contextStore);\n    setCurrentErrorFrame(frame.errorFrame);\n    var hasYielded = visitLoop(frame.traversalChildren, frame.traversalMap, frame.traversalStore, frame.traversalErrorFrame, queue, visitor, clientRefVisitor);\n    if (hasYielded) {\n      queue.unshift(makeYieldFrame(frame.traversalChildren, frame.traversalMap, frame.traversalStore, frame.traversalErrorFrame));\n    }\n  } else {\n    var prevDispatcher = getReactCurrentDispatcher();\n    var children = null;\n    injectReactCurrentDispatcher(Dispatcher);\n    try {\n      if (frame.kind === \"frame.class\") {\n        children = update$2(queue, frame);\n      } else if (frame.kind === \"frame.hooks\") {\n        children = update$3(queue, frame);\n      } else if (frame.kind === \"frame.lazy\") {\n        children = update$4(queue, frame);\n      } else if (frame.kind === \"client-ref\") {\n        children = update$1(queue, frame);\n      }\n    } catch (error) {\n      var errorFrame = getCurrentErrorFrame();\n      if (!errorFrame) {\n        throw error;\n      }\n      errorFrame.error = error;\n      queue.unshift(errorFrame);\n      children = null;\n    } finally {\n      injectReactCurrentDispatcher(prevDispatcher);\n    }\n    visit(getChildrenArray(children), queue, visitor, clientRefVisitor);\n  }\n};\n\nfunction _ref(resolve, reject) {\n  setImmediate(resolve);\n}\n\nvar flushFrames = function(queue, visitor, clientRefVisitor, state) {\n  var frame = queue.shift();\n  if (!frame) {\n    return Promise.resolve();\n  }\n  if (SHOULD_YIELD && frame.kind === \"frame.yield\") {\n    frame.thenable = new Promise(_ref);\n  }\n  return Promise.resolve(frame.thenable).then((function() {\n    setCurrentRendererState(state);\n    update(frame, queue, visitor, clientRefVisitor);\n    return flushFrames(queue, visitor, clientRefVisitor, state);\n  }), (function(error) {\n    if (!frame.errorFrame) {\n      throw error;\n    }\n    frame.errorFrame.error = error;\n    update(frame.errorFrame, queue, visitor, clientRefVisitor);\n  }));\n};\n\nvar defaultVisitor = function() {\n  return undefined;\n};\n\nvar runningPrepassCount = 0;\n\nfunction _ref2() {\n  runningPrepassCount--;\n  if (!runningPrepassCount) {\n    delete globalThis.__ssrPrepassEnv;\n  }\n}\n\nvar renderPrepass = function(element, visitor, clientRefVisitor) {\n  if (!visitor) {\n    visitor = defaultVisitor;\n  }\n  if (!clientRefVisitor) {\n    clientRefVisitor = defaultVisitor;\n  }\n  var queue = [];\n  var state = initRendererState();\n  setCurrentContextMap({});\n  setCurrentContextStore(new Map);\n  setCurrentErrorFrame(null);\n  try {\n    runningPrepassCount++;\n    globalThis.__ssrPrepassEnv = {\n      readContextValue: readContextValue,\n      setContextValue: setContextValue\n    };\n    visit(getChildrenArray(element), queue, visitor, clientRefVisitor);\n  } catch (error) {\n    runningPrepassCount--;\n    if (!runningPrepassCount) {\n      delete globalThis.__ssrPrepassEnv;\n    }\n    return Promise.reject(error);\n  }\n  return flushFrames(queue, visitor, clientRefVisitor, state).finally(_ref2);\n};\n\n\n//# sourceMappingURL=react-ssr-prepass.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcGxhc21pY2FwcC9yZWFjdC1zc3ItcHJlcGFzcy9kaXN0L3JlYWN0LXNzci1wcmVwYXNzLmVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF1RDs7QUFFdkQ7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxpR0FBd0Q7QUFDbEU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsMkNBQVE7O0FBRXRCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1REFBdUQ7QUFDdkQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw0Q0FBNEM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvREFBYTtBQUN4QjtBQUNBO0FBQ0EsV0FBVyxvREFBYTtBQUN4QixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0Isc0NBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9EQUFhLENBQUMsdURBQWMsSUFBSTtBQUMzQyxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsaUdBQXdELElBQUksOEdBQXFFLElBQUksOEdBQXFFOztBQUVoTzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9EQUFhO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0RBQWE7QUFDakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVvQztBQUNwQyIsInNvdXJjZXMiOlsiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvV29uZGVyVml0ZS1mcm9udGVuZC9ub2RlX21vZHVsZXMvQHBsYXNtaWNhcHAvcmVhY3Qtc3NyLXByZXBhc3MvZGlzdC9yZWFjdC1zc3ItcHJlcGFzcy5lcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgQ2hpbGRyZW4sIGNyZWF0ZUVsZW1lbnQgfSBmcm9tIFwicmVhY3RcIjtcblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIHJldHVybiBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uKG4pIHtcbiAgICBmb3IgKHZhciBlID0gMTsgZSA8IGFyZ3VtZW50cy5sZW5ndGg7IGUrKykge1xuICAgICAgdmFyIHQgPSBhcmd1bWVudHNbZV07XG4gICAgICBmb3IgKHZhciByIGluIHQpIHtcbiAgICAgICAgKHt9KS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsIHIpICYmIChuW3JdID0gdFtyXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuO1xuICB9LCBfZXh0ZW5kcy5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufVxuXG52YXIgRWxlbWVudCA9IDYwMTAzO1xuXG52YXIgVHJhbnNpdGlvbmFsRWxlbWVudCA9IDYwMTAzO1xuXG52YXIgUG9ydGFsID0gNjAxMDY7XG5cbnZhciBGcmFnbWVudCA9IDYwMTA3O1xuXG52YXIgU3RyaWN0TW9kZSA9IDYwMTA4O1xuXG52YXIgUHJvZmlsZXIgPSA2MDExNDtcblxudmFyIENvbnRleHRQcm92aWRlciA9IDYwMTA5O1xuXG52YXIgQ29udGV4dENvbnN1bWVyID0gdW5kZWZpbmVkO1xuXG52YXIgQ29udGV4dCA9IDYwMTEwO1xuXG52YXIgQ29uY3VycmVudE1vZGUgPSA2MDExMTtcblxudmFyIEZvcndhcmRSZWYgPSA2MDExMjtcblxudmFyIFN1c3BlbnNlID0gNjAxMTM7XG5cbnZhciBNZW1vID0gNjAxMTU7XG5cbnZhciBMYXp5ID0gNjAxMTY7XG5cbnZhciBDbGllbnRSZWZlcmVuY2VUYWcgPSB1bmRlZmluZWQ7XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLmZvcikge1xuICB2YXIgc3ltYm9sRm9yID0gU3ltYm9sLmZvcjtcbiAgRWxlbWVudCA9IHN5bWJvbEZvcihcInJlYWN0LmVsZW1lbnRcIik7XG4gIFRyYW5zaXRpb25hbEVsZW1lbnQgPSBzeW1ib2xGb3IoXCJyZWFjdC50cmFuc2l0aW9uYWwuZWxlbWVudFwiKTtcbiAgUG9ydGFsID0gc3ltYm9sRm9yKFwicmVhY3QucG9ydGFsXCIpO1xuICBGcmFnbWVudCA9IHN5bWJvbEZvcihcInJlYWN0LmZyYWdtZW50XCIpO1xuICBTdHJpY3RNb2RlID0gc3ltYm9sRm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIik7XG4gIFByb2ZpbGVyID0gc3ltYm9sRm9yKFwicmVhY3QucHJvZmlsZXJcIik7XG4gIENvbnRleHRQcm92aWRlciA9IHN5bWJvbEZvcihcInJlYWN0LnByb3ZpZGVyXCIpO1xuICBDb250ZXh0Q29uc3VtZXIgPSBzeW1ib2xGb3IoXCJyZWFjdC5jb25zdW1lclwiKTtcbiAgQ29udGV4dCA9IHN5bWJvbEZvcihcInJlYWN0LmNvbnRleHRcIik7XG4gIENvbmN1cnJlbnRNb2RlID0gc3ltYm9sRm9yKFwicmVhY3QuY29uY3VycmVudF9tb2RlXCIpO1xuICBGb3J3YXJkUmVmID0gc3ltYm9sRm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIik7XG4gIFN1c3BlbnNlID0gc3ltYm9sRm9yKFwicmVhY3Quc3VzcGVuc2VcIik7XG4gIE1lbW8gPSBzeW1ib2xGb3IoXCJyZWFjdC5tZW1vXCIpO1xuICBMYXp5ID0gc3ltYm9sRm9yKFwicmVhY3QubGF6eVwiKTtcbiAgQ2xpZW50UmVmZXJlbmNlVGFnID0gc3ltYm9sRm9yKFwicmVhY3QuY2xpZW50LnJlZmVyZW5jZVwiKTtcbn1cblxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IEVsZW1lbnQ7XG5cbnZhciBSRUFDVF9UUkFOU0lUSU9OQUxfRUxFTUVOVF9UWVBFID0gVHJhbnNpdGlvbmFsRWxlbWVudDtcblxudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gUG9ydGFsO1xuXG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IEZyYWdtZW50O1xuXG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN0cmljdE1vZGU7XG5cbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gUHJvZmlsZXI7XG5cbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gQ29udGV4dFByb3ZpZGVyO1xuXG52YXIgUkVBQ1RfQ09OU1VNRVJfVFlQRSA9IENvbnRleHRDb25zdW1lcjtcblxudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IENvbnRleHQ7XG5cbnZhciBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSA9IENvbmN1cnJlbnRNb2RlO1xuXG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IEZvcndhcmRSZWY7XG5cbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3VzcGVuc2U7XG5cbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBNZW1vO1xuXG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gTGF6eTtcblxudmFyIENMSUVOVF9SRUZFUkVOQ0VfVEFHID0gQ2xpZW50UmVmZXJlbmNlVGFnO1xuXG5mdW5jdGlvbiBpc0NsaWVudFJlZmVyZW5jZShyZWZlcmVuY2UpIHtcbiAgcmV0dXJuIHJlZmVyZW5jZS4kJHR5cGVvZiA9PT0gQ0xJRU5UX1JFRkVSRU5DRV9UQUc7XG59XG5cbnZhciBnZXRDb21wb25lbnROYW1lID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAoaXNDbGllbnRSZWZlcmVuY2UodHlwZSkpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGlmICh0eXBlLmRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWU7XG4gIH1cbiAgaWYgKHNob3VsZENvbnN0cnVjdCh0eXBlKSkge1xuICAgIHJldHVybiB0eXBlLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHR5cGUubmFtZTtcbiAgfVxufTtcblxuZnVuY3Rpb24gaXNSZWFjdDE5KCkge1xuICByZXR1cm4gIVJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xufVxuXG52YXIgc2hvdWxkQ29uc3RydWN0ID0gZnVuY3Rpb24oQ29tcCkge1xuICByZXR1cm4gQ29tcC5wcm90b3R5cGUgJiYgQ29tcC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudDtcbn07XG5cbnZhciB0eXBlT2YgPSBmdW5jdGlvbih4KSB7XG4gIHN3aXRjaCAoeC4kJHR5cGVvZikge1xuICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICByZXR1cm4gUkVBQ1RfUE9SVEFMX1RZUEU7XG5cbiAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgY2FzZSBSRUFDVF9UUkFOU0lUSU9OQUxfRUxFTUVOVF9UWVBFOlxuICAgIHN3aXRjaCAoeC50eXBlKSB7XG4gICAgIGNhc2UgUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU7XG5cbiAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuIFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG5cbiAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuIFJFQUNUX1BST0ZJTEVSX1RZUEU7XG5cbiAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU7XG5cbiAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIFJFQUNUX1NVU1BFTlNFX1RZUEU7XG5cbiAgICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgc3dpdGNoICh4LnR5cGUgJiYgeC50eXBlLiQkdHlwZW9mKSB7XG4gICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICByZXR1cm4gUkVBQ1RfTEFaWV9UWVBFO1xuXG4gICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICByZXR1cm4gUkVBQ1RfTUVNT19UWVBFO1xuXG4gICAgICAgICBjYXNlIFJFQUNUX0NPTlNVTUVSX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFJFQUNUX0NPTlNVTUVSX1RZUEU7XG5cbiAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBpc1JlYWN0MTkoKSA/IFJFQUNUX1BST1ZJREVSX1RZUEUgOiBSRUFDVF9DT05TVU1FUl9UWVBFO1xuXG4gICAgICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFJFQUNUX1BST1ZJREVSX1RZUEU7XG5cbiAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICByZXR1cm4gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcblxuICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICBkZWZhdWx0OlxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn07XG5cbnZhciB0b0FycmF5ID0gQ2hpbGRyZW4udG9BcnJheTtcblxudmFyIGlzQWJzdHJhY3RFbGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICByZXR1cm4gbm9kZSAhPT0gbnVsbCAmJiB0eXBlb2Ygbm9kZSA9PT0gXCJvYmplY3RcIjtcbn07XG5cbnZhciBnZXRDaGlsZHJlbkFycmF5ID0gZnVuY3Rpb24obm9kZSkge1xuICByZXR1cm4gdG9BcnJheShub2RlKS5maWx0ZXIoaXNBYnN0cmFjdEVsZW1lbnQpO1xufTtcblxudmFyIGNvbXB1dGVQcm9wcyA9IGZ1bmN0aW9uKHByb3BzLCBkZWZhdWx0UHJvcHMpIHtcbiAgcmV0dXJuIHR5cGVvZiBkZWZhdWx0UHJvcHMgPT09IFwib2JqZWN0XCIgPyBfZXh0ZW5kcyh7fSwgZGVmYXVsdFByb3BzLCBwcm9wcykgOiBwcm9wcztcbn07XG5cbnZhciBjdXJyZW50Q29udGV4dFN0b3JlID0gbmV3IE1hcDtcblxudmFyIGN1cnJlbnRDb250ZXh0TWFwID0ge307XG5cbnZhciBwcmV2Q29udGV4dE1hcCA9IHVuZGVmaW5lZDtcblxudmFyIHByZXZDb250ZXh0RW50cnkgPSB1bmRlZmluZWQ7XG5cbnZhciBnZXRDdXJyZW50Q29udGV4dE1hcCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gX2V4dGVuZHMoe30sIGN1cnJlbnRDb250ZXh0TWFwKTtcbn07XG5cbnZhciBnZXRDdXJyZW50Q29udGV4dFN0b3JlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgTWFwKGN1cnJlbnRDb250ZXh0U3RvcmUpO1xufTtcblxudmFyIGZsdXNoUHJldkNvbnRleHRNYXAgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHByZXYgPSBwcmV2Q29udGV4dE1hcDtcbiAgcHJldkNvbnRleHRNYXAgPSB1bmRlZmluZWQ7XG4gIHJldHVybiBwcmV2O1xufTtcblxudmFyIGZsdXNoUHJldkNvbnRleHRTdG9yZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcHJldiA9IHByZXZDb250ZXh0RW50cnk7XG4gIHByZXZDb250ZXh0RW50cnkgPSB1bmRlZmluZWQ7XG4gIHJldHVybiBwcmV2O1xufTtcblxudmFyIHJlc3RvcmVDb250ZXh0TWFwID0gZnVuY3Rpb24ocHJldikge1xuICBpZiAocHJldiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgX2V4dGVuZHMoY3VycmVudENvbnRleHRNYXAsIHByZXYpO1xuICB9XG59O1xuXG52YXIgcmVzdG9yZUNvbnRleHRTdG9yZSA9IGZ1bmN0aW9uKHByZXYpIHtcbiAgaWYgKHByZXYgIT09IHVuZGVmaW5lZCkge1xuICAgIGN1cnJlbnRDb250ZXh0U3RvcmUuc2V0KHByZXZbMF0sIHByZXZbMV0pO1xuICB9XG59O1xuXG52YXIgc2V0Q3VycmVudENvbnRleHRNYXAgPSBmdW5jdGlvbihtYXApIHtcbiAgcHJldkNvbnRleHRNYXAgPSB1bmRlZmluZWQ7XG4gIGN1cnJlbnRDb250ZXh0TWFwID0gbWFwO1xufTtcblxudmFyIHNldEN1cnJlbnRDb250ZXh0U3RvcmUgPSBmdW5jdGlvbihzdG9yZSkge1xuICBwcmV2Q29udGV4dEVudHJ5ID0gdW5kZWZpbmVkO1xuICBjdXJyZW50Q29udGV4dFN0b3JlID0gc3RvcmU7XG59O1xuXG52YXIgYXNzaWduQ29udGV4dE1hcCA9IGZ1bmN0aW9uKG1hcCkge1xuICBwcmV2Q29udGV4dE1hcCA9IHt9O1xuICBmb3IgKHZhciBuYW1lIGluIG1hcCkge1xuICAgIHByZXZDb250ZXh0TWFwW25hbWVdID0gY3VycmVudENvbnRleHRNYXBbbmFtZV07XG4gICAgY3VycmVudENvbnRleHRNYXBbbmFtZV0gPSBtYXBbbmFtZV07XG4gIH1cbn07XG5cbnZhciBzZXRDb250ZXh0VmFsdWUgPSBmdW5jdGlvbihjb250ZXh0LCB2YWx1ZSkge1xuICBwcmV2Q29udGV4dEVudHJ5ID0gWyBjb250ZXh0LCBjdXJyZW50Q29udGV4dFN0b3JlLmdldChjb250ZXh0KSBdO1xuICBjdXJyZW50Q29udGV4dFN0b3JlLnNldChjb250ZXh0LCB2YWx1ZSk7XG59O1xuXG52YXIgcmVhZENvbnRleHRWYWx1ZSA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgdmFyIHZhbHVlID0gY3VycmVudENvbnRleHRTdG9yZS5nZXQoY29udGV4dCk7XG4gIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBjb250ZXh0Ll9jdXJyZW50VmFsdWU7XG59O1xuXG52YXIgZW1wdHlDb250ZXh0ID0ge307XG5cbnZhciBtYXNrQ29udGV4dCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGNvbnRleHRUeXBlID0gdHlwZS5jb250ZXh0VHlwZTtcbiAgdmFyIGNvbnRleHRUeXBlcyA9IHR5cGUuY29udGV4dFR5cGVzO1xuICBpZiAoY29udGV4dFR5cGUpIHtcbiAgICByZXR1cm4gcmVhZENvbnRleHRWYWx1ZShjb250ZXh0VHlwZSk7XG4gIH0gZWxzZSBpZiAoIWNvbnRleHRUeXBlcykge1xuICAgIHJldHVybiBlbXB0eUNvbnRleHQ7XG4gIH1cbiAgdmFyIG1hc2tlZENvbnRleHQgPSB7fTtcbiAgZm9yICh2YXIgbmFtZSBpbiBjb250ZXh0VHlwZXMpIHtcbiAgICBtYXNrZWRDb250ZXh0W25hbWVdID0gY3VycmVudENvbnRleHRNYXBbbmFtZV07XG4gIH1cbiAgcmV0dXJuIG1hc2tlZENvbnRleHQ7XG59O1xuXG52YXIgY3VycmVudEVycm9yRnJhbWUgPSBudWxsO1xuXG52YXIgZ2V0Q3VycmVudEVycm9yRnJhbWUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGN1cnJlbnRFcnJvckZyYW1lO1xufTtcblxudmFyIHNldEN1cnJlbnRFcnJvckZyYW1lID0gZnVuY3Rpb24oZnJhbWUpIHtcbiAgY3VycmVudEVycm9yRnJhbWUgPSBmcmFtZSB8fCBudWxsO1xufTtcblxudmFyIHJlbmRlcmVyU3RhdGVSZWYgPSB7XG4gIGN1cnJlbnQ6IHtcbiAgICB1bmlxdWVJRDogMFxuICB9XG59O1xuXG52YXIgaW5pdFJlbmRlcmVyU3RhdGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHJlbmRlcmVyU3RhdGVSZWYuY3VycmVudCA9IHtcbiAgICB1bmlxdWVJRDogMFxuICB9O1xufTtcblxudmFyIHNldEN1cnJlbnRSZW5kZXJlclN0YXRlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgcmV0dXJuIHJlbmRlcmVyU3RhdGVSZWYuY3VycmVudCA9IHN0YXRlO1xufTtcblxuZnVuY3Rpb24gaXMoeCwgeSkge1xuICByZXR1cm4geCA9PT0geSAmJiAoeCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHkpIHx8IHggIT09IHggJiYgeSAhPT0geTtcbn1cblxudmFyIG9iamVjdElzID0gdHlwZW9mIE9iamVjdC5pcyA9PT0gXCJmdW5jdGlvblwiID8gT2JqZWN0LmlzIDogaXM7XG5cbnZhciBpcyQxID0gb2JqZWN0SXM7XG5cbnZhciBjdXJyZW50SWRlbnRpdHkgPSBudWxsO1xuXG52YXIgbWFrZUlkZW50aXR5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7fTtcbn07XG5cbnZhciBzZXRDdXJyZW50SWRlbnRpdHkgPSBmdW5jdGlvbihpZCkge1xuICBjdXJyZW50SWRlbnRpdHkgPSBpZDtcbn07XG5cbnZhciBnZXRDdXJyZW50SWRlbnRpdHkgPSBmdW5jdGlvbigpIHtcbiAgaWYgKGN1cnJlbnRJZGVudGl0eSA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIltyZWFjdC1zc3ItcHJlcGFzc10gSG9va3MgY2FuIG9ubHkgYmUgY2FsbGVkIGluc2lkZSB0aGUgYm9keSBvZiBhIGZ1bmN0aW9uIGNvbXBvbmVudC4gXCIgKyBcIihodHRwczovL2ZiLm1lL3JlYWN0LWludmFsaWQtaG9vay1jYWxsKVwiKTtcbiAgfVxuICByZXR1cm4gY3VycmVudElkZW50aXR5O1xufTtcblxudmFyIGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcblxudmFyIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG5cbnZhciBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gZmFsc2U7XG5cbnZhciByZW5kZXJQaGFzZVVwZGF0ZXMgPSBudWxsO1xuXG52YXIgbnVtYmVyT2ZSZVJlbmRlcnMgPSAwO1xuXG52YXIgUkVfUkVOREVSX0xJTUlUJDEgPSAyNTtcblxudmFyIGdldEZpcnN0SG9vayA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2s7XG59O1xuXG52YXIgc2V0Rmlyc3RIb29rID0gZnVuY3Rpb24oaG9vaykge1xuICBmaXJzdFdvcmtJblByb2dyZXNzSG9vayA9IGhvb2s7XG59O1xuXG5mdW5jdGlvbiBhcmVIb29rSW5wdXRzRXF1YWwobmV4dERlcHMsIHByZXZEZXBzKSB7XG4gIGlmIChwcmV2RGVwcyA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHByZXZEZXBzLmxlbmd0aCAmJiBpIDwgbmV4dERlcHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWlzJDEobmV4dERlcHNbaV0sIHByZXZEZXBzW2ldKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSG9vaygpIHtcbiAgcmV0dXJuIHtcbiAgICBtZW1vaXplZFN0YXRlOiBudWxsLFxuICAgIHF1ZXVlOiBudWxsLFxuICAgIG5leHQ6IG51bGxcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkge1xuICBpZiAod29ya0luUHJvZ3Jlc3NIb29rID09PSBudWxsKSB7XG4gICAgaWYgKGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2sgPSB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBjcmVhdGVIb29rKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBmaXJzdFdvcmtJblByb2dyZXNzSG9vaztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHdvcmtJblByb2dyZXNzSG9vay5uZXh0ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rLm5leHQgPSBjcmVhdGVIb29rKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzc0hvb2sgPSB3b3JrSW5Qcm9ncmVzc0hvb2submV4dDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyV2l0aEhvb2tzKENvbXBvbmVudCwgcHJvcHMsIHJlZk9yQ29udGV4dCkge1xuICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xuICB2YXIgY2hpbGRyZW4gPSBDb21wb25lbnQocHJvcHMsIHJlZk9yQ29udGV4dCk7XG4gIHdoaWxlIChudW1iZXJPZlJlUmVuZGVycyA8IFJFX1JFTkRFUl9MSU1JVCQxICYmIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUpIHtcbiAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gZmFsc2U7XG4gICAgbnVtYmVyT2ZSZVJlbmRlcnMgKz0gMTtcbiAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xuICAgIGNoaWxkcmVuID0gQ29tcG9uZW50KHByb3BzLCByZWZPckNvbnRleHQpO1xuICB9XG4gIG51bWJlck9mUmVSZW5kZXJzID0gMDtcbiAgcmVuZGVyUGhhc2VVcGRhdGVzID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG5mdW5jdGlvbiByZWFkQ29udGV4dChjb250ZXh0LCBfKSB7XG4gIHJldHVybiByZWFkQ29udGV4dFZhbHVlKGNvbnRleHQpO1xufVxuXG5mdW5jdGlvbiB1c2VDb250ZXh0KGNvbnRleHQsIF8pIHtcbiAgZ2V0Q3VycmVudElkZW50aXR5KCk7XG4gIHJldHVybiByZWFkQ29udGV4dFZhbHVlKGNvbnRleHQpO1xufVxuXG5mdW5jdGlvbiBiYXNpY1N0YXRlUmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gIHJldHVybiB0eXBlb2YgYWN0aW9uID09PSBcImZ1bmN0aW9uXCIgPyBhY3Rpb24oc3RhdGUpIDogYWN0aW9uO1xufVxuXG5mdW5jdGlvbiB1c2VTdGF0ZShpbml0aWFsU3RhdGUpIHtcbiAgcmV0dXJuIHVzZVJlZHVjZXIoYmFzaWNTdGF0ZVJlZHVjZXIsIGluaXRpYWxTdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIHVzZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICB2YXIgaWQgPSBnZXRDdXJyZW50SWRlbnRpdHkoKTtcbiAgd29ya0luUHJvZ3Jlc3NIb29rID0gY3JlYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIGlmICh3b3JrSW5Qcm9ncmVzc0hvb2sucXVldWUgPT09IG51bGwpIHtcbiAgICB2YXIgaW5pdGlhbFN0YXRlO1xuICAgIGlmIChyZWR1Y2VyID09PSBiYXNpY1N0YXRlUmVkdWNlcikge1xuICAgICAgaW5pdGlhbFN0YXRlID0gdHlwZW9mIGluaXRpYWxBcmcgPT09IFwiZnVuY3Rpb25cIiA/IGluaXRpYWxBcmcoKSA6IGluaXRpYWxBcmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluaXRpYWxTdGF0ZSA9IGluaXQgIT09IHVuZGVmaW5lZCA/IGluaXQoaW5pdGlhbEFyZykgOiBpbml0aWFsQXJnO1xuICAgIH1cbiAgICB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgfVxuICB2YXIgcXVldWUgPSB3b3JrSW5Qcm9ncmVzc0hvb2sucXVldWUgfHwgKHdvcmtJblByb2dyZXNzSG9vay5xdWV1ZSA9IHtcbiAgICBsYXN0OiBudWxsLFxuICAgIGRpc3BhdGNoOiBudWxsXG4gIH0pO1xuICB2YXIgZGlzcGF0Y2ggPSBxdWV1ZS5kaXNwYXRjaCB8fCAocXVldWUuZGlzcGF0Y2ggPSBkaXNwYXRjaEFjdGlvbi5iaW5kKG51bGwsIGlkLCBxdWV1ZSkpO1xuICBpZiAocmVuZGVyUGhhc2VVcGRhdGVzICE9PSBudWxsKSB7XG4gICAgdmFyIGZpcnN0UmVuZGVyUGhhc2VVcGRhdGUgPSByZW5kZXJQaGFzZVVwZGF0ZXMuZ2V0KHF1ZXVlKTtcbiAgICBpZiAoZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZW5kZXJQaGFzZVVwZGF0ZXMuZGVsZXRlKHF1ZXVlKTtcbiAgICAgIHZhciBuZXdTdGF0ZSA9IHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlO1xuICAgICAgdmFyIHVwZGF0ZSA9IGZpcnN0UmVuZGVyUGhhc2VVcGRhdGU7XG4gICAgICBkbyB7XG4gICAgICAgIHZhciBhY3Rpb24gPSB1cGRhdGUuYWN0aW9uO1xuICAgICAgICBuZXdTdGF0ZSA9IHJlZHVjZXIobmV3U3RhdGUsIGFjdGlvbik7XG4gICAgICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuICAgICAgfSB3aGlsZSAodXBkYXRlICE9PSBudWxsKTtcbiAgICAgIHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGU7XG4gICAgfVxuICB9XG4gIHJldHVybiBbIHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlLCBkaXNwYXRjaCBdO1xufVxuXG5mdW5jdGlvbiB1c2VNZW1vKG5leHRDcmVhdGUsIGRlcHMpIHtcbiAgZ2V0Q3VycmVudElkZW50aXR5KCk7XG4gIHdvcmtJblByb2dyZXNzSG9vayA9IGNyZWF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgbmV4dERlcHMgPSBkZXBzID09PSB1bmRlZmluZWQgPyBudWxsIDogZGVwcztcbiAgdmFyIHByZXZTdGF0ZSA9IHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlO1xuICBpZiAocHJldlN0YXRlICE9PSBudWxsICYmIG5leHREZXBzICE9PSBudWxsKSB7XG4gICAgdmFyIHByZXZEZXBzID0gcHJldlN0YXRlWzFdO1xuICAgIGlmIChhcmVIb29rSW5wdXRzRXF1YWwobmV4dERlcHMsIHByZXZEZXBzKSkge1xuICAgICAgcmV0dXJuIHByZXZTdGF0ZVswXTtcbiAgICB9XG4gIH1cbiAgdmFyIG5leHRWYWx1ZSA9IG5leHRDcmVhdGUoKTtcbiAgd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUgPSBbIG5leHRWYWx1ZSwgbmV4dERlcHMgXTtcbiAgcmV0dXJuIG5leHRWYWx1ZTtcbn1cblxuZnVuY3Rpb24gdXNlUmVmKGluaXRpYWxWYWx1ZSkge1xuICBnZXRDdXJyZW50SWRlbnRpdHkoKTtcbiAgd29ya0luUHJvZ3Jlc3NIb29rID0gY3JlYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBwcmV2aW91c1JlZiA9IHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlO1xuICBpZiAocHJldmlvdXNSZWYgPT09IG51bGwpIHtcbiAgICB2YXIgcmVmID0ge1xuICAgICAgY3VycmVudDogaW5pdGlhbFZhbHVlXG4gICAgfTtcbiAgICB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSA9IHJlZjtcbiAgICByZXR1cm4gcmVmO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwcmV2aW91c1JlZjtcbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VPcGFxdWVJZGVudGlmaWVyKCkge1xuICBnZXRDdXJyZW50SWRlbnRpdHkoKTtcbiAgd29ya0luUHJvZ3Jlc3NIb29rID0gY3JlYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIGlmICghd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUpIHtcbiAgICB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSA9IFwiUjpcIiArIChyZW5kZXJlclN0YXRlUmVmLmN1cnJlbnQudW5pcXVlSUQrKykudG9TdHJpbmcoMzYpO1xuICB9XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZTtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hBY3Rpb24oY29tcG9uZW50SWRlbnRpdHksIHF1ZXVlLCBhY3Rpb24pIHtcbiAgaWYgKGNvbXBvbmVudElkZW50aXR5ID09PSBjdXJyZW50SWRlbnRpdHkpIHtcbiAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gdHJ1ZTtcbiAgICB2YXIgdXBkYXRlID0ge1xuICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcbiAgICBpZiAocmVuZGVyUGhhc2VVcGRhdGVzID09PSBudWxsKSB7XG4gICAgICByZW5kZXJQaGFzZVVwZGF0ZXMgPSBuZXcgTWFwO1xuICAgIH1cbiAgICB2YXIgZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSA9IHJlbmRlclBoYXNlVXBkYXRlcy5nZXQocXVldWUpO1xuICAgIGlmIChmaXJzdFJlbmRlclBoYXNlVXBkYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlbmRlclBoYXNlVXBkYXRlcy5zZXQocXVldWUsIHVwZGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsYXN0UmVuZGVyUGhhc2VVcGRhdGUgPSBmaXJzdFJlbmRlclBoYXNlVXBkYXRlO1xuICAgICAgd2hpbGUgKGxhc3RSZW5kZXJQaGFzZVVwZGF0ZS5uZXh0ICE9PSBudWxsKSB7XG4gICAgICAgIGxhc3RSZW5kZXJQaGFzZVVwZGF0ZSA9IGxhc3RSZW5kZXJQaGFzZVVwZGF0ZS5uZXh0O1xuICAgICAgfVxuICAgICAgbGFzdFJlbmRlclBoYXNlVXBkYXRlLm5leHQgPSB1cGRhdGU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVzZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKSB7XG4gIHJldHVybiB1c2VNZW1vKChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY2FsbGJhY2s7XG4gIH0pLCBkZXBzKTtcbn1cblxuZnVuY3Rpb24gdXNlTXV0YWJsZVNvdXJjZShzb3VyY2UsIGdldFNuYXBzaG90LCBfc3Vic2NyaWJlKSB7XG4gIGdldEN1cnJlbnRJZGVudGl0eSgpO1xuICByZXR1cm4gZ2V0U25hcHNob3Qoc291cmNlLl9zb3VyY2UpO1xufVxuXG5mdW5jdGlvbiBub29wKCkge31cblxuZnVuY3Rpb24gX3JlZiQzKGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrKCk7XG59XG5cbmZ1bmN0aW9uIHVzZVRyYW5zaXRpb24oKSB7XG4gIHZhciBzdGFydFRyYW5zaXRpb24gPSBfcmVmJDM7XG4gIHJldHVybiBbIHN0YXJ0VHJhbnNpdGlvbiwgZmFsc2UgXTtcbn1cblxuZnVuY3Rpb24gdXNlRGVmZXJyZWRWYWx1ZShpbnB1dCkge1xuICByZXR1cm4gaW5wdXQ7XG59XG5cbmZ1bmN0aW9uIHVzZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gIHJldHVybiBnZXRTbmFwc2hvdCgpO1xufVxuXG52YXIgRGlzcGF0Y2hlciA9IHtcbiAgcmVhZENvbnRleHQ6IHJlYWRDb250ZXh0LFxuICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogdXNlU3luY0V4dGVybmFsU3RvcmUsXG4gIHVzZUNvbnRleHQ6IHVzZUNvbnRleHQsXG4gIHVzZU1lbW86IHVzZU1lbW8sXG4gIHVzZVJlZHVjZXI6IHVzZVJlZHVjZXIsXG4gIHVzZVJlZjogdXNlUmVmLFxuICB1c2VTdGF0ZTogdXNlU3RhdGUsXG4gIHVzZUNhbGxiYWNrOiB1c2VDYWxsYmFjayxcbiAgdXNlTXV0YWJsZVNvdXJjZTogdXNlTXV0YWJsZVNvdXJjZSxcbiAgdXNlVHJhbnNpdGlvbjogdXNlVHJhbnNpdGlvbixcbiAgdXNlRGVmZXJyZWRWYWx1ZTogdXNlRGVmZXJyZWRWYWx1ZSxcbiAgdXNlT3BhcXVlSWRlbnRpZmllcjogdXNlT3BhcXVlSWRlbnRpZmllcixcbiAgdXNlSWQ6IHVzZU9wYXF1ZUlkZW50aWZpZXIsXG4gIHVuc3RhYmxlX3VzZUlkOiB1c2VPcGFxdWVJZGVudGlmaWVyLFxuICB1bnN0YWJsZV91c2VPcGFxdWVJZGVudGlmaWVyOiB1c2VPcGFxdWVJZGVudGlmaWVyLFxuICB1c2VMYXlvdXRFZmZlY3Q6IG5vb3AsXG4gIHVzZUltcGVyYXRpdmVIYW5kbGU6IG5vb3AsXG4gIHVzZUVmZmVjdDogbm9vcCxcbiAgdXNlRGVidWdWYWx1ZTogbm9vcCxcbiAgdXNlSW5zZXJ0aW9uRWZmZWN0OiBub29wLFxuICBpc1BsYXNtaWNQcmVwYXNzOiB0cnVlXG59O1xuXG52YXIgcmVzb2x2ZSA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIHBheWxvYWQgPSB0eXBlLl9wYXlsb2FkIHx8IHR5cGU7XG4gIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IDApIHtcbiAgICByZXR1cm4gcGF5bG9hZC5fcmVzdWx0O1xuICB9IGVsc2UgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gMSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocGF5bG9hZC5fcmVzdWx0KTtcbiAgfSBlbHNlIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IDIpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QocGF5bG9hZC5fcmVzdWx0KTtcbiAgfVxuICBwYXlsb2FkLl9zdGF0dXMgPSAwO1xuICByZXR1cm4gcGF5bG9hZC5fcmVzdWx0ID0gKHBheWxvYWQuX2N0b3IgfHwgcGF5bG9hZC5fcmVzdWx0KSgpLnRoZW4oKGZ1bmN0aW9uKENvbXBvbmVudCkge1xuICAgIHBheWxvYWQuX3Jlc3VsdCA9IENvbXBvbmVudDtcbiAgICBpZiAodHlwZW9mIENvbXBvbmVudCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBwYXlsb2FkLl9zdGF0dXMgPSAxO1xuICAgIH0gZWxzZSBpZiAoQ29tcG9uZW50ICE9PSBudWxsICYmIHR5cGVvZiBDb21wb25lbnQgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIENvbXBvbmVudC5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHBheWxvYWQuX3Jlc3VsdCA9IENvbXBvbmVudC5kZWZhdWx0O1xuICAgICAgcGF5bG9hZC5fc3RhdHVzID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF5bG9hZC5fc3RhdHVzID0gMjtcbiAgICB9XG4gIH0pKS5jYXRjaCgoZnVuY3Rpb24oZXJyb3IpIHtcbiAgICBwYXlsb2FkLl9zdGF0dXMgPSAyO1xuICAgIHBheWxvYWQuX3Jlc3VsdCA9IGVycm9yO1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gIH0pKTtcbn07XG5cbnZhciBtYWtlRnJhbWUkMiA9IGZ1bmN0aW9uKHR5cGUsIHByb3BzLCB0aGVuYWJsZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwiZnJhbWUubGF6eVwiLFxuICAgIGNvbnRleHRNYXA6IGdldEN1cnJlbnRDb250ZXh0TWFwKCksXG4gICAgY29udGV4dFN0b3JlOiBnZXRDdXJyZW50Q29udGV4dFN0b3JlKCksXG4gICAgZXJyb3JGcmFtZTogZ2V0Q3VycmVudEVycm9yRnJhbWUoKSxcbiAgICB0aGVuYWJsZTogdGhlbmFibGUsXG4gICAgcHJvcHM6IHByb3BzLFxuICAgIHR5cGU6IHR5cGVcbiAgfTtcbn07XG5cbnZhciByZW5kZXIkNCA9IGZ1bmN0aW9uKHR5cGUsIHByb3BzLCBxdWV1ZSkge1xuICB2YXIgcGF5bG9hZCA9IHR5cGUuX3BheWxvYWQgfHwgdHlwZTtcbiAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gMSAmJiBwYXlsb2FkLl9yZXN1bHQpIHtcbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudChwYXlsb2FkLl9yZXN1bHQsIHByb3BzKTtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KHR5cGUuX2luaXQodHlwZS5fcGF5bG9hZCksIHByb3BzKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKCEhZXJyICYmIHR5cGVvZiBlcnIudGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBxdWV1ZS5wdXNoKG1ha2VGcmFtZSQyKHR5cGUsIHByb3BzLCBlcnIpKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbnZhciBtb3VudCQzID0gZnVuY3Rpb24odHlwZSwgcHJvcHMsIHF1ZXVlKSB7XG4gIHZhciBwYXlsb2FkID0gdHlwZS5fcGF5bG9hZCB8fCB0eXBlO1xuICBpZiAocGF5bG9hZC5fc3RhdHVzICE9IG51bGwgJiYgcGF5bG9hZC5fc3RhdHVzIDw9IDApIHtcbiAgICBxdWV1ZS5wdXNoKG1ha2VGcmFtZSQyKHR5cGUsIHByb3BzLCByZXNvbHZlKHR5cGUpKSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHJlbmRlciQ0KHR5cGUsIHByb3BzLCBxdWV1ZSk7XG59O1xuXG52YXIgdXBkYXRlJDQgPSBmdW5jdGlvbihxdWV1ZSwgZnJhbWUpIHtcbiAgc2V0Q3VycmVudElkZW50aXR5KG51bGwpO1xuICBzZXRDdXJyZW50Q29udGV4dE1hcChmcmFtZS5jb250ZXh0TWFwKTtcbiAgc2V0Q3VycmVudENvbnRleHRTdG9yZShmcmFtZS5jb250ZXh0U3RvcmUpO1xuICBzZXRDdXJyZW50RXJyb3JGcmFtZShmcmFtZS5lcnJvckZyYW1lKTtcbiAgcmV0dXJuIHJlbmRlciQ0KGZyYW1lLnR5cGUsIGZyYW1lLnByb3BzLCBxdWV1ZSk7XG59O1xuXG52YXIgbWFrZUZyYW1lJDEgPSBmdW5jdGlvbih0eXBlLCBwcm9wcywgdGhlbmFibGUpIHtcbiAgcmV0dXJuIHtcbiAgICBjb250ZXh0TWFwOiBnZXRDdXJyZW50Q29udGV4dE1hcCgpLFxuICAgIGNvbnRleHRTdG9yZTogZ2V0Q3VycmVudENvbnRleHRTdG9yZSgpLFxuICAgIGlkOiBnZXRDdXJyZW50SWRlbnRpdHkoKSxcbiAgICBob29rOiBnZXRGaXJzdEhvb2soKSxcbiAgICBraW5kOiBcImZyYW1lLmhvb2tzXCIsXG4gICAgZXJyb3JGcmFtZTogZ2V0Q3VycmVudEVycm9yRnJhbWUoKSxcbiAgICB0aGVuYWJsZTogdGhlbmFibGUsXG4gICAgcHJvcHM6IHByb3BzLFxuICAgIHR5cGU6IHR5cGVcbiAgfTtcbn07XG5cbnZhciByZW5kZXIkMyA9IGZ1bmN0aW9uKHR5cGUsIHByb3BzLCBxdWV1ZSkge1xuICB0cnkge1xuICAgIHJldHVybiByZW5kZXJXaXRoSG9va3ModHlwZSwgY29tcHV0ZVByb3BzKHByb3BzLCB0eXBlLmRlZmF1bHRQcm9wcyksIG1hc2tDb250ZXh0KHR5cGUpKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAodHlwZW9mIGVycm9yLnRoZW4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY29uc29sZS53YXJuKFwiUExBU01JQzogRW5jb3VudGVyZWQgZXJyb3Igd2hlbiBwcmUtcmVuZGVyaW5nIFwiICsgZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSArIFwiOiBcIiArIGVycm9yKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG1ha2VGcmFtZSQxKHR5cGUsIHByb3BzLCBlcnJvcikpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG52YXIgbW91bnQkMiA9IGZ1bmN0aW9uKHR5cGUsIHByb3BzLCBxdWV1ZSwgdmlzaXRvciwgZWxlbWVudCkge1xuICBzZXRGaXJzdEhvb2sobnVsbCk7XG4gIHNldEN1cnJlbnRJZGVudGl0eShtYWtlSWRlbnRpdHkoKSk7XG4gIHZhciBwcm9taXNlID0gdmlzaXRvcihlbGVtZW50KTtcbiAgaWYgKHByb21pc2UpIHtcbiAgICBxdWV1ZS5wdXNoKG1ha2VGcmFtZSQxKHR5cGUsIHByb3BzLCBwcm9taXNlKSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHJlbmRlciQzKHR5cGUsIHByb3BzLCBxdWV1ZSk7XG59O1xuXG52YXIgdXBkYXRlJDMgPSBmdW5jdGlvbihxdWV1ZSwgZnJhbWUpIHtcbiAgc2V0Rmlyc3RIb29rKGZyYW1lLmhvb2spO1xuICBzZXRDdXJyZW50SWRlbnRpdHkoZnJhbWUuaWQpO1xuICBzZXRDdXJyZW50Q29udGV4dE1hcChmcmFtZS5jb250ZXh0TWFwKTtcbiAgc2V0Q3VycmVudENvbnRleHRTdG9yZShmcmFtZS5jb250ZXh0U3RvcmUpO1xuICBzZXRDdXJyZW50RXJyb3JGcmFtZShmcmFtZS5lcnJvckZyYW1lKTtcbiAgcmV0dXJuIHJlbmRlciQzKGZyYW1lLnR5cGUsIGZyYW1lLnByb3BzLCBxdWV1ZSk7XG59O1xuXG52YXIgUkVfUkVOREVSX0xJTUlUID0gMjU7XG5cbmZ1bmN0aW9uIF9yZWYkMigpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBfcmVmMiQxKCkge1xuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGNyZWF0ZVVwZGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHF1ZXVlID0gW107XG4gIHJldHVybiB7XG4gICAgX3Rocm93bjogMCxcbiAgICBxdWV1ZTogcXVldWUsXG4gICAgaXNNb3VudGVkOiBfcmVmJDIsXG4gICAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBfcmVmMiQxLFxuICAgIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uKGluc3RhbmNlLCBjb21wbGV0ZVN0YXRlKSB7XG4gICAgICBpZiAoaW5zdGFuY2UuX2lzTW91bnRlZCkge1xuICAgICAgICBxdWV1ZS5sZW5ndGggPSAwO1xuICAgICAgICBxdWV1ZS5wdXNoKGNvbXBsZXRlU3RhdGUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbihpbnN0YW5jZSwgY3VycmVudFBhcnRpYWxTdGF0ZSkge1xuICAgICAgaWYgKGluc3RhbmNlLl9pc01vdW50ZWQpIHtcbiAgICAgICAgcXVldWUucHVzaChjdXJyZW50UGFydGlhbFN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59O1xuXG52YXIgZmx1c2hFbnF1ZXVlZFN0YXRlID0gZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgdmFyIHF1ZXVlID0gaW5zdGFuY2UudXBkYXRlci5xdWV1ZTtcbiAgaWYgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgbmV4dFN0YXRlID0gX2V4dGVuZHMoe30sIGluc3RhbmNlLnN0YXRlKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHF1ZXVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIHBhcnRpYWwgPSBxdWV1ZVtpXTtcbiAgICAgIHZhciBwYXJ0aWFsU3RhdGUgPSB0eXBlb2YgcGFydGlhbCA9PT0gXCJmdW5jdGlvblwiID8gcGFydGlhbC5jYWxsKGluc3RhbmNlLCBuZXh0U3RhdGUsIGluc3RhbmNlLnByb3BzLCBpbnN0YW5jZS5jb250ZXh0KSA6IHBhcnRpYWw7XG4gICAgICBpZiAocGFydGlhbFN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIF9leHRlbmRzKG5leHRTdGF0ZSwgcGFydGlhbFN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaW5zdGFuY2Uuc3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgcXVldWUubGVuZ3RoID0gMDtcbiAgfVxufTtcblxudmFyIGNyZWF0ZUluc3RhbmNlID0gZnVuY3Rpb24odHlwZSwgcHJvcHMpIHtcbiAgdmFyIHVwZGF0ZXIgPSBjcmVhdGVVcGRhdGVyKCk7XG4gIHZhciBjb21wdXRlZFByb3BzID0gY29tcHV0ZVByb3BzKHByb3BzLCB0eXBlLmRlZmF1bHRQcm9wcyk7XG4gIHZhciBjb250ZXh0ID0gbWFza0NvbnRleHQodHlwZSk7XG4gIHZhciBpbnN0YW5jZSA9IG5ldyB0eXBlKGNvbXB1dGVkUHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpO1xuICBpbnN0YW5jZS5wcm9wcyA9IGNvbXB1dGVkUHJvcHM7XG4gIGluc3RhbmNlLmNvbnRleHQgPSBjb250ZXh0O1xuICBpbnN0YW5jZS51cGRhdGVyID0gdXBkYXRlcjtcbiAgaW5zdGFuY2UuX2lzTW91bnRlZCA9IHRydWU7XG4gIGlmIChpbnN0YW5jZS5zdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaW5zdGFuY2Uuc3RhdGUgPSBudWxsO1xuICB9XG4gIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkQ2F0Y2ggPT09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgdHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHZhciBmcmFtZSA9IG1ha2VGcmFtZSh0eXBlLCBpbnN0YW5jZSwgbnVsbCk7XG4gICAgZnJhbWUuZXJyb3JGcmFtZSA9IGZyYW1lO1xuICAgIHNldEN1cnJlbnRFcnJvckZyYW1lKGZyYW1lKTtcbiAgfVxuICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB2YXIgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gdHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7XG4gICAgdmFyIHN0YXRlID0gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKGluc3RhbmNlLnByb3BzLCBpbnN0YW5jZS5zdGF0ZSk7XG4gICAgaWYgKHN0YXRlICE9PSBudWxsICYmIHN0YXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGluc3RhbmNlLnN0YXRlID0gX2V4dGVuZHMoe30sIGluc3RhbmNlLnN0YXRlLCBzdGF0ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCgpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50KCk7XG4gIH1cbiAgcmV0dXJuIGluc3RhbmNlO1xufTtcblxudmFyIG1ha2VGcmFtZSA9IGZ1bmN0aW9uKHR5cGUsIGluc3RhbmNlLCB0aGVuYWJsZSkge1xuICByZXR1cm4ge1xuICAgIGNvbnRleHRNYXA6IGdldEN1cnJlbnRDb250ZXh0TWFwKCksXG4gICAgY29udGV4dFN0b3JlOiBnZXRDdXJyZW50Q29udGV4dFN0b3JlKCksXG4gICAgZXJyb3JGcmFtZTogZ2V0Q3VycmVudEVycm9yRnJhbWUoKSxcbiAgICB0aGVuYWJsZTogdGhlbmFibGUsXG4gICAga2luZDogXCJmcmFtZS5jbGFzc1wiLFxuICAgIGVycm9yOiBudWxsLFxuICAgIGluc3RhbmNlOiBpbnN0YW5jZSxcbiAgICB0eXBlOiB0eXBlXG4gIH07XG59O1xuXG52YXIgcmVuZGVyJDIgPSBmdW5jdGlvbih0eXBlLCBpbnN0YW5jZSwgcXVldWUpIHtcbiAgZmx1c2hFbnF1ZXVlZFN0YXRlKGluc3RhbmNlKTtcbiAgdmFyIGNoaWxkID0gbnVsbDtcbiAgdHJ5IHtcbiAgICBjaGlsZCA9IGluc3RhbmNlLnJlbmRlcigpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmICh0eXBlb2YgZXJyb3IudGhlbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJQTEFTTUlDOiBFbmNvdW50ZXJlZCBlcnJvciB3aGVuIHByZS1yZW5kZXJpbmcgY29tcG9uZW50IFwiICsgZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSArIFwiLiBUaGlzIGlzIGZpbmUgYXMgbG9uZyBhcyB5b3UgYXJlIG5vdCBmZXRjaGluZyBkYXRhIHdpdGggQHBsYXNtaWNhcHAvcXVlcnkgaW5zaWRlIHRoaXMgY29tcG9uZW50LiAgRXJyb3I6IFwiICsgZXJyb3IpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobWFrZUZyYW1lKHR5cGUsIGluc3RhbmNlLCBlcnJvcikpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICh0eXBlLmNoaWxkQ29udGV4dFR5cGVzICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGluc3RhbmNlLmdldENoaWxkQ29udGV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdmFyIGNoaWxkQ29udGV4dCA9IGluc3RhbmNlLmdldENoaWxkQ29udGV4dCgpO1xuICAgIGlmIChjaGlsZENvbnRleHQgIT09IG51bGwgJiYgdHlwZW9mIGNoaWxkQ29udGV4dCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgYXNzaWduQ29udGV4dE1hcChjaGlsZENvbnRleHQpO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIGluc3RhbmNlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyAhPT0gXCJmdW5jdGlvblwiICYmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09IFwiZnVuY3Rpb25cIikgJiYgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVbm1vdW50ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB0cnkge1xuICAgICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVubW91bnQoKTtcbiAgICB9IGNhdGNoIChfZXJyKSB7fVxuICB9XG4gIGluc3RhbmNlLl9pc01vdW50ZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGNoaWxkO1xufTtcblxudmFyIG1vdW50JDEgPSBmdW5jdGlvbih0eXBlLCBwcm9wcywgcXVldWUsIHZpc2l0b3IsIGVsZW1lbnQpIHtcbiAgc2V0Q3VycmVudElkZW50aXR5KG51bGwpO1xuICB2YXIgaW5zdGFuY2UgPSBjcmVhdGVJbnN0YW5jZSh0eXBlLCBwcm9wcyk7XG4gIHZhciBwcm9taXNlID0gdmlzaXRvcihlbGVtZW50LCBpbnN0YW5jZSk7XG4gIGlmIChwcm9taXNlKSB7XG4gICAgcXVldWUucHVzaChtYWtlRnJhbWUodHlwZSwgaW5zdGFuY2UsIHByb21pc2UpKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gcmVuZGVyJDIodHlwZSwgaW5zdGFuY2UsIHF1ZXVlKTtcbn07XG5cbnZhciB1cGRhdGUkMiA9IGZ1bmN0aW9uKHF1ZXVlLCBmcmFtZSkge1xuICBzZXRDdXJyZW50SWRlbnRpdHkobnVsbCk7XG4gIHNldEN1cnJlbnRDb250ZXh0TWFwKGZyYW1lLmNvbnRleHRNYXApO1xuICBzZXRDdXJyZW50Q29udGV4dFN0b3JlKGZyYW1lLmNvbnRleHRTdG9yZSk7XG4gIHNldEN1cnJlbnRFcnJvckZyYW1lKGZyYW1lLmVycm9yRnJhbWUpO1xuICBpZiAoZnJhbWUuZXJyb3IpIHtcbiAgICBpZiAoKytmcmFtZS5pbnN0YW5jZS51cGRhdGVyLl90aHJvd24gPj0gUkVfUkVOREVSX0xJTUlUKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnJhbWUuaW5zdGFuY2UuX2lzTW91bnRlZCA9IHRydWU7XG4gICAgaWYgKHR5cGVvZiBmcmFtZS5pbnN0YW5jZS5jb21wb25lbnREaWRDYXRjaCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBmcmFtZS5pbnN0YW5jZS5jb21wb25lbnREaWRDYXRjaChmcmFtZS5lcnJvcik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZnJhbWUudHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgZnJhbWUuaW5zdGFuY2UudXBkYXRlci5lbnF1ZXVlU2V0U3RhdGUoZnJhbWUuaW5zdGFuY2UsIGZyYW1lLnR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGZyYW1lLmVycm9yKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZW5kZXIkMihmcmFtZS50eXBlLCBmcmFtZS5pbnN0YW5jZSwgcXVldWUpO1xufTtcblxuZnVuY3Rpb24gX3JlZiQxKGVsdCkge1xuICByZXR1cm4gZWx0ICYmIHR5cGVvZiBlbHQgPT09IFwib2JqZWN0XCIgJiYgdHlwZU9mKGVsdCk7XG59XG5cbnZhciByZW5kZXIkMSA9IGZ1bmN0aW9uKHR5cGUsIHByb3BzLCBxdWV1ZSwgY2xpZW50UmVmVmlzaXRvciwgZWxlbWVudCkge1xuICB0cnkge1xuICAgIHZhciBub2RlID0gY2xpZW50UmVmVmlzaXRvcihlbGVtZW50KTtcbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwge30sIFtdLmNvbmNhdChub2RlID8gZ2V0Q2hpbGRyZW5BcnJheShub2RlKSA6IE9iamVjdC52YWx1ZXMocHJvcHMpLmZsYXQoSW5maW5pdHkpLmZpbHRlcihfcmVmJDEpKSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKHR5cGVvZiBlcnJvci50aGVuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlBMQVNNSUM6IEVuY291bnRlcmVkIGVycm9yIHdoZW4gcHJlLXJlbmRlcmluZyBjbGllbnQgcmVmZXJlbmNlOiBcIiArIGVycm9yKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBxdWV1ZS5wdXNoKHtcbiAgICAgIGNvbnRleHRNYXA6IGdldEN1cnJlbnRDb250ZXh0TWFwKCksXG4gICAgICBjb250ZXh0U3RvcmU6IGdldEN1cnJlbnRDb250ZXh0U3RvcmUoKSxcbiAgICAgIGVycm9yRnJhbWU6IGdldEN1cnJlbnRFcnJvckZyYW1lKCksXG4gICAgICBpZDogZ2V0Q3VycmVudElkZW50aXR5KCksXG4gICAgICBob29rOiBnZXRGaXJzdEhvb2soKSxcbiAgICAgIHRoZW5hYmxlOiBlcnJvcixcbiAgICAgIGtpbmQ6IFwiY2xpZW50LXJlZlwiLFxuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICBjbGllbnRSZWZWaXNpdG9yOiBjbGllbnRSZWZWaXNpdG9yXG4gICAgfSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbnZhciBtb3VudCA9IGZ1bmN0aW9uKHR5cGUsIHByb3BzLCBxdWV1ZSwgY2xpZW50UmVmVmlzaXRvciwgZWxlbWVudCkge1xuICBzZXRGaXJzdEhvb2sobnVsbCk7XG4gIHNldEN1cnJlbnRJZGVudGl0eShtYWtlSWRlbnRpdHkoKSk7XG4gIHJldHVybiByZW5kZXIkMSh0eXBlLCBwcm9wcywgcXVldWUsIGNsaWVudFJlZlZpc2l0b3IsIGVsZW1lbnQpO1xufTtcblxudmFyIHVwZGF0ZSQxID0gZnVuY3Rpb24ocXVldWUsIGZyYW1lKSB7XG4gIHNldEZpcnN0SG9vayhmcmFtZS5ob29rKTtcbiAgc2V0Q3VycmVudElkZW50aXR5KGZyYW1lLmlkKTtcbiAgc2V0Q3VycmVudENvbnRleHRNYXAoZnJhbWUuY29udGV4dE1hcCk7XG4gIHNldEN1cnJlbnRDb250ZXh0U3RvcmUoZnJhbWUuY29udGV4dFN0b3JlKTtcbiAgc2V0Q3VycmVudEVycm9yRnJhbWUoZnJhbWUuZXJyb3JGcmFtZSk7XG4gIHJldHVybiByZW5kZXIkMShmcmFtZS50eXBlLCBmcmFtZS5wcm9wcywgcXVldWUsIGZyYW1lLmNsaWVudFJlZlZpc2l0b3IsIGZyYW1lLmVsZW1lbnQpO1xufTtcblxudmFyIFJFQUNUX0lOVEVSTkFMUyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEIHx8IFJlYWN0Ll9fQ0xJRU5UX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERSB8fCBSZWFjdC5fX1NFUlZFUl9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREU7XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUkVBQ1RfSU5URVJOQUxTLlJlYWN0Q3VycmVudERpc3BhdGNoZXIgfHwgUkVBQ1RfSU5URVJOQUxTO1xuXG52YXIgZ2V0UmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50IHx8IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuSDtcbn07XG5cbnZhciBpbmplY3RSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gZnVuY3Rpb24obmV3RGlzcGF0Y2hlcikge1xuICBpZiAoIWlzUmVhY3QxOSgpKSB7XG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbmV3RGlzcGF0Y2hlcjtcbiAgfSBlbHNlIHtcbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLkggPSBuZXdEaXNwYXRjaGVyO1xuICB9XG59O1xuXG52YXIgU0hPVUxEX1lJRUxEID0gdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiO1xuXG52YXIgWUlFTERfQUZURVJfTVMgPSA1O1xuXG52YXIgcmVuZGVyID0gZnVuY3Rpb24odHlwZSwgcHJvcHMsIHF1ZXVlLCB2aXNpdG9yLCBjbGllbnRSZWZWaXNpdG9yLCBlbGVtZW50KSB7XG4gIGlmIChpc0NsaWVudFJlZmVyZW5jZSh0eXBlKSkge1xuICAgIHJldHVybiBtb3VudCh0eXBlLCBwcm9wcywgcXVldWUsIGNsaWVudFJlZlZpc2l0b3IsIGVsZW1lbnQpO1xuICB9XG4gIHJldHVybiBzaG91bGRDb25zdHJ1Y3QodHlwZSkgPyBtb3VudCQxKHR5cGUsIHByb3BzLCBxdWV1ZSwgdmlzaXRvciwgZWxlbWVudCkgOiBtb3VudCQyKHR5cGUsIHByb3BzLCBxdWV1ZSwgdmlzaXRvciwgZWxlbWVudCk7XG59O1xuXG52YXIgdmlzaXRFbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgcXVldWUsIHZpc2l0b3IsIGNsaWVudFJlZlZpc2l0b3IpIHtcbiAgc3dpdGNoICh0eXBlT2YoZWxlbWVudCkpIHtcbiAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgIGNhc2UgUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU6XG4gICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAge1xuICAgICAgdmFyIGZyYWdtZW50RWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICByZXR1cm4gZ2V0Q2hpbGRyZW5BcnJheShmcmFnbWVudEVsZW1lbnQucHJvcHMuY2hpbGRyZW4pO1xuICAgIH1cblxuICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgIHtcbiAgICAgIHZhciBwcm92aWRlckVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgdmFyIHJlZiA9IHByb3ZpZGVyRWxlbWVudC5wcm9wcztcbiAgICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHJlZi5jaGlsZHJlbjtcbiAgICAgIHZhciB0eXBlID0gcHJvdmlkZXJFbGVtZW50LnR5cGU7XG4gICAgICB2YXIgY29udGV4dCA9IHR5cGVvZiB0eXBlLl9jb250ZXh0ID09PSBcIm9iamVjdFwiID8gdHlwZS5fY29udGV4dCA6IHR5cGU7XG4gICAgICBzZXRDb250ZXh0VmFsdWUoY29udGV4dCwgdmFsdWUpO1xuICAgICAgcmV0dXJuIGdldENoaWxkcmVuQXJyYXkoY2hpbGRyZW4pO1xuICAgIH1cblxuICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgIHtcbiAgICAgIHZhciBjb25zdW1lckVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgdmFyIHJlZiQxID0gY29uc3VtZXJFbGVtZW50LnByb3BzO1xuICAgICAgdmFyIGNoaWxkcmVuJDEgPSByZWYkMS5jaGlsZHJlbjtcbiAgICAgIGlmICh0eXBlb2YgY2hpbGRyZW4kMSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHZhciB0eXBlJDEgPSBjb25zdW1lckVsZW1lbnQudHlwZTtcbiAgICAgICAgdmFyIGNvbnRleHQkMSA9IHR5cGVvZiB0eXBlJDEuX2NvbnRleHQgPT09IFwib2JqZWN0XCIgPyB0eXBlJDEuX2NvbnRleHQgOiB0eXBlJDE7XG4gICAgICAgIHZhciB2YWx1ZSQxID0gcmVhZENvbnRleHRWYWx1ZShjb250ZXh0JDEpO1xuICAgICAgICByZXR1cm4gZ2V0Q2hpbGRyZW5BcnJheShjaGlsZHJlbiQxKHZhbHVlJDEpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgIHtcbiAgICAgIHZhciBsYXp5RWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB2YXIgdHlwZSQyID0gbGF6eUVsZW1lbnQudHlwZTtcbiAgICAgIHZhciBjaGlsZCA9IG1vdW50JDModHlwZSQyLCBsYXp5RWxlbWVudC5wcm9wcywgcXVldWUpO1xuICAgICAgcmV0dXJuIGdldENoaWxkcmVuQXJyYXkoY2hpbGQpO1xuICAgIH1cblxuICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAge1xuICAgICAgdmFyIG1lbW9FbGVtZW50ID0gZWxlbWVudDtcbiAgICAgIHZhciByZWYkMiA9IG1lbW9FbGVtZW50LnR5cGU7XG4gICAgICB2YXIgdHlwZSQzID0gcmVmJDIudHlwZTtcbiAgICAgIHZhciBjaGlsZCQxID0gY3JlYXRlRWxlbWVudCh0eXBlJDMsIG1lbW9FbGVtZW50LnByb3BzKTtcbiAgICAgIHJldHVybiBnZXRDaGlsZHJlbkFycmF5KGNoaWxkJDEpO1xuICAgIH1cblxuICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgIHtcbiAgICAgIHZhciByZWZFbGVtZW50ID0gZWxlbWVudDtcbiAgICAgIHZhciByZWYkMyA9IHJlZkVsZW1lbnQudHlwZTtcbiAgICAgIHZhciB0eXBlJDQgPSByZWYkMy5yZW5kZXI7XG4gICAgICB2YXIgZGVmYXVsdFByb3BzID0gcmVmJDMuZGVmYXVsdFByb3BzO1xuICAgICAgdmFyIHByb3BzID0gY29tcHV0ZVByb3BzKHJlZkVsZW1lbnQucHJvcHMsIGRlZmF1bHRQcm9wcyk7XG4gICAgICB2YXIgY2hpbGQkMiA9IGNyZWF0ZUVsZW1lbnQodHlwZSQ0LCBwcm9wcyk7XG4gICAgICByZXR1cm4gZ2V0Q2hpbGRyZW5BcnJheShjaGlsZCQyKTtcbiAgICB9XG5cbiAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgIHtcbiAgICAgIHZhciBlbCA9IGVsZW1lbnQ7XG4gICAgICBpZiAodHlwZW9mIGVsLnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIGdldENoaWxkcmVuQXJyYXkoZWwucHJvcHMuY2hpbGRyZW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHVzZXJFbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdmFyIHR5cGUkNSA9IHVzZXJFbGVtZW50LnR5cGU7XG4gICAgICAgIHZhciBwcm9wcyQxID0gdXNlckVsZW1lbnQucHJvcHM7XG4gICAgICAgIHZhciBjaGlsZCQzID0gcmVuZGVyKHR5cGUkNSwgcHJvcHMkMSwgcXVldWUsIHZpc2l0b3IsIGNsaWVudFJlZlZpc2l0b3IsIHVzZXJFbGVtZW50KTtcbiAgICAgICAgcmV0dXJuIGdldENoaWxkcmVuQXJyYXkoY2hpbGQkMyk7XG4gICAgICB9XG4gICAgfVxuXG4gICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgZGVmYXVsdDpcbiAgICByZXR1cm4gW107XG4gIH1cbn07XG5cbnZhciB2aXNpdExvb3AgPSBmdW5jdGlvbih0cmF2ZXJzYWxDaGlsZHJlbiwgdHJhdmVyc2FsTWFwLCB0cmF2ZXJzYWxTdG9yZSwgdHJhdmVyc2FsRXJyb3JGcmFtZSwgcXVldWUsIHZpc2l0b3IsIGNsaWVudFJlZlZpc2l0b3IpIHtcbiAgdmFyIHByZXZEaXNwYXRjaGVyID0gZ2V0UmVhY3RDdXJyZW50RGlzcGF0Y2hlcigpO1xuICB2YXIgc3RhcnQgPSBEYXRlLm5vdygpO1xuICB0cnkge1xuICAgIGluamVjdFJlYWN0Q3VycmVudERpc3BhdGNoZXIoRGlzcGF0Y2hlcik7XG4gICAgd2hpbGUgKHRyYXZlcnNhbENoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBlbGVtZW50ID0gdHJhdmVyc2FsQ2hpbGRyZW5bdHJhdmVyc2FsQ2hpbGRyZW4ubGVuZ3RoIC0gMV0uc2hpZnQoKTtcbiAgICAgIGlmIChlbGVtZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gdmlzaXRFbGVtZW50KGVsZW1lbnQsIHF1ZXVlLCB2aXNpdG9yLCBjbGllbnRSZWZWaXNpdG9yKTtcbiAgICAgICAgdHJhdmVyc2FsQ2hpbGRyZW4ucHVzaChjaGlsZHJlbik7XG4gICAgICAgIHRyYXZlcnNhbE1hcC5wdXNoKGZsdXNoUHJldkNvbnRleHRNYXAoKSk7XG4gICAgICAgIHRyYXZlcnNhbFN0b3JlLnB1c2goZmx1c2hQcmV2Q29udGV4dFN0b3JlKCkpO1xuICAgICAgICB0cmF2ZXJzYWxFcnJvckZyYW1lLnB1c2goZ2V0Q3VycmVudEVycm9yRnJhbWUoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmF2ZXJzYWxDaGlsZHJlbi5wb3AoKTtcbiAgICAgICAgcmVzdG9yZUNvbnRleHRNYXAodHJhdmVyc2FsTWFwLnBvcCgpKTtcbiAgICAgICAgcmVzdG9yZUNvbnRleHRTdG9yZSh0cmF2ZXJzYWxTdG9yZS5wb3AoKSk7XG4gICAgICAgIHNldEN1cnJlbnRFcnJvckZyYW1lKHRyYXZlcnNhbEVycm9yRnJhbWUucG9wKCkpO1xuICAgICAgfVxuICAgICAgaWYgKFNIT1VMRF9ZSUVMRCAmJiBEYXRlLm5vdygpIC0gc3RhcnQgPiBZSUVMRF9BRlRFUl9NUykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHZhciBlcnJvckZyYW1lID0gZ2V0Q3VycmVudEVycm9yRnJhbWUoKTtcbiAgICBpZiAoIWVycm9yRnJhbWUpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBlcnJvckZyYW1lLmVycm9yID0gZXJyb3I7XG4gICAgcXVldWUudW5zaGlmdChlcnJvckZyYW1lKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZmluYWxseSB7XG4gICAgaW5qZWN0UmVhY3RDdXJyZW50RGlzcGF0Y2hlcihwcmV2RGlzcGF0Y2hlcik7XG4gIH1cbn07XG5cbnZhciBtYWtlWWllbGRGcmFtZSA9IGZ1bmN0aW9uKHRyYXZlcnNhbENoaWxkcmVuLCB0cmF2ZXJzYWxNYXAsIHRyYXZlcnNhbFN0b3JlLCB0cmF2ZXJzYWxFcnJvckZyYW1lKSB7XG4gIHJldHVybiB7XG4gICAgY29udGV4dE1hcDogZ2V0Q3VycmVudENvbnRleHRNYXAoKSxcbiAgICBjb250ZXh0U3RvcmU6IGdldEN1cnJlbnRDb250ZXh0U3RvcmUoKSxcbiAgICBlcnJvckZyYW1lOiBnZXRDdXJyZW50RXJyb3JGcmFtZSgpLFxuICAgIHRoZW5hYmxlOiBudWxsLFxuICAgIGtpbmQ6IFwiZnJhbWUueWllbGRcIixcbiAgICB0cmF2ZXJzYWxDaGlsZHJlbjogdHJhdmVyc2FsQ2hpbGRyZW4sXG4gICAgdHJhdmVyc2FsTWFwOiB0cmF2ZXJzYWxNYXAsXG4gICAgdHJhdmVyc2FsU3RvcmU6IHRyYXZlcnNhbFN0b3JlLFxuICAgIHRyYXZlcnNhbEVycm9yRnJhbWU6IHRyYXZlcnNhbEVycm9yRnJhbWVcbiAgfTtcbn07XG5cbnZhciB2aXNpdCA9IGZ1bmN0aW9uKGluaXQsIHF1ZXVlLCB2aXNpdG9yLCBjbGllbnRSZWZWaXNpdG9yKSB7XG4gIHZhciB0cmF2ZXJzYWxDaGlsZHJlbiA9IFsgaW5pdCBdO1xuICB2YXIgdHJhdmVyc2FsTWFwID0gWyBmbHVzaFByZXZDb250ZXh0TWFwKCkgXTtcbiAgdmFyIHRyYXZlcnNhbFN0b3JlID0gWyBmbHVzaFByZXZDb250ZXh0U3RvcmUoKSBdO1xuICB2YXIgdHJhdmVyc2FsRXJyb3JGcmFtZSA9IFsgZ2V0Q3VycmVudEVycm9yRnJhbWUoKSBdO1xuICB2YXIgaGFzWWllbGRlZCA9IHZpc2l0TG9vcCh0cmF2ZXJzYWxDaGlsZHJlbiwgdHJhdmVyc2FsTWFwLCB0cmF2ZXJzYWxTdG9yZSwgdHJhdmVyc2FsRXJyb3JGcmFtZSwgcXVldWUsIHZpc2l0b3IsIGNsaWVudFJlZlZpc2l0b3IpO1xuICBpZiAoaGFzWWllbGRlZCkge1xuICAgIHF1ZXVlLnVuc2hpZnQobWFrZVlpZWxkRnJhbWUodHJhdmVyc2FsQ2hpbGRyZW4sIHRyYXZlcnNhbE1hcCwgdHJhdmVyc2FsU3RvcmUsIHRyYXZlcnNhbEVycm9yRnJhbWUpKTtcbiAgfVxufTtcblxudmFyIHVwZGF0ZSA9IGZ1bmN0aW9uKGZyYW1lLCBxdWV1ZSwgdmlzaXRvciwgY2xpZW50UmVmVmlzaXRvcikge1xuICBpZiAoZnJhbWUua2luZCA9PT0gXCJmcmFtZS55aWVsZFwiKSB7XG4gICAgc2V0Q3VycmVudElkZW50aXR5KG51bGwpO1xuICAgIHNldEN1cnJlbnRDb250ZXh0TWFwKGZyYW1lLmNvbnRleHRNYXApO1xuICAgIHNldEN1cnJlbnRDb250ZXh0U3RvcmUoZnJhbWUuY29udGV4dFN0b3JlKTtcbiAgICBzZXRDdXJyZW50RXJyb3JGcmFtZShmcmFtZS5lcnJvckZyYW1lKTtcbiAgICB2YXIgaGFzWWllbGRlZCA9IHZpc2l0TG9vcChmcmFtZS50cmF2ZXJzYWxDaGlsZHJlbiwgZnJhbWUudHJhdmVyc2FsTWFwLCBmcmFtZS50cmF2ZXJzYWxTdG9yZSwgZnJhbWUudHJhdmVyc2FsRXJyb3JGcmFtZSwgcXVldWUsIHZpc2l0b3IsIGNsaWVudFJlZlZpc2l0b3IpO1xuICAgIGlmIChoYXNZaWVsZGVkKSB7XG4gICAgICBxdWV1ZS51bnNoaWZ0KG1ha2VZaWVsZEZyYW1lKGZyYW1lLnRyYXZlcnNhbENoaWxkcmVuLCBmcmFtZS50cmF2ZXJzYWxNYXAsIGZyYW1lLnRyYXZlcnNhbFN0b3JlLCBmcmFtZS50cmF2ZXJzYWxFcnJvckZyYW1lKSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IGdldFJlYWN0Q3VycmVudERpc3BhdGNoZXIoKTtcbiAgICB2YXIgY2hpbGRyZW4gPSBudWxsO1xuICAgIGluamVjdFJlYWN0Q3VycmVudERpc3BhdGNoZXIoRGlzcGF0Y2hlcik7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChmcmFtZS5raW5kID09PSBcImZyYW1lLmNsYXNzXCIpIHtcbiAgICAgICAgY2hpbGRyZW4gPSB1cGRhdGUkMihxdWV1ZSwgZnJhbWUpO1xuICAgICAgfSBlbHNlIGlmIChmcmFtZS5raW5kID09PSBcImZyYW1lLmhvb2tzXCIpIHtcbiAgICAgICAgY2hpbGRyZW4gPSB1cGRhdGUkMyhxdWV1ZSwgZnJhbWUpO1xuICAgICAgfSBlbHNlIGlmIChmcmFtZS5raW5kID09PSBcImZyYW1lLmxhenlcIikge1xuICAgICAgICBjaGlsZHJlbiA9IHVwZGF0ZSQ0KHF1ZXVlLCBmcmFtZSk7XG4gICAgICB9IGVsc2UgaWYgKGZyYW1lLmtpbmQgPT09IFwiY2xpZW50LXJlZlwiKSB7XG4gICAgICAgIGNoaWxkcmVuID0gdXBkYXRlJDEocXVldWUsIGZyYW1lKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdmFyIGVycm9yRnJhbWUgPSBnZXRDdXJyZW50RXJyb3JGcmFtZSgpO1xuICAgICAgaWYgKCFlcnJvckZyYW1lKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgZXJyb3JGcmFtZS5lcnJvciA9IGVycm9yO1xuICAgICAgcXVldWUudW5zaGlmdChlcnJvckZyYW1lKTtcbiAgICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaW5qZWN0UmVhY3RDdXJyZW50RGlzcGF0Y2hlcihwcmV2RGlzcGF0Y2hlcik7XG4gICAgfVxuICAgIHZpc2l0KGdldENoaWxkcmVuQXJyYXkoY2hpbGRyZW4pLCBxdWV1ZSwgdmlzaXRvciwgY2xpZW50UmVmVmlzaXRvcik7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9yZWYocmVzb2x2ZSwgcmVqZWN0KSB7XG4gIHNldEltbWVkaWF0ZShyZXNvbHZlKTtcbn1cblxudmFyIGZsdXNoRnJhbWVzID0gZnVuY3Rpb24ocXVldWUsIHZpc2l0b3IsIGNsaWVudFJlZlZpc2l0b3IsIHN0YXRlKSB7XG4gIHZhciBmcmFtZSA9IHF1ZXVlLnNoaWZ0KCk7XG4gIGlmICghZnJhbWUpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cbiAgaWYgKFNIT1VMRF9ZSUVMRCAmJiBmcmFtZS5raW5kID09PSBcImZyYW1lLnlpZWxkXCIpIHtcbiAgICBmcmFtZS50aGVuYWJsZSA9IG5ldyBQcm9taXNlKF9yZWYpO1xuICB9XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoZnJhbWUudGhlbmFibGUpLnRoZW4oKGZ1bmN0aW9uKCkge1xuICAgIHNldEN1cnJlbnRSZW5kZXJlclN0YXRlKHN0YXRlKTtcbiAgICB1cGRhdGUoZnJhbWUsIHF1ZXVlLCB2aXNpdG9yLCBjbGllbnRSZWZWaXNpdG9yKTtcbiAgICByZXR1cm4gZmx1c2hGcmFtZXMocXVldWUsIHZpc2l0b3IsIGNsaWVudFJlZlZpc2l0b3IsIHN0YXRlKTtcbiAgfSksIChmdW5jdGlvbihlcnJvcikge1xuICAgIGlmICghZnJhbWUuZXJyb3JGcmFtZSkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGZyYW1lLmVycm9yRnJhbWUuZXJyb3IgPSBlcnJvcjtcbiAgICB1cGRhdGUoZnJhbWUuZXJyb3JGcmFtZSwgcXVldWUsIHZpc2l0b3IsIGNsaWVudFJlZlZpc2l0b3IpO1xuICB9KSk7XG59O1xuXG52YXIgZGVmYXVsdFZpc2l0b3IgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbnZhciBydW5uaW5nUHJlcGFzc0NvdW50ID0gMDtcblxuZnVuY3Rpb24gX3JlZjIoKSB7XG4gIHJ1bm5pbmdQcmVwYXNzQ291bnQtLTtcbiAgaWYgKCFydW5uaW5nUHJlcGFzc0NvdW50KSB7XG4gICAgZGVsZXRlIGdsb2JhbFRoaXMuX19zc3JQcmVwYXNzRW52O1xuICB9XG59XG5cbnZhciByZW5kZXJQcmVwYXNzID0gZnVuY3Rpb24oZWxlbWVudCwgdmlzaXRvciwgY2xpZW50UmVmVmlzaXRvcikge1xuICBpZiAoIXZpc2l0b3IpIHtcbiAgICB2aXNpdG9yID0gZGVmYXVsdFZpc2l0b3I7XG4gIH1cbiAgaWYgKCFjbGllbnRSZWZWaXNpdG9yKSB7XG4gICAgY2xpZW50UmVmVmlzaXRvciA9IGRlZmF1bHRWaXNpdG9yO1xuICB9XG4gIHZhciBxdWV1ZSA9IFtdO1xuICB2YXIgc3RhdGUgPSBpbml0UmVuZGVyZXJTdGF0ZSgpO1xuICBzZXRDdXJyZW50Q29udGV4dE1hcCh7fSk7XG4gIHNldEN1cnJlbnRDb250ZXh0U3RvcmUobmV3IE1hcCk7XG4gIHNldEN1cnJlbnRFcnJvckZyYW1lKG51bGwpO1xuICB0cnkge1xuICAgIHJ1bm5pbmdQcmVwYXNzQ291bnQrKztcbiAgICBnbG9iYWxUaGlzLl9fc3NyUHJlcGFzc0VudiA9IHtcbiAgICAgIHJlYWRDb250ZXh0VmFsdWU6IHJlYWRDb250ZXh0VmFsdWUsXG4gICAgICBzZXRDb250ZXh0VmFsdWU6IHNldENvbnRleHRWYWx1ZVxuICAgIH07XG4gICAgdmlzaXQoZ2V0Q2hpbGRyZW5BcnJheShlbGVtZW50KSwgcXVldWUsIHZpc2l0b3IsIGNsaWVudFJlZlZpc2l0b3IpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJ1bm5pbmdQcmVwYXNzQ291bnQtLTtcbiAgICBpZiAoIXJ1bm5pbmdQcmVwYXNzQ291bnQpIHtcbiAgICAgIGRlbGV0ZSBnbG9iYWxUaGlzLl9fc3NyUHJlcGFzc0VudjtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgfVxuICByZXR1cm4gZmx1c2hGcmFtZXMocXVldWUsIHZpc2l0b3IsIGNsaWVudFJlZlZpc2l0b3IsIHN0YXRlKS5maW5hbGx5KF9yZWYyKTtcbn07XG5cbmV4cG9ydCB7IHJlbmRlclByZXBhc3MgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVhY3Qtc3NyLXByZXBhc3MuZXMuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@plasmicapp/react-ssr-prepass/dist/react-ssr-prepass.es.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/AuthAdminApi.js":
/*!********************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/AuthAdminApi.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _GoTrueAdminApi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GoTrueAdminApi */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js\");\n\nconst AuthAdminApi = _GoTrueAdminApi__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AuthAdminApi);\n//# sourceMappingURL=AuthAdminApi.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9BdXRoQWRtaW5BcGkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBOEM7QUFDOUMscUJBQXFCLHVEQUFjO0FBQ25DLGlFQUFlLFlBQVksRUFBQztBQUM1QiIsInNvdXJjZXMiOlsiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvV29uZGVyVml0ZS1mcm9udGVuZC9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvQXV0aEFkbWluQXBpLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBHb1RydWVBZG1pbkFwaSBmcm9tICcuL0dvVHJ1ZUFkbWluQXBpJztcbmNvbnN0IEF1dGhBZG1pbkFwaSA9IEdvVHJ1ZUFkbWluQXBpO1xuZXhwb3J0IGRlZmF1bHQgQXV0aEFkbWluQXBpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXV0aEFkbWluQXBpLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/AuthAdminApi.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/AuthClient.js":
/*!******************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/AuthClient.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _GoTrueClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GoTrueClient */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/GoTrueClient.js\");\n\nconst AuthClient = _GoTrueClient__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AuthClient);\n//# sourceMappingURL=AuthClient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9BdXRoQ2xpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTBDO0FBQzFDLG1CQUFtQixxREFBWTtBQUMvQixpRUFBZSxVQUFVLEVBQUM7QUFDMUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL1dvbmRlclZpdGUtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL2Rpc3QvbW9kdWxlL0F1dGhDbGllbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEdvVHJ1ZUNsaWVudCBmcm9tICcuL0dvVHJ1ZUNsaWVudCc7XG5jb25zdCBBdXRoQ2xpZW50ID0gR29UcnVlQ2xpZW50O1xuZXhwb3J0IGRlZmF1bHQgQXV0aENsaWVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUF1dGhDbGllbnQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/AuthClient.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ GoTrueAdminApi)\n/* harmony export */ });\n/* harmony import */ var _lib_fetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/fetch */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/fetch.js\");\n/* harmony import */ var _lib_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/helpers */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/helpers.js\");\n/* harmony import */ var _lib_errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/errors */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/errors.js\");\nvar __rest = (undefined && undefined.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\n\n\n\nclass GoTrueAdminApi {\n    constructor({ url = '', headers = {}, fetch, }) {\n        this.url = url;\n        this.headers = headers;\n        this.fetch = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_1__.resolveFetch)(fetch);\n        this.mfa = {\n            listFactors: this._listFactors.bind(this),\n            deleteFactor: this._deleteFactor.bind(this),\n        };\n    }\n    /**\n     * Removes a logged-in session.\n     * @param jwt A valid, logged-in JWT.\n     * @param scope The logout sope.\n     */\n    async signOut(jwt, scope = 'global') {\n        try {\n            await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, 'POST', `${this.url}/logout?scope=${scope}`, {\n                headers: this.headers,\n                jwt,\n                noResolveJson: true,\n            });\n            return { data: null, error: null };\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return { data: null, error };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Sends an invite link to an email address.\n     * @param email The email address of the user.\n     * @param options Additional options to be included when inviting.\n     */\n    async inviteUserByEmail(email, options = {}) {\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, 'POST', `${this.url}/invite`, {\n                body: { email, data: options.data },\n                headers: this.headers,\n                redirectTo: options.redirectTo,\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._userResponse,\n            });\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return { data: { user: null }, error };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Generates email links and OTPs to be sent via a custom email provider.\n     * @param email The user's email.\n     * @param options.password User password. For signup only.\n     * @param options.data Optional user metadata. For signup only.\n     * @param options.redirectTo The redirect url which should be appended to the generated link\n     */\n    async generateLink(params) {\n        try {\n            const { options } = params, rest = __rest(params, [\"options\"]);\n            const body = Object.assign(Object.assign({}, rest), options);\n            if ('newEmail' in rest) {\n                // replace newEmail with new_email in request body\n                body.new_email = rest === null || rest === void 0 ? void 0 : rest.newEmail;\n                delete body['newEmail'];\n            }\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, 'POST', `${this.url}/admin/generate_link`, {\n                body: body,\n                headers: this.headers,\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._generateLinkResponse,\n                redirectTo: options === null || options === void 0 ? void 0 : options.redirectTo,\n            });\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        properties: null,\n                        user: null,\n                    },\n                    error,\n                };\n            }\n            throw error;\n        }\n    }\n    // User Admin API\n    /**\n     * Creates a new user.\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */\n    async createUser(attributes) {\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, 'POST', `${this.url}/admin/users`, {\n                body: attributes,\n                headers: this.headers,\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._userResponse,\n            });\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return { data: { user: null }, error };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Get a list of users.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     * @param params An object which supports `page` and `perPage` as numbers, to alter the paginated results.\n     */\n    async listUsers(params) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        try {\n            const pagination = { nextPage: null, lastPage: 0, total: 0 };\n            const response = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, 'GET', `${this.url}/admin/users`, {\n                headers: this.headers,\n                noResolveJson: true,\n                query: {\n                    page: (_b = (_a = params === null || params === void 0 ? void 0 : params.page) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : '',\n                    per_page: (_d = (_c = params === null || params === void 0 ? void 0 : params.perPage) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : '',\n                },\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._noResolveJsonResponse,\n            });\n            if (response.error)\n                throw response.error;\n            const users = await response.json();\n            const total = (_e = response.headers.get('x-total-count')) !== null && _e !== void 0 ? _e : 0;\n            const links = (_g = (_f = response.headers.get('link')) === null || _f === void 0 ? void 0 : _f.split(',')) !== null && _g !== void 0 ? _g : [];\n            if (links.length > 0) {\n                links.forEach((link) => {\n                    const page = parseInt(link.split(';')[0].split('=')[1].substring(0, 1));\n                    const rel = JSON.parse(link.split(';')[1].split('=')[1]);\n                    pagination[`${rel}Page`] = page;\n                });\n                pagination.total = parseInt(total);\n            }\n            return { data: Object.assign(Object.assign({}, users), pagination), error: null };\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return { data: { users: [] }, error };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Get user by id.\n     *\n     * @param uid The user's unique identifier\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */\n    async getUserById(uid) {\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, 'GET', `${this.url}/admin/users/${uid}`, {\n                headers: this.headers,\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._userResponse,\n            });\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return { data: { user: null }, error };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Updates the user data.\n     *\n     * @param attributes The data you want to update.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */\n    async updateUserById(uid, attributes) {\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, 'PUT', `${this.url}/admin/users/${uid}`, {\n                body: attributes,\n                headers: this.headers,\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._userResponse,\n            });\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return { data: { user: null }, error };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Delete a user. Requires a `service_role` key.\n     *\n     * @param id The user id you want to remove.\n     * @param shouldSoftDelete If true, then the user will be soft-deleted from the auth schema. Soft deletion allows user identification from the hashed user ID but is not reversible.\n     * Defaults to false for backward compatibility.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */\n    async deleteUser(id, shouldSoftDelete = false) {\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, 'DELETE', `${this.url}/admin/users/${id}`, {\n                headers: this.headers,\n                body: {\n                    should_soft_delete: shouldSoftDelete,\n                },\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._userResponse,\n            });\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return { data: { user: null }, error };\n            }\n            throw error;\n        }\n    }\n    async _listFactors(params) {\n        try {\n            const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, 'GET', `${this.url}/admin/users/${params.userId}/factors`, {\n                headers: this.headers,\n                xform: (factors) => {\n                    return { data: { factors }, error: null };\n                },\n            });\n            return { data, error };\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return { data: null, error };\n            }\n            throw error;\n        }\n    }\n    async _deleteFactor(params) {\n        try {\n            const data = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, 'DELETE', `${this.url}/admin/users/${params.userId}/factors/${params.id}`, {\n                headers: this.headers,\n            });\n            return { data, error: null };\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return { data: null, error };\n            }\n            throw error;\n        }\n    }\n}\n//# sourceMappingURL=GoTrueAdminApi.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9Hb1RydWVBZG1pbkFwaS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUEsY0FBYyxTQUFJLElBQUksU0FBSTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxjQUFjO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDc0c7QUFDekQ7QUFDRjtBQUM1QjtBQUNmLGtCQUFrQixzQkFBc0IsVUFBVTtBQUNsRDtBQUNBO0FBQ0EscUJBQXFCLDBEQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvREFBUSx3QkFBd0IsU0FBUyxnQkFBZ0IsTUFBTTtBQUNqRjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxnQkFBZ0Isd0RBQVc7QUFDM0IseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBLHlCQUF5QixvREFBUSx3QkFBd0IsU0FBUztBQUNsRSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0E7QUFDQSx1QkFBdUIscURBQWE7QUFDcEMsYUFBYTtBQUNiO0FBQ0E7QUFDQSxnQkFBZ0Isd0RBQVc7QUFDM0IseUJBQXlCLFFBQVEsWUFBWTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG9EQUFRLHdCQUF3QixTQUFTO0FBQ2xFO0FBQ0E7QUFDQSx1QkFBdUIsNkRBQXFCO0FBQzVDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxnQkFBZ0Isd0RBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsb0RBQVEsd0JBQXdCLFNBQVM7QUFDbEU7QUFDQTtBQUNBLHVCQUF1QixxREFBYTtBQUNwQyxhQUFhO0FBQ2I7QUFDQTtBQUNBLGdCQUFnQix3REFBVztBQUMzQix5QkFBeUIsUUFBUSxZQUFZO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLG1DQUFtQyxvREFBUSx1QkFBdUIsU0FBUztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLHVCQUF1Qiw4REFBc0I7QUFDN0MsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZELHdEQUF3RDtBQUN4RCxrQ0FBa0MsSUFBSTtBQUN0QyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLHFCQUFxQixvQ0FBb0M7QUFDekQ7QUFDQTtBQUNBLGdCQUFnQix3REFBVztBQUMzQix5QkFBeUIsUUFBUSxXQUFXO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG9EQUFRLHVCQUF1QixTQUFTLGVBQWUsSUFBSTtBQUNwRjtBQUNBLHVCQUF1QixxREFBYTtBQUNwQyxhQUFhO0FBQ2I7QUFDQTtBQUNBLGdCQUFnQix3REFBVztBQUMzQix5QkFBeUIsUUFBUSxZQUFZO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG9EQUFRLHVCQUF1QixTQUFTLGVBQWUsSUFBSTtBQUNwRjtBQUNBO0FBQ0EsdUJBQXVCLHFEQUFhO0FBQ3BDLGFBQWE7QUFDYjtBQUNBO0FBQ0EsZ0JBQWdCLHdEQUFXO0FBQzNCLHlCQUF5QixRQUFRLFlBQVk7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG9EQUFRLDBCQUEwQixTQUFTLGVBQWUsR0FBRztBQUN0RjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsdUJBQXVCLHFEQUFhO0FBQ3BDLGFBQWE7QUFDYjtBQUNBO0FBQ0EsZ0JBQWdCLHdEQUFXO0FBQzNCLHlCQUF5QixRQUFRLFlBQVk7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWMsUUFBUSxvREFBUSx1QkFBdUIsU0FBUyxlQUFlLGNBQWM7QUFDL0c7QUFDQTtBQUNBLDZCQUE2QixRQUFRLFNBQVM7QUFDOUMsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGdCQUFnQix3REFBVztBQUMzQix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG9EQUFRLDBCQUEwQixTQUFTLGVBQWUsY0FBYyxXQUFXLFVBQVU7QUFDNUg7QUFDQSxhQUFhO0FBQ2IscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxnQkFBZ0Isd0RBQVc7QUFDM0IseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvV29uZGVyVml0ZS1mcm9udGVuZC9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvR29UcnVlQWRtaW5BcGkuanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fcmVzdCA9ICh0aGlzICYmIHRoaXMuX19yZXN0KSB8fCBmdW5jdGlvbiAocywgZSkge1xuICAgIHZhciB0ID0ge307XG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHQ7XG59O1xuaW1wb3J0IHsgX2dlbmVyYXRlTGlua1Jlc3BvbnNlLCBfbm9SZXNvbHZlSnNvblJlc3BvbnNlLCBfcmVxdWVzdCwgX3VzZXJSZXNwb25zZSwgfSBmcm9tICcuL2xpYi9mZXRjaCc7XG5pbXBvcnQgeyByZXNvbHZlRmV0Y2ggfSBmcm9tICcuL2xpYi9oZWxwZXJzJztcbmltcG9ydCB7IGlzQXV0aEVycm9yIH0gZnJvbSAnLi9saWIvZXJyb3JzJztcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdvVHJ1ZUFkbWluQXBpIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHVybCA9ICcnLCBoZWFkZXJzID0ge30sIGZldGNoLCB9KSB7XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgICAgICB0aGlzLmZldGNoID0gcmVzb2x2ZUZldGNoKGZldGNoKTtcbiAgICAgICAgdGhpcy5tZmEgPSB7XG4gICAgICAgICAgICBsaXN0RmFjdG9yczogdGhpcy5fbGlzdEZhY3RvcnMuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGRlbGV0ZUZhY3RvcjogdGhpcy5fZGVsZXRlRmFjdG9yLmJpbmQodGhpcyksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBsb2dnZWQtaW4gc2Vzc2lvbi5cbiAgICAgKiBAcGFyYW0gand0IEEgdmFsaWQsIGxvZ2dlZC1pbiBKV1QuXG4gICAgICogQHBhcmFtIHNjb3BlIFRoZSBsb2dvdXQgc29wZS5cbiAgICAgKi9cbiAgICBhc3luYyBzaWduT3V0KGp3dCwgc2NvcGUgPSAnZ2xvYmFsJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vbG9nb3V0P3Njb3BlPSR7c2NvcGV9YCwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBqd3QsXG4gICAgICAgICAgICAgICAgbm9SZXNvbHZlSnNvbjogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYW4gaW52aXRlIGxpbmsgdG8gYW4gZW1haWwgYWRkcmVzcy5cbiAgICAgKiBAcGFyYW0gZW1haWwgVGhlIGVtYWlsIGFkZHJlc3Mgb2YgdGhlIHVzZXIuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zIHRvIGJlIGluY2x1ZGVkIHdoZW4gaW52aXRpbmcuXG4gICAgICovXG4gICAgYXN5bmMgaW52aXRlVXNlckJ5RW1haWwoZW1haWwsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L2ludml0ZWAsIHtcbiAgICAgICAgICAgICAgICBib2R5OiB7IGVtYWlsLCBkYXRhOiBvcHRpb25zLmRhdGEgfSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgcmVkaXJlY3RUbzogb3B0aW9ucy5yZWRpcmVjdFRvLFxuICAgICAgICAgICAgICAgIHhmb3JtOiBfdXNlclJlc3BvbnNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgZW1haWwgbGlua3MgYW5kIE9UUHMgdG8gYmUgc2VudCB2aWEgYSBjdXN0b20gZW1haWwgcHJvdmlkZXIuXG4gICAgICogQHBhcmFtIGVtYWlsIFRoZSB1c2VyJ3MgZW1haWwuXG4gICAgICogQHBhcmFtIG9wdGlvbnMucGFzc3dvcmQgVXNlciBwYXNzd29yZC4gRm9yIHNpZ251cCBvbmx5LlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmRhdGEgT3B0aW9uYWwgdXNlciBtZXRhZGF0YS4gRm9yIHNpZ251cCBvbmx5LlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnJlZGlyZWN0VG8gVGhlIHJlZGlyZWN0IHVybCB3aGljaCBzaG91bGQgYmUgYXBwZW5kZWQgdG8gdGhlIGdlbmVyYXRlZCBsaW5rXG4gICAgICovXG4gICAgYXN5bmMgZ2VuZXJhdGVMaW5rKHBhcmFtcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBvcHRpb25zIH0gPSBwYXJhbXMsIHJlc3QgPSBfX3Jlc3QocGFyYW1zLCBbXCJvcHRpb25zXCJdKTtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlc3QpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmICgnbmV3RW1haWwnIGluIHJlc3QpIHtcbiAgICAgICAgICAgICAgICAvLyByZXBsYWNlIG5ld0VtYWlsIHdpdGggbmV3X2VtYWlsIGluIHJlcXVlc3QgYm9keVxuICAgICAgICAgICAgICAgIGJvZHkubmV3X2VtYWlsID0gcmVzdCA9PT0gbnVsbCB8fCByZXN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXN0Lm5ld0VtYWlsO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBib2R5WyduZXdFbWFpbCddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L2FkbWluL2dlbmVyYXRlX2xpbmtgLCB7XG4gICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgeGZvcm06IF9nZW5lcmF0ZUxpbmtSZXNwb25zZSxcbiAgICAgICAgICAgICAgICByZWRpcmVjdFRvOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucmVkaXJlY3RUbyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VyOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVXNlciBBZG1pbiBBUElcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHVzZXIuXG4gICAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gYSBzZXJ2ZXIuIE5ldmVyIGV4cG9zZSB5b3VyIGBzZXJ2aWNlX3JvbGVgIGtleSBpbiB0aGUgYnJvd3Nlci5cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVVc2VyKGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9hZG1pbi91c2Vyc2AsIHtcbiAgICAgICAgICAgICAgICBib2R5OiBhdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICB4Zm9ybTogX3VzZXJSZXNwb25zZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGEgbGlzdCBvZiB1c2Vycy5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIGEgc2VydmVyLiBOZXZlciBleHBvc2UgeW91ciBgc2VydmljZV9yb2xlYCBrZXkgaW4gdGhlIGJyb3dzZXIuXG4gICAgICogQHBhcmFtIHBhcmFtcyBBbiBvYmplY3Qgd2hpY2ggc3VwcG9ydHMgYHBhZ2VgIGFuZCBgcGVyUGFnZWAgYXMgbnVtYmVycywgdG8gYWx0ZXIgdGhlIHBhZ2luYXRlZCByZXN1bHRzLlxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RVc2VycyhwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcGFnaW5hdGlvbiA9IHsgbmV4dFBhZ2U6IG51bGwsIGxhc3RQYWdlOiAwLCB0b3RhbDogMCB9O1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnR0VUJywgYCR7dGhpcy51cmx9L2FkbWluL3VzZXJzYCwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBub1Jlc29sdmVKc29uOiB0cnVlLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgICAgICAgICAgIHBhZ2U6IChfYiA9IChfYSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5wYWdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9TdHJpbmcoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJycsXG4gICAgICAgICAgICAgICAgICAgIHBlcl9wYWdlOiAoX2QgPSAoX2MgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMucGVyUGFnZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnRvU3RyaW5nKCkpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6ICcnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgeGZvcm06IF9ub1Jlc29sdmVKc29uUmVzcG9uc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5lcnJvcilcbiAgICAgICAgICAgICAgICB0aHJvdyByZXNwb25zZS5lcnJvcjtcbiAgICAgICAgICAgIGNvbnN0IHVzZXJzID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgY29uc3QgdG90YWwgPSAoX2UgPSByZXNwb25zZS5oZWFkZXJzLmdldCgneC10b3RhbC1jb3VudCcpKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiAwO1xuICAgICAgICAgICAgY29uc3QgbGlua3MgPSAoX2cgPSAoX2YgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnbGluaycpKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Yuc3BsaXQoJywnKSkgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogW107XG4gICAgICAgICAgICBpZiAobGlua3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGxpbmtzLmZvckVhY2goKGxpbmspID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFnZSA9IHBhcnNlSW50KGxpbmsuc3BsaXQoJzsnKVswXS5zcGxpdCgnPScpWzFdLnN1YnN0cmluZygwLCAxKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbCA9IEpTT04ucGFyc2UobGluay5zcGxpdCgnOycpWzFdLnNwbGl0KCc9JylbMV0pO1xuICAgICAgICAgICAgICAgICAgICBwYWdpbmF0aW9uW2Ake3JlbH1QYWdlYF0gPSBwYWdlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHBhZ2luYXRpb24udG90YWwgPSBwYXJzZUludCh0b3RhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHVzZXJzKSwgcGFnaW5hdGlvbiksIGVycm9yOiBudWxsIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyczogW10gfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB1c2VyIGJ5IGlkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHVpZCBUaGUgdXNlcidzIHVuaXF1ZSBpZGVudGlmaWVyXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBhIHNlcnZlci4gTmV2ZXIgZXhwb3NlIHlvdXIgYHNlcnZpY2Vfcm9sZWAga2V5IGluIHRoZSBicm93c2VyLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFVzZXJCeUlkKHVpZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdHRVQnLCBgJHt0aGlzLnVybH0vYWRtaW4vdXNlcnMvJHt1aWR9YCwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICB4Zm9ybTogX3VzZXJSZXNwb25zZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgdXNlciBkYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIGF0dHJpYnV0ZXMgVGhlIGRhdGEgeW91IHdhbnQgdG8gdXBkYXRlLlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gYSBzZXJ2ZXIuIE5ldmVyIGV4cG9zZSB5b3VyIGBzZXJ2aWNlX3JvbGVgIGtleSBpbiB0aGUgYnJvd3Nlci5cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVVc2VyQnlJZCh1aWQsIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUFVUJywgYCR7dGhpcy51cmx9L2FkbWluL3VzZXJzLyR7dWlkfWAsIHtcbiAgICAgICAgICAgICAgICBib2R5OiBhdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICB4Zm9ybTogX3VzZXJSZXNwb25zZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlIGEgdXNlci4gUmVxdWlyZXMgYSBgc2VydmljZV9yb2xlYCBrZXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWQgVGhlIHVzZXIgaWQgeW91IHdhbnQgdG8gcmVtb3ZlLlxuICAgICAqIEBwYXJhbSBzaG91bGRTb2Z0RGVsZXRlIElmIHRydWUsIHRoZW4gdGhlIHVzZXIgd2lsbCBiZSBzb2Z0LWRlbGV0ZWQgZnJvbSB0aGUgYXV0aCBzY2hlbWEuIFNvZnQgZGVsZXRpb24gYWxsb3dzIHVzZXIgaWRlbnRpZmljYXRpb24gZnJvbSB0aGUgaGFzaGVkIHVzZXIgSUQgYnV0IGlzIG5vdCByZXZlcnNpYmxlLlxuICAgICAqIERlZmF1bHRzIHRvIGZhbHNlIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gYSBzZXJ2ZXIuIE5ldmVyIGV4cG9zZSB5b3VyIGBzZXJ2aWNlX3JvbGVgIGtleSBpbiB0aGUgYnJvd3Nlci5cbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGVVc2VyKGlkLCBzaG91bGRTb2Z0RGVsZXRlID0gZmFsc2UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnREVMRVRFJywgYCR7dGhpcy51cmx9L2FkbWluL3VzZXJzLyR7aWR9YCwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgICAgIHNob3VsZF9zb2Z0X2RlbGV0ZTogc2hvdWxkU29mdERlbGV0ZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHhmb3JtOiBfdXNlclJlc3BvbnNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfbGlzdEZhY3RvcnMocGFyYW1zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnR0VUJywgYCR7dGhpcy51cmx9L2FkbWluL3VzZXJzLyR7cGFyYW1zLnVzZXJJZH0vZmFjdG9yc2AsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgeGZvcm06IChmYWN0b3JzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgZmFjdG9ycyB9LCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF9kZWxldGVGYWN0b3IocGFyYW1zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0RFTEVURScsIGAke3RoaXMudXJsfS9hZG1pbi91c2Vycy8ke3BhcmFtcy51c2VySWR9L2ZhY3RvcnMvJHtwYXJhbXMuaWR9YCwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Hb1RydWVBZG1pbkFwaS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/GoTrueClient.js":
/*!********************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/GoTrueClient.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ GoTrueClient)\n/* harmony export */ });\n/* harmony import */ var _GoTrueAdminApi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GoTrueAdminApi */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js\");\n/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/constants */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/constants.js\");\n/* harmony import */ var _lib_errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/errors */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/errors.js\");\n/* harmony import */ var _lib_fetch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/fetch */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/fetch.js\");\n/* harmony import */ var _lib_helpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/helpers */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/helpers.js\");\n/* harmony import */ var _lib_local_storage__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/local-storage */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/local-storage.js\");\n/* harmony import */ var _lib_polyfills__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lib/polyfills */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/polyfills.js\");\n/* harmony import */ var _lib_version__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lib/version */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/version.js\");\n/* harmony import */ var _lib_locks__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./lib/locks */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/locks.js\");\n\n\n\n\n\n\n\n\n\n(0,_lib_polyfills__WEBPACK_IMPORTED_MODULE_6__.polyfillGlobalThis)(); // Make \"globalThis\" available\nconst DEFAULT_OPTIONS = {\n    url: _lib_constants__WEBPACK_IMPORTED_MODULE_1__.GOTRUE_URL,\n    storageKey: _lib_constants__WEBPACK_IMPORTED_MODULE_1__.STORAGE_KEY,\n    autoRefreshToken: true,\n    persistSession: true,\n    detectSessionInUrl: true,\n    headers: _lib_constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_HEADERS,\n    flowType: 'implicit',\n    debug: false,\n    hasCustomAuthorizationHeader: false,\n};\n/** Current session will be checked for refresh at this interval. */\nconst AUTO_REFRESH_TICK_DURATION = 30 * 1000;\n/**\n * A token refresh will be attempted this many ticks before the current session expires. */\nconst AUTO_REFRESH_TICK_THRESHOLD = 3;\nasync function lockNoOp(name, acquireTimeout, fn) {\n    return await fn();\n}\nclass GoTrueClient {\n    /**\n     * Create a new client for use in the browser.\n     */\n    constructor(options) {\n        var _a, _b;\n        this.memoryStorage = null;\n        this.stateChangeEmitters = new Map();\n        this.autoRefreshTicker = null;\n        this.visibilityChangedCallback = null;\n        this.refreshingDeferred = null;\n        /**\n         * Keeps track of the async client initialization.\n         * When null or not yet resolved the auth state is `unknown`\n         * Once resolved the the auth state is known and it's save to call any further client methods.\n         * Keep extra care to never reject or throw uncaught errors\n         */\n        this.initializePromise = null;\n        this.detectSessionInUrl = true;\n        this.hasCustomAuthorizationHeader = false;\n        this.suppressGetSessionWarning = false;\n        this.lockAcquired = false;\n        this.pendingInLock = [];\n        /**\n         * Used to broadcast state change events to other tabs listening.\n         */\n        this.broadcastChannel = null;\n        this.logger = console.log;\n        this.instanceID = GoTrueClient.nextInstanceID;\n        GoTrueClient.nextInstanceID += 1;\n        if (this.instanceID > 0 && (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)()) {\n            console.warn('Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.');\n        }\n        const settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);\n        this.logDebugMessages = !!settings.debug;\n        if (typeof settings.debug === 'function') {\n            this.logger = settings.debug;\n        }\n        this.persistSession = settings.persistSession;\n        this.storageKey = settings.storageKey;\n        this.autoRefreshToken = settings.autoRefreshToken;\n        this.admin = new _GoTrueAdminApi__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n            url: settings.url,\n            headers: settings.headers,\n            fetch: settings.fetch,\n        });\n        this.url = settings.url;\n        this.headers = settings.headers;\n        this.fetch = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.resolveFetch)(settings.fetch);\n        this.lock = settings.lock || lockNoOp;\n        this.detectSessionInUrl = settings.detectSessionInUrl;\n        this.flowType = settings.flowType;\n        this.hasCustomAuthorizationHeader = settings.hasCustomAuthorizationHeader;\n        if (settings.lock) {\n            this.lock = settings.lock;\n        }\n        else if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && ((_a = globalThis === null || globalThis === void 0 ? void 0 : globalThis.navigator) === null || _a === void 0 ? void 0 : _a.locks)) {\n            this.lock = _lib_locks__WEBPACK_IMPORTED_MODULE_8__.navigatorLock;\n        }\n        else {\n            this.lock = lockNoOp;\n        }\n        this.mfa = {\n            verify: this._verify.bind(this),\n            enroll: this._enroll.bind(this),\n            unenroll: this._unenroll.bind(this),\n            challenge: this._challenge.bind(this),\n            listFactors: this._listFactors.bind(this),\n            challengeAndVerify: this._challengeAndVerify.bind(this),\n            getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this),\n        };\n        if (this.persistSession) {\n            if (settings.storage) {\n                this.storage = settings.storage;\n            }\n            else {\n                if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.supportsLocalStorage)()) {\n                    this.storage = _lib_local_storage__WEBPACK_IMPORTED_MODULE_5__.localStorageAdapter;\n                }\n                else {\n                    this.memoryStorage = {};\n                    this.storage = (0,_lib_local_storage__WEBPACK_IMPORTED_MODULE_5__.memoryLocalStorageAdapter)(this.memoryStorage);\n                }\n            }\n        }\n        else {\n            this.memoryStorage = {};\n            this.storage = (0,_lib_local_storage__WEBPACK_IMPORTED_MODULE_5__.memoryLocalStorageAdapter)(this.memoryStorage);\n        }\n        if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {\n            try {\n                this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey);\n            }\n            catch (e) {\n                console.error('Failed to create a new BroadcastChannel, multi-tab state changes will not be available', e);\n            }\n            (_b = this.broadcastChannel) === null || _b === void 0 ? void 0 : _b.addEventListener('message', async (event) => {\n                this._debug('received broadcast notification from other tab or client', event);\n                await this._notifyAllSubscribers(event.data.event, event.data.session, false); // broadcast = false so we don't get an endless loop of messages\n            });\n        }\n        this.initialize();\n    }\n    _debug(...args) {\n        if (this.logDebugMessages) {\n            this.logger(`GoTrueClient@${this.instanceID} (${_lib_version__WEBPACK_IMPORTED_MODULE_7__.version}) ${new Date().toISOString()}`, ...args);\n        }\n        return this;\n    }\n    /**\n     * Initializes the client session either from the url or from storage.\n     * This method is automatically called when instantiating the client, but should also be called\n     * manually when checking for an error from an auth redirect (oauth, magiclink, password recovery, etc).\n     */\n    async initialize() {\n        if (this.initializePromise) {\n            return await this.initializePromise;\n        }\n        this.initializePromise = (async () => {\n            return await this._acquireLock(-1, async () => {\n                return await this._initialize();\n            });\n        })();\n        return await this.initializePromise;\n    }\n    /**\n     * IMPORTANT:\n     * 1. Never throw in this method, as it is called from the constructor\n     * 2. Never return a session from this method as it would be cached over\n     *    the whole lifetime of the client\n     */\n    async _initialize() {\n        var _a;\n        try {\n            const params = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.parseParametersFromURL)(window.location.href);\n            let callbackUrlType = 'none';\n            if (this._isImplicitGrantCallback(params)) {\n                callbackUrlType = 'implicit';\n            }\n            else if (await this._isPKCECallback(params)) {\n                callbackUrlType = 'pkce';\n            }\n            /**\n             * Attempt to get the session from the URL only if these conditions are fulfilled\n             *\n             * Note: If the URL isn't one of the callback url types (implicit or pkce),\n             * then there could be an existing session so we don't want to prematurely remove it\n             */\n            if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && this.detectSessionInUrl && callbackUrlType !== 'none') {\n                const { data, error } = await this._getSessionFromURL(params, callbackUrlType);\n                if (error) {\n                    this._debug('#_initialize()', 'error detecting session from URL', error);\n                    if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthImplicitGrantRedirectError)(error)) {\n                        const errorCode = (_a = error.details) === null || _a === void 0 ? void 0 : _a.code;\n                        if (errorCode === 'identity_already_exists' ||\n                            errorCode === 'identity_not_found' ||\n                            errorCode === 'single_identity_not_deletable') {\n                            return { error };\n                        }\n                    }\n                    // failed login attempt via url,\n                    // remove old session as in verifyOtp, signUp and signInWith*\n                    await this._removeSession();\n                    return { error };\n                }\n                const { session, redirectType } = data;\n                this._debug('#_initialize()', 'detected session in URL', session, 'redirect type', redirectType);\n                await this._saveSession(session);\n                setTimeout(async () => {\n                    if (redirectType === 'recovery') {\n                        await this._notifyAllSubscribers('PASSWORD_RECOVERY', session);\n                    }\n                    else {\n                        await this._notifyAllSubscribers('SIGNED_IN', session);\n                    }\n                }, 0);\n                return { error: null };\n            }\n            // no login attempt via callback url try to recover session from storage\n            await this._recoverAndRefresh();\n            return { error: null };\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return { error };\n            }\n            return {\n                error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthUnknownError('Unexpected error during initialization', error),\n            };\n        }\n        finally {\n            await this._handleVisibilityChange();\n            this._debug('#_initialize()', 'end');\n        }\n    }\n    /**\n     * Creates a new anonymous user.\n     *\n     * @returns A session where the is_anonymous claim in the access token JWT set to true\n     */\n    async signInAnonymously(credentials) {\n        var _a, _b, _c;\n        try {\n            const res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', `${this.url}/signup`, {\n                headers: this.headers,\n                body: {\n                    data: (_b = (_a = credentials === null || credentials === void 0 ? void 0 : credentials.options) === null || _a === void 0 ? void 0 : _a.data) !== null && _b !== void 0 ? _b : {},\n                    gotrue_meta_security: { captcha_token: (_c = credentials === null || credentials === void 0 ? void 0 : credentials.options) === null || _c === void 0 ? void 0 : _c.captchaToken },\n                },\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse,\n            });\n            const { data, error } = res;\n            if (error || !data) {\n                return { data: { user: null, session: null }, error: error };\n            }\n            const session = data.session;\n            const user = data.user;\n            if (data.session) {\n                await this._saveSession(data.session);\n                await this._notifyAllSubscribers('SIGNED_IN', session);\n            }\n            return { data: { user, session }, error: null };\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return { data: { user: null, session: null }, error };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Creates a new user.\n     *\n     * Be aware that if a user account exists in the system you may get back an\n     * error message that attempts to hide this information from the user.\n     * This method has support for PKCE via email signups. The PKCE flow cannot be used when autoconfirm is enabled.\n     *\n     * @returns A logged-in session if the server has \"autoconfirm\" ON\n     * @returns A user if the server has \"autoconfirm\" OFF\n     */\n    async signUp(credentials) {\n        var _a, _b, _c;\n        try {\n            let res;\n            if ('email' in credentials) {\n                const { email, password, options } = credentials;\n                let codeChallenge = null;\n                let codeChallengeMethod = null;\n                if (this.flowType === 'pkce') {\n                    ;\n                    [codeChallenge, codeChallengeMethod] = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getCodeChallengeAndMethod)(this.storage, this.storageKey);\n                }\n                res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', `${this.url}/signup`, {\n                    headers: this.headers,\n                    redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,\n                    body: {\n                        email,\n                        password,\n                        data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n                        gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },\n                        code_challenge: codeChallenge,\n                        code_challenge_method: codeChallengeMethod,\n                    },\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse,\n                });\n            }\n            else if ('phone' in credentials) {\n                const { phone, password, options } = credentials;\n                res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', `${this.url}/signup`, {\n                    headers: this.headers,\n                    body: {\n                        phone,\n                        password,\n                        data: (_b = options === null || options === void 0 ? void 0 : options.data) !== null && _b !== void 0 ? _b : {},\n                        channel: (_c = options === null || options === void 0 ? void 0 : options.channel) !== null && _c !== void 0 ? _c : 'sms',\n                        gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },\n                    },\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse,\n                });\n            }\n            else {\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidCredentialsError('You must provide either an email or phone number and a password');\n            }\n            const { data, error } = res;\n            if (error || !data) {\n                return { data: { user: null, session: null }, error: error };\n            }\n            const session = data.session;\n            const user = data.user;\n            if (data.session) {\n                await this._saveSession(data.session);\n                await this._notifyAllSubscribers('SIGNED_IN', session);\n            }\n            return { data: { user, session }, error: null };\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return { data: { user: null, session: null }, error };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Log in an existing user with an email and password or phone and password.\n     *\n     * Be aware that you may get back an error message that will not distinguish\n     * between the cases where the account does not exist or that the\n     * email/phone and password combination is wrong or that the account can only\n     * be accessed via social login.\n     */\n    async signInWithPassword(credentials) {\n        try {\n            let res;\n            if ('email' in credentials) {\n                const { email, password, options } = credentials;\n                res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', `${this.url}/token?grant_type=password`, {\n                    headers: this.headers,\n                    body: {\n                        email,\n                        password,\n                        gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },\n                    },\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponsePassword,\n                });\n            }\n            else if ('phone' in credentials) {\n                const { phone, password, options } = credentials;\n                res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', `${this.url}/token?grant_type=password`, {\n                    headers: this.headers,\n                    body: {\n                        phone,\n                        password,\n                        gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },\n                    },\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponsePassword,\n                });\n            }\n            else {\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidCredentialsError('You must provide either an email or phone number and a password');\n            }\n            const { data, error } = res;\n            if (error) {\n                return { data: { user: null, session: null }, error };\n            }\n            else if (!data || !data.session || !data.user) {\n                return { data: { user: null, session: null }, error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidTokenResponseError() };\n            }\n            if (data.session) {\n                await this._saveSession(data.session);\n                await this._notifyAllSubscribers('SIGNED_IN', data.session);\n            }\n            return {\n                data: Object.assign({ user: data.user, session: data.session }, (data.weak_password ? { weakPassword: data.weak_password } : null)),\n                error,\n            };\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return { data: { user: null, session: null }, error };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Log in an existing user via a third-party provider.\n     * This method supports the PKCE flow.\n     */\n    async signInWithOAuth(credentials) {\n        var _a, _b, _c, _d;\n        return await this._handleProviderSignIn(credentials.provider, {\n            redirectTo: (_a = credentials.options) === null || _a === void 0 ? void 0 : _a.redirectTo,\n            scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,\n            queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams,\n            skipBrowserRedirect: (_d = credentials.options) === null || _d === void 0 ? void 0 : _d.skipBrowserRedirect,\n        });\n    }\n    /**\n     * Log in an existing user by exchanging an Auth Code issued during the PKCE flow.\n     */\n    async exchangeCodeForSession(authCode) {\n        await this.initializePromise;\n        return this._acquireLock(-1, async () => {\n            return this._exchangeCodeForSession(authCode);\n        });\n    }\n    async _exchangeCodeForSession(authCode) {\n        const storageItem = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n        const [codeVerifier, redirectType] = (storageItem !== null && storageItem !== void 0 ? storageItem : '').split('/');\n        try {\n            const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', `${this.url}/token?grant_type=pkce`, {\n                headers: this.headers,\n                body: {\n                    auth_code: authCode,\n                    code_verifier: codeVerifier,\n                },\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse,\n            });\n            await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n            if (error) {\n                throw error;\n            }\n            if (!data || !data.session || !data.user) {\n                return {\n                    data: { user: null, session: null, redirectType: null },\n                    error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidTokenResponseError(),\n                };\n            }\n            if (data.session) {\n                await this._saveSession(data.session);\n                await this._notifyAllSubscribers('SIGNED_IN', data.session);\n            }\n            return { data: Object.assign(Object.assign({}, data), { redirectType: redirectType !== null && redirectType !== void 0 ? redirectType : null }), error };\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return { data: { user: null, session: null, redirectType: null }, error };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Allows signing in with an OIDC ID token. The authentication provider used\n     * should be enabled and configured.\n     */\n    async signInWithIdToken(credentials) {\n        try {\n            const { options, provider, token, access_token, nonce } = credentials;\n            const res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', `${this.url}/token?grant_type=id_token`, {\n                headers: this.headers,\n                body: {\n                    provider,\n                    id_token: token,\n                    access_token,\n                    nonce,\n                    gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },\n                },\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse,\n            });\n            const { data, error } = res;\n            if (error) {\n                return { data: { user: null, session: null }, error };\n            }\n            else if (!data || !data.session || !data.user) {\n                return {\n                    data: { user: null, session: null },\n                    error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidTokenResponseError(),\n                };\n            }\n            if (data.session) {\n                await this._saveSession(data.session);\n                await this._notifyAllSubscribers('SIGNED_IN', data.session);\n            }\n            return { data, error };\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return { data: { user: null, session: null }, error };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Log in a user using magiclink or a one-time password (OTP).\n     *\n     * If the `{{ .ConfirmationURL }}` variable is specified in the email template, a magiclink will be sent.\n     * If the `{{ .Token }}` variable is specified in the email template, an OTP will be sent.\n     * If you're using phone sign-ins, only an OTP will be sent. You won't be able to send a magiclink for phone sign-ins.\n     *\n     * Be aware that you may get back an error message that will not distinguish\n     * between the cases where the account does not exist or, that the account\n     * can only be accessed via social login.\n     *\n     * Do note that you will need to configure a Whatsapp sender on Twilio\n     * if you are using phone sign in with the 'whatsapp' channel. The whatsapp\n     * channel is not supported on other providers\n     * at this time.\n     * This method supports PKCE when an email is passed.\n     */\n    async signInWithOtp(credentials) {\n        var _a, _b, _c, _d, _e;\n        try {\n            if ('email' in credentials) {\n                const { email, options } = credentials;\n                let codeChallenge = null;\n                let codeChallengeMethod = null;\n                if (this.flowType === 'pkce') {\n                    ;\n                    [codeChallenge, codeChallengeMethod] = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getCodeChallengeAndMethod)(this.storage, this.storageKey);\n                }\n                const { error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', `${this.url}/otp`, {\n                    headers: this.headers,\n                    body: {\n                        email,\n                        data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n                        create_user: (_b = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _b !== void 0 ? _b : true,\n                        gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },\n                        code_challenge: codeChallenge,\n                        code_challenge_method: codeChallengeMethod,\n                    },\n                    redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,\n                });\n                return { data: { user: null, session: null }, error };\n            }\n            if ('phone' in credentials) {\n                const { phone, options } = credentials;\n                const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', `${this.url}/otp`, {\n                    headers: this.headers,\n                    body: {\n                        phone,\n                        data: (_c = options === null || options === void 0 ? void 0 : options.data) !== null && _c !== void 0 ? _c : {},\n                        create_user: (_d = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _d !== void 0 ? _d : true,\n                        gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },\n                        channel: (_e = options === null || options === void 0 ? void 0 : options.channel) !== null && _e !== void 0 ? _e : 'sms',\n                    },\n                });\n                return { data: { user: null, session: null, messageId: data === null || data === void 0 ? void 0 : data.message_id }, error };\n            }\n            throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidCredentialsError('You must provide either an email or phone number.');\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return { data: { user: null, session: null }, error };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Log in a user given a User supplied OTP or TokenHash received through mobile or email.\n     */\n    async verifyOtp(params) {\n        var _a, _b;\n        try {\n            let redirectTo = undefined;\n            let captchaToken = undefined;\n            if ('options' in params) {\n                redirectTo = (_a = params.options) === null || _a === void 0 ? void 0 : _a.redirectTo;\n                captchaToken = (_b = params.options) === null || _b === void 0 ? void 0 : _b.captchaToken;\n            }\n            const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', `${this.url}/verify`, {\n                headers: this.headers,\n                body: Object.assign(Object.assign({}, params), { gotrue_meta_security: { captcha_token: captchaToken } }),\n                redirectTo,\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse,\n            });\n            if (error) {\n                throw error;\n            }\n            if (!data) {\n                throw new Error('An error occurred on token verification.');\n            }\n            const session = data.session;\n            const user = data.user;\n            if (session === null || session === void 0 ? void 0 : session.access_token) {\n                await this._saveSession(session);\n                await this._notifyAllSubscribers(params.type == 'recovery' ? 'PASSWORD_RECOVERY' : 'SIGNED_IN', session);\n            }\n            return { data: { user, session }, error: null };\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return { data: { user: null, session: null }, error };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Attempts a single-sign on using an enterprise Identity Provider. A\n     * successful SSO attempt will redirect the current page to the identity\n     * provider authorization page. The redirect URL is implementation and SSO\n     * protocol specific.\n     *\n     * You can use it by providing a SSO domain. Typically you can extract this\n     * domain by asking users for their email address. If this domain is\n     * registered on the Auth instance the redirect will use that organization's\n     * currently active SSO Identity Provider for the login.\n     *\n     * If you have built an organization-specific login page, you can use the\n     * organization's SSO Identity Provider UUID directly instead.\n     */\n    async signInWithSSO(params) {\n        var _a, _b, _c;\n        try {\n            let codeChallenge = null;\n            let codeChallengeMethod = null;\n            if (this.flowType === 'pkce') {\n                ;\n                [codeChallenge, codeChallengeMethod] = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getCodeChallengeAndMethod)(this.storage, this.storageKey);\n            }\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', `${this.url}/sso`, {\n                body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, ('providerId' in params ? { provider_id: params.providerId } : null)), ('domain' in params ? { domain: params.domain } : null)), { redirect_to: (_b = (_a = params.options) === null || _a === void 0 ? void 0 : _a.redirectTo) !== null && _b !== void 0 ? _b : undefined }), (((_c = params === null || params === void 0 ? void 0 : params.options) === null || _c === void 0 ? void 0 : _c.captchaToken)\n                    ? { gotrue_meta_security: { captcha_token: params.options.captchaToken } }\n                    : null)), { skip_http_redirect: true, code_challenge: codeChallenge, code_challenge_method: codeChallengeMethod }),\n                headers: this.headers,\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._ssoResponse,\n            });\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return { data: null, error };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Sends a reauthentication OTP to the user's email or phone number.\n     * Requires the user to be signed-in.\n     */\n    async reauthenticate() {\n        await this.initializePromise;\n        return await this._acquireLock(-1, async () => {\n            return await this._reauthenticate();\n        });\n    }\n    async _reauthenticate() {\n        try {\n            return await this._useSession(async (result) => {\n                const { data: { session }, error: sessionError, } = result;\n                if (sessionError)\n                    throw sessionError;\n                if (!session)\n                    throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();\n                const { error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'GET', `${this.url}/reauthenticate`, {\n                    headers: this.headers,\n                    jwt: session.access_token,\n                });\n                return { data: { user: null, session: null }, error };\n            });\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return { data: { user: null, session: null }, error };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Resends an existing signup confirmation email, email change email, SMS OTP or phone change OTP.\n     */\n    async resend(credentials) {\n        try {\n            const endpoint = `${this.url}/resend`;\n            if ('email' in credentials) {\n                const { email, type, options } = credentials;\n                const { error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', endpoint, {\n                    headers: this.headers,\n                    body: {\n                        email,\n                        type,\n                        gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },\n                    },\n                    redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,\n                });\n                return { data: { user: null, session: null }, error };\n            }\n            else if ('phone' in credentials) {\n                const { phone, type, options } = credentials;\n                const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', endpoint, {\n                    headers: this.headers,\n                    body: {\n                        phone,\n                        type,\n                        gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },\n                    },\n                });\n                return { data: { user: null, session: null, messageId: data === null || data === void 0 ? void 0 : data.message_id }, error };\n            }\n            throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidCredentialsError('You must provide either an email or phone number and a type');\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return { data: { user: null, session: null }, error };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Returns the session, refreshing it if necessary.\n     *\n     * The session returned can be null if the session is not detected which can happen in the event a user is not signed-in or has logged out.\n     *\n     * **IMPORTANT:** This method loads values directly from the storage attached\n     * to the client. If that storage is based on request cookies for example,\n     * the values in it may not be authentic and therefore it's strongly advised\n     * against using this method and its results in such circumstances. A warning\n     * will be emitted if this is detected. Use {@link #getUser()} instead.\n     */\n    async getSession() {\n        await this.initializePromise;\n        const result = await this._acquireLock(-1, async () => {\n            return this._useSession(async (result) => {\n                return result;\n            });\n        });\n        return result;\n    }\n    /**\n     * Acquires a global lock based on the storage key.\n     */\n    async _acquireLock(acquireTimeout, fn) {\n        this._debug('#_acquireLock', 'begin', acquireTimeout);\n        try {\n            if (this.lockAcquired) {\n                const last = this.pendingInLock.length\n                    ? this.pendingInLock[this.pendingInLock.length - 1]\n                    : Promise.resolve();\n                const result = (async () => {\n                    await last;\n                    return await fn();\n                })();\n                this.pendingInLock.push((async () => {\n                    try {\n                        await result;\n                    }\n                    catch (e) {\n                        // we just care if it finished\n                    }\n                })());\n                return result;\n            }\n            return await this.lock(`lock:${this.storageKey}`, acquireTimeout, async () => {\n                this._debug('#_acquireLock', 'lock acquired for storage key', this.storageKey);\n                try {\n                    this.lockAcquired = true;\n                    const result = fn();\n                    this.pendingInLock.push((async () => {\n                        try {\n                            await result;\n                        }\n                        catch (e) {\n                            // we just care if it finished\n                        }\n                    })());\n                    await result;\n                    // keep draining the queue until there's nothing to wait on\n                    while (this.pendingInLock.length) {\n                        const waitOn = [...this.pendingInLock];\n                        await Promise.all(waitOn);\n                        this.pendingInLock.splice(0, waitOn.length);\n                    }\n                    return await result;\n                }\n                finally {\n                    this._debug('#_acquireLock', 'lock released for storage key', this.storageKey);\n                    this.lockAcquired = false;\n                }\n            });\n        }\n        finally {\n            this._debug('#_acquireLock', 'end');\n        }\n    }\n    /**\n     * Use instead of {@link #getSession} inside the library. It is\n     * semantically usually what you want, as getting a session involves some\n     * processing afterwards that requires only one client operating on the\n     * session at once across multiple tabs or processes.\n     */\n    async _useSession(fn) {\n        this._debug('#_useSession', 'begin');\n        try {\n            // the use of __loadSession here is the only correct use of the function!\n            const result = await this.__loadSession();\n            return await fn(result);\n        }\n        finally {\n            this._debug('#_useSession', 'end');\n        }\n    }\n    /**\n     * NEVER USE DIRECTLY!\n     *\n     * Always use {@link #_useSession}.\n     */\n    async __loadSession() {\n        this._debug('#__loadSession()', 'begin');\n        if (!this.lockAcquired) {\n            this._debug('#__loadSession()', 'used outside of an acquired lock!', new Error().stack);\n        }\n        try {\n            let currentSession = null;\n            const maybeSession = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getItemAsync)(this.storage, this.storageKey);\n            this._debug('#getSession()', 'session from storage', maybeSession);\n            if (maybeSession !== null) {\n                if (this._isValidSession(maybeSession)) {\n                    currentSession = maybeSession;\n                }\n                else {\n                    this._debug('#getSession()', 'session from storage is not valid');\n                    await this._removeSession();\n                }\n            }\n            if (!currentSession) {\n                return { data: { session: null }, error: null };\n            }\n            const hasExpired = currentSession.expires_at\n                ? currentSession.expires_at <= Date.now() / 1000\n                : false;\n            this._debug('#__loadSession()', `session has${hasExpired ? '' : ' not'} expired`, 'expires_at', currentSession.expires_at);\n            if (!hasExpired) {\n                if (this.storage.isServer) {\n                    let suppressWarning = this.suppressGetSessionWarning;\n                    const proxySession = new Proxy(currentSession, {\n                        get: (target, prop, receiver) => {\n                            if (!suppressWarning && prop === 'user') {\n                                // only show warning when the user object is being accessed from the server\n                                console.warn('Using the user object as returned from supabase.auth.getSession() or from some supabase.auth.onAuthStateChange() events could be insecure! This value comes directly from the storage medium (usually cookies on the server) and may not be authentic. Use supabase.auth.getUser() instead which authenticates the data by contacting the Supabase Auth server.');\n                                suppressWarning = true; // keeps this proxy instance from logging additional warnings\n                                this.suppressGetSessionWarning = true; // keeps this client's future proxy instances from warning\n                            }\n                            return Reflect.get(target, prop, receiver);\n                        },\n                    });\n                    currentSession = proxySession;\n                }\n                return { data: { session: currentSession }, error: null };\n            }\n            const { session, error } = await this._callRefreshToken(currentSession.refresh_token);\n            if (error) {\n                return { data: { session: null }, error };\n            }\n            return { data: { session }, error: null };\n        }\n        finally {\n            this._debug('#__loadSession()', 'end');\n        }\n    }\n    /**\n     * Gets the current user details if there is an existing session. This method\n     * performs a network request to the Supabase Auth server, so the returned\n     * value is authentic and can be used to base authorization rules on.\n     *\n     * @param jwt Takes in an optional access token JWT. If no JWT is provided, the JWT from the current session is used.\n     */\n    async getUser(jwt) {\n        if (jwt) {\n            return await this._getUser(jwt);\n        }\n        await this.initializePromise;\n        const result = await this._acquireLock(-1, async () => {\n            return await this._getUser();\n        });\n        return result;\n    }\n    async _getUser(jwt) {\n        try {\n            if (jwt) {\n                return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'GET', `${this.url}/user`, {\n                    headers: this.headers,\n                    jwt: jwt,\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._userResponse,\n                });\n            }\n            return await this._useSession(async (result) => {\n                var _a, _b, _c;\n                const { data, error } = result;\n                if (error) {\n                    throw error;\n                }\n                // returns an error if there is no access_token or custom authorization header\n                if (!((_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) && !this.hasCustomAuthorizationHeader) {\n                    return { data: { user: null }, error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError() };\n                }\n                return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'GET', `${this.url}/user`, {\n                    headers: this.headers,\n                    jwt: (_c = (_b = data.session) === null || _b === void 0 ? void 0 : _b.access_token) !== null && _c !== void 0 ? _c : undefined,\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._userResponse,\n                });\n            });\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthSessionMissingError)(error)) {\n                    // JWT contains a `session_id` which does not correspond to an active\n                    // session in the database, indicating the user is signed out.\n                    await this._removeSession();\n                    await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n                }\n                return { data: { user: null }, error };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Updates user data for a logged in user.\n     */\n    async updateUser(attributes, options = {}) {\n        await this.initializePromise;\n        return await this._acquireLock(-1, async () => {\n            return await this._updateUser(attributes, options);\n        });\n    }\n    async _updateUser(attributes, options = {}) {\n        try {\n            return await this._useSession(async (result) => {\n                const { data: sessionData, error: sessionError } = result;\n                if (sessionError) {\n                    throw sessionError;\n                }\n                if (!sessionData.session) {\n                    throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();\n                }\n                const session = sessionData.session;\n                let codeChallenge = null;\n                let codeChallengeMethod = null;\n                if (this.flowType === 'pkce' && attributes.email != null) {\n                    ;\n                    [codeChallenge, codeChallengeMethod] = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getCodeChallengeAndMethod)(this.storage, this.storageKey);\n                }\n                const { data, error: userError } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'PUT', `${this.url}/user`, {\n                    headers: this.headers,\n                    redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,\n                    body: Object.assign(Object.assign({}, attributes), { code_challenge: codeChallenge, code_challenge_method: codeChallengeMethod }),\n                    jwt: session.access_token,\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._userResponse,\n                });\n                if (userError)\n                    throw userError;\n                session.user = data.user;\n                await this._saveSession(session);\n                await this._notifyAllSubscribers('USER_UPDATED', session);\n                return { data: { user: session.user }, error: null };\n            });\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return { data: { user: null }, error };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Decodes a JWT (without performing any validation).\n     */\n    _decodeJWT(jwt) {\n        return (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.decodeJWTPayload)(jwt);\n    }\n    /**\n     * Sets the session data from the current session. If the current session is expired, setSession will take care of refreshing it to obtain a new session.\n     * If the refresh token or access token in the current session is invalid, an error will be thrown.\n     * @param currentSession The current session that minimally contains an access token and refresh token.\n     */\n    async setSession(currentSession) {\n        await this.initializePromise;\n        return await this._acquireLock(-1, async () => {\n            return await this._setSession(currentSession);\n        });\n    }\n    async _setSession(currentSession) {\n        try {\n            if (!currentSession.access_token || !currentSession.refresh_token) {\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();\n            }\n            const timeNow = Date.now() / 1000;\n            let expiresAt = timeNow;\n            let hasExpired = true;\n            let session = null;\n            const payload = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.decodeJWTPayload)(currentSession.access_token);\n            if (payload.exp) {\n                expiresAt = payload.exp;\n                hasExpired = expiresAt <= timeNow;\n            }\n            if (hasExpired) {\n                const { session: refreshedSession, error } = await this._callRefreshToken(currentSession.refresh_token);\n                if (error) {\n                    return { data: { user: null, session: null }, error: error };\n                }\n                if (!refreshedSession) {\n                    return { data: { user: null, session: null }, error: null };\n                }\n                session = refreshedSession;\n            }\n            else {\n                const { data, error } = await this._getUser(currentSession.access_token);\n                if (error) {\n                    throw error;\n                }\n                session = {\n                    access_token: currentSession.access_token,\n                    refresh_token: currentSession.refresh_token,\n                    user: data.user,\n                    token_type: 'bearer',\n                    expires_in: expiresAt - timeNow,\n                    expires_at: expiresAt,\n                };\n                await this._saveSession(session);\n                await this._notifyAllSubscribers('SIGNED_IN', session);\n            }\n            return { data: { user: session.user, session }, error: null };\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return { data: { session: null, user: null }, error };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Returns a new session, regardless of expiry status.\n     * Takes in an optional current session. If not passed in, then refreshSession() will attempt to retrieve it from getSession().\n     * If the current session's refresh token is invalid, an error will be thrown.\n     * @param currentSession The current session. If passed in, it must contain a refresh token.\n     */\n    async refreshSession(currentSession) {\n        await this.initializePromise;\n        return await this._acquireLock(-1, async () => {\n            return await this._refreshSession(currentSession);\n        });\n    }\n    async _refreshSession(currentSession) {\n        try {\n            return await this._useSession(async (result) => {\n                var _a;\n                if (!currentSession) {\n                    const { data, error } = result;\n                    if (error) {\n                        throw error;\n                    }\n                    currentSession = (_a = data.session) !== null && _a !== void 0 ? _a : undefined;\n                }\n                if (!(currentSession === null || currentSession === void 0 ? void 0 : currentSession.refresh_token)) {\n                    throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();\n                }\n                const { session, error } = await this._callRefreshToken(currentSession.refresh_token);\n                if (error) {\n                    return { data: { user: null, session: null }, error: error };\n                }\n                if (!session) {\n                    return { data: { user: null, session: null }, error: null };\n                }\n                return { data: { user: session.user, session }, error: null };\n            });\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return { data: { user: null, session: null }, error };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Gets the session data from a URL string\n     */\n    async _getSessionFromURL(params, callbackUrlType) {\n        try {\n            if (!(0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)())\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthImplicitGrantRedirectError('No browser detected.');\n            // If there's an error in the URL, it doesn't matter what flow it is, we just return the error.\n            if (params.error || params.error_description || params.error_code) {\n                // The error class returned implies that the redirect is from an implicit grant flow\n                // but it could also be from a redirect error from a PKCE flow.\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthImplicitGrantRedirectError(params.error_description || 'Error in URL with unspecified error_description', {\n                    error: params.error || 'unspecified_error',\n                    code: params.error_code || 'unspecified_code',\n                });\n            }\n            // Checks for mismatches between the flowType initialised in the client and the URL parameters\n            switch (callbackUrlType) {\n                case 'implicit':\n                    if (this.flowType === 'pkce') {\n                        throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthPKCEGrantCodeExchangeError('Not a valid PKCE flow url.');\n                    }\n                    break;\n                case 'pkce':\n                    if (this.flowType === 'implicit') {\n                        throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthImplicitGrantRedirectError('Not a valid implicit grant flow url.');\n                    }\n                    break;\n                default:\n                // there's no mismatch so we continue\n            }\n            // Since this is a redirect for PKCE, we attempt to retrieve the code from the URL for the code exchange\n            if (callbackUrlType === 'pkce') {\n                this._debug('#_initialize()', 'begin', 'is PKCE flow', true);\n                if (!params.code)\n                    throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthPKCEGrantCodeExchangeError('No code detected.');\n                const { data, error } = await this._exchangeCodeForSession(params.code);\n                if (error)\n                    throw error;\n                const url = new URL(window.location.href);\n                url.searchParams.delete('code');\n                window.history.replaceState(window.history.state, '', url.toString());\n                return { data: { session: data.session, redirectType: null }, error: null };\n            }\n            const { provider_token, provider_refresh_token, access_token, refresh_token, expires_in, expires_at, token_type, } = params;\n            if (!access_token || !expires_in || !refresh_token || !token_type) {\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthImplicitGrantRedirectError('No session defined in URL');\n            }\n            const timeNow = Math.round(Date.now() / 1000);\n            const expiresIn = parseInt(expires_in);\n            let expiresAt = timeNow + expiresIn;\n            if (expires_at) {\n                expiresAt = parseInt(expires_at);\n            }\n            const actuallyExpiresIn = expiresAt - timeNow;\n            if (actuallyExpiresIn * 1000 <= AUTO_REFRESH_TICK_DURATION) {\n                console.warn(`@supabase/gotrue-js: Session as retrieved from URL expires in ${actuallyExpiresIn}s, should have been closer to ${expiresIn}s`);\n            }\n            const issuedAt = expiresAt - expiresIn;\n            if (timeNow - issuedAt >= 120) {\n                console.warn('@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale', issuedAt, expiresAt, timeNow);\n            }\n            else if (timeNow - issuedAt < 0) {\n                console.warn('@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clock for skew', issuedAt, expiresAt, timeNow);\n            }\n            const { data, error } = await this._getUser(access_token);\n            if (error)\n                throw error;\n            const session = {\n                provider_token,\n                provider_refresh_token,\n                access_token,\n                expires_in: expiresIn,\n                expires_at: expiresAt,\n                refresh_token,\n                token_type,\n                user: data.user,\n            };\n            // Remove tokens from URL\n            window.location.hash = '';\n            this._debug('#_getSessionFromURL()', 'clearing window.location.hash');\n            return { data: { session, redirectType: params.type }, error: null };\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return { data: { session: null, redirectType: null }, error };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Checks if the current URL contains parameters given by an implicit oauth grant flow (https://www.rfc-editor.org/rfc/rfc6749.html#section-4.2)\n     */\n    _isImplicitGrantCallback(params) {\n        return Boolean(params.access_token || params.error_description);\n    }\n    /**\n     * Checks if the current URL and backing storage contain parameters given by a PKCE flow\n     */\n    async _isPKCECallback(params) {\n        const currentStorageContent = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n        return !!(params.code && currentStorageContent);\n    }\n    /**\n     * Inside a browser context, `signOut()` will remove the logged in user from the browser session and log them out - removing all items from localstorage and then trigger a `\"SIGNED_OUT\"` event.\n     *\n     * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`.\n     * There is no way to revoke a user's access token jwt until it expires. It is recommended to set a shorter expiry on the jwt for this reason.\n     *\n     * If using `others` scope, no `SIGNED_OUT` event is fired!\n     */\n    async signOut(options = { scope: 'global' }) {\n        await this.initializePromise;\n        return await this._acquireLock(-1, async () => {\n            return await this._signOut(options);\n        });\n    }\n    async _signOut({ scope } = { scope: 'global' }) {\n        return await this._useSession(async (result) => {\n            var _a;\n            const { data, error: sessionError } = result;\n            if (sessionError) {\n                return { error: sessionError };\n            }\n            const accessToken = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token;\n            if (accessToken) {\n                const { error } = await this.admin.signOut(accessToken, scope);\n                if (error) {\n                    // ignore 404s since user might not exist anymore\n                    // ignore 401s since an invalid or expired JWT should sign out the current session\n                    if (!((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthApiError)(error) &&\n                        (error.status === 404 || error.status === 401 || error.status === 403))) {\n                        return { error };\n                    }\n                }\n            }\n            if (scope !== 'others') {\n                await this._removeSession();\n                await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n            }\n            return { error: null };\n        });\n    }\n    /**\n     * Receive a notification every time an auth event happens.\n     * @param callback A callback function to be invoked when an auth event happens.\n     */\n    onAuthStateChange(callback) {\n        const id = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.uuid)();\n        const subscription = {\n            id,\n            callback,\n            unsubscribe: () => {\n                this._debug('#unsubscribe()', 'state change callback with id removed', id);\n                this.stateChangeEmitters.delete(id);\n            },\n        };\n        this._debug('#onAuthStateChange()', 'registered callback with id', id);\n        this.stateChangeEmitters.set(id, subscription);\n        (async () => {\n            await this.initializePromise;\n            await this._acquireLock(-1, async () => {\n                this._emitInitialSession(id);\n            });\n        })();\n        return { data: { subscription } };\n    }\n    async _emitInitialSession(id) {\n        return await this._useSession(async (result) => {\n            var _a, _b;\n            try {\n                const { data: { session }, error, } = result;\n                if (error)\n                    throw error;\n                await ((_a = this.stateChangeEmitters.get(id)) === null || _a === void 0 ? void 0 : _a.callback('INITIAL_SESSION', session));\n                this._debug('INITIAL_SESSION', 'callback id', id, 'session', session);\n            }\n            catch (err) {\n                await ((_b = this.stateChangeEmitters.get(id)) === null || _b === void 0 ? void 0 : _b.callback('INITIAL_SESSION', null));\n                this._debug('INITIAL_SESSION', 'callback id', id, 'error', err);\n                console.error(err);\n            }\n        });\n    }\n    /**\n     * Sends a password reset request to an email address. This method supports the PKCE flow.\n     *\n     * @param email The email address of the user.\n     * @param options.redirectTo The URL to send the user to after they click the password reset link.\n     * @param options.captchaToken Verification token received when the user completes the captcha on the site.\n     */\n    async resetPasswordForEmail(email, options = {}) {\n        let codeChallenge = null;\n        let codeChallengeMethod = null;\n        if (this.flowType === 'pkce') {\n            ;\n            [codeChallenge, codeChallengeMethod] = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getCodeChallengeAndMethod)(this.storage, this.storageKey, true // isPasswordRecovery\n            );\n        }\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', `${this.url}/recover`, {\n                body: {\n                    email,\n                    code_challenge: codeChallenge,\n                    code_challenge_method: codeChallengeMethod,\n                    gotrue_meta_security: { captcha_token: options.captchaToken },\n                },\n                headers: this.headers,\n                redirectTo: options.redirectTo,\n            });\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return { data: null, error };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Gets all the identities linked to a user.\n     */\n    async getUserIdentities() {\n        var _a;\n        try {\n            const { data, error } = await this.getUser();\n            if (error)\n                throw error;\n            return { data: { identities: (_a = data.user.identities) !== null && _a !== void 0 ? _a : [] }, error: null };\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return { data: null, error };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Links an oauth identity to an existing user.\n     * This method supports the PKCE flow.\n     */\n    async linkIdentity(credentials) {\n        var _a;\n        try {\n            const { data, error } = await this._useSession(async (result) => {\n                var _a, _b, _c, _d, _e;\n                const { data, error } = result;\n                if (error)\n                    throw error;\n                const url = await this._getUrlForProvider(`${this.url}/user/identities/authorize`, credentials.provider, {\n                    redirectTo: (_a = credentials.options) === null || _a === void 0 ? void 0 : _a.redirectTo,\n                    scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,\n                    queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams,\n                    skipBrowserRedirect: true,\n                });\n                return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'GET', url, {\n                    headers: this.headers,\n                    jwt: (_e = (_d = data.session) === null || _d === void 0 ? void 0 : _d.access_token) !== null && _e !== void 0 ? _e : undefined,\n                });\n            });\n            if (error)\n                throw error;\n            if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && !((_a = credentials.options) === null || _a === void 0 ? void 0 : _a.skipBrowserRedirect)) {\n                window.location.assign(data === null || data === void 0 ? void 0 : data.url);\n            }\n            return { data: { provider: credentials.provider, url: data === null || data === void 0 ? void 0 : data.url }, error: null };\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return { data: { provider: credentials.provider, url: null }, error };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Unlinks an identity from a user by deleting it. The user will no longer be able to sign in with that identity once it's unlinked.\n     */\n    async unlinkIdentity(identity) {\n        try {\n            return await this._useSession(async (result) => {\n                var _a, _b;\n                const { data, error } = result;\n                if (error) {\n                    throw error;\n                }\n                return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'DELETE', `${this.url}/user/identities/${identity.identity_id}`, {\n                    headers: this.headers,\n                    jwt: (_b = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : undefined,\n                });\n            });\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return { data: null, error };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Generates a new JWT.\n     * @param refreshToken A valid refresh token that was returned on login.\n     */\n    async _refreshAccessToken(refreshToken) {\n        const debugName = `#_refreshAccessToken(${refreshToken.substring(0, 5)}...)`;\n        this._debug(debugName, 'begin');\n        try {\n            const startedAt = Date.now();\n            // will attempt to refresh the token with exponential backoff\n            return await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.retryable)(async (attempt) => {\n                if (attempt > 0) {\n                    await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.sleep)(200 * Math.pow(2, attempt - 1)); // 200, 400, 800, ...\n                }\n                this._debug(debugName, 'refreshing attempt', attempt);\n                return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', `${this.url}/token?grant_type=refresh_token`, {\n                    body: { refresh_token: refreshToken },\n                    headers: this.headers,\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse,\n                });\n            }, (attempt, error) => {\n                const nextBackOffInterval = 200 * Math.pow(2, attempt);\n                return (error &&\n                    (0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthRetryableFetchError)(error) &&\n                    // retryable only if the request can be sent before the backoff overflows the tick duration\n                    Date.now() + nextBackOffInterval - startedAt < AUTO_REFRESH_TICK_DURATION);\n            });\n        }\n        catch (error) {\n            this._debug(debugName, 'error', error);\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return { data: { session: null, user: null }, error };\n            }\n            throw error;\n        }\n        finally {\n            this._debug(debugName, 'end');\n        }\n    }\n    _isValidSession(maybeSession) {\n        const isValidSession = typeof maybeSession === 'object' &&\n            maybeSession !== null &&\n            'access_token' in maybeSession &&\n            'refresh_token' in maybeSession &&\n            'expires_at' in maybeSession;\n        return isValidSession;\n    }\n    async _handleProviderSignIn(provider, options) {\n        const url = await this._getUrlForProvider(`${this.url}/authorize`, provider, {\n            redirectTo: options.redirectTo,\n            scopes: options.scopes,\n            queryParams: options.queryParams,\n        });\n        this._debug('#_handleProviderSignIn()', 'provider', provider, 'options', options, 'url', url);\n        // try to open on the browser\n        if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && !options.skipBrowserRedirect) {\n            window.location.assign(url);\n        }\n        return { data: { provider, url }, error: null };\n    }\n    /**\n     * Recovers the session from LocalStorage and refreshes the token\n     * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\n     */\n    async _recoverAndRefresh() {\n        var _a;\n        const debugName = '#_recoverAndRefresh()';\n        this._debug(debugName, 'begin');\n        try {\n            const currentSession = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getItemAsync)(this.storage, this.storageKey);\n            this._debug(debugName, 'session from storage', currentSession);\n            if (!this._isValidSession(currentSession)) {\n                this._debug(debugName, 'session is not valid');\n                if (currentSession !== null) {\n                    await this._removeSession();\n                }\n                return;\n            }\n            const timeNow = Math.round(Date.now() / 1000);\n            const expiresWithMargin = ((_a = currentSession.expires_at) !== null && _a !== void 0 ? _a : Infinity) < timeNow + _lib_constants__WEBPACK_IMPORTED_MODULE_1__.EXPIRY_MARGIN;\n            this._debug(debugName, `session has${expiresWithMargin ? '' : ' not'} expired with margin of ${_lib_constants__WEBPACK_IMPORTED_MODULE_1__.EXPIRY_MARGIN}s`);\n            if (expiresWithMargin) {\n                if (this.autoRefreshToken && currentSession.refresh_token) {\n                    const { error } = await this._callRefreshToken(currentSession.refresh_token);\n                    if (error) {\n                        console.error(error);\n                        if (!(0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthRetryableFetchError)(error)) {\n                            this._debug(debugName, 'refresh failed with a non-retryable error, removing the session', error);\n                            await this._removeSession();\n                        }\n                    }\n                }\n            }\n            else {\n                // no need to persist currentSession again, as we just loaded it from\n                // local storage; persisting it again may overwrite a value saved by\n                // another client with access to the same local storage\n                await this._notifyAllSubscribers('SIGNED_IN', currentSession);\n            }\n        }\n        catch (err) {\n            this._debug(debugName, 'error', err);\n            console.error(err);\n            return;\n        }\n        finally {\n            this._debug(debugName, 'end');\n        }\n    }\n    async _callRefreshToken(refreshToken) {\n        var _a, _b;\n        if (!refreshToken) {\n            throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();\n        }\n        // refreshing is already in progress\n        if (this.refreshingDeferred) {\n            return this.refreshingDeferred.promise;\n        }\n        const debugName = `#_callRefreshToken(${refreshToken.substring(0, 5)}...)`;\n        this._debug(debugName, 'begin');\n        try {\n            this.refreshingDeferred = new _lib_helpers__WEBPACK_IMPORTED_MODULE_4__.Deferred();\n            const { data, error } = await this._refreshAccessToken(refreshToken);\n            if (error)\n                throw error;\n            if (!data.session)\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();\n            await this._saveSession(data.session);\n            await this._notifyAllSubscribers('TOKEN_REFRESHED', data.session);\n            const result = { session: data.session, error: null };\n            this.refreshingDeferred.resolve(result);\n            return result;\n        }\n        catch (error) {\n            this._debug(debugName, 'error', error);\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                const result = { session: null, error };\n                if (!(0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthRetryableFetchError)(error)) {\n                    await this._removeSession();\n                }\n                (_a = this.refreshingDeferred) === null || _a === void 0 ? void 0 : _a.resolve(result);\n                return result;\n            }\n            (_b = this.refreshingDeferred) === null || _b === void 0 ? void 0 : _b.reject(error);\n            throw error;\n        }\n        finally {\n            this.refreshingDeferred = null;\n            this._debug(debugName, 'end');\n        }\n    }\n    async _notifyAllSubscribers(event, session, broadcast = true) {\n        const debugName = `#_notifyAllSubscribers(${event})`;\n        this._debug(debugName, 'begin', session, `broadcast = ${broadcast}`);\n        try {\n            if (this.broadcastChannel && broadcast) {\n                this.broadcastChannel.postMessage({ event, session });\n            }\n            const errors = [];\n            const promises = Array.from(this.stateChangeEmitters.values()).map(async (x) => {\n                try {\n                    await x.callback(event, session);\n                }\n                catch (e) {\n                    errors.push(e);\n                }\n            });\n            await Promise.all(promises);\n            if (errors.length > 0) {\n                for (let i = 0; i < errors.length; i += 1) {\n                    console.error(errors[i]);\n                }\n                throw errors[0];\n            }\n        }\n        finally {\n            this._debug(debugName, 'end');\n        }\n    }\n    /**\n     * set currentSession and currentUser\n     * process to _startAutoRefreshToken if possible\n     */\n    async _saveSession(session) {\n        this._debug('#_saveSession()', session);\n        // _saveSession is always called whenever a new session has been acquired\n        // so we can safely suppress the warning returned by future getSession calls\n        this.suppressGetSessionWarning = true;\n        await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.setItemAsync)(this.storage, this.storageKey, session);\n    }\n    async _removeSession() {\n        this._debug('#_removeSession()');\n        await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, this.storageKey);\n        await this._notifyAllSubscribers('SIGNED_OUT', null);\n    }\n    /**\n     * Removes any registered visibilitychange callback.\n     *\n     * {@see #startAutoRefresh}\n     * {@see #stopAutoRefresh}\n     */\n    _removeVisibilityChangedCallback() {\n        this._debug('#_removeVisibilityChangedCallback()');\n        const callback = this.visibilityChangedCallback;\n        this.visibilityChangedCallback = null;\n        try {\n            if (callback && (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && (window === null || window === void 0 ? void 0 : window.removeEventListener)) {\n                window.removeEventListener('visibilitychange', callback);\n            }\n        }\n        catch (e) {\n            console.error('removing visibilitychange callback failed', e);\n        }\n    }\n    /**\n     * This is the private implementation of {@link #startAutoRefresh}. Use this\n     * within the library.\n     */\n    async _startAutoRefresh() {\n        await this._stopAutoRefresh();\n        this._debug('#_startAutoRefresh()');\n        const ticker = setInterval(() => this._autoRefreshTokenTick(), AUTO_REFRESH_TICK_DURATION);\n        this.autoRefreshTicker = ticker;\n        if (ticker && typeof ticker === 'object' && typeof ticker.unref === 'function') {\n            // ticker is a NodeJS Timeout object that has an `unref` method\n            // https://nodejs.org/api/timers.html#timeoutunref\n            // When auto refresh is used in NodeJS (like for testing) the\n            // `setInterval` is preventing the process from being marked as\n            // finished and tests run endlessly. This can be prevented by calling\n            // `unref()` on the returned object.\n            ticker.unref();\n            // @ts-expect-error TS has no context of Deno\n        }\n        else if (typeof Deno !== 'undefined' && typeof Deno.unrefTimer === 'function') {\n            // similar like for NodeJS, but with the Deno API\n            // https://deno.land/api@latest?unstable&s=Deno.unrefTimer\n            // @ts-expect-error TS has no context of Deno\n            Deno.unrefTimer(ticker);\n        }\n        // run the tick immediately, but in the next pass of the event loop so that\n        // #_initialize can be allowed to complete without recursively waiting on\n        // itself\n        setTimeout(async () => {\n            await this.initializePromise;\n            await this._autoRefreshTokenTick();\n        }, 0);\n    }\n    /**\n     * This is the private implementation of {@link #stopAutoRefresh}. Use this\n     * within the library.\n     */\n    async _stopAutoRefresh() {\n        this._debug('#_stopAutoRefresh()');\n        const ticker = this.autoRefreshTicker;\n        this.autoRefreshTicker = null;\n        if (ticker) {\n            clearInterval(ticker);\n        }\n    }\n    /**\n     * Starts an auto-refresh process in the background. The session is checked\n     * every few seconds. Close to the time of expiration a process is started to\n     * refresh the session. If refreshing fails it will be retried for as long as\n     * necessary.\n     *\n     * If you set the {@link GoTrueClientOptions#autoRefreshToken} you don't need\n     * to call this function, it will be called for you.\n     *\n     * On browsers the refresh process works only when the tab/window is in the\n     * foreground to conserve resources as well as prevent race conditions and\n     * flooding auth with requests. If you call this method any managed\n     * visibility change callback will be removed and you must manage visibility\n     * changes on your own.\n     *\n     * On non-browser platforms the refresh process works *continuously* in the\n     * background, which may not be desirable. You should hook into your\n     * platform's foreground indication mechanism and call these methods\n     * appropriately to conserve resources.\n     *\n     * {@see #stopAutoRefresh}\n     */\n    async startAutoRefresh() {\n        this._removeVisibilityChangedCallback();\n        await this._startAutoRefresh();\n    }\n    /**\n     * Stops an active auto refresh process running in the background (if any).\n     *\n     * If you call this method any managed visibility change callback will be\n     * removed and you must manage visibility changes on your own.\n     *\n     * See {@link #startAutoRefresh} for more details.\n     */\n    async stopAutoRefresh() {\n        this._removeVisibilityChangedCallback();\n        await this._stopAutoRefresh();\n    }\n    /**\n     * Runs the auto refresh token tick.\n     */\n    async _autoRefreshTokenTick() {\n        this._debug('#_autoRefreshTokenTick()', 'begin');\n        try {\n            await this._acquireLock(0, async () => {\n                try {\n                    const now = Date.now();\n                    try {\n                        return await this._useSession(async (result) => {\n                            const { data: { session }, } = result;\n                            if (!session || !session.refresh_token || !session.expires_at) {\n                                this._debug('#_autoRefreshTokenTick()', 'no session');\n                                return;\n                            }\n                            // session will expire in this many ticks (or has already expired if <= 0)\n                            const expiresInTicks = Math.floor((session.expires_at * 1000 - now) / AUTO_REFRESH_TICK_DURATION);\n                            this._debug('#_autoRefreshTokenTick()', `access token expires in ${expiresInTicks} ticks, a tick lasts ${AUTO_REFRESH_TICK_DURATION}ms, refresh threshold is ${AUTO_REFRESH_TICK_THRESHOLD} ticks`);\n                            if (expiresInTicks <= AUTO_REFRESH_TICK_THRESHOLD) {\n                                await this._callRefreshToken(session.refresh_token);\n                            }\n                        });\n                    }\n                    catch (e) {\n                        console.error('Auto refresh tick failed with error. This is likely a transient error.', e);\n                    }\n                }\n                finally {\n                    this._debug('#_autoRefreshTokenTick()', 'end');\n                }\n            });\n        }\n        catch (e) {\n            if (e.isAcquireTimeout || e instanceof _lib_locks__WEBPACK_IMPORTED_MODULE_8__.LockAcquireTimeoutError) {\n                this._debug('auto refresh token tick lock not available');\n            }\n            else {\n                throw e;\n            }\n        }\n    }\n    /**\n     * Registers callbacks on the browser / platform, which in-turn run\n     * algorithms when the browser window/tab are in foreground. On non-browser\n     * platforms it assumes always foreground.\n     */\n    async _handleVisibilityChange() {\n        this._debug('#_handleVisibilityChange()');\n        if (!(0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {\n            if (this.autoRefreshToken) {\n                // in non-browser environments the refresh token ticker runs always\n                this.startAutoRefresh();\n            }\n            return false;\n        }\n        try {\n            this.visibilityChangedCallback = async () => await this._onVisibilityChanged(false);\n            window === null || window === void 0 ? void 0 : window.addEventListener('visibilitychange', this.visibilityChangedCallback);\n            // now immediately call the visbility changed callback to setup with the\n            // current visbility state\n            await this._onVisibilityChanged(true); // initial call\n        }\n        catch (error) {\n            console.error('_handleVisibilityChange', error);\n        }\n    }\n    /**\n     * Callback registered with `window.addEventListener('visibilitychange')`.\n     */\n    async _onVisibilityChanged(calledFromInitialize) {\n        const methodName = `#_onVisibilityChanged(${calledFromInitialize})`;\n        this._debug(methodName, 'visibilityState', document.visibilityState);\n        if (document.visibilityState === 'visible') {\n            if (this.autoRefreshToken) {\n                // in browser environments the refresh token ticker runs only on focused tabs\n                // which prevents race conditions\n                this._startAutoRefresh();\n            }\n            if (!calledFromInitialize) {\n                // called when the visibility has changed, i.e. the browser\n                // transitioned from hidden -> visible so we need to see if the session\n                // should be recovered immediately... but to do that we need to acquire\n                // the lock first asynchronously\n                await this.initializePromise;\n                await this._acquireLock(-1, async () => {\n                    if (document.visibilityState !== 'visible') {\n                        this._debug(methodName, 'acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting');\n                        // visibility has changed while waiting for the lock, abort\n                        return;\n                    }\n                    // recover the session\n                    await this._recoverAndRefresh();\n                });\n            }\n        }\n        else if (document.visibilityState === 'hidden') {\n            if (this.autoRefreshToken) {\n                this._stopAutoRefresh();\n            }\n        }\n    }\n    /**\n     * Generates the relevant login URL for a third-party provider.\n     * @param options.redirectTo A URL or mobile address to send the user to after they are confirmed.\n     * @param options.scopes A space-separated list of scopes granted to the OAuth application.\n     * @param options.queryParams An object of key-value pairs containing query parameters granted to the OAuth application.\n     */\n    async _getUrlForProvider(url, provider, options) {\n        const urlParams = [`provider=${encodeURIComponent(provider)}`];\n        if (options === null || options === void 0 ? void 0 : options.redirectTo) {\n            urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`);\n        }\n        if (options === null || options === void 0 ? void 0 : options.scopes) {\n            urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`);\n        }\n        if (this.flowType === 'pkce') {\n            const [codeChallenge, codeChallengeMethod] = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getCodeChallengeAndMethod)(this.storage, this.storageKey);\n            const flowParams = new URLSearchParams({\n                code_challenge: `${encodeURIComponent(codeChallenge)}`,\n                code_challenge_method: `${encodeURIComponent(codeChallengeMethod)}`,\n            });\n            urlParams.push(flowParams.toString());\n        }\n        if (options === null || options === void 0 ? void 0 : options.queryParams) {\n            const query = new URLSearchParams(options.queryParams);\n            urlParams.push(query.toString());\n        }\n        if (options === null || options === void 0 ? void 0 : options.skipBrowserRedirect) {\n            urlParams.push(`skip_http_redirect=${options.skipBrowserRedirect}`);\n        }\n        return `${url}?${urlParams.join('&')}`;\n    }\n    async _unenroll(params) {\n        try {\n            return await this._useSession(async (result) => {\n                var _a;\n                const { data: sessionData, error: sessionError } = result;\n                if (sessionError) {\n                    return { data: null, error: sessionError };\n                }\n                return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'DELETE', `${this.url}/factors/${params.factorId}`, {\n                    headers: this.headers,\n                    jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token,\n                });\n            });\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return { data: null, error };\n            }\n            throw error;\n        }\n    }\n    async _enroll(params) {\n        try {\n            return await this._useSession(async (result) => {\n                var _a, _b;\n                const { data: sessionData, error: sessionError } = result;\n                if (sessionError) {\n                    return { data: null, error: sessionError };\n                }\n                const body = Object.assign({ friendly_name: params.friendlyName, factor_type: params.factorType }, (params.factorType === 'phone' ? { phone: params.phone } : { issuer: params.issuer }));\n                const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', `${this.url}/factors`, {\n                    body,\n                    headers: this.headers,\n                    jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token,\n                });\n                if (error) {\n                    return { data: null, error };\n                }\n                if (params.factorType === 'totp' && ((_b = data === null || data === void 0 ? void 0 : data.totp) === null || _b === void 0 ? void 0 : _b.qr_code)) {\n                    data.totp.qr_code = `data:image/svg+xml;utf-8,${data.totp.qr_code}`;\n                }\n                return { data, error: null };\n            });\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return { data: null, error };\n            }\n            throw error;\n        }\n    }\n    /**\n     * {@see GoTrueMFAApi#verify}\n     */\n    async _verify(params) {\n        return this._acquireLock(-1, async () => {\n            try {\n                return await this._useSession(async (result) => {\n                    var _a;\n                    const { data: sessionData, error: sessionError } = result;\n                    if (sessionError) {\n                        return { data: null, error: sessionError };\n                    }\n                    const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', `${this.url}/factors/${params.factorId}/verify`, {\n                        body: { code: params.code, challenge_id: params.challengeId },\n                        headers: this.headers,\n                        jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token,\n                    });\n                    if (error) {\n                        return { data: null, error };\n                    }\n                    await this._saveSession(Object.assign({ expires_at: Math.round(Date.now() / 1000) + data.expires_in }, data));\n                    await this._notifyAllSubscribers('MFA_CHALLENGE_VERIFIED', data);\n                    return { data, error };\n                });\n            }\n            catch (error) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * {@see GoTrueMFAApi#challenge}\n     */\n    async _challenge(params) {\n        return this._acquireLock(-1, async () => {\n            try {\n                return await this._useSession(async (result) => {\n                    var _a;\n                    const { data: sessionData, error: sessionError } = result;\n                    if (sessionError) {\n                        return { data: null, error: sessionError };\n                    }\n                    return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', `${this.url}/factors/${params.factorId}/challenge`, {\n                        body: { channel: params.channel },\n                        headers: this.headers,\n                        jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token,\n                    });\n                });\n            }\n            catch (error) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * {@see GoTrueMFAApi#challengeAndVerify}\n     */\n    async _challengeAndVerify(params) {\n        // both _challenge and _verify independently acquire the lock, so no need\n        // to acquire it here\n        const { data: challengeData, error: challengeError } = await this._challenge({\n            factorId: params.factorId,\n        });\n        if (challengeError) {\n            return { data: null, error: challengeError };\n        }\n        return await this._verify({\n            factorId: params.factorId,\n            challengeId: challengeData.id,\n            code: params.code,\n        });\n    }\n    /**\n     * {@see GoTrueMFAApi#listFactors}\n     */\n    async _listFactors() {\n        // use #getUser instead of #_getUser as the former acquires a lock\n        const { data: { user }, error: userError, } = await this.getUser();\n        if (userError) {\n            return { data: null, error: userError };\n        }\n        const factors = (user === null || user === void 0 ? void 0 : user.factors) || [];\n        const totp = factors.filter((factor) => factor.factor_type === 'totp' && factor.status === 'verified');\n        const phone = factors.filter((factor) => factor.factor_type === 'phone' && factor.status === 'verified');\n        return {\n            data: {\n                all: factors,\n                totp,\n                phone,\n            },\n            error: null,\n        };\n    }\n    /**\n     * {@see GoTrueMFAApi#getAuthenticatorAssuranceLevel}\n     */\n    async _getAuthenticatorAssuranceLevel() {\n        return this._acquireLock(-1, async () => {\n            return await this._useSession(async (result) => {\n                var _a, _b;\n                const { data: { session }, error: sessionError, } = result;\n                if (sessionError) {\n                    return { data: null, error: sessionError };\n                }\n                if (!session) {\n                    return {\n                        data: { currentLevel: null, nextLevel: null, currentAuthenticationMethods: [] },\n                        error: null,\n                    };\n                }\n                const payload = this._decodeJWT(session.access_token);\n                let currentLevel = null;\n                if (payload.aal) {\n                    currentLevel = payload.aal;\n                }\n                let nextLevel = currentLevel;\n                const verifiedFactors = (_b = (_a = session.user.factors) === null || _a === void 0 ? void 0 : _a.filter((factor) => factor.status === 'verified')) !== null && _b !== void 0 ? _b : [];\n                if (verifiedFactors.length > 0) {\n                    nextLevel = 'aal2';\n                }\n                const currentAuthenticationMethods = payload.amr || [];\n                return { data: { currentLevel, nextLevel, currentAuthenticationMethods }, error: null };\n            });\n        });\n    }\n}\nGoTrueClient.nextInstanceID = 0;\n//# sourceMappingURL=GoTrueClient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9Hb1RydWVDbGllbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUE4QztBQUM0QztBQUNpTztBQUMxTTtBQUNrSDtBQUM5STtBQUNoQztBQUNiO0FBQzZCO0FBQ3JFLGtFQUFrQixJQUFJO0FBQ3RCO0FBQ0EsU0FBUyxzREFBVTtBQUNuQixnQkFBZ0IsdURBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsYUFBYSwyREFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsdURBQVM7QUFDNUM7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1REFBYztBQUN2QztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHFCQUFxQiwwREFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix1REFBUztBQUMxQix3QkFBd0IscURBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtFQUFvQjtBQUN4QyxtQ0FBbUMsbUVBQW1CO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyw2RUFBeUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw2RUFBeUI7QUFDcEQ7QUFDQSxZQUFZLHVEQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0Y7QUFDL0YsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsaUJBQWlCLEdBQUcsaURBQU8sQ0FBQyxJQUFJLHlCQUF5QjtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsb0VBQXNCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVEQUFTO0FBQ3pCLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQSx3QkFBd0IsNkVBQWdDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxnQkFBZ0Isd0RBQVc7QUFDM0IseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSwyQkFBMkIseURBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixvREFBUSx3QkFBd0IsU0FBUztBQUN2RTtBQUNBO0FBQ0Esc01BQXNNO0FBQ3RNLDRDQUE0QywwSkFBMEo7QUFDdE0saUJBQWlCO0FBQ2pCLHVCQUF1Qix3REFBZ0I7QUFDdkMsYUFBYTtBQUNiLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0EseUJBQXlCLFFBQVEsMkJBQTJCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVEsZUFBZTtBQUM1QztBQUNBO0FBQ0EsZ0JBQWdCLHdEQUFXO0FBQzNCLHlCQUF5QixRQUFRLDJCQUEyQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyQkFBMkI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsdUVBQXlCO0FBQzFGO0FBQ0EsNEJBQTRCLG9EQUFRLHdCQUF3QixTQUFTO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1SUFBdUk7QUFDdkksZ0RBQWdELHVGQUF1RjtBQUN2STtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLDJCQUEyQix3REFBZ0I7QUFDM0MsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25ELDRCQUE0QixvREFBUSx3QkFBd0IsU0FBUztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVJQUF1STtBQUN2STtBQUNBLGdEQUFnRCx1RkFBdUY7QUFDdkkscUJBQXFCO0FBQ3JCLDJCQUEyQix3REFBZ0I7QUFDM0MsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSwwQkFBMEIsb0VBQTJCO0FBQ3JEO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQSx5QkFBeUIsUUFBUSwyQkFBMkI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsUUFBUSxlQUFlO0FBQzVDO0FBQ0E7QUFDQSxnQkFBZ0Isd0RBQVc7QUFDM0IseUJBQXlCLFFBQVEsMkJBQTJCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDJCQUEyQjtBQUNuRCw0QkFBNEIsb0RBQVEsd0JBQXdCLFNBQVM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsdUZBQXVGO0FBQ3ZJLHFCQUFxQjtBQUNyQiwyQkFBMkIsZ0VBQXdCO0FBQ25ELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esd0JBQXdCLDJCQUEyQjtBQUNuRCw0QkFBNEIsb0RBQVEsd0JBQXdCLFNBQVM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsdUZBQXVGO0FBQ3ZJLHFCQUFxQjtBQUNyQiwyQkFBMkIsZ0VBQXdCO0FBQ25ELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsMEJBQTBCLG9FQUEyQjtBQUNyRDtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0EseUJBQXlCLFFBQVEsMkJBQTJCO0FBQzVEO0FBQ0E7QUFDQSx5QkFBeUIsUUFBUSwyQkFBMkIsYUFBYSxzRUFBNkI7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHdDQUF3QywwQkFBMEIsbUNBQW1DO0FBQzNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHdEQUFXO0FBQzNCLHlCQUF5QixRQUFRLDJCQUEyQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esa0NBQWtDLDBEQUFZLGtCQUFrQixnQkFBZ0I7QUFDaEY7QUFDQTtBQUNBLG9CQUFvQixjQUFjLFFBQVEsb0RBQVEsd0JBQXdCLFNBQVM7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsdUJBQXVCLHdEQUFnQjtBQUN2QyxhQUFhO0FBQ2Isa0JBQWtCLDZEQUFlLGtCQUFrQixnQkFBZ0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrQ0FBK0M7QUFDM0UsK0JBQStCLHNFQUE2QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsb0NBQW9DLFdBQVcsc0ZBQXNGO0FBQzFKO0FBQ0E7QUFDQSxnQkFBZ0Isd0RBQVc7QUFDM0IseUJBQXlCLFFBQVEsK0NBQStDO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdEQUFnRDtBQUNwRSw4QkFBOEIsb0RBQVEsd0JBQXdCLFNBQVM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHVGQUF1RjtBQUNuSSxpQkFBaUI7QUFDakIsdUJBQXVCLHdEQUFnQjtBQUN2QyxhQUFhO0FBQ2Isb0JBQW9CLGNBQWM7QUFDbEM7QUFDQSx5QkFBeUIsUUFBUSwyQkFBMkI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDJCQUEyQjtBQUN2RCwrQkFBK0Isc0VBQTZCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsZ0JBQWdCLHdEQUFXO0FBQzNCLHlCQUF5QixRQUFRLDJCQUEyQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckMsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLHVFQUF5QjtBQUMxRjtBQUNBLHdCQUF3QixRQUFRLFFBQVEsb0RBQVEsd0JBQXdCLFNBQVM7QUFDakY7QUFDQTtBQUNBO0FBQ0EsdUlBQXVJO0FBQ3ZJO0FBQ0EsZ0RBQWdELHVGQUF1RjtBQUN2STtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsaUJBQWlCO0FBQ2pCLHlCQUF5QixRQUFRLDJCQUEyQjtBQUM1RDtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6Qyx3QkFBd0IsY0FBYyxRQUFRLG9EQUFRLHdCQUF3QixTQUFTO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBLHVJQUF1STtBQUN2STtBQUNBLGdEQUFnRCx1RkFBdUY7QUFDdkk7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLHlCQUF5QixRQUFRLG1HQUFtRztBQUNwSTtBQUNBLHNCQUFzQixvRUFBMkI7QUFDakQ7QUFDQTtBQUNBLGdCQUFnQix3REFBVztBQUMzQix5QkFBeUIsUUFBUSwyQkFBMkI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYyxRQUFRLG9EQUFRLHdCQUF3QixTQUFTO0FBQ25GO0FBQ0Esb0RBQW9ELGFBQWEsd0JBQXdCLCtCQUErQjtBQUN4SDtBQUNBLHVCQUF1Qix3REFBZ0I7QUFDdkMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixRQUFRLGVBQWU7QUFDNUM7QUFDQTtBQUNBLGdCQUFnQix3REFBVztBQUMzQix5QkFBeUIsUUFBUSwyQkFBMkI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsdUVBQXlCO0FBQ3RGO0FBQ0EseUJBQXlCLG9EQUFRLHdCQUF3QixTQUFTO0FBQ2xFLDhGQUE4Riw4QkFBOEIsaUNBQWlDLGtDQUFrQyx3QkFBd0IsWUFBWSx5SUFBeUk7QUFDNVcsd0JBQXdCLHdCQUF3QjtBQUNoRCxnQ0FBZ0MscUdBQXFHO0FBQ3JJO0FBQ0EsdUJBQXVCLG9EQUFZO0FBQ25DLGFBQWE7QUFDYjtBQUNBO0FBQ0EsZ0JBQWdCLHdEQUFXO0FBQzNCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUSxTQUFTLHlCQUF5QjtBQUNsRTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsZ0VBQXVCO0FBQ3JELHdCQUF3QixRQUFRLFFBQVEsb0RBQVEsdUJBQXVCLFNBQVM7QUFDaEY7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQix5QkFBeUIsUUFBUSwyQkFBMkI7QUFDNUQsYUFBYTtBQUNiO0FBQ0E7QUFDQSxnQkFBZ0Isd0RBQVc7QUFDM0IseUJBQXlCLFFBQVEsMkJBQTJCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxTQUFTO0FBQ3pDO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQyx3QkFBd0IsUUFBUSxRQUFRLG9EQUFRO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHVGQUF1RjtBQUN2SSxxQkFBcUI7QUFDckI7QUFDQSxpQkFBaUI7QUFDakIseUJBQXlCLFFBQVEsMkJBQTJCO0FBQzVEO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DLHdCQUF3QixjQUFjLFFBQVEsb0RBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsdUZBQXVGO0FBQ3ZJLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIseUJBQXlCLFFBQVEsbUdBQW1HO0FBQ3BJO0FBQ0Esc0JBQXNCLG9FQUEyQjtBQUNqRDtBQUNBO0FBQ0EsZ0JBQWdCLHdEQUFXO0FBQzNCLHlCQUF5QixRQUFRLDJCQUEyQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxrQkFBa0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLDJDQUEyQyxnQkFBZ0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QywwREFBWTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFFBQVEsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCwwQkFBMEI7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RCx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHlCQUF5QixRQUFRLHlCQUF5QjtBQUMxRDtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQSx5QkFBeUIsUUFBUSxlQUFlO0FBQ2hEO0FBQ0EscUJBQXFCLFFBQVEsU0FBUztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG9EQUFRLHVCQUF1QixTQUFTO0FBQ3JFO0FBQ0E7QUFDQSwyQkFBMkIscURBQWE7QUFDeEMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsUUFBUSxZQUFZLGFBQWEsZ0VBQXVCO0FBQ3JGO0FBQ0EsNkJBQTZCLG9EQUFRLHVCQUF1QixTQUFTO0FBQ3JFO0FBQ0E7QUFDQSwyQkFBMkIscURBQWE7QUFDeEMsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsZ0JBQWdCLHdEQUFXO0FBQzNCLG9CQUFvQixzRUFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDZEQUFlLGtCQUFrQixnQkFBZ0I7QUFDM0U7QUFDQSx5QkFBeUIsUUFBUSxZQUFZO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0Esd0JBQXdCLHlDQUF5QztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixnRUFBdUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLHVFQUF5QjtBQUMxRjtBQUNBLHdCQUF3Qix5QkFBeUIsUUFBUSxvREFBUSx1QkFBdUIsU0FBUztBQUNqRztBQUNBO0FBQ0Esd0RBQXdELGlCQUFpQiwyRUFBMkU7QUFDcEo7QUFDQSwyQkFBMkIscURBQWE7QUFDeEMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsUUFBUSxvQkFBb0I7QUFDckQsYUFBYTtBQUNiO0FBQ0E7QUFDQSxnQkFBZ0Isd0RBQVc7QUFDM0IseUJBQXlCLFFBQVEsWUFBWTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4REFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZ0VBQXVCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsOERBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUNBQW1DO0FBQzNEO0FBQ0EsNkJBQTZCLFFBQVEsMkJBQTJCO0FBQ2hFO0FBQ0E7QUFDQSw2QkFBNkIsUUFBUSwyQkFBMkI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVEsNkJBQTZCO0FBQzFEO0FBQ0E7QUFDQSxnQkFBZ0Isd0RBQVc7QUFDM0IseUJBQXlCLFFBQVEsMkJBQTJCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGNBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGdFQUF1QjtBQUNyRDtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQSw2QkFBNkIsUUFBUSwyQkFBMkI7QUFDaEU7QUFDQTtBQUNBLDZCQUE2QixRQUFRLDJCQUEyQjtBQUNoRTtBQUNBLHlCQUF5QixRQUFRLDZCQUE2QjtBQUM5RCxhQUFhO0FBQ2I7QUFDQTtBQUNBLGdCQUFnQix3REFBVztBQUMzQix5QkFBeUIsUUFBUSwyQkFBMkI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHVEQUFTO0FBQzFCLDBCQUEwQix1RUFBOEI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsdUVBQThCO0FBQ3hEO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx1RUFBOEI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsdUVBQThCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix1RUFBOEI7QUFDNUQsd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixRQUFRLDJDQUEyQztBQUM1RTtBQUNBLG9CQUFvQiwyR0FBMkc7QUFDL0g7QUFDQSwwQkFBMEIsdUVBQThCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RixrQkFBa0IsZ0NBQWdDLFVBQVU7QUFDMUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixRQUFRLG9DQUFvQztBQUNqRTtBQUNBO0FBQ0EsZ0JBQWdCLHdEQUFXO0FBQzNCLHlCQUF5QixRQUFRLG1DQUFtQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDBEQUFZLGtCQUFrQixnQkFBZ0I7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsaUJBQWlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHFCQUFxQixRQUFRLElBQUksaUJBQWlCO0FBQ2xEO0FBQ0E7QUFDQSxvQkFBb0IsNEJBQTRCO0FBQ2hEO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwyREFBYztBQUN4QztBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDZEQUFlLGtCQUFrQixnQkFBZ0I7QUFDdkU7QUFDQSxxQkFBcUI7QUFDckIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrREFBSTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUSxTQUFTLFdBQVc7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCx1RUFBeUI7QUFDbEY7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG9EQUFRLHdCQUF3QixTQUFTO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHFDQUFxQztBQUNqRixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsZ0JBQWdCLHdEQUFXO0FBQzNCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQSxxQkFBcUIsUUFBUSw2RUFBNkU7QUFDMUc7QUFDQTtBQUNBLGdCQUFnQix3REFBVztBQUMzQix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0Esd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBLDZEQUE2RCxTQUFTO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLDZCQUE2QixvREFBUTtBQUNyQztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsZ0JBQWdCLHVEQUFTO0FBQ3pCO0FBQ0E7QUFDQSxxQkFBcUIsUUFBUSwyRkFBMkY7QUFDeEg7QUFDQTtBQUNBLGdCQUFnQix3REFBVztBQUMzQix5QkFBeUIsUUFBUSwyQ0FBMkM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixvREFBUSwwQkFBMEIsU0FBUyxtQkFBbUIscUJBQXFCO0FBQ2hIO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxnQkFBZ0Isd0RBQVc7QUFDM0IseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCw2QkFBNkI7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdURBQVM7QUFDbEM7QUFDQSwwQkFBMEIsbURBQUssa0NBQWtDO0FBQ2pFO0FBQ0E7QUFDQSw2QkFBNkIsb0RBQVEsd0JBQXdCLFNBQVM7QUFDdEUsNEJBQTRCLDZCQUE2QjtBQUN6RDtBQUNBLDJCQUEyQix3REFBZ0I7QUFDM0MsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0Esb0JBQW9CLHNFQUF5QjtBQUM3QztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix3REFBVztBQUMzQix5QkFBeUIsUUFBUSwyQkFBMkI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsU0FBUztBQUM5RDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFlBQVksdURBQVM7QUFDckI7QUFDQTtBQUNBLGlCQUFpQixRQUFRLGVBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsMERBQVk7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0hBQStILHlEQUFhO0FBQzVJLGlEQUFpRCxpQ0FBaUMseUJBQXlCLHlEQUFhLENBQUM7QUFDekg7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQSw2QkFBNkIsc0VBQXlCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0VBQXVCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsNkJBQTZCO0FBQzdFO0FBQ0E7QUFDQSwwQ0FBMEMsa0RBQVE7QUFDbEQsb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdFQUF1QjtBQUNqRDtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0RBQVc7QUFDM0IsaUNBQWlDO0FBQ2pDLHFCQUFxQixzRUFBeUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxNQUFNO0FBQzFELGdFQUFnRSxVQUFVO0FBQzFFO0FBQ0E7QUFDQSxvREFBb0QsZ0JBQWdCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsZ0NBQWdDLG1CQUFtQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDBEQUFZO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNkRBQWU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVEQUFTO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsd0JBQXdCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDhDQUE4Qyx1QkFBdUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNENBQTRDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlCQUF5QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRLFNBQVMsSUFBSTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0YsZ0JBQWdCLHNCQUFzQiwyQkFBMkIsMkJBQTJCLDZCQUE2QjtBQUN4TjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsbURBQW1ELCtEQUF1QjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx1REFBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxxQkFBcUI7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyw2QkFBNkI7QUFDcEU7QUFDQSwwQ0FBMEMsdUNBQXVDO0FBQ2pGO0FBQ0E7QUFDQSxxQ0FBcUMsbUNBQW1DO0FBQ3hFO0FBQ0E7QUFDQSwrREFBK0QsdUVBQXlCO0FBQ3hGO0FBQ0EsbUNBQW1DLGtDQUFrQztBQUNyRSwwQ0FBMEMsd0NBQXdDO0FBQ2xGLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCw0QkFBNEI7QUFDN0U7QUFDQSxrQkFBa0IsSUFBSSxHQUFHLG9CQUFvQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlDQUF5QztBQUNqRTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLDZCQUE2QixvREFBUSwwQkFBMEIsU0FBUyxXQUFXLGdCQUFnQjtBQUNuRztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsZ0JBQWdCLHdEQUFXO0FBQzNCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlDQUF5QztBQUNqRTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLDZDQUE2QyxvRUFBb0UscUNBQXFDLHNCQUFzQixJQUFJLHVCQUF1QjtBQUN2TSx3QkFBd0IsY0FBYyxRQUFRLG9EQUFRLHdCQUF3QixTQUFTO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsNERBQTRELFFBQVEsa0JBQWtCO0FBQ3RGO0FBQ0EseUJBQXlCO0FBQ3pCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsZ0JBQWdCLHdEQUFXO0FBQzNCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix5Q0FBeUM7QUFDckU7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSw0QkFBNEIsY0FBYyxRQUFRLG9EQUFRLHdCQUF3QixTQUFTLFdBQVcsZ0JBQWdCO0FBQ3RILGdDQUFnQyxxREFBcUQ7QUFDckY7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGlDQUFpQztBQUNqQztBQUNBLDREQUE0RCw2REFBNkQ7QUFDekg7QUFDQSw2QkFBNkI7QUFDN0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxvQkFBb0Isd0RBQVc7QUFDL0IsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix5Q0FBeUM7QUFDckU7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSxpQ0FBaUMsb0RBQVEsd0JBQXdCLFNBQVMsV0FBVyxnQkFBZ0I7QUFDckcsZ0NBQWdDLHlCQUF5QjtBQUN6RDtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esb0JBQW9CLHdEQUFXO0FBQy9CLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2Q0FBNkM7QUFDN0Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRLE1BQU0sc0JBQXNCO0FBQ3BEO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVEsU0FBUyx5QkFBeUI7QUFDbEU7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHVFQUF1RTtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFFBQVEsdURBQXVEO0FBQ3hGLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL1dvbmRlclZpdGUtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL2Rpc3QvbW9kdWxlL0dvVHJ1ZUNsaWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgR29UcnVlQWRtaW5BcGkgZnJvbSAnLi9Hb1RydWVBZG1pbkFwaSc7XG5pbXBvcnQgeyBERUZBVUxUX0hFQURFUlMsIEVYUElSWV9NQVJHSU4sIEdPVFJVRV9VUkwsIFNUT1JBR0VfS0VZIH0gZnJvbSAnLi9saWIvY29uc3RhbnRzJztcbmltcG9ydCB7IEF1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvciwgQXV0aFBLQ0VHcmFudENvZGVFeGNoYW5nZUVycm9yLCBBdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3IsIEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yLCBBdXRoSW52YWxpZFRva2VuUmVzcG9uc2VFcnJvciwgQXV0aFVua25vd25FcnJvciwgaXNBdXRoQXBpRXJyb3IsIGlzQXV0aEVycm9yLCBpc0F1dGhSZXRyeWFibGVGZXRjaEVycm9yLCBpc0F1dGhTZXNzaW9uTWlzc2luZ0Vycm9yLCBpc0F1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvciwgfSBmcm9tICcuL2xpYi9lcnJvcnMnO1xuaW1wb3J0IHsgX3JlcXVlc3QsIF9zZXNzaW9uUmVzcG9uc2UsIF9zZXNzaW9uUmVzcG9uc2VQYXNzd29yZCwgX3VzZXJSZXNwb25zZSwgX3Nzb1Jlc3BvbnNlLCB9IGZyb20gJy4vbGliL2ZldGNoJztcbmltcG9ydCB7IGRlY29kZUpXVFBheWxvYWQsIERlZmVycmVkLCBnZXRJdGVtQXN5bmMsIGlzQnJvd3NlciwgcmVtb3ZlSXRlbUFzeW5jLCByZXNvbHZlRmV0Y2gsIHNldEl0ZW1Bc3luYywgdXVpZCwgcmV0cnlhYmxlLCBzbGVlcCwgc3VwcG9ydHNMb2NhbFN0b3JhZ2UsIHBhcnNlUGFyYW1ldGVyc0Zyb21VUkwsIGdldENvZGVDaGFsbGVuZ2VBbmRNZXRob2QsIH0gZnJvbSAnLi9saWIvaGVscGVycyc7XG5pbXBvcnQgeyBsb2NhbFN0b3JhZ2VBZGFwdGVyLCBtZW1vcnlMb2NhbFN0b3JhZ2VBZGFwdGVyIH0gZnJvbSAnLi9saWIvbG9jYWwtc3RvcmFnZSc7XG5pbXBvcnQgeyBwb2x5ZmlsbEdsb2JhbFRoaXMgfSBmcm9tICcuL2xpYi9wb2x5ZmlsbHMnO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gJy4vbGliL3ZlcnNpb24nO1xuaW1wb3J0IHsgTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IsIG5hdmlnYXRvckxvY2sgfSBmcm9tICcuL2xpYi9sb2Nrcyc7XG5wb2x5ZmlsbEdsb2JhbFRoaXMoKTsgLy8gTWFrZSBcImdsb2JhbFRoaXNcIiBhdmFpbGFibGVcbmNvbnN0IERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgICB1cmw6IEdPVFJVRV9VUkwsXG4gICAgc3RvcmFnZUtleTogU1RPUkFHRV9LRVksXG4gICAgYXV0b1JlZnJlc2hUb2tlbjogdHJ1ZSxcbiAgICBwZXJzaXN0U2Vzc2lvbjogdHJ1ZSxcbiAgICBkZXRlY3RTZXNzaW9uSW5Vcmw6IHRydWUsXG4gICAgaGVhZGVyczogREVGQVVMVF9IRUFERVJTLFxuICAgIGZsb3dUeXBlOiAnaW1wbGljaXQnLFxuICAgIGRlYnVnOiBmYWxzZSxcbiAgICBoYXNDdXN0b21BdXRob3JpemF0aW9uSGVhZGVyOiBmYWxzZSxcbn07XG4vKiogQ3VycmVudCBzZXNzaW9uIHdpbGwgYmUgY2hlY2tlZCBmb3IgcmVmcmVzaCBhdCB0aGlzIGludGVydmFsLiAqL1xuY29uc3QgQVVUT19SRUZSRVNIX1RJQ0tfRFVSQVRJT04gPSAzMCAqIDEwMDA7XG4vKipcbiAqIEEgdG9rZW4gcmVmcmVzaCB3aWxsIGJlIGF0dGVtcHRlZCB0aGlzIG1hbnkgdGlja3MgYmVmb3JlIHRoZSBjdXJyZW50IHNlc3Npb24gZXhwaXJlcy4gKi9cbmNvbnN0IEFVVE9fUkVGUkVTSF9USUNLX1RIUkVTSE9MRCA9IDM7XG5hc3luYyBmdW5jdGlvbiBsb2NrTm9PcChuYW1lLCBhY3F1aXJlVGltZW91dCwgZm4pIHtcbiAgICByZXR1cm4gYXdhaXQgZm4oKTtcbn1cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdvVHJ1ZUNsaWVudCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGNsaWVudCBmb3IgdXNlIGluIHRoZSBicm93c2VyLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy5tZW1vcnlTdG9yYWdlID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZUVtaXR0ZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmF1dG9SZWZyZXNoVGlja2VyID0gbnVsbDtcbiAgICAgICAgdGhpcy52aXNpYmlsaXR5Q2hhbmdlZENhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZWZyZXNoaW5nRGVmZXJyZWQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogS2VlcHMgdHJhY2sgb2YgdGhlIGFzeW5jIGNsaWVudCBpbml0aWFsaXphdGlvbi5cbiAgICAgICAgICogV2hlbiBudWxsIG9yIG5vdCB5ZXQgcmVzb2x2ZWQgdGhlIGF1dGggc3RhdGUgaXMgYHVua25vd25gXG4gICAgICAgICAqIE9uY2UgcmVzb2x2ZWQgdGhlIHRoZSBhdXRoIHN0YXRlIGlzIGtub3duIGFuZCBpdCdzIHNhdmUgdG8gY2FsbCBhbnkgZnVydGhlciBjbGllbnQgbWV0aG9kcy5cbiAgICAgICAgICogS2VlcCBleHRyYSBjYXJlIHRvIG5ldmVyIHJlamVjdCBvciB0aHJvdyB1bmNhdWdodCBlcnJvcnNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZVByb21pc2UgPSBudWxsO1xuICAgICAgICB0aGlzLmRldGVjdFNlc3Npb25JblVybCA9IHRydWU7XG4gICAgICAgIHRoaXMuaGFzQ3VzdG9tQXV0aG9yaXphdGlvbkhlYWRlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN1cHByZXNzR2V0U2Vzc2lvbldhcm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sb2NrQWNxdWlyZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wZW5kaW5nSW5Mb2NrID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2VkIHRvIGJyb2FkY2FzdCBzdGF0ZSBjaGFuZ2UgZXZlbnRzIHRvIG90aGVyIHRhYnMgbGlzdGVuaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5icm9hZGNhc3RDaGFubmVsID0gbnVsbDtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBjb25zb2xlLmxvZztcbiAgICAgICAgdGhpcy5pbnN0YW5jZUlEID0gR29UcnVlQ2xpZW50Lm5leHRJbnN0YW5jZUlEO1xuICAgICAgICBHb1RydWVDbGllbnQubmV4dEluc3RhbmNlSUQgKz0gMTtcbiAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2VJRCA+IDAgJiYgaXNCcm93c2VyKCkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignTXVsdGlwbGUgR29UcnVlQ2xpZW50IGluc3RhbmNlcyBkZXRlY3RlZCBpbiB0aGUgc2FtZSBicm93c2VyIGNvbnRleHQuIEl0IGlzIG5vdCBhbiBlcnJvciwgYnV0IHRoaXMgc2hvdWxkIGJlIGF2b2lkZWQgYXMgaXQgbWF5IHByb2R1Y2UgdW5kZWZpbmVkIGJlaGF2aW9yIHdoZW4gdXNlZCBjb25jdXJyZW50bHkgdW5kZXIgdGhlIHNhbWUgc3RvcmFnZSBrZXkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUyksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmxvZ0RlYnVnTWVzc2FnZXMgPSAhIXNldHRpbmdzLmRlYnVnO1xuICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzLmRlYnVnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlciA9IHNldHRpbmdzLmRlYnVnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGVyc2lzdFNlc3Npb24gPSBzZXR0aW5ncy5wZXJzaXN0U2Vzc2lvbjtcbiAgICAgICAgdGhpcy5zdG9yYWdlS2V5ID0gc2V0dGluZ3Muc3RvcmFnZUtleTtcbiAgICAgICAgdGhpcy5hdXRvUmVmcmVzaFRva2VuID0gc2V0dGluZ3MuYXV0b1JlZnJlc2hUb2tlbjtcbiAgICAgICAgdGhpcy5hZG1pbiA9IG5ldyBHb1RydWVBZG1pbkFwaSh7XG4gICAgICAgICAgICB1cmw6IHNldHRpbmdzLnVybCxcbiAgICAgICAgICAgIGhlYWRlcnM6IHNldHRpbmdzLmhlYWRlcnMsXG4gICAgICAgICAgICBmZXRjaDogc2V0dGluZ3MuZmV0Y2gsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVybCA9IHNldHRpbmdzLnVybDtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gc2V0dGluZ3MuaGVhZGVycztcbiAgICAgICAgdGhpcy5mZXRjaCA9IHJlc29sdmVGZXRjaChzZXR0aW5ncy5mZXRjaCk7XG4gICAgICAgIHRoaXMubG9jayA9IHNldHRpbmdzLmxvY2sgfHwgbG9ja05vT3A7XG4gICAgICAgIHRoaXMuZGV0ZWN0U2Vzc2lvbkluVXJsID0gc2V0dGluZ3MuZGV0ZWN0U2Vzc2lvbkluVXJsO1xuICAgICAgICB0aGlzLmZsb3dUeXBlID0gc2V0dGluZ3MuZmxvd1R5cGU7XG4gICAgICAgIHRoaXMuaGFzQ3VzdG9tQXV0aG9yaXphdGlvbkhlYWRlciA9IHNldHRpbmdzLmhhc0N1c3RvbUF1dGhvcml6YXRpb25IZWFkZXI7XG4gICAgICAgIGlmIChzZXR0aW5ncy5sb2NrKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2sgPSBzZXR0aW5ncy5sb2NrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQnJvd3NlcigpICYmICgoX2EgPSBnbG9iYWxUaGlzID09PSBudWxsIHx8IGdsb2JhbFRoaXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdsb2JhbFRoaXMubmF2aWdhdG9yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubG9ja3MpKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2sgPSBuYXZpZ2F0b3JMb2NrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sb2NrID0gbG9ja05vT3A7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZmEgPSB7XG4gICAgICAgICAgICB2ZXJpZnk6IHRoaXMuX3ZlcmlmeS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgZW5yb2xsOiB0aGlzLl9lbnJvbGwuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIHVuZW5yb2xsOiB0aGlzLl91bmVucm9sbC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgY2hhbGxlbmdlOiB0aGlzLl9jaGFsbGVuZ2UuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGxpc3RGYWN0b3JzOiB0aGlzLl9saXN0RmFjdG9ycy5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgY2hhbGxlbmdlQW5kVmVyaWZ5OiB0aGlzLl9jaGFsbGVuZ2VBbmRWZXJpZnkuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGdldEF1dGhlbnRpY2F0b3JBc3N1cmFuY2VMZXZlbDogdGhpcy5fZ2V0QXV0aGVudGljYXRvckFzc3VyYW5jZUxldmVsLmJpbmQodGhpcyksXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLnBlcnNpc3RTZXNzaW9uKSB7XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3Muc3RvcmFnZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcmFnZSA9IHNldHRpbmdzLnN0b3JhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoc3VwcG9ydHNMb2NhbFN0b3JhZ2UoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3JhZ2UgPSBsb2NhbFN0b3JhZ2VBZGFwdGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZW1vcnlTdG9yYWdlID0ge307XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcmFnZSA9IG1lbW9yeUxvY2FsU3RvcmFnZUFkYXB0ZXIodGhpcy5tZW1vcnlTdG9yYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1lbW9yeVN0b3JhZ2UgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZSA9IG1lbW9yeUxvY2FsU3RvcmFnZUFkYXB0ZXIodGhpcy5tZW1vcnlTdG9yYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNCcm93c2VyKCkgJiYgZ2xvYmFsVGhpcy5Ccm9hZGNhc3RDaGFubmVsICYmIHRoaXMucGVyc2lzdFNlc3Npb24gJiYgdGhpcy5zdG9yYWdlS2V5KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0Q2hhbm5lbCA9IG5ldyBnbG9iYWxUaGlzLkJyb2FkY2FzdENoYW5uZWwodGhpcy5zdG9yYWdlS2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGNyZWF0ZSBhIG5ldyBCcm9hZGNhc3RDaGFubmVsLCBtdWx0aS10YWIgc3RhdGUgY2hhbmdlcyB3aWxsIG5vdCBiZSBhdmFpbGFibGUnLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChfYiA9IHRoaXMuYnJvYWRjYXN0Q2hhbm5lbCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygncmVjZWl2ZWQgYnJvYWRjYXN0IG5vdGlmaWNhdGlvbiBmcm9tIG90aGVyIHRhYiBvciBjbGllbnQnLCBldmVudCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoZXZlbnQuZGF0YS5ldmVudCwgZXZlbnQuZGF0YS5zZXNzaW9uLCBmYWxzZSk7IC8vIGJyb2FkY2FzdCA9IGZhbHNlIHNvIHdlIGRvbid0IGdldCBhbiBlbmRsZXNzIGxvb3Agb2YgbWVzc2FnZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgIH1cbiAgICBfZGVidWcoLi4uYXJncykge1xuICAgICAgICBpZiAodGhpcy5sb2dEZWJ1Z01lc3NhZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlcihgR29UcnVlQ2xpZW50QCR7dGhpcy5pbnN0YW5jZUlEfSAoJHt2ZXJzaW9ufSkgJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9YCwgLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBjbGllbnQgc2Vzc2lvbiBlaXRoZXIgZnJvbSB0aGUgdXJsIG9yIGZyb20gc3RvcmFnZS5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBhdXRvbWF0aWNhbGx5IGNhbGxlZCB3aGVuIGluc3RhbnRpYXRpbmcgdGhlIGNsaWVudCwgYnV0IHNob3VsZCBhbHNvIGJlIGNhbGxlZFxuICAgICAqIG1hbnVhbGx5IHdoZW4gY2hlY2tpbmcgZm9yIGFuIGVycm9yIGZyb20gYW4gYXV0aCByZWRpcmVjdCAob2F1dGgsIG1hZ2ljbGluaywgcGFzc3dvcmQgcmVjb3ZlcnksIGV0YykuXG4gICAgICovXG4gICAgYXN5bmMgaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5pdGlhbGl6ZVByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZVByb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2FjcXVpcmVMb2NrKC0xLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2luaXRpYWxpemUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KSgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSU1QT1JUQU5UOlxuICAgICAqIDEuIE5ldmVyIHRocm93IGluIHRoaXMgbWV0aG9kLCBhcyBpdCBpcyBjYWxsZWQgZnJvbSB0aGUgY29uc3RydWN0b3JcbiAgICAgKiAyLiBOZXZlciByZXR1cm4gYSBzZXNzaW9uIGZyb20gdGhpcyBtZXRob2QgYXMgaXQgd291bGQgYmUgY2FjaGVkIG92ZXJcbiAgICAgKiAgICB0aGUgd2hvbGUgbGlmZXRpbWUgb2YgdGhlIGNsaWVudFxuICAgICAqL1xuICAgIGFzeW5jIF9pbml0aWFsaXplKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBwYXJzZVBhcmFtZXRlcnNGcm9tVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgICAgIGxldCBjYWxsYmFja1VybFR5cGUgPSAnbm9uZSc7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNJbXBsaWNpdEdyYW50Q2FsbGJhY2socGFyYW1zKSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrVXJsVHlwZSA9ICdpbXBsaWNpdCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhd2FpdCB0aGlzLl9pc1BLQ0VDYWxsYmFjayhwYXJhbXMpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tVcmxUeXBlID0gJ3BrY2UnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBdHRlbXB0IHRvIGdldCB0aGUgc2Vzc2lvbiBmcm9tIHRoZSBVUkwgb25seSBpZiB0aGVzZSBjb25kaXRpb25zIGFyZSBmdWxmaWxsZWRcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBOb3RlOiBJZiB0aGUgVVJMIGlzbid0IG9uZSBvZiB0aGUgY2FsbGJhY2sgdXJsIHR5cGVzIChpbXBsaWNpdCBvciBwa2NlKSxcbiAgICAgICAgICAgICAqIHRoZW4gdGhlcmUgY291bGQgYmUgYW4gZXhpc3Rpbmcgc2Vzc2lvbiBzbyB3ZSBkb24ndCB3YW50IHRvIHByZW1hdHVyZWx5IHJlbW92ZSBpdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoaXNCcm93c2VyKCkgJiYgdGhpcy5kZXRlY3RTZXNzaW9uSW5VcmwgJiYgY2FsbGJhY2tVcmxUeXBlICE9PSAnbm9uZScpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCB0aGlzLl9nZXRTZXNzaW9uRnJvbVVSTChwYXJhbXMsIGNhbGxiYWNrVXJsVHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX2luaXRpYWxpemUoKScsICdlcnJvciBkZXRlY3Rpbmcgc2Vzc2lvbiBmcm9tIFVSTCcsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JDb2RlID0gKF9hID0gZXJyb3IuZGV0YWlscykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JDb2RlID09PSAnaWRlbnRpdHlfYWxyZWFkeV9leGlzdHMnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JDb2RlID09PSAnaWRlbnRpdHlfbm90X2ZvdW5kJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yQ29kZSA9PT0gJ3NpbmdsZV9pZGVudGl0eV9ub3RfZGVsZXRhYmxlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGVycm9yIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gZmFpbGVkIGxvZ2luIGF0dGVtcHQgdmlhIHVybCxcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIG9sZCBzZXNzaW9uIGFzIGluIHZlcmlmeU90cCwgc2lnblVwIGFuZCBzaWduSW5XaXRoKlxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9yZW1vdmVTZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgc2Vzc2lvbiwgcmVkaXJlY3RUeXBlIH0gPSBkYXRhO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX2luaXRpYWxpemUoKScsICdkZXRlY3RlZCBzZXNzaW9uIGluIFVSTCcsIHNlc3Npb24sICdyZWRpcmVjdCB0eXBlJywgcmVkaXJlY3RUeXBlKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihzZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlZGlyZWN0VHlwZSA9PT0gJ3JlY292ZXJ5Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1BBU1NXT1JEX1JFQ09WRVJZJywgc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbm8gbG9naW4gYXR0ZW1wdCB2aWEgY2FsbGJhY2sgdXJsIHRyeSB0byByZWNvdmVyIHNlc3Npb24gZnJvbSBzdG9yYWdlXG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9yZWNvdmVyQW5kUmVmcmVzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBlcnJvcjogbmV3IEF1dGhVbmtub3duRXJyb3IoJ1VuZXhwZWN0ZWQgZXJyb3IgZHVyaW5nIGluaXRpYWxpemF0aW9uJywgZXJyb3IpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2hhbmRsZVZpc2liaWxpdHlDaGFuZ2UoKTtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX2luaXRpYWxpemUoKScsICdlbmQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGFub255bW91cyB1c2VyLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBzZXNzaW9uIHdoZXJlIHRoZSBpc19hbm9ueW1vdXMgY2xhaW0gaW4gdGhlIGFjY2VzcyB0b2tlbiBKV1Qgc2V0IHRvIHRydWVcbiAgICAgKi9cbiAgICBhc3luYyBzaWduSW5Bbm9ueW1vdXNseShjcmVkZW50aWFscykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3NpZ251cGAsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiAoX2IgPSAoX2EgPSBjcmVkZW50aWFscyA9PT0gbnVsbCB8fCBjcmVkZW50aWFscyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3JlZGVudGlhbHMub3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRhdGEpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHt9LFxuICAgICAgICAgICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiAoX2MgPSBjcmVkZW50aWFscyA9PT0gbnVsbCB8fCBjcmVkZW50aWFscyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3JlZGVudGlhbHMub3B0aW9ucykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhcHRjaGFUb2tlbiB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgeGZvcm06IF9zZXNzaW9uUmVzcG9uc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IHJlcztcbiAgICAgICAgICAgIGlmIChlcnJvciB8fCAhZGF0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb24gPSBkYXRhLnNlc3Npb247XG4gICAgICAgICAgICBjb25zdCB1c2VyID0gZGF0YS51c2VyO1xuICAgICAgICAgICAgaWYgKGRhdGEuc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKGRhdGEuc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1NJR05FRF9JTicsIHNlc3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyLCBzZXNzaW9uIH0sIGVycm9yOiBudWxsIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHVzZXIuXG4gICAgICpcbiAgICAgKiBCZSBhd2FyZSB0aGF0IGlmIGEgdXNlciBhY2NvdW50IGV4aXN0cyBpbiB0aGUgc3lzdGVtIHlvdSBtYXkgZ2V0IGJhY2sgYW5cbiAgICAgKiBlcnJvciBtZXNzYWdlIHRoYXQgYXR0ZW1wdHMgdG8gaGlkZSB0aGlzIGluZm9ybWF0aW9uIGZyb20gdGhlIHVzZXIuXG4gICAgICogVGhpcyBtZXRob2QgaGFzIHN1cHBvcnQgZm9yIFBLQ0UgdmlhIGVtYWlsIHNpZ251cHMuIFRoZSBQS0NFIGZsb3cgY2Fubm90IGJlIHVzZWQgd2hlbiBhdXRvY29uZmlybSBpcyBlbmFibGVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBsb2dnZWQtaW4gc2Vzc2lvbiBpZiB0aGUgc2VydmVyIGhhcyBcImF1dG9jb25maXJtXCIgT05cbiAgICAgKiBAcmV0dXJucyBBIHVzZXIgaWYgdGhlIHNlcnZlciBoYXMgXCJhdXRvY29uZmlybVwiIE9GRlxuICAgICAqL1xuICAgIGFzeW5jIHNpZ25VcChjcmVkZW50aWFscykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCByZXM7XG4gICAgICAgICAgICBpZiAoJ2VtYWlsJyBpbiBjcmVkZW50aWFscykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZW1haWwsIHBhc3N3b3JkLCBvcHRpb25zIH0gPSBjcmVkZW50aWFscztcbiAgICAgICAgICAgICAgICBsZXQgY29kZUNoYWxsZW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IGNvZGVDaGFsbGVuZ2VNZXRob2QgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZsb3dUeXBlID09PSAncGtjZScpIHtcbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICBbY29kZUNoYWxsZW5nZSwgY29kZUNoYWxsZW5nZU1ldGhvZF0gPSBhd2FpdCBnZXRDb2RlQ2hhbGxlbmdlQW5kTWV0aG9kKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vc2lnbnVwYCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIHJlZGlyZWN0VG86IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5lbWFpbFJlZGlyZWN0VG8sXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtYWlsLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFzc3dvcmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGF0YSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlX2NoYWxsZW5nZTogY29kZUNoYWxsZW5nZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVfY2hhbGxlbmdlX21ldGhvZDogY29kZUNoYWxsZW5nZU1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgeGZvcm06IF9zZXNzaW9uUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgncGhvbmUnIGluIGNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwaG9uZSwgcGFzc3dvcmQsIG9wdGlvbnMgfSA9IGNyZWRlbnRpYWxzO1xuICAgICAgICAgICAgICAgIHJlcyA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3NpZ251cGAsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwaG9uZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhc3N3b3JkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogKF9iID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRhdGEpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbDogKF9jID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNoYW5uZWwpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6ICdzbXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNhcHRjaGFUb2tlbiB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB4Zm9ybTogX3Nlc3Npb25SZXNwb25zZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3IoJ1lvdSBtdXN0IHByb3ZpZGUgZWl0aGVyIGFuIGVtYWlsIG9yIHBob25lIG51bWJlciBhbmQgYSBwYXNzd29yZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gcmVzO1xuICAgICAgICAgICAgaWYgKGVycm9yIHx8ICFkYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yOiBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IGRhdGEuc2Vzc2lvbjtcbiAgICAgICAgICAgIGNvbnN0IHVzZXIgPSBkYXRhLnVzZXI7XG4gICAgICAgICAgICBpZiAoZGF0YS5zZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgc2Vzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXIsIHNlc3Npb24gfSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZyBpbiBhbiBleGlzdGluZyB1c2VyIHdpdGggYW4gZW1haWwgYW5kIHBhc3N3b3JkIG9yIHBob25lIGFuZCBwYXNzd29yZC5cbiAgICAgKlxuICAgICAqIEJlIGF3YXJlIHRoYXQgeW91IG1heSBnZXQgYmFjayBhbiBlcnJvciBtZXNzYWdlIHRoYXQgd2lsbCBub3QgZGlzdGluZ3Vpc2hcbiAgICAgKiBiZXR3ZWVuIHRoZSBjYXNlcyB3aGVyZSB0aGUgYWNjb3VudCBkb2VzIG5vdCBleGlzdCBvciB0aGF0IHRoZVxuICAgICAqIGVtYWlsL3Bob25lIGFuZCBwYXNzd29yZCBjb21iaW5hdGlvbiBpcyB3cm9uZyBvciB0aGF0IHRoZSBhY2NvdW50IGNhbiBvbmx5XG4gICAgICogYmUgYWNjZXNzZWQgdmlhIHNvY2lhbCBsb2dpbi5cbiAgICAgKi9cbiAgICBhc3luYyBzaWduSW5XaXRoUGFzc3dvcmQoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCByZXM7XG4gICAgICAgICAgICBpZiAoJ2VtYWlsJyBpbiBjcmVkZW50aWFscykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZW1haWwsIHBhc3N3b3JkLCBvcHRpb25zIH0gPSBjcmVkZW50aWFscztcbiAgICAgICAgICAgICAgICByZXMgPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS90b2tlbj9ncmFudF90eXBlPXBhc3N3b3JkYCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtYWlsLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFzc3dvcmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlUGFzc3dvcmQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgncGhvbmUnIGluIGNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwaG9uZSwgcGFzc3dvcmQsIG9wdGlvbnMgfSA9IGNyZWRlbnRpYWxzO1xuICAgICAgICAgICAgICAgIHJlcyA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3Rva2VuP2dyYW50X3R5cGU9cGFzc3dvcmRgLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGhvbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXNzd29yZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgeGZvcm06IF9zZXNzaW9uUmVzcG9uc2VQYXNzd29yZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3IoJ1lvdSBtdXN0IHByb3ZpZGUgZWl0aGVyIGFuIGVtYWlsIG9yIHBob25lIG51bWJlciBhbmQgYSBwYXNzd29yZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gcmVzO1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghZGF0YSB8fCAhZGF0YS5zZXNzaW9uIHx8ICFkYXRhLnVzZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3I6IG5ldyBBdXRoSW52YWxpZFRva2VuUmVzcG9uc2VFcnJvcigpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS5zZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7IHVzZXI6IGRhdGEudXNlciwgc2Vzc2lvbjogZGF0YS5zZXNzaW9uIH0sIChkYXRhLndlYWtfcGFzc3dvcmQgPyB7IHdlYWtQYXNzd29yZDogZGF0YS53ZWFrX3Bhc3N3b3JkIH0gOiBudWxsKSksXG4gICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9nIGluIGFuIGV4aXN0aW5nIHVzZXIgdmlhIGEgdGhpcmQtcGFydHkgcHJvdmlkZXIuXG4gICAgICogVGhpcyBtZXRob2Qgc3VwcG9ydHMgdGhlIFBLQ0UgZmxvdy5cbiAgICAgKi9cbiAgICBhc3luYyBzaWduSW5XaXRoT0F1dGgoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5faGFuZGxlUHJvdmlkZXJTaWduSW4oY3JlZGVudGlhbHMucHJvdmlkZXIsIHtcbiAgICAgICAgICAgIHJlZGlyZWN0VG86IChfYSA9IGNyZWRlbnRpYWxzLm9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWRpcmVjdFRvLFxuICAgICAgICAgICAgc2NvcGVzOiAoX2IgPSBjcmVkZW50aWFscy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2NvcGVzLFxuICAgICAgICAgICAgcXVlcnlQYXJhbXM6IChfYyA9IGNyZWRlbnRpYWxzLm9wdGlvbnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5xdWVyeVBhcmFtcyxcbiAgICAgICAgICAgIHNraXBCcm93c2VyUmVkaXJlY3Q6IChfZCA9IGNyZWRlbnRpYWxzLm9wdGlvbnMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5za2lwQnJvd3NlclJlZGlyZWN0LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9nIGluIGFuIGV4aXN0aW5nIHVzZXIgYnkgZXhjaGFuZ2luZyBhbiBBdXRoIENvZGUgaXNzdWVkIGR1cmluZyB0aGUgUEtDRSBmbG93LlxuICAgICAqL1xuICAgIGFzeW5jIGV4Y2hhbmdlQ29kZUZvclNlc3Npb24oYXV0aENvZGUpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjcXVpcmVMb2NrKC0xLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXhjaGFuZ2VDb2RlRm9yU2Vzc2lvbihhdXRoQ29kZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBfZXhjaGFuZ2VDb2RlRm9yU2Vzc2lvbihhdXRoQ29kZSkge1xuICAgICAgICBjb25zdCBzdG9yYWdlSXRlbSA9IGF3YWl0IGdldEl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIGAke3RoaXMuc3RvcmFnZUtleX0tY29kZS12ZXJpZmllcmApO1xuICAgICAgICBjb25zdCBbY29kZVZlcmlmaWVyLCByZWRpcmVjdFR5cGVdID0gKHN0b3JhZ2VJdGVtICE9PSBudWxsICYmIHN0b3JhZ2VJdGVtICE9PSB2b2lkIDAgPyBzdG9yYWdlSXRlbSA6ICcnKS5zcGxpdCgnLycpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vdG9rZW4/Z3JhbnRfdHlwZT1wa2NlYCwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgICAgIGF1dGhfY29kZTogYXV0aENvZGUsXG4gICAgICAgICAgICAgICAgICAgIGNvZGVfdmVyaWZpZXI6IGNvZGVWZXJpZmllcixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByZW1vdmVJdGVtQXN5bmModGhpcy5zdG9yYWdlLCBgJHt0aGlzLnN0b3JhZ2VLZXl9LWNvZGUtdmVyaWZpZXJgKTtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLnNlc3Npb24gfHwgIWRhdGEudXNlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCwgcmVkaXJlY3RUeXBlOiBudWxsIH0sXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBuZXcgQXV0aEludmFsaWRUb2tlblJlc3BvbnNlRXJyb3IoKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEuc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKGRhdGEuc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1NJR05FRF9JTicsIGRhdGEuc2Vzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRhdGEpLCB7IHJlZGlyZWN0VHlwZTogcmVkaXJlY3RUeXBlICE9PSBudWxsICYmIHJlZGlyZWN0VHlwZSAhPT0gdm9pZCAwID8gcmVkaXJlY3RUeXBlIDogbnVsbCB9KSwgZXJyb3IgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwsIHJlZGlyZWN0VHlwZTogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxsb3dzIHNpZ25pbmcgaW4gd2l0aCBhbiBPSURDIElEIHRva2VuLiBUaGUgYXV0aGVudGljYXRpb24gcHJvdmlkZXIgdXNlZFxuICAgICAqIHNob3VsZCBiZSBlbmFibGVkIGFuZCBjb25maWd1cmVkLlxuICAgICAqL1xuICAgIGFzeW5jIHNpZ25JbldpdGhJZFRva2VuKGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IG9wdGlvbnMsIHByb3ZpZGVyLCB0b2tlbiwgYWNjZXNzX3Rva2VuLCBub25jZSB9ID0gY3JlZGVudGlhbHM7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS90b2tlbj9ncmFudF90eXBlPWlkX3Rva2VuYCwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyLFxuICAgICAgICAgICAgICAgICAgICBpZF90b2tlbjogdG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIGFjY2Vzc190b2tlbixcbiAgICAgICAgICAgICAgICAgICAgbm9uY2UsXG4gICAgICAgICAgICAgICAgICAgIGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSByZXM7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFkYXRhIHx8ICFkYXRhLnNlc3Npb24gfHwgIWRhdGEudXNlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogbmV3IEF1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yKCksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhLnNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihkYXRhLnNlc3Npb24pO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdTSUdORURfSU4nLCBkYXRhLnNlc3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3IgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZyBpbiBhIHVzZXIgdXNpbmcgbWFnaWNsaW5rIG9yIGEgb25lLXRpbWUgcGFzc3dvcmQgKE9UUCkuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgYHt7IC5Db25maXJtYXRpb25VUkwgfX1gIHZhcmlhYmxlIGlzIHNwZWNpZmllZCBpbiB0aGUgZW1haWwgdGVtcGxhdGUsIGEgbWFnaWNsaW5rIHdpbGwgYmUgc2VudC5cbiAgICAgKiBJZiB0aGUgYHt7IC5Ub2tlbiB9fWAgdmFyaWFibGUgaXMgc3BlY2lmaWVkIGluIHRoZSBlbWFpbCB0ZW1wbGF0ZSwgYW4gT1RQIHdpbGwgYmUgc2VudC5cbiAgICAgKiBJZiB5b3UncmUgdXNpbmcgcGhvbmUgc2lnbi1pbnMsIG9ubHkgYW4gT1RQIHdpbGwgYmUgc2VudC4gWW91IHdvbid0IGJlIGFibGUgdG8gc2VuZCBhIG1hZ2ljbGluayBmb3IgcGhvbmUgc2lnbi1pbnMuXG4gICAgICpcbiAgICAgKiBCZSBhd2FyZSB0aGF0IHlvdSBtYXkgZ2V0IGJhY2sgYW4gZXJyb3IgbWVzc2FnZSB0aGF0IHdpbGwgbm90IGRpc3Rpbmd1aXNoXG4gICAgICogYmV0d2VlbiB0aGUgY2FzZXMgd2hlcmUgdGhlIGFjY291bnQgZG9lcyBub3QgZXhpc3Qgb3IsIHRoYXQgdGhlIGFjY291bnRcbiAgICAgKiBjYW4gb25seSBiZSBhY2Nlc3NlZCB2aWEgc29jaWFsIGxvZ2luLlxuICAgICAqXG4gICAgICogRG8gbm90ZSB0aGF0IHlvdSB3aWxsIG5lZWQgdG8gY29uZmlndXJlIGEgV2hhdHNhcHAgc2VuZGVyIG9uIFR3aWxpb1xuICAgICAqIGlmIHlvdSBhcmUgdXNpbmcgcGhvbmUgc2lnbiBpbiB3aXRoIHRoZSAnd2hhdHNhcHAnIGNoYW5uZWwuIFRoZSB3aGF0c2FwcFxuICAgICAqIGNoYW5uZWwgaXMgbm90IHN1cHBvcnRlZCBvbiBvdGhlciBwcm92aWRlcnNcbiAgICAgKiBhdCB0aGlzIHRpbWUuXG4gICAgICogVGhpcyBtZXRob2Qgc3VwcG9ydHMgUEtDRSB3aGVuIGFuIGVtYWlsIGlzIHBhc3NlZC5cbiAgICAgKi9cbiAgICBhc3luYyBzaWduSW5XaXRoT3RwKGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoJ2VtYWlsJyBpbiBjcmVkZW50aWFscykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZW1haWwsIG9wdGlvbnMgfSA9IGNyZWRlbnRpYWxzO1xuICAgICAgICAgICAgICAgIGxldCBjb2RlQ2hhbGxlbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBsZXQgY29kZUNoYWxsZW5nZU1ldGhvZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmxvd1R5cGUgPT09ICdwa2NlJykge1xuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgIFtjb2RlQ2hhbGxlbmdlLCBjb2RlQ2hhbGxlbmdlTWV0aG9kXSA9IGF3YWl0IGdldENvZGVDaGFsbGVuZ2VBbmRNZXRob2QodGhpcy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9vdHBgLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW1haWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGF0YSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVfdXNlcjogKF9iID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNob3VsZENyZWF0ZVVzZXIpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlX2NoYWxsZW5nZTogY29kZUNoYWxsZW5nZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVfY2hhbGxlbmdlX21ldGhvZDogY29kZUNoYWxsZW5nZU1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcmVkaXJlY3RUbzogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmVtYWlsUmVkaXJlY3RUbyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgncGhvbmUnIGluIGNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwaG9uZSwgb3B0aW9ucyB9ID0gY3JlZGVudGlhbHM7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vb3RwYCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBob25lLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogKF9jID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRhdGEpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlX3VzZXI6IChfZCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaG91bGRDcmVhdGVVc2VyKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNhcHRjaGFUb2tlbiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbDogKF9lID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNoYW5uZWwpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6ICdzbXMnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCwgbWVzc2FnZUlkOiBkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGEubWVzc2FnZV9pZCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhJbnZhbGlkQ3JlZGVudGlhbHNFcnJvcignWW91IG11c3QgcHJvdmlkZSBlaXRoZXIgYW4gZW1haWwgb3IgcGhvbmUgbnVtYmVyLicpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9nIGluIGEgdXNlciBnaXZlbiBhIFVzZXIgc3VwcGxpZWQgT1RQIG9yIFRva2VuSGFzaCByZWNlaXZlZCB0aHJvdWdoIG1vYmlsZSBvciBlbWFpbC5cbiAgICAgKi9cbiAgICBhc3luYyB2ZXJpZnlPdHAocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgcmVkaXJlY3RUbyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGxldCBjYXB0Y2hhVG9rZW4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoJ29wdGlvbnMnIGluIHBhcmFtcykge1xuICAgICAgICAgICAgICAgIHJlZGlyZWN0VG8gPSAoX2EgPSBwYXJhbXMub3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlZGlyZWN0VG87XG4gICAgICAgICAgICAgICAgY2FwdGNoYVRva2VuID0gKF9iID0gcGFyYW1zLm9wdGlvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYXB0Y2hhVG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS92ZXJpZnlgLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1zKSwgeyBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBjYXB0Y2hhVG9rZW4gfSB9KSxcbiAgICAgICAgICAgICAgICByZWRpcmVjdFRvLFxuICAgICAgICAgICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQW4gZXJyb3Igb2NjdXJyZWQgb24gdG9rZW4gdmVyaWZpY2F0aW9uLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IGRhdGEuc2Vzc2lvbjtcbiAgICAgICAgICAgIGNvbnN0IHVzZXIgPSBkYXRhLnVzZXI7XG4gICAgICAgICAgICBpZiAoc2Vzc2lvbiA9PT0gbnVsbCB8fCBzZXNzaW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXNzaW9uLmFjY2Vzc190b2tlbikge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKHNlc3Npb24pO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKHBhcmFtcy50eXBlID09ICdyZWNvdmVyeScgPyAnUEFTU1dPUkRfUkVDT1ZFUlknIDogJ1NJR05FRF9JTicsIHNlc3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyLCBzZXNzaW9uIH0sIGVycm9yOiBudWxsIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0cyBhIHNpbmdsZS1zaWduIG9uIHVzaW5nIGFuIGVudGVycHJpc2UgSWRlbnRpdHkgUHJvdmlkZXIuIEFcbiAgICAgKiBzdWNjZXNzZnVsIFNTTyBhdHRlbXB0IHdpbGwgcmVkaXJlY3QgdGhlIGN1cnJlbnQgcGFnZSB0byB0aGUgaWRlbnRpdHlcbiAgICAgKiBwcm92aWRlciBhdXRob3JpemF0aW9uIHBhZ2UuIFRoZSByZWRpcmVjdCBVUkwgaXMgaW1wbGVtZW50YXRpb24gYW5kIFNTT1xuICAgICAqIHByb3RvY29sIHNwZWNpZmljLlxuICAgICAqXG4gICAgICogWW91IGNhbiB1c2UgaXQgYnkgcHJvdmlkaW5nIGEgU1NPIGRvbWFpbi4gVHlwaWNhbGx5IHlvdSBjYW4gZXh0cmFjdCB0aGlzXG4gICAgICogZG9tYWluIGJ5IGFza2luZyB1c2VycyBmb3IgdGhlaXIgZW1haWwgYWRkcmVzcy4gSWYgdGhpcyBkb21haW4gaXNcbiAgICAgKiByZWdpc3RlcmVkIG9uIHRoZSBBdXRoIGluc3RhbmNlIHRoZSByZWRpcmVjdCB3aWxsIHVzZSB0aGF0IG9yZ2FuaXphdGlvbidzXG4gICAgICogY3VycmVudGx5IGFjdGl2ZSBTU08gSWRlbnRpdHkgUHJvdmlkZXIgZm9yIHRoZSBsb2dpbi5cbiAgICAgKlxuICAgICAqIElmIHlvdSBoYXZlIGJ1aWx0IGFuIG9yZ2FuaXphdGlvbi1zcGVjaWZpYyBsb2dpbiBwYWdlLCB5b3UgY2FuIHVzZSB0aGVcbiAgICAgKiBvcmdhbml6YXRpb24ncyBTU08gSWRlbnRpdHkgUHJvdmlkZXIgVVVJRCBkaXJlY3RseSBpbnN0ZWFkLlxuICAgICAqL1xuICAgIGFzeW5jIHNpZ25JbldpdGhTU08ocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IGNvZGVDaGFsbGVuZ2UgPSBudWxsO1xuICAgICAgICAgICAgbGV0IGNvZGVDaGFsbGVuZ2VNZXRob2QgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMuZmxvd1R5cGUgPT09ICdwa2NlJykge1xuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBbY29kZUNoYWxsZW5nZSwgY29kZUNoYWxsZW5nZU1ldGhvZF0gPSBhd2FpdCBnZXRDb2RlQ2hhbGxlbmdlQW5kTWV0aG9kKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9zc29gLCB7XG4gICAgICAgICAgICAgICAgYm9keTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoJ3Byb3ZpZGVySWQnIGluIHBhcmFtcyA/IHsgcHJvdmlkZXJfaWQ6IHBhcmFtcy5wcm92aWRlcklkIH0gOiBudWxsKSksICgnZG9tYWluJyBpbiBwYXJhbXMgPyB7IGRvbWFpbjogcGFyYW1zLmRvbWFpbiB9IDogbnVsbCkpLCB7IHJlZGlyZWN0X3RvOiAoX2IgPSAoX2EgPSBwYXJhbXMub3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlZGlyZWN0VG8pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHVuZGVmaW5lZCB9KSwgKCgoX2MgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMub3B0aW9ucykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhcHRjaGFUb2tlbilcbiAgICAgICAgICAgICAgICAgICAgPyB7IGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IHBhcmFtcy5vcHRpb25zLmNhcHRjaGFUb2tlbiB9IH1cbiAgICAgICAgICAgICAgICAgICAgOiBudWxsKSksIHsgc2tpcF9odHRwX3JlZGlyZWN0OiB0cnVlLCBjb2RlX2NoYWxsZW5nZTogY29kZUNoYWxsZW5nZSwgY29kZV9jaGFsbGVuZ2VfbWV0aG9kOiBjb2RlQ2hhbGxlbmdlTWV0aG9kIH0pLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICB4Zm9ybTogX3Nzb1Jlc3BvbnNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgcmVhdXRoZW50aWNhdGlvbiBPVFAgdG8gdGhlIHVzZXIncyBlbWFpbCBvciBwaG9uZSBudW1iZXIuXG4gICAgICogUmVxdWlyZXMgdGhlIHVzZXIgdG8gYmUgc2lnbmVkLWluLlxuICAgICAqL1xuICAgIGFzeW5jIHJlYXV0aGVudGljYXRlKCkge1xuICAgICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2soLTEsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9yZWF1dGhlbnRpY2F0ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgX3JlYXV0aGVudGljYXRlKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogeyBzZXNzaW9uIH0sIGVycm9yOiBzZXNzaW9uRXJyb3IsIH0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKHNlc3Npb25FcnJvcilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgc2Vzc2lvbkVycm9yO1xuICAgICAgICAgICAgICAgIGlmICghc2Vzc2lvbilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0dFVCcsIGAke3RoaXMudXJsfS9yZWF1dGhlbnRpY2F0ZWAsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBqd3Q6IHNlc3Npb24uYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNlbmRzIGFuIGV4aXN0aW5nIHNpZ251cCBjb25maXJtYXRpb24gZW1haWwsIGVtYWlsIGNoYW5nZSBlbWFpbCwgU01TIE9UUCBvciBwaG9uZSBjaGFuZ2UgT1RQLlxuICAgICAqL1xuICAgIGFzeW5jIHJlc2VuZChjcmVkZW50aWFscykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZW5kcG9pbnQgPSBgJHt0aGlzLnVybH0vcmVzZW5kYDtcbiAgICAgICAgICAgIGlmICgnZW1haWwnIGluIGNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBlbWFpbCwgdHlwZSwgb3B0aW9ucyB9ID0gY3JlZGVudGlhbHM7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBlbmRwb2ludCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtYWlsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcmVkaXJlY3RUbzogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmVtYWlsUmVkaXJlY3RUbyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCdwaG9uZScgaW4gY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHBob25lLCB0eXBlLCBvcHRpb25zIH0gPSBjcmVkZW50aWFscztcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGVuZHBvaW50LCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGhvbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNhcHRjaGFUb2tlbiB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCwgbWVzc2FnZUlkOiBkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGEubWVzc2FnZV9pZCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhJbnZhbGlkQ3JlZGVudGlhbHNFcnJvcignWW91IG11c3QgcHJvdmlkZSBlaXRoZXIgYW4gZW1haWwgb3IgcGhvbmUgbnVtYmVyIGFuZCBhIHR5cGUnKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNlc3Npb24sIHJlZnJlc2hpbmcgaXQgaWYgbmVjZXNzYXJ5LlxuICAgICAqXG4gICAgICogVGhlIHNlc3Npb24gcmV0dXJuZWQgY2FuIGJlIG51bGwgaWYgdGhlIHNlc3Npb24gaXMgbm90IGRldGVjdGVkIHdoaWNoIGNhbiBoYXBwZW4gaW4gdGhlIGV2ZW50IGEgdXNlciBpcyBub3Qgc2lnbmVkLWluIG9yIGhhcyBsb2dnZWQgb3V0LlxuICAgICAqXG4gICAgICogKipJTVBPUlRBTlQ6KiogVGhpcyBtZXRob2QgbG9hZHMgdmFsdWVzIGRpcmVjdGx5IGZyb20gdGhlIHN0b3JhZ2UgYXR0YWNoZWRcbiAgICAgKiB0byB0aGUgY2xpZW50LiBJZiB0aGF0IHN0b3JhZ2UgaXMgYmFzZWQgb24gcmVxdWVzdCBjb29raWVzIGZvciBleGFtcGxlLFxuICAgICAqIHRoZSB2YWx1ZXMgaW4gaXQgbWF5IG5vdCBiZSBhdXRoZW50aWMgYW5kIHRoZXJlZm9yZSBpdCdzIHN0cm9uZ2x5IGFkdmlzZWRcbiAgICAgKiBhZ2FpbnN0IHVzaW5nIHRoaXMgbWV0aG9kIGFuZCBpdHMgcmVzdWx0cyBpbiBzdWNoIGNpcmN1bXN0YW5jZXMuIEEgd2FybmluZ1xuICAgICAqIHdpbGwgYmUgZW1pdHRlZCBpZiB0aGlzIGlzIGRldGVjdGVkLiBVc2Uge0BsaW5rICNnZXRVc2VyKCl9IGluc3RlYWQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0U2Vzc2lvbigpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2soLTEsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBY3F1aXJlcyBhIGdsb2JhbCBsb2NrIGJhc2VkIG9uIHRoZSBzdG9yYWdlIGtleS5cbiAgICAgKi9cbiAgICBhc3luYyBfYWNxdWlyZUxvY2soYWNxdWlyZVRpbWVvdXQsIGZuKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCcjX2FjcXVpcmVMb2NrJywgJ2JlZ2luJywgYWNxdWlyZVRpbWVvdXQpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHRoaXMubG9ja0FjcXVpcmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdCA9IHRoaXMucGVuZGluZ0luTG9jay5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLnBlbmRpbmdJbkxvY2tbdGhpcy5wZW5kaW5nSW5Mb2NrLmxlbmd0aCAtIDFdXG4gICAgICAgICAgICAgICAgICAgIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgbGFzdDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGZuKCk7XG4gICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdJbkxvY2sucHVzaCgoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBqdXN0IGNhcmUgaWYgaXQgZmluaXNoZWRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5sb2NrKGBsb2NrOiR7dGhpcy5zdG9yYWdlS2V5fWAsIGFjcXVpcmVUaW1lb3V0LCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoJyNfYWNxdWlyZUxvY2snLCAnbG9jayBhY3F1aXJlZCBmb3Igc3RvcmFnZSBrZXknLCB0aGlzLnN0b3JhZ2VLZXkpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9ja0FjcXVpcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZm4oKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nSW5Mb2NrLnB1c2goKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBqdXN0IGNhcmUgaWYgaXQgZmluaXNoZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSkoKSk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgLy8ga2VlcCBkcmFpbmluZyB0aGUgcXVldWUgdW50aWwgdGhlcmUncyBub3RoaW5nIHRvIHdhaXQgb25cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMucGVuZGluZ0luTG9jay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdhaXRPbiA9IFsuLi50aGlzLnBlbmRpbmdJbkxvY2tdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwod2FpdE9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0luTG9jay5zcGxpY2UoMCwgd2FpdE9uLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX2FjcXVpcmVMb2NrJywgJ2xvY2sgcmVsZWFzZWQgZm9yIHN0b3JhZ2Uga2V5JywgdGhpcy5zdG9yYWdlS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2NrQWNxdWlyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX2FjcXVpcmVMb2NrJywgJ2VuZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZSBpbnN0ZWFkIG9mIHtAbGluayAjZ2V0U2Vzc2lvbn0gaW5zaWRlIHRoZSBsaWJyYXJ5LiBJdCBpc1xuICAgICAqIHNlbWFudGljYWxseSB1c3VhbGx5IHdoYXQgeW91IHdhbnQsIGFzIGdldHRpbmcgYSBzZXNzaW9uIGludm9sdmVzIHNvbWVcbiAgICAgKiBwcm9jZXNzaW5nIGFmdGVyd2FyZHMgdGhhdCByZXF1aXJlcyBvbmx5IG9uZSBjbGllbnQgb3BlcmF0aW5nIG9uIHRoZVxuICAgICAqIHNlc3Npb24gYXQgb25jZSBhY3Jvc3MgbXVsdGlwbGUgdGFicyBvciBwcm9jZXNzZXMuXG4gICAgICovXG4gICAgYXN5bmMgX3VzZVNlc3Npb24oZm4pIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJyNfdXNlU2Vzc2lvbicsICdiZWdpbicpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gdGhlIHVzZSBvZiBfX2xvYWRTZXNzaW9uIGhlcmUgaXMgdGhlIG9ubHkgY29ycmVjdCB1c2Ugb2YgdGhlIGZ1bmN0aW9uIVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fX2xvYWRTZXNzaW9uKCk7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgZm4ocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX3VzZVNlc3Npb24nLCAnZW5kJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTkVWRVIgVVNFIERJUkVDVExZIVxuICAgICAqXG4gICAgICogQWx3YXlzIHVzZSB7QGxpbmsgI191c2VTZXNzaW9ufS5cbiAgICAgKi9cbiAgICBhc3luYyBfX2xvYWRTZXNzaW9uKCkge1xuICAgICAgICB0aGlzLl9kZWJ1ZygnI19fbG9hZFNlc3Npb24oKScsICdiZWdpbicpO1xuICAgICAgICBpZiAoIXRoaXMubG9ja0FjcXVpcmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19fbG9hZFNlc3Npb24oKScsICd1c2VkIG91dHNpZGUgb2YgYW4gYWNxdWlyZWQgbG9jayEnLCBuZXcgRXJyb3IoKS5zdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50U2Vzc2lvbiA9IG51bGw7XG4gICAgICAgICAgICBjb25zdCBtYXliZVNlc3Npb24gPSBhd2FpdCBnZXRJdGVtQXN5bmModGhpcy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXkpO1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoJyNnZXRTZXNzaW9uKCknLCAnc2Vzc2lvbiBmcm9tIHN0b3JhZ2UnLCBtYXliZVNlc3Npb24pO1xuICAgICAgICAgICAgaWYgKG1heWJlU2Vzc2lvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc1ZhbGlkU2Vzc2lvbihtYXliZVNlc3Npb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZXNzaW9uID0gbWF5YmVTZXNzaW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoJyNnZXRTZXNzaW9uKCknLCAnc2Vzc2lvbiBmcm9tIHN0b3JhZ2UgaXMgbm90IHZhbGlkJyk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3JlbW92ZVNlc3Npb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnRTZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBzZXNzaW9uOiBudWxsIH0sIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoYXNFeHBpcmVkID0gY3VycmVudFNlc3Npb24uZXhwaXJlc19hdFxuICAgICAgICAgICAgICAgID8gY3VycmVudFNlc3Npb24uZXhwaXJlc19hdCA8PSBEYXRlLm5vdygpIC8gMTAwMFxuICAgICAgICAgICAgICAgIDogZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19fbG9hZFNlc3Npb24oKScsIGBzZXNzaW9uIGhhcyR7aGFzRXhwaXJlZCA/ICcnIDogJyBub3QnfSBleHBpcmVkYCwgJ2V4cGlyZXNfYXQnLCBjdXJyZW50U2Vzc2lvbi5leHBpcmVzX2F0KTtcbiAgICAgICAgICAgIGlmICghaGFzRXhwaXJlZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0b3JhZ2UuaXNTZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN1cHByZXNzV2FybmluZyA9IHRoaXMuc3VwcHJlc3NHZXRTZXNzaW9uV2FybmluZztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJveHlTZXNzaW9uID0gbmV3IFByb3h5KGN1cnJlbnRTZXNzaW9uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQ6ICh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdXBwcmVzc1dhcm5pbmcgJiYgcHJvcCA9PT0gJ3VzZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgc2hvdyB3YXJuaW5nIHdoZW4gdGhlIHVzZXIgb2JqZWN0IGlzIGJlaW5nIGFjY2Vzc2VkIGZyb20gdGhlIHNlcnZlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1VzaW5nIHRoZSB1c2VyIG9iamVjdCBhcyByZXR1cm5lZCBmcm9tIHN1cGFiYXNlLmF1dGguZ2V0U2Vzc2lvbigpIG9yIGZyb20gc29tZSBzdXBhYmFzZS5hdXRoLm9uQXV0aFN0YXRlQ2hhbmdlKCkgZXZlbnRzIGNvdWxkIGJlIGluc2VjdXJlISBUaGlzIHZhbHVlIGNvbWVzIGRpcmVjdGx5IGZyb20gdGhlIHN0b3JhZ2UgbWVkaXVtICh1c3VhbGx5IGNvb2tpZXMgb24gdGhlIHNlcnZlcikgYW5kIG1heSBub3QgYmUgYXV0aGVudGljLiBVc2Ugc3VwYWJhc2UuYXV0aC5nZXRVc2VyKCkgaW5zdGVhZCB3aGljaCBhdXRoZW50aWNhdGVzIHRoZSBkYXRhIGJ5IGNvbnRhY3RpbmcgdGhlIFN1cGFiYXNlIEF1dGggc2VydmVyLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdXBwcmVzc1dhcm5pbmcgPSB0cnVlOyAvLyBrZWVwcyB0aGlzIHByb3h5IGluc3RhbmNlIGZyb20gbG9nZ2luZyBhZGRpdGlvbmFsIHdhcm5pbmdzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3VwcHJlc3NHZXRTZXNzaW9uV2FybmluZyA9IHRydWU7IC8vIGtlZXBzIHRoaXMgY2xpZW50J3MgZnV0dXJlIHByb3h5IGluc3RhbmNlcyBmcm9tIHdhcm5pbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZXNzaW9uID0gcHJveHlTZXNzaW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHNlc3Npb246IGN1cnJlbnRTZXNzaW9uIH0sIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHNlc3Npb24sIGVycm9yIH0gPSBhd2FpdCB0aGlzLl9jYWxsUmVmcmVzaFRva2VuKGN1cnJlbnRTZXNzaW9uLnJlZnJlc2hfdG9rZW4pO1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHNlc3Npb24gfSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX19sb2FkU2Vzc2lvbigpJywgJ2VuZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgdXNlciBkZXRhaWxzIGlmIHRoZXJlIGlzIGFuIGV4aXN0aW5nIHNlc3Npb24uIFRoaXMgbWV0aG9kXG4gICAgICogcGVyZm9ybXMgYSBuZXR3b3JrIHJlcXVlc3QgdG8gdGhlIFN1cGFiYXNlIEF1dGggc2VydmVyLCBzbyB0aGUgcmV0dXJuZWRcbiAgICAgKiB2YWx1ZSBpcyBhdXRoZW50aWMgYW5kIGNhbiBiZSB1c2VkIHRvIGJhc2UgYXV0aG9yaXphdGlvbiBydWxlcyBvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBqd3QgVGFrZXMgaW4gYW4gb3B0aW9uYWwgYWNjZXNzIHRva2VuIEpXVC4gSWYgbm8gSldUIGlzIHByb3ZpZGVkLCB0aGUgSldUIGZyb20gdGhlIGN1cnJlbnQgc2Vzc2lvbiBpcyB1c2VkLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFVzZXIoand0KSB7XG4gICAgICAgIGlmIChqd3QpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9nZXRVc2VyKGp3dCk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2soLTEsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9nZXRVc2VyKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBfZ2V0VXNlcihqd3QpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChqd3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0dFVCcsIGAke3RoaXMudXJsfS91c2VyYCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGp3dDogand0LFxuICAgICAgICAgICAgICAgICAgICB4Zm9ybTogX3VzZXJSZXNwb25zZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyByZXR1cm5zIGFuIGVycm9yIGlmIHRoZXJlIGlzIG5vIGFjY2Vzc190b2tlbiBvciBjdXN0b20gYXV0aG9yaXphdGlvbiBoZWFkZXJcbiAgICAgICAgICAgICAgICBpZiAoISgoX2EgPSBkYXRhLnNlc3Npb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY2Nlc3NfdG9rZW4pICYmICF0aGlzLmhhc0N1c3RvbUF1dGhvcml6YXRpb25IZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsIH0sIGVycm9yOiBuZXcgQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoKSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0dFVCcsIGAke3RoaXMudXJsfS91c2VyYCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGp3dDogKF9jID0gKF9iID0gZGF0YS5zZXNzaW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWNjZXNzX3Rva2VuKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIHhmb3JtOiBfdXNlclJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEpXVCBjb250YWlucyBhIGBzZXNzaW9uX2lkYCB3aGljaCBkb2VzIG5vdCBjb3JyZXNwb25kIHRvIGFuIGFjdGl2ZVxuICAgICAgICAgICAgICAgICAgICAvLyBzZXNzaW9uIGluIHRoZSBkYXRhYmFzZSwgaW5kaWNhdGluZyB0aGUgdXNlciBpcyBzaWduZWQgb3V0LlxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9yZW1vdmVTZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHJlbW92ZUl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIGAke3RoaXMuc3RvcmFnZUtleX0tY29kZS12ZXJpZmllcmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdXNlciBkYXRhIGZvciBhIGxvZ2dlZCBpbiB1c2VyLlxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZVVzZXIoYXR0cmlidXRlcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2U7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jaygtMSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VwZGF0ZVVzZXIoYXR0cmlidXRlcywgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBfdXBkYXRlVXNlcihhdHRyaWJ1dGVzLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGE6IHNlc3Npb25EYXRhLCBlcnJvcjogc2Vzc2lvbkVycm9yIH0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKHNlc3Npb25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBzZXNzaW9uRXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghc2Vzc2lvbkRhdGEuc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IHNlc3Npb25EYXRhLnNlc3Npb247XG4gICAgICAgICAgICAgICAgbGV0IGNvZGVDaGFsbGVuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBjb2RlQ2hhbGxlbmdlTWV0aG9kID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5mbG93VHlwZSA9PT0gJ3BrY2UnICYmIGF0dHJpYnV0ZXMuZW1haWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgIFtjb2RlQ2hhbGxlbmdlLCBjb2RlQ2hhbGxlbmdlTWV0aG9kXSA9IGF3YWl0IGdldENvZGVDaGFsbGVuZ2VBbmRNZXRob2QodGhpcy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yOiB1c2VyRXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQVVQnLCBgJHt0aGlzLnVybH0vdXNlcmAsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICByZWRpcmVjdFRvOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZW1haWxSZWRpcmVjdFRvLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGF0dHJpYnV0ZXMpLCB7IGNvZGVfY2hhbGxlbmdlOiBjb2RlQ2hhbGxlbmdlLCBjb2RlX2NoYWxsZW5nZV9tZXRob2Q6IGNvZGVDaGFsbGVuZ2VNZXRob2QgfSksXG4gICAgICAgICAgICAgICAgICAgIGp3dDogc2Vzc2lvbi5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIHhmb3JtOiBfdXNlclJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICh1c2VyRXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IHVzZXJFcnJvcjtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLnVzZXIgPSBkYXRhLnVzZXI7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1VTRVJfVVBEQVRFRCcsIHNlc3Npb24pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogc2Vzc2lvbi51c2VyIH0sIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlY29kZXMgYSBKV1QgKHdpdGhvdXQgcGVyZm9ybWluZyBhbnkgdmFsaWRhdGlvbikuXG4gICAgICovXG4gICAgX2RlY29kZUpXVChqd3QpIHtcbiAgICAgICAgcmV0dXJuIGRlY29kZUpXVFBheWxvYWQoand0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc2Vzc2lvbiBkYXRhIGZyb20gdGhlIGN1cnJlbnQgc2Vzc2lvbi4gSWYgdGhlIGN1cnJlbnQgc2Vzc2lvbiBpcyBleHBpcmVkLCBzZXRTZXNzaW9uIHdpbGwgdGFrZSBjYXJlIG9mIHJlZnJlc2hpbmcgaXQgdG8gb2J0YWluIGEgbmV3IHNlc3Npb24uXG4gICAgICogSWYgdGhlIHJlZnJlc2ggdG9rZW4gb3IgYWNjZXNzIHRva2VuIGluIHRoZSBjdXJyZW50IHNlc3Npb24gaXMgaW52YWxpZCwgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gICAgICogQHBhcmFtIGN1cnJlbnRTZXNzaW9uIFRoZSBjdXJyZW50IHNlc3Npb24gdGhhdCBtaW5pbWFsbHkgY29udGFpbnMgYW4gYWNjZXNzIHRva2VuIGFuZCByZWZyZXNoIHRva2VuLlxuICAgICAqL1xuICAgIGFzeW5jIHNldFNlc3Npb24oY3VycmVudFNlc3Npb24pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2FjcXVpcmVMb2NrKC0xLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fc2V0U2Vzc2lvbihjdXJyZW50U2Vzc2lvbik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBfc2V0U2Vzc2lvbihjdXJyZW50U2Vzc2lvbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFjdXJyZW50U2Vzc2lvbi5hY2Nlc3NfdG9rZW4gfHwgIWN1cnJlbnRTZXNzaW9uLnJlZnJlc2hfdG9rZW4pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRpbWVOb3cgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICAgICAgICAgIGxldCBleHBpcmVzQXQgPSB0aW1lTm93O1xuICAgICAgICAgICAgbGV0IGhhc0V4cGlyZWQgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IHNlc3Npb24gPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IGRlY29kZUpXVFBheWxvYWQoY3VycmVudFNlc3Npb24uYWNjZXNzX3Rva2VuKTtcbiAgICAgICAgICAgIGlmIChwYXlsb2FkLmV4cCkge1xuICAgICAgICAgICAgICAgIGV4cGlyZXNBdCA9IHBheWxvYWQuZXhwO1xuICAgICAgICAgICAgICAgIGhhc0V4cGlyZWQgPSBleHBpcmVzQXQgPD0gdGltZU5vdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNFeHBpcmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzZXNzaW9uOiByZWZyZXNoZWRTZXNzaW9uLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5fY2FsbFJlZnJlc2hUb2tlbihjdXJyZW50U2Vzc2lvbi5yZWZyZXNoX3Rva2VuKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yOiBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXJlZnJlc2hlZFNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlc3Npb24gPSByZWZyZXNoZWRTZXNzaW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5fZ2V0VXNlcihjdXJyZW50U2Vzc2lvbi5hY2Nlc3NfdG9rZW4pO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2Vzc2lvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgYWNjZXNzX3Rva2VuOiBjdXJyZW50U2Vzc2lvbi5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hfdG9rZW46IGN1cnJlbnRTZXNzaW9uLnJlZnJlc2hfdG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIHVzZXI6IGRhdGEudXNlcixcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5fdHlwZTogJ2JlYXJlcicsXG4gICAgICAgICAgICAgICAgICAgIGV4cGlyZXNfaW46IGV4cGlyZXNBdCAtIHRpbWVOb3csXG4gICAgICAgICAgICAgICAgICAgIGV4cGlyZXNfYXQ6IGV4cGlyZXNBdCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKHNlc3Npb24pO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdTSUdORURfSU4nLCBzZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogc2Vzc2lvbi51c2VyLCBzZXNzaW9uIH0sIGVycm9yOiBudWxsIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBzZXNzaW9uOiBudWxsLCB1c2VyOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IHNlc3Npb24sIHJlZ2FyZGxlc3Mgb2YgZXhwaXJ5IHN0YXR1cy5cbiAgICAgKiBUYWtlcyBpbiBhbiBvcHRpb25hbCBjdXJyZW50IHNlc3Npb24uIElmIG5vdCBwYXNzZWQgaW4sIHRoZW4gcmVmcmVzaFNlc3Npb24oKSB3aWxsIGF0dGVtcHQgdG8gcmV0cmlldmUgaXQgZnJvbSBnZXRTZXNzaW9uKCkuXG4gICAgICogSWYgdGhlIGN1cnJlbnQgc2Vzc2lvbidzIHJlZnJlc2ggdG9rZW4gaXMgaW52YWxpZCwgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gICAgICogQHBhcmFtIGN1cnJlbnRTZXNzaW9uIFRoZSBjdXJyZW50IHNlc3Npb24uIElmIHBhc3NlZCBpbiwgaXQgbXVzdCBjb250YWluIGEgcmVmcmVzaCB0b2tlbi5cbiAgICAgKi9cbiAgICBhc3luYyByZWZyZXNoU2Vzc2lvbihjdXJyZW50U2Vzc2lvbikge1xuICAgICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2soLTEsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9yZWZyZXNoU2Vzc2lvbihjdXJyZW50U2Vzc2lvbik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBfcmVmcmVzaFNlc3Npb24oY3VycmVudFNlc3Npb24pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50U2Vzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFNlc3Npb24gPSAoX2EgPSBkYXRhLnNlc3Npb24pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCEoY3VycmVudFNlc3Npb24gPT09IG51bGwgfHwgY3VycmVudFNlc3Npb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnRTZXNzaW9uLnJlZnJlc2hfdG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IHNlc3Npb24sIGVycm9yIH0gPSBhd2FpdCB0aGlzLl9jYWxsUmVmcmVzaFRva2VuKGN1cnJlbnRTZXNzaW9uLnJlZnJlc2hfdG9rZW4pO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3I6IGVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBzZXNzaW9uLnVzZXIsIHNlc3Npb24gfSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc2Vzc2lvbiBkYXRhIGZyb20gYSBVUkwgc3RyaW5nXG4gICAgICovXG4gICAgYXN5bmMgX2dldFNlc3Npb25Gcm9tVVJMKHBhcmFtcywgY2FsbGJhY2tVcmxUeXBlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIWlzQnJvd3NlcigpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3IoJ05vIGJyb3dzZXIgZGV0ZWN0ZWQuJyk7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSdzIGFuIGVycm9yIGluIHRoZSBVUkwsIGl0IGRvZXNuJ3QgbWF0dGVyIHdoYXQgZmxvdyBpdCBpcywgd2UganVzdCByZXR1cm4gdGhlIGVycm9yLlxuICAgICAgICAgICAgaWYgKHBhcmFtcy5lcnJvciB8fCBwYXJhbXMuZXJyb3JfZGVzY3JpcHRpb24gfHwgcGFyYW1zLmVycm9yX2NvZGUpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgZXJyb3IgY2xhc3MgcmV0dXJuZWQgaW1wbGllcyB0aGF0IHRoZSByZWRpcmVjdCBpcyBmcm9tIGFuIGltcGxpY2l0IGdyYW50IGZsb3dcbiAgICAgICAgICAgICAgICAvLyBidXQgaXQgY291bGQgYWxzbyBiZSBmcm9tIGEgcmVkaXJlY3QgZXJyb3IgZnJvbSBhIFBLQ0UgZmxvdy5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yKHBhcmFtcy5lcnJvcl9kZXNjcmlwdGlvbiB8fCAnRXJyb3IgaW4gVVJMIHdpdGggdW5zcGVjaWZpZWQgZXJyb3JfZGVzY3JpcHRpb24nLCB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBwYXJhbXMuZXJyb3IgfHwgJ3Vuc3BlY2lmaWVkX2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgY29kZTogcGFyYW1zLmVycm9yX2NvZGUgfHwgJ3Vuc3BlY2lmaWVkX2NvZGUnLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2tzIGZvciBtaXNtYXRjaGVzIGJldHdlZW4gdGhlIGZsb3dUeXBlIGluaXRpYWxpc2VkIGluIHRoZSBjbGllbnQgYW5kIHRoZSBVUkwgcGFyYW1ldGVyc1xuICAgICAgICAgICAgc3dpdGNoIChjYWxsYmFja1VybFR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdpbXBsaWNpdCc6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZsb3dUeXBlID09PSAncGtjZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBBdXRoUEtDRUdyYW50Q29kZUV4Y2hhbmdlRXJyb3IoJ05vdCBhIHZhbGlkIFBLQ0UgZmxvdyB1cmwuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAncGtjZSc6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZsb3dUeXBlID09PSAnaW1wbGljaXQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yKCdOb3QgYSB2YWxpZCBpbXBsaWNpdCBncmFudCBmbG93IHVybC4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIHRoZXJlJ3Mgbm8gbWlzbWF0Y2ggc28gd2UgY29udGludWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNpbmNlIHRoaXMgaXMgYSByZWRpcmVjdCBmb3IgUEtDRSwgd2UgYXR0ZW1wdCB0byByZXRyaWV2ZSB0aGUgY29kZSBmcm9tIHRoZSBVUkwgZm9yIHRoZSBjb2RlIGV4Y2hhbmdlXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2tVcmxUeXBlID09PSAncGtjZScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19pbml0aWFsaXplKCknLCAnYmVnaW4nLCAnaXMgUEtDRSBmbG93JywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJhbXMuY29kZSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhQS0NFR3JhbnRDb2RlRXhjaGFuZ2VFcnJvcignTm8gY29kZSBkZXRlY3RlZC4nKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCB0aGlzLl9leGNoYW5nZUNvZGVGb3JTZXNzaW9uKHBhcmFtcy5jb2RlKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuZGVsZXRlKCdjb2RlJyk7XG4gICAgICAgICAgICAgICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKHdpbmRvdy5oaXN0b3J5LnN0YXRlLCAnJywgdXJsLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgc2Vzc2lvbjogZGF0YS5zZXNzaW9uLCByZWRpcmVjdFR5cGU6IG51bGwgfSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgcHJvdmlkZXJfdG9rZW4sIHByb3ZpZGVyX3JlZnJlc2hfdG9rZW4sIGFjY2Vzc190b2tlbiwgcmVmcmVzaF90b2tlbiwgZXhwaXJlc19pbiwgZXhwaXJlc19hdCwgdG9rZW5fdHlwZSwgfSA9IHBhcmFtcztcbiAgICAgICAgICAgIGlmICghYWNjZXNzX3Rva2VuIHx8ICFleHBpcmVzX2luIHx8ICFyZWZyZXNoX3Rva2VuIHx8ICF0b2tlbl90eXBlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcignTm8gc2Vzc2lvbiBkZWZpbmVkIGluIFVSTCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGltZU5vdyA9IE1hdGgucm91bmQoRGF0ZS5ub3coKSAvIDEwMDApO1xuICAgICAgICAgICAgY29uc3QgZXhwaXJlc0luID0gcGFyc2VJbnQoZXhwaXJlc19pbik7XG4gICAgICAgICAgICBsZXQgZXhwaXJlc0F0ID0gdGltZU5vdyArIGV4cGlyZXNJbjtcbiAgICAgICAgICAgIGlmIChleHBpcmVzX2F0KSB7XG4gICAgICAgICAgICAgICAgZXhwaXJlc0F0ID0gcGFyc2VJbnQoZXhwaXJlc19hdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhY3R1YWxseUV4cGlyZXNJbiA9IGV4cGlyZXNBdCAtIHRpbWVOb3c7XG4gICAgICAgICAgICBpZiAoYWN0dWFsbHlFeHBpcmVzSW4gKiAxMDAwIDw9IEFVVE9fUkVGUkVTSF9USUNLX0RVUkFUSU9OKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBAc3VwYWJhc2UvZ290cnVlLWpzOiBTZXNzaW9uIGFzIHJldHJpZXZlZCBmcm9tIFVSTCBleHBpcmVzIGluICR7YWN0dWFsbHlFeHBpcmVzSW59cywgc2hvdWxkIGhhdmUgYmVlbiBjbG9zZXIgdG8gJHtleHBpcmVzSW59c2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaXNzdWVkQXQgPSBleHBpcmVzQXQgLSBleHBpcmVzSW47XG4gICAgICAgICAgICBpZiAodGltZU5vdyAtIGlzc3VlZEF0ID49IDEyMCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignQHN1cGFiYXNlL2dvdHJ1ZS1qczogU2Vzc2lvbiBhcyByZXRyaWV2ZWQgZnJvbSBVUkwgd2FzIGlzc3VlZCBvdmVyIDEyMHMgYWdvLCBVUkwgY291bGQgYmUgc3RhbGUnLCBpc3N1ZWRBdCwgZXhwaXJlc0F0LCB0aW1lTm93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRpbWVOb3cgLSBpc3N1ZWRBdCA8IDApIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0BzdXBhYmFzZS9nb3RydWUtanM6IFNlc3Npb24gYXMgcmV0cmlldmVkIGZyb20gVVJMIHdhcyBpc3N1ZWQgaW4gdGhlIGZ1dHVyZT8gQ2hlY2sgdGhlIGRldmljZSBjbG9jayBmb3Igc2tldycsIGlzc3VlZEF0LCBleHBpcmVzQXQsIHRpbWVOb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5fZ2V0VXNlcihhY2Nlc3NfdG9rZW4pO1xuICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IHtcbiAgICAgICAgICAgICAgICBwcm92aWRlcl90b2tlbixcbiAgICAgICAgICAgICAgICBwcm92aWRlcl9yZWZyZXNoX3Rva2VuLFxuICAgICAgICAgICAgICAgIGFjY2Vzc190b2tlbixcbiAgICAgICAgICAgICAgICBleHBpcmVzX2luOiBleHBpcmVzSW4sXG4gICAgICAgICAgICAgICAgZXhwaXJlc19hdDogZXhwaXJlc0F0LFxuICAgICAgICAgICAgICAgIHJlZnJlc2hfdG9rZW4sXG4gICAgICAgICAgICAgICAgdG9rZW5fdHlwZSxcbiAgICAgICAgICAgICAgICB1c2VyOiBkYXRhLnVzZXIsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHRva2VucyBmcm9tIFVSTFxuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSAnJztcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX2dldFNlc3Npb25Gcm9tVVJMKCknLCAnY2xlYXJpbmcgd2luZG93LmxvY2F0aW9uLmhhc2gnKTtcbiAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgc2Vzc2lvbiwgcmVkaXJlY3RUeXBlOiBwYXJhbXMudHlwZSB9LCBlcnJvcjogbnVsbCB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgc2Vzc2lvbjogbnVsbCwgcmVkaXJlY3RUeXBlOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGN1cnJlbnQgVVJMIGNvbnRhaW5zIHBhcmFtZXRlcnMgZ2l2ZW4gYnkgYW4gaW1wbGljaXQgb2F1dGggZ3JhbnQgZmxvdyAoaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzY3NDkuaHRtbCNzZWN0aW9uLTQuMilcbiAgICAgKi9cbiAgICBfaXNJbXBsaWNpdEdyYW50Q2FsbGJhY2socGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHBhcmFtcy5hY2Nlc3NfdG9rZW4gfHwgcGFyYW1zLmVycm9yX2Rlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBjdXJyZW50IFVSTCBhbmQgYmFja2luZyBzdG9yYWdlIGNvbnRhaW4gcGFyYW1ldGVycyBnaXZlbiBieSBhIFBLQ0UgZmxvd1xuICAgICAqL1xuICAgIGFzeW5jIF9pc1BLQ0VDYWxsYmFjayhwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgY3VycmVudFN0b3JhZ2VDb250ZW50ID0gYXdhaXQgZ2V0SXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgYCR7dGhpcy5zdG9yYWdlS2V5fS1jb2RlLXZlcmlmaWVyYCk7XG4gICAgICAgIHJldHVybiAhIShwYXJhbXMuY29kZSAmJiBjdXJyZW50U3RvcmFnZUNvbnRlbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNpZGUgYSBicm93c2VyIGNvbnRleHQsIGBzaWduT3V0KClgIHdpbGwgcmVtb3ZlIHRoZSBsb2dnZWQgaW4gdXNlciBmcm9tIHRoZSBicm93c2VyIHNlc3Npb24gYW5kIGxvZyB0aGVtIG91dCAtIHJlbW92aW5nIGFsbCBpdGVtcyBmcm9tIGxvY2Fsc3RvcmFnZSBhbmQgdGhlbiB0cmlnZ2VyIGEgYFwiU0lHTkVEX09VVFwiYCBldmVudC5cbiAgICAgKlxuICAgICAqIEZvciBzZXJ2ZXItc2lkZSBtYW5hZ2VtZW50LCB5b3UgY2FuIHJldm9rZSBhbGwgcmVmcmVzaCB0b2tlbnMgZm9yIGEgdXNlciBieSBwYXNzaW5nIGEgdXNlcidzIEpXVCB0aHJvdWdoIHRvIGBhdXRoLmFwaS5zaWduT3V0KEpXVDogc3RyaW5nKWAuXG4gICAgICogVGhlcmUgaXMgbm8gd2F5IHRvIHJldm9rZSBhIHVzZXIncyBhY2Nlc3MgdG9rZW4gand0IHVudGlsIGl0IGV4cGlyZXMuIEl0IGlzIHJlY29tbWVuZGVkIHRvIHNldCBhIHNob3J0ZXIgZXhwaXJ5IG9uIHRoZSBqd3QgZm9yIHRoaXMgcmVhc29uLlxuICAgICAqXG4gICAgICogSWYgdXNpbmcgYG90aGVyc2Agc2NvcGUsIG5vIGBTSUdORURfT1VUYCBldmVudCBpcyBmaXJlZCFcbiAgICAgKi9cbiAgICBhc3luYyBzaWduT3V0KG9wdGlvbnMgPSB7IHNjb3BlOiAnZ2xvYmFsJyB9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2U7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jaygtMSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3NpZ25PdXQob3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBfc2lnbk91dCh7IHNjb3BlIH0gPSB7IHNjb3BlOiAnZ2xvYmFsJyB9KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3I6IHNlc3Npb25FcnJvciB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgaWYgKHNlc3Npb25FcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiBzZXNzaW9uRXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFjY2Vzc1Rva2VuID0gKF9hID0gZGF0YS5zZXNzaW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWNjZXNzX3Rva2VuO1xuICAgICAgICAgICAgaWYgKGFjY2Vzc1Rva2VuKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgdGhpcy5hZG1pbi5zaWduT3V0KGFjY2Vzc1Rva2VuLCBzY29wZSk7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSA0MDRzIHNpbmNlIHVzZXIgbWlnaHQgbm90IGV4aXN0IGFueW1vcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIDQwMXMgc2luY2UgYW4gaW52YWxpZCBvciBleHBpcmVkIEpXVCBzaG91bGQgc2lnbiBvdXQgdGhlIGN1cnJlbnQgc2Vzc2lvblxuICAgICAgICAgICAgICAgICAgICBpZiAoIShpc0F1dGhBcGlFcnJvcihlcnJvcikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChlcnJvci5zdGF0dXMgPT09IDQwNCB8fCBlcnJvci5zdGF0dXMgPT09IDQwMSB8fCBlcnJvci5zdGF0dXMgPT09IDQwMykpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBlcnJvciB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNjb3BlICE9PSAnb3RoZXJzJykge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3JlbW92ZVNlc3Npb24oKTtcbiAgICAgICAgICAgICAgICBhd2FpdCByZW1vdmVJdGVtQXN5bmModGhpcy5zdG9yYWdlLCBgJHt0aGlzLnN0b3JhZ2VLZXl9LWNvZGUtdmVyaWZpZXJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiBudWxsIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWNlaXZlIGEgbm90aWZpY2F0aW9uIGV2ZXJ5IHRpbWUgYW4gYXV0aCBldmVudCBoYXBwZW5zLlxuICAgICAqIEBwYXJhbSBjYWxsYmFjayBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgd2hlbiBhbiBhdXRoIGV2ZW50IGhhcHBlbnMuXG4gICAgICovXG4gICAgb25BdXRoU3RhdGVDaGFuZ2UoY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgaWQgPSB1dWlkKCk7XG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgICAgICB1bnN1YnNjcmliZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjdW5zdWJzY3JpYmUoKScsICdzdGF0ZSBjaGFuZ2UgY2FsbGJhY2sgd2l0aCBpZCByZW1vdmVkJywgaWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VFbWl0dGVycy5kZWxldGUoaWQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fZGVidWcoJyNvbkF1dGhTdGF0ZUNoYW5nZSgpJywgJ3JlZ2lzdGVyZWQgY2FsbGJhY2sgd2l0aCBpZCcsIGlkKTtcbiAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZUVtaXR0ZXJzLnNldChpZCwgc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2U7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jaygtMSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VtaXRJbml0aWFsU2Vzc2lvbihpZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBzdWJzY3JpcHRpb24gfSB9O1xuICAgIH1cbiAgICBhc3luYyBfZW1pdEluaXRpYWxTZXNzaW9uKGlkKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogeyBzZXNzaW9uIH0sIGVycm9yLCB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgYXdhaXQgKChfYSA9IHRoaXMuc3RhdGVDaGFuZ2VFbWl0dGVycy5nZXQoaWQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbGJhY2soJ0lOSVRJQUxfU0VTU0lPTicsIHNlc3Npb24pKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnSU5JVElBTF9TRVNTSU9OJywgJ2NhbGxiYWNrIGlkJywgaWQsICdzZXNzaW9uJywgc2Vzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgKChfYiA9IHRoaXMuc3RhdGVDaGFuZ2VFbWl0dGVycy5nZXQoaWQpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbGJhY2soJ0lOSVRJQUxfU0VTU0lPTicsIG51bGwpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnSU5JVElBTF9TRVNTSU9OJywgJ2NhbGxiYWNrIGlkJywgaWQsICdlcnJvcicsIGVycik7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBwYXNzd29yZCByZXNldCByZXF1ZXN0IHRvIGFuIGVtYWlsIGFkZHJlc3MuIFRoaXMgbWV0aG9kIHN1cHBvcnRzIHRoZSBQS0NFIGZsb3cuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZW1haWwgVGhlIGVtYWlsIGFkZHJlc3Mgb2YgdGhlIHVzZXIuXG4gICAgICogQHBhcmFtIG9wdGlvbnMucmVkaXJlY3RUbyBUaGUgVVJMIHRvIHNlbmQgdGhlIHVzZXIgdG8gYWZ0ZXIgdGhleSBjbGljayB0aGUgcGFzc3dvcmQgcmVzZXQgbGluay5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5jYXB0Y2hhVG9rZW4gVmVyaWZpY2F0aW9uIHRva2VuIHJlY2VpdmVkIHdoZW4gdGhlIHVzZXIgY29tcGxldGVzIHRoZSBjYXB0Y2hhIG9uIHRoZSBzaXRlLlxuICAgICAqL1xuICAgIGFzeW5jIHJlc2V0UGFzc3dvcmRGb3JFbWFpbChlbWFpbCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCBjb2RlQ2hhbGxlbmdlID0gbnVsbDtcbiAgICAgICAgbGV0IGNvZGVDaGFsbGVuZ2VNZXRob2QgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5mbG93VHlwZSA9PT0gJ3BrY2UnKSB7XG4gICAgICAgICAgICA7XG4gICAgICAgICAgICBbY29kZUNoYWxsZW5nZSwgY29kZUNoYWxsZW5nZU1ldGhvZF0gPSBhd2FpdCBnZXRDb2RlQ2hhbGxlbmdlQW5kTWV0aG9kKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5LCB0cnVlIC8vIGlzUGFzc3dvcmRSZWNvdmVyeVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3JlY292ZXJgLCB7XG4gICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICBlbWFpbCxcbiAgICAgICAgICAgICAgICAgICAgY29kZV9jaGFsbGVuZ2U6IGNvZGVDaGFsbGVuZ2UsXG4gICAgICAgICAgICAgICAgICAgIGNvZGVfY2hhbGxlbmdlX21ldGhvZDogY29kZUNoYWxsZW5nZU1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogb3B0aW9ucy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICByZWRpcmVjdFRvOiBvcHRpb25zLnJlZGlyZWN0VG8sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhbGwgdGhlIGlkZW50aXRpZXMgbGlua2VkIHRvIGEgdXNlci5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRVc2VySWRlbnRpdGllcygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5nZXRVc2VyKCk7XG4gICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IGlkZW50aXRpZXM6IChfYSA9IGRhdGEudXNlci5pZGVudGl0aWVzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSB9LCBlcnJvcjogbnVsbCB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaW5rcyBhbiBvYXV0aCBpZGVudGl0eSB0byBhbiBleGlzdGluZyB1c2VyLlxuICAgICAqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIHRoZSBQS0NFIGZsb3cuXG4gICAgICovXG4gICAgYXN5bmMgbGlua0lkZW50aXR5KGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgY29uc3QgdXJsID0gYXdhaXQgdGhpcy5fZ2V0VXJsRm9yUHJvdmlkZXIoYCR7dGhpcy51cmx9L3VzZXIvaWRlbnRpdGllcy9hdXRob3JpemVgLCBjcmVkZW50aWFscy5wcm92aWRlciwge1xuICAgICAgICAgICAgICAgICAgICByZWRpcmVjdFRvOiAoX2EgPSBjcmVkZW50aWFscy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVkaXJlY3RUbyxcbiAgICAgICAgICAgICAgICAgICAgc2NvcGVzOiAoX2IgPSBjcmVkZW50aWFscy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2NvcGVzLFxuICAgICAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogKF9jID0gY3JlZGVudGlhbHMub3B0aW9ucykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICBza2lwQnJvd3NlclJlZGlyZWN0OiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnR0VUJywgdXJsLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgand0OiAoX2UgPSAoX2QgPSBkYXRhLnNlc3Npb24pID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hY2Nlc3NfdG9rZW4pICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgaWYgKGlzQnJvd3NlcigpICYmICEoKF9hID0gY3JlZGVudGlhbHMub3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNraXBCcm93c2VyUmVkaXJlY3QpKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmFzc2lnbihkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGEudXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgcHJvdmlkZXI6IGNyZWRlbnRpYWxzLnByb3ZpZGVyLCB1cmw6IGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YS51cmwgfSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHByb3ZpZGVyOiBjcmVkZW50aWFscy5wcm92aWRlciwgdXJsOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbmxpbmtzIGFuIGlkZW50aXR5IGZyb20gYSB1c2VyIGJ5IGRlbGV0aW5nIGl0LiBUaGUgdXNlciB3aWxsIG5vIGxvbmdlciBiZSBhYmxlIHRvIHNpZ24gaW4gd2l0aCB0aGF0IGlkZW50aXR5IG9uY2UgaXQncyB1bmxpbmtlZC5cbiAgICAgKi9cbiAgICBhc3luYyB1bmxpbmtJZGVudGl0eShpZGVudGl0eSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdERUxFVEUnLCBgJHt0aGlzLnVybH0vdXNlci9pZGVudGl0aWVzLyR7aWRlbnRpdHkuaWRlbnRpdHlfaWR9YCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGp3dDogKF9iID0gKF9hID0gZGF0YS5zZXNzaW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWNjZXNzX3Rva2VuKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgbmV3IEpXVC5cbiAgICAgKiBAcGFyYW0gcmVmcmVzaFRva2VuIEEgdmFsaWQgcmVmcmVzaCB0b2tlbiB0aGF0IHdhcyByZXR1cm5lZCBvbiBsb2dpbi5cbiAgICAgKi9cbiAgICBhc3luYyBfcmVmcmVzaEFjY2Vzc1Rva2VuKHJlZnJlc2hUb2tlbikge1xuICAgICAgICBjb25zdCBkZWJ1Z05hbWUgPSBgI19yZWZyZXNoQWNjZXNzVG9rZW4oJHtyZWZyZXNoVG9rZW4uc3Vic3RyaW5nKDAsIDUpfS4uLilgO1xuICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdiZWdpbicpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRlZEF0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIC8vIHdpbGwgYXR0ZW1wdCB0byByZWZyZXNoIHRoZSB0b2tlbiB3aXRoIGV4cG9uZW50aWFsIGJhY2tvZmZcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCByZXRyeWFibGUoYXN5bmMgKGF0dGVtcHQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYXR0ZW1wdCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgc2xlZXAoMjAwICogTWF0aC5wb3coMiwgYXR0ZW1wdCAtIDEpKTsgLy8gMjAwLCA0MDAsIDgwMCwgLi4uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ3JlZnJlc2hpbmcgYXR0ZW1wdCcsIGF0dGVtcHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS90b2tlbj9ncmFudF90eXBlPXJlZnJlc2hfdG9rZW5gLCB7XG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHsgcmVmcmVzaF90b2tlbjogcmVmcmVzaFRva2VuIH0sXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgeGZvcm06IF9zZXNzaW9uUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCAoYXR0ZW1wdCwgZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0QmFja09mZkludGVydmFsID0gMjAwICogTWF0aC5wb3coMiwgYXR0ZW1wdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChlcnJvciAmJlxuICAgICAgICAgICAgICAgICAgICBpc0F1dGhSZXRyeWFibGVGZXRjaEVycm9yKGVycm9yKSAmJlxuICAgICAgICAgICAgICAgICAgICAvLyByZXRyeWFibGUgb25seSBpZiB0aGUgcmVxdWVzdCBjYW4gYmUgc2VudCBiZWZvcmUgdGhlIGJhY2tvZmYgb3ZlcmZsb3dzIHRoZSB0aWNrIGR1cmF0aW9uXG4gICAgICAgICAgICAgICAgICAgIERhdGUubm93KCkgKyBuZXh0QmFja09mZkludGVydmFsIC0gc3RhcnRlZEF0IDwgQVVUT19SRUZSRVNIX1RJQ0tfRFVSQVRJT04pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHNlc3Npb246IG51bGwsIHVzZXI6IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnZW5kJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2lzVmFsaWRTZXNzaW9uKG1heWJlU2Vzc2lvbikge1xuICAgICAgICBjb25zdCBpc1ZhbGlkU2Vzc2lvbiA9IHR5cGVvZiBtYXliZVNlc3Npb24gPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBtYXliZVNlc3Npb24gIT09IG51bGwgJiZcbiAgICAgICAgICAgICdhY2Nlc3NfdG9rZW4nIGluIG1heWJlU2Vzc2lvbiAmJlxuICAgICAgICAgICAgJ3JlZnJlc2hfdG9rZW4nIGluIG1heWJlU2Vzc2lvbiAmJlxuICAgICAgICAgICAgJ2V4cGlyZXNfYXQnIGluIG1heWJlU2Vzc2lvbjtcbiAgICAgICAgcmV0dXJuIGlzVmFsaWRTZXNzaW9uO1xuICAgIH1cbiAgICBhc3luYyBfaGFuZGxlUHJvdmlkZXJTaWduSW4ocHJvdmlkZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgdXJsID0gYXdhaXQgdGhpcy5fZ2V0VXJsRm9yUHJvdmlkZXIoYCR7dGhpcy51cmx9L2F1dGhvcml6ZWAsIHByb3ZpZGVyLCB7XG4gICAgICAgICAgICByZWRpcmVjdFRvOiBvcHRpb25zLnJlZGlyZWN0VG8sXG4gICAgICAgICAgICBzY29wZXM6IG9wdGlvbnMuc2NvcGVzLFxuICAgICAgICAgICAgcXVlcnlQYXJhbXM6IG9wdGlvbnMucXVlcnlQYXJhbXMsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9kZWJ1ZygnI19oYW5kbGVQcm92aWRlclNpZ25JbigpJywgJ3Byb3ZpZGVyJywgcHJvdmlkZXIsICdvcHRpb25zJywgb3B0aW9ucywgJ3VybCcsIHVybCk7XG4gICAgICAgIC8vIHRyeSB0byBvcGVuIG9uIHRoZSBicm93c2VyXG4gICAgICAgIGlmIChpc0Jyb3dzZXIoKSAmJiAhb3B0aW9ucy5za2lwQnJvd3NlclJlZGlyZWN0KSB7XG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uYXNzaWduKHVybCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBwcm92aWRlciwgdXJsIH0sIGVycm9yOiBudWxsIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlY292ZXJzIHRoZSBzZXNzaW9uIGZyb20gTG9jYWxTdG9yYWdlIGFuZCByZWZyZXNoZXMgdGhlIHRva2VuXG4gICAgICogTm90ZTogdGhpcyBtZXRob2QgaXMgYXN5bmMgdG8gYWNjb21tb2RhdGUgZm9yIEFzeW5jU3RvcmFnZSBlLmcuIGluIFJlYWN0IG5hdGl2ZS5cbiAgICAgKi9cbiAgICBhc3luYyBfcmVjb3ZlckFuZFJlZnJlc2goKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgZGVidWdOYW1lID0gJyNfcmVjb3ZlckFuZFJlZnJlc2goKSc7XG4gICAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ2JlZ2luJyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50U2Vzc2lvbiA9IGF3YWl0IGdldEl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSk7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdzZXNzaW9uIGZyb20gc3RvcmFnZScsIGN1cnJlbnRTZXNzaW9uKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNWYWxpZFNlc3Npb24oY3VycmVudFNlc3Npb24pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnc2Vzc2lvbiBpcyBub3QgdmFsaWQnKTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFNlc3Npb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fcmVtb3ZlU2Vzc2lvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0aW1lTm93ID0gTWF0aC5yb3VuZChEYXRlLm5vdygpIC8gMTAwMCk7XG4gICAgICAgICAgICBjb25zdCBleHBpcmVzV2l0aE1hcmdpbiA9ICgoX2EgPSBjdXJyZW50U2Vzc2lvbi5leHBpcmVzX2F0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBJbmZpbml0eSkgPCB0aW1lTm93ICsgRVhQSVJZX01BUkdJTjtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgYHNlc3Npb24gaGFzJHtleHBpcmVzV2l0aE1hcmdpbiA/ICcnIDogJyBub3QnfSBleHBpcmVkIHdpdGggbWFyZ2luIG9mICR7RVhQSVJZX01BUkdJTn1zYCk7XG4gICAgICAgICAgICBpZiAoZXhwaXJlc1dpdGhNYXJnaW4pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hdXRvUmVmcmVzaFRva2VuICYmIGN1cnJlbnRTZXNzaW9uLnJlZnJlc2hfdG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgdGhpcy5fY2FsbFJlZnJlc2hUb2tlbihjdXJyZW50U2Vzc2lvbi5yZWZyZXNoX3Rva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdyZWZyZXNoIGZhaWxlZCB3aXRoIGEgbm9uLXJldHJ5YWJsZSBlcnJvciwgcmVtb3ZpbmcgdGhlIHNlc3Npb24nLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fcmVtb3ZlU2Vzc2lvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbm8gbmVlZCB0byBwZXJzaXN0IGN1cnJlbnRTZXNzaW9uIGFnYWluLCBhcyB3ZSBqdXN0IGxvYWRlZCBpdCBmcm9tXG4gICAgICAgICAgICAgICAgLy8gbG9jYWwgc3RvcmFnZTsgcGVyc2lzdGluZyBpdCBhZ2FpbiBtYXkgb3ZlcndyaXRlIGEgdmFsdWUgc2F2ZWQgYnlcbiAgICAgICAgICAgICAgICAvLyBhbm90aGVyIGNsaWVudCB3aXRoIGFjY2VzcyB0byB0aGUgc2FtZSBsb2NhbCBzdG9yYWdlXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1NJR05FRF9JTicsIGN1cnJlbnRTZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdlcnJvcicsIGVycik7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdlbmQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfY2FsbFJlZnJlc2hUb2tlbihyZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKCFyZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlZnJlc2hpbmcgaXMgYWxyZWFkeSBpbiBwcm9ncmVzc1xuICAgICAgICBpZiAodGhpcy5yZWZyZXNoaW5nRGVmZXJyZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZnJlc2hpbmdEZWZlcnJlZC5wcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlYnVnTmFtZSA9IGAjX2NhbGxSZWZyZXNoVG9rZW4oJHtyZWZyZXNoVG9rZW4uc3Vic3RyaW5nKDAsIDUpfS4uLilgO1xuICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdiZWdpbicpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoaW5nRGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuX3JlZnJlc2hBY2Nlc3NUb2tlbihyZWZyZXNoVG9rZW4pO1xuICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgaWYgKCFkYXRhLnNlc3Npb24pXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKCk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihkYXRhLnNlc3Npb24pO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1RPS0VOX1JFRlJFU0hFRCcsIGRhdGEuc2Vzc2lvbik7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7IHNlc3Npb246IGRhdGEuc2Vzc2lvbiwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaGluZ0RlZmVycmVkLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7IHNlc3Npb246IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgaWYgKCFpc0F1dGhSZXRyeWFibGVGZXRjaEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9yZW1vdmVTZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMucmVmcmVzaGluZ0RlZmVycmVkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoX2IgPSB0aGlzLnJlZnJlc2hpbmdEZWZlcnJlZCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaGluZ0RlZmVycmVkID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ2VuZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF9ub3RpZnlBbGxTdWJzY3JpYmVycyhldmVudCwgc2Vzc2lvbiwgYnJvYWRjYXN0ID0gdHJ1ZSkge1xuICAgICAgICBjb25zdCBkZWJ1Z05hbWUgPSBgI19ub3RpZnlBbGxTdWJzY3JpYmVycygke2V2ZW50fSlgO1xuICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdiZWdpbicsIHNlc3Npb24sIGBicm9hZGNhc3QgPSAke2Jyb2FkY2FzdH1gKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJyb2FkY2FzdENoYW5uZWwgJiYgYnJvYWRjYXN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5icm9hZGNhc3RDaGFubmVsLnBvc3RNZXNzYWdlKHsgZXZlbnQsIHNlc3Npb24gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0gQXJyYXkuZnJvbSh0aGlzLnN0YXRlQ2hhbmdlRW1pdHRlcnMudmFsdWVzKCkpLm1hcChhc3luYyAoeCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHguY2FsbGJhY2soZXZlbnQsIHNlc3Npb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgICAgICAgIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXJyb3JzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3JzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3JzWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnZW5kJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogc2V0IGN1cnJlbnRTZXNzaW9uIGFuZCBjdXJyZW50VXNlclxuICAgICAqIHByb2Nlc3MgdG8gX3N0YXJ0QXV0b1JlZnJlc2hUb2tlbiBpZiBwb3NzaWJsZVxuICAgICAqL1xuICAgIGFzeW5jIF9zYXZlU2Vzc2lvbihzZXNzaW9uKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCcjX3NhdmVTZXNzaW9uKCknLCBzZXNzaW9uKTtcbiAgICAgICAgLy8gX3NhdmVTZXNzaW9uIGlzIGFsd2F5cyBjYWxsZWQgd2hlbmV2ZXIgYSBuZXcgc2Vzc2lvbiBoYXMgYmVlbiBhY3F1aXJlZFxuICAgICAgICAvLyBzbyB3ZSBjYW4gc2FmZWx5IHN1cHByZXNzIHRoZSB3YXJuaW5nIHJldHVybmVkIGJ5IGZ1dHVyZSBnZXRTZXNzaW9uIGNhbGxzXG4gICAgICAgIHRoaXMuc3VwcHJlc3NHZXRTZXNzaW9uV2FybmluZyA9IHRydWU7XG4gICAgICAgIGF3YWl0IHNldEl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSwgc2Vzc2lvbik7XG4gICAgfVxuICAgIGFzeW5jIF9yZW1vdmVTZXNzaW9uKCkge1xuICAgICAgICB0aGlzLl9kZWJ1ZygnI19yZW1vdmVTZXNzaW9uKCknKTtcbiAgICAgICAgYXdhaXQgcmVtb3ZlSXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5KTtcbiAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1NJR05FRF9PVVQnLCBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbnkgcmVnaXN0ZXJlZCB2aXNpYmlsaXR5Y2hhbmdlIGNhbGxiYWNrLlxuICAgICAqXG4gICAgICoge0BzZWUgI3N0YXJ0QXV0b1JlZnJlc2h9XG4gICAgICoge0BzZWUgI3N0b3BBdXRvUmVmcmVzaH1cbiAgICAgKi9cbiAgICBfcmVtb3ZlVmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjaygpIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJyNfcmVtb3ZlVmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjaygpJyk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gdGhpcy52aXNpYmlsaXR5Q2hhbmdlZENhbGxiYWNrO1xuICAgICAgICB0aGlzLnZpc2liaWxpdHlDaGFuZ2VkQ2FsbGJhY2sgPSBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrICYmIGlzQnJvd3NlcigpICYmICh3aW5kb3cgPT09IG51bGwgfHwgd2luZG93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcikpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcigncmVtb3ZpbmcgdmlzaWJpbGl0eWNoYW5nZSBjYWxsYmFjayBmYWlsZWQnLCBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHRoZSBwcml2YXRlIGltcGxlbWVudGF0aW9uIG9mIHtAbGluayAjc3RhcnRBdXRvUmVmcmVzaH0uIFVzZSB0aGlzXG4gICAgICogd2l0aGluIHRoZSBsaWJyYXJ5LlxuICAgICAqL1xuICAgIGFzeW5jIF9zdGFydEF1dG9SZWZyZXNoKCkge1xuICAgICAgICBhd2FpdCB0aGlzLl9zdG9wQXV0b1JlZnJlc2goKTtcbiAgICAgICAgdGhpcy5fZGVidWcoJyNfc3RhcnRBdXRvUmVmcmVzaCgpJyk7XG4gICAgICAgIGNvbnN0IHRpY2tlciA9IHNldEludGVydmFsKCgpID0+IHRoaXMuX2F1dG9SZWZyZXNoVG9rZW5UaWNrKCksIEFVVE9fUkVGUkVTSF9USUNLX0RVUkFUSU9OKTtcbiAgICAgICAgdGhpcy5hdXRvUmVmcmVzaFRpY2tlciA9IHRpY2tlcjtcbiAgICAgICAgaWYgKHRpY2tlciAmJiB0eXBlb2YgdGlja2VyID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdGlja2VyLnVucmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyB0aWNrZXIgaXMgYSBOb2RlSlMgVGltZW91dCBvYmplY3QgdGhhdCBoYXMgYW4gYHVucmVmYCBtZXRob2RcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvdGltZXJzLmh0bWwjdGltZW91dHVucmVmXG4gICAgICAgICAgICAvLyBXaGVuIGF1dG8gcmVmcmVzaCBpcyB1c2VkIGluIE5vZGVKUyAobGlrZSBmb3IgdGVzdGluZykgdGhlXG4gICAgICAgICAgICAvLyBgc2V0SW50ZXJ2YWxgIGlzIHByZXZlbnRpbmcgdGhlIHByb2Nlc3MgZnJvbSBiZWluZyBtYXJrZWQgYXNcbiAgICAgICAgICAgIC8vIGZpbmlzaGVkIGFuZCB0ZXN0cyBydW4gZW5kbGVzc2x5LiBUaGlzIGNhbiBiZSBwcmV2ZW50ZWQgYnkgY2FsbGluZ1xuICAgICAgICAgICAgLy8gYHVucmVmKClgIG9uIHRoZSByZXR1cm5lZCBvYmplY3QuXG4gICAgICAgICAgICB0aWNrZXIudW5yZWYoKTtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVFMgaGFzIG5vIGNvbnRleHQgb2YgRGVub1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBEZW5vICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgRGVuby51bnJlZlRpbWVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBzaW1pbGFyIGxpa2UgZm9yIE5vZGVKUywgYnV0IHdpdGggdGhlIERlbm8gQVBJXG4gICAgICAgICAgICAvLyBodHRwczovL2Rlbm8ubGFuZC9hcGlAbGF0ZXN0P3Vuc3RhYmxlJnM9RGVuby51bnJlZlRpbWVyXG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRTIGhhcyBubyBjb250ZXh0IG9mIERlbm9cbiAgICAgICAgICAgIERlbm8udW5yZWZUaW1lcih0aWNrZXIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJ1biB0aGUgdGljayBpbW1lZGlhdGVseSwgYnV0IGluIHRoZSBuZXh0IHBhc3Mgb2YgdGhlIGV2ZW50IGxvb3Agc28gdGhhdFxuICAgICAgICAvLyAjX2luaXRpYWxpemUgY2FuIGJlIGFsbG93ZWQgdG8gY29tcGxldGUgd2l0aG91dCByZWN1cnNpdmVseSB3YWl0aW5nIG9uXG4gICAgICAgIC8vIGl0c2VsZlxuICAgICAgICBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2U7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9hdXRvUmVmcmVzaFRva2VuVGljaygpO1xuICAgICAgICB9LCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB0aGUgcHJpdmF0ZSBpbXBsZW1lbnRhdGlvbiBvZiB7QGxpbmsgI3N0b3BBdXRvUmVmcmVzaH0uIFVzZSB0aGlzXG4gICAgICogd2l0aGluIHRoZSBsaWJyYXJ5LlxuICAgICAqL1xuICAgIGFzeW5jIF9zdG9wQXV0b1JlZnJlc2goKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCcjX3N0b3BBdXRvUmVmcmVzaCgpJyk7XG4gICAgICAgIGNvbnN0IHRpY2tlciA9IHRoaXMuYXV0b1JlZnJlc2hUaWNrZXI7XG4gICAgICAgIHRoaXMuYXV0b1JlZnJlc2hUaWNrZXIgPSBudWxsO1xuICAgICAgICBpZiAodGlja2VyKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRpY2tlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnRzIGFuIGF1dG8tcmVmcmVzaCBwcm9jZXNzIGluIHRoZSBiYWNrZ3JvdW5kLiBUaGUgc2Vzc2lvbiBpcyBjaGVja2VkXG4gICAgICogZXZlcnkgZmV3IHNlY29uZHMuIENsb3NlIHRvIHRoZSB0aW1lIG9mIGV4cGlyYXRpb24gYSBwcm9jZXNzIGlzIHN0YXJ0ZWQgdG9cbiAgICAgKiByZWZyZXNoIHRoZSBzZXNzaW9uLiBJZiByZWZyZXNoaW5nIGZhaWxzIGl0IHdpbGwgYmUgcmV0cmllZCBmb3IgYXMgbG9uZyBhc1xuICAgICAqIG5lY2Vzc2FyeS5cbiAgICAgKlxuICAgICAqIElmIHlvdSBzZXQgdGhlIHtAbGluayBHb1RydWVDbGllbnRPcHRpb25zI2F1dG9SZWZyZXNoVG9rZW59IHlvdSBkb24ndCBuZWVkXG4gICAgICogdG8gY2FsbCB0aGlzIGZ1bmN0aW9uLCBpdCB3aWxsIGJlIGNhbGxlZCBmb3IgeW91LlxuICAgICAqXG4gICAgICogT24gYnJvd3NlcnMgdGhlIHJlZnJlc2ggcHJvY2VzcyB3b3JrcyBvbmx5IHdoZW4gdGhlIHRhYi93aW5kb3cgaXMgaW4gdGhlXG4gICAgICogZm9yZWdyb3VuZCB0byBjb25zZXJ2ZSByZXNvdXJjZXMgYXMgd2VsbCBhcyBwcmV2ZW50IHJhY2UgY29uZGl0aW9ucyBhbmRcbiAgICAgKiBmbG9vZGluZyBhdXRoIHdpdGggcmVxdWVzdHMuIElmIHlvdSBjYWxsIHRoaXMgbWV0aG9kIGFueSBtYW5hZ2VkXG4gICAgICogdmlzaWJpbGl0eSBjaGFuZ2UgY2FsbGJhY2sgd2lsbCBiZSByZW1vdmVkIGFuZCB5b3UgbXVzdCBtYW5hZ2UgdmlzaWJpbGl0eVxuICAgICAqIGNoYW5nZXMgb24geW91ciBvd24uXG4gICAgICpcbiAgICAgKiBPbiBub24tYnJvd3NlciBwbGF0Zm9ybXMgdGhlIHJlZnJlc2ggcHJvY2VzcyB3b3JrcyAqY29udGludW91c2x5KiBpbiB0aGVcbiAgICAgKiBiYWNrZ3JvdW5kLCB3aGljaCBtYXkgbm90IGJlIGRlc2lyYWJsZS4gWW91IHNob3VsZCBob29rIGludG8geW91clxuICAgICAqIHBsYXRmb3JtJ3MgZm9yZWdyb3VuZCBpbmRpY2F0aW9uIG1lY2hhbmlzbSBhbmQgY2FsbCB0aGVzZSBtZXRob2RzXG4gICAgICogYXBwcm9wcmlhdGVseSB0byBjb25zZXJ2ZSByZXNvdXJjZXMuXG4gICAgICpcbiAgICAgKiB7QHNlZSAjc3RvcEF1dG9SZWZyZXNofVxuICAgICAqL1xuICAgIGFzeW5jIHN0YXJ0QXV0b1JlZnJlc2goKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZVZpc2liaWxpdHlDaGFuZ2VkQ2FsbGJhY2soKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fc3RhcnRBdXRvUmVmcmVzaCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9wcyBhbiBhY3RpdmUgYXV0byByZWZyZXNoIHByb2Nlc3MgcnVubmluZyBpbiB0aGUgYmFja2dyb3VuZCAoaWYgYW55KS5cbiAgICAgKlxuICAgICAqIElmIHlvdSBjYWxsIHRoaXMgbWV0aG9kIGFueSBtYW5hZ2VkIHZpc2liaWxpdHkgY2hhbmdlIGNhbGxiYWNrIHdpbGwgYmVcbiAgICAgKiByZW1vdmVkIGFuZCB5b3UgbXVzdCBtYW5hZ2UgdmlzaWJpbGl0eSBjaGFuZ2VzIG9uIHlvdXIgb3duLlxuICAgICAqXG4gICAgICogU2VlIHtAbGluayAjc3RhcnRBdXRvUmVmcmVzaH0gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKi9cbiAgICBhc3luYyBzdG9wQXV0b1JlZnJlc2goKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZVZpc2liaWxpdHlDaGFuZ2VkQ2FsbGJhY2soKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fc3RvcEF1dG9SZWZyZXNoKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJ1bnMgdGhlIGF1dG8gcmVmcmVzaCB0b2tlbiB0aWNrLlxuICAgICAqL1xuICAgIGFzeW5jIF9hdXRvUmVmcmVzaFRva2VuVGljaygpIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJyNfYXV0b1JlZnJlc2hUb2tlblRpY2soKScsICdiZWdpbicpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2soMCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiB7IHNlc3Npb24gfSwgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNlc3Npb24gfHwgIXNlc3Npb24ucmVmcmVzaF90b2tlbiB8fCAhc2Vzc2lvbi5leHBpcmVzX2F0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX2F1dG9SZWZyZXNoVG9rZW5UaWNrKCknLCAnbm8gc2Vzc2lvbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlc3Npb24gd2lsbCBleHBpcmUgaW4gdGhpcyBtYW55IHRpY2tzIChvciBoYXMgYWxyZWFkeSBleHBpcmVkIGlmIDw9IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhwaXJlc0luVGlja3MgPSBNYXRoLmZsb29yKChzZXNzaW9uLmV4cGlyZXNfYXQgKiAxMDAwIC0gbm93KSAvIEFVVE9fUkVGUkVTSF9USUNLX0RVUkFUSU9OKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19hdXRvUmVmcmVzaFRva2VuVGljaygpJywgYGFjY2VzcyB0b2tlbiBleHBpcmVzIGluICR7ZXhwaXJlc0luVGlja3N9IHRpY2tzLCBhIHRpY2sgbGFzdHMgJHtBVVRPX1JFRlJFU0hfVElDS19EVVJBVElPTn1tcywgcmVmcmVzaCB0aHJlc2hvbGQgaXMgJHtBVVRPX1JFRlJFU0hfVElDS19USFJFU0hPTER9IHRpY2tzYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cGlyZXNJblRpY2tzIDw9IEFVVE9fUkVGUkVTSF9USUNLX1RIUkVTSE9MRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9jYWxsUmVmcmVzaFRva2VuKHNlc3Npb24ucmVmcmVzaF90b2tlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0F1dG8gcmVmcmVzaCB0aWNrIGZhaWxlZCB3aXRoIGVycm9yLiBUaGlzIGlzIGxpa2VseSBhIHRyYW5zaWVudCBlcnJvci4nLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoJyNfYXV0b1JlZnJlc2hUb2tlblRpY2soKScsICdlbmQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUuaXNBY3F1aXJlVGltZW91dCB8fCBlIGluc3RhbmNlb2YgTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnYXV0byByZWZyZXNoIHRva2VuIHRpY2sgbG9jayBub3QgYXZhaWxhYmxlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBjYWxsYmFja3Mgb24gdGhlIGJyb3dzZXIgLyBwbGF0Zm9ybSwgd2hpY2ggaW4tdHVybiBydW5cbiAgICAgKiBhbGdvcml0aG1zIHdoZW4gdGhlIGJyb3dzZXIgd2luZG93L3RhYiBhcmUgaW4gZm9yZWdyb3VuZC4gT24gbm9uLWJyb3dzZXJcbiAgICAgKiBwbGF0Zm9ybXMgaXQgYXNzdW1lcyBhbHdheXMgZm9yZWdyb3VuZC5cbiAgICAgKi9cbiAgICBhc3luYyBfaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSgpIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJyNfaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSgpJyk7XG4gICAgICAgIGlmICghaXNCcm93c2VyKCkgfHwgISh3aW5kb3cgPT09IG51bGwgfHwgd2luZG93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmF1dG9SZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAvLyBpbiBub24tYnJvd3NlciBlbnZpcm9ubWVudHMgdGhlIHJlZnJlc2ggdG9rZW4gdGlja2VyIHJ1bnMgYWx3YXlzXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydEF1dG9SZWZyZXNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMudmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjayA9IGFzeW5jICgpID0+IGF3YWl0IHRoaXMuX29uVmlzaWJpbGl0eUNoYW5nZWQoZmFsc2UpO1xuICAgICAgICAgICAgd2luZG93ID09PSBudWxsIHx8IHdpbmRvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCB0aGlzLnZpc2liaWxpdHlDaGFuZ2VkQ2FsbGJhY2spO1xuICAgICAgICAgICAgLy8gbm93IGltbWVkaWF0ZWx5IGNhbGwgdGhlIHZpc2JpbGl0eSBjaGFuZ2VkIGNhbGxiYWNrIHRvIHNldHVwIHdpdGggdGhlXG4gICAgICAgICAgICAvLyBjdXJyZW50IHZpc2JpbGl0eSBzdGF0ZVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5fb25WaXNpYmlsaXR5Q2hhbmdlZCh0cnVlKTsgLy8gaW5pdGlhbCBjYWxsXG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdfaGFuZGxlVmlzaWJpbGl0eUNoYW5nZScsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsYmFjayByZWdpc3RlcmVkIHdpdGggYHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJylgLlxuICAgICAqL1xuICAgIGFzeW5jIF9vblZpc2liaWxpdHlDaGFuZ2VkKGNhbGxlZEZyb21Jbml0aWFsaXplKSB7XG4gICAgICAgIGNvbnN0IG1ldGhvZE5hbWUgPSBgI19vblZpc2liaWxpdHlDaGFuZ2VkKCR7Y2FsbGVkRnJvbUluaXRpYWxpemV9KWA7XG4gICAgICAgIHRoaXMuX2RlYnVnKG1ldGhvZE5hbWUsICd2aXNpYmlsaXR5U3RhdGUnLCBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUpO1xuICAgICAgICBpZiAoZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSAndmlzaWJsZScpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmF1dG9SZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAvLyBpbiBicm93c2VyIGVudmlyb25tZW50cyB0aGUgcmVmcmVzaCB0b2tlbiB0aWNrZXIgcnVucyBvbmx5IG9uIGZvY3VzZWQgdGFic1xuICAgICAgICAgICAgICAgIC8vIHdoaWNoIHByZXZlbnRzIHJhY2UgY29uZGl0aW9uc1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0QXV0b1JlZnJlc2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY2FsbGVkRnJvbUluaXRpYWxpemUpIHtcbiAgICAgICAgICAgICAgICAvLyBjYWxsZWQgd2hlbiB0aGUgdmlzaWJpbGl0eSBoYXMgY2hhbmdlZCwgaS5lLiB0aGUgYnJvd3NlclxuICAgICAgICAgICAgICAgIC8vIHRyYW5zaXRpb25lZCBmcm9tIGhpZGRlbiAtPiB2aXNpYmxlIHNvIHdlIG5lZWQgdG8gc2VlIGlmIHRoZSBzZXNzaW9uXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIHJlY292ZXJlZCBpbW1lZGlhdGVseS4uLiBidXQgdG8gZG8gdGhhdCB3ZSBuZWVkIHRvIGFjcXVpcmVcbiAgICAgICAgICAgICAgICAvLyB0aGUgbG9jayBmaXJzdCBhc3luY2hyb25vdXNseVxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2U7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2soLTEsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSAhPT0gJ3Zpc2libGUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZyhtZXRob2ROYW1lLCAnYWNxdWlyZWQgdGhlIGxvY2sgdG8gcmVjb3ZlciB0aGUgc2Vzc2lvbiwgYnV0IHRoZSBicm93c2VyIHZpc2liaWxpdHlTdGF0ZSBpcyBubyBsb25nZXIgdmlzaWJsZSwgYWJvcnRpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZpc2liaWxpdHkgaGFzIGNoYW5nZWQgd2hpbGUgd2FpdGluZyBmb3IgdGhlIGxvY2ssIGFib3J0XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gcmVjb3ZlciB0aGUgc2Vzc2lvblxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9yZWNvdmVyQW5kUmVmcmVzaCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gJ2hpZGRlbicpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmF1dG9SZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdG9wQXV0b1JlZnJlc2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgdGhlIHJlbGV2YW50IGxvZ2luIFVSTCBmb3IgYSB0aGlyZC1wYXJ0eSBwcm92aWRlci5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5yZWRpcmVjdFRvIEEgVVJMIG9yIG1vYmlsZSBhZGRyZXNzIHRvIHNlbmQgdGhlIHVzZXIgdG8gYWZ0ZXIgdGhleSBhcmUgY29uZmlybWVkLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnNjb3BlcyBBIHNwYWNlLXNlcGFyYXRlZCBsaXN0IG9mIHNjb3BlcyBncmFudGVkIHRvIHRoZSBPQXV0aCBhcHBsaWNhdGlvbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5xdWVyeVBhcmFtcyBBbiBvYmplY3Qgb2Yga2V5LXZhbHVlIHBhaXJzIGNvbnRhaW5pbmcgcXVlcnkgcGFyYW1ldGVycyBncmFudGVkIHRvIHRoZSBPQXV0aCBhcHBsaWNhdGlvbi5cbiAgICAgKi9cbiAgICBhc3luYyBfZ2V0VXJsRm9yUHJvdmlkZXIodXJsLCBwcm92aWRlciwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB1cmxQYXJhbXMgPSBbYHByb3ZpZGVyPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHByb3ZpZGVyKX1gXTtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yZWRpcmVjdFRvKSB7XG4gICAgICAgICAgICB1cmxQYXJhbXMucHVzaChgcmVkaXJlY3RfdG89JHtlbmNvZGVVUklDb21wb25lbnQob3B0aW9ucy5yZWRpcmVjdFRvKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNjb3Blcykge1xuICAgICAgICAgICAgdXJsUGFyYW1zLnB1c2goYHNjb3Blcz0ke2VuY29kZVVSSUNvbXBvbmVudChvcHRpb25zLnNjb3Blcyl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZmxvd1R5cGUgPT09ICdwa2NlJykge1xuICAgICAgICAgICAgY29uc3QgW2NvZGVDaGFsbGVuZ2UsIGNvZGVDaGFsbGVuZ2VNZXRob2RdID0gYXdhaXQgZ2V0Q29kZUNoYWxsZW5nZUFuZE1ldGhvZCh0aGlzLnN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSk7XG4gICAgICAgICAgICBjb25zdCBmbG93UGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgICAgICAgICAgICAgY29kZV9jaGFsbGVuZ2U6IGAke2VuY29kZVVSSUNvbXBvbmVudChjb2RlQ2hhbGxlbmdlKX1gLFxuICAgICAgICAgICAgICAgIGNvZGVfY2hhbGxlbmdlX21ldGhvZDogYCR7ZW5jb2RlVVJJQ29tcG9uZW50KGNvZGVDaGFsbGVuZ2VNZXRob2QpfWAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHVybFBhcmFtcy5wdXNoKGZsb3dQYXJhbXMudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5xdWVyeVBhcmFtcykge1xuICAgICAgICAgICAgY29uc3QgcXVlcnkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKG9wdGlvbnMucXVlcnlQYXJhbXMpO1xuICAgICAgICAgICAgdXJsUGFyYW1zLnB1c2gocXVlcnkudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5za2lwQnJvd3NlclJlZGlyZWN0KSB7XG4gICAgICAgICAgICB1cmxQYXJhbXMucHVzaChgc2tpcF9odHRwX3JlZGlyZWN0PSR7b3B0aW9ucy5za2lwQnJvd3NlclJlZGlyZWN0fWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHt1cmx9PyR7dXJsUGFyYW1zLmpvaW4oJyYnKX1gO1xuICAgIH1cbiAgICBhc3luYyBfdW5lbnJvbGwocGFyYW1zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogc2Vzc2lvbkRhdGEsIGVycm9yOiBzZXNzaW9uRXJyb3IgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoc2Vzc2lvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiBzZXNzaW9uRXJyb3IgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdERUxFVEUnLCBgJHt0aGlzLnVybH0vZmFjdG9ycy8ke3BhcmFtcy5mYWN0b3JJZH1gLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgand0OiAoX2EgPSBzZXNzaW9uRGF0YSA9PT0gbnVsbCB8fCBzZXNzaW9uRGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2Vzc2lvbkRhdGEuc2Vzc2lvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFjY2Vzc190b2tlbixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfZW5yb2xsKHBhcmFtcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBzZXNzaW9uRGF0YSwgZXJyb3I6IHNlc3Npb25FcnJvciB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChzZXNzaW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IHNlc3Npb25FcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBib2R5ID0gT2JqZWN0LmFzc2lnbih7IGZyaWVuZGx5X25hbWU6IHBhcmFtcy5mcmllbmRseU5hbWUsIGZhY3Rvcl90eXBlOiBwYXJhbXMuZmFjdG9yVHlwZSB9LCAocGFyYW1zLmZhY3RvclR5cGUgPT09ICdwaG9uZScgPyB7IHBob25lOiBwYXJhbXMucGhvbmUgfSA6IHsgaXNzdWVyOiBwYXJhbXMuaXNzdWVyIH0pKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9mYWN0b3JzYCwge1xuICAgICAgICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGp3dDogKF9hID0gc2Vzc2lvbkRhdGEgPT09IG51bGwgfHwgc2Vzc2lvbkRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlc3Npb25EYXRhLnNlc3Npb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuZmFjdG9yVHlwZSA9PT0gJ3RvdHAnICYmICgoX2IgPSBkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGEudG90cCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnFyX2NvZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEudG90cC5xcl9jb2RlID0gYGRhdGE6aW1hZ2Uvc3ZnK3htbDt1dGYtOCwke2RhdGEudG90cC5xcl9jb2RlfWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICoge0BzZWUgR29UcnVlTUZBQXBpI3ZlcmlmeX1cbiAgICAgKi9cbiAgICBhc3luYyBfdmVyaWZ5KHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWNxdWlyZUxvY2soLTEsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogc2Vzc2lvbkRhdGEsIGVycm9yOiBzZXNzaW9uRXJyb3IgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlc3Npb25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IHNlc3Npb25FcnJvciB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L2ZhY3RvcnMvJHtwYXJhbXMuZmFjdG9ySWR9L3ZlcmlmeWAsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IHsgY29kZTogcGFyYW1zLmNvZGUsIGNoYWxsZW5nZV9pZDogcGFyYW1zLmNoYWxsZW5nZUlkIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBqd3Q6IChfYSA9IHNlc3Npb25EYXRhID09PSBudWxsIHx8IHNlc3Npb25EYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXNzaW9uRGF0YS5zZXNzaW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKE9iamVjdC5hc3NpZ24oeyBleHBpcmVzX2F0OiBNYXRoLnJvdW5kKERhdGUubm93KCkgLyAxMDAwKSArIGRhdGEuZXhwaXJlc19pbiB9LCBkYXRhKSk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdNRkFfQ0hBTExFTkdFX1ZFUklGSUVEJywgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICoge0BzZWUgR29UcnVlTUZBQXBpI2NoYWxsZW5nZX1cbiAgICAgKi9cbiAgICBhc3luYyBfY2hhbGxlbmdlKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWNxdWlyZUxvY2soLTEsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogc2Vzc2lvbkRhdGEsIGVycm9yOiBzZXNzaW9uRXJyb3IgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlc3Npb25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IHNlc3Npb25FcnJvciB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9mYWN0b3JzLyR7cGFyYW1zLmZhY3RvcklkfS9jaGFsbGVuZ2VgLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiB7IGNoYW5uZWw6IHBhcmFtcy5jaGFubmVsIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBqd3Q6IChfYSA9IHNlc3Npb25EYXRhID09PSBudWxsIHx8IHNlc3Npb25EYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXNzaW9uRGF0YS5zZXNzaW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB7QHNlZSBHb1RydWVNRkFBcGkjY2hhbGxlbmdlQW5kVmVyaWZ5fVxuICAgICAqL1xuICAgIGFzeW5jIF9jaGFsbGVuZ2VBbmRWZXJpZnkocGFyYW1zKSB7XG4gICAgICAgIC8vIGJvdGggX2NoYWxsZW5nZSBhbmQgX3ZlcmlmeSBpbmRlcGVuZGVudGx5IGFjcXVpcmUgdGhlIGxvY2ssIHNvIG5vIG5lZWRcbiAgICAgICAgLy8gdG8gYWNxdWlyZSBpdCBoZXJlXG4gICAgICAgIGNvbnN0IHsgZGF0YTogY2hhbGxlbmdlRGF0YSwgZXJyb3I6IGNoYWxsZW5nZUVycm9yIH0gPSBhd2FpdCB0aGlzLl9jaGFsbGVuZ2Uoe1xuICAgICAgICAgICAgZmFjdG9ySWQ6IHBhcmFtcy5mYWN0b3JJZCxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjaGFsbGVuZ2VFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IGNoYWxsZW5nZUVycm9yIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3ZlcmlmeSh7XG4gICAgICAgICAgICBmYWN0b3JJZDogcGFyYW1zLmZhY3RvcklkLFxuICAgICAgICAgICAgY2hhbGxlbmdlSWQ6IGNoYWxsZW5nZURhdGEuaWQsXG4gICAgICAgICAgICBjb2RlOiBwYXJhbXMuY29kZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHtAc2VlIEdvVHJ1ZU1GQUFwaSNsaXN0RmFjdG9yc31cbiAgICAgKi9cbiAgICBhc3luYyBfbGlzdEZhY3RvcnMoKSB7XG4gICAgICAgIC8vIHVzZSAjZ2V0VXNlciBpbnN0ZWFkIG9mICNfZ2V0VXNlciBhcyB0aGUgZm9ybWVyIGFjcXVpcmVzIGEgbG9ja1xuICAgICAgICBjb25zdCB7IGRhdGE6IHsgdXNlciB9LCBlcnJvcjogdXNlckVycm9yLCB9ID0gYXdhaXQgdGhpcy5nZXRVc2VyKCk7XG4gICAgICAgIGlmICh1c2VyRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiB1c2VyRXJyb3IgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmYWN0b3JzID0gKHVzZXIgPT09IG51bGwgfHwgdXNlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogdXNlci5mYWN0b3JzKSB8fCBbXTtcbiAgICAgICAgY29uc3QgdG90cCA9IGZhY3RvcnMuZmlsdGVyKChmYWN0b3IpID0+IGZhY3Rvci5mYWN0b3JfdHlwZSA9PT0gJ3RvdHAnICYmIGZhY3Rvci5zdGF0dXMgPT09ICd2ZXJpZmllZCcpO1xuICAgICAgICBjb25zdCBwaG9uZSA9IGZhY3RvcnMuZmlsdGVyKChmYWN0b3IpID0+IGZhY3Rvci5mYWN0b3JfdHlwZSA9PT0gJ3Bob25lJyAmJiBmYWN0b3Iuc3RhdHVzID09PSAndmVyaWZpZWQnKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBhbGw6IGZhY3RvcnMsXG4gICAgICAgICAgICAgICAgdG90cCxcbiAgICAgICAgICAgICAgICBwaG9uZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICoge0BzZWUgR29UcnVlTUZBQXBpI2dldEF1dGhlbnRpY2F0b3JBc3N1cmFuY2VMZXZlbH1cbiAgICAgKi9cbiAgICBhc3luYyBfZ2V0QXV0aGVudGljYXRvckFzc3VyYW5jZUxldmVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWNxdWlyZUxvY2soLTEsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogeyBzZXNzaW9uIH0sIGVycm9yOiBzZXNzaW9uRXJyb3IsIH0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKHNlc3Npb25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogc2Vzc2lvbkVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogeyBjdXJyZW50TGV2ZWw6IG51bGwsIG5leHRMZXZlbDogbnVsbCwgY3VycmVudEF1dGhlbnRpY2F0aW9uTWV0aG9kczogW10gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gdGhpcy5fZGVjb2RlSldUKHNlc3Npb24uYWNjZXNzX3Rva2VuKTtcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudExldmVsID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAocGF5bG9hZC5hYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudExldmVsID0gcGF5bG9hZC5hYWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBuZXh0TGV2ZWwgPSBjdXJyZW50TGV2ZWw7XG4gICAgICAgICAgICAgICAgY29uc3QgdmVyaWZpZWRGYWN0b3JzID0gKF9iID0gKF9hID0gc2Vzc2lvbi51c2VyLmZhY3RvcnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5maWx0ZXIoKGZhY3RvcikgPT4gZmFjdG9yLnN0YXR1cyA9PT0gJ3ZlcmlmaWVkJykpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdO1xuICAgICAgICAgICAgICAgIGlmICh2ZXJpZmllZEZhY3RvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBuZXh0TGV2ZWwgPSAnYWFsMic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRBdXRoZW50aWNhdGlvbk1ldGhvZHMgPSBwYXlsb2FkLmFtciB8fCBbXTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IGN1cnJlbnRMZXZlbCwgbmV4dExldmVsLCBjdXJyZW50QXV0aGVudGljYXRpb25NZXRob2RzIH0sIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuR29UcnVlQ2xpZW50Lm5leHRJbnN0YW5jZUlEID0gMDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdvVHJ1ZUNsaWVudC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/GoTrueClient.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthAdminApi: () => (/* reexport safe */ _AuthAdminApi__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   AuthApiError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthApiError),\n/* harmony export */   AuthClient: () => (/* reexport safe */ _AuthClient__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   AuthError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthError),\n/* harmony export */   AuthImplicitGrantRedirectError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthImplicitGrantRedirectError),\n/* harmony export */   AuthInvalidCredentialsError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthInvalidCredentialsError),\n/* harmony export */   AuthInvalidTokenResponseError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthInvalidTokenResponseError),\n/* harmony export */   AuthPKCEGrantCodeExchangeError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthPKCEGrantCodeExchangeError),\n/* harmony export */   AuthRetryableFetchError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthRetryableFetchError),\n/* harmony export */   AuthSessionMissingError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthSessionMissingError),\n/* harmony export */   AuthUnknownError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthUnknownError),\n/* harmony export */   AuthWeakPasswordError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthWeakPasswordError),\n/* harmony export */   CustomAuthError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.CustomAuthError),\n/* harmony export */   GoTrueAdminApi: () => (/* reexport safe */ _GoTrueAdminApi__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   GoTrueClient: () => (/* reexport safe */ _GoTrueClient__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   NavigatorLockAcquireTimeoutError: () => (/* reexport safe */ _lib_locks__WEBPACK_IMPORTED_MODULE_6__.NavigatorLockAcquireTimeoutError),\n/* harmony export */   isAuthApiError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthApiError),\n/* harmony export */   isAuthError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthError),\n/* harmony export */   isAuthImplicitGrantRedirectError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthImplicitGrantRedirectError),\n/* harmony export */   isAuthRetryableFetchError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthRetryableFetchError),\n/* harmony export */   isAuthSessionMissingError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthSessionMissingError),\n/* harmony export */   isAuthWeakPasswordError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthWeakPasswordError),\n/* harmony export */   lockInternals: () => (/* reexport safe */ _lib_locks__WEBPACK_IMPORTED_MODULE_6__.internals),\n/* harmony export */   navigatorLock: () => (/* reexport safe */ _lib_locks__WEBPACK_IMPORTED_MODULE_6__.navigatorLock)\n/* harmony export */ });\n/* harmony import */ var _GoTrueAdminApi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GoTrueAdminApi */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js\");\n/* harmony import */ var _GoTrueClient__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GoTrueClient */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/GoTrueClient.js\");\n/* harmony import */ var _AuthAdminApi__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AuthAdminApi */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/AuthAdminApi.js\");\n/* harmony import */ var _AuthClient__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AuthClient */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/AuthClient.js\");\n/* harmony import */ var _lib_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/types */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/types.js\");\n/* harmony import */ var _lib_errors__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/errors */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/errors.js\");\n/* harmony import */ var _lib_locks__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lib/locks */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/locks.js\");\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQThDO0FBQ0o7QUFDQTtBQUNKO0FBQzRCO0FBQ3RDO0FBQ0M7QUFDOEU7QUFDM0ciLCJzb3VyY2VzIjpbIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL1dvbmRlclZpdGUtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL2Rpc3QvbW9kdWxlL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBHb1RydWVBZG1pbkFwaSBmcm9tICcuL0dvVHJ1ZUFkbWluQXBpJztcbmltcG9ydCBHb1RydWVDbGllbnQgZnJvbSAnLi9Hb1RydWVDbGllbnQnO1xuaW1wb3J0IEF1dGhBZG1pbkFwaSBmcm9tICcuL0F1dGhBZG1pbkFwaSc7XG5pbXBvcnQgQXV0aENsaWVudCBmcm9tICcuL0F1dGhDbGllbnQnO1xuZXhwb3J0IHsgR29UcnVlQWRtaW5BcGksIEdvVHJ1ZUNsaWVudCwgQXV0aEFkbWluQXBpLCBBdXRoQ2xpZW50IH07XG5leHBvcnQgKiBmcm9tICcuL2xpYi90eXBlcyc7XG5leHBvcnQgKiBmcm9tICcuL2xpYi9lcnJvcnMnO1xuZXhwb3J0IHsgbmF2aWdhdG9yTG9jaywgTmF2aWdhdG9yTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IsIGludGVybmFscyBhcyBsb2NrSW50ZXJuYWxzLCB9IGZyb20gJy4vbGliL2xvY2tzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/constants.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/constants.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   API_VERSIONS: () => (/* binding */ API_VERSIONS),\n/* harmony export */   API_VERSION_HEADER_NAME: () => (/* binding */ API_VERSION_HEADER_NAME),\n/* harmony export */   AUDIENCE: () => (/* binding */ AUDIENCE),\n/* harmony export */   DEFAULT_HEADERS: () => (/* binding */ DEFAULT_HEADERS),\n/* harmony export */   EXPIRY_MARGIN: () => (/* binding */ EXPIRY_MARGIN),\n/* harmony export */   GOTRUE_URL: () => (/* binding */ GOTRUE_URL),\n/* harmony export */   NETWORK_FAILURE: () => (/* binding */ NETWORK_FAILURE),\n/* harmony export */   STORAGE_KEY: () => (/* binding */ STORAGE_KEY)\n/* harmony export */ });\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./version */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/version.js\");\n\nconst GOTRUE_URL = 'http://localhost:9999';\nconst STORAGE_KEY = 'supabase.auth.token';\nconst AUDIENCE = '';\nconst DEFAULT_HEADERS = { 'X-Client-Info': `gotrue-js/${_version__WEBPACK_IMPORTED_MODULE_0__.version}` };\nconst EXPIRY_MARGIN = 10; // in seconds\nconst NETWORK_FAILURE = {\n    MAX_RETRIES: 10,\n    RETRY_INTERVAL: 2, // in deciseconds\n};\nconst API_VERSION_HEADER_NAME = 'X-Supabase-Api-Version';\nconst API_VERSIONS = {\n    '2024-01-01': {\n        timestamp: Date.parse('2024-01-01T00:00:00.0Z'),\n        name: '2024-01-01',\n    },\n};\n//# sourceMappingURL=constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFvQztBQUM3QjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsOEJBQThCLDZDQUFPLENBQUM7QUFDaEUsMEJBQTBCO0FBQzFCO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvd29uZGVybGFuZG1pdGNoL0Nhc2NhZGVQcm9qZWN0cy9Xb25kZXJWaXRlLWZyb250ZW5kL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvY29uc3RhbnRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuL3ZlcnNpb24nO1xuZXhwb3J0IGNvbnN0IEdPVFJVRV9VUkwgPSAnaHR0cDovL2xvY2FsaG9zdDo5OTk5JztcbmV4cG9ydCBjb25zdCBTVE9SQUdFX0tFWSA9ICdzdXBhYmFzZS5hdXRoLnRva2VuJztcbmV4cG9ydCBjb25zdCBBVURJRU5DRSA9ICcnO1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfSEVBREVSUyA9IHsgJ1gtQ2xpZW50LUluZm8nOiBgZ290cnVlLWpzLyR7dmVyc2lvbn1gIH07XG5leHBvcnQgY29uc3QgRVhQSVJZX01BUkdJTiA9IDEwOyAvLyBpbiBzZWNvbmRzXG5leHBvcnQgY29uc3QgTkVUV09SS19GQUlMVVJFID0ge1xuICAgIE1BWF9SRVRSSUVTOiAxMCxcbiAgICBSRVRSWV9JTlRFUlZBTDogMiwgLy8gaW4gZGVjaXNlY29uZHNcbn07XG5leHBvcnQgY29uc3QgQVBJX1ZFUlNJT05fSEVBREVSX05BTUUgPSAnWC1TdXBhYmFzZS1BcGktVmVyc2lvbic7XG5leHBvcnQgY29uc3QgQVBJX1ZFUlNJT05TID0ge1xuICAgICcyMDI0LTAxLTAxJzoge1xuICAgICAgICB0aW1lc3RhbXA6IERhdGUucGFyc2UoJzIwMjQtMDEtMDFUMDA6MDA6MDAuMFonKSxcbiAgICAgICAgbmFtZTogJzIwMjQtMDEtMDEnLFxuICAgIH0sXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/constants.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/errors.js":
/*!******************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/errors.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthApiError: () => (/* binding */ AuthApiError),\n/* harmony export */   AuthError: () => (/* binding */ AuthError),\n/* harmony export */   AuthImplicitGrantRedirectError: () => (/* binding */ AuthImplicitGrantRedirectError),\n/* harmony export */   AuthInvalidCredentialsError: () => (/* binding */ AuthInvalidCredentialsError),\n/* harmony export */   AuthInvalidTokenResponseError: () => (/* binding */ AuthInvalidTokenResponseError),\n/* harmony export */   AuthPKCEGrantCodeExchangeError: () => (/* binding */ AuthPKCEGrantCodeExchangeError),\n/* harmony export */   AuthRetryableFetchError: () => (/* binding */ AuthRetryableFetchError),\n/* harmony export */   AuthSessionMissingError: () => (/* binding */ AuthSessionMissingError),\n/* harmony export */   AuthUnknownError: () => (/* binding */ AuthUnknownError),\n/* harmony export */   AuthWeakPasswordError: () => (/* binding */ AuthWeakPasswordError),\n/* harmony export */   CustomAuthError: () => (/* binding */ CustomAuthError),\n/* harmony export */   isAuthApiError: () => (/* binding */ isAuthApiError),\n/* harmony export */   isAuthError: () => (/* binding */ isAuthError),\n/* harmony export */   isAuthImplicitGrantRedirectError: () => (/* binding */ isAuthImplicitGrantRedirectError),\n/* harmony export */   isAuthRetryableFetchError: () => (/* binding */ isAuthRetryableFetchError),\n/* harmony export */   isAuthSessionMissingError: () => (/* binding */ isAuthSessionMissingError),\n/* harmony export */   isAuthWeakPasswordError: () => (/* binding */ isAuthWeakPasswordError)\n/* harmony export */ });\nclass AuthError extends Error {\n    constructor(message, status, code) {\n        super(message);\n        this.__isAuthError = true;\n        this.name = 'AuthError';\n        this.status = status;\n        this.code = code;\n    }\n}\nfunction isAuthError(error) {\n    return typeof error === 'object' && error !== null && '__isAuthError' in error;\n}\nclass AuthApiError extends AuthError {\n    constructor(message, status, code) {\n        super(message, status, code);\n        this.name = 'AuthApiError';\n        this.status = status;\n        this.code = code;\n    }\n}\nfunction isAuthApiError(error) {\n    return isAuthError(error) && error.name === 'AuthApiError';\n}\nclass AuthUnknownError extends AuthError {\n    constructor(message, originalError) {\n        super(message);\n        this.name = 'AuthUnknownError';\n        this.originalError = originalError;\n    }\n}\nclass CustomAuthError extends AuthError {\n    constructor(message, name, status, code) {\n        super(message, status, code);\n        this.name = name;\n        this.status = status;\n    }\n}\nclass AuthSessionMissingError extends CustomAuthError {\n    constructor() {\n        super('Auth session missing!', 'AuthSessionMissingError', 400, undefined);\n    }\n}\nfunction isAuthSessionMissingError(error) {\n    return isAuthError(error) && error.name === 'AuthSessionMissingError';\n}\nclass AuthInvalidTokenResponseError extends CustomAuthError {\n    constructor() {\n        super('Auth session or user missing', 'AuthInvalidTokenResponseError', 500, undefined);\n    }\n}\nclass AuthInvalidCredentialsError extends CustomAuthError {\n    constructor(message) {\n        super(message, 'AuthInvalidCredentialsError', 400, undefined);\n    }\n}\nclass AuthImplicitGrantRedirectError extends CustomAuthError {\n    constructor(message, details = null) {\n        super(message, 'AuthImplicitGrantRedirectError', 500, undefined);\n        this.details = null;\n        this.details = details;\n    }\n    toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            status: this.status,\n            details: this.details,\n        };\n    }\n}\nfunction isAuthImplicitGrantRedirectError(error) {\n    return isAuthError(error) && error.name === 'AuthImplicitGrantRedirectError';\n}\nclass AuthPKCEGrantCodeExchangeError extends CustomAuthError {\n    constructor(message, details = null) {\n        super(message, 'AuthPKCEGrantCodeExchangeError', 500, undefined);\n        this.details = null;\n        this.details = details;\n    }\n    toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            status: this.status,\n            details: this.details,\n        };\n    }\n}\nclass AuthRetryableFetchError extends CustomAuthError {\n    constructor(message, status) {\n        super(message, 'AuthRetryableFetchError', status, undefined);\n    }\n}\nfunction isAuthRetryableFetchError(error) {\n    return isAuthError(error) && error.name === 'AuthRetryableFetchError';\n}\n/**\n * This error is thrown on certain methods when the password used is deemed\n * weak. Inspect the reasons to identify what password strength rules are\n * inadequate.\n */\nclass AuthWeakPasswordError extends CustomAuthError {\n    constructor(message, status, reasons) {\n        super(message, 'AuthWeakPasswordError', status, 'weak_password');\n        this.reasons = reasons;\n    }\n}\nfunction isAuthWeakPasswordError(error) {\n    return isAuthError(error) && error.name === 'AuthWeakPasswordError';\n}\n//# sourceMappingURL=errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvZXJyb3JzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvd29uZGVybGFuZG1pdGNoL0Nhc2NhZGVQcm9qZWN0cy9Xb25kZXJWaXRlLWZyb250ZW5kL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvZXJyb3JzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjbGFzcyBBdXRoRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhdHVzLCBjb2RlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLl9faXNBdXRoRXJyb3IgPSB0cnVlO1xuICAgICAgICB0aGlzLm5hbWUgPSAnQXV0aEVycm9yJztcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQXV0aEVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcgJiYgZXJyb3IgIT09IG51bGwgJiYgJ19faXNBdXRoRXJyb3InIGluIGVycm9yO1xufVxuZXhwb3J0IGNsYXNzIEF1dGhBcGlFcnJvciBleHRlbmRzIEF1dGhFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhdHVzLCBjb2RlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsIHN0YXR1cywgY29kZSk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdBdXRoQXBpRXJyb3InO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNBdXRoQXBpRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gaXNBdXRoRXJyb3IoZXJyb3IpICYmIGVycm9yLm5hbWUgPT09ICdBdXRoQXBpRXJyb3InO1xufVxuZXhwb3J0IGNsYXNzIEF1dGhVbmtub3duRXJyb3IgZXh0ZW5kcyBBdXRoRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG9yaWdpbmFsRXJyb3IpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdBdXRoVW5rbm93bkVycm9yJztcbiAgICAgICAgdGhpcy5vcmlnaW5hbEVycm9yID0gb3JpZ2luYWxFcnJvcjtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQ3VzdG9tQXV0aEVycm9yIGV4dGVuZHMgQXV0aEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBuYW1lLCBzdGF0dXMsIGNvZGUpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgc3RhdHVzLCBjb2RlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yIGV4dGVuZHMgQ3VzdG9tQXV0aEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ0F1dGggc2Vzc2lvbiBtaXNzaW5nIScsICdBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcicsIDQwMCwgdW5kZWZpbmVkKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBpc0F1dGhFcnJvcihlcnJvcikgJiYgZXJyb3IubmFtZSA9PT0gJ0F1dGhTZXNzaW9uTWlzc2luZ0Vycm9yJztcbn1cbmV4cG9ydCBjbGFzcyBBdXRoSW52YWxpZFRva2VuUmVzcG9uc2VFcnJvciBleHRlbmRzIEN1c3RvbUF1dGhFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdBdXRoIHNlc3Npb24gb3IgdXNlciBtaXNzaW5nJywgJ0F1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yJywgNTAwLCB1bmRlZmluZWQpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBBdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3IgZXh0ZW5kcyBDdXN0b21BdXRoRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgJ0F1dGhJbnZhbGlkQ3JlZGVudGlhbHNFcnJvcicsIDQwMCwgdW5kZWZpbmVkKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yIGV4dGVuZHMgQ3VzdG9tQXV0aEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBkZXRhaWxzID0gbnVsbCkge1xuICAgICAgICBzdXBlcihtZXNzYWdlLCAnQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yJywgNTAwLCB1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLmRldGFpbHMgPSBudWxsO1xuICAgICAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICAgICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgICAgICAgZGV0YWlsczogdGhpcy5kZXRhaWxzLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0F1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBpc0F1dGhFcnJvcihlcnJvcikgJiYgZXJyb3IubmFtZSA9PT0gJ0F1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcic7XG59XG5leHBvcnQgY2xhc3MgQXV0aFBLQ0VHcmFudENvZGVFeGNoYW5nZUVycm9yIGV4dGVuZHMgQ3VzdG9tQXV0aEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBkZXRhaWxzID0gbnVsbCkge1xuICAgICAgICBzdXBlcihtZXNzYWdlLCAnQXV0aFBLQ0VHcmFudENvZGVFeGNoYW5nZUVycm9yJywgNTAwLCB1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLmRldGFpbHMgPSBudWxsO1xuICAgICAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICAgICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgICAgICAgZGV0YWlsczogdGhpcy5kZXRhaWxzLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvciBleHRlbmRzIEN1c3RvbUF1dGhFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhdHVzKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsICdBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcicsIHN0YXR1cywgdW5kZWZpbmVkKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBpc0F1dGhFcnJvcihlcnJvcikgJiYgZXJyb3IubmFtZSA9PT0gJ0F1dGhSZXRyeWFibGVGZXRjaEVycm9yJztcbn1cbi8qKlxuICogVGhpcyBlcnJvciBpcyB0aHJvd24gb24gY2VydGFpbiBtZXRob2RzIHdoZW4gdGhlIHBhc3N3b3JkIHVzZWQgaXMgZGVlbWVkXG4gKiB3ZWFrLiBJbnNwZWN0IHRoZSByZWFzb25zIHRvIGlkZW50aWZ5IHdoYXQgcGFzc3dvcmQgc3RyZW5ndGggcnVsZXMgYXJlXG4gKiBpbmFkZXF1YXRlLlxuICovXG5leHBvcnQgY2xhc3MgQXV0aFdlYWtQYXNzd29yZEVycm9yIGV4dGVuZHMgQ3VzdG9tQXV0aEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdGF0dXMsIHJlYXNvbnMpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgJ0F1dGhXZWFrUGFzc3dvcmRFcnJvcicsIHN0YXR1cywgJ3dlYWtfcGFzc3dvcmQnKTtcbiAgICAgICAgdGhpcy5yZWFzb25zID0gcmVhc29ucztcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNBdXRoV2Vha1Bhc3N3b3JkRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gaXNBdXRoRXJyb3IoZXJyb3IpICYmIGVycm9yLm5hbWUgPT09ICdBdXRoV2Vha1Bhc3N3b3JkRXJyb3InO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/errors.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/fetch.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/fetch.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _generateLinkResponse: () => (/* binding */ _generateLinkResponse),\n/* harmony export */   _noResolveJsonResponse: () => (/* binding */ _noResolveJsonResponse),\n/* harmony export */   _request: () => (/* binding */ _request),\n/* harmony export */   _sessionResponse: () => (/* binding */ _sessionResponse),\n/* harmony export */   _sessionResponsePassword: () => (/* binding */ _sessionResponsePassword),\n/* harmony export */   _ssoResponse: () => (/* binding */ _ssoResponse),\n/* harmony export */   _userResponse: () => (/* binding */ _userResponse),\n/* harmony export */   handleError: () => (/* binding */ handleError)\n/* harmony export */ });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/constants.js\");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/helpers.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./errors */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/errors.js\");\nvar __rest = (undefined && undefined.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\n\n\n\nconst _getErrorMessage = (err) => err.msg || err.message || err.error_description || err.error || JSON.stringify(err);\nconst NETWORK_ERROR_CODES = [502, 503, 504];\nasync function handleError(error) {\n    var _a;\n    if (!(0,_helpers__WEBPACK_IMPORTED_MODULE_1__.looksLikeFetchResponse)(error)) {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthRetryableFetchError(_getErrorMessage(error), 0);\n    }\n    if (NETWORK_ERROR_CODES.includes(error.status)) {\n        // status in 500...599 range - server had an error, request might be retryed.\n        throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthRetryableFetchError(_getErrorMessage(error), error.status);\n    }\n    let data;\n    try {\n        data = await error.json();\n    }\n    catch (e) {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthUnknownError(_getErrorMessage(e), e);\n    }\n    let errorCode = undefined;\n    const responseAPIVersion = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.parseResponseAPIVersion)(error);\n    if (responseAPIVersion &&\n        responseAPIVersion.getTime() >= _constants__WEBPACK_IMPORTED_MODULE_0__.API_VERSIONS['2024-01-01'].timestamp &&\n        typeof data === 'object' &&\n        data &&\n        typeof data.code === 'string') {\n        errorCode = data.code;\n    }\n    else if (typeof data === 'object' && data && typeof data.error_code === 'string') {\n        errorCode = data.error_code;\n    }\n    if (!errorCode) {\n        // Legacy support for weak password errors, when there were no error codes\n        if (typeof data === 'object' &&\n            data &&\n            typeof data.weak_password === 'object' &&\n            data.weak_password &&\n            Array.isArray(data.weak_password.reasons) &&\n            data.weak_password.reasons.length &&\n            data.weak_password.reasons.reduce((a, i) => a && typeof i === 'string', true)) {\n            throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthWeakPasswordError(_getErrorMessage(data), error.status, data.weak_password.reasons);\n        }\n    }\n    else if (errorCode === 'weak_password') {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthWeakPasswordError(_getErrorMessage(data), error.status, ((_a = data.weak_password) === null || _a === void 0 ? void 0 : _a.reasons) || []);\n    }\n    else if (errorCode === 'session_not_found') {\n        // The `session_id` inside the JWT does not correspond to a row in the\n        // `sessions` table. This usually means the user has signed out, has been\n        // deleted, or their session has somehow been terminated.\n        throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();\n    }\n    throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthApiError(_getErrorMessage(data), error.status || 500, errorCode);\n}\nconst _getRequestParams = (method, options, parameters, body) => {\n    const params = { method, headers: (options === null || options === void 0 ? void 0 : options.headers) || {} };\n    if (method === 'GET') {\n        return params;\n    }\n    params.headers = Object.assign({ 'Content-Type': 'application/json;charset=UTF-8' }, options === null || options === void 0 ? void 0 : options.headers);\n    params.body = JSON.stringify(body);\n    return Object.assign(Object.assign({}, params), parameters);\n};\nasync function _request(fetcher, method, url, options) {\n    var _a;\n    const headers = Object.assign({}, options === null || options === void 0 ? void 0 : options.headers);\n    if (!headers[_constants__WEBPACK_IMPORTED_MODULE_0__.API_VERSION_HEADER_NAME]) {\n        headers[_constants__WEBPACK_IMPORTED_MODULE_0__.API_VERSION_HEADER_NAME] = _constants__WEBPACK_IMPORTED_MODULE_0__.API_VERSIONS['2024-01-01'].name;\n    }\n    if (options === null || options === void 0 ? void 0 : options.jwt) {\n        headers['Authorization'] = `Bearer ${options.jwt}`;\n    }\n    const qs = (_a = options === null || options === void 0 ? void 0 : options.query) !== null && _a !== void 0 ? _a : {};\n    if (options === null || options === void 0 ? void 0 : options.redirectTo) {\n        qs['redirect_to'] = options.redirectTo;\n    }\n    const queryString = Object.keys(qs).length ? '?' + new URLSearchParams(qs).toString() : '';\n    const data = await _handleRequest(fetcher, method, url + queryString, {\n        headers,\n        noResolveJson: options === null || options === void 0 ? void 0 : options.noResolveJson,\n    }, {}, options === null || options === void 0 ? void 0 : options.body);\n    return (options === null || options === void 0 ? void 0 : options.xform) ? options === null || options === void 0 ? void 0 : options.xform(data) : { data: Object.assign({}, data), error: null };\n}\nasync function _handleRequest(fetcher, method, url, options, parameters, body) {\n    const requestParams = _getRequestParams(method, options, parameters, body);\n    let result;\n    try {\n        result = await fetcher(url, Object.assign({}, requestParams));\n    }\n    catch (e) {\n        console.error(e);\n        // fetch failed, likely due to a network or CORS error\n        throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthRetryableFetchError(_getErrorMessage(e), 0);\n    }\n    if (!result.ok) {\n        await handleError(result);\n    }\n    if (options === null || options === void 0 ? void 0 : options.noResolveJson) {\n        return result;\n    }\n    try {\n        return await result.json();\n    }\n    catch (e) {\n        await handleError(e);\n    }\n}\nfunction _sessionResponse(data) {\n    var _a;\n    let session = null;\n    if (hasSession(data)) {\n        session = Object.assign({}, data);\n        if (!data.expires_at) {\n            session.expires_at = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.expiresAt)(data.expires_in);\n        }\n    }\n    const user = (_a = data.user) !== null && _a !== void 0 ? _a : data;\n    return { data: { session, user }, error: null };\n}\nfunction _sessionResponsePassword(data) {\n    const response = _sessionResponse(data);\n    if (!response.error &&\n        data.weak_password &&\n        typeof data.weak_password === 'object' &&\n        Array.isArray(data.weak_password.reasons) &&\n        data.weak_password.reasons.length &&\n        data.weak_password.message &&\n        typeof data.weak_password.message === 'string' &&\n        data.weak_password.reasons.reduce((a, i) => a && typeof i === 'string', true)) {\n        response.data.weak_password = data.weak_password;\n    }\n    return response;\n}\nfunction _userResponse(data) {\n    var _a;\n    const user = (_a = data.user) !== null && _a !== void 0 ? _a : data;\n    return { data: { user }, error: null };\n}\nfunction _ssoResponse(data) {\n    return { data, error: null };\n}\nfunction _generateLinkResponse(data) {\n    const { action_link, email_otp, hashed_token, redirect_to, verification_type } = data, rest = __rest(data, [\"action_link\", \"email_otp\", \"hashed_token\", \"redirect_to\", \"verification_type\"]);\n    const properties = {\n        action_link,\n        email_otp,\n        hashed_token,\n        redirect_to,\n        verification_type,\n    };\n    const user = Object.assign({}, rest);\n    return {\n        data: {\n            properties,\n            user,\n        },\n        error: null,\n    };\n}\nfunction _noResolveJsonResponse(data) {\n    return data;\n}\n/**\n * hasSession checks if the response object contains a valid session\n * @param data A response object\n * @returns true if a session is in the response\n */\nfunction hasSession(data) {\n    return data.access_token && data.refresh_token && data.expires_in;\n}\n//# sourceMappingURL=fetch.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvZmV0Y2guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQSxjQUFjLFNBQUksSUFBSSxTQUFJO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGNBQWM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNvRTtBQUNtQjtBQUM2QztBQUNwSTtBQUNBO0FBQ087QUFDUDtBQUNBLFNBQVMsZ0VBQXNCO0FBQy9CLGtCQUFrQiw0REFBdUI7QUFDekM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDREQUF1QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscURBQWdCO0FBQ2xDO0FBQ0E7QUFDQSwrQkFBK0IsaUVBQXVCO0FBQ3REO0FBQ0Esd0NBQXdDLG9EQUFZO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMERBQXFCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwwREFBcUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw0REFBdUI7QUFDekM7QUFDQSxjQUFjLGlEQUFZO0FBQzFCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGtDQUFrQyxnQkFBZ0I7QUFDdkY7QUFDQSx5Q0FBeUM7QUFDekM7QUFDTztBQUNQO0FBQ0Esb0NBQW9DO0FBQ3BDLGlCQUFpQiwrREFBdUI7QUFDeEMsZ0JBQWdCLCtEQUF1QixJQUFJLG9EQUFZO0FBQ3ZEO0FBQ0E7QUFDQSw2Q0FBNkMsWUFBWTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVCx5SkFBeUosc0JBQXNCO0FBQy9LO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNERBQXVCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBLGlDQUFpQyxtREFBUztBQUMxQztBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVEsZUFBZTtBQUNwQztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxhQUFhLFFBQVEsTUFBTTtBQUMzQjtBQUNPO0FBQ1AsYUFBYTtBQUNiO0FBQ087QUFDUCxZQUFZLHVFQUF1RTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL1dvbmRlclZpdGUtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL2Rpc3QvbW9kdWxlL2xpYi9mZXRjaC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19yZXN0ID0gKHRoaXMgJiYgdGhpcy5fX3Jlc3QpIHx8IGZ1bmN0aW9uIChzLCBlKSB7XG4gICAgdmFyIHQgPSB7fTtcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgICAgIH1cbiAgICByZXR1cm4gdDtcbn07XG5pbXBvcnQgeyBBUElfVkVSU0lPTlMsIEFQSV9WRVJTSU9OX0hFQURFUl9OQU1FIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgZXhwaXJlc0F0LCBsb29rc0xpa2VGZXRjaFJlc3BvbnNlLCBwYXJzZVJlc3BvbnNlQVBJVmVyc2lvbiB9IGZyb20gJy4vaGVscGVycyc7XG5pbXBvcnQgeyBBdXRoQXBpRXJyb3IsIEF1dGhSZXRyeWFibGVGZXRjaEVycm9yLCBBdXRoV2Vha1Bhc3N3b3JkRXJyb3IsIEF1dGhVbmtub3duRXJyb3IsIEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yLCB9IGZyb20gJy4vZXJyb3JzJztcbmNvbnN0IF9nZXRFcnJvck1lc3NhZ2UgPSAoZXJyKSA9PiBlcnIubXNnIHx8IGVyci5tZXNzYWdlIHx8IGVyci5lcnJvcl9kZXNjcmlwdGlvbiB8fCBlcnIuZXJyb3IgfHwgSlNPTi5zdHJpbmdpZnkoZXJyKTtcbmNvbnN0IE5FVFdPUktfRVJST1JfQ09ERVMgPSBbNTAyLCA1MDMsIDUwNF07XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaGFuZGxlRXJyb3IoZXJyb3IpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCFsb29rc0xpa2VGZXRjaFJlc3BvbnNlKGVycm9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IoX2dldEVycm9yTWVzc2FnZShlcnJvciksIDApO1xuICAgIH1cbiAgICBpZiAoTkVUV09SS19FUlJPUl9DT0RFUy5pbmNsdWRlcyhlcnJvci5zdGF0dXMpKSB7XG4gICAgICAgIC8vIHN0YXR1cyBpbiA1MDAuLi41OTkgcmFuZ2UgLSBzZXJ2ZXIgaGFkIGFuIGVycm9yLCByZXF1ZXN0IG1pZ2h0IGJlIHJldHJ5ZWQuXG4gICAgICAgIHRocm93IG5ldyBBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcihfZ2V0RXJyb3JNZXNzYWdlKGVycm9yKSwgZXJyb3Iuc3RhdHVzKTtcbiAgICB9XG4gICAgbGV0IGRhdGE7XG4gICAgdHJ5IHtcbiAgICAgICAgZGF0YSA9IGF3YWl0IGVycm9yLmpzb24oKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEF1dGhVbmtub3duRXJyb3IoX2dldEVycm9yTWVzc2FnZShlKSwgZSk7XG4gICAgfVxuICAgIGxldCBlcnJvckNvZGUgPSB1bmRlZmluZWQ7XG4gICAgY29uc3QgcmVzcG9uc2VBUElWZXJzaW9uID0gcGFyc2VSZXNwb25zZUFQSVZlcnNpb24oZXJyb3IpO1xuICAgIGlmIChyZXNwb25zZUFQSVZlcnNpb24gJiZcbiAgICAgICAgcmVzcG9uc2VBUElWZXJzaW9uLmdldFRpbWUoKSA+PSBBUElfVkVSU0lPTlNbJzIwMjQtMDEtMDEnXS50aW1lc3RhbXAgJiZcbiAgICAgICAgdHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmXG4gICAgICAgIGRhdGEgJiZcbiAgICAgICAgdHlwZW9mIGRhdGEuY29kZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZXJyb3JDb2RlID0gZGF0YS5jb2RlO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgJiYgZGF0YSAmJiB0eXBlb2YgZGF0YS5lcnJvcl9jb2RlID09PSAnc3RyaW5nJykge1xuICAgICAgICBlcnJvckNvZGUgPSBkYXRhLmVycm9yX2NvZGU7XG4gICAgfVxuICAgIGlmICghZXJyb3JDb2RlKSB7XG4gICAgICAgIC8vIExlZ2FjeSBzdXBwb3J0IGZvciB3ZWFrIHBhc3N3b3JkIGVycm9ycywgd2hlbiB0aGVyZSB3ZXJlIG5vIGVycm9yIGNvZGVzXG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIGRhdGEgJiZcbiAgICAgICAgICAgIHR5cGVvZiBkYXRhLndlYWtfcGFzc3dvcmQgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBkYXRhLndlYWtfcGFzc3dvcmQgJiZcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoZGF0YS53ZWFrX3Bhc3N3b3JkLnJlYXNvbnMpICYmXG4gICAgICAgICAgICBkYXRhLndlYWtfcGFzc3dvcmQucmVhc29ucy5sZW5ndGggJiZcbiAgICAgICAgICAgIGRhdGEud2Vha19wYXNzd29yZC5yZWFzb25zLnJlZHVjZSgoYSwgaSkgPT4gYSAmJiB0eXBlb2YgaSA9PT0gJ3N0cmluZycsIHRydWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXV0aFdlYWtQYXNzd29yZEVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZGF0YSksIGVycm9yLnN0YXR1cywgZGF0YS53ZWFrX3Bhc3N3b3JkLnJlYXNvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGVycm9yQ29kZSA9PT0gJ3dlYWtfcGFzc3dvcmQnKSB7XG4gICAgICAgIHRocm93IG5ldyBBdXRoV2Vha1Bhc3N3b3JkRXJyb3IoX2dldEVycm9yTWVzc2FnZShkYXRhKSwgZXJyb3Iuc3RhdHVzLCAoKF9hID0gZGF0YS53ZWFrX3Bhc3N3b3JkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVhc29ucykgfHwgW10pO1xuICAgIH1cbiAgICBlbHNlIGlmIChlcnJvckNvZGUgPT09ICdzZXNzaW9uX25vdF9mb3VuZCcpIHtcbiAgICAgICAgLy8gVGhlIGBzZXNzaW9uX2lkYCBpbnNpZGUgdGhlIEpXVCBkb2VzIG5vdCBjb3JyZXNwb25kIHRvIGEgcm93IGluIHRoZVxuICAgICAgICAvLyBgc2Vzc2lvbnNgIHRhYmxlLiBUaGlzIHVzdWFsbHkgbWVhbnMgdGhlIHVzZXIgaGFzIHNpZ25lZCBvdXQsIGhhcyBiZWVuXG4gICAgICAgIC8vIGRlbGV0ZWQsIG9yIHRoZWlyIHNlc3Npb24gaGFzIHNvbWVob3cgYmVlbiB0ZXJtaW5hdGVkLlxuICAgICAgICB0aHJvdyBuZXcgQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEF1dGhBcGlFcnJvcihfZ2V0RXJyb3JNZXNzYWdlKGRhdGEpLCBlcnJvci5zdGF0dXMgfHwgNTAwLCBlcnJvckNvZGUpO1xufVxuY29uc3QgX2dldFJlcXVlc3RQYXJhbXMgPSAobWV0aG9kLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCBib2R5KSA9PiB7XG4gICAgY29uc3QgcGFyYW1zID0geyBtZXRob2QsIGhlYWRlcnM6IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaGVhZGVycykgfHwge30gfTtcbiAgICBpZiAobWV0aG9kID09PSAnR0VUJykge1xuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cbiAgICBwYXJhbXMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb247Y2hhcnNldD1VVEYtOCcgfSwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRlcnMpO1xuICAgIHBhcmFtcy5ib2R5ID0gSlNPTi5zdHJpbmdpZnkoYm9keSk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1zKSwgcGFyYW1ldGVycyk7XG59O1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIF9yZXF1ZXN0KGZldGNoZXIsIG1ldGhvZCwgdXJsLCBvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaGVhZGVycyk7XG4gICAgaWYgKCFoZWFkZXJzW0FQSV9WRVJTSU9OX0hFQURFUl9OQU1FXSkge1xuICAgICAgICBoZWFkZXJzW0FQSV9WRVJTSU9OX0hFQURFUl9OQU1FXSA9IEFQSV9WRVJTSU9OU1snMjAyNC0wMS0wMSddLm5hbWU7XG4gICAgfVxuICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuand0KSB7XG4gICAgICAgIGhlYWRlcnNbJ0F1dGhvcml6YXRpb24nXSA9IGBCZWFyZXIgJHtvcHRpb25zLmp3dH1gO1xuICAgIH1cbiAgICBjb25zdCBxcyA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5xdWVyeSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge307XG4gICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yZWRpcmVjdFRvKSB7XG4gICAgICAgIHFzWydyZWRpcmVjdF90byddID0gb3B0aW9ucy5yZWRpcmVjdFRvO1xuICAgIH1cbiAgICBjb25zdCBxdWVyeVN0cmluZyA9IE9iamVjdC5rZXlzKHFzKS5sZW5ndGggPyAnPycgKyBuZXcgVVJMU2VhcmNoUGFyYW1zKHFzKS50b1N0cmluZygpIDogJyc7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IF9oYW5kbGVSZXF1ZXN0KGZldGNoZXIsIG1ldGhvZCwgdXJsICsgcXVlcnlTdHJpbmcsIHtcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgbm9SZXNvbHZlSnNvbjogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm5vUmVzb2x2ZUpzb24sXG4gICAgfSwge30sIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5ib2R5KTtcbiAgICByZXR1cm4gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy54Zm9ybSkgPyBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMueGZvcm0oZGF0YSkgOiB7IGRhdGE6IE9iamVjdC5hc3NpZ24oe30sIGRhdGEpLCBlcnJvcjogbnVsbCB9O1xufVxuYXN5bmMgZnVuY3Rpb24gX2hhbmRsZVJlcXVlc3QoZmV0Y2hlciwgbWV0aG9kLCB1cmwsIG9wdGlvbnMsIHBhcmFtZXRlcnMsIGJvZHkpIHtcbiAgICBjb25zdCByZXF1ZXN0UGFyYW1zID0gX2dldFJlcXVlc3RQYXJhbXMobWV0aG9kLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCBib2R5KTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIHRyeSB7XG4gICAgICAgIHJlc3VsdCA9IGF3YWl0IGZldGNoZXIodXJsLCBPYmplY3QuYXNzaWduKHt9LCByZXF1ZXN0UGFyYW1zKSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgIC8vIGZldGNoIGZhaWxlZCwgbGlrZWx5IGR1ZSB0byBhIG5ldHdvcmsgb3IgQ09SUyBlcnJvclxuICAgICAgICB0aHJvdyBuZXcgQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IoX2dldEVycm9yTWVzc2FnZShlKSwgMCk7XG4gICAgfVxuICAgIGlmICghcmVzdWx0Lm9rKSB7XG4gICAgICAgIGF3YWl0IGhhbmRsZUVycm9yKHJlc3VsdCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubm9SZXNvbHZlSnNvbikge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgcmVzdWx0Lmpzb24oKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgYXdhaXQgaGFuZGxlRXJyb3IoZSk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIF9zZXNzaW9uUmVzcG9uc2UoZGF0YSkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgc2Vzc2lvbiA9IG51bGw7XG4gICAgaWYgKGhhc1Nlc3Npb24oZGF0YSkpIHtcbiAgICAgICAgc2Vzc2lvbiA9IE9iamVjdC5hc3NpZ24oe30sIGRhdGEpO1xuICAgICAgICBpZiAoIWRhdGEuZXhwaXJlc19hdCkge1xuICAgICAgICAgICAgc2Vzc2lvbi5leHBpcmVzX2F0ID0gZXhwaXJlc0F0KGRhdGEuZXhwaXJlc19pbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdXNlciA9IChfYSA9IGRhdGEudXNlcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZGF0YTtcbiAgICByZXR1cm4geyBkYXRhOiB7IHNlc3Npb24sIHVzZXIgfSwgZXJyb3I6IG51bGwgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBfc2Vzc2lvblJlc3BvbnNlUGFzc3dvcmQoZGF0YSkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gX3Nlc3Npb25SZXNwb25zZShkYXRhKTtcbiAgICBpZiAoIXJlc3BvbnNlLmVycm9yICYmXG4gICAgICAgIGRhdGEud2Vha19wYXNzd29yZCAmJlxuICAgICAgICB0eXBlb2YgZGF0YS53ZWFrX3Bhc3N3b3JkID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBBcnJheS5pc0FycmF5KGRhdGEud2Vha19wYXNzd29yZC5yZWFzb25zKSAmJlxuICAgICAgICBkYXRhLndlYWtfcGFzc3dvcmQucmVhc29ucy5sZW5ndGggJiZcbiAgICAgICAgZGF0YS53ZWFrX3Bhc3N3b3JkLm1lc3NhZ2UgJiZcbiAgICAgICAgdHlwZW9mIGRhdGEud2Vha19wYXNzd29yZC5tZXNzYWdlID09PSAnc3RyaW5nJyAmJlxuICAgICAgICBkYXRhLndlYWtfcGFzc3dvcmQucmVhc29ucy5yZWR1Y2UoKGEsIGkpID0+IGEgJiYgdHlwZW9mIGkgPT09ICdzdHJpbmcnLCB0cnVlKSkge1xuICAgICAgICByZXNwb25zZS5kYXRhLndlYWtfcGFzc3dvcmQgPSBkYXRhLndlYWtfcGFzc3dvcmQ7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBfdXNlclJlc3BvbnNlKGRhdGEpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgdXNlciA9IChfYSA9IGRhdGEudXNlcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZGF0YTtcbiAgICByZXR1cm4geyBkYXRhOiB7IHVzZXIgfSwgZXJyb3I6IG51bGwgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBfc3NvUmVzcG9uc2UoZGF0YSkge1xuICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH07XG59XG5leHBvcnQgZnVuY3Rpb24gX2dlbmVyYXRlTGlua1Jlc3BvbnNlKGRhdGEpIHtcbiAgICBjb25zdCB7IGFjdGlvbl9saW5rLCBlbWFpbF9vdHAsIGhhc2hlZF90b2tlbiwgcmVkaXJlY3RfdG8sIHZlcmlmaWNhdGlvbl90eXBlIH0gPSBkYXRhLCByZXN0ID0gX19yZXN0KGRhdGEsIFtcImFjdGlvbl9saW5rXCIsIFwiZW1haWxfb3RwXCIsIFwiaGFzaGVkX3Rva2VuXCIsIFwicmVkaXJlY3RfdG9cIiwgXCJ2ZXJpZmljYXRpb25fdHlwZVwiXSk7XG4gICAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICAgICAgYWN0aW9uX2xpbmssXG4gICAgICAgIGVtYWlsX290cCxcbiAgICAgICAgaGFzaGVkX3Rva2VuLFxuICAgICAgICByZWRpcmVjdF90byxcbiAgICAgICAgdmVyaWZpY2F0aW9uX3R5cGUsXG4gICAgfTtcbiAgICBjb25zdCB1c2VyID0gT2JqZWN0LmFzc2lnbih7fSwgcmVzdCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgcHJvcGVydGllcyxcbiAgICAgICAgICAgIHVzZXIsXG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gX25vUmVzb2x2ZUpzb25SZXNwb25zZShkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGE7XG59XG4vKipcbiAqIGhhc1Nlc3Npb24gY2hlY2tzIGlmIHRoZSByZXNwb25zZSBvYmplY3QgY29udGFpbnMgYSB2YWxpZCBzZXNzaW9uXG4gKiBAcGFyYW0gZGF0YSBBIHJlc3BvbnNlIG9iamVjdFxuICogQHJldHVybnMgdHJ1ZSBpZiBhIHNlc3Npb24gaXMgaW4gdGhlIHJlc3BvbnNlXG4gKi9cbmZ1bmN0aW9uIGhhc1Nlc3Npb24oZGF0YSkge1xuICAgIHJldHVybiBkYXRhLmFjY2Vzc190b2tlbiAmJiBkYXRhLnJlZnJlc2hfdG9rZW4gJiYgZGF0YS5leHBpcmVzX2luO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmV0Y2guanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/fetch.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/helpers.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/helpers.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Deferred: () => (/* binding */ Deferred),\n/* harmony export */   decodeBase64URL: () => (/* binding */ decodeBase64URL),\n/* harmony export */   decodeJWTPayload: () => (/* binding */ decodeJWTPayload),\n/* harmony export */   expiresAt: () => (/* binding */ expiresAt),\n/* harmony export */   generatePKCEChallenge: () => (/* binding */ generatePKCEChallenge),\n/* harmony export */   generatePKCEVerifier: () => (/* binding */ generatePKCEVerifier),\n/* harmony export */   getCodeChallengeAndMethod: () => (/* binding */ getCodeChallengeAndMethod),\n/* harmony export */   getItemAsync: () => (/* binding */ getItemAsync),\n/* harmony export */   isBrowser: () => (/* binding */ isBrowser),\n/* harmony export */   looksLikeFetchResponse: () => (/* binding */ looksLikeFetchResponse),\n/* harmony export */   parseParametersFromURL: () => (/* binding */ parseParametersFromURL),\n/* harmony export */   parseResponseAPIVersion: () => (/* binding */ parseResponseAPIVersion),\n/* harmony export */   removeItemAsync: () => (/* binding */ removeItemAsync),\n/* harmony export */   resolveFetch: () => (/* binding */ resolveFetch),\n/* harmony export */   retryable: () => (/* binding */ retryable),\n/* harmony export */   setItemAsync: () => (/* binding */ setItemAsync),\n/* harmony export */   sleep: () => (/* binding */ sleep),\n/* harmony export */   supportsLocalStorage: () => (/* binding */ supportsLocalStorage),\n/* harmony export */   uuid: () => (/* binding */ uuid)\n/* harmony export */ });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/constants.js\");\n\nfunction expiresAt(expiresIn) {\n    const timeNow = Math.round(Date.now() / 1000);\n    return timeNow + expiresIn;\n}\nfunction uuid() {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n        const r = (Math.random() * 16) | 0, v = c == 'x' ? r : (r & 0x3) | 0x8;\n        return v.toString(16);\n    });\n}\nconst isBrowser = () => typeof window !== 'undefined' && typeof document !== 'undefined';\nconst localStorageWriteTests = {\n    tested: false,\n    writable: false,\n};\n/**\n * Checks whether localStorage is supported on this browser.\n */\nconst supportsLocalStorage = () => {\n    if (!isBrowser()) {\n        return false;\n    }\n    try {\n        if (typeof globalThis.localStorage !== 'object') {\n            return false;\n        }\n    }\n    catch (e) {\n        // DOM exception when accessing `localStorage`\n        return false;\n    }\n    if (localStorageWriteTests.tested) {\n        return localStorageWriteTests.writable;\n    }\n    const randomKey = `lswt-${Math.random()}${Math.random()}`;\n    try {\n        globalThis.localStorage.setItem(randomKey, randomKey);\n        globalThis.localStorage.removeItem(randomKey);\n        localStorageWriteTests.tested = true;\n        localStorageWriteTests.writable = true;\n    }\n    catch (e) {\n        // localStorage can't be written to\n        // https://www.chromium.org/for-testers/bug-reporting-guidelines/uncaught-securityerror-failed-to-read-the-localstorage-property-from-window-access-is-denied-for-this-document\n        localStorageWriteTests.tested = true;\n        localStorageWriteTests.writable = false;\n    }\n    return localStorageWriteTests.writable;\n};\n/**\n * Extracts parameters encoded in the URL both in the query and fragment.\n */\nfunction parseParametersFromURL(href) {\n    const result = {};\n    const url = new URL(href);\n    if (url.hash && url.hash[0] === '#') {\n        try {\n            const hashSearchParams = new URLSearchParams(url.hash.substring(1));\n            hashSearchParams.forEach((value, key) => {\n                result[key] = value;\n            });\n        }\n        catch (e) {\n            // hash is not a query string\n        }\n    }\n    // search parameters take precedence over hash parameters\n    url.searchParams.forEach((value, key) => {\n        result[key] = value;\n    });\n    return result;\n}\nconst resolveFetch = (customFetch) => {\n    let _fetch;\n    if (customFetch) {\n        _fetch = customFetch;\n    }\n    else if (typeof fetch === 'undefined') {\n        _fetch = (...args) => Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @supabase/node-fetch */ \"(app-pages-browser)/./node_modules/@supabase/node-fetch/browser.js\")).then(({ default: fetch }) => fetch(...args));\n    }\n    else {\n        _fetch = fetch;\n    }\n    return (...args) => _fetch(...args);\n};\nconst looksLikeFetchResponse = (maybeResponse) => {\n    return (typeof maybeResponse === 'object' &&\n        maybeResponse !== null &&\n        'status' in maybeResponse &&\n        'ok' in maybeResponse &&\n        'json' in maybeResponse &&\n        typeof maybeResponse.json === 'function');\n};\n// Storage helpers\nconst setItemAsync = async (storage, key, data) => {\n    await storage.setItem(key, JSON.stringify(data));\n};\nconst getItemAsync = async (storage, key) => {\n    const value = await storage.getItem(key);\n    if (!value) {\n        return null;\n    }\n    try {\n        return JSON.parse(value);\n    }\n    catch (_a) {\n        return value;\n    }\n};\nconst removeItemAsync = async (storage, key) => {\n    await storage.removeItem(key);\n};\nfunction decodeBase64URL(value) {\n    const key = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n    let base64 = '';\n    let chr1, chr2, chr3;\n    let enc1, enc2, enc3, enc4;\n    let i = 0;\n    value = value.replace('-', '+').replace('_', '/');\n    while (i < value.length) {\n        enc1 = key.indexOf(value.charAt(i++));\n        enc2 = key.indexOf(value.charAt(i++));\n        enc3 = key.indexOf(value.charAt(i++));\n        enc4 = key.indexOf(value.charAt(i++));\n        chr1 = (enc1 << 2) | (enc2 >> 4);\n        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\n        chr3 = ((enc3 & 3) << 6) | enc4;\n        base64 = base64 + String.fromCharCode(chr1);\n        if (enc3 != 64 && chr2 != 0) {\n            base64 = base64 + String.fromCharCode(chr2);\n        }\n        if (enc4 != 64 && chr3 != 0) {\n            base64 = base64 + String.fromCharCode(chr3);\n        }\n    }\n    return base64;\n}\n/**\n * A deferred represents some asynchronous work that is not yet finished, which\n * may or may not culminate in a value.\n * Taken from: https://github.com/mike-north/types/blob/master/src/async.ts\n */\nclass Deferred {\n    constructor() {\n        // eslint-disable-next-line @typescript-eslint/no-extra-semi\n        ;\n        this.promise = new Deferred.promiseConstructor((res, rej) => {\n            // eslint-disable-next-line @typescript-eslint/no-extra-semi\n            ;\n            this.resolve = res;\n            this.reject = rej;\n        });\n    }\n}\nDeferred.promiseConstructor = Promise;\n// Taken from: https://stackoverflow.com/questions/38552003/how-to-decode-jwt-token-in-javascript-without-using-a-library\nfunction decodeJWTPayload(token) {\n    // Regex checks for base64url format\n    const base64UrlRegex = /^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}=?$|[a-z0-9_-]{2}(==)?$)$/i;\n    const parts = token.split('.');\n    if (parts.length !== 3) {\n        throw new Error('JWT is not valid: not a JWT structure');\n    }\n    if (!base64UrlRegex.test(parts[1])) {\n        throw new Error('JWT is not valid: payload is not in base64url format');\n    }\n    const base64Url = parts[1];\n    return JSON.parse(decodeBase64URL(base64Url));\n}\n/**\n * Creates a promise that resolves to null after some time.\n */\nasync function sleep(time) {\n    return await new Promise((accept) => {\n        setTimeout(() => accept(null), time);\n    });\n}\n/**\n * Converts the provided async function into a retryable function. Each result\n * or thrown error is sent to the isRetryable function which should return true\n * if the function should run again.\n */\nfunction retryable(fn, isRetryable) {\n    const promise = new Promise((accept, reject) => {\n        // eslint-disable-next-line @typescript-eslint/no-extra-semi\n        ;\n        (async () => {\n            for (let attempt = 0; attempt < Infinity; attempt++) {\n                try {\n                    const result = await fn(attempt);\n                    if (!isRetryable(attempt, null, result)) {\n                        accept(result);\n                        return;\n                    }\n                }\n                catch (e) {\n                    if (!isRetryable(attempt, e)) {\n                        reject(e);\n                        return;\n                    }\n                }\n            }\n        })();\n    });\n    return promise;\n}\nfunction dec2hex(dec) {\n    return ('0' + dec.toString(16)).substr(-2);\n}\n// Functions below taken from: https://stackoverflow.com/questions/63309409/creating-a-code-verifier-and-challenge-for-pkce-auth-on-spotify-api-in-reactjs\nfunction generatePKCEVerifier() {\n    const verifierLength = 56;\n    const array = new Uint32Array(verifierLength);\n    if (typeof crypto === 'undefined') {\n        const charSet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';\n        const charSetLen = charSet.length;\n        let verifier = '';\n        for (let i = 0; i < verifierLength; i++) {\n            verifier += charSet.charAt(Math.floor(Math.random() * charSetLen));\n        }\n        return verifier;\n    }\n    crypto.getRandomValues(array);\n    return Array.from(array, dec2hex).join('');\n}\nasync function sha256(randomString) {\n    const encoder = new TextEncoder();\n    const encodedData = encoder.encode(randomString);\n    const hash = await crypto.subtle.digest('SHA-256', encodedData);\n    const bytes = new Uint8Array(hash);\n    return Array.from(bytes)\n        .map((c) => String.fromCharCode(c))\n        .join('');\n}\nfunction base64urlencode(str) {\n    return btoa(str).replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=+$/, '');\n}\nasync function generatePKCEChallenge(verifier) {\n    const hasCryptoSupport = typeof crypto !== 'undefined' &&\n        typeof crypto.subtle !== 'undefined' &&\n        typeof TextEncoder !== 'undefined';\n    if (!hasCryptoSupport) {\n        console.warn('WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256.');\n        return verifier;\n    }\n    const hashed = await sha256(verifier);\n    return base64urlencode(hashed);\n}\nasync function getCodeChallengeAndMethod(storage, storageKey, isPasswordRecovery = false) {\n    const codeVerifier = generatePKCEVerifier();\n    let storedCodeVerifier = codeVerifier;\n    if (isPasswordRecovery) {\n        storedCodeVerifier += '/PASSWORD_RECOVERY';\n    }\n    await setItemAsync(storage, `${storageKey}-code-verifier`, storedCodeVerifier);\n    const codeChallenge = await generatePKCEChallenge(codeVerifier);\n    const codeChallengeMethod = codeVerifier === codeChallenge ? 'plain' : 's256';\n    return [codeChallenge, codeChallengeMethod];\n}\n/** Parses the API version which is 2YYY-MM-DD. */\nconst API_VERSION_REGEX = /^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i;\nfunction parseResponseAPIVersion(response) {\n    const apiVersion = response.headers.get(_constants__WEBPACK_IMPORTED_MODULE_0__.API_VERSION_HEADER_NAME);\n    if (!apiVersion) {\n        return null;\n    }\n    if (!apiVersion.match(API_VERSION_REGEX)) {\n        return null;\n    }\n    try {\n        const date = new Date(`${apiVersion}T00:00:00.0Z`);\n        return date;\n    }\n    catch (e) {\n        return null;\n    }\n}\n//# sourceMappingURL=helpers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvaGVscGVycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFzRDtBQUMvQztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGNBQWMsRUFBRSxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixzTEFBOEIsU0FBUyxnQkFBZ0I7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLHlDQUF5QyxFQUFFLGdCQUFnQixFQUFFLGVBQWUsRUFBRTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG9CQUFvQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFdBQVc7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxFQUFFO0FBQzlCO0FBQ1AsNENBQTRDLCtEQUF1QjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxXQUFXO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvd29uZGVybGFuZG1pdGNoL0Nhc2NhZGVQcm9qZWN0cy9Xb25kZXJWaXRlLWZyb250ZW5kL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvaGVscGVycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBUElfVkVSU0lPTl9IRUFERVJfTkFNRSB9IGZyb20gJy4vY29uc3RhbnRzJztcbmV4cG9ydCBmdW5jdGlvbiBleHBpcmVzQXQoZXhwaXJlc0luKSB7XG4gICAgY29uc3QgdGltZU5vdyA9IE1hdGgucm91bmQoRGF0ZS5ub3coKSAvIDEwMDApO1xuICAgIHJldHVybiB0aW1lTm93ICsgZXhwaXJlc0luO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHV1aWQoKSB7XG4gICAgcmV0dXJuICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgY29uc3QgciA9IChNYXRoLnJhbmRvbSgpICogMTYpIHwgMCwgdiA9IGMgPT0gJ3gnID8gciA6IChyICYgMHgzKSB8IDB4ODtcbiAgICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICAgIH0pO1xufVxuZXhwb3J0IGNvbnN0IGlzQnJvd3NlciA9ICgpID0+IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5jb25zdCBsb2NhbFN0b3JhZ2VXcml0ZVRlc3RzID0ge1xuICAgIHRlc3RlZDogZmFsc2UsXG4gICAgd3JpdGFibGU6IGZhbHNlLFxufTtcbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgbG9jYWxTdG9yYWdlIGlzIHN1cHBvcnRlZCBvbiB0aGlzIGJyb3dzZXIuXG4gKi9cbmV4cG9ydCBjb25zdCBzdXBwb3J0c0xvY2FsU3RvcmFnZSA9ICgpID0+IHtcbiAgICBpZiAoIWlzQnJvd3NlcigpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzLmxvY2FsU3RvcmFnZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvLyBET00gZXhjZXB0aW9uIHdoZW4gYWNjZXNzaW5nIGBsb2NhbFN0b3JhZ2VgXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGxvY2FsU3RvcmFnZVdyaXRlVGVzdHMudGVzdGVkKSB7XG4gICAgICAgIHJldHVybiBsb2NhbFN0b3JhZ2VXcml0ZVRlc3RzLndyaXRhYmxlO1xuICAgIH1cbiAgICBjb25zdCByYW5kb21LZXkgPSBgbHN3dC0ke01hdGgucmFuZG9tKCl9JHtNYXRoLnJhbmRvbSgpfWA7XG4gICAgdHJ5IHtcbiAgICAgICAgZ2xvYmFsVGhpcy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShyYW5kb21LZXksIHJhbmRvbUtleSk7XG4gICAgICAgIGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0ocmFuZG9tS2V5KTtcbiAgICAgICAgbG9jYWxTdG9yYWdlV3JpdGVUZXN0cy50ZXN0ZWQgPSB0cnVlO1xuICAgICAgICBsb2NhbFN0b3JhZ2VXcml0ZVRlc3RzLndyaXRhYmxlID0gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gbG9jYWxTdG9yYWdlIGNhbid0IGJlIHdyaXR0ZW4gdG9cbiAgICAgICAgLy8gaHR0cHM6Ly93d3cuY2hyb21pdW0ub3JnL2Zvci10ZXN0ZXJzL2J1Zy1yZXBvcnRpbmctZ3VpZGVsaW5lcy91bmNhdWdodC1zZWN1cml0eWVycm9yLWZhaWxlZC10by1yZWFkLXRoZS1sb2NhbHN0b3JhZ2UtcHJvcGVydHktZnJvbS13aW5kb3ctYWNjZXNzLWlzLWRlbmllZC1mb3ItdGhpcy1kb2N1bWVudFxuICAgICAgICBsb2NhbFN0b3JhZ2VXcml0ZVRlc3RzLnRlc3RlZCA9IHRydWU7XG4gICAgICAgIGxvY2FsU3RvcmFnZVdyaXRlVGVzdHMud3JpdGFibGUgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGxvY2FsU3RvcmFnZVdyaXRlVGVzdHMud3JpdGFibGU7XG59O1xuLyoqXG4gKiBFeHRyYWN0cyBwYXJhbWV0ZXJzIGVuY29kZWQgaW4gdGhlIFVSTCBib3RoIGluIHRoZSBxdWVyeSBhbmQgZnJhZ21lbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVBhcmFtZXRlcnNGcm9tVVJMKGhyZWYpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGhyZWYpO1xuICAgIGlmICh1cmwuaGFzaCAmJiB1cmwuaGFzaFswXSA9PT0gJyMnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBoYXNoU2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh1cmwuaGFzaC5zdWJzdHJpbmcoMSkpO1xuICAgICAgICAgICAgaGFzaFNlYXJjaFBhcmFtcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBoYXNoIGlzIG5vdCBhIHF1ZXJ5IHN0cmluZ1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHNlYXJjaCBwYXJhbWV0ZXJzIHRha2UgcHJlY2VkZW5jZSBvdmVyIGhhc2ggcGFyYW1ldGVyc1xuICAgIHVybC5zZWFyY2hQYXJhbXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgY29uc3QgcmVzb2x2ZUZldGNoID0gKGN1c3RvbUZldGNoKSA9PiB7XG4gICAgbGV0IF9mZXRjaDtcbiAgICBpZiAoY3VzdG9tRmV0Y2gpIHtcbiAgICAgICAgX2ZldGNoID0gY3VzdG9tRmV0Y2g7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBmZXRjaCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgX2ZldGNoID0gKC4uLmFyZ3MpID0+IGltcG9ydCgnQHN1cGFiYXNlL25vZGUtZmV0Y2gnKS50aGVuKCh7IGRlZmF1bHQ6IGZldGNoIH0pID0+IGZldGNoKC4uLmFyZ3MpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIF9mZXRjaCA9IGZldGNoO1xuICAgIH1cbiAgICByZXR1cm4gKC4uLmFyZ3MpID0+IF9mZXRjaCguLi5hcmdzKTtcbn07XG5leHBvcnQgY29uc3QgbG9va3NMaWtlRmV0Y2hSZXNwb25zZSA9IChtYXliZVJlc3BvbnNlKSA9PiB7XG4gICAgcmV0dXJuICh0eXBlb2YgbWF5YmVSZXNwb25zZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgbWF5YmVSZXNwb25zZSAhPT0gbnVsbCAmJlxuICAgICAgICAnc3RhdHVzJyBpbiBtYXliZVJlc3BvbnNlICYmXG4gICAgICAgICdvaycgaW4gbWF5YmVSZXNwb25zZSAmJlxuICAgICAgICAnanNvbicgaW4gbWF5YmVSZXNwb25zZSAmJlxuICAgICAgICB0eXBlb2YgbWF5YmVSZXNwb25zZS5qc29uID09PSAnZnVuY3Rpb24nKTtcbn07XG4vLyBTdG9yYWdlIGhlbHBlcnNcbmV4cG9ydCBjb25zdCBzZXRJdGVtQXN5bmMgPSBhc3luYyAoc3RvcmFnZSwga2V5LCBkYXRhKSA9PiB7XG4gICAgYXdhaXQgc3RvcmFnZS5zZXRJdGVtKGtleSwgSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xufTtcbmV4cG9ydCBjb25zdCBnZXRJdGVtQXN5bmMgPSBhc3luYyAoc3RvcmFnZSwga2V5KSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSBhd2FpdCBzdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChfYSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCByZW1vdmVJdGVtQXN5bmMgPSBhc3luYyAoc3RvcmFnZSwga2V5KSA9PiB7XG4gICAgYXdhaXQgc3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG59O1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUJhc2U2NFVSTCh2YWx1ZSkge1xuICAgIGNvbnN0IGtleSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSc7XG4gICAgbGV0IGJhc2U2NCA9ICcnO1xuICAgIGxldCBjaHIxLCBjaHIyLCBjaHIzO1xuICAgIGxldCBlbmMxLCBlbmMyLCBlbmMzLCBlbmM0O1xuICAgIGxldCBpID0gMDtcbiAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoJy0nLCAnKycpLnJlcGxhY2UoJ18nLCAnLycpO1xuICAgIHdoaWxlIChpIDwgdmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIGVuYzEgPSBrZXkuaW5kZXhPZih2YWx1ZS5jaGFyQXQoaSsrKSk7XG4gICAgICAgIGVuYzIgPSBrZXkuaW5kZXhPZih2YWx1ZS5jaGFyQXQoaSsrKSk7XG4gICAgICAgIGVuYzMgPSBrZXkuaW5kZXhPZih2YWx1ZS5jaGFyQXQoaSsrKSk7XG4gICAgICAgIGVuYzQgPSBrZXkuaW5kZXhPZih2YWx1ZS5jaGFyQXQoaSsrKSk7XG4gICAgICAgIGNocjEgPSAoZW5jMSA8PCAyKSB8IChlbmMyID4+IDQpO1xuICAgICAgICBjaHIyID0gKChlbmMyICYgMTUpIDw8IDQpIHwgKGVuYzMgPj4gMik7XG4gICAgICAgIGNocjMgPSAoKGVuYzMgJiAzKSA8PCA2KSB8IGVuYzQ7XG4gICAgICAgIGJhc2U2NCA9IGJhc2U2NCArIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyMSk7XG4gICAgICAgIGlmIChlbmMzICE9IDY0ICYmIGNocjIgIT0gMCkge1xuICAgICAgICAgICAgYmFzZTY0ID0gYmFzZTY0ICsgU3RyaW5nLmZyb21DaGFyQ29kZShjaHIyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5jNCAhPSA2NCAmJiBjaHIzICE9IDApIHtcbiAgICAgICAgICAgIGJhc2U2NCA9IGJhc2U2NCArIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyMyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJhc2U2NDtcbn1cbi8qKlxuICogQSBkZWZlcnJlZCByZXByZXNlbnRzIHNvbWUgYXN5bmNocm9ub3VzIHdvcmsgdGhhdCBpcyBub3QgeWV0IGZpbmlzaGVkLCB3aGljaFxuICogbWF5IG9yIG1heSBub3QgY3VsbWluYXRlIGluIGEgdmFsdWUuXG4gKiBUYWtlbiBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vbWlrZS1ub3J0aC90eXBlcy9ibG9iL21hc3Rlci9zcmMvYXN5bmMudHNcbiAqL1xuZXhwb3J0IGNsYXNzIERlZmVycmVkIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHRyYS1zZW1pXG4gICAgICAgIDtcbiAgICAgICAgdGhpcy5wcm9taXNlID0gbmV3IERlZmVycmVkLnByb21pc2VDb25zdHJ1Y3RvcigocmVzLCByZWopID0+IHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXh0cmEtc2VtaVxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlID0gcmVzO1xuICAgICAgICAgICAgdGhpcy5yZWplY3QgPSByZWo7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbkRlZmVycmVkLnByb21pc2VDb25zdHJ1Y3RvciA9IFByb21pc2U7XG4vLyBUYWtlbiBmcm9tOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zODU1MjAwMy9ob3ctdG8tZGVjb2RlLWp3dC10b2tlbi1pbi1qYXZhc2NyaXB0LXdpdGhvdXQtdXNpbmctYS1saWJyYXJ5XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlSldUUGF5bG9hZCh0b2tlbikge1xuICAgIC8vIFJlZ2V4IGNoZWNrcyBmb3IgYmFzZTY0dXJsIGZvcm1hdFxuICAgIGNvbnN0IGJhc2U2NFVybFJlZ2V4ID0gL14oW2EtejAtOV8tXXs0fSkqKCR8W2EtejAtOV8tXXszfT0/JHxbYS16MC05Xy1dezJ9KD09KT8kKSQvaTtcbiAgICBjb25zdCBwYXJ0cyA9IHRva2VuLnNwbGl0KCcuJyk7XG4gICAgaWYgKHBhcnRzLmxlbmd0aCAhPT0gMykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0pXVCBpcyBub3QgdmFsaWQ6IG5vdCBhIEpXVCBzdHJ1Y3R1cmUnKTtcbiAgICB9XG4gICAgaWYgKCFiYXNlNjRVcmxSZWdleC50ZXN0KHBhcnRzWzFdKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0pXVCBpcyBub3QgdmFsaWQ6IHBheWxvYWQgaXMgbm90IGluIGJhc2U2NHVybCBmb3JtYXQnKTtcbiAgICB9XG4gICAgY29uc3QgYmFzZTY0VXJsID0gcGFydHNbMV07XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoZGVjb2RlQmFzZTY0VVJMKGJhc2U2NFVybCkpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIG51bGwgYWZ0ZXIgc29tZSB0aW1lLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2xlZXAodGltZSkge1xuICAgIHJldHVybiBhd2FpdCBuZXcgUHJvbWlzZSgoYWNjZXB0KSA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gYWNjZXB0KG51bGwpLCB0aW1lKTtcbiAgICB9KTtcbn1cbi8qKlxuICogQ29udmVydHMgdGhlIHByb3ZpZGVkIGFzeW5jIGZ1bmN0aW9uIGludG8gYSByZXRyeWFibGUgZnVuY3Rpb24uIEVhY2ggcmVzdWx0XG4gKiBvciB0aHJvd24gZXJyb3IgaXMgc2VudCB0byB0aGUgaXNSZXRyeWFibGUgZnVuY3Rpb24gd2hpY2ggc2hvdWxkIHJldHVybiB0cnVlXG4gKiBpZiB0aGUgZnVuY3Rpb24gc2hvdWxkIHJ1biBhZ2Fpbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJldHJ5YWJsZShmbiwgaXNSZXRyeWFibGUpIHtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKGFjY2VwdCwgcmVqZWN0KSA9PiB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXh0cmEtc2VtaVxuICAgICAgICA7XG4gICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBhdHRlbXB0ID0gMDsgYXR0ZW1wdCA8IEluZmluaXR5OyBhdHRlbXB0KyspIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBmbihhdHRlbXB0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1JldHJ5YWJsZShhdHRlbXB0LCBudWxsLCByZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2NlcHQocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUmV0cnlhYmxlKGF0dGVtcHQsIGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5mdW5jdGlvbiBkZWMyaGV4KGRlYykge1xuICAgIHJldHVybiAoJzAnICsgZGVjLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC0yKTtcbn1cbi8vIEZ1bmN0aW9ucyBiZWxvdyB0YWtlbiBmcm9tOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82MzMwOTQwOS9jcmVhdGluZy1hLWNvZGUtdmVyaWZpZXItYW5kLWNoYWxsZW5nZS1mb3ItcGtjZS1hdXRoLW9uLXNwb3RpZnktYXBpLWluLXJlYWN0anNcbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVBLQ0VWZXJpZmllcigpIHtcbiAgICBjb25zdCB2ZXJpZmllckxlbmd0aCA9IDU2O1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQzMkFycmF5KHZlcmlmaWVyTGVuZ3RoKTtcbiAgICBpZiAodHlwZW9mIGNyeXB0byA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc3QgY2hhclNldCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS0uX34nO1xuICAgICAgICBjb25zdCBjaGFyU2V0TGVuID0gY2hhclNldC5sZW5ndGg7XG4gICAgICAgIGxldCB2ZXJpZmllciA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZlcmlmaWVyTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZlcmlmaWVyICs9IGNoYXJTZXQuY2hhckF0KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNoYXJTZXRMZW4pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmVyaWZpZXI7XG4gICAgfVxuICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYXJyYXkpO1xuICAgIHJldHVybiBBcnJheS5mcm9tKGFycmF5LCBkZWMyaGV4KS5qb2luKCcnKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNoYTI1NihyYW5kb21TdHJpbmcpIHtcbiAgICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgY29uc3QgZW5jb2RlZERhdGEgPSBlbmNvZGVyLmVuY29kZShyYW5kb21TdHJpbmcpO1xuICAgIGNvbnN0IGhhc2ggPSBhd2FpdCBjcnlwdG8uc3VidGxlLmRpZ2VzdCgnU0hBLTI1NicsIGVuY29kZWREYXRhKTtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGhhc2gpO1xuICAgIHJldHVybiBBcnJheS5mcm9tKGJ5dGVzKVxuICAgICAgICAubWFwKChjKSA9PiBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpKVxuICAgICAgICAuam9pbignJyk7XG59XG5mdW5jdGlvbiBiYXNlNjR1cmxlbmNvZGUoc3RyKSB7XG4gICAgcmV0dXJuIGJ0b2Eoc3RyKS5yZXBsYWNlKC9cXCsvZywgJy0nKS5yZXBsYWNlKC9cXC8vZywgJ18nKS5yZXBsYWNlKC89KyQvLCAnJyk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVQS0NFQ2hhbGxlbmdlKHZlcmlmaWVyKSB7XG4gICAgY29uc3QgaGFzQ3J5cHRvU3VwcG9ydCA9IHR5cGVvZiBjcnlwdG8gIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIHR5cGVvZiBjcnlwdG8uc3VidGxlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICB0eXBlb2YgVGV4dEVuY29kZXIgIT09ICd1bmRlZmluZWQnO1xuICAgIGlmICghaGFzQ3J5cHRvU3VwcG9ydCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1dlYkNyeXB0byBBUEkgaXMgbm90IHN1cHBvcnRlZC4gQ29kZSBjaGFsbGVuZ2UgbWV0aG9kIHdpbGwgZGVmYXVsdCB0byB1c2UgcGxhaW4gaW5zdGVhZCBvZiBzaGEyNTYuJyk7XG4gICAgICAgIHJldHVybiB2ZXJpZmllcjtcbiAgICB9XG4gICAgY29uc3QgaGFzaGVkID0gYXdhaXQgc2hhMjU2KHZlcmlmaWVyKTtcbiAgICByZXR1cm4gYmFzZTY0dXJsZW5jb2RlKGhhc2hlZCk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q29kZUNoYWxsZW5nZUFuZE1ldGhvZChzdG9yYWdlLCBzdG9yYWdlS2V5LCBpc1Bhc3N3b3JkUmVjb3ZlcnkgPSBmYWxzZSkge1xuICAgIGNvbnN0IGNvZGVWZXJpZmllciA9IGdlbmVyYXRlUEtDRVZlcmlmaWVyKCk7XG4gICAgbGV0IHN0b3JlZENvZGVWZXJpZmllciA9IGNvZGVWZXJpZmllcjtcbiAgICBpZiAoaXNQYXNzd29yZFJlY292ZXJ5KSB7XG4gICAgICAgIHN0b3JlZENvZGVWZXJpZmllciArPSAnL1BBU1NXT1JEX1JFQ09WRVJZJztcbiAgICB9XG4gICAgYXdhaXQgc2V0SXRlbUFzeW5jKHN0b3JhZ2UsIGAke3N0b3JhZ2VLZXl9LWNvZGUtdmVyaWZpZXJgLCBzdG9yZWRDb2RlVmVyaWZpZXIpO1xuICAgIGNvbnN0IGNvZGVDaGFsbGVuZ2UgPSBhd2FpdCBnZW5lcmF0ZVBLQ0VDaGFsbGVuZ2UoY29kZVZlcmlmaWVyKTtcbiAgICBjb25zdCBjb2RlQ2hhbGxlbmdlTWV0aG9kID0gY29kZVZlcmlmaWVyID09PSBjb2RlQ2hhbGxlbmdlID8gJ3BsYWluJyA6ICdzMjU2JztcbiAgICByZXR1cm4gW2NvZGVDaGFsbGVuZ2UsIGNvZGVDaGFsbGVuZ2VNZXRob2RdO1xufVxuLyoqIFBhcnNlcyB0aGUgQVBJIHZlcnNpb24gd2hpY2ggaXMgMllZWS1NTS1ERC4gKi9cbmNvbnN0IEFQSV9WRVJTSU9OX1JFR0VYID0gL14yWzAtOV17M30tKDBbMS05XXwxWzAtMl0pLSgwWzEtOV18MVswLTldfDJbMC05XXwzWzAtMV0pJC9pO1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUmVzcG9uc2VBUElWZXJzaW9uKHJlc3BvbnNlKSB7XG4gICAgY29uc3QgYXBpVmVyc2lvbiA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KEFQSV9WRVJTSU9OX0hFQURFUl9OQU1FKTtcbiAgICBpZiAoIWFwaVZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICghYXBpVmVyc2lvbi5tYXRjaChBUElfVkVSU0lPTl9SRUdFWCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShgJHthcGlWZXJzaW9ufVQwMDowMDowMC4wWmApO1xuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGVscGVycy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/helpers.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/local-storage.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/local-storage.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   localStorageAdapter: () => (/* binding */ localStorageAdapter),\n/* harmony export */   memoryLocalStorageAdapter: () => (/* binding */ memoryLocalStorageAdapter)\n/* harmony export */ });\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/helpers.js\");\n\n/**\n * Provides safe access to the globalThis.localStorage property.\n */\nconst localStorageAdapter = {\n    getItem: (key) => {\n        if (!(0,_helpers__WEBPACK_IMPORTED_MODULE_0__.supportsLocalStorage)()) {\n            return null;\n        }\n        return globalThis.localStorage.getItem(key);\n    },\n    setItem: (key, value) => {\n        if (!(0,_helpers__WEBPACK_IMPORTED_MODULE_0__.supportsLocalStorage)()) {\n            return;\n        }\n        globalThis.localStorage.setItem(key, value);\n    },\n    removeItem: (key) => {\n        if (!(0,_helpers__WEBPACK_IMPORTED_MODULE_0__.supportsLocalStorage)()) {\n            return;\n        }\n        globalThis.localStorage.removeItem(key);\n    },\n};\n/**\n * Returns a localStorage-like object that stores the key-value pairs in\n * memory.\n */\nfunction memoryLocalStorageAdapter(store = {}) {\n    return {\n        getItem: (key) => {\n            return store[key] || null;\n        },\n        setItem: (key, value) => {\n            store[key] = value;\n        },\n        removeItem: (key) => {\n            delete store[key];\n        },\n    };\n}\n//# sourceMappingURL=local-storage.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvbG9jYWwtc3RvcmFnZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGFBQWEsOERBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGFBQWEsOERBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGFBQWEsOERBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sNkNBQTZDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvd29uZGVybGFuZG1pdGNoL0Nhc2NhZGVQcm9qZWN0cy9Xb25kZXJWaXRlLWZyb250ZW5kL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvbG9jYWwtc3RvcmFnZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzdXBwb3J0c0xvY2FsU3RvcmFnZSB9IGZyb20gJy4vaGVscGVycyc7XG4vKipcbiAqIFByb3ZpZGVzIHNhZmUgYWNjZXNzIHRvIHRoZSBnbG9iYWxUaGlzLmxvY2FsU3RvcmFnZSBwcm9wZXJ0eS5cbiAqL1xuZXhwb3J0IGNvbnN0IGxvY2FsU3RvcmFnZUFkYXB0ZXIgPSB7XG4gICAgZ2V0SXRlbTogKGtleSkgPT4ge1xuICAgICAgICBpZiAoIXN1cHBvcnRzTG9jYWxTdG9yYWdlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzLmxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgfSxcbiAgICBzZXRJdGVtOiAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAoIXN1cHBvcnRzTG9jYWxTdG9yYWdlKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBnbG9iYWxUaGlzLmxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgdmFsdWUpO1xuICAgIH0sXG4gICAgcmVtb3ZlSXRlbTogKGtleSkgPT4ge1xuICAgICAgICBpZiAoIXN1cHBvcnRzTG9jYWxTdG9yYWdlKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBnbG9iYWxUaGlzLmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG4gICAgfSxcbn07XG4vKipcbiAqIFJldHVybnMgYSBsb2NhbFN0b3JhZ2UtbGlrZSBvYmplY3QgdGhhdCBzdG9yZXMgdGhlIGtleS12YWx1ZSBwYWlycyBpblxuICogbWVtb3J5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVtb3J5TG9jYWxTdG9yYWdlQWRhcHRlcihzdG9yZSA9IHt9KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0SXRlbTogKGtleSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHN0b3JlW2tleV0gfHwgbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0SXRlbTogKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIHN0b3JlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlSXRlbTogKGtleSkgPT4ge1xuICAgICAgICAgICAgZGVsZXRlIHN0b3JlW2tleV07XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvY2FsLXN0b3JhZ2UuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/local-storage.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/locks.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/locks.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LockAcquireTimeoutError: () => (/* binding */ LockAcquireTimeoutError),\n/* harmony export */   NavigatorLockAcquireTimeoutError: () => (/* binding */ NavigatorLockAcquireTimeoutError),\n/* harmony export */   ProcessLockAcquireTimeoutError: () => (/* binding */ ProcessLockAcquireTimeoutError),\n/* harmony export */   internals: () => (/* binding */ internals),\n/* harmony export */   navigatorLock: () => (/* binding */ navigatorLock),\n/* harmony export */   processLock: () => (/* binding */ processLock)\n/* harmony export */ });\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/helpers.js\");\n\n/**\n * @experimental\n */\nconst internals = {\n    /**\n     * @experimental\n     */\n    debug: !!(globalThis &&\n        (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.supportsLocalStorage)() &&\n        globalThis.localStorage &&\n        globalThis.localStorage.getItem('supabase.gotrue-js.locks.debug') === 'true'),\n};\n/**\n * An error thrown when a lock cannot be acquired after some amount of time.\n *\n * Use the {@link #isAcquireTimeout} property instead of checking with `instanceof`.\n */\nclass LockAcquireTimeoutError extends Error {\n    constructor(message) {\n        super(message);\n        this.isAcquireTimeout = true;\n    }\n}\nclass NavigatorLockAcquireTimeoutError extends LockAcquireTimeoutError {\n}\nclass ProcessLockAcquireTimeoutError extends LockAcquireTimeoutError {\n}\n/**\n * Implements a global exclusive lock using the Navigator LockManager API. It\n * is available on all browsers released after 2022-03-15 with Safari being the\n * last one to release support. If the API is not available, this function will\n * throw. Make sure you check availablility before configuring {@link\n * GoTrueClient}.\n *\n * You can turn on debugging by setting the `supabase.gotrue-js.locks.debug`\n * local storage item to `true`.\n *\n * Internals:\n *\n * Since the LockManager API does not preserve stack traces for the async\n * function passed in the `request` method, a trick is used where acquiring the\n * lock releases a previously started promise to run the operation in the `fn`\n * function. The lock waits for that promise to finish (with or without error),\n * while the function will finally wait for the result anyway.\n *\n * @param name Name of the lock to be acquired.\n * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if\n *                       the lock can't be acquired without waiting. If positive, the lock acquire\n *                       will time out after so many milliseconds. An error is\n *                       a timeout if it has `isAcquireTimeout` set to true.\n * @param fn The operation to run once the lock is acquired.\n */\nasync function navigatorLock(name, acquireTimeout, fn) {\n    if (internals.debug) {\n        console.log('@supabase/gotrue-js: navigatorLock: acquire lock', name, acquireTimeout);\n    }\n    const abortController = new globalThis.AbortController();\n    if (acquireTimeout > 0) {\n        setTimeout(() => {\n            abortController.abort();\n            if (internals.debug) {\n                console.log('@supabase/gotrue-js: navigatorLock acquire timed out', name);\n            }\n        }, acquireTimeout);\n    }\n    // MDN article: https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request\n    // Wrapping navigator.locks.request() with a plain Promise is done as some\n    // libraries like zone.js patch the Promise object to track the execution\n    // context. However, it appears that most browsers use an internal promise\n    // implementation when using the navigator.locks.request() API causing them\n    // to lose context and emit confusing log messages or break certain features.\n    // This wrapping is believed to help zone.js track the execution context\n    // better.\n    return await Promise.resolve().then(() => globalThis.navigator.locks.request(name, acquireTimeout === 0\n        ? {\n            mode: 'exclusive',\n            ifAvailable: true,\n        }\n        : {\n            mode: 'exclusive',\n            signal: abortController.signal,\n        }, async (lock) => {\n        if (lock) {\n            if (internals.debug) {\n                console.log('@supabase/gotrue-js: navigatorLock: acquired', name, lock.name);\n            }\n            try {\n                return await fn();\n            }\n            finally {\n                if (internals.debug) {\n                    console.log('@supabase/gotrue-js: navigatorLock: released', name, lock.name);\n                }\n            }\n        }\n        else {\n            if (acquireTimeout === 0) {\n                if (internals.debug) {\n                    console.log('@supabase/gotrue-js: navigatorLock: not immediately available', name);\n                }\n                throw new NavigatorLockAcquireTimeoutError(`Acquiring an exclusive Navigator LockManager lock \"${name}\" immediately failed`);\n            }\n            else {\n                if (internals.debug) {\n                    try {\n                        const result = await globalThis.navigator.locks.query();\n                        console.log('@supabase/gotrue-js: Navigator LockManager state', JSON.stringify(result, null, '  '));\n                    }\n                    catch (e) {\n                        console.warn('@supabase/gotrue-js: Error when querying Navigator LockManager state', e);\n                    }\n                }\n                // Browser is not following the Navigator LockManager spec, it\n                // returned a null lock when we didn't use ifAvailable. So we can\n                // pretend the lock is acquired in the name of backward compatibility\n                // and user experience and just run the function.\n                console.warn('@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request');\n                return await fn();\n            }\n        }\n    }));\n}\nconst PROCESS_LOCKS = {};\n/**\n * Implements a global exclusive lock that works only in the current process.\n * Useful for environments like React Native or other non-browser\n * single-process (i.e. no concept of \"tabs\") environments.\n *\n * Use {@link #navigatorLock} in browser environments.\n *\n * @param name Name of the lock to be acquired.\n * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if\n *                       the lock can't be acquired without waiting. If positive, the lock acquire\n *                       will time out after so many milliseconds. An error is\n *                       a timeout if it has `isAcquireTimeout` set to true.\n * @param fn The operation to run once the lock is acquired.\n */\nasync function processLock(name, acquireTimeout, fn) {\n    var _a;\n    const previousOperation = (_a = PROCESS_LOCKS[name]) !== null && _a !== void 0 ? _a : Promise.resolve();\n    const currentOperation = Promise.race([\n        previousOperation.catch(() => {\n            // ignore error of previous operation that we're waiting to finish\n            return null;\n        }),\n        acquireTimeout >= 0\n            ? new Promise((_, reject) => {\n                setTimeout(() => {\n                    reject(new ProcessLockAcquireTimeoutError(`Acquring process lock with name \"${name}\" timed out`));\n                }, acquireTimeout);\n            })\n            : null,\n    ].filter((x) => x))\n        .catch((e) => {\n        if (e && e.isAcquireTimeout) {\n            throw e;\n        }\n        return null;\n    })\n        .then(async () => {\n        // previous operations finished and we didn't get a race on the acquire\n        // timeout, so the current operation can finally start\n        return await fn();\n    });\n    PROCESS_LOCKS[name] = currentOperation.catch(async (e) => {\n        if (e && e.isAcquireTimeout) {\n            // if the current operation timed out, it doesn't mean that the previous\n            // operation finished, so we need contnue waiting for it to finish\n            await previousOperation;\n            return null;\n        }\n        throw e;\n    });\n    // finally wait for the current operation to finish successfully, with an\n    // error or with an acquire timeout error\n    return await currentOperation;\n}\n//# sourceMappingURL=locks.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvbG9ja3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw4REFBb0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5QkFBeUI7QUFDckM7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpSEFBaUgsS0FBSztBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0JBQXNCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxrR0FBa0csS0FBSztBQUN2RyxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvV29uZGVyVml0ZS1mcm9udGVuZC9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL2xvY2tzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHN1cHBvcnRzTG9jYWxTdG9yYWdlIH0gZnJvbSAnLi9oZWxwZXJzJztcbi8qKlxuICogQGV4cGVyaW1lbnRhbFxuICovXG5leHBvcnQgY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIC8qKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICBkZWJ1ZzogISEoZ2xvYmFsVGhpcyAmJlxuICAgICAgICBzdXBwb3J0c0xvY2FsU3RvcmFnZSgpICYmXG4gICAgICAgIGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlICYmXG4gICAgICAgIGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3N1cGFiYXNlLmdvdHJ1ZS1qcy5sb2Nrcy5kZWJ1ZycpID09PSAndHJ1ZScpLFxufTtcbi8qKlxuICogQW4gZXJyb3IgdGhyb3duIHdoZW4gYSBsb2NrIGNhbm5vdCBiZSBhY3F1aXJlZCBhZnRlciBzb21lIGFtb3VudCBvZiB0aW1lLlxuICpcbiAqIFVzZSB0aGUge0BsaW5rICNpc0FjcXVpcmVUaW1lb3V0fSBwcm9wZXJ0eSBpbnN0ZWFkIG9mIGNoZWNraW5nIHdpdGggYGluc3RhbmNlb2ZgLlxuICovXG5leHBvcnQgY2xhc3MgTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5pc0FjcXVpcmVUaW1lb3V0ID0gdHJ1ZTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgTmF2aWdhdG9yTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IgZXh0ZW5kcyBMb2NrQWNxdWlyZVRpbWVvdXRFcnJvciB7XG59XG5leHBvcnQgY2xhc3MgUHJvY2Vzc0xvY2tBY3F1aXJlVGltZW91dEVycm9yIGV4dGVuZHMgTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3Ige1xufVxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgZ2xvYmFsIGV4Y2x1c2l2ZSBsb2NrIHVzaW5nIHRoZSBOYXZpZ2F0b3IgTG9ja01hbmFnZXIgQVBJLiBJdFxuICogaXMgYXZhaWxhYmxlIG9uIGFsbCBicm93c2VycyByZWxlYXNlZCBhZnRlciAyMDIyLTAzLTE1IHdpdGggU2FmYXJpIGJlaW5nIHRoZVxuICogbGFzdCBvbmUgdG8gcmVsZWFzZSBzdXBwb3J0LiBJZiB0aGUgQVBJIGlzIG5vdCBhdmFpbGFibGUsIHRoaXMgZnVuY3Rpb24gd2lsbFxuICogdGhyb3cuIE1ha2Ugc3VyZSB5b3UgY2hlY2sgYXZhaWxhYmxpbGl0eSBiZWZvcmUgY29uZmlndXJpbmcge0BsaW5rXG4gKiBHb1RydWVDbGllbnR9LlxuICpcbiAqIFlvdSBjYW4gdHVybiBvbiBkZWJ1Z2dpbmcgYnkgc2V0dGluZyB0aGUgYHN1cGFiYXNlLmdvdHJ1ZS1qcy5sb2Nrcy5kZWJ1Z2BcbiAqIGxvY2FsIHN0b3JhZ2UgaXRlbSB0byBgdHJ1ZWAuXG4gKlxuICogSW50ZXJuYWxzOlxuICpcbiAqIFNpbmNlIHRoZSBMb2NrTWFuYWdlciBBUEkgZG9lcyBub3QgcHJlc2VydmUgc3RhY2sgdHJhY2VzIGZvciB0aGUgYXN5bmNcbiAqIGZ1bmN0aW9uIHBhc3NlZCBpbiB0aGUgYHJlcXVlc3RgIG1ldGhvZCwgYSB0cmljayBpcyB1c2VkIHdoZXJlIGFjcXVpcmluZyB0aGVcbiAqIGxvY2sgcmVsZWFzZXMgYSBwcmV2aW91c2x5IHN0YXJ0ZWQgcHJvbWlzZSB0byBydW4gdGhlIG9wZXJhdGlvbiBpbiB0aGUgYGZuYFxuICogZnVuY3Rpb24uIFRoZSBsb2NrIHdhaXRzIGZvciB0aGF0IHByb21pc2UgdG8gZmluaXNoICh3aXRoIG9yIHdpdGhvdXQgZXJyb3IpLFxuICogd2hpbGUgdGhlIGZ1bmN0aW9uIHdpbGwgZmluYWxseSB3YWl0IGZvciB0aGUgcmVzdWx0IGFueXdheS5cbiAqXG4gKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHRoZSBsb2NrIHRvIGJlIGFjcXVpcmVkLlxuICogQHBhcmFtIGFjcXVpcmVUaW1lb3V0IElmIG5lZ2F0aXZlLCBubyB0aW1lb3V0LiBJZiAwIGFuIGVycm9yIGlzIHRocm93biBpZlxuICogICAgICAgICAgICAgICAgICAgICAgIHRoZSBsb2NrIGNhbid0IGJlIGFjcXVpcmVkIHdpdGhvdXQgd2FpdGluZy4gSWYgcG9zaXRpdmUsIHRoZSBsb2NrIGFjcXVpcmVcbiAqICAgICAgICAgICAgICAgICAgICAgICB3aWxsIHRpbWUgb3V0IGFmdGVyIHNvIG1hbnkgbWlsbGlzZWNvbmRzLiBBbiBlcnJvciBpc1xuICogICAgICAgICAgICAgICAgICAgICAgIGEgdGltZW91dCBpZiBpdCBoYXMgYGlzQWNxdWlyZVRpbWVvdXRgIHNldCB0byB0cnVlLlxuICogQHBhcmFtIGZuIFRoZSBvcGVyYXRpb24gdG8gcnVuIG9uY2UgdGhlIGxvY2sgaXMgYWNxdWlyZWQuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBuYXZpZ2F0b3JMb2NrKG5hbWUsIGFjcXVpcmVUaW1lb3V0LCBmbikge1xuICAgIGlmIChpbnRlcm5hbHMuZGVidWcpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0BzdXBhYmFzZS9nb3RydWUtanM6IG5hdmlnYXRvckxvY2s6IGFjcXVpcmUgbG9jaycsIG5hbWUsIGFjcXVpcmVUaW1lb3V0KTtcbiAgICB9XG4gICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IGdsb2JhbFRoaXMuQWJvcnRDb250cm9sbGVyKCk7XG4gICAgaWYgKGFjcXVpcmVUaW1lb3V0ID4gMCkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICAgICAgaWYgKGludGVybmFscy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdAc3VwYWJhc2UvZ290cnVlLWpzOiBuYXZpZ2F0b3JMb2NrIGFjcXVpcmUgdGltZWQgb3V0JywgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGFjcXVpcmVUaW1lb3V0KTtcbiAgICB9XG4gICAgLy8gTUROIGFydGljbGU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Mb2NrTWFuYWdlci9yZXF1ZXN0XG4gICAgLy8gV3JhcHBpbmcgbmF2aWdhdG9yLmxvY2tzLnJlcXVlc3QoKSB3aXRoIGEgcGxhaW4gUHJvbWlzZSBpcyBkb25lIGFzIHNvbWVcbiAgICAvLyBsaWJyYXJpZXMgbGlrZSB6b25lLmpzIHBhdGNoIHRoZSBQcm9taXNlIG9iamVjdCB0byB0cmFjayB0aGUgZXhlY3V0aW9uXG4gICAgLy8gY29udGV4dC4gSG93ZXZlciwgaXQgYXBwZWFycyB0aGF0IG1vc3QgYnJvd3NlcnMgdXNlIGFuIGludGVybmFsIHByb21pc2VcbiAgICAvLyBpbXBsZW1lbnRhdGlvbiB3aGVuIHVzaW5nIHRoZSBuYXZpZ2F0b3IubG9ja3MucmVxdWVzdCgpIEFQSSBjYXVzaW5nIHRoZW1cbiAgICAvLyB0byBsb3NlIGNvbnRleHQgYW5kIGVtaXQgY29uZnVzaW5nIGxvZyBtZXNzYWdlcyBvciBicmVhayBjZXJ0YWluIGZlYXR1cmVzLlxuICAgIC8vIFRoaXMgd3JhcHBpbmcgaXMgYmVsaWV2ZWQgdG8gaGVscCB6b25lLmpzIHRyYWNrIHRoZSBleGVjdXRpb24gY29udGV4dFxuICAgIC8vIGJldHRlci5cbiAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiBnbG9iYWxUaGlzLm5hdmlnYXRvci5sb2Nrcy5yZXF1ZXN0KG5hbWUsIGFjcXVpcmVUaW1lb3V0ID09PSAwXG4gICAgICAgID8ge1xuICAgICAgICAgICAgbW9kZTogJ2V4Y2x1c2l2ZScsXG4gICAgICAgICAgICBpZkF2YWlsYWJsZTogdHJ1ZSxcbiAgICAgICAgfVxuICAgICAgICA6IHtcbiAgICAgICAgICAgIG1vZGU6ICdleGNsdXNpdmUnLFxuICAgICAgICAgICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICB9LCBhc3luYyAobG9jaykgPT4ge1xuICAgICAgICBpZiAobG9jaykge1xuICAgICAgICAgICAgaWYgKGludGVybmFscy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdAc3VwYWJhc2UvZ290cnVlLWpzOiBuYXZpZ2F0b3JMb2NrOiBhY3F1aXJlZCcsIG5hbWUsIGxvY2submFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBmbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgaWYgKGludGVybmFscy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQHN1cGFiYXNlL2dvdHJ1ZS1qczogbmF2aWdhdG9yTG9jazogcmVsZWFzZWQnLCBuYW1lLCBsb2NrLm5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChhY3F1aXJlVGltZW91dCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbHMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0BzdXBhYmFzZS9nb3RydWUtanM6IG5hdmlnYXRvckxvY2s6IG5vdCBpbW1lZGlhdGVseSBhdmFpbGFibGUnLCBuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5hdmlnYXRvckxvY2tBY3F1aXJlVGltZW91dEVycm9yKGBBY3F1aXJpbmcgYW4gZXhjbHVzaXZlIE5hdmlnYXRvciBMb2NrTWFuYWdlciBsb2NrIFwiJHtuYW1lfVwiIGltbWVkaWF0ZWx5IGZhaWxlZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGludGVybmFscy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2xvYmFsVGhpcy5uYXZpZ2F0b3IubG9ja3MucXVlcnkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdAc3VwYWJhc2UvZ290cnVlLWpzOiBOYXZpZ2F0b3IgTG9ja01hbmFnZXIgc3RhdGUnLCBKU09OLnN0cmluZ2lmeShyZXN1bHQsIG51bGwsICcgICcpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdAc3VwYWJhc2UvZ290cnVlLWpzOiBFcnJvciB3aGVuIHF1ZXJ5aW5nIE5hdmlnYXRvciBMb2NrTWFuYWdlciBzdGF0ZScsIGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEJyb3dzZXIgaXMgbm90IGZvbGxvd2luZyB0aGUgTmF2aWdhdG9yIExvY2tNYW5hZ2VyIHNwZWMsIGl0XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuZWQgYSBudWxsIGxvY2sgd2hlbiB3ZSBkaWRuJ3QgdXNlIGlmQXZhaWxhYmxlLiBTbyB3ZSBjYW5cbiAgICAgICAgICAgICAgICAvLyBwcmV0ZW5kIHRoZSBsb2NrIGlzIGFjcXVpcmVkIGluIHRoZSBuYW1lIG9mIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgICAgICAvLyBhbmQgdXNlciBleHBlcmllbmNlIGFuZCBqdXN0IHJ1biB0aGUgZnVuY3Rpb24uXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdAc3VwYWJhc2UvZ290cnVlLWpzOiBOYXZpZ2F0b3IgTG9ja01hbmFnZXIgcmV0dXJuZWQgYSBudWxsIGxvY2sgd2hlbiB1c2luZyAjcmVxdWVzdCB3aXRob3V0IGlmQXZhaWxhYmxlIHNldCB0byB0cnVlLCBpdCBhcHBlYXJzIHRoaXMgYnJvd3NlciBpcyBub3QgZm9sbG93aW5nIHRoZSBMb2NrTWFuYWdlciBzcGVjIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Mb2NrTWFuYWdlci9yZXF1ZXN0Jyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGZuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KSk7XG59XG5jb25zdCBQUk9DRVNTX0xPQ0tTID0ge307XG4vKipcbiAqIEltcGxlbWVudHMgYSBnbG9iYWwgZXhjbHVzaXZlIGxvY2sgdGhhdCB3b3JrcyBvbmx5IGluIHRoZSBjdXJyZW50IHByb2Nlc3MuXG4gKiBVc2VmdWwgZm9yIGVudmlyb25tZW50cyBsaWtlIFJlYWN0IE5hdGl2ZSBvciBvdGhlciBub24tYnJvd3NlclxuICogc2luZ2xlLXByb2Nlc3MgKGkuZS4gbm8gY29uY2VwdCBvZiBcInRhYnNcIikgZW52aXJvbm1lbnRzLlxuICpcbiAqIFVzZSB7QGxpbmsgI25hdmlnYXRvckxvY2t9IGluIGJyb3dzZXIgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhlIGxvY2sgdG8gYmUgYWNxdWlyZWQuXG4gKiBAcGFyYW0gYWNxdWlyZVRpbWVvdXQgSWYgbmVnYXRpdmUsIG5vIHRpbWVvdXQuIElmIDAgYW4gZXJyb3IgaXMgdGhyb3duIGlmXG4gKiAgICAgICAgICAgICAgICAgICAgICAgdGhlIGxvY2sgY2FuJ3QgYmUgYWNxdWlyZWQgd2l0aG91dCB3YWl0aW5nLiBJZiBwb3NpdGl2ZSwgdGhlIGxvY2sgYWNxdWlyZVxuICogICAgICAgICAgICAgICAgICAgICAgIHdpbGwgdGltZSBvdXQgYWZ0ZXIgc28gbWFueSBtaWxsaXNlY29uZHMuIEFuIGVycm9yIGlzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgYSB0aW1lb3V0IGlmIGl0IGhhcyBgaXNBY3F1aXJlVGltZW91dGAgc2V0IHRvIHRydWUuXG4gKiBAcGFyYW0gZm4gVGhlIG9wZXJhdGlvbiB0byBydW4gb25jZSB0aGUgbG9jayBpcyBhY3F1aXJlZC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NMb2NrKG5hbWUsIGFjcXVpcmVUaW1lb3V0LCBmbikge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBwcmV2aW91c09wZXJhdGlvbiA9IChfYSA9IFBST0NFU1NfTE9DS1NbbmFtZV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIGNvbnN0IGN1cnJlbnRPcGVyYXRpb24gPSBQcm9taXNlLnJhY2UoW1xuICAgICAgICBwcmV2aW91c09wZXJhdGlvbi5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAvLyBpZ25vcmUgZXJyb3Igb2YgcHJldmlvdXMgb3BlcmF0aW9uIHRoYXQgd2UncmUgd2FpdGluZyB0byBmaW5pc2hcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KSxcbiAgICAgICAgYWNxdWlyZVRpbWVvdXQgPj0gMFxuICAgICAgICAgICAgPyBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgUHJvY2Vzc0xvY2tBY3F1aXJlVGltZW91dEVycm9yKGBBY3F1cmluZyBwcm9jZXNzIGxvY2sgd2l0aCBuYW1lIFwiJHtuYW1lfVwiIHRpbWVkIG91dGApKTtcbiAgICAgICAgICAgICAgICB9LCBhY3F1aXJlVGltZW91dCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgOiBudWxsLFxuICAgIF0uZmlsdGVyKCh4KSA9PiB4KSlcbiAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgIGlmIChlICYmIGUuaXNBY3F1aXJlVGltZW91dCkge1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9KVxuICAgICAgICAudGhlbihhc3luYyAoKSA9PiB7XG4gICAgICAgIC8vIHByZXZpb3VzIG9wZXJhdGlvbnMgZmluaXNoZWQgYW5kIHdlIGRpZG4ndCBnZXQgYSByYWNlIG9uIHRoZSBhY3F1aXJlXG4gICAgICAgIC8vIHRpbWVvdXQsIHNvIHRoZSBjdXJyZW50IG9wZXJhdGlvbiBjYW4gZmluYWxseSBzdGFydFxuICAgICAgICByZXR1cm4gYXdhaXQgZm4oKTtcbiAgICB9KTtcbiAgICBQUk9DRVNTX0xPQ0tTW25hbWVdID0gY3VycmVudE9wZXJhdGlvbi5jYXRjaChhc3luYyAoZSkgPT4ge1xuICAgICAgICBpZiAoZSAmJiBlLmlzQWNxdWlyZVRpbWVvdXQpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBjdXJyZW50IG9wZXJhdGlvbiB0aW1lZCBvdXQsIGl0IGRvZXNuJ3QgbWVhbiB0aGF0IHRoZSBwcmV2aW91c1xuICAgICAgICAgICAgLy8gb3BlcmF0aW9uIGZpbmlzaGVkLCBzbyB3ZSBuZWVkIGNvbnRudWUgd2FpdGluZyBmb3IgaXQgdG8gZmluaXNoXG4gICAgICAgICAgICBhd2FpdCBwcmV2aW91c09wZXJhdGlvbjtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGU7XG4gICAgfSk7XG4gICAgLy8gZmluYWxseSB3YWl0IGZvciB0aGUgY3VycmVudCBvcGVyYXRpb24gdG8gZmluaXNoIHN1Y2Nlc3NmdWxseSwgd2l0aCBhblxuICAgIC8vIGVycm9yIG9yIHdpdGggYW4gYWNxdWlyZSB0aW1lb3V0IGVycm9yXG4gICAgcmV0dXJuIGF3YWl0IGN1cnJlbnRPcGVyYXRpb247XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2Nrcy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/locks.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/polyfills.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/polyfills.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   polyfillGlobalThis: () => (/* binding */ polyfillGlobalThis)\n/* harmony export */ });\n/**\n * https://mathiasbynens.be/notes/globalthis\n */\nfunction polyfillGlobalThis() {\n    if (typeof globalThis === 'object')\n        return;\n    try {\n        Object.defineProperty(Object.prototype, '__magic__', {\n            get: function () {\n                return this;\n            },\n            configurable: true,\n        });\n        // @ts-expect-error 'Allow access to magic'\n        __magic__.globalThis = __magic__;\n        // @ts-expect-error 'Allow access to magic'\n        delete Object.prototype.__magic__;\n    }\n    catch (e) {\n        if (typeof self !== 'undefined') {\n            // @ts-expect-error 'Allow access to globals'\n            self.globalThis = self;\n        }\n    }\n}\n//# sourceMappingURL=polyfills.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvcG9seWZpbGxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvV29uZGVyVml0ZS1mcm9udGVuZC9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL3BvbHlmaWxscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9nbG9iYWx0aGlzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwb2x5ZmlsbEdsb2JhbFRoaXMoKSB7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JylcbiAgICAgICAgcmV0dXJuO1xuICAgIHRyeSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3QucHJvdG90eXBlLCAnX19tYWdpY19fJywge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAnQWxsb3cgYWNjZXNzIHRvIG1hZ2ljJ1xuICAgICAgICBfX21hZ2ljX18uZ2xvYmFsVGhpcyA9IF9fbWFnaWNfXztcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAnQWxsb3cgYWNjZXNzIHRvIG1hZ2ljJ1xuICAgICAgICBkZWxldGUgT2JqZWN0LnByb3RvdHlwZS5fX21hZ2ljX187XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgJ0FsbG93IGFjY2VzcyB0byBnbG9iYWxzJ1xuICAgICAgICAgICAgc2VsZi5nbG9iYWxUaGlzID0gc2VsZjtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvbHlmaWxscy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/polyfills.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/types.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/types.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvdHlwZXMuanMiLCJtYXBwaW5ncyI6IjtBQUFVO0FBQ1YiLCJzb3VyY2VzIjpbIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL1dvbmRlclZpdGUtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL2Rpc3QvbW9kdWxlL2xpYi90eXBlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/types.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/version.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/version.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = '2.67.3';\n//# sourceMappingURL=version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUCIsInNvdXJjZXMiOlsiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvV29uZGVyVml0ZS1mcm9udGVuZC9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL3ZlcnNpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSAnMi42Ny4zJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlcnNpb24uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/version.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/functions-js/dist/module/FunctionsClient.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@supabase/functions-js/dist/module/FunctionsClient.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FunctionsClient: () => (/* binding */ FunctionsClient)\n/* harmony export */ });\n/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helper */ \"(app-pages-browser)/./node_modules/@supabase/functions-js/dist/module/helper.js\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"(app-pages-browser)/./node_modules/@supabase/functions-js/dist/module/types.js\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\nclass FunctionsClient {\n    constructor(url, { headers = {}, customFetch, region = _types__WEBPACK_IMPORTED_MODULE_0__.FunctionRegion.Any, } = {}) {\n        this.url = url;\n        this.headers = headers;\n        this.region = region;\n        this.fetch = (0,_helper__WEBPACK_IMPORTED_MODULE_1__.resolveFetch)(customFetch);\n    }\n    /**\n     * Updates the authorization header\n     * @param token - the new jwt token sent in the authorisation header\n     */\n    setAuth(token) {\n        this.headers.Authorization = `Bearer ${token}`;\n    }\n    /**\n     * Invokes a function\n     * @param functionName - The name of the Function to invoke.\n     * @param options - Options for invoking the Function.\n     */\n    invoke(functionName, options = {}) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const { headers, method, body: functionArgs } = options;\n                let _headers = {};\n                let { region } = options;\n                if (!region) {\n                    region = this.region;\n                }\n                if (region && region !== 'any') {\n                    _headers['x-region'] = region;\n                }\n                let body;\n                if (functionArgs &&\n                    ((headers && !Object.prototype.hasOwnProperty.call(headers, 'Content-Type')) || !headers)) {\n                    if ((typeof Blob !== 'undefined' && functionArgs instanceof Blob) ||\n                        functionArgs instanceof ArrayBuffer) {\n                        // will work for File as File inherits Blob\n                        // also works for ArrayBuffer as it is the same underlying structure as a Blob\n                        _headers['Content-Type'] = 'application/octet-stream';\n                        body = functionArgs;\n                    }\n                    else if (typeof functionArgs === 'string') {\n                        // plain string\n                        _headers['Content-Type'] = 'text/plain';\n                        body = functionArgs;\n                    }\n                    else if (typeof FormData !== 'undefined' && functionArgs instanceof FormData) {\n                        // don't set content-type headers\n                        // Request will automatically add the right boundary value\n                        body = functionArgs;\n                    }\n                    else {\n                        // default, assume this is JSON\n                        _headers['Content-Type'] = 'application/json';\n                        body = JSON.stringify(functionArgs);\n                    }\n                }\n                const response = yield this.fetch(`${this.url}/${functionName}`, {\n                    method: method || 'POST',\n                    // headers priority is (high to low):\n                    // 1. invoke-level headers\n                    // 2. client-level headers\n                    // 3. default Content-Type header\n                    headers: Object.assign(Object.assign(Object.assign({}, _headers), this.headers), headers),\n                    body,\n                }).catch((fetchError) => {\n                    throw new _types__WEBPACK_IMPORTED_MODULE_0__.FunctionsFetchError(fetchError);\n                });\n                const isRelayError = response.headers.get('x-relay-error');\n                if (isRelayError && isRelayError === 'true') {\n                    throw new _types__WEBPACK_IMPORTED_MODULE_0__.FunctionsRelayError(response);\n                }\n                if (!response.ok) {\n                    throw new _types__WEBPACK_IMPORTED_MODULE_0__.FunctionsHttpError(response);\n                }\n                let responseType = ((_a = response.headers.get('Content-Type')) !== null && _a !== void 0 ? _a : 'text/plain').split(';')[0].trim();\n                let data;\n                if (responseType === 'application/json') {\n                    data = yield response.json();\n                }\n                else if (responseType === 'application/octet-stream') {\n                    data = yield response.blob();\n                }\n                else if (responseType === 'text/event-stream') {\n                    data = response;\n                }\n                else if (responseType === 'multipart/form-data') {\n                    data = yield response.formData();\n                }\n                else {\n                    // default to text\n                    data = yield response.text();\n                }\n                return { data, error: null };\n            }\n            catch (error) {\n                return { data: null, error };\n            }\n        });\n    }\n}\n//# sourceMappingURL=FunctionsClient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvZnVuY3Rpb25zLWpzL2Rpc3QvbW9kdWxlL0Z1bmN0aW9uc0NsaWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxpQkFBaUIsU0FBSSxJQUFJLFNBQUk7QUFDN0IsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDd0M7QUFDZ0U7QUFDakc7QUFDUCx1QkFBdUIsWUFBWSx3QkFBd0Isa0RBQWMsUUFBUSxJQUFJO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixxREFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsTUFBTTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNDQUFzQztBQUM5RDtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsU0FBUyxHQUFHLGFBQWE7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RTtBQUNBLGlCQUFpQjtBQUNqQiw4QkFBOEIsdURBQW1CO0FBQ2pELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsOEJBQThCLHVEQUFtQjtBQUNqRDtBQUNBO0FBQ0EsOEJBQThCLHNEQUFrQjtBQUNoRDtBQUNBLHVJQUF1STtBQUN2STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvd29uZGVybGFuZG1pdGNoL0Nhc2NhZGVQcm9qZWN0cy9Xb25kZXJWaXRlLWZyb250ZW5kL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvZnVuY3Rpb25zLWpzL2Rpc3QvbW9kdWxlL0Z1bmN0aW9uc0NsaWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmltcG9ydCB7IHJlc29sdmVGZXRjaCB9IGZyb20gJy4vaGVscGVyJztcbmltcG9ydCB7IEZ1bmN0aW9uc0ZldGNoRXJyb3IsIEZ1bmN0aW9uc0h0dHBFcnJvciwgRnVuY3Rpb25zUmVsYXlFcnJvciwgRnVuY3Rpb25SZWdpb24sIH0gZnJvbSAnLi90eXBlcyc7XG5leHBvcnQgY2xhc3MgRnVuY3Rpb25zQ2xpZW50IHtcbiAgICBjb25zdHJ1Y3Rvcih1cmwsIHsgaGVhZGVycyA9IHt9LCBjdXN0b21GZXRjaCwgcmVnaW9uID0gRnVuY3Rpb25SZWdpb24uQW55LCB9ID0ge30pIHtcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgICAgIHRoaXMucmVnaW9uID0gcmVnaW9uO1xuICAgICAgICB0aGlzLmZldGNoID0gcmVzb2x2ZUZldGNoKGN1c3RvbUZldGNoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgYXV0aG9yaXphdGlvbiBoZWFkZXJcbiAgICAgKiBAcGFyYW0gdG9rZW4gLSB0aGUgbmV3IGp3dCB0b2tlbiBzZW50IGluIHRoZSBhdXRob3Jpc2F0aW9uIGhlYWRlclxuICAgICAqL1xuICAgIHNldEF1dGgodG9rZW4pIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzLkF1dGhvcml6YXRpb24gPSBgQmVhcmVyICR7dG9rZW59YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW52b2tlcyBhIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIGZ1bmN0aW9uTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBGdW5jdGlvbiB0byBpbnZva2UuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciBpbnZva2luZyB0aGUgRnVuY3Rpb24uXG4gICAgICovXG4gICAgaW52b2tlKGZ1bmN0aW9uTmFtZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBoZWFkZXJzLCBtZXRob2QsIGJvZHk6IGZ1bmN0aW9uQXJncyB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgICAgICBsZXQgX2hlYWRlcnMgPSB7fTtcbiAgICAgICAgICAgICAgICBsZXQgeyByZWdpb24gfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWdpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVnaW9uID0gdGhpcy5yZWdpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZWdpb24gJiYgcmVnaW9uICE9PSAnYW55Jykge1xuICAgICAgICAgICAgICAgICAgICBfaGVhZGVyc1sneC1yZWdpb24nXSA9IHJlZ2lvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGJvZHk7XG4gICAgICAgICAgICAgICAgaWYgKGZ1bmN0aW9uQXJncyAmJlxuICAgICAgICAgICAgICAgICAgICAoKGhlYWRlcnMgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChoZWFkZXJzLCAnQ29udGVudC1UeXBlJykpIHx8ICFoZWFkZXJzKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiBmdW5jdGlvbkFyZ3MgaW5zdGFuY2VvZiBCbG9iKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25BcmdzIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdpbGwgd29yayBmb3IgRmlsZSBhcyBGaWxlIGluaGVyaXRzIEJsb2JcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsc28gd29ya3MgZm9yIEFycmF5QnVmZmVyIGFzIGl0IGlzIHRoZSBzYW1lIHVuZGVybHlpbmcgc3RydWN0dXJlIGFzIGEgQmxvYlxuICAgICAgICAgICAgICAgICAgICAgICAgX2hlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5ID0gZnVuY3Rpb25BcmdzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBmdW5jdGlvbkFyZ3MgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwbGFpbiBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIF9oZWFkZXJzWydDb250ZW50LVR5cGUnXSA9ICd0ZXh0L3BsYWluJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgPSBmdW5jdGlvbkFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIEZvcm1EYXRhICE9PSAndW5kZWZpbmVkJyAmJiBmdW5jdGlvbkFyZ3MgaW5zdGFuY2VvZiBGb3JtRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3Qgc2V0IGNvbnRlbnQtdHlwZSBoZWFkZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXF1ZXN0IHdpbGwgYXV0b21hdGljYWxseSBhZGQgdGhlIHJpZ2h0IGJvdW5kYXJ5IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5ID0gZnVuY3Rpb25BcmdzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVmYXVsdCwgYXNzdW1lIHRoaXMgaXMgSlNPTlxuICAgICAgICAgICAgICAgICAgICAgICAgX2hlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keSA9IEpTT04uc3RyaW5naWZ5KGZ1bmN0aW9uQXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmZldGNoKGAke3RoaXMudXJsfS8ke2Z1bmN0aW9uTmFtZX1gLCB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kIHx8ICdQT1NUJyxcbiAgICAgICAgICAgICAgICAgICAgLy8gaGVhZGVycyBwcmlvcml0eSBpcyAoaGlnaCB0byBsb3cpOlxuICAgICAgICAgICAgICAgICAgICAvLyAxLiBpbnZva2UtbGV2ZWwgaGVhZGVyc1xuICAgICAgICAgICAgICAgICAgICAvLyAyLiBjbGllbnQtbGV2ZWwgaGVhZGVyc1xuICAgICAgICAgICAgICAgICAgICAvLyAzLiBkZWZhdWx0IENvbnRlbnQtVHlwZSBoZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIF9oZWFkZXJzKSwgdGhpcy5oZWFkZXJzKSwgaGVhZGVycyksXG4gICAgICAgICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goKGZldGNoRXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZ1bmN0aW9uc0ZldGNoRXJyb3IoZmV0Y2hFcnJvcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNSZWxheUVycm9yID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ3gtcmVsYXktZXJyb3InKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNSZWxheUVycm9yICYmIGlzUmVsYXlFcnJvciA9PT0gJ3RydWUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGdW5jdGlvbnNSZWxheUVycm9yKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRnVuY3Rpb25zSHR0cEVycm9yKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHJlc3BvbnNlVHlwZSA9ICgoX2EgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnQ29udGVudC1UeXBlJykpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICd0ZXh0L3BsYWluJykuc3BsaXQoJzsnKVswXS50cmltKCk7XG4gICAgICAgICAgICAgICAgbGV0IGRhdGE7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlVHlwZSA9PT0gJ2FwcGxpY2F0aW9uL2pzb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSB5aWVsZCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlc3BvbnNlVHlwZSA9PT0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHlpZWxkIHJlc3BvbnNlLmJsb2IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzcG9uc2VUeXBlID09PSAndGV4dC9ldmVudC1zdHJlYW0nKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzcG9uc2VUeXBlID09PSAnbXVsdGlwYXJ0L2Zvcm0tZGF0YScpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHlpZWxkIHJlc3BvbnNlLmZvcm1EYXRhKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IHRvIHRleHRcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHlpZWxkIHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZ1bmN0aW9uc0NsaWVudC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/functions-js/dist/module/FunctionsClient.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/functions-js/dist/module/helper.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@supabase/functions-js/dist/module/helper.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   resolveFetch: () => (/* binding */ resolveFetch)\n/* harmony export */ });\nconst resolveFetch = (customFetch) => {\n    let _fetch;\n    if (customFetch) {\n        _fetch = customFetch;\n    }\n    else if (typeof fetch === 'undefined') {\n        _fetch = (...args) => Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @supabase/node-fetch */ \"(app-pages-browser)/./node_modules/@supabase/node-fetch/browser.js\")).then(({ default: fetch }) => fetch(...args));\n    }\n    else {\n        _fetch = fetch;\n    }\n    return (...args) => _fetch(...args);\n};\n//# sourceMappingURL=helper.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvZnVuY3Rpb25zLWpzL2Rpc3QvbW9kdWxlL2hlbHBlci5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHNMQUE4QixTQUFTLGdCQUFnQjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvV29uZGVyVml0ZS1mcm9udGVuZC9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2Z1bmN0aW9ucy1qcy9kaXN0L21vZHVsZS9oZWxwZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHJlc29sdmVGZXRjaCA9IChjdXN0b21GZXRjaCkgPT4ge1xuICAgIGxldCBfZmV0Y2g7XG4gICAgaWYgKGN1c3RvbUZldGNoKSB7XG4gICAgICAgIF9mZXRjaCA9IGN1c3RvbUZldGNoO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZmV0Y2ggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIF9mZXRjaCA9ICguLi5hcmdzKSA9PiBpbXBvcnQoJ0BzdXBhYmFzZS9ub2RlLWZldGNoJykudGhlbigoeyBkZWZhdWx0OiBmZXRjaCB9KSA9PiBmZXRjaCguLi5hcmdzKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBfZmV0Y2ggPSBmZXRjaDtcbiAgICB9XG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiBfZmV0Y2goLi4uYXJncyk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGVscGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/functions-js/dist/module/helper.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/functions-js/dist/module/types.js":
/*!******************************************************************!*\
  !*** ./node_modules/@supabase/functions-js/dist/module/types.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FunctionRegion: () => (/* binding */ FunctionRegion),\n/* harmony export */   FunctionsError: () => (/* binding */ FunctionsError),\n/* harmony export */   FunctionsFetchError: () => (/* binding */ FunctionsFetchError),\n/* harmony export */   FunctionsHttpError: () => (/* binding */ FunctionsHttpError),\n/* harmony export */   FunctionsRelayError: () => (/* binding */ FunctionsRelayError)\n/* harmony export */ });\nclass FunctionsError extends Error {\n    constructor(message, name = 'FunctionsError', context) {\n        super(message);\n        this.name = name;\n        this.context = context;\n    }\n}\nclass FunctionsFetchError extends FunctionsError {\n    constructor(context) {\n        super('Failed to send a request to the Edge Function', 'FunctionsFetchError', context);\n    }\n}\nclass FunctionsRelayError extends FunctionsError {\n    constructor(context) {\n        super('Relay Error invoking the Edge Function', 'FunctionsRelayError', context);\n    }\n}\nclass FunctionsHttpError extends FunctionsError {\n    constructor(context) {\n        super('Edge Function returned a non-2xx status code', 'FunctionsHttpError', context);\n    }\n}\n// Define the enum for the 'region' property\nvar FunctionRegion;\n(function (FunctionRegion) {\n    FunctionRegion[\"Any\"] = \"any\";\n    FunctionRegion[\"ApNortheast1\"] = \"ap-northeast-1\";\n    FunctionRegion[\"ApNortheast2\"] = \"ap-northeast-2\";\n    FunctionRegion[\"ApSouth1\"] = \"ap-south-1\";\n    FunctionRegion[\"ApSoutheast1\"] = \"ap-southeast-1\";\n    FunctionRegion[\"ApSoutheast2\"] = \"ap-southeast-2\";\n    FunctionRegion[\"CaCentral1\"] = \"ca-central-1\";\n    FunctionRegion[\"EuCentral1\"] = \"eu-central-1\";\n    FunctionRegion[\"EuWest1\"] = \"eu-west-1\";\n    FunctionRegion[\"EuWest2\"] = \"eu-west-2\";\n    FunctionRegion[\"EuWest3\"] = \"eu-west-3\";\n    FunctionRegion[\"SaEast1\"] = \"sa-east-1\";\n    FunctionRegion[\"UsEast1\"] = \"us-east-1\";\n    FunctionRegion[\"UsWest1\"] = \"us-west-1\";\n    FunctionRegion[\"UsWest2\"] = \"us-west-2\";\n})(FunctionRegion || (FunctionRegion = {}));\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvZnVuY3Rpb25zLWpzL2Rpc3QvbW9kdWxlL3R5cGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdDQUF3QztBQUN6QyIsInNvdXJjZXMiOlsiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvV29uZGVyVml0ZS1mcm9udGVuZC9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2Z1bmN0aW9ucy1qcy9kaXN0L21vZHVsZS90eXBlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY2xhc3MgRnVuY3Rpb25zRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgbmFtZSA9ICdGdW5jdGlvbnNFcnJvcicsIGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEZ1bmN0aW9uc0ZldGNoRXJyb3IgZXh0ZW5kcyBGdW5jdGlvbnNFcnJvciB7XG4gICAgY29uc3RydWN0b3IoY29udGV4dCkge1xuICAgICAgICBzdXBlcignRmFpbGVkIHRvIHNlbmQgYSByZXF1ZXN0IHRvIHRoZSBFZGdlIEZ1bmN0aW9uJywgJ0Z1bmN0aW9uc0ZldGNoRXJyb3InLCBjb250ZXh0KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgRnVuY3Rpb25zUmVsYXlFcnJvciBleHRlbmRzIEZ1bmN0aW9uc0Vycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyKCdSZWxheSBFcnJvciBpbnZva2luZyB0aGUgRWRnZSBGdW5jdGlvbicsICdGdW5jdGlvbnNSZWxheUVycm9yJywgY29udGV4dCk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEZ1bmN0aW9uc0h0dHBFcnJvciBleHRlbmRzIEZ1bmN0aW9uc0Vycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyKCdFZGdlIEZ1bmN0aW9uIHJldHVybmVkIGEgbm9uLTJ4eCBzdGF0dXMgY29kZScsICdGdW5jdGlvbnNIdHRwRXJyb3InLCBjb250ZXh0KTtcbiAgICB9XG59XG4vLyBEZWZpbmUgdGhlIGVudW0gZm9yIHRoZSAncmVnaW9uJyBwcm9wZXJ0eVxuZXhwb3J0IHZhciBGdW5jdGlvblJlZ2lvbjtcbihmdW5jdGlvbiAoRnVuY3Rpb25SZWdpb24pIHtcbiAgICBGdW5jdGlvblJlZ2lvbltcIkFueVwiXSA9IFwiYW55XCI7XG4gICAgRnVuY3Rpb25SZWdpb25bXCJBcE5vcnRoZWFzdDFcIl0gPSBcImFwLW5vcnRoZWFzdC0xXCI7XG4gICAgRnVuY3Rpb25SZWdpb25bXCJBcE5vcnRoZWFzdDJcIl0gPSBcImFwLW5vcnRoZWFzdC0yXCI7XG4gICAgRnVuY3Rpb25SZWdpb25bXCJBcFNvdXRoMVwiXSA9IFwiYXAtc291dGgtMVwiO1xuICAgIEZ1bmN0aW9uUmVnaW9uW1wiQXBTb3V0aGVhc3QxXCJdID0gXCJhcC1zb3V0aGVhc3QtMVwiO1xuICAgIEZ1bmN0aW9uUmVnaW9uW1wiQXBTb3V0aGVhc3QyXCJdID0gXCJhcC1zb3V0aGVhc3QtMlwiO1xuICAgIEZ1bmN0aW9uUmVnaW9uW1wiQ2FDZW50cmFsMVwiXSA9IFwiY2EtY2VudHJhbC0xXCI7XG4gICAgRnVuY3Rpb25SZWdpb25bXCJFdUNlbnRyYWwxXCJdID0gXCJldS1jZW50cmFsLTFcIjtcbiAgICBGdW5jdGlvblJlZ2lvbltcIkV1V2VzdDFcIl0gPSBcImV1LXdlc3QtMVwiO1xuICAgIEZ1bmN0aW9uUmVnaW9uW1wiRXVXZXN0MlwiXSA9IFwiZXUtd2VzdC0yXCI7XG4gICAgRnVuY3Rpb25SZWdpb25bXCJFdVdlc3QzXCJdID0gXCJldS13ZXN0LTNcIjtcbiAgICBGdW5jdGlvblJlZ2lvbltcIlNhRWFzdDFcIl0gPSBcInNhLWVhc3QtMVwiO1xuICAgIEZ1bmN0aW9uUmVnaW9uW1wiVXNFYXN0MVwiXSA9IFwidXMtZWFzdC0xXCI7XG4gICAgRnVuY3Rpb25SZWdpb25bXCJVc1dlc3QxXCJdID0gXCJ1cy13ZXN0LTFcIjtcbiAgICBGdW5jdGlvblJlZ2lvbltcIlVzV2VzdDJcIl0gPSBcInVzLXdlc3QtMlwiO1xufSkoRnVuY3Rpb25SZWdpb24gfHwgKEZ1bmN0aW9uUmVnaW9uID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/functions-js/dist/module/types.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/node-fetch/browser.js":
/*!******************************************************!*\
  !*** ./node_modules/@supabase/node-fetch/browser.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Headers: () => (/* binding */ Headers),\n/* harmony export */   Request: () => (/* binding */ Request),\n/* harmony export */   Response: () => (/* binding */ Response),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   fetch: () => (/* binding */ fetch)\n/* harmony export */ });\n\n\n// ref: https://github.com/tc39/proposal-global\nvar getGlobal = function() {\n    // the only reliable means to get the global object is\n    // `Function('return this')()`\n    // However, this causes CSP violations in Chrome apps.\n    if (typeof self !== 'undefined') { return self; }\n    if (typeof window !== 'undefined') { return window; }\n    if (typeof __webpack_require__.g !== 'undefined') { return __webpack_require__.g; }\n    throw new Error('unable to locate global object');\n}\n\nvar globalObject = getGlobal();\n\nconst fetch = globalObject.fetch;\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (globalObject.fetch.bind(globalObject));\n\nconst Headers = globalObject.Headers;\nconst Request = globalObject.Request;\nconst Response = globalObject.Response;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvbm9kZS1mZXRjaC9icm93c2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2Qyx5Q0FBeUM7QUFDekMsZUFBZSxxQkFBTSxvQkFBb0IsT0FBTyxxQkFBTTtBQUN0RDtBQUNBOztBQUVBOztBQUVPOztBQUVQLGlFQUFlLHFDQUFxQyxFQUFDOztBQUU5QztBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL1dvbmRlclZpdGUtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9ub2RlLWZldGNoL2Jyb3dzZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIHJlZjogaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtZ2xvYmFsXG52YXIgZ2V0R2xvYmFsID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gdGhlIG9ubHkgcmVsaWFibGUgbWVhbnMgdG8gZ2V0IHRoZSBnbG9iYWwgb2JqZWN0IGlzXG4gICAgLy8gYEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKClgXG4gICAgLy8gSG93ZXZlciwgdGhpcyBjYXVzZXMgQ1NQIHZpb2xhdGlvbnMgaW4gQ2hyb21lIGFwcHMuXG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykgeyByZXR1cm4gc2VsZjsgfVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgeyByZXR1cm4gd2luZG93OyB9XG4gICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7IHJldHVybiBnbG9iYWw7IH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuYWJsZSB0byBsb2NhdGUgZ2xvYmFsIG9iamVjdCcpO1xufVxuXG52YXIgZ2xvYmFsT2JqZWN0ID0gZ2V0R2xvYmFsKCk7XG5cbmV4cG9ydCBjb25zdCBmZXRjaCA9IGdsb2JhbE9iamVjdC5mZXRjaDtcblxuZXhwb3J0IGRlZmF1bHQgZ2xvYmFsT2JqZWN0LmZldGNoLmJpbmQoZ2xvYmFsT2JqZWN0KTtcblxuZXhwb3J0IGNvbnN0IEhlYWRlcnMgPSBnbG9iYWxPYmplY3QuSGVhZGVycztcbmV4cG9ydCBjb25zdCBSZXF1ZXN0ID0gZ2xvYmFsT2JqZWN0LlJlcXVlc3Q7XG5leHBvcnQgY29uc3QgUmVzcG9uc2UgPSBnbG9iYWxPYmplY3QuUmVzcG9uc2U7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/node-fetch/browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestBuilder.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestBuilder.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// @ts-ignore\nconst node_fetch_1 = __importDefault(__webpack_require__(/*! @supabase/node-fetch */ \"(app-pages-browser)/./node_modules/@supabase/node-fetch/browser.js\"));\nconst PostgrestError_1 = __importDefault(__webpack_require__(/*! ./PostgrestError */ \"(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestError.js\"));\nclass PostgrestBuilder {\n    constructor(builder) {\n        this.shouldThrowOnError = false;\n        this.method = builder.method;\n        this.url = builder.url;\n        this.headers = builder.headers;\n        this.schema = builder.schema;\n        this.body = builder.body;\n        this.shouldThrowOnError = builder.shouldThrowOnError;\n        this.signal = builder.signal;\n        this.isMaybeSingle = builder.isMaybeSingle;\n        if (builder.fetch) {\n            this.fetch = builder.fetch;\n        }\n        else if (typeof fetch === 'undefined') {\n            this.fetch = node_fetch_1.default;\n        }\n        else {\n            this.fetch = fetch;\n        }\n    }\n    /**\n     * If there's an error with the query, throwOnError will reject the promise by\n     * throwing the error instead of returning it as part of a successful response.\n     *\n     * {@link https://github.com/supabase/supabase-js/issues/92}\n     */\n    throwOnError() {\n        this.shouldThrowOnError = true;\n        return this;\n    }\n    /**\n     * Set an HTTP header for the request.\n     */\n    setHeader(name, value) {\n        this.headers = Object.assign({}, this.headers);\n        this.headers[name] = value;\n        return this;\n    }\n    then(onfulfilled, onrejected) {\n        // https://postgrest.org/en/stable/api.html#switching-schemas\n        if (this.schema === undefined) {\n            // skip\n        }\n        else if (['GET', 'HEAD'].includes(this.method)) {\n            this.headers['Accept-Profile'] = this.schema;\n        }\n        else {\n            this.headers['Content-Profile'] = this.schema;\n        }\n        if (this.method !== 'GET' && this.method !== 'HEAD') {\n            this.headers['Content-Type'] = 'application/json';\n        }\n        // NOTE: Invoke w/o `this` to avoid illegal invocation error.\n        // https://github.com/supabase/postgrest-js/pull/247\n        const _fetch = this.fetch;\n        let res = _fetch(this.url.toString(), {\n            method: this.method,\n            headers: this.headers,\n            body: JSON.stringify(this.body),\n            signal: this.signal,\n        }).then(async (res) => {\n            var _a, _b, _c;\n            let error = null;\n            let data = null;\n            let count = null;\n            let status = res.status;\n            let statusText = res.statusText;\n            if (res.ok) {\n                if (this.method !== 'HEAD') {\n                    const body = await res.text();\n                    if (body === '') {\n                        // Prefer: return=minimal\n                    }\n                    else if (this.headers['Accept'] === 'text/csv') {\n                        data = body;\n                    }\n                    else if (this.headers['Accept'] &&\n                        this.headers['Accept'].includes('application/vnd.pgrst.plan+text')) {\n                        data = body;\n                    }\n                    else {\n                        data = JSON.parse(body);\n                    }\n                }\n                const countHeader = (_a = this.headers['Prefer']) === null || _a === void 0 ? void 0 : _a.match(/count=(exact|planned|estimated)/);\n                const contentRange = (_b = res.headers.get('content-range')) === null || _b === void 0 ? void 0 : _b.split('/');\n                if (countHeader && contentRange && contentRange.length > 1) {\n                    count = parseInt(contentRange[1]);\n                }\n                // Temporary partial fix for https://github.com/supabase/postgrest-js/issues/361\n                // Issue persists e.g. for `.insert([...]).select().maybeSingle()`\n                if (this.isMaybeSingle && this.method === 'GET' && Array.isArray(data)) {\n                    if (data.length > 1) {\n                        error = {\n                            // https://github.com/PostgREST/postgrest/blob/a867d79c42419af16c18c3fb019eba8df992626f/src/PostgREST/Error.hs#L553\n                            code: 'PGRST116',\n                            details: `Results contain ${data.length} rows, application/vnd.pgrst.object+json requires 1 row`,\n                            hint: null,\n                            message: 'JSON object requested, multiple (or no) rows returned',\n                        };\n                        data = null;\n                        count = null;\n                        status = 406;\n                        statusText = 'Not Acceptable';\n                    }\n                    else if (data.length === 1) {\n                        data = data[0];\n                    }\n                    else {\n                        data = null;\n                    }\n                }\n            }\n            else {\n                const body = await res.text();\n                try {\n                    error = JSON.parse(body);\n                    // Workaround for https://github.com/supabase/postgrest-js/issues/295\n                    if (Array.isArray(error) && res.status === 404) {\n                        data = [];\n                        error = null;\n                        status = 200;\n                        statusText = 'OK';\n                    }\n                }\n                catch (_d) {\n                    // Workaround for https://github.com/supabase/postgrest-js/issues/295\n                    if (res.status === 404 && body === '') {\n                        status = 204;\n                        statusText = 'No Content';\n                    }\n                    else {\n                        error = {\n                            message: body,\n                        };\n                    }\n                }\n                if (error && this.isMaybeSingle && ((_c = error === null || error === void 0 ? void 0 : error.details) === null || _c === void 0 ? void 0 : _c.includes('0 rows'))) {\n                    error = null;\n                    status = 200;\n                    statusText = 'OK';\n                }\n                if (error && this.shouldThrowOnError) {\n                    throw new PostgrestError_1.default(error);\n                }\n            }\n            const postgrestResponse = {\n                error,\n                data,\n                count,\n                status,\n                statusText,\n            };\n            return postgrestResponse;\n        });\n        if (!this.shouldThrowOnError) {\n            res = res.catch((fetchError) => {\n                var _a, _b, _c;\n                return ({\n                    error: {\n                        message: `${(_a = fetchError === null || fetchError === void 0 ? void 0 : fetchError.name) !== null && _a !== void 0 ? _a : 'FetchError'}: ${fetchError === null || fetchError === void 0 ? void 0 : fetchError.message}`,\n                        details: `${(_b = fetchError === null || fetchError === void 0 ? void 0 : fetchError.stack) !== null && _b !== void 0 ? _b : ''}`,\n                        hint: '',\n                        code: `${(_c = fetchError === null || fetchError === void 0 ? void 0 : fetchError.code) !== null && _c !== void 0 ? _c : ''}`,\n                    },\n                    data: null,\n                    count: null,\n                    status: 0,\n                    statusText: '',\n                });\n            });\n        }\n        return res.then(onfulfilled, onrejected);\n    }\n}\nexports[\"default\"] = PostgrestBuilder;\n//# sourceMappingURL=PostgrestBuilder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL2Rpc3QvY2pzL1Bvc3RncmVzdEJ1aWxkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBLHFDQUFxQyxtQkFBTyxDQUFDLGdHQUFzQjtBQUNuRSx5Q0FBeUMsbUJBQU8sQ0FBQyw4R0FBa0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsYUFBYTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw2SEFBNkgsSUFBSSwyRUFBMkU7QUFDaFAsb0NBQW9DLG9IQUFvSDtBQUN4SjtBQUNBLGlDQUFpQyxtSEFBbUg7QUFDcEoscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL1dvbmRlclZpdGUtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMvZGlzdC9janMvUG9zdGdyZXN0QnVpbGRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIEB0cy1pZ25vcmVcbmNvbnN0IG5vZGVfZmV0Y2hfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiQHN1cGFiYXNlL25vZGUtZmV0Y2hcIikpO1xuY29uc3QgUG9zdGdyZXN0RXJyb3JfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9Qb3N0Z3Jlc3RFcnJvclwiKSk7XG5jbGFzcyBQb3N0Z3Jlc3RCdWlsZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihidWlsZGVyKSB7XG4gICAgICAgIHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yID0gZmFsc2U7XG4gICAgICAgIHRoaXMubWV0aG9kID0gYnVpbGRlci5tZXRob2Q7XG4gICAgICAgIHRoaXMudXJsID0gYnVpbGRlci51cmw7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IGJ1aWxkZXIuaGVhZGVycztcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBidWlsZGVyLnNjaGVtYTtcbiAgICAgICAgdGhpcy5ib2R5ID0gYnVpbGRlci5ib2R5O1xuICAgICAgICB0aGlzLnNob3VsZFRocm93T25FcnJvciA9IGJ1aWxkZXIuc2hvdWxkVGhyb3dPbkVycm9yO1xuICAgICAgICB0aGlzLnNpZ25hbCA9IGJ1aWxkZXIuc2lnbmFsO1xuICAgICAgICB0aGlzLmlzTWF5YmVTaW5nbGUgPSBidWlsZGVyLmlzTWF5YmVTaW5nbGU7XG4gICAgICAgIGlmIChidWlsZGVyLmZldGNoKSB7XG4gICAgICAgICAgICB0aGlzLmZldGNoID0gYnVpbGRlci5mZXRjaDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgZmV0Y2ggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aGlzLmZldGNoID0gbm9kZV9mZXRjaF8xLmRlZmF1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZldGNoID0gZmV0Y2g7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgdGhlcmUncyBhbiBlcnJvciB3aXRoIHRoZSBxdWVyeSwgdGhyb3dPbkVycm9yIHdpbGwgcmVqZWN0IHRoZSBwcm9taXNlIGJ5XG4gICAgICogdGhyb3dpbmcgdGhlIGVycm9yIGluc3RlYWQgb2YgcmV0dXJuaW5nIGl0IGFzIHBhcnQgb2YgYSBzdWNjZXNzZnVsIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICoge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9zdXBhYmFzZS9zdXBhYmFzZS1qcy9pc3N1ZXMvOTJ9XG4gICAgICovXG4gICAgdGhyb3dPbkVycm9yKCkge1xuICAgICAgICB0aGlzLnNob3VsZFRocm93T25FcnJvciA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgYW4gSFRUUCBoZWFkZXIgZm9yIHRoZSByZXF1ZXN0LlxuICAgICAqL1xuICAgIHNldEhlYWRlcihuYW1lLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmhlYWRlcnMpO1xuICAgICAgICB0aGlzLmhlYWRlcnNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRoZW4ob25mdWxmaWxsZWQsIG9ucmVqZWN0ZWQpIHtcbiAgICAgICAgLy8gaHR0cHM6Ly9wb3N0Z3Jlc3Qub3JnL2VuL3N0YWJsZS9hcGkuaHRtbCNzd2l0Y2hpbmctc2NoZW1hc1xuICAgICAgICBpZiAodGhpcy5zY2hlbWEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gc2tpcFxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFsnR0VUJywgJ0hFQUQnXS5pbmNsdWRlcyh0aGlzLm1ldGhvZCkpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyc1snQWNjZXB0LVByb2ZpbGUnXSA9IHRoaXMuc2NoZW1hO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzWydDb250ZW50LVByb2ZpbGUnXSA9IHRoaXMuc2NoZW1hO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1ldGhvZCAhPT0gJ0dFVCcgJiYgdGhpcy5tZXRob2QgIT09ICdIRUFEJykge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgfVxuICAgICAgICAvLyBOT1RFOiBJbnZva2Ugdy9vIGB0aGlzYCB0byBhdm9pZCBpbGxlZ2FsIGludm9jYXRpb24gZXJyb3IuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zdXBhYmFzZS9wb3N0Z3Jlc3QtanMvcHVsbC8yNDdcbiAgICAgICAgY29uc3QgX2ZldGNoID0gdGhpcy5mZXRjaDtcbiAgICAgICAgbGV0IHJlcyA9IF9mZXRjaCh0aGlzLnVybC50b1N0cmluZygpLCB7XG4gICAgICAgICAgICBtZXRob2Q6IHRoaXMubWV0aG9kLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkodGhpcy5ib2R5KSxcbiAgICAgICAgICAgIHNpZ25hbDogdGhpcy5zaWduYWwsXG4gICAgICAgIH0pLnRoZW4oYXN5bmMgKHJlcykgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBsZXQgZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgbGV0IGRhdGEgPSBudWxsO1xuICAgICAgICAgICAgbGV0IGNvdW50ID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBzdGF0dXMgPSByZXMuc3RhdHVzO1xuICAgICAgICAgICAgbGV0IHN0YXR1c1RleHQgPSByZXMuc3RhdHVzVGV4dDtcbiAgICAgICAgICAgIGlmIChyZXMub2spIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tZXRob2QgIT09ICdIRUFEJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBib2R5ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvZHkgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQcmVmZXI6IHJldHVybj1taW5pbWFsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5oZWFkZXJzWydBY2NlcHQnXSA9PT0gJ3RleHQvY3N2Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGJvZHk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5oZWFkZXJzWydBY2NlcHQnXSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oZWFkZXJzWydBY2NlcHQnXS5pbmNsdWRlcygnYXBwbGljYXRpb24vdm5kLnBncnN0LnBsYW4rdGV4dCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gYm9keTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGJvZHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNvdW50SGVhZGVyID0gKF9hID0gdGhpcy5oZWFkZXJzWydQcmVmZXInXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hdGNoKC9jb3VudD0oZXhhY3R8cGxhbm5lZHxlc3RpbWF0ZWQpLyk7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udGVudFJhbmdlID0gKF9iID0gcmVzLmhlYWRlcnMuZ2V0KCdjb250ZW50LXJhbmdlJykpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zcGxpdCgnLycpO1xuICAgICAgICAgICAgICAgIGlmIChjb3VudEhlYWRlciAmJiBjb250ZW50UmFuZ2UgJiYgY29udGVudFJhbmdlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnQgPSBwYXJzZUludChjb250ZW50UmFuZ2VbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUZW1wb3JhcnkgcGFydGlhbCBmaXggZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9zdXBhYmFzZS9wb3N0Z3Jlc3QtanMvaXNzdWVzLzM2MVxuICAgICAgICAgICAgICAgIC8vIElzc3VlIHBlcnNpc3RzIGUuZy4gZm9yIGAuaW5zZXJ0KFsuLi5dKS5zZWxlY3QoKS5tYXliZVNpbmdsZSgpYFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzTWF5YmVTaW5nbGUgJiYgdGhpcy5tZXRob2QgPT09ICdHRVQnICYmIEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL1Bvc3RnUkVTVC9wb3N0Z3Jlc3QvYmxvYi9hODY3ZDc5YzQyNDE5YWYxNmMxOGMzZmIwMTllYmE4ZGY5OTI2MjZmL3NyYy9Qb3N0Z1JFU1QvRXJyb3IuaHMjTDU1M1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6ICdQR1JTVDExNicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogYFJlc3VsdHMgY29udGFpbiAke2RhdGEubGVuZ3RofSByb3dzLCBhcHBsaWNhdGlvbi92bmQucGdyc3Qub2JqZWN0K2pzb24gcmVxdWlyZXMgMSByb3dgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpbnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ0pTT04gb2JqZWN0IHJlcXVlc3RlZCwgbXVsdGlwbGUgKG9yIG5vKSByb3dzIHJldHVybmVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9IDQwNjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHQgPSAnTm90IEFjY2VwdGFibGUnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRhdGEubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YVswXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYm9keSA9IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBKU09OLnBhcnNlKGJvZHkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBXb3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vc3VwYWJhc2UvcG9zdGdyZXN0LWpzL2lzc3Vlcy8yOTVcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXJyb3IpICYmIHJlcy5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0gMjAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dCA9ICdPSyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKF9kKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdvcmthcm91bmQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9zdXBhYmFzZS9wb3N0Z3Jlc3QtanMvaXNzdWVzLzI5NVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzLnN0YXR1cyA9PT0gNDA0ICYmIGJvZHkgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMgPSAyMDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0ID0gJ05vIENvbnRlbnQnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYm9keSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yICYmIHRoaXMuaXNNYXliZVNpbmdsZSAmJiAoKF9jID0gZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLmRldGFpbHMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5pbmNsdWRlcygnMCByb3dzJykpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0gMjAwO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0ID0gJ09LJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yICYmIHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBQb3N0Z3Jlc3RFcnJvcl8xLmRlZmF1bHQoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBvc3RncmVzdFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgY291bnQsXG4gICAgICAgICAgICAgICAgc3RhdHVzLFxuICAgICAgICAgICAgICAgIHN0YXR1c1RleHQsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHBvc3RncmVzdFJlc3BvbnNlO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCF0aGlzLnNob3VsZFRocm93T25FcnJvcikge1xuICAgICAgICAgICAgcmVzID0gcmVzLmNhdGNoKChmZXRjaEVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgJHsoX2EgPSBmZXRjaEVycm9yID09PSBudWxsIHx8IGZldGNoRXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZldGNoRXJyb3IubmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ0ZldGNoRXJyb3InfTogJHtmZXRjaEVycm9yID09PSBudWxsIHx8IGZldGNoRXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZldGNoRXJyb3IubWVzc2FnZX1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogYCR7KF9iID0gZmV0Y2hFcnJvciA9PT0gbnVsbCB8fCBmZXRjaEVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmZXRjaEVycm9yLnN0YWNrKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJ31gLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGludDogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBgJHsoX2MgPSBmZXRjaEVycm9yID09PSBudWxsIHx8IGZldGNoRXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZldGNoRXJyb3IuY29kZSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogJyd9YCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgY291bnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogMCxcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dDogJycsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzLnRoZW4ob25mdWxmaWxsZWQsIG9ucmVqZWN0ZWQpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFBvc3RncmVzdEJ1aWxkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qb3N0Z3Jlc3RCdWlsZGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestBuilder.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestClient.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestClient.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst PostgrestQueryBuilder_1 = __importDefault(__webpack_require__(/*! ./PostgrestQueryBuilder */ \"(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestQueryBuilder.js\"));\nconst PostgrestFilterBuilder_1 = __importDefault(__webpack_require__(/*! ./PostgrestFilterBuilder */ \"(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestFilterBuilder.js\"));\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/constants.js\");\n/**\n * PostgREST client.\n *\n * @typeParam Database - Types for the schema from the [type\n * generator](https://supabase.com/docs/reference/javascript/next/typescript-support)\n *\n * @typeParam SchemaName - Postgres schema to switch to. Must be a string\n * literal, the same one passed to the constructor. If the schema is not\n * `\"public\"`, this must be supplied manually.\n */\nclass PostgrestClient {\n    // TODO: Add back shouldThrowOnError once we figure out the typings\n    /**\n     * Creates a PostgREST client.\n     *\n     * @param url - URL of the PostgREST endpoint\n     * @param options - Named parameters\n     * @param options.headers - Custom headers\n     * @param options.schema - Postgres schema to switch to\n     * @param options.fetch - Custom fetch\n     */\n    constructor(url, { headers = {}, schema, fetch, } = {}) {\n        this.url = url;\n        this.headers = Object.assign(Object.assign({}, constants_1.DEFAULT_HEADERS), headers);\n        this.schemaName = schema;\n        this.fetch = fetch;\n    }\n    /**\n     * Perform a query on a table or a view.\n     *\n     * @param relation - The table or view name to query\n     */\n    from(relation) {\n        const url = new URL(`${this.url}/${relation}`);\n        return new PostgrestQueryBuilder_1.default(url, {\n            headers: Object.assign({}, this.headers),\n            schema: this.schemaName,\n            fetch: this.fetch,\n        });\n    }\n    /**\n     * Select a schema to query or perform an function (rpc) call.\n     *\n     * The schema needs to be on the list of exposed schemas inside Supabase.\n     *\n     * @param schema - The schema to query\n     */\n    schema(schema) {\n        return new PostgrestClient(this.url, {\n            headers: this.headers,\n            schema,\n            fetch: this.fetch,\n        });\n    }\n    /**\n     * Perform a function call.\n     *\n     * @param fn - The function name to call\n     * @param args - The arguments to pass to the function call\n     * @param options - Named parameters\n     * @param options.head - When set to `true`, `data` will not be returned.\n     * Useful if you only need the count.\n     * @param options.get - When set to `true`, the function will be called with\n     * read-only access mode.\n     * @param options.count - Count algorithm to use to count rows returned by the\n     * function. Only applicable for [set-returning\n     * functions](https://www.postgresql.org/docs/current/functions-srf.html).\n     *\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n     * hood.\n     *\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n     * statistics under the hood.\n     *\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n     * numbers.\n     */\n    rpc(fn, args = {}, { head = false, get = false, count, } = {}) {\n        let method;\n        const url = new URL(`${this.url}/rpc/${fn}`);\n        let body;\n        if (head || get) {\n            method = head ? 'HEAD' : 'GET';\n            Object.entries(args)\n                // params with undefined value needs to be filtered out, otherwise it'll\n                // show up as `?param=undefined`\n                .filter(([_, value]) => value !== undefined)\n                // array values need special syntax\n                .map(([name, value]) => [name, Array.isArray(value) ? `{${value.join(',')}}` : `${value}`])\n                .forEach(([name, value]) => {\n                url.searchParams.append(name, value);\n            });\n        }\n        else {\n            method = 'POST';\n            body = args;\n        }\n        const headers = Object.assign({}, this.headers);\n        if (count) {\n            headers['Prefer'] = `count=${count}`;\n        }\n        return new PostgrestFilterBuilder_1.default({\n            method,\n            url,\n            headers,\n            schema: this.schemaName,\n            body,\n            fetch: this.fetch,\n            allowEmpty: false,\n        });\n    }\n}\nexports[\"default\"] = PostgrestClient;\n//# sourceMappingURL=PostgrestClient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL2Rpc3QvY2pzL1Bvc3RncmVzdENsaWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdEQUFnRCxtQkFBTyxDQUFDLDRIQUF5QjtBQUNqRixpREFBaUQsbUJBQU8sQ0FBQyw4SEFBMEI7QUFDbkYsb0JBQW9CLG1CQUFPLENBQUMsb0dBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFlBQVksbUJBQW1CLElBQUk7QUFDMUQ7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFNBQVMsR0FBRyxTQUFTO0FBQ3BEO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLElBQUksb0NBQW9DLElBQUk7QUFDakU7QUFDQSwrQkFBK0IsU0FBUyxPQUFPLEdBQUc7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxFQUFFLGlCQUFpQixPQUFPLE1BQU07QUFDeEc7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0EseUNBQXlDLE1BQU07QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyIvVXNlcnMvd29uZGVybGFuZG1pdGNoL0Nhc2NhZGVQcm9qZWN0cy9Xb25kZXJWaXRlLWZyb250ZW5kL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL2Rpc3QvY2pzL1Bvc3RncmVzdENsaWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFBvc3RncmVzdFF1ZXJ5QnVpbGRlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1Bvc3RncmVzdFF1ZXJ5QnVpbGRlclwiKSk7XG5jb25zdCBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vUG9zdGdyZXN0RmlsdGVyQnVpbGRlclwiKSk7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbi8qKlxuICogUG9zdGdSRVNUIGNsaWVudC5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGFiYXNlIC0gVHlwZXMgZm9yIHRoZSBzY2hlbWEgZnJvbSB0aGUgW3R5cGVcbiAqIGdlbmVyYXRvcl0oaHR0cHM6Ly9zdXBhYmFzZS5jb20vZG9jcy9yZWZlcmVuY2UvamF2YXNjcmlwdC9uZXh0L3R5cGVzY3JpcHQtc3VwcG9ydClcbiAqXG4gKiBAdHlwZVBhcmFtIFNjaGVtYU5hbWUgLSBQb3N0Z3JlcyBzY2hlbWEgdG8gc3dpdGNoIHRvLiBNdXN0IGJlIGEgc3RyaW5nXG4gKiBsaXRlcmFsLCB0aGUgc2FtZSBvbmUgcGFzc2VkIHRvIHRoZSBjb25zdHJ1Y3Rvci4gSWYgdGhlIHNjaGVtYSBpcyBub3RcbiAqIGBcInB1YmxpY1wiYCwgdGhpcyBtdXN0IGJlIHN1cHBsaWVkIG1hbnVhbGx5LlxuICovXG5jbGFzcyBQb3N0Z3Jlc3RDbGllbnQge1xuICAgIC8vIFRPRE86IEFkZCBiYWNrIHNob3VsZFRocm93T25FcnJvciBvbmNlIHdlIGZpZ3VyZSBvdXQgdGhlIHR5cGluZ3NcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgUG9zdGdSRVNUIGNsaWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1cmwgLSBVUkwgb2YgdGhlIFBvc3RnUkVTVCBlbmRwb2ludFxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLmhlYWRlcnMgLSBDdXN0b20gaGVhZGVyc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLnNjaGVtYSAtIFBvc3RncmVzIHNjaGVtYSB0byBzd2l0Y2ggdG9cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5mZXRjaCAtIEN1c3RvbSBmZXRjaFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHVybCwgeyBoZWFkZXJzID0ge30sIHNjaGVtYSwgZmV0Y2gsIH0gPSB7fSkge1xuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb25zdGFudHNfMS5ERUZBVUxUX0hFQURFUlMpLCBoZWFkZXJzKTtcbiAgICAgICAgdGhpcy5zY2hlbWFOYW1lID0gc2NoZW1hO1xuICAgICAgICB0aGlzLmZldGNoID0gZmV0Y2g7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gYSBxdWVyeSBvbiBhIHRhYmxlIG9yIGEgdmlldy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByZWxhdGlvbiAtIFRoZSB0YWJsZSBvciB2aWV3IG5hbWUgdG8gcXVlcnlcbiAgICAgKi9cbiAgICBmcm9tKHJlbGF0aW9uKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYCR7dGhpcy51cmx9LyR7cmVsYXRpb259YCk7XG4gICAgICAgIHJldHVybiBuZXcgUG9zdGdyZXN0UXVlcnlCdWlsZGVyXzEuZGVmYXVsdCh1cmwsIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuaGVhZGVycyksXG4gICAgICAgICAgICBzY2hlbWE6IHRoaXMuc2NoZW1hTmFtZSxcbiAgICAgICAgICAgIGZldGNoOiB0aGlzLmZldGNoLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VsZWN0IGEgc2NoZW1hIHRvIHF1ZXJ5IG9yIHBlcmZvcm0gYW4gZnVuY3Rpb24gKHJwYykgY2FsbC5cbiAgICAgKlxuICAgICAqIFRoZSBzY2hlbWEgbmVlZHMgdG8gYmUgb24gdGhlIGxpc3Qgb2YgZXhwb3NlZCBzY2hlbWFzIGluc2lkZSBTdXBhYmFzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzY2hlbWEgLSBUaGUgc2NoZW1hIHRvIHF1ZXJ5XG4gICAgICovXG4gICAgc2NoZW1hKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gbmV3IFBvc3RncmVzdENsaWVudCh0aGlzLnVybCwge1xuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2NoZW1hLFxuICAgICAgICAgICAgZmV0Y2g6IHRoaXMuZmV0Y2gsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGEgZnVuY3Rpb24gY2FsbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmbiAtIFRoZSBmdW5jdGlvbiBuYW1lIHRvIGNhbGxcbiAgICAgKiBAcGFyYW0gYXJncyAtIFRoZSBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgZnVuY3Rpb24gY2FsbFxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLmhlYWQgLSBXaGVuIHNldCB0byBgdHJ1ZWAsIGBkYXRhYCB3aWxsIG5vdCBiZSByZXR1cm5lZC5cbiAgICAgKiBVc2VmdWwgaWYgeW91IG9ubHkgbmVlZCB0aGUgY291bnQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZ2V0IC0gV2hlbiBzZXQgdG8gYHRydWVgLCB0aGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2l0aFxuICAgICAqIHJlYWQtb25seSBhY2Nlc3MgbW9kZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5jb3VudCAtIENvdW50IGFsZ29yaXRobSB0byB1c2UgdG8gY291bnQgcm93cyByZXR1cm5lZCBieSB0aGVcbiAgICAgKiBmdW5jdGlvbi4gT25seSBhcHBsaWNhYmxlIGZvciBbc2V0LXJldHVybmluZ1xuICAgICAqIGZ1bmN0aW9uc10oaHR0cHM6Ly93d3cucG9zdGdyZXNxbC5vcmcvZG9jcy9jdXJyZW50L2Z1bmN0aW9ucy1zcmYuaHRtbCkuXG4gICAgICpcbiAgICAgKiBgXCJleGFjdFwiYDogRXhhY3QgYnV0IHNsb3cgY291bnQgYWxnb3JpdGhtLiBQZXJmb3JtcyBhIGBDT1VOVCgqKWAgdW5kZXIgdGhlXG4gICAgICogaG9vZC5cbiAgICAgKlxuICAgICAqIGBcInBsYW5uZWRcImA6IEFwcHJveGltYXRlZCBidXQgZmFzdCBjb3VudCBhbGdvcml0aG0uIFVzZXMgdGhlIFBvc3RncmVzXG4gICAgICogc3RhdGlzdGljcyB1bmRlciB0aGUgaG9vZC5cbiAgICAgKlxuICAgICAqIGBcImVzdGltYXRlZFwiYDogVXNlcyBleGFjdCBjb3VudCBmb3IgbG93IG51bWJlcnMgYW5kIHBsYW5uZWQgY291bnQgZm9yIGhpZ2hcbiAgICAgKiBudW1iZXJzLlxuICAgICAqL1xuICAgIHJwYyhmbiwgYXJncyA9IHt9LCB7IGhlYWQgPSBmYWxzZSwgZ2V0ID0gZmFsc2UsIGNvdW50LCB9ID0ge30pIHtcbiAgICAgICAgbGV0IG1ldGhvZDtcbiAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChgJHt0aGlzLnVybH0vcnBjLyR7Zm59YCk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAoaGVhZCB8fCBnZXQpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9IGhlYWQgPyAnSEVBRCcgOiAnR0VUJztcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGFyZ3MpXG4gICAgICAgICAgICAgICAgLy8gcGFyYW1zIHdpdGggdW5kZWZpbmVkIHZhbHVlIG5lZWRzIHRvIGJlIGZpbHRlcmVkIG91dCwgb3RoZXJ3aXNlIGl0J2xsXG4gICAgICAgICAgICAgICAgLy8gc2hvdyB1cCBhcyBgP3BhcmFtPXVuZGVmaW5lZGBcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChbXywgdmFsdWVdKSA9PiB2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIC8vIGFycmF5IHZhbHVlcyBuZWVkIHNwZWNpYWwgc3ludGF4XG4gICAgICAgICAgICAgICAgLm1hcCgoW25hbWUsIHZhbHVlXSkgPT4gW25hbWUsIEFycmF5LmlzQXJyYXkodmFsdWUpID8gYHske3ZhbHVlLmpvaW4oJywnKX19YCA6IGAke3ZhbHVlfWBdKVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKChbbmFtZSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQobmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnUE9TVCc7XG4gICAgICAgICAgICBib2R5ID0gYXJncztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5oZWFkZXJzKTtcbiAgICAgICAgaWYgKGNvdW50KSB7XG4gICAgICAgICAgICBoZWFkZXJzWydQcmVmZXInXSA9IGBjb3VudD0ke2NvdW50fWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyXzEuZGVmYXVsdCh7XG4gICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgc2NoZW1hOiB0aGlzLnNjaGVtYU5hbWUsXG4gICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgZmV0Y2g6IHRoaXMuZmV0Y2gsXG4gICAgICAgICAgICBhbGxvd0VtcHR5OiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gUG9zdGdyZXN0Q2xpZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UG9zdGdyZXN0Q2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestClient.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestError.js":
/*!************************************************************************!*\
  !*** ./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestError.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * Error format\n *\n * {@link https://postgrest.org/en/stable/api.html?highlight=options#errors-and-http-status-codes}\n */\nclass PostgrestError extends Error {\n    constructor(context) {\n        super(context.message);\n        this.name = 'PostgrestError';\n        this.details = context.details;\n        this.hint = context.hint;\n        this.code = context.code;\n    }\n}\nexports[\"default\"] = PostgrestError;\n//# sourceMappingURL=PostgrestError.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL2Rpc3QvY2pzL1Bvc3RncmVzdEVycm9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL1dvbmRlclZpdGUtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMvZGlzdC9janMvUG9zdGdyZXN0RXJyb3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEVycm9yIGZvcm1hdFxuICpcbiAqIHtAbGluayBodHRwczovL3Bvc3RncmVzdC5vcmcvZW4vc3RhYmxlL2FwaS5odG1sP2hpZ2hsaWdodD1vcHRpb25zI2Vycm9ycy1hbmQtaHR0cC1zdGF0dXMtY29kZXN9XG4gKi9cbmNsYXNzIFBvc3RncmVzdEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIoY29udGV4dC5tZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1Bvc3RncmVzdEVycm9yJztcbiAgICAgICAgdGhpcy5kZXRhaWxzID0gY29udGV4dC5kZXRhaWxzO1xuICAgICAgICB0aGlzLmhpbnQgPSBjb250ZXh0LmhpbnQ7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvbnRleHQuY29kZTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBQb3N0Z3Jlc3RFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBvc3RncmVzdEVycm9yLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestError.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestFilterBuilder.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestFilterBuilder.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst PostgrestTransformBuilder_1 = __importDefault(__webpack_require__(/*! ./PostgrestTransformBuilder */ \"(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestTransformBuilder.js\"));\nclass PostgrestFilterBuilder extends PostgrestTransformBuilder_1.default {\n    /**\n     * Match only rows where `column` is equal to `value`.\n     *\n     * To check if the value of `column` is NULL, you should use `.is()` instead.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */\n    eq(column, value) {\n        this.url.searchParams.append(column, `eq.${value}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` is not equal to `value`.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */\n    neq(column, value) {\n        this.url.searchParams.append(column, `neq.${value}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` is greater than `value`.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */\n    gt(column, value) {\n        this.url.searchParams.append(column, `gt.${value}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` is greater than or equal to `value`.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */\n    gte(column, value) {\n        this.url.searchParams.append(column, `gte.${value}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` is less than `value`.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */\n    lt(column, value) {\n        this.url.searchParams.append(column, `lt.${value}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` is less than or equal to `value`.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */\n    lte(column, value) {\n        this.url.searchParams.append(column, `lte.${value}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` matches `pattern` case-sensitively.\n     *\n     * @param column - The column to filter on\n     * @param pattern - The pattern to match with\n     */\n    like(column, pattern) {\n        this.url.searchParams.append(column, `like.${pattern}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` matches all of `patterns` case-sensitively.\n     *\n     * @param column - The column to filter on\n     * @param patterns - The patterns to match with\n     */\n    likeAllOf(column, patterns) {\n        this.url.searchParams.append(column, `like(all).{${patterns.join(',')}}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` matches any of `patterns` case-sensitively.\n     *\n     * @param column - The column to filter on\n     * @param patterns - The patterns to match with\n     */\n    likeAnyOf(column, patterns) {\n        this.url.searchParams.append(column, `like(any).{${patterns.join(',')}}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` matches `pattern` case-insensitively.\n     *\n     * @param column - The column to filter on\n     * @param pattern - The pattern to match with\n     */\n    ilike(column, pattern) {\n        this.url.searchParams.append(column, `ilike.${pattern}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` matches all of `patterns` case-insensitively.\n     *\n     * @param column - The column to filter on\n     * @param patterns - The patterns to match with\n     */\n    ilikeAllOf(column, patterns) {\n        this.url.searchParams.append(column, `ilike(all).{${patterns.join(',')}}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` matches any of `patterns` case-insensitively.\n     *\n     * @param column - The column to filter on\n     * @param patterns - The patterns to match with\n     */\n    ilikeAnyOf(column, patterns) {\n        this.url.searchParams.append(column, `ilike(any).{${patterns.join(',')}}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` IS `value`.\n     *\n     * For non-boolean columns, this is only relevant for checking if the value of\n     * `column` is NULL by setting `value` to `null`.\n     *\n     * For boolean columns, you can also set `value` to `true` or `false` and it\n     * will behave the same way as `.eq()`.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */\n    is(column, value) {\n        this.url.searchParams.append(column, `is.${value}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` is included in the `values` array.\n     *\n     * @param column - The column to filter on\n     * @param values - The values array to filter with\n     */\n    in(column, values) {\n        const cleanedValues = Array.from(new Set(values))\n            .map((s) => {\n            // handle postgrest reserved characters\n            // https://postgrest.org/en/v7.0.0/api.html#reserved-characters\n            if (typeof s === 'string' && new RegExp('[,()]').test(s))\n                return `\"${s}\"`;\n            else\n                return `${s}`;\n        })\n            .join(',');\n        this.url.searchParams.append(column, `in.(${cleanedValues})`);\n        return this;\n    }\n    /**\n     * Only relevant for jsonb, array, and range columns. Match only rows where\n     * `column` contains every element appearing in `value`.\n     *\n     * @param column - The jsonb, array, or range column to filter on\n     * @param value - The jsonb, array, or range value to filter with\n     */\n    contains(column, value) {\n        if (typeof value === 'string') {\n            // range types can be inclusive '[', ']' or exclusive '(', ')' so just\n            // keep it simple and accept a string\n            this.url.searchParams.append(column, `cs.${value}`);\n        }\n        else if (Array.isArray(value)) {\n            // array\n            this.url.searchParams.append(column, `cs.{${value.join(',')}}`);\n        }\n        else {\n            // json\n            this.url.searchParams.append(column, `cs.${JSON.stringify(value)}`);\n        }\n        return this;\n    }\n    /**\n     * Only relevant for jsonb, array, and range columns. Match only rows where\n     * every element appearing in `column` is contained by `value`.\n     *\n     * @param column - The jsonb, array, or range column to filter on\n     * @param value - The jsonb, array, or range value to filter with\n     */\n    containedBy(column, value) {\n        if (typeof value === 'string') {\n            // range\n            this.url.searchParams.append(column, `cd.${value}`);\n        }\n        else if (Array.isArray(value)) {\n            // array\n            this.url.searchParams.append(column, `cd.{${value.join(',')}}`);\n        }\n        else {\n            // json\n            this.url.searchParams.append(column, `cd.${JSON.stringify(value)}`);\n        }\n        return this;\n    }\n    /**\n     * Only relevant for range columns. Match only rows where every element in\n     * `column` is greater than any element in `range`.\n     *\n     * @param column - The range column to filter on\n     * @param range - The range to filter with\n     */\n    rangeGt(column, range) {\n        this.url.searchParams.append(column, `sr.${range}`);\n        return this;\n    }\n    /**\n     * Only relevant for range columns. Match only rows where every element in\n     * `column` is either contained in `range` or greater than any element in\n     * `range`.\n     *\n     * @param column - The range column to filter on\n     * @param range - The range to filter with\n     */\n    rangeGte(column, range) {\n        this.url.searchParams.append(column, `nxl.${range}`);\n        return this;\n    }\n    /**\n     * Only relevant for range columns. Match only rows where every element in\n     * `column` is less than any element in `range`.\n     *\n     * @param column - The range column to filter on\n     * @param range - The range to filter with\n     */\n    rangeLt(column, range) {\n        this.url.searchParams.append(column, `sl.${range}`);\n        return this;\n    }\n    /**\n     * Only relevant for range columns. Match only rows where every element in\n     * `column` is either contained in `range` or less than any element in\n     * `range`.\n     *\n     * @param column - The range column to filter on\n     * @param range - The range to filter with\n     */\n    rangeLte(column, range) {\n        this.url.searchParams.append(column, `nxr.${range}`);\n        return this;\n    }\n    /**\n     * Only relevant for range columns. Match only rows where `column` is\n     * mutually exclusive to `range` and there can be no element between the two\n     * ranges.\n     *\n     * @param column - The range column to filter on\n     * @param range - The range to filter with\n     */\n    rangeAdjacent(column, range) {\n        this.url.searchParams.append(column, `adj.${range}`);\n        return this;\n    }\n    /**\n     * Only relevant for array and range columns. Match only rows where\n     * `column` and `value` have an element in common.\n     *\n     * @param column - The array or range column to filter on\n     * @param value - The array or range value to filter with\n     */\n    overlaps(column, value) {\n        if (typeof value === 'string') {\n            // range\n            this.url.searchParams.append(column, `ov.${value}`);\n        }\n        else {\n            // array\n            this.url.searchParams.append(column, `ov.{${value.join(',')}}`);\n        }\n        return this;\n    }\n    /**\n     * Only relevant for text and tsvector columns. Match only rows where\n     * `column` matches the query string in `query`.\n     *\n     * @param column - The text or tsvector column to filter on\n     * @param query - The query text to match with\n     * @param options - Named parameters\n     * @param options.config - The text search configuration to use\n     * @param options.type - Change how the `query` text is interpreted\n     */\n    textSearch(column, query, { config, type } = {}) {\n        let typePart = '';\n        if (type === 'plain') {\n            typePart = 'pl';\n        }\n        else if (type === 'phrase') {\n            typePart = 'ph';\n        }\n        else if (type === 'websearch') {\n            typePart = 'w';\n        }\n        const configPart = config === undefined ? '' : `(${config})`;\n        this.url.searchParams.append(column, `${typePart}fts${configPart}.${query}`);\n        return this;\n    }\n    /**\n     * Match only rows where each column in `query` keys is equal to its\n     * associated value. Shorthand for multiple `.eq()`s.\n     *\n     * @param query - The object to filter with, with column names as keys mapped\n     * to their filter values\n     */\n    match(query) {\n        Object.entries(query).forEach(([column, value]) => {\n            this.url.searchParams.append(column, `eq.${value}`);\n        });\n        return this;\n    }\n    /**\n     * Match only rows which doesn't satisfy the filter.\n     *\n     * Unlike most filters, `opearator` and `value` are used as-is and need to\n     * follow [PostgREST\n     * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n     * to make sure they are properly sanitized.\n     *\n     * @param column - The column to filter on\n     * @param operator - The operator to be negated to filter with, following\n     * PostgREST syntax\n     * @param value - The value to filter with, following PostgREST syntax\n     */\n    not(column, operator, value) {\n        this.url.searchParams.append(column, `not.${operator}.${value}`);\n        return this;\n    }\n    /**\n     * Match only rows which satisfy at least one of the filters.\n     *\n     * Unlike most filters, `filters` is used as-is and needs to follow [PostgREST\n     * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n     * to make sure it's properly sanitized.\n     *\n     * It's currently not possible to do an `.or()` filter across multiple tables.\n     *\n     * @param filters - The filters to use, following PostgREST syntax\n     * @param options - Named parameters\n     * @param options.referencedTable - Set this to filter on referenced tables\n     * instead of the parent table\n     * @param options.foreignTable - Deprecated, use `referencedTable` instead\n     */\n    or(filters, { foreignTable, referencedTable = foreignTable, } = {}) {\n        const key = referencedTable ? `${referencedTable}.or` : 'or';\n        this.url.searchParams.append(key, `(${filters})`);\n        return this;\n    }\n    /**\n     * Match only rows which satisfy the filter. This is an escape hatch - you\n     * should use the specific filter methods wherever possible.\n     *\n     * Unlike most filters, `opearator` and `value` are used as-is and need to\n     * follow [PostgREST\n     * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n     * to make sure they are properly sanitized.\n     *\n     * @param column - The column to filter on\n     * @param operator - The operator to filter with, following PostgREST syntax\n     * @param value - The value to filter with, following PostgREST syntax\n     */\n    filter(column, operator, value) {\n        this.url.searchParams.append(column, `${operator}.${value}`);\n        return this;\n    }\n}\nexports[\"default\"] = PostgrestFilterBuilder;\n//# sourceMappingURL=PostgrestFilterBuilder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL2Rpc3QvY2pzL1Bvc3RncmVzdEZpbHRlckJ1aWxkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvREFBb0QsbUJBQU8sQ0FBQyxvSUFBNkI7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsTUFBTTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsTUFBTTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsTUFBTTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsTUFBTTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsTUFBTTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsTUFBTTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsUUFBUTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsRUFBRSxvQkFBb0I7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELEVBQUUsb0JBQW9CO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxRQUFRO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxFQUFFLG9CQUFvQjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsRUFBRSxvQkFBb0I7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELE1BQU07QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixFQUFFO0FBQzdCO0FBQ0EsMEJBQTBCLEVBQUU7QUFDNUIsU0FBUztBQUNUO0FBQ0Esb0RBQW9ELGNBQWM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsTUFBTTtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsRUFBRSxpQkFBaUI7QUFDekU7QUFDQTtBQUNBO0FBQ0EsdURBQXVELHNCQUFzQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxNQUFNO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxFQUFFLGlCQUFpQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsc0JBQXNCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsTUFBTTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELE1BQU07QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsTUFBTTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELE1BQU07QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxNQUFNO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxNQUFNO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxFQUFFLGlCQUFpQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxlQUFlLElBQUk7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsT0FBTztBQUNsRSxnREFBZ0QsU0FBUyxLQUFLLFdBQVcsR0FBRyxNQUFNO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsTUFBTTtBQUM3RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsU0FBUyxHQUFHLE1BQU07QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnREFBZ0QsSUFBSTtBQUN0RSx5Q0FBeUMsZ0JBQWdCO0FBQ3pELDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFNBQVMsR0FBRyxNQUFNO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL1dvbmRlclZpdGUtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMvZGlzdC9janMvUG9zdGdyZXN0RmlsdGVyQnVpbGRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFBvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9Qb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyXCIpKTtcbmNsYXNzIFBvc3RncmVzdEZpbHRlckJ1aWxkZXIgZXh0ZW5kcyBQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyXzEuZGVmYXVsdCB7XG4gICAgLyoqXG4gICAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIGlzIGVxdWFsIHRvIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBUbyBjaGVjayBpZiB0aGUgdmFsdWUgb2YgYGNvbHVtbmAgaXMgTlVMTCwgeW91IHNob3VsZCB1c2UgYC5pcygpYCBpbnN0ZWFkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG4gICAgICovXG4gICAgZXEoY29sdW1uLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGVxLiR7dmFsdWV9YCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgaXMgbm90IGVxdWFsIHRvIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsdGVyIHdpdGhcbiAgICAgKi9cbiAgICBuZXEoY29sdW1uLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYG5lcS4ke3ZhbHVlfWApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIGlzIGdyZWF0ZXIgdGhhbiBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG4gICAgICovXG4gICAgZ3QoY29sdW1uLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGd0LiR7dmFsdWV9YCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsdGVyIHdpdGhcbiAgICAgKi9cbiAgICBndGUoY29sdW1uLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGd0ZS4ke3ZhbHVlfWApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIGlzIGxlc3MgdGhhbiBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG4gICAgICovXG4gICAgbHQoY29sdW1uLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGx0LiR7dmFsdWV9YCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsdGVyIHdpdGhcbiAgICAgKi9cbiAgICBsdGUoY29sdW1uLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGx0ZS4ke3ZhbHVlfWApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIG1hdGNoZXMgYHBhdHRlcm5gIGNhc2Utc2Vuc2l0aXZlbHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICAgKiBAcGFyYW0gcGF0dGVybiAtIFRoZSBwYXR0ZXJuIHRvIG1hdGNoIHdpdGhcbiAgICAgKi9cbiAgICBsaWtlKGNvbHVtbiwgcGF0dGVybikge1xuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGxpa2UuJHtwYXR0ZXJufWApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIG1hdGNoZXMgYWxsIG9mIGBwYXR0ZXJuc2AgY2FzZS1zZW5zaXRpdmVseS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuICAgICAqIEBwYXJhbSBwYXR0ZXJucyAtIFRoZSBwYXR0ZXJucyB0byBtYXRjaCB3aXRoXG4gICAgICovXG4gICAgbGlrZUFsbE9mKGNvbHVtbiwgcGF0dGVybnMpIHtcbiAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBsaWtlKGFsbCkueyR7cGF0dGVybnMuam9pbignLCcpfX1gKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBtYXRjaGVzIGFueSBvZiBgcGF0dGVybnNgIGNhc2Utc2Vuc2l0aXZlbHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICAgKiBAcGFyYW0gcGF0dGVybnMgLSBUaGUgcGF0dGVybnMgdG8gbWF0Y2ggd2l0aFxuICAgICAqL1xuICAgIGxpa2VBbnlPZihjb2x1bW4sIHBhdHRlcm5zKSB7XG4gICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgbGlrZShhbnkpLnske3BhdHRlcm5zLmpvaW4oJywnKX19YCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgbWF0Y2hlcyBgcGF0dGVybmAgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAgICogQHBhcmFtIHBhdHRlcm4gLSBUaGUgcGF0dGVybiB0byBtYXRjaCB3aXRoXG4gICAgICovXG4gICAgaWxpa2UoY29sdW1uLCBwYXR0ZXJuKSB7XG4gICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgaWxpa2UuJHtwYXR0ZXJufWApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIG1hdGNoZXMgYWxsIG9mIGBwYXR0ZXJuc2AgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAgICogQHBhcmFtIHBhdHRlcm5zIC0gVGhlIHBhdHRlcm5zIHRvIG1hdGNoIHdpdGhcbiAgICAgKi9cbiAgICBpbGlrZUFsbE9mKGNvbHVtbiwgcGF0dGVybnMpIHtcbiAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBpbGlrZShhbGwpLnske3BhdHRlcm5zLmpvaW4oJywnKX19YCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgbWF0Y2hlcyBhbnkgb2YgYHBhdHRlcm5zYCBjYXNlLWluc2Vuc2l0aXZlbHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICAgKiBAcGFyYW0gcGF0dGVybnMgLSBUaGUgcGF0dGVybnMgdG8gbWF0Y2ggd2l0aFxuICAgICAqL1xuICAgIGlsaWtlQW55T2YoY29sdW1uLCBwYXR0ZXJucykge1xuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGlsaWtlKGFueSkueyR7cGF0dGVybnMuam9pbignLCcpfX1gKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBJUyBgdmFsdWVgLlxuICAgICAqXG4gICAgICogRm9yIG5vbi1ib29sZWFuIGNvbHVtbnMsIHRoaXMgaXMgb25seSByZWxldmFudCBmb3IgY2hlY2tpbmcgaWYgdGhlIHZhbHVlIG9mXG4gICAgICogYGNvbHVtbmAgaXMgTlVMTCBieSBzZXR0aW5nIGB2YWx1ZWAgdG8gYG51bGxgLlxuICAgICAqXG4gICAgICogRm9yIGJvb2xlYW4gY29sdW1ucywgeW91IGNhbiBhbHNvIHNldCBgdmFsdWVgIHRvIGB0cnVlYCBvciBgZmFsc2VgIGFuZCBpdFxuICAgICAqIHdpbGwgYmVoYXZlIHRoZSBzYW1lIHdheSBhcyBgLmVxKClgLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG4gICAgICovXG4gICAgaXMoY29sdW1uLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGlzLiR7dmFsdWV9YCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgaXMgaW5jbHVkZWQgaW4gdGhlIGB2YWx1ZXNgIGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAgICogQHBhcmFtIHZhbHVlcyAtIFRoZSB2YWx1ZXMgYXJyYXkgdG8gZmlsdGVyIHdpdGhcbiAgICAgKi9cbiAgICBpbihjb2x1bW4sIHZhbHVlcykge1xuICAgICAgICBjb25zdCBjbGVhbmVkVmFsdWVzID0gQXJyYXkuZnJvbShuZXcgU2V0KHZhbHVlcykpXG4gICAgICAgICAgICAubWFwKChzKSA9PiB7XG4gICAgICAgICAgICAvLyBoYW5kbGUgcG9zdGdyZXN0IHJlc2VydmVkIGNoYXJhY3RlcnNcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vcG9zdGdyZXN0Lm9yZy9lbi92Ny4wLjAvYXBpLmh0bWwjcmVzZXJ2ZWQtY2hhcmFjdGVyc1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzID09PSAnc3RyaW5nJyAmJiBuZXcgUmVnRXhwKCdbLCgpXScpLnRlc3QocykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGBcIiR7c31cImA7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke3N9YDtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKCcsJyk7XG4gICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgaW4uKCR7Y2xlYW5lZFZhbHVlc30pYCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPbmx5IHJlbGV2YW50IGZvciBqc29uYiwgYXJyYXksIGFuZCByYW5nZSBjb2x1bW5zLiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmVcbiAgICAgKiBgY29sdW1uYCBjb250YWlucyBldmVyeSBlbGVtZW50IGFwcGVhcmluZyBpbiBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBqc29uYiwgYXJyYXksIG9yIHJhbmdlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUganNvbmIsIGFycmF5LCBvciByYW5nZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aFxuICAgICAqL1xuICAgIGNvbnRhaW5zKGNvbHVtbiwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIHJhbmdlIHR5cGVzIGNhbiBiZSBpbmNsdXNpdmUgJ1snLCAnXScgb3IgZXhjbHVzaXZlICcoJywgJyknIHNvIGp1c3RcbiAgICAgICAgICAgIC8vIGtlZXAgaXQgc2ltcGxlIGFuZCBhY2NlcHQgYSBzdHJpbmdcbiAgICAgICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgY3MuJHt2YWx1ZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgLy8gYXJyYXlcbiAgICAgICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgY3MueyR7dmFsdWUuam9pbignLCcpfX1gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGpzb25cbiAgICAgICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgY3MuJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9ubHkgcmVsZXZhbnQgZm9yIGpzb25iLCBhcnJheSwgYW5kIHJhbmdlIGNvbHVtbnMuIE1hdGNoIG9ubHkgcm93cyB3aGVyZVxuICAgICAqIGV2ZXJ5IGVsZW1lbnQgYXBwZWFyaW5nIGluIGBjb2x1bW5gIGlzIGNvbnRhaW5lZCBieSBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBqc29uYiwgYXJyYXksIG9yIHJhbmdlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUganNvbmIsIGFycmF5LCBvciByYW5nZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aFxuICAgICAqL1xuICAgIGNvbnRhaW5lZEJ5KGNvbHVtbiwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIHJhbmdlXG4gICAgICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGNkLiR7dmFsdWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIC8vIGFycmF5XG4gICAgICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGNkLnske3ZhbHVlLmpvaW4oJywnKX19YCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBqc29uXG4gICAgICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGNkLiR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPbmx5IHJlbGV2YW50IGZvciByYW5nZSBjb2x1bW5zLiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgZXZlcnkgZWxlbWVudCBpblxuICAgICAqIGBjb2x1bW5gIGlzIGdyZWF0ZXIgdGhhbiBhbnkgZWxlbWVudCBpbiBgcmFuZ2VgLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSByYW5nZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAgICogQHBhcmFtIHJhbmdlIC0gVGhlIHJhbmdlIHRvIGZpbHRlciB3aXRoXG4gICAgICovXG4gICAgcmFuZ2VHdChjb2x1bW4sIHJhbmdlKSB7XG4gICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgc3IuJHtyYW5nZX1gKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9ubHkgcmVsZXZhbnQgZm9yIHJhbmdlIGNvbHVtbnMuIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBldmVyeSBlbGVtZW50IGluXG4gICAgICogYGNvbHVtbmAgaXMgZWl0aGVyIGNvbnRhaW5lZCBpbiBgcmFuZ2VgIG9yIGdyZWF0ZXIgdGhhbiBhbnkgZWxlbWVudCBpblxuICAgICAqIGByYW5nZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIHJhbmdlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICAgKiBAcGFyYW0gcmFuZ2UgLSBUaGUgcmFuZ2UgdG8gZmlsdGVyIHdpdGhcbiAgICAgKi9cbiAgICByYW5nZUd0ZShjb2x1bW4sIHJhbmdlKSB7XG4gICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgbnhsLiR7cmFuZ2V9YCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPbmx5IHJlbGV2YW50IGZvciByYW5nZSBjb2x1bW5zLiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgZXZlcnkgZWxlbWVudCBpblxuICAgICAqIGBjb2x1bW5gIGlzIGxlc3MgdGhhbiBhbnkgZWxlbWVudCBpbiBgcmFuZ2VgLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSByYW5nZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAgICogQHBhcmFtIHJhbmdlIC0gVGhlIHJhbmdlIHRvIGZpbHRlciB3aXRoXG4gICAgICovXG4gICAgcmFuZ2VMdChjb2x1bW4sIHJhbmdlKSB7XG4gICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgc2wuJHtyYW5nZX1gKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9ubHkgcmVsZXZhbnQgZm9yIHJhbmdlIGNvbHVtbnMuIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBldmVyeSBlbGVtZW50IGluXG4gICAgICogYGNvbHVtbmAgaXMgZWl0aGVyIGNvbnRhaW5lZCBpbiBgcmFuZ2VgIG9yIGxlc3MgdGhhbiBhbnkgZWxlbWVudCBpblxuICAgICAqIGByYW5nZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIHJhbmdlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICAgKiBAcGFyYW0gcmFuZ2UgLSBUaGUgcmFuZ2UgdG8gZmlsdGVyIHdpdGhcbiAgICAgKi9cbiAgICByYW5nZUx0ZShjb2x1bW4sIHJhbmdlKSB7XG4gICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgbnhyLiR7cmFuZ2V9YCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPbmx5IHJlbGV2YW50IGZvciByYW5nZSBjb2x1bW5zLiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgaXNcbiAgICAgKiBtdXR1YWxseSBleGNsdXNpdmUgdG8gYHJhbmdlYCBhbmQgdGhlcmUgY2FuIGJlIG5vIGVsZW1lbnQgYmV0d2VlbiB0aGUgdHdvXG4gICAgICogcmFuZ2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSByYW5nZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAgICogQHBhcmFtIHJhbmdlIC0gVGhlIHJhbmdlIHRvIGZpbHRlciB3aXRoXG4gICAgICovXG4gICAgcmFuZ2VBZGphY2VudChjb2x1bW4sIHJhbmdlKSB7XG4gICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgYWRqLiR7cmFuZ2V9YCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPbmx5IHJlbGV2YW50IGZvciBhcnJheSBhbmQgcmFuZ2UgY29sdW1ucy4gTWF0Y2ggb25seSByb3dzIHdoZXJlXG4gICAgICogYGNvbHVtbmAgYW5kIGB2YWx1ZWAgaGF2ZSBhbiBlbGVtZW50IGluIGNvbW1vbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgYXJyYXkgb3IgcmFuZ2UgY29sdW1uIHRvIGZpbHRlciBvblxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBhcnJheSBvciByYW5nZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aFxuICAgICAqL1xuICAgIG92ZXJsYXBzKGNvbHVtbiwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIHJhbmdlXG4gICAgICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYG92LiR7dmFsdWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBhcnJheVxuICAgICAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBvdi57JHt2YWx1ZS5qb2luKCcsJyl9fWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPbmx5IHJlbGV2YW50IGZvciB0ZXh0IGFuZCB0c3ZlY3RvciBjb2x1bW5zLiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmVcbiAgICAgKiBgY29sdW1uYCBtYXRjaGVzIHRoZSBxdWVyeSBzdHJpbmcgaW4gYHF1ZXJ5YC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgdGV4dCBvciB0c3ZlY3RvciBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAgICogQHBhcmFtIHF1ZXJ5IC0gVGhlIHF1ZXJ5IHRleHQgdG8gbWF0Y2ggd2l0aFxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLmNvbmZpZyAtIFRoZSB0ZXh0IHNlYXJjaCBjb25maWd1cmF0aW9uIHRvIHVzZVxuICAgICAqIEBwYXJhbSBvcHRpb25zLnR5cGUgLSBDaGFuZ2UgaG93IHRoZSBgcXVlcnlgIHRleHQgaXMgaW50ZXJwcmV0ZWRcbiAgICAgKi9cbiAgICB0ZXh0U2VhcmNoKGNvbHVtbiwgcXVlcnksIHsgY29uZmlnLCB0eXBlIH0gPSB7fSkge1xuICAgICAgICBsZXQgdHlwZVBhcnQgPSAnJztcbiAgICAgICAgaWYgKHR5cGUgPT09ICdwbGFpbicpIHtcbiAgICAgICAgICAgIHR5cGVQYXJ0ID0gJ3BsJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSAncGhyYXNlJykge1xuICAgICAgICAgICAgdHlwZVBhcnQgPSAncGgnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICd3ZWJzZWFyY2gnKSB7XG4gICAgICAgICAgICB0eXBlUGFydCA9ICd3JztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb25maWdQYXJ0ID0gY29uZmlnID09PSB1bmRlZmluZWQgPyAnJyA6IGAoJHtjb25maWd9KWA7XG4gICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgJHt0eXBlUGFydH1mdHMke2NvbmZpZ1BhcnR9LiR7cXVlcnl9YCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgZWFjaCBjb2x1bW4gaW4gYHF1ZXJ5YCBrZXlzIGlzIGVxdWFsIHRvIGl0c1xuICAgICAqIGFzc29jaWF0ZWQgdmFsdWUuIFNob3J0aGFuZCBmb3IgbXVsdGlwbGUgYC5lcSgpYHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcXVlcnkgLSBUaGUgb2JqZWN0IHRvIGZpbHRlciB3aXRoLCB3aXRoIGNvbHVtbiBuYW1lcyBhcyBrZXlzIG1hcHBlZFxuICAgICAqIHRvIHRoZWlyIGZpbHRlciB2YWx1ZXNcbiAgICAgKi9cbiAgICBtYXRjaChxdWVyeSkge1xuICAgICAgICBPYmplY3QuZW50cmllcyhxdWVyeSkuZm9yRWFjaCgoW2NvbHVtbiwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGVxLiR7dmFsdWV9YCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWF0Y2ggb25seSByb3dzIHdoaWNoIGRvZXNuJ3Qgc2F0aXNmeSB0aGUgZmlsdGVyLlxuICAgICAqXG4gICAgICogVW5saWtlIG1vc3QgZmlsdGVycywgYG9wZWFyYXRvcmAgYW5kIGB2YWx1ZWAgYXJlIHVzZWQgYXMtaXMgYW5kIG5lZWQgdG9cbiAgICAgKiBmb2xsb3cgW1Bvc3RnUkVTVFxuICAgICAqIHN5bnRheF0oaHR0cHM6Ly9wb3N0Z3Jlc3Qub3JnL2VuL3N0YWJsZS9hcGkuaHRtbCNvcGVyYXRvcnMpLiBZb3UgYWxzbyBuZWVkXG4gICAgICogdG8gbWFrZSBzdXJlIHRoZXkgYXJlIHByb3Blcmx5IHNhbml0aXplZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuICAgICAqIEBwYXJhbSBvcGVyYXRvciAtIFRoZSBvcGVyYXRvciB0byBiZSBuZWdhdGVkIHRvIGZpbHRlciB3aXRoLCBmb2xsb3dpbmdcbiAgICAgKiBQb3N0Z1JFU1Qgc3ludGF4XG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoLCBmb2xsb3dpbmcgUG9zdGdSRVNUIHN5bnRheFxuICAgICAqL1xuICAgIG5vdChjb2x1bW4sIG9wZXJhdG9yLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYG5vdC4ke29wZXJhdG9yfS4ke3ZhbHVlfWApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWF0Y2ggb25seSByb3dzIHdoaWNoIHNhdGlzZnkgYXQgbGVhc3Qgb25lIG9mIHRoZSBmaWx0ZXJzLlxuICAgICAqXG4gICAgICogVW5saWtlIG1vc3QgZmlsdGVycywgYGZpbHRlcnNgIGlzIHVzZWQgYXMtaXMgYW5kIG5lZWRzIHRvIGZvbGxvdyBbUG9zdGdSRVNUXG4gICAgICogc3ludGF4XShodHRwczovL3Bvc3RncmVzdC5vcmcvZW4vc3RhYmxlL2FwaS5odG1sI29wZXJhdG9ycykuIFlvdSBhbHNvIG5lZWRcbiAgICAgKiB0byBtYWtlIHN1cmUgaXQncyBwcm9wZXJseSBzYW5pdGl6ZWQuXG4gICAgICpcbiAgICAgKiBJdCdzIGN1cnJlbnRseSBub3QgcG9zc2libGUgdG8gZG8gYW4gYC5vcigpYCBmaWx0ZXIgYWNyb3NzIG11bHRpcGxlIHRhYmxlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWx0ZXJzIC0gVGhlIGZpbHRlcnMgdG8gdXNlLCBmb2xsb3dpbmcgUG9zdGdSRVNUIHN5bnRheFxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLnJlZmVyZW5jZWRUYWJsZSAtIFNldCB0aGlzIHRvIGZpbHRlciBvbiByZWZlcmVuY2VkIHRhYmxlc1xuICAgICAqIGluc3RlYWQgb2YgdGhlIHBhcmVudCB0YWJsZVxuICAgICAqIEBwYXJhbSBvcHRpb25zLmZvcmVpZ25UYWJsZSAtIERlcHJlY2F0ZWQsIHVzZSBgcmVmZXJlbmNlZFRhYmxlYCBpbnN0ZWFkXG4gICAgICovXG4gICAgb3IoZmlsdGVycywgeyBmb3JlaWduVGFibGUsIHJlZmVyZW5jZWRUYWJsZSA9IGZvcmVpZ25UYWJsZSwgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHJlZmVyZW5jZWRUYWJsZSA/IGAke3JlZmVyZW5jZWRUYWJsZX0ub3JgIDogJ29yJztcbiAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIGAoJHtmaWx0ZXJzfSlgKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hdGNoIG9ubHkgcm93cyB3aGljaCBzYXRpc2Z5IHRoZSBmaWx0ZXIuIFRoaXMgaXMgYW4gZXNjYXBlIGhhdGNoIC0geW91XG4gICAgICogc2hvdWxkIHVzZSB0aGUgc3BlY2lmaWMgZmlsdGVyIG1ldGhvZHMgd2hlcmV2ZXIgcG9zc2libGUuXG4gICAgICpcbiAgICAgKiBVbmxpa2UgbW9zdCBmaWx0ZXJzLCBgb3BlYXJhdG9yYCBhbmQgYHZhbHVlYCBhcmUgdXNlZCBhcy1pcyBhbmQgbmVlZCB0b1xuICAgICAqIGZvbGxvdyBbUG9zdGdSRVNUXG4gICAgICogc3ludGF4XShodHRwczovL3Bvc3RncmVzdC5vcmcvZW4vc3RhYmxlL2FwaS5odG1sI29wZXJhdG9ycykuIFlvdSBhbHNvIG5lZWRcbiAgICAgKiB0byBtYWtlIHN1cmUgdGhleSBhcmUgcHJvcGVybHkgc2FuaXRpemVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAgICogQHBhcmFtIG9wZXJhdG9yIC0gVGhlIG9wZXJhdG9yIHRvIGZpbHRlciB3aXRoLCBmb2xsb3dpbmcgUG9zdGdSRVNUIHN5bnRheFxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aCwgZm9sbG93aW5nIFBvc3RnUkVTVCBzeW50YXhcbiAgICAgKi9cbiAgICBmaWx0ZXIoY29sdW1uLCBvcGVyYXRvciwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGAke29wZXJhdG9yfS4ke3ZhbHVlfWApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UG9zdGdyZXN0RmlsdGVyQnVpbGRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestFilterBuilder.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestQueryBuilder.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestQueryBuilder.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst PostgrestFilterBuilder_1 = __importDefault(__webpack_require__(/*! ./PostgrestFilterBuilder */ \"(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestFilterBuilder.js\"));\nclass PostgrestQueryBuilder {\n    constructor(url, { headers = {}, schema, fetch, }) {\n        this.url = url;\n        this.headers = headers;\n        this.schema = schema;\n        this.fetch = fetch;\n    }\n    /**\n     * Perform a SELECT query on the table or view.\n     *\n     * @param columns - The columns to retrieve, separated by commas. Columns can be renamed when returned with `customName:columnName`\n     *\n     * @param options - Named parameters\n     *\n     * @param options.head - When set to `true`, `data` will not be returned.\n     * Useful if you only need the count.\n     *\n     * @param options.count - Count algorithm to use to count rows in the table or view.\n     *\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n     * hood.\n     *\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n     * statistics under the hood.\n     *\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n     * numbers.\n     */\n    select(columns, { head = false, count, } = {}) {\n        const method = head ? 'HEAD' : 'GET';\n        // Remove whitespaces except when quoted\n        let quoted = false;\n        const cleanedColumns = (columns !== null && columns !== void 0 ? columns : '*')\n            .split('')\n            .map((c) => {\n            if (/\\s/.test(c) && !quoted) {\n                return '';\n            }\n            if (c === '\"') {\n                quoted = !quoted;\n            }\n            return c;\n        })\n            .join('');\n        this.url.searchParams.set('select', cleanedColumns);\n        if (count) {\n            this.headers['Prefer'] = `count=${count}`;\n        }\n        return new PostgrestFilterBuilder_1.default({\n            method,\n            url: this.url,\n            headers: this.headers,\n            schema: this.schema,\n            fetch: this.fetch,\n            allowEmpty: false,\n        });\n    }\n    /**\n     * Perform an INSERT into the table or view.\n     *\n     * By default, inserted rows are not returned. To return it, chain the call\n     * with `.select()`.\n     *\n     * @param values - The values to insert. Pass an object to insert a single row\n     * or an array to insert multiple rows.\n     *\n     * @param options - Named parameters\n     *\n     * @param options.count - Count algorithm to use to count inserted rows.\n     *\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n     * hood.\n     *\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n     * statistics under the hood.\n     *\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n     * numbers.\n     *\n     * @param options.defaultToNull - Make missing fields default to `null`.\n     * Otherwise, use the default value for the column. Only applies for bulk\n     * inserts.\n     */\n    insert(values, { count, defaultToNull = true, } = {}) {\n        const method = 'POST';\n        const prefersHeaders = [];\n        if (this.headers['Prefer']) {\n            prefersHeaders.push(this.headers['Prefer']);\n        }\n        if (count) {\n            prefersHeaders.push(`count=${count}`);\n        }\n        if (!defaultToNull) {\n            prefersHeaders.push('missing=default');\n        }\n        this.headers['Prefer'] = prefersHeaders.join(',');\n        if (Array.isArray(values)) {\n            const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), []);\n            if (columns.length > 0) {\n                const uniqueColumns = [...new Set(columns)].map((column) => `\"${column}\"`);\n                this.url.searchParams.set('columns', uniqueColumns.join(','));\n            }\n        }\n        return new PostgrestFilterBuilder_1.default({\n            method,\n            url: this.url,\n            headers: this.headers,\n            schema: this.schema,\n            body: values,\n            fetch: this.fetch,\n            allowEmpty: false,\n        });\n    }\n    /**\n     * Perform an UPSERT on the table or view. Depending on the column(s) passed\n     * to `onConflict`, `.upsert()` allows you to perform the equivalent of\n     * `.insert()` if a row with the corresponding `onConflict` columns doesn't\n     * exist, or if it does exist, perform an alternative action depending on\n     * `ignoreDuplicates`.\n     *\n     * By default, upserted rows are not returned. To return it, chain the call\n     * with `.select()`.\n     *\n     * @param values - The values to upsert with. Pass an object to upsert a\n     * single row or an array to upsert multiple rows.\n     *\n     * @param options - Named parameters\n     *\n     * @param options.onConflict - Comma-separated UNIQUE column(s) to specify how\n     * duplicate rows are determined. Two rows are duplicates if all the\n     * `onConflict` columns are equal.\n     *\n     * @param options.ignoreDuplicates - If `true`, duplicate rows are ignored. If\n     * `false`, duplicate rows are merged with existing rows.\n     *\n     * @param options.count - Count algorithm to use to count upserted rows.\n     *\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n     * hood.\n     *\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n     * statistics under the hood.\n     *\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n     * numbers.\n     *\n     * @param options.defaultToNull - Make missing fields default to `null`.\n     * Otherwise, use the default value for the column. This only applies when\n     * inserting new rows, not when merging with existing rows under\n     * `ignoreDuplicates: false`. This also only applies when doing bulk upserts.\n     */\n    upsert(values, { onConflict, ignoreDuplicates = false, count, defaultToNull = true, } = {}) {\n        const method = 'POST';\n        const prefersHeaders = [`resolution=${ignoreDuplicates ? 'ignore' : 'merge'}-duplicates`];\n        if (onConflict !== undefined)\n            this.url.searchParams.set('on_conflict', onConflict);\n        if (this.headers['Prefer']) {\n            prefersHeaders.push(this.headers['Prefer']);\n        }\n        if (count) {\n            prefersHeaders.push(`count=${count}`);\n        }\n        if (!defaultToNull) {\n            prefersHeaders.push('missing=default');\n        }\n        this.headers['Prefer'] = prefersHeaders.join(',');\n        if (Array.isArray(values)) {\n            const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), []);\n            if (columns.length > 0) {\n                const uniqueColumns = [...new Set(columns)].map((column) => `\"${column}\"`);\n                this.url.searchParams.set('columns', uniqueColumns.join(','));\n            }\n        }\n        return new PostgrestFilterBuilder_1.default({\n            method,\n            url: this.url,\n            headers: this.headers,\n            schema: this.schema,\n            body: values,\n            fetch: this.fetch,\n            allowEmpty: false,\n        });\n    }\n    /**\n     * Perform an UPDATE on the table or view.\n     *\n     * By default, updated rows are not returned. To return it, chain the call\n     * with `.select()` after filters.\n     *\n     * @param values - The values to update with\n     *\n     * @param options - Named parameters\n     *\n     * @param options.count - Count algorithm to use to count updated rows.\n     *\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n     * hood.\n     *\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n     * statistics under the hood.\n     *\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n     * numbers.\n     */\n    update(values, { count, } = {}) {\n        const method = 'PATCH';\n        const prefersHeaders = [];\n        if (this.headers['Prefer']) {\n            prefersHeaders.push(this.headers['Prefer']);\n        }\n        if (count) {\n            prefersHeaders.push(`count=${count}`);\n        }\n        this.headers['Prefer'] = prefersHeaders.join(',');\n        return new PostgrestFilterBuilder_1.default({\n            method,\n            url: this.url,\n            headers: this.headers,\n            schema: this.schema,\n            body: values,\n            fetch: this.fetch,\n            allowEmpty: false,\n        });\n    }\n    /**\n     * Perform a DELETE on the table or view.\n     *\n     * By default, deleted rows are not returned. To return it, chain the call\n     * with `.select()` after filters.\n     *\n     * @param options - Named parameters\n     *\n     * @param options.count - Count algorithm to use to count deleted rows.\n     *\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n     * hood.\n     *\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n     * statistics under the hood.\n     *\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n     * numbers.\n     */\n    delete({ count, } = {}) {\n        const method = 'DELETE';\n        const prefersHeaders = [];\n        if (count) {\n            prefersHeaders.push(`count=${count}`);\n        }\n        if (this.headers['Prefer']) {\n            prefersHeaders.unshift(this.headers['Prefer']);\n        }\n        this.headers['Prefer'] = prefersHeaders.join(',');\n        return new PostgrestFilterBuilder_1.default({\n            method,\n            url: this.url,\n            headers: this.headers,\n            schema: this.schema,\n            fetch: this.fetch,\n            allowEmpty: false,\n        });\n    }\n}\nexports[\"default\"] = PostgrestQueryBuilder;\n//# sourceMappingURL=PostgrestQueryBuilder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL2Rpc3QvY2pzL1Bvc3RncmVzdFF1ZXJ5QnVpbGRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlEQUFpRCxtQkFBTyxDQUFDLDhIQUEwQjtBQUNuRjtBQUNBLHVCQUF1QixZQUFZLGtCQUFrQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVCQUF1QixJQUFJO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxNQUFNO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLCtCQUErQixJQUFJO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxNQUFNO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsT0FBTztBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixxRUFBcUUsSUFBSTtBQUM5RjtBQUNBLDhDQUE4QyxzQ0FBc0M7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE1BQU07QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixPQUFPO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUyxJQUFJO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxNQUFNO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVMsSUFBSTtBQUMxQjtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsTUFBTTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL1dvbmRlclZpdGUtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMvZGlzdC9janMvUG9zdGdyZXN0UXVlcnlCdWlsZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgUG9zdGdyZXN0RmlsdGVyQnVpbGRlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1Bvc3RncmVzdEZpbHRlckJ1aWxkZXJcIikpO1xuY2xhc3MgUG9zdGdyZXN0UXVlcnlCdWlsZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih1cmwsIHsgaGVhZGVycyA9IHt9LCBzY2hlbWEsIGZldGNoLCB9KSB7XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgICAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICAgICAgdGhpcy5mZXRjaCA9IGZldGNoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGEgU0VMRUNUIHF1ZXJ5IG9uIHRoZSB0YWJsZSBvciB2aWV3LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbnMgLSBUaGUgY29sdW1ucyB0byByZXRyaWV2ZSwgc2VwYXJhdGVkIGJ5IGNvbW1hcy4gQ29sdW1ucyBjYW4gYmUgcmVuYW1lZCB3aGVuIHJldHVybmVkIHdpdGggYGN1c3RvbU5hbWU6Y29sdW1uTmFtZWBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMuaGVhZCAtIFdoZW4gc2V0IHRvIGB0cnVlYCwgYGRhdGFgIHdpbGwgbm90IGJlIHJldHVybmVkLlxuICAgICAqIFVzZWZ1bCBpZiB5b3Ugb25seSBuZWVkIHRoZSBjb3VudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmNvdW50IC0gQ291bnQgYWxnb3JpdGhtIHRvIHVzZSB0byBjb3VudCByb3dzIGluIHRoZSB0YWJsZSBvciB2aWV3LlxuICAgICAqXG4gICAgICogYFwiZXhhY3RcImA6IEV4YWN0IGJ1dCBzbG93IGNvdW50IGFsZ29yaXRobS4gUGVyZm9ybXMgYSBgQ09VTlQoKilgIHVuZGVyIHRoZVxuICAgICAqIGhvb2QuXG4gICAgICpcbiAgICAgKiBgXCJwbGFubmVkXCJgOiBBcHByb3hpbWF0ZWQgYnV0IGZhc3QgY291bnQgYWxnb3JpdGhtLiBVc2VzIHRoZSBQb3N0Z3Jlc1xuICAgICAqIHN0YXRpc3RpY3MgdW5kZXIgdGhlIGhvb2QuXG4gICAgICpcbiAgICAgKiBgXCJlc3RpbWF0ZWRcImA6IFVzZXMgZXhhY3QgY291bnQgZm9yIGxvdyBudW1iZXJzIGFuZCBwbGFubmVkIGNvdW50IGZvciBoaWdoXG4gICAgICogbnVtYmVycy5cbiAgICAgKi9cbiAgICBzZWxlY3QoY29sdW1ucywgeyBoZWFkID0gZmFsc2UsIGNvdW50LCB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgbWV0aG9kID0gaGVhZCA/ICdIRUFEJyA6ICdHRVQnO1xuICAgICAgICAvLyBSZW1vdmUgd2hpdGVzcGFjZXMgZXhjZXB0IHdoZW4gcXVvdGVkXG4gICAgICAgIGxldCBxdW90ZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgY2xlYW5lZENvbHVtbnMgPSAoY29sdW1ucyAhPT0gbnVsbCAmJiBjb2x1bW5zICE9PSB2b2lkIDAgPyBjb2x1bW5zIDogJyonKVxuICAgICAgICAgICAgLnNwbGl0KCcnKVxuICAgICAgICAgICAgLm1hcCgoYykgPT4ge1xuICAgICAgICAgICAgaWYgKC9cXHMvLnRlc3QoYykgJiYgIXF1b3RlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjID09PSAnXCInKSB7XG4gICAgICAgICAgICAgICAgcXVvdGVkID0gIXF1b3RlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oJycpO1xuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuc2V0KCdzZWxlY3QnLCBjbGVhbmVkQ29sdW1ucyk7XG4gICAgICAgIGlmIChjb3VudCkge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzWydQcmVmZXInXSA9IGBjb3VudD0ke2NvdW50fWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyXzEuZGVmYXVsdCh7XG4gICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICB1cmw6IHRoaXMudXJsLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2NoZW1hOiB0aGlzLnNjaGVtYSxcbiAgICAgICAgICAgIGZldGNoOiB0aGlzLmZldGNoLFxuICAgICAgICAgICAgYWxsb3dFbXB0eTogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGFuIElOU0VSVCBpbnRvIHRoZSB0YWJsZSBvciB2aWV3LlxuICAgICAqXG4gICAgICogQnkgZGVmYXVsdCwgaW5zZXJ0ZWQgcm93cyBhcmUgbm90IHJldHVybmVkLiBUbyByZXR1cm4gaXQsIGNoYWluIHRoZSBjYWxsXG4gICAgICogd2l0aCBgLnNlbGVjdCgpYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgdmFsdWVzIHRvIGluc2VydC4gUGFzcyBhbiBvYmplY3QgdG8gaW5zZXJ0IGEgc2luZ2xlIHJvd1xuICAgICAqIG9yIGFuIGFycmF5IHRvIGluc2VydCBtdWx0aXBsZSByb3dzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5jb3VudCAtIENvdW50IGFsZ29yaXRobSB0byB1c2UgdG8gY291bnQgaW5zZXJ0ZWQgcm93cy5cbiAgICAgKlxuICAgICAqIGBcImV4YWN0XCJgOiBFeGFjdCBidXQgc2xvdyBjb3VudCBhbGdvcml0aG0uIFBlcmZvcm1zIGEgYENPVU5UKCopYCB1bmRlciB0aGVcbiAgICAgKiBob29kLlxuICAgICAqXG4gICAgICogYFwicGxhbm5lZFwiYDogQXBwcm94aW1hdGVkIGJ1dCBmYXN0IGNvdW50IGFsZ29yaXRobS4gVXNlcyB0aGUgUG9zdGdyZXNcbiAgICAgKiBzdGF0aXN0aWNzIHVuZGVyIHRoZSBob29kLlxuICAgICAqXG4gICAgICogYFwiZXN0aW1hdGVkXCJgOiBVc2VzIGV4YWN0IGNvdW50IGZvciBsb3cgbnVtYmVycyBhbmQgcGxhbm5lZCBjb3VudCBmb3IgaGlnaFxuICAgICAqIG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5kZWZhdWx0VG9OdWxsIC0gTWFrZSBtaXNzaW5nIGZpZWxkcyBkZWZhdWx0IHRvIGBudWxsYC5cbiAgICAgKiBPdGhlcndpc2UsIHVzZSB0aGUgZGVmYXVsdCB2YWx1ZSBmb3IgdGhlIGNvbHVtbi4gT25seSBhcHBsaWVzIGZvciBidWxrXG4gICAgICogaW5zZXJ0cy5cbiAgICAgKi9cbiAgICBpbnNlcnQodmFsdWVzLCB7IGNvdW50LCBkZWZhdWx0VG9OdWxsID0gdHJ1ZSwgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQT1NUJztcbiAgICAgICAgY29uc3QgcHJlZmVyc0hlYWRlcnMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMuaGVhZGVyc1snUHJlZmVyJ10pIHtcbiAgICAgICAgICAgIHByZWZlcnNIZWFkZXJzLnB1c2godGhpcy5oZWFkZXJzWydQcmVmZXInXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvdW50KSB7XG4gICAgICAgICAgICBwcmVmZXJzSGVhZGVycy5wdXNoKGBjb3VudD0ke2NvdW50fWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVmYXVsdFRvTnVsbCkge1xuICAgICAgICAgICAgcHJlZmVyc0hlYWRlcnMucHVzaCgnbWlzc2luZz1kZWZhdWx0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oZWFkZXJzWydQcmVmZXInXSA9IHByZWZlcnNIZWFkZXJzLmpvaW4oJywnKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICAgICAgY29uc3QgY29sdW1ucyA9IHZhbHVlcy5yZWR1Y2UoKGFjYywgeCkgPT4gYWNjLmNvbmNhdChPYmplY3Qua2V5cyh4KSksIFtdKTtcbiAgICAgICAgICAgIGlmIChjb2x1bW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCB1bmlxdWVDb2x1bW5zID0gWy4uLm5ldyBTZXQoY29sdW1ucyldLm1hcCgoY29sdW1uKSA9PiBgXCIke2NvbHVtbn1cImApO1xuICAgICAgICAgICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5zZXQoJ2NvbHVtbnMnLCB1bmlxdWVDb2x1bW5zLmpvaW4oJywnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyXzEuZGVmYXVsdCh7XG4gICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICB1cmw6IHRoaXMudXJsLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2NoZW1hOiB0aGlzLnNjaGVtYSxcbiAgICAgICAgICAgIGJvZHk6IHZhbHVlcyxcbiAgICAgICAgICAgIGZldGNoOiB0aGlzLmZldGNoLFxuICAgICAgICAgICAgYWxsb3dFbXB0eTogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGFuIFVQU0VSVCBvbiB0aGUgdGFibGUgb3Igdmlldy4gRGVwZW5kaW5nIG9uIHRoZSBjb2x1bW4ocykgcGFzc2VkXG4gICAgICogdG8gYG9uQ29uZmxpY3RgLCBgLnVwc2VydCgpYCBhbGxvd3MgeW91IHRvIHBlcmZvcm0gdGhlIGVxdWl2YWxlbnQgb2ZcbiAgICAgKiBgLmluc2VydCgpYCBpZiBhIHJvdyB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIGBvbkNvbmZsaWN0YCBjb2x1bW5zIGRvZXNuJ3RcbiAgICAgKiBleGlzdCwgb3IgaWYgaXQgZG9lcyBleGlzdCwgcGVyZm9ybSBhbiBhbHRlcm5hdGl2ZSBhY3Rpb24gZGVwZW5kaW5nIG9uXG4gICAgICogYGlnbm9yZUR1cGxpY2F0ZXNgLlxuICAgICAqXG4gICAgICogQnkgZGVmYXVsdCwgdXBzZXJ0ZWQgcm93cyBhcmUgbm90IHJldHVybmVkLiBUbyByZXR1cm4gaXQsIGNoYWluIHRoZSBjYWxsXG4gICAgICogd2l0aCBgLnNlbGVjdCgpYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgdmFsdWVzIHRvIHVwc2VydCB3aXRoLiBQYXNzIGFuIG9iamVjdCB0byB1cHNlcnQgYVxuICAgICAqIHNpbmdsZSByb3cgb3IgYW4gYXJyYXkgdG8gdXBzZXJ0IG11bHRpcGxlIHJvd3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zLm9uQ29uZmxpY3QgLSBDb21tYS1zZXBhcmF0ZWQgVU5JUVVFIGNvbHVtbihzKSB0byBzcGVjaWZ5IGhvd1xuICAgICAqIGR1cGxpY2F0ZSByb3dzIGFyZSBkZXRlcm1pbmVkLiBUd28gcm93cyBhcmUgZHVwbGljYXRlcyBpZiBhbGwgdGhlXG4gICAgICogYG9uQ29uZmxpY3RgIGNvbHVtbnMgYXJlIGVxdWFsLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMuaWdub3JlRHVwbGljYXRlcyAtIElmIGB0cnVlYCwgZHVwbGljYXRlIHJvd3MgYXJlIGlnbm9yZWQuIElmXG4gICAgICogYGZhbHNlYCwgZHVwbGljYXRlIHJvd3MgYXJlIG1lcmdlZCB3aXRoIGV4aXN0aW5nIHJvd3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5jb3VudCAtIENvdW50IGFsZ29yaXRobSB0byB1c2UgdG8gY291bnQgdXBzZXJ0ZWQgcm93cy5cbiAgICAgKlxuICAgICAqIGBcImV4YWN0XCJgOiBFeGFjdCBidXQgc2xvdyBjb3VudCBhbGdvcml0aG0uIFBlcmZvcm1zIGEgYENPVU5UKCopYCB1bmRlciB0aGVcbiAgICAgKiBob29kLlxuICAgICAqXG4gICAgICogYFwicGxhbm5lZFwiYDogQXBwcm94aW1hdGVkIGJ1dCBmYXN0IGNvdW50IGFsZ29yaXRobS4gVXNlcyB0aGUgUG9zdGdyZXNcbiAgICAgKiBzdGF0aXN0aWNzIHVuZGVyIHRoZSBob29kLlxuICAgICAqXG4gICAgICogYFwiZXN0aW1hdGVkXCJgOiBVc2VzIGV4YWN0IGNvdW50IGZvciBsb3cgbnVtYmVycyBhbmQgcGxhbm5lZCBjb3VudCBmb3IgaGlnaFxuICAgICAqIG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5kZWZhdWx0VG9OdWxsIC0gTWFrZSBtaXNzaW5nIGZpZWxkcyBkZWZhdWx0IHRvIGBudWxsYC5cbiAgICAgKiBPdGhlcndpc2UsIHVzZSB0aGUgZGVmYXVsdCB2YWx1ZSBmb3IgdGhlIGNvbHVtbi4gVGhpcyBvbmx5IGFwcGxpZXMgd2hlblxuICAgICAqIGluc2VydGluZyBuZXcgcm93cywgbm90IHdoZW4gbWVyZ2luZyB3aXRoIGV4aXN0aW5nIHJvd3MgdW5kZXJcbiAgICAgKiBgaWdub3JlRHVwbGljYXRlczogZmFsc2VgLiBUaGlzIGFsc28gb25seSBhcHBsaWVzIHdoZW4gZG9pbmcgYnVsayB1cHNlcnRzLlxuICAgICAqL1xuICAgIHVwc2VydCh2YWx1ZXMsIHsgb25Db25mbGljdCwgaWdub3JlRHVwbGljYXRlcyA9IGZhbHNlLCBjb3VudCwgZGVmYXVsdFRvTnVsbCA9IHRydWUsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBtZXRob2QgPSAnUE9TVCc7XG4gICAgICAgIGNvbnN0IHByZWZlcnNIZWFkZXJzID0gW2ByZXNvbHV0aW9uPSR7aWdub3JlRHVwbGljYXRlcyA/ICdpZ25vcmUnIDogJ21lcmdlJ30tZHVwbGljYXRlc2BdO1xuICAgICAgICBpZiAob25Db25mbGljdCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLnNldCgnb25fY29uZmxpY3QnLCBvbkNvbmZsaWN0KTtcbiAgICAgICAgaWYgKHRoaXMuaGVhZGVyc1snUHJlZmVyJ10pIHtcbiAgICAgICAgICAgIHByZWZlcnNIZWFkZXJzLnB1c2godGhpcy5oZWFkZXJzWydQcmVmZXInXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvdW50KSB7XG4gICAgICAgICAgICBwcmVmZXJzSGVhZGVycy5wdXNoKGBjb3VudD0ke2NvdW50fWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVmYXVsdFRvTnVsbCkge1xuICAgICAgICAgICAgcHJlZmVyc0hlYWRlcnMucHVzaCgnbWlzc2luZz1kZWZhdWx0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oZWFkZXJzWydQcmVmZXInXSA9IHByZWZlcnNIZWFkZXJzLmpvaW4oJywnKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICAgICAgY29uc3QgY29sdW1ucyA9IHZhbHVlcy5yZWR1Y2UoKGFjYywgeCkgPT4gYWNjLmNvbmNhdChPYmplY3Qua2V5cyh4KSksIFtdKTtcbiAgICAgICAgICAgIGlmIChjb2x1bW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCB1bmlxdWVDb2x1bW5zID0gWy4uLm5ldyBTZXQoY29sdW1ucyldLm1hcCgoY29sdW1uKSA9PiBgXCIke2NvbHVtbn1cImApO1xuICAgICAgICAgICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5zZXQoJ2NvbHVtbnMnLCB1bmlxdWVDb2x1bW5zLmpvaW4oJywnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyXzEuZGVmYXVsdCh7XG4gICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICB1cmw6IHRoaXMudXJsLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2NoZW1hOiB0aGlzLnNjaGVtYSxcbiAgICAgICAgICAgIGJvZHk6IHZhbHVlcyxcbiAgICAgICAgICAgIGZldGNoOiB0aGlzLmZldGNoLFxuICAgICAgICAgICAgYWxsb3dFbXB0eTogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGFuIFVQREFURSBvbiB0aGUgdGFibGUgb3Igdmlldy5cbiAgICAgKlxuICAgICAqIEJ5IGRlZmF1bHQsIHVwZGF0ZWQgcm93cyBhcmUgbm90IHJldHVybmVkLiBUbyByZXR1cm4gaXQsIGNoYWluIHRoZSBjYWxsXG4gICAgICogd2l0aCBgLnNlbGVjdCgpYCBhZnRlciBmaWx0ZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlcyAtIFRoZSB2YWx1ZXMgdG8gdXBkYXRlIHdpdGhcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMuY291bnQgLSBDb3VudCBhbGdvcml0aG0gdG8gdXNlIHRvIGNvdW50IHVwZGF0ZWQgcm93cy5cbiAgICAgKlxuICAgICAqIGBcImV4YWN0XCJgOiBFeGFjdCBidXQgc2xvdyBjb3VudCBhbGdvcml0aG0uIFBlcmZvcm1zIGEgYENPVU5UKCopYCB1bmRlciB0aGVcbiAgICAgKiBob29kLlxuICAgICAqXG4gICAgICogYFwicGxhbm5lZFwiYDogQXBwcm94aW1hdGVkIGJ1dCBmYXN0IGNvdW50IGFsZ29yaXRobS4gVXNlcyB0aGUgUG9zdGdyZXNcbiAgICAgKiBzdGF0aXN0aWNzIHVuZGVyIHRoZSBob29kLlxuICAgICAqXG4gICAgICogYFwiZXN0aW1hdGVkXCJgOiBVc2VzIGV4YWN0IGNvdW50IGZvciBsb3cgbnVtYmVycyBhbmQgcGxhbm5lZCBjb3VudCBmb3IgaGlnaFxuICAgICAqIG51bWJlcnMuXG4gICAgICovXG4gICAgdXBkYXRlKHZhbHVlcywgeyBjb3VudCwgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQQVRDSCc7XG4gICAgICAgIGNvbnN0IHByZWZlcnNIZWFkZXJzID0gW107XG4gICAgICAgIGlmICh0aGlzLmhlYWRlcnNbJ1ByZWZlciddKSB7XG4gICAgICAgICAgICBwcmVmZXJzSGVhZGVycy5wdXNoKHRoaXMuaGVhZGVyc1snUHJlZmVyJ10pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3VudCkge1xuICAgICAgICAgICAgcHJlZmVyc0hlYWRlcnMucHVzaChgY291bnQ9JHtjb3VudH1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhlYWRlcnNbJ1ByZWZlciddID0gcHJlZmVyc0hlYWRlcnMuam9pbignLCcpO1xuICAgICAgICByZXR1cm4gbmV3IFBvc3RncmVzdEZpbHRlckJ1aWxkZXJfMS5kZWZhdWx0KHtcbiAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgIHVybDogdGhpcy51cmwsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzY2hlbWE6IHRoaXMuc2NoZW1hLFxuICAgICAgICAgICAgYm9keTogdmFsdWVzLFxuICAgICAgICAgICAgZmV0Y2g6IHRoaXMuZmV0Y2gsXG4gICAgICAgICAgICBhbGxvd0VtcHR5OiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gYSBERUxFVEUgb24gdGhlIHRhYmxlIG9yIHZpZXcuXG4gICAgICpcbiAgICAgKiBCeSBkZWZhdWx0LCBkZWxldGVkIHJvd3MgYXJlIG5vdCByZXR1cm5lZC4gVG8gcmV0dXJuIGl0LCBjaGFpbiB0aGUgY2FsbFxuICAgICAqIHdpdGggYC5zZWxlY3QoKWAgYWZ0ZXIgZmlsdGVycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMuY291bnQgLSBDb3VudCBhbGdvcml0aG0gdG8gdXNlIHRvIGNvdW50IGRlbGV0ZWQgcm93cy5cbiAgICAgKlxuICAgICAqIGBcImV4YWN0XCJgOiBFeGFjdCBidXQgc2xvdyBjb3VudCBhbGdvcml0aG0uIFBlcmZvcm1zIGEgYENPVU5UKCopYCB1bmRlciB0aGVcbiAgICAgKiBob29kLlxuICAgICAqXG4gICAgICogYFwicGxhbm5lZFwiYDogQXBwcm94aW1hdGVkIGJ1dCBmYXN0IGNvdW50IGFsZ29yaXRobS4gVXNlcyB0aGUgUG9zdGdyZXNcbiAgICAgKiBzdGF0aXN0aWNzIHVuZGVyIHRoZSBob29kLlxuICAgICAqXG4gICAgICogYFwiZXN0aW1hdGVkXCJgOiBVc2VzIGV4YWN0IGNvdW50IGZvciBsb3cgbnVtYmVycyBhbmQgcGxhbm5lZCBjb3VudCBmb3IgaGlnaFxuICAgICAqIG51bWJlcnMuXG4gICAgICovXG4gICAgZGVsZXRlKHsgY291bnQsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBtZXRob2QgPSAnREVMRVRFJztcbiAgICAgICAgY29uc3QgcHJlZmVyc0hlYWRlcnMgPSBbXTtcbiAgICAgICAgaWYgKGNvdW50KSB7XG4gICAgICAgICAgICBwcmVmZXJzSGVhZGVycy5wdXNoKGBjb3VudD0ke2NvdW50fWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhlYWRlcnNbJ1ByZWZlciddKSB7XG4gICAgICAgICAgICBwcmVmZXJzSGVhZGVycy51bnNoaWZ0KHRoaXMuaGVhZGVyc1snUHJlZmVyJ10pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGVhZGVyc1snUHJlZmVyJ10gPSBwcmVmZXJzSGVhZGVycy5qb2luKCcsJyk7XG4gICAgICAgIHJldHVybiBuZXcgUG9zdGdyZXN0RmlsdGVyQnVpbGRlcl8xLmRlZmF1bHQoe1xuICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgdXJsOiB0aGlzLnVybCxcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNjaGVtYTogdGhpcy5zY2hlbWEsXG4gICAgICAgICAgICBmZXRjaDogdGhpcy5mZXRjaCxcbiAgICAgICAgICAgIGFsbG93RW1wdHk6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestQueryBuilder.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestTransformBuilder.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestTransformBuilder.js ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst PostgrestBuilder_1 = __importDefault(__webpack_require__(/*! ./PostgrestBuilder */ \"(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestBuilder.js\"));\nclass PostgrestTransformBuilder extends PostgrestBuilder_1.default {\n    /**\n     * Perform a SELECT on the query result.\n     *\n     * By default, `.insert()`, `.update()`, `.upsert()`, and `.delete()` do not\n     * return modified rows. By calling this method, modified rows are returned in\n     * `data`.\n     *\n     * @param columns - The columns to retrieve, separated by commas\n     */\n    select(columns) {\n        // Remove whitespaces except when quoted\n        let quoted = false;\n        const cleanedColumns = (columns !== null && columns !== void 0 ? columns : '*')\n            .split('')\n            .map((c) => {\n            if (/\\s/.test(c) && !quoted) {\n                return '';\n            }\n            if (c === '\"') {\n                quoted = !quoted;\n            }\n            return c;\n        })\n            .join('');\n        this.url.searchParams.set('select', cleanedColumns);\n        if (this.headers['Prefer']) {\n            this.headers['Prefer'] += ',';\n        }\n        this.headers['Prefer'] += 'return=representation';\n        return this;\n    }\n    /**\n     * Order the query result by `column`.\n     *\n     * You can call this method multiple times to order by multiple columns.\n     *\n     * You can order referenced tables, but it only affects the ordering of the\n     * parent table if you use `!inner` in the query.\n     *\n     * @param column - The column to order by\n     * @param options - Named parameters\n     * @param options.ascending - If `true`, the result will be in ascending order\n     * @param options.nullsFirst - If `true`, `null`s appear first. If `false`,\n     * `null`s appear last.\n     * @param options.referencedTable - Set this to order a referenced table by\n     * its columns\n     * @param options.foreignTable - Deprecated, use `options.referencedTable`\n     * instead\n     */\n    order(column, { ascending = true, nullsFirst, foreignTable, referencedTable = foreignTable, } = {}) {\n        const key = referencedTable ? `${referencedTable}.order` : 'order';\n        const existingOrder = this.url.searchParams.get(key);\n        this.url.searchParams.set(key, `${existingOrder ? `${existingOrder},` : ''}${column}.${ascending ? 'asc' : 'desc'}${nullsFirst === undefined ? '' : nullsFirst ? '.nullsfirst' : '.nullslast'}`);\n        return this;\n    }\n    /**\n     * Limit the query result by `count`.\n     *\n     * @param count - The maximum number of rows to return\n     * @param options - Named parameters\n     * @param options.referencedTable - Set this to limit rows of referenced\n     * tables instead of the parent table\n     * @param options.foreignTable - Deprecated, use `options.referencedTable`\n     * instead\n     */\n    limit(count, { foreignTable, referencedTable = foreignTable, } = {}) {\n        const key = typeof referencedTable === 'undefined' ? 'limit' : `${referencedTable}.limit`;\n        this.url.searchParams.set(key, `${count}`);\n        return this;\n    }\n    /**\n     * Limit the query result by starting at an offset `from` and ending at the offset `to`.\n     * Only records within this range are returned.\n     * This respects the query order and if there is no order clause the range could behave unexpectedly.\n     * The `from` and `to` values are 0-based and inclusive: `range(1, 3)` will include the second, third\n     * and fourth rows of the query.\n     *\n     * @param from - The starting index from which to limit the result\n     * @param to - The last index to which to limit the result\n     * @param options - Named parameters\n     * @param options.referencedTable - Set this to limit rows of referenced\n     * tables instead of the parent table\n     * @param options.foreignTable - Deprecated, use `options.referencedTable`\n     * instead\n     */\n    range(from, to, { foreignTable, referencedTable = foreignTable, } = {}) {\n        const keyOffset = typeof referencedTable === 'undefined' ? 'offset' : `${referencedTable}.offset`;\n        const keyLimit = typeof referencedTable === 'undefined' ? 'limit' : `${referencedTable}.limit`;\n        this.url.searchParams.set(keyOffset, `${from}`);\n        // Range is inclusive, so add 1\n        this.url.searchParams.set(keyLimit, `${to - from + 1}`);\n        return this;\n    }\n    /**\n     * Set the AbortSignal for the fetch request.\n     *\n     * @param signal - The AbortSignal to use for the fetch request\n     */\n    abortSignal(signal) {\n        this.signal = signal;\n        return this;\n    }\n    /**\n     * Return `data` as a single object instead of an array of objects.\n     *\n     * Query result must be one row (e.g. using `.limit(1)`), otherwise this\n     * returns an error.\n     */\n    single() {\n        this.headers['Accept'] = 'application/vnd.pgrst.object+json';\n        return this;\n    }\n    /**\n     * Return `data` as a single object instead of an array of objects.\n     *\n     * Query result must be zero or one row (e.g. using `.limit(1)`), otherwise\n     * this returns an error.\n     */\n    maybeSingle() {\n        // Temporary partial fix for https://github.com/supabase/postgrest-js/issues/361\n        // Issue persists e.g. for `.insert([...]).select().maybeSingle()`\n        if (this.method === 'GET') {\n            this.headers['Accept'] = 'application/json';\n        }\n        else {\n            this.headers['Accept'] = 'application/vnd.pgrst.object+json';\n        }\n        this.isMaybeSingle = true;\n        return this;\n    }\n    /**\n     * Return `data` as a string in CSV format.\n     */\n    csv() {\n        this.headers['Accept'] = 'text/csv';\n        return this;\n    }\n    /**\n     * Return `data` as an object in [GeoJSON](https://geojson.org) format.\n     */\n    geojson() {\n        this.headers['Accept'] = 'application/geo+json';\n        return this;\n    }\n    /**\n     * Return `data` as the EXPLAIN plan for the query.\n     *\n     * You need to enable the\n     * [db_plan_enabled](https://supabase.com/docs/guides/database/debugging-performance#enabling-explain)\n     * setting before using this method.\n     *\n     * @param options - Named parameters\n     *\n     * @param options.analyze - If `true`, the query will be executed and the\n     * actual run time will be returned\n     *\n     * @param options.verbose - If `true`, the query identifier will be returned\n     * and `data` will include the output columns of the query\n     *\n     * @param options.settings - If `true`, include information on configuration\n     * parameters that affect query planning\n     *\n     * @param options.buffers - If `true`, include information on buffer usage\n     *\n     * @param options.wal - If `true`, include information on WAL record generation\n     *\n     * @param options.format - The format of the output, can be `\"text\"` (default)\n     * or `\"json\"`\n     */\n    explain({ analyze = false, verbose = false, settings = false, buffers = false, wal = false, format = 'text', } = {}) {\n        var _a;\n        const options = [\n            analyze ? 'analyze' : null,\n            verbose ? 'verbose' : null,\n            settings ? 'settings' : null,\n            buffers ? 'buffers' : null,\n            wal ? 'wal' : null,\n        ]\n            .filter(Boolean)\n            .join('|');\n        // An Accept header can carry multiple media types but postgrest-js always sends one\n        const forMediatype = (_a = this.headers['Accept']) !== null && _a !== void 0 ? _a : 'application/json';\n        this.headers['Accept'] = `application/vnd.pgrst.plan+${format}; for=\"${forMediatype}\"; options=${options};`;\n        if (format === 'json')\n            return this;\n        else\n            return this;\n    }\n    /**\n     * Rollback the query.\n     *\n     * `data` will still be returned, but the query is not committed.\n     */\n    rollback() {\n        var _a;\n        if (((_a = this.headers['Prefer']) !== null && _a !== void 0 ? _a : '').trim().length > 0) {\n            this.headers['Prefer'] += ',tx=rollback';\n        }\n        else {\n            this.headers['Prefer'] = 'tx=rollback';\n        }\n        return this;\n    }\n    /**\n     * Override the type of the returned `data`.\n     *\n     * @typeParam NewResult - The new result type to override with\n     */\n    returns() {\n        return this;\n    }\n}\nexports[\"default\"] = PostgrestTransformBuilder;\n//# sourceMappingURL=PostgrestTransformBuilder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL2Rpc3QvY2pzL1Bvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQ0FBMkMsbUJBQU8sQ0FBQyxrSEFBb0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDhFQUE4RSxJQUFJO0FBQ3RHLHlDQUF5QyxnQkFBZ0I7QUFDekQ7QUFDQSwwQ0FBMEMsbUJBQW1CLGNBQWMsUUFBUSxFQUFFLE9BQU8sR0FBRywyQkFBMkIsRUFBRSwwRUFBMEU7QUFDdE07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdEQUFnRCxJQUFJO0FBQ3ZFLDBFQUEwRSxnQkFBZ0I7QUFDMUYsMENBQTBDLE1BQU07QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnREFBZ0QsSUFBSTtBQUMxRSxpRkFBaUYsZ0JBQWdCO0FBQ2pHLCtFQUErRSxnQkFBZ0I7QUFDL0YsZ0RBQWdELEtBQUs7QUFDckQ7QUFDQSwrQ0FBK0MsY0FBYztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHFHQUFxRyxJQUFJO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxTQUFTLE9BQU8sYUFBYSxHQUFHLFVBQVUsU0FBUztBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvV29uZGVyVml0ZS1mcm9udGVuZC9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Bvc3RncmVzdC1qcy9kaXN0L2Nqcy9Qb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgUG9zdGdyZXN0QnVpbGRlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1Bvc3RncmVzdEJ1aWxkZXJcIikpO1xuY2xhc3MgUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlciBleHRlbmRzIFBvc3RncmVzdEJ1aWxkZXJfMS5kZWZhdWx0IHtcbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGEgU0VMRUNUIG9uIHRoZSBxdWVyeSByZXN1bHQuXG4gICAgICpcbiAgICAgKiBCeSBkZWZhdWx0LCBgLmluc2VydCgpYCwgYC51cGRhdGUoKWAsIGAudXBzZXJ0KClgLCBhbmQgYC5kZWxldGUoKWAgZG8gbm90XG4gICAgICogcmV0dXJuIG1vZGlmaWVkIHJvd3MuIEJ5IGNhbGxpbmcgdGhpcyBtZXRob2QsIG1vZGlmaWVkIHJvd3MgYXJlIHJldHVybmVkIGluXG4gICAgICogYGRhdGFgLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbnMgLSBUaGUgY29sdW1ucyB0byByZXRyaWV2ZSwgc2VwYXJhdGVkIGJ5IGNvbW1hc1xuICAgICAqL1xuICAgIHNlbGVjdChjb2x1bW5zKSB7XG4gICAgICAgIC8vIFJlbW92ZSB3aGl0ZXNwYWNlcyBleGNlcHQgd2hlbiBxdW90ZWRcbiAgICAgICAgbGV0IHF1b3RlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBjbGVhbmVkQ29sdW1ucyA9IChjb2x1bW5zICE9PSBudWxsICYmIGNvbHVtbnMgIT09IHZvaWQgMCA/IGNvbHVtbnMgOiAnKicpXG4gICAgICAgICAgICAuc3BsaXQoJycpXG4gICAgICAgICAgICAubWFwKChjKSA9PiB7XG4gICAgICAgICAgICBpZiAoL1xccy8udGVzdChjKSAmJiAhcXVvdGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMgPT09ICdcIicpIHtcbiAgICAgICAgICAgICAgICBxdW90ZWQgPSAhcXVvdGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbignJyk7XG4gICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5zZXQoJ3NlbGVjdCcsIGNsZWFuZWRDb2x1bW5zKTtcbiAgICAgICAgaWYgKHRoaXMuaGVhZGVyc1snUHJlZmVyJ10pIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyc1snUHJlZmVyJ10gKz0gJywnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGVhZGVyc1snUHJlZmVyJ10gKz0gJ3JldHVybj1yZXByZXNlbnRhdGlvbic7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPcmRlciB0aGUgcXVlcnkgcmVzdWx0IGJ5IGBjb2x1bW5gLlxuICAgICAqXG4gICAgICogWW91IGNhbiBjYWxsIHRoaXMgbWV0aG9kIG11bHRpcGxlIHRpbWVzIHRvIG9yZGVyIGJ5IG11bHRpcGxlIGNvbHVtbnMuXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIG9yZGVyIHJlZmVyZW5jZWQgdGFibGVzLCBidXQgaXQgb25seSBhZmZlY3RzIHRoZSBvcmRlcmluZyBvZiB0aGVcbiAgICAgKiBwYXJlbnQgdGFibGUgaWYgeW91IHVzZSBgIWlubmVyYCBpbiB0aGUgcXVlcnkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBvcmRlciBieVxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLmFzY2VuZGluZyAtIElmIGB0cnVlYCwgdGhlIHJlc3VsdCB3aWxsIGJlIGluIGFzY2VuZGluZyBvcmRlclxuICAgICAqIEBwYXJhbSBvcHRpb25zLm51bGxzRmlyc3QgLSBJZiBgdHJ1ZWAsIGBudWxsYHMgYXBwZWFyIGZpcnN0LiBJZiBgZmFsc2VgLFxuICAgICAqIGBudWxsYHMgYXBwZWFyIGxhc3QuXG4gICAgICogQHBhcmFtIG9wdGlvbnMucmVmZXJlbmNlZFRhYmxlIC0gU2V0IHRoaXMgdG8gb3JkZXIgYSByZWZlcmVuY2VkIHRhYmxlIGJ5XG4gICAgICogaXRzIGNvbHVtbnNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5mb3JlaWduVGFibGUgLSBEZXByZWNhdGVkLCB1c2UgYG9wdGlvbnMucmVmZXJlbmNlZFRhYmxlYFxuICAgICAqIGluc3RlYWRcbiAgICAgKi9cbiAgICBvcmRlcihjb2x1bW4sIHsgYXNjZW5kaW5nID0gdHJ1ZSwgbnVsbHNGaXJzdCwgZm9yZWlnblRhYmxlLCByZWZlcmVuY2VkVGFibGUgPSBmb3JlaWduVGFibGUsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBrZXkgPSByZWZlcmVuY2VkVGFibGUgPyBgJHtyZWZlcmVuY2VkVGFibGV9Lm9yZGVyYCA6ICdvcmRlcic7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nT3JkZXIgPSB0aGlzLnVybC5zZWFyY2hQYXJhbXMuZ2V0KGtleSk7XG4gICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5zZXQoa2V5LCBgJHtleGlzdGluZ09yZGVyID8gYCR7ZXhpc3RpbmdPcmRlcn0sYCA6ICcnfSR7Y29sdW1ufS4ke2FzY2VuZGluZyA/ICdhc2MnIDogJ2Rlc2MnfSR7bnVsbHNGaXJzdCA9PT0gdW5kZWZpbmVkID8gJycgOiBudWxsc0ZpcnN0ID8gJy5udWxsc2ZpcnN0JyA6ICcubnVsbHNsYXN0J31gKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpbWl0IHRoZSBxdWVyeSByZXN1bHQgYnkgYGNvdW50YC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb3VudCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiByb3dzIHRvIHJldHVyblxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLnJlZmVyZW5jZWRUYWJsZSAtIFNldCB0aGlzIHRvIGxpbWl0IHJvd3Mgb2YgcmVmZXJlbmNlZFxuICAgICAqIHRhYmxlcyBpbnN0ZWFkIG9mIHRoZSBwYXJlbnQgdGFibGVcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5mb3JlaWduVGFibGUgLSBEZXByZWNhdGVkLCB1c2UgYG9wdGlvbnMucmVmZXJlbmNlZFRhYmxlYFxuICAgICAqIGluc3RlYWRcbiAgICAgKi9cbiAgICBsaW1pdChjb3VudCwgeyBmb3JlaWduVGFibGUsIHJlZmVyZW5jZWRUYWJsZSA9IGZvcmVpZ25UYWJsZSwgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHR5cGVvZiByZWZlcmVuY2VkVGFibGUgPT09ICd1bmRlZmluZWQnID8gJ2xpbWl0JyA6IGAke3JlZmVyZW5jZWRUYWJsZX0ubGltaXRgO1xuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuc2V0KGtleSwgYCR7Y291bnR9YCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaW1pdCB0aGUgcXVlcnkgcmVzdWx0IGJ5IHN0YXJ0aW5nIGF0IGFuIG9mZnNldCBgZnJvbWAgYW5kIGVuZGluZyBhdCB0aGUgb2Zmc2V0IGB0b2AuXG4gICAgICogT25seSByZWNvcmRzIHdpdGhpbiB0aGlzIHJhbmdlIGFyZSByZXR1cm5lZC5cbiAgICAgKiBUaGlzIHJlc3BlY3RzIHRoZSBxdWVyeSBvcmRlciBhbmQgaWYgdGhlcmUgaXMgbm8gb3JkZXIgY2xhdXNlIHRoZSByYW5nZSBjb3VsZCBiZWhhdmUgdW5leHBlY3RlZGx5LlxuICAgICAqIFRoZSBgZnJvbWAgYW5kIGB0b2AgdmFsdWVzIGFyZSAwLWJhc2VkIGFuZCBpbmNsdXNpdmU6IGByYW5nZSgxLCAzKWAgd2lsbCBpbmNsdWRlIHRoZSBzZWNvbmQsIHRoaXJkXG4gICAgICogYW5kIGZvdXJ0aCByb3dzIG9mIHRoZSBxdWVyeS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmcm9tIC0gVGhlIHN0YXJ0aW5nIGluZGV4IGZyb20gd2hpY2ggdG8gbGltaXQgdGhlIHJlc3VsdFxuICAgICAqIEBwYXJhbSB0byAtIFRoZSBsYXN0IGluZGV4IHRvIHdoaWNoIHRvIGxpbWl0IHRoZSByZXN1bHRcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5yZWZlcmVuY2VkVGFibGUgLSBTZXQgdGhpcyB0byBsaW1pdCByb3dzIG9mIHJlZmVyZW5jZWRcbiAgICAgKiB0YWJsZXMgaW5zdGVhZCBvZiB0aGUgcGFyZW50IHRhYmxlXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZm9yZWlnblRhYmxlIC0gRGVwcmVjYXRlZCwgdXNlIGBvcHRpb25zLnJlZmVyZW5jZWRUYWJsZWBcbiAgICAgKiBpbnN0ZWFkXG4gICAgICovXG4gICAgcmFuZ2UoZnJvbSwgdG8sIHsgZm9yZWlnblRhYmxlLCByZWZlcmVuY2VkVGFibGUgPSBmb3JlaWduVGFibGUsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBrZXlPZmZzZXQgPSB0eXBlb2YgcmVmZXJlbmNlZFRhYmxlID09PSAndW5kZWZpbmVkJyA/ICdvZmZzZXQnIDogYCR7cmVmZXJlbmNlZFRhYmxlfS5vZmZzZXRgO1xuICAgICAgICBjb25zdCBrZXlMaW1pdCA9IHR5cGVvZiByZWZlcmVuY2VkVGFibGUgPT09ICd1bmRlZmluZWQnID8gJ2xpbWl0JyA6IGAke3JlZmVyZW5jZWRUYWJsZX0ubGltaXRgO1xuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuc2V0KGtleU9mZnNldCwgYCR7ZnJvbX1gKTtcbiAgICAgICAgLy8gUmFuZ2UgaXMgaW5jbHVzaXZlLCBzbyBhZGQgMVxuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuc2V0KGtleUxpbWl0LCBgJHt0byAtIGZyb20gKyAxfWApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBBYm9ydFNpZ25hbCBmb3IgdGhlIGZldGNoIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2lnbmFsIC0gVGhlIEFib3J0U2lnbmFsIHRvIHVzZSBmb3IgdGhlIGZldGNoIHJlcXVlc3RcbiAgICAgKi9cbiAgICBhYm9ydFNpZ25hbChzaWduYWwpIHtcbiAgICAgICAgdGhpcy5zaWduYWwgPSBzaWduYWw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYGRhdGFgIGFzIGEgc2luZ2xlIG9iamVjdCBpbnN0ZWFkIG9mIGFuIGFycmF5IG9mIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBRdWVyeSByZXN1bHQgbXVzdCBiZSBvbmUgcm93IChlLmcuIHVzaW5nIGAubGltaXQoMSlgKSwgb3RoZXJ3aXNlIHRoaXNcbiAgICAgKiByZXR1cm5zIGFuIGVycm9yLlxuICAgICAqL1xuICAgIHNpbmdsZSgpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzWydBY2NlcHQnXSA9ICdhcHBsaWNhdGlvbi92bmQucGdyc3Qub2JqZWN0K2pzb24nO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGBkYXRhYCBhcyBhIHNpbmdsZSBvYmplY3QgaW5zdGVhZCBvZiBhbiBhcnJheSBvZiBvYmplY3RzLlxuICAgICAqXG4gICAgICogUXVlcnkgcmVzdWx0IG11c3QgYmUgemVybyBvciBvbmUgcm93IChlLmcuIHVzaW5nIGAubGltaXQoMSlgKSwgb3RoZXJ3aXNlXG4gICAgICogdGhpcyByZXR1cm5zIGFuIGVycm9yLlxuICAgICAqL1xuICAgIG1heWJlU2luZ2xlKCkge1xuICAgICAgICAvLyBUZW1wb3JhcnkgcGFydGlhbCBmaXggZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9zdXBhYmFzZS9wb3N0Z3Jlc3QtanMvaXNzdWVzLzM2MVxuICAgICAgICAvLyBJc3N1ZSBwZXJzaXN0cyBlLmcuIGZvciBgLmluc2VydChbLi4uXSkuc2VsZWN0KCkubWF5YmVTaW5nbGUoKWBcbiAgICAgICAgaWYgKHRoaXMubWV0aG9kID09PSAnR0VUJykge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzWydBY2NlcHQnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyc1snQWNjZXB0J10gPSAnYXBwbGljYXRpb24vdm5kLnBncnN0Lm9iamVjdCtqc29uJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzTWF5YmVTaW5nbGUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGBkYXRhYCBhcyBhIHN0cmluZyBpbiBDU1YgZm9ybWF0LlxuICAgICAqL1xuICAgIGNzdigpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzWydBY2NlcHQnXSA9ICd0ZXh0L2Nzdic7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYGRhdGFgIGFzIGFuIG9iamVjdCBpbiBbR2VvSlNPTl0oaHR0cHM6Ly9nZW9qc29uLm9yZykgZm9ybWF0LlxuICAgICAqL1xuICAgIGdlb2pzb24oKSB7XG4gICAgICAgIHRoaXMuaGVhZGVyc1snQWNjZXB0J10gPSAnYXBwbGljYXRpb24vZ2VvK2pzb24nO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGBkYXRhYCBhcyB0aGUgRVhQTEFJTiBwbGFuIGZvciB0aGUgcXVlcnkuXG4gICAgICpcbiAgICAgKiBZb3UgbmVlZCB0byBlbmFibGUgdGhlXG4gICAgICogW2RiX3BsYW5fZW5hYmxlZF0oaHR0cHM6Ly9zdXBhYmFzZS5jb20vZG9jcy9ndWlkZXMvZGF0YWJhc2UvZGVidWdnaW5nLXBlcmZvcm1hbmNlI2VuYWJsaW5nLWV4cGxhaW4pXG4gICAgICogc2V0dGluZyBiZWZvcmUgdXNpbmcgdGhpcyBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmFuYWx5emUgLSBJZiBgdHJ1ZWAsIHRoZSBxdWVyeSB3aWxsIGJlIGV4ZWN1dGVkIGFuZCB0aGVcbiAgICAgKiBhY3R1YWwgcnVuIHRpbWUgd2lsbCBiZSByZXR1cm5lZFxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMudmVyYm9zZSAtIElmIGB0cnVlYCwgdGhlIHF1ZXJ5IGlkZW50aWZpZXIgd2lsbCBiZSByZXR1cm5lZFxuICAgICAqIGFuZCBgZGF0YWAgd2lsbCBpbmNsdWRlIHRoZSBvdXRwdXQgY29sdW1ucyBvZiB0aGUgcXVlcnlcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnNldHRpbmdzIC0gSWYgYHRydWVgLCBpbmNsdWRlIGluZm9ybWF0aW9uIG9uIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBwYXJhbWV0ZXJzIHRoYXQgYWZmZWN0IHF1ZXJ5IHBsYW5uaW5nXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5idWZmZXJzIC0gSWYgYHRydWVgLCBpbmNsdWRlIGluZm9ybWF0aW9uIG9uIGJ1ZmZlciB1c2FnZVxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMud2FsIC0gSWYgYHRydWVgLCBpbmNsdWRlIGluZm9ybWF0aW9uIG9uIFdBTCByZWNvcmQgZ2VuZXJhdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZm9ybWF0IC0gVGhlIGZvcm1hdCBvZiB0aGUgb3V0cHV0LCBjYW4gYmUgYFwidGV4dFwiYCAoZGVmYXVsdClcbiAgICAgKiBvciBgXCJqc29uXCJgXG4gICAgICovXG4gICAgZXhwbGFpbih7IGFuYWx5emUgPSBmYWxzZSwgdmVyYm9zZSA9IGZhbHNlLCBzZXR0aW5ncyA9IGZhbHNlLCBidWZmZXJzID0gZmFsc2UsIHdhbCA9IGZhbHNlLCBmb3JtYXQgPSAndGV4dCcsIH0gPSB7fSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBbXG4gICAgICAgICAgICBhbmFseXplID8gJ2FuYWx5emUnIDogbnVsbCxcbiAgICAgICAgICAgIHZlcmJvc2UgPyAndmVyYm9zZScgOiBudWxsLFxuICAgICAgICAgICAgc2V0dGluZ3MgPyAnc2V0dGluZ3MnIDogbnVsbCxcbiAgICAgICAgICAgIGJ1ZmZlcnMgPyAnYnVmZmVycycgOiBudWxsLFxuICAgICAgICAgICAgd2FsID8gJ3dhbCcgOiBudWxsLFxuICAgICAgICBdXG4gICAgICAgICAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgICAgICAgICAuam9pbignfCcpO1xuICAgICAgICAvLyBBbiBBY2NlcHQgaGVhZGVyIGNhbiBjYXJyeSBtdWx0aXBsZSBtZWRpYSB0eXBlcyBidXQgcG9zdGdyZXN0LWpzIGFsd2F5cyBzZW5kcyBvbmVcbiAgICAgICAgY29uc3QgZm9yTWVkaWF0eXBlID0gKF9hID0gdGhpcy5oZWFkZXJzWydBY2NlcHQnXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICB0aGlzLmhlYWRlcnNbJ0FjY2VwdCddID0gYGFwcGxpY2F0aW9uL3ZuZC5wZ3JzdC5wbGFuKyR7Zm9ybWF0fTsgZm9yPVwiJHtmb3JNZWRpYXR5cGV9XCI7IG9wdGlvbnM9JHtvcHRpb25zfTtgO1xuICAgICAgICBpZiAoZm9ybWF0ID09PSAnanNvbicpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJvbGxiYWNrIHRoZSBxdWVyeS5cbiAgICAgKlxuICAgICAqIGBkYXRhYCB3aWxsIHN0aWxsIGJlIHJldHVybmVkLCBidXQgdGhlIHF1ZXJ5IGlzIG5vdCBjb21taXR0ZWQuXG4gICAgICovXG4gICAgcm9sbGJhY2soKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCgoX2EgPSB0aGlzLmhlYWRlcnNbJ1ByZWZlciddKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJykudHJpbSgpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyc1snUHJlZmVyJ10gKz0gJyx0eD1yb2xsYmFjayc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhlYWRlcnNbJ1ByZWZlciddID0gJ3R4PXJvbGxiYWNrJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhlIHR5cGUgb2YgdGhlIHJldHVybmVkIGBkYXRhYC5cbiAgICAgKlxuICAgICAqIEB0eXBlUGFyYW0gTmV3UmVzdWx0IC0gVGhlIG5ldyByZXN1bHQgdHlwZSB0byBvdmVycmlkZSB3aXRoXG4gICAgICovXG4gICAgcmV0dXJucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestTransformBuilder.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/constants.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@supabase/postgrest-js/dist/cjs/constants.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DEFAULT_HEADERS = void 0;\nconst version_1 = __webpack_require__(/*! ./version */ \"(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/version.js\");\nexports.DEFAULT_HEADERS = { 'X-Client-Info': `postgrest-js/${version_1.version}` };\n//# sourceMappingURL=constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL2Rpc3QvY2pzL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUI7QUFDdkIsa0JBQWtCLG1CQUFPLENBQUMsZ0dBQVc7QUFDckMsdUJBQXVCLEtBQUssaUNBQWlDLGtCQUFrQjtBQUMvRSIsInNvdXJjZXMiOlsiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvV29uZGVyVml0ZS1mcm9udGVuZC9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Bvc3RncmVzdC1qcy9kaXN0L2Nqcy9jb25zdGFudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRFRkFVTFRfSEVBREVSUyA9IHZvaWQgMDtcbmNvbnN0IHZlcnNpb25fMSA9IHJlcXVpcmUoXCIuL3ZlcnNpb25cIik7XG5leHBvcnRzLkRFRkFVTFRfSEVBREVSUyA9IHsgJ1gtQ2xpZW50LUluZm8nOiBgcG9zdGdyZXN0LWpzLyR7dmVyc2lvbl8xLnZlcnNpb259YCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/constants.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@supabase/postgrest-js/dist/cjs/index.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PostgrestError = exports.PostgrestBuilder = exports.PostgrestTransformBuilder = exports.PostgrestFilterBuilder = exports.PostgrestQueryBuilder = exports.PostgrestClient = void 0;\n// Always update wrapper.mjs when updating this file.\nconst PostgrestClient_1 = __importDefault(__webpack_require__(/*! ./PostgrestClient */ \"(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestClient.js\"));\nexports.PostgrestClient = PostgrestClient_1.default;\nconst PostgrestQueryBuilder_1 = __importDefault(__webpack_require__(/*! ./PostgrestQueryBuilder */ \"(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestQueryBuilder.js\"));\nexports.PostgrestQueryBuilder = PostgrestQueryBuilder_1.default;\nconst PostgrestFilterBuilder_1 = __importDefault(__webpack_require__(/*! ./PostgrestFilterBuilder */ \"(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestFilterBuilder.js\"));\nexports.PostgrestFilterBuilder = PostgrestFilterBuilder_1.default;\nconst PostgrestTransformBuilder_1 = __importDefault(__webpack_require__(/*! ./PostgrestTransformBuilder */ \"(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestTransformBuilder.js\"));\nexports.PostgrestTransformBuilder = PostgrestTransformBuilder_1.default;\nconst PostgrestBuilder_1 = __importDefault(__webpack_require__(/*! ./PostgrestBuilder */ \"(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestBuilder.js\"));\nexports.PostgrestBuilder = PostgrestBuilder_1.default;\nconst PostgrestError_1 = __importDefault(__webpack_require__(/*! ./PostgrestError */ \"(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestError.js\"));\nexports.PostgrestError = PostgrestError_1.default;\nexports[\"default\"] = {\n    PostgrestClient: PostgrestClient_1.default,\n    PostgrestQueryBuilder: PostgrestQueryBuilder_1.default,\n    PostgrestFilterBuilder: PostgrestFilterBuilder_1.default,\n    PostgrestTransformBuilder: PostgrestTransformBuilder_1.default,\n    PostgrestBuilder: PostgrestBuilder_1.default,\n    PostgrestError: PostgrestError_1.default,\n};\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL2Rpc3QvY2pzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCLEdBQUcsd0JBQXdCLEdBQUcsaUNBQWlDLEdBQUcsOEJBQThCLEdBQUcsNkJBQTZCLEdBQUcsdUJBQXVCO0FBQ2hMO0FBQ0EsMENBQTBDLG1CQUFPLENBQUMsZ0hBQW1CO0FBQ3JFLHVCQUF1QjtBQUN2QixnREFBZ0QsbUJBQU8sQ0FBQyw0SEFBeUI7QUFDakYsNkJBQTZCO0FBQzdCLGlEQUFpRCxtQkFBTyxDQUFDLDhIQUEwQjtBQUNuRiw4QkFBOEI7QUFDOUIsb0RBQW9ELG1CQUFPLENBQUMsb0lBQTZCO0FBQ3pGLGlDQUFpQztBQUNqQywyQ0FBMkMsbUJBQU8sQ0FBQyxrSEFBb0I7QUFDdkUsd0JBQXdCO0FBQ3hCLHlDQUF5QyxtQkFBTyxDQUFDLDhHQUFrQjtBQUNuRSxzQkFBc0I7QUFDdEIsa0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvd29uZGVybGFuZG1pdGNoL0Nhc2NhZGVQcm9qZWN0cy9Xb25kZXJWaXRlLWZyb250ZW5kL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL2Rpc3QvY2pzL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Qb3N0Z3Jlc3RFcnJvciA9IGV4cG9ydHMuUG9zdGdyZXN0QnVpbGRlciA9IGV4cG9ydHMuUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlciA9IGV4cG9ydHMuUG9zdGdyZXN0RmlsdGVyQnVpbGRlciA9IGV4cG9ydHMuUG9zdGdyZXN0UXVlcnlCdWlsZGVyID0gZXhwb3J0cy5Qb3N0Z3Jlc3RDbGllbnQgPSB2b2lkIDA7XG4vLyBBbHdheXMgdXBkYXRlIHdyYXBwZXIubWpzIHdoZW4gdXBkYXRpbmcgdGhpcyBmaWxlLlxuY29uc3QgUG9zdGdyZXN0Q2xpZW50XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vUG9zdGdyZXN0Q2xpZW50XCIpKTtcbmV4cG9ydHMuUG9zdGdyZXN0Q2xpZW50ID0gUG9zdGdyZXN0Q2xpZW50XzEuZGVmYXVsdDtcbmNvbnN0IFBvc3RncmVzdFF1ZXJ5QnVpbGRlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1Bvc3RncmVzdFF1ZXJ5QnVpbGRlclwiKSk7XG5leHBvcnRzLlBvc3RncmVzdFF1ZXJ5QnVpbGRlciA9IFBvc3RncmVzdFF1ZXJ5QnVpbGRlcl8xLmRlZmF1bHQ7XG5jb25zdCBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vUG9zdGdyZXN0RmlsdGVyQnVpbGRlclwiKSk7XG5leHBvcnRzLlBvc3RncmVzdEZpbHRlckJ1aWxkZXIgPSBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyXzEuZGVmYXVsdDtcbmNvbnN0IFBvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9Qb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyXCIpKTtcbmV4cG9ydHMuUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlciA9IFBvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXJfMS5kZWZhdWx0O1xuY29uc3QgUG9zdGdyZXN0QnVpbGRlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1Bvc3RncmVzdEJ1aWxkZXJcIikpO1xuZXhwb3J0cy5Qb3N0Z3Jlc3RCdWlsZGVyID0gUG9zdGdyZXN0QnVpbGRlcl8xLmRlZmF1bHQ7XG5jb25zdCBQb3N0Z3Jlc3RFcnJvcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1Bvc3RncmVzdEVycm9yXCIpKTtcbmV4cG9ydHMuUG9zdGdyZXN0RXJyb3IgPSBQb3N0Z3Jlc3RFcnJvcl8xLmRlZmF1bHQ7XG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gICAgUG9zdGdyZXN0Q2xpZW50OiBQb3N0Z3Jlc3RDbGllbnRfMS5kZWZhdWx0LFxuICAgIFBvc3RncmVzdFF1ZXJ5QnVpbGRlcjogUG9zdGdyZXN0UXVlcnlCdWlsZGVyXzEuZGVmYXVsdCxcbiAgICBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyOiBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyXzEuZGVmYXVsdCxcbiAgICBQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyOiBQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyXzEuZGVmYXVsdCxcbiAgICBQb3N0Z3Jlc3RCdWlsZGVyOiBQb3N0Z3Jlc3RCdWlsZGVyXzEuZGVmYXVsdCxcbiAgICBQb3N0Z3Jlc3RFcnJvcjogUG9zdGdyZXN0RXJyb3JfMS5kZWZhdWx0LFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/version.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@supabase/postgrest-js/dist/cjs/version.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.version = void 0;\nexports.version = '0.0.0-automated';\n//# sourceMappingURL=version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL2Rpc3QvY2pzL3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZTtBQUNmLGVBQWU7QUFDZiIsInNvdXJjZXMiOlsiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvV29uZGVyVml0ZS1mcm9udGVuZC9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Bvc3RncmVzdC1qcy9kaXN0L2Nqcy92ZXJzaW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52ZXJzaW9uID0gdm9pZCAwO1xuZXhwb3J0cy52ZXJzaW9uID0gJzAuMC4wLWF1dG9tYXRlZCc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJzaW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/version.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   REALTIME_CHANNEL_STATES: () => (/* binding */ REALTIME_CHANNEL_STATES),\n/* harmony export */   REALTIME_LISTEN_TYPES: () => (/* binding */ REALTIME_LISTEN_TYPES),\n/* harmony export */   REALTIME_POSTGRES_CHANGES_LISTEN_EVENT: () => (/* binding */ REALTIME_POSTGRES_CHANGES_LISTEN_EVENT),\n/* harmony export */   REALTIME_SUBSCRIBE_STATES: () => (/* binding */ REALTIME_SUBSCRIBE_STATES),\n/* harmony export */   \"default\": () => (/* binding */ RealtimeChannel)\n/* harmony export */ });\n/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/constants */ \"(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/constants.js\");\n/* harmony import */ var _lib_push__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/push */ \"(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/push.js\");\n/* harmony import */ var _lib_timer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/timer */ \"(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/timer.js\");\n/* harmony import */ var _RealtimePresence__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./RealtimePresence */ \"(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js\");\n/* harmony import */ var _lib_transformers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/transformers */ \"(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/transformers.js\");\n\n\n\n\n\n\nvar REALTIME_POSTGRES_CHANGES_LISTEN_EVENT;\n(function (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT) {\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"ALL\"] = \"*\";\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"INSERT\"] = \"INSERT\";\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"UPDATE\"] = \"UPDATE\";\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"DELETE\"] = \"DELETE\";\n})(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT || (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = {}));\nvar REALTIME_LISTEN_TYPES;\n(function (REALTIME_LISTEN_TYPES) {\n    REALTIME_LISTEN_TYPES[\"BROADCAST\"] = \"broadcast\";\n    REALTIME_LISTEN_TYPES[\"PRESENCE\"] = \"presence\";\n    REALTIME_LISTEN_TYPES[\"POSTGRES_CHANGES\"] = \"postgres_changes\";\n    REALTIME_LISTEN_TYPES[\"SYSTEM\"] = \"system\";\n})(REALTIME_LISTEN_TYPES || (REALTIME_LISTEN_TYPES = {}));\nvar REALTIME_SUBSCRIBE_STATES;\n(function (REALTIME_SUBSCRIBE_STATES) {\n    REALTIME_SUBSCRIBE_STATES[\"SUBSCRIBED\"] = \"SUBSCRIBED\";\n    REALTIME_SUBSCRIBE_STATES[\"TIMED_OUT\"] = \"TIMED_OUT\";\n    REALTIME_SUBSCRIBE_STATES[\"CLOSED\"] = \"CLOSED\";\n    REALTIME_SUBSCRIBE_STATES[\"CHANNEL_ERROR\"] = \"CHANNEL_ERROR\";\n})(REALTIME_SUBSCRIBE_STATES || (REALTIME_SUBSCRIBE_STATES = {}));\nconst REALTIME_CHANNEL_STATES = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES;\n/** A channel is the basic building block of Realtime\n * and narrows the scope of data flow to subscribed clients.\n * You can think of a channel as a chatroom where participants are able to see who's online\n * and send and receive messages.\n */\nclass RealtimeChannel {\n    constructor(\n    /** Topic name can be any string. */\n    topic, params = { config: {} }, socket) {\n        this.topic = topic;\n        this.params = params;\n        this.socket = socket;\n        this.bindings = {};\n        this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.closed;\n        this.joinedOnce = false;\n        this.pushBuffer = [];\n        this.subTopic = topic.replace(/^realtime:/i, '');\n        this.params.config = Object.assign({\n            broadcast: { ack: false, self: false },\n            presence: { key: '' },\n            private: false,\n        }, params.config);\n        this.timeout = this.socket.timeout;\n        this.joinPush = new _lib_push__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this, _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS.join, this.params, this.timeout);\n        this.rejoinTimer = new _lib_timer__WEBPACK_IMPORTED_MODULE_2__[\"default\"](() => this._rejoinUntilConnected(), this.socket.reconnectAfterMs);\n        this.joinPush.receive('ok', () => {\n            this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.joined;\n            this.rejoinTimer.reset();\n            this.pushBuffer.forEach((pushEvent) => pushEvent.send());\n            this.pushBuffer = [];\n        });\n        this._onClose(() => {\n            this.rejoinTimer.reset();\n            this.socket.log('channel', `close ${this.topic} ${this._joinRef()}`);\n            this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.closed;\n            this.socket._remove(this);\n        });\n        this._onError((reason) => {\n            if (this._isLeaving() || this._isClosed()) {\n                return;\n            }\n            this.socket.log('channel', `error ${this.topic}`, reason);\n            this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.errored;\n            this.rejoinTimer.scheduleTimeout();\n        });\n        this.joinPush.receive('timeout', () => {\n            if (!this._isJoining()) {\n                return;\n            }\n            this.socket.log('channel', `timeout ${this.topic}`, this.joinPush.timeout);\n            this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.errored;\n            this.rejoinTimer.scheduleTimeout();\n        });\n        this._on(_lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS.reply, {}, (payload, ref) => {\n            this._trigger(this._replyEventName(ref), payload);\n        });\n        this.presence = new _RealtimePresence__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this);\n        this.broadcastEndpointURL =\n            (0,_lib_transformers__WEBPACK_IMPORTED_MODULE_4__.httpEndpointURL)(this.socket.endPoint) + '/api/broadcast';\n        this.private = this.params.config.private || false;\n    }\n    /** Subscribe registers your client with the server */\n    subscribe(callback, timeout = this.timeout) {\n        var _a, _b;\n        if (!this.socket.isConnected()) {\n            this.socket.connect();\n        }\n        if (this.joinedOnce) {\n            throw `tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance`;\n        }\n        else {\n            const { config: { broadcast, presence, private: isPrivate }, } = this.params;\n            this._onError((e) => callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, e));\n            this._onClose(() => callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CLOSED));\n            const accessTokenPayload = {};\n            const config = {\n                broadcast,\n                presence,\n                postgres_changes: (_b = (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.map((r) => r.filter)) !== null && _b !== void 0 ? _b : [],\n                private: isPrivate,\n            };\n            if (this.socket.accessTokenValue) {\n                accessTokenPayload.access_token = this.socket.accessTokenValue;\n            }\n            this.updateJoinPayload(Object.assign({ config }, accessTokenPayload));\n            this.joinedOnce = true;\n            this._rejoin(timeout);\n            this.joinPush\n                .receive('ok', async ({ postgres_changes }) => {\n                var _a;\n                this.socket.setAuth();\n                if (postgres_changes === undefined) {\n                    callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);\n                    return;\n                }\n                else {\n                    const clientPostgresBindings = this.bindings.postgres_changes;\n                    const bindingsLen = (_a = clientPostgresBindings === null || clientPostgresBindings === void 0 ? void 0 : clientPostgresBindings.length) !== null && _a !== void 0 ? _a : 0;\n                    const newPostgresBindings = [];\n                    for (let i = 0; i < bindingsLen; i++) {\n                        const clientPostgresBinding = clientPostgresBindings[i];\n                        const { filter: { event, schema, table, filter }, } = clientPostgresBinding;\n                        const serverPostgresFilter = postgres_changes && postgres_changes[i];\n                        if (serverPostgresFilter &&\n                            serverPostgresFilter.event === event &&\n                            serverPostgresFilter.schema === schema &&\n                            serverPostgresFilter.table === table &&\n                            serverPostgresFilter.filter === filter) {\n                            newPostgresBindings.push(Object.assign(Object.assign({}, clientPostgresBinding), { id: serverPostgresFilter.id }));\n                        }\n                        else {\n                            this.unsubscribe();\n                            callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error('mismatch between server and client bindings for postgres changes'));\n                            return;\n                        }\n                    }\n                    this.bindings.postgres_changes = newPostgresBindings;\n                    callback && callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);\n                    return;\n                }\n            })\n                .receive('error', (error) => {\n                callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error(JSON.stringify(Object.values(error).join(', ') || 'error')));\n                return;\n            })\n                .receive('timeout', () => {\n                callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.TIMED_OUT);\n                return;\n            });\n        }\n        return this;\n    }\n    presenceState() {\n        return this.presence.state;\n    }\n    async track(payload, opts = {}) {\n        return await this.send({\n            type: 'presence',\n            event: 'track',\n            payload,\n        }, opts.timeout || this.timeout);\n    }\n    async untrack(opts = {}) {\n        return await this.send({\n            type: 'presence',\n            event: 'untrack',\n        }, opts);\n    }\n    on(type, filter, callback) {\n        return this._on(type, filter, callback);\n    }\n    /**\n     * Sends a message into the channel.\n     *\n     * @param args Arguments to send to channel\n     * @param args.type The type of event to send\n     * @param args.event The name of the event being sent\n     * @param args.payload Payload to be sent\n     * @param opts Options to be used during the send process\n     */\n    async send(args, opts = {}) {\n        var _a, _b;\n        if (!this._canPush() && args.type === 'broadcast') {\n            const { event, payload: endpoint_payload } = args;\n            const authorization = this.socket.accessTokenValue\n                ? `Bearer ${this.socket.accessTokenValue}`\n                : '';\n            const options = {\n                method: 'POST',\n                headers: {\n                    Authorization: authorization,\n                    apikey: this.socket.apiKey ? this.socket.apiKey : '',\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({\n                    messages: [\n                        {\n                            topic: this.subTopic,\n                            event,\n                            payload: endpoint_payload,\n                            private: this.private,\n                        },\n                    ],\n                }),\n            };\n            try {\n                const response = await this._fetchWithTimeout(this.broadcastEndpointURL, options, (_a = opts.timeout) !== null && _a !== void 0 ? _a : this.timeout);\n                await ((_b = response.body) === null || _b === void 0 ? void 0 : _b.cancel());\n                return response.ok ? 'ok' : 'error';\n            }\n            catch (error) {\n                if (error.name === 'AbortError') {\n                    return 'timed out';\n                }\n                else {\n                    return 'error';\n                }\n            }\n        }\n        else {\n            return new Promise((resolve) => {\n                var _a, _b, _c;\n                const push = this._push(args.type, args, opts.timeout || this.timeout);\n                if (args.type === 'broadcast' && !((_c = (_b = (_a = this.params) === null || _a === void 0 ? void 0 : _a.config) === null || _b === void 0 ? void 0 : _b.broadcast) === null || _c === void 0 ? void 0 : _c.ack)) {\n                    resolve('ok');\n                }\n                push.receive('ok', () => resolve('ok'));\n                push.receive('error', () => resolve('error'));\n                push.receive('timeout', () => resolve('timed out'));\n            });\n        }\n    }\n    updateJoinPayload(payload) {\n        this.joinPush.updatePayload(payload);\n    }\n    /**\n     * Leaves the channel.\n     *\n     * Unsubscribes from server events, and instructs channel to terminate on server.\n     * Triggers onClose() hooks.\n     *\n     * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\n     * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\n     */\n    unsubscribe(timeout = this.timeout) {\n        this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.leaving;\n        const onClose = () => {\n            this.socket.log('channel', `leave ${this.topic}`);\n            this._trigger(_lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS.close, 'leave', this._joinRef());\n        };\n        this.rejoinTimer.reset();\n        // Destroy joinPush to avoid connection timeouts during unscription phase\n        this.joinPush.destroy();\n        return new Promise((resolve) => {\n            const leavePush = new _lib_push__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this, _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS.leave, {}, timeout);\n            leavePush\n                .receive('ok', () => {\n                onClose();\n                resolve('ok');\n            })\n                .receive('timeout', () => {\n                onClose();\n                resolve('timed out');\n            })\n                .receive('error', () => {\n                resolve('error');\n            });\n            leavePush.send();\n            if (!this._canPush()) {\n                leavePush.trigger('ok', {});\n            }\n        });\n    }\n    /** @internal */\n    async _fetchWithTimeout(url, options, timeout) {\n        const controller = new AbortController();\n        const id = setTimeout(() => controller.abort(), timeout);\n        const response = await this.socket.fetch(url, Object.assign(Object.assign({}, options), { signal: controller.signal }));\n        clearTimeout(id);\n        return response;\n    }\n    /** @internal */\n    _push(event, payload, timeout = this.timeout) {\n        if (!this.joinedOnce) {\n            throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;\n        }\n        let pushEvent = new _lib_push__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this, event, payload, timeout);\n        if (this._canPush()) {\n            pushEvent.send();\n        }\n        else {\n            pushEvent.startTimeout();\n            this.pushBuffer.push(pushEvent);\n        }\n        return pushEvent;\n    }\n    /**\n     * Overridable message hook\n     *\n     * Receives all events for specialized message handling before dispatching to the channel callbacks.\n     * Must return the payload, modified or unmodified.\n     *\n     * @internal\n     */\n    _onMessage(_event, payload, _ref) {\n        return payload;\n    }\n    /** @internal */\n    _isMember(topic) {\n        return this.topic === topic;\n    }\n    /** @internal */\n    _joinRef() {\n        return this.joinPush.ref;\n    }\n    /** @internal */\n    _trigger(type, payload, ref) {\n        var _a, _b;\n        const typeLower = type.toLocaleLowerCase();\n        const { close, error, leave, join } = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS;\n        const events = [close, error, leave, join];\n        if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {\n            return;\n        }\n        let handledPayload = this._onMessage(typeLower, payload, ref);\n        if (payload && !handledPayload) {\n            throw 'channel onMessage callbacks must return the payload, modified or unmodified';\n        }\n        if (['insert', 'update', 'delete'].includes(typeLower)) {\n            (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.filter((bind) => {\n                var _a, _b, _c;\n                return (((_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event) === '*' ||\n                    ((_c = (_b = bind.filter) === null || _b === void 0 ? void 0 : _b.event) === null || _c === void 0 ? void 0 : _c.toLocaleLowerCase()) === typeLower);\n            }).map((bind) => bind.callback(handledPayload, ref));\n        }\n        else {\n            (_b = this.bindings[typeLower]) === null || _b === void 0 ? void 0 : _b.filter((bind) => {\n                var _a, _b, _c, _d, _e, _f;\n                if (['broadcast', 'presence', 'postgres_changes'].includes(typeLower)) {\n                    if ('id' in bind) {\n                        const bindId = bind.id;\n                        const bindEvent = (_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event;\n                        return (bindId &&\n                            ((_b = payload.ids) === null || _b === void 0 ? void 0 : _b.includes(bindId)) &&\n                            (bindEvent === '*' ||\n                                (bindEvent === null || bindEvent === void 0 ? void 0 : bindEvent.toLocaleLowerCase()) ===\n                                    ((_c = payload.data) === null || _c === void 0 ? void 0 : _c.type.toLocaleLowerCase())));\n                    }\n                    else {\n                        const bindEvent = (_e = (_d = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _d === void 0 ? void 0 : _d.event) === null || _e === void 0 ? void 0 : _e.toLocaleLowerCase();\n                        return (bindEvent === '*' ||\n                            bindEvent === ((_f = payload === null || payload === void 0 ? void 0 : payload.event) === null || _f === void 0 ? void 0 : _f.toLocaleLowerCase()));\n                    }\n                }\n                else {\n                    return bind.type.toLocaleLowerCase() === typeLower;\n                }\n            }).map((bind) => {\n                if (typeof handledPayload === 'object' && 'ids' in handledPayload) {\n                    const postgresChanges = handledPayload.data;\n                    const { schema, table, commit_timestamp, type, errors } = postgresChanges;\n                    const enrichedPayload = {\n                        schema: schema,\n                        table: table,\n                        commit_timestamp: commit_timestamp,\n                        eventType: type,\n                        new: {},\n                        old: {},\n                        errors: errors,\n                    };\n                    handledPayload = Object.assign(Object.assign({}, enrichedPayload), this._getPayloadRecords(postgresChanges));\n                }\n                bind.callback(handledPayload, ref);\n            });\n        }\n    }\n    /** @internal */\n    _isClosed() {\n        return this.state === _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.closed;\n    }\n    /** @internal */\n    _isJoined() {\n        return this.state === _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.joined;\n    }\n    /** @internal */\n    _isJoining() {\n        return this.state === _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.joining;\n    }\n    /** @internal */\n    _isLeaving() {\n        return this.state === _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.leaving;\n    }\n    /** @internal */\n    _replyEventName(ref) {\n        return `chan_reply_${ref}`;\n    }\n    /** @internal */\n    _on(type, filter, callback) {\n        const typeLower = type.toLocaleLowerCase();\n        const binding = {\n            type: typeLower,\n            filter: filter,\n            callback: callback,\n        };\n        if (this.bindings[typeLower]) {\n            this.bindings[typeLower].push(binding);\n        }\n        else {\n            this.bindings[typeLower] = [binding];\n        }\n        return this;\n    }\n    /** @internal */\n    _off(type, filter) {\n        const typeLower = type.toLocaleLowerCase();\n        this.bindings[typeLower] = this.bindings[typeLower].filter((bind) => {\n            var _a;\n            return !(((_a = bind.type) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) === typeLower &&\n                RealtimeChannel.isEqual(bind.filter, filter));\n        });\n        return this;\n    }\n    /** @internal */\n    static isEqual(obj1, obj2) {\n        if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n            return false;\n        }\n        for (const k in obj1) {\n            if (obj1[k] !== obj2[k]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /** @internal */\n    _rejoinUntilConnected() {\n        this.rejoinTimer.scheduleTimeout();\n        if (this.socket.isConnected()) {\n            this._rejoin();\n        }\n    }\n    /**\n     * Registers a callback that will be executed when the channel closes.\n     *\n     * @internal\n     */\n    _onClose(callback) {\n        this._on(_lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS.close, {}, callback);\n    }\n    /**\n     * Registers a callback that will be executed when the channel encounteres an error.\n     *\n     * @internal\n     */\n    _onError(callback) {\n        this._on(_lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS.error, {}, (reason) => callback(reason));\n    }\n    /**\n     * Returns `true` if the socket is connected and the channel has been joined.\n     *\n     * @internal\n     */\n    _canPush() {\n        return this.socket.isConnected() && this._isJoined();\n    }\n    /** @internal */\n    _rejoin(timeout = this.timeout) {\n        if (this._isLeaving()) {\n            return;\n        }\n        this.socket._leaveOpenTopic(this.topic);\n        this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.joining;\n        this.joinPush.resend(timeout);\n    }\n    /** @internal */\n    _getPayloadRecords(payload) {\n        const records = {\n            new: {},\n            old: {},\n        };\n        if (payload.type === 'INSERT' || payload.type === 'UPDATE') {\n            records.new = _lib_transformers__WEBPACK_IMPORTED_MODULE_4__.convertChangeData(payload.columns, payload.record);\n        }\n        if (payload.type === 'UPDATE' || payload.type === 'DELETE') {\n            records.old = _lib_transformers__WEBPACK_IMPORTED_MODULE_4__.convertChangeData(payload.columns, payload.old_record);\n        }\n        return records;\n    }\n}\n//# sourceMappingURL=RealtimeChannel.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvUmVhbHRpbWVDaGFubmVsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBaUU7QUFDbkM7QUFDRTtBQUNrQjtBQUNDO0FBQ0U7QUFDOUM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3RkFBd0Y7QUFDbEY7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzREFBc0Q7QUFDaEQ7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4REFBOEQ7QUFDeEQsZ0NBQWdDLDBEQUFjO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwwREFBYztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix5QkFBeUI7QUFDbEQsd0JBQXdCLFNBQVM7QUFDakM7QUFDQSxTQUFTO0FBQ1Q7QUFDQSw0QkFBNEIsaURBQUksT0FBTywwREFBYztBQUNyRCwrQkFBK0Isa0RBQUs7QUFDcEM7QUFDQSx5QkFBeUIsMERBQWM7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWSxFQUFFLGdCQUFnQjtBQUM5RSx5QkFBeUIsMERBQWM7QUFDdkM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsV0FBVztBQUMzRCx5QkFBeUIsMERBQWM7QUFDdkM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsV0FBVztBQUM3RCx5QkFBeUIsMERBQWM7QUFDdkM7QUFDQSxTQUFTO0FBQ1QsaUJBQWlCLDBEQUFjLFVBQVU7QUFDekM7QUFDQSxTQUFTO0FBQ1QsNEJBQTRCLHlEQUFnQjtBQUM1QztBQUNBLFlBQVksa0VBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVUseUNBQXlDLElBQUk7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFFBQVE7QUFDM0Q7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGtCQUFrQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxpQkFBaUI7QUFDckQ7QUFDQSxnQ0FBZ0MsVUFBVSw4QkFBOEIsSUFBSTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsNEJBQTRCLDZCQUE2QjtBQUM1STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0Esb0JBQW9CLG1DQUFtQztBQUN2RDtBQUNBLDRCQUE0Qiw2QkFBNkI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDBEQUFjO0FBQ25DO0FBQ0EsZ0RBQWdELFdBQVc7QUFDM0QsMEJBQTBCLDBEQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsaURBQUksT0FBTywwREFBYyxVQUFVO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRixjQUFjLDJCQUEyQjtBQUM3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsTUFBTSxRQUFRLFdBQVc7QUFDN0Q7QUFDQSw0QkFBNEIsaURBQUk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0QkFBNEIsRUFBRSwwREFBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSw0QkFBNEIsZ0RBQWdEO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwwREFBYztBQUM1QztBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMERBQWM7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDBEQUFjO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwwREFBYztBQUM1QztBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsSUFBSTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDBEQUFjLFVBQVU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMERBQWMsVUFBVTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMERBQWM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLDBCQUEwQixnRUFBOEI7QUFDeEQ7QUFDQTtBQUNBLDBCQUEwQixnRUFBOEI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvV29uZGVyVml0ZS1mcm9udGVuZC9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL1JlYWx0aW1lQ2hhbm5lbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDSEFOTkVMX0VWRU5UUywgQ0hBTk5FTF9TVEFURVMgfSBmcm9tICcuL2xpYi9jb25zdGFudHMnO1xuaW1wb3J0IFB1c2ggZnJvbSAnLi9saWIvcHVzaCc7XG5pbXBvcnQgVGltZXIgZnJvbSAnLi9saWIvdGltZXInO1xuaW1wb3J0IFJlYWx0aW1lUHJlc2VuY2UgZnJvbSAnLi9SZWFsdGltZVByZXNlbmNlJztcbmltcG9ydCAqIGFzIFRyYW5zZm9ybWVycyBmcm9tICcuL2xpYi90cmFuc2Zvcm1lcnMnO1xuaW1wb3J0IHsgaHR0cEVuZHBvaW50VVJMIH0gZnJvbSAnLi9saWIvdHJhbnNmb3JtZXJzJztcbmV4cG9ydCB2YXIgUkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlQ7XG4oZnVuY3Rpb24gKFJFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5UKSB7XG4gICAgUkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlRbXCJBTExcIl0gPSBcIipcIjtcbiAgICBSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVFtcIklOU0VSVFwiXSA9IFwiSU5TRVJUXCI7XG4gICAgUkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlRbXCJVUERBVEVcIl0gPSBcIlVQREFURVwiO1xuICAgIFJFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5UW1wiREVMRVRFXCJdID0gXCJERUxFVEVcIjtcbn0pKFJFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5UIHx8IChSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVCA9IHt9KSk7XG5leHBvcnQgdmFyIFJFQUxUSU1FX0xJU1RFTl9UWVBFUztcbihmdW5jdGlvbiAoUkVBTFRJTUVfTElTVEVOX1RZUEVTKSB7XG4gICAgUkVBTFRJTUVfTElTVEVOX1RZUEVTW1wiQlJPQURDQVNUXCJdID0gXCJicm9hZGNhc3RcIjtcbiAgICBSRUFMVElNRV9MSVNURU5fVFlQRVNbXCJQUkVTRU5DRVwiXSA9IFwicHJlc2VuY2VcIjtcbiAgICBSRUFMVElNRV9MSVNURU5fVFlQRVNbXCJQT1NUR1JFU19DSEFOR0VTXCJdID0gXCJwb3N0Z3Jlc19jaGFuZ2VzXCI7XG4gICAgUkVBTFRJTUVfTElTVEVOX1RZUEVTW1wiU1lTVEVNXCJdID0gXCJzeXN0ZW1cIjtcbn0pKFJFQUxUSU1FX0xJU1RFTl9UWVBFUyB8fCAoUkVBTFRJTUVfTElTVEVOX1RZUEVTID0ge30pKTtcbmV4cG9ydCB2YXIgUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUztcbihmdW5jdGlvbiAoUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUykge1xuICAgIFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVNbXCJTVUJTQ1JJQkVEXCJdID0gXCJTVUJTQ1JJQkVEXCI7XG4gICAgUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFU1tcIlRJTUVEX09VVFwiXSA9IFwiVElNRURfT1VUXCI7XG4gICAgUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFU1tcIkNMT1NFRFwiXSA9IFwiQ0xPU0VEXCI7XG4gICAgUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFU1tcIkNIQU5ORUxfRVJST1JcIl0gPSBcIkNIQU5ORUxfRVJST1JcIjtcbn0pKFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMgfHwgKFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMgPSB7fSkpO1xuZXhwb3J0IGNvbnN0IFJFQUxUSU1FX0NIQU5ORUxfU1RBVEVTID0gQ0hBTk5FTF9TVEFURVM7XG4vKiogQSBjaGFubmVsIGlzIHRoZSBiYXNpYyBidWlsZGluZyBibG9jayBvZiBSZWFsdGltZVxuICogYW5kIG5hcnJvd3MgdGhlIHNjb3BlIG9mIGRhdGEgZmxvdyB0byBzdWJzY3JpYmVkIGNsaWVudHMuXG4gKiBZb3UgY2FuIHRoaW5rIG9mIGEgY2hhbm5lbCBhcyBhIGNoYXRyb29tIHdoZXJlIHBhcnRpY2lwYW50cyBhcmUgYWJsZSB0byBzZWUgd2hvJ3Mgb25saW5lXG4gKiBhbmQgc2VuZCBhbmQgcmVjZWl2ZSBtZXNzYWdlcy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVhbHRpbWVDaGFubmVsIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKiogVG9waWMgbmFtZSBjYW4gYmUgYW55IHN0cmluZy4gKi9cbiAgICB0b3BpYywgcGFyYW1zID0geyBjb25maWc6IHt9IH0sIHNvY2tldCkge1xuICAgICAgICB0aGlzLnRvcGljID0gdG9waWM7XG4gICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgICAgICB0aGlzLnNvY2tldCA9IHNvY2tldDtcbiAgICAgICAgdGhpcy5iaW5kaW5ncyA9IHt9O1xuICAgICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuY2xvc2VkO1xuICAgICAgICB0aGlzLmpvaW5lZE9uY2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wdXNoQnVmZmVyID0gW107XG4gICAgICAgIHRoaXMuc3ViVG9waWMgPSB0b3BpYy5yZXBsYWNlKC9ecmVhbHRpbWU6L2ksICcnKTtcbiAgICAgICAgdGhpcy5wYXJhbXMuY29uZmlnID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBicm9hZGNhc3Q6IHsgYWNrOiBmYWxzZSwgc2VsZjogZmFsc2UgfSxcbiAgICAgICAgICAgIHByZXNlbmNlOiB7IGtleTogJycgfSxcbiAgICAgICAgICAgIHByaXZhdGU6IGZhbHNlLFxuICAgICAgICB9LCBwYXJhbXMuY29uZmlnKTtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gdGhpcy5zb2NrZXQudGltZW91dDtcbiAgICAgICAgdGhpcy5qb2luUHVzaCA9IG5ldyBQdXNoKHRoaXMsIENIQU5ORUxfRVZFTlRTLmpvaW4sIHRoaXMucGFyYW1zLCB0aGlzLnRpbWVvdXQpO1xuICAgICAgICB0aGlzLnJlam9pblRpbWVyID0gbmV3IFRpbWVyKCgpID0+IHRoaXMuX3Jlam9pblVudGlsQ29ubmVjdGVkKCksIHRoaXMuc29ja2V0LnJlY29ubmVjdEFmdGVyTXMpO1xuICAgICAgICB0aGlzLmpvaW5QdXNoLnJlY2VpdmUoJ29rJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmpvaW5lZDtcbiAgICAgICAgICAgIHRoaXMucmVqb2luVGltZXIucmVzZXQoKTtcbiAgICAgICAgICAgIHRoaXMucHVzaEJ1ZmZlci5mb3JFYWNoKChwdXNoRXZlbnQpID0+IHB1c2hFdmVudC5zZW5kKCkpO1xuICAgICAgICAgICAgdGhpcy5wdXNoQnVmZmVyID0gW107XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9vbkNsb3NlKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVqb2luVGltZXIucmVzZXQoKTtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0LmxvZygnY2hhbm5lbCcsIGBjbG9zZSAke3RoaXMudG9waWN9ICR7dGhpcy5fam9pblJlZigpfWApO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmNsb3NlZDtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0Ll9yZW1vdmUodGhpcyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9vbkVycm9yKChyZWFzb24pID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0xlYXZpbmcoKSB8fCB0aGlzLl9pc0Nsb3NlZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zb2NrZXQubG9nKCdjaGFubmVsJywgYGVycm9yICR7dGhpcy50b3BpY31gLCByZWFzb24pO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmVycm9yZWQ7XG4gICAgICAgICAgICB0aGlzLnJlam9pblRpbWVyLnNjaGVkdWxlVGltZW91dCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5qb2luUHVzaC5yZWNlaXZlKCd0aW1lb3V0JywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc0pvaW5pbmcoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc29ja2V0LmxvZygnY2hhbm5lbCcsIGB0aW1lb3V0ICR7dGhpcy50b3BpY31gLCB0aGlzLmpvaW5QdXNoLnRpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmVycm9yZWQ7XG4gICAgICAgICAgICB0aGlzLnJlam9pblRpbWVyLnNjaGVkdWxlVGltZW91dCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fb24oQ0hBTk5FTF9FVkVOVFMucmVwbHksIHt9LCAocGF5bG9hZCwgcmVmKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl90cmlnZ2VyKHRoaXMuX3JlcGx5RXZlbnROYW1lKHJlZiksIHBheWxvYWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wcmVzZW5jZSA9IG5ldyBSZWFsdGltZVByZXNlbmNlKHRoaXMpO1xuICAgICAgICB0aGlzLmJyb2FkY2FzdEVuZHBvaW50VVJMID1cbiAgICAgICAgICAgIGh0dHBFbmRwb2ludFVSTCh0aGlzLnNvY2tldC5lbmRQb2ludCkgKyAnL2FwaS9icm9hZGNhc3QnO1xuICAgICAgICB0aGlzLnByaXZhdGUgPSB0aGlzLnBhcmFtcy5jb25maWcucHJpdmF0ZSB8fCBmYWxzZTtcbiAgICB9XG4gICAgLyoqIFN1YnNjcmliZSByZWdpc3RlcnMgeW91ciBjbGllbnQgd2l0aCB0aGUgc2VydmVyICovXG4gICAgc3Vic2NyaWJlKGNhbGxiYWNrLCB0aW1lb3V0ID0gdGhpcy50aW1lb3V0KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICghdGhpcy5zb2NrZXQuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQuY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmpvaW5lZE9uY2UpIHtcbiAgICAgICAgICAgIHRocm93IGB0cmllZCB0byBzdWJzY3JpYmUgbXVsdGlwbGUgdGltZXMuICdzdWJzY3JpYmUnIGNhbiBvbmx5IGJlIGNhbGxlZCBhIHNpbmdsZSB0aW1lIHBlciBjaGFubmVsIGluc3RhbmNlYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHsgY29uZmlnOiB7IGJyb2FkY2FzdCwgcHJlc2VuY2UsIHByaXZhdGU6IGlzUHJpdmF0ZSB9LCB9ID0gdGhpcy5wYXJhbXM7XG4gICAgICAgICAgICB0aGlzLl9vbkVycm9yKChlKSA9PiBjYWxsYmFjayA9PT0gbnVsbCB8fCBjYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2soUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUy5DSEFOTkVMX0VSUk9SLCBlKSk7XG4gICAgICAgICAgICB0aGlzLl9vbkNsb3NlKCgpID0+IGNhbGxiYWNrID09PSBudWxsIHx8IGNhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFjayhSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTLkNMT1NFRCkpO1xuICAgICAgICAgICAgY29uc3QgYWNjZXNzVG9rZW5QYXlsb2FkID0ge307XG4gICAgICAgICAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICAgICAgICAgICAgYnJvYWRjYXN0LFxuICAgICAgICAgICAgICAgIHByZXNlbmNlLFxuICAgICAgICAgICAgICAgIHBvc3RncmVzX2NoYW5nZXM6IChfYiA9IChfYSA9IHRoaXMuYmluZGluZ3MucG9zdGdyZXNfY2hhbmdlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcCgocikgPT4gci5maWx0ZXIpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXSxcbiAgICAgICAgICAgICAgICBwcml2YXRlOiBpc1ByaXZhdGUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRoaXMuc29ja2V0LmFjY2Vzc1Rva2VuVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBhY2Nlc3NUb2tlblBheWxvYWQuYWNjZXNzX3Rva2VuID0gdGhpcy5zb2NrZXQuYWNjZXNzVG9rZW5WYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudXBkYXRlSm9pblBheWxvYWQoT2JqZWN0LmFzc2lnbih7IGNvbmZpZyB9LCBhY2Nlc3NUb2tlblBheWxvYWQpKTtcbiAgICAgICAgICAgIHRoaXMuam9pbmVkT25jZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9yZWpvaW4odGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLmpvaW5QdXNoXG4gICAgICAgICAgICAgICAgLnJlY2VpdmUoJ29rJywgYXN5bmMgKHsgcG9zdGdyZXNfY2hhbmdlcyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0LnNldEF1dGgoKTtcbiAgICAgICAgICAgICAgICBpZiAocG9zdGdyZXNfY2hhbmdlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID09PSBudWxsIHx8IGNhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFjayhSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTLlNVQlNDUklCRUQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjbGllbnRQb3N0Z3Jlc0JpbmRpbmdzID0gdGhpcy5iaW5kaW5ncy5wb3N0Z3Jlc19jaGFuZ2VzO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBiaW5kaW5nc0xlbiA9IChfYSA9IGNsaWVudFBvc3RncmVzQmluZGluZ3MgPT09IG51bGwgfHwgY2xpZW50UG9zdGdyZXNCaW5kaW5ncyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2xpZW50UG9zdGdyZXNCaW5kaW5ncy5sZW5ndGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1Bvc3RncmVzQmluZGluZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW5kaW5nc0xlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjbGllbnRQb3N0Z3Jlc0JpbmRpbmcgPSBjbGllbnRQb3N0Z3Jlc0JpbmRpbmdzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBmaWx0ZXI6IHsgZXZlbnQsIHNjaGVtYSwgdGFibGUsIGZpbHRlciB9LCB9ID0gY2xpZW50UG9zdGdyZXNCaW5kaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VydmVyUG9zdGdyZXNGaWx0ZXIgPSBwb3N0Z3Jlc19jaGFuZ2VzICYmIHBvc3RncmVzX2NoYW5nZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VydmVyUG9zdGdyZXNGaWx0ZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJQb3N0Z3Jlc0ZpbHRlci5ldmVudCA9PT0gZXZlbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJQb3N0Z3Jlc0ZpbHRlci5zY2hlbWEgPT09IHNjaGVtYSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlclBvc3RncmVzRmlsdGVyLnRhYmxlID09PSB0YWJsZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlclBvc3RncmVzRmlsdGVyLmZpbHRlciA9PT0gZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3UG9zdGdyZXNCaW5kaW5ncy5wdXNoKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY2xpZW50UG9zdGdyZXNCaW5kaW5nKSwgeyBpZDogc2VydmVyUG9zdGdyZXNGaWx0ZXIuaWQgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID09PSBudWxsIHx8IGNhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFjayhSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTLkNIQU5ORUxfRVJST1IsIG5ldyBFcnJvcignbWlzbWF0Y2ggYmV0d2VlbiBzZXJ2ZXIgYW5kIGNsaWVudCBiaW5kaW5ncyBmb3IgcG9zdGdyZXMgY2hhbmdlcycpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iaW5kaW5ncy5wb3N0Z3Jlc19jaGFuZ2VzID0gbmV3UG9zdGdyZXNCaW5kaW5ncztcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUy5TVUJTQ1JJQkVEKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnJlY2VpdmUoJ2Vycm9yJywgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPT09IG51bGwgfHwgY2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrKFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMuQ0hBTk5FTF9FUlJPUiwgbmV3IEVycm9yKEpTT04uc3RyaW5naWZ5KE9iamVjdC52YWx1ZXMoZXJyb3IpLmpvaW4oJywgJykgfHwgJ2Vycm9yJykpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5yZWNlaXZlKCd0aW1lb3V0JywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID09PSBudWxsIHx8IGNhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFjayhSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTLlRJTUVEX09VVCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHByZXNlbmNlU3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZXNlbmNlLnN0YXRlO1xuICAgIH1cbiAgICBhc3luYyB0cmFjayhwYXlsb2FkLCBvcHRzID0ge30pIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VuZCh7XG4gICAgICAgICAgICB0eXBlOiAncHJlc2VuY2UnLFxuICAgICAgICAgICAgZXZlbnQ6ICd0cmFjaycsXG4gICAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICB9LCBvcHRzLnRpbWVvdXQgfHwgdGhpcy50aW1lb3V0KTtcbiAgICB9XG4gICAgYXN5bmMgdW50cmFjayhvcHRzID0ge30pIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VuZCh7XG4gICAgICAgICAgICB0eXBlOiAncHJlc2VuY2UnLFxuICAgICAgICAgICAgZXZlbnQ6ICd1bnRyYWNrJyxcbiAgICAgICAgfSwgb3B0cyk7XG4gICAgfVxuICAgIG9uKHR5cGUsIGZpbHRlciwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uKHR5cGUsIGZpbHRlciwgY2FsbGJhY2spO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIG1lc3NhZ2UgaW50byB0aGUgY2hhbm5lbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmdzIEFyZ3VtZW50cyB0byBzZW5kIHRvIGNoYW5uZWxcbiAgICAgKiBAcGFyYW0gYXJncy50eXBlIFRoZSB0eXBlIG9mIGV2ZW50IHRvIHNlbmRcbiAgICAgKiBAcGFyYW0gYXJncy5ldmVudCBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgYmVpbmcgc2VudFxuICAgICAqIEBwYXJhbSBhcmdzLnBheWxvYWQgUGF5bG9hZCB0byBiZSBzZW50XG4gICAgICogQHBhcmFtIG9wdHMgT3B0aW9ucyB0byBiZSB1c2VkIGR1cmluZyB0aGUgc2VuZCBwcm9jZXNzXG4gICAgICovXG4gICAgYXN5bmMgc2VuZChhcmdzLCBvcHRzID0ge30pIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKCF0aGlzLl9jYW5QdXNoKCkgJiYgYXJncy50eXBlID09PSAnYnJvYWRjYXN0Jykge1xuICAgICAgICAgICAgY29uc3QgeyBldmVudCwgcGF5bG9hZDogZW5kcG9pbnRfcGF5bG9hZCB9ID0gYXJncztcbiAgICAgICAgICAgIGNvbnN0IGF1dGhvcml6YXRpb24gPSB0aGlzLnNvY2tldC5hY2Nlc3NUb2tlblZhbHVlXG4gICAgICAgICAgICAgICAgPyBgQmVhcmVyICR7dGhpcy5zb2NrZXQuYWNjZXNzVG9rZW5WYWx1ZX1gXG4gICAgICAgICAgICAgICAgOiAnJztcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICBBdXRob3JpemF0aW9uOiBhdXRob3JpemF0aW9uLFxuICAgICAgICAgICAgICAgICAgICBhcGlrZXk6IHRoaXMuc29ja2V0LmFwaUtleSA/IHRoaXMuc29ja2V0LmFwaUtleSA6ICcnLFxuICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlczogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcGljOiB0aGlzLnN1YlRvcGljLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IGVuZHBvaW50X3BheWxvYWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpdmF0ZTogdGhpcy5wcml2YXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fZmV0Y2hXaXRoVGltZW91dCh0aGlzLmJyb2FkY2FzdEVuZHBvaW50VVJMLCBvcHRpb25zLCAoX2EgPSBvcHRzLnRpbWVvdXQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMudGltZW91dCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgKChfYiA9IHJlc3BvbnNlLmJvZHkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYW5jZWwoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLm9rID8gJ29rJyA6ICdlcnJvcic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAndGltZWQgb3V0JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnZXJyb3InO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgICAgIGNvbnN0IHB1c2ggPSB0aGlzLl9wdXNoKGFyZ3MudHlwZSwgYXJncywgb3B0cy50aW1lb3V0IHx8IHRoaXMudGltZW91dCk7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3MudHlwZSA9PT0gJ2Jyb2FkY2FzdCcgJiYgISgoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLnBhcmFtcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmJyb2FkY2FzdCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmFjaykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgnb2snKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHVzaC5yZWNlaXZlKCdvaycsICgpID0+IHJlc29sdmUoJ29rJykpO1xuICAgICAgICAgICAgICAgIHB1c2gucmVjZWl2ZSgnZXJyb3InLCAoKSA9PiByZXNvbHZlKCdlcnJvcicpKTtcbiAgICAgICAgICAgICAgICBwdXNoLnJlY2VpdmUoJ3RpbWVvdXQnLCAoKSA9PiByZXNvbHZlKCd0aW1lZCBvdXQnKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVKb2luUGF5bG9hZChwYXlsb2FkKSB7XG4gICAgICAgIHRoaXMuam9pblB1c2gudXBkYXRlUGF5bG9hZChwYXlsb2FkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGVhdmVzIHRoZSBjaGFubmVsLlxuICAgICAqXG4gICAgICogVW5zdWJzY3JpYmVzIGZyb20gc2VydmVyIGV2ZW50cywgYW5kIGluc3RydWN0cyBjaGFubmVsIHRvIHRlcm1pbmF0ZSBvbiBzZXJ2ZXIuXG4gICAgICogVHJpZ2dlcnMgb25DbG9zZSgpIGhvb2tzLlxuICAgICAqXG4gICAgICogVG8gcmVjZWl2ZSBsZWF2ZSBhY2tub3dsZWRnZW1lbnRzLCB1c2UgdGhlIGEgYHJlY2VpdmVgIGhvb2sgdG8gYmluZCB0byB0aGUgc2VydmVyIGFjaywgaWU6XG4gICAgICogY2hhbm5lbC51bnN1YnNjcmliZSgpLnJlY2VpdmUoXCJva1wiLCAoKSA9PiBhbGVydChcImxlZnQhXCIpIClcbiAgICAgKi9cbiAgICB1bnN1YnNjcmliZSh0aW1lb3V0ID0gdGhpcy50aW1lb3V0KSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5sZWF2aW5nO1xuICAgICAgICBjb25zdCBvbkNsb3NlID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQubG9nKCdjaGFubmVsJywgYGxlYXZlICR7dGhpcy50b3BpY31gKTtcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXIoQ0hBTk5FTF9FVkVOVFMuY2xvc2UsICdsZWF2ZScsIHRoaXMuX2pvaW5SZWYoKSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucmVqb2luVGltZXIucmVzZXQoKTtcbiAgICAgICAgLy8gRGVzdHJveSBqb2luUHVzaCB0byBhdm9pZCBjb25uZWN0aW9uIHRpbWVvdXRzIGR1cmluZyB1bnNjcmlwdGlvbiBwaGFzZVxuICAgICAgICB0aGlzLmpvaW5QdXNoLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsZWF2ZVB1c2ggPSBuZXcgUHVzaCh0aGlzLCBDSEFOTkVMX0VWRU5UUy5sZWF2ZSwge30sIHRpbWVvdXQpO1xuICAgICAgICAgICAgbGVhdmVQdXNoXG4gICAgICAgICAgICAgICAgLnJlY2VpdmUoJ29rJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIG9uQ2xvc2UoKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCdvaycpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAucmVjZWl2ZSgndGltZW91dCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICBvbkNsb3NlKCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgndGltZWQgb3V0Jyk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5yZWNlaXZlKCdlcnJvcicsICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCdlcnJvcicpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZWF2ZVB1c2guc2VuZCgpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9jYW5QdXNoKCkpIHtcbiAgICAgICAgICAgICAgICBsZWF2ZVB1c2gudHJpZ2dlcignb2snLCB7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgYXN5bmMgX2ZldGNoV2l0aFRpbWVvdXQodXJsLCBvcHRpb25zLCB0aW1lb3V0KSB7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIGNvbnN0IGlkID0gc2V0VGltZW91dCgoKSA9PiBjb250cm9sbGVyLmFib3J0KCksIHRpbWVvdXQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuc29ja2V0LmZldGNoKHVybCwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsIH0pKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGlkKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3B1c2goZXZlbnQsIHBheWxvYWQsIHRpbWVvdXQgPSB0aGlzLnRpbWVvdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmpvaW5lZE9uY2UpIHtcbiAgICAgICAgICAgIHRocm93IGB0cmllZCB0byBwdXNoICcke2V2ZW50fScgdG8gJyR7dGhpcy50b3BpY30nIGJlZm9yZSBqb2luaW5nLiBVc2UgY2hhbm5lbC5zdWJzY3JpYmUoKSBiZWZvcmUgcHVzaGluZyBldmVudHNgO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwdXNoRXZlbnQgPSBuZXcgUHVzaCh0aGlzLCBldmVudCwgcGF5bG9hZCwgdGltZW91dCk7XG4gICAgICAgIGlmICh0aGlzLl9jYW5QdXNoKCkpIHtcbiAgICAgICAgICAgIHB1c2hFdmVudC5zZW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwdXNoRXZlbnQuc3RhcnRUaW1lb3V0KCk7XG4gICAgICAgICAgICB0aGlzLnB1c2hCdWZmZXIucHVzaChwdXNoRXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwdXNoRXZlbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRhYmxlIG1lc3NhZ2UgaG9va1xuICAgICAqXG4gICAgICogUmVjZWl2ZXMgYWxsIGV2ZW50cyBmb3Igc3BlY2lhbGl6ZWQgbWVzc2FnZSBoYW5kbGluZyBiZWZvcmUgZGlzcGF0Y2hpbmcgdG8gdGhlIGNoYW5uZWwgY2FsbGJhY2tzLlxuICAgICAqIE11c3QgcmV0dXJuIHRoZSBwYXlsb2FkLCBtb2RpZmllZCBvciB1bm1vZGlmaWVkLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX29uTWVzc2FnZShfZXZlbnQsIHBheWxvYWQsIF9yZWYpIHtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfaXNNZW1iZXIodG9waWMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9waWMgPT09IHRvcGljO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2pvaW5SZWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmpvaW5QdXNoLnJlZjtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF90cmlnZ2VyKHR5cGUsIHBheWxvYWQsIHJlZikge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCB0eXBlTG93ZXIgPSB0eXBlLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IHsgY2xvc2UsIGVycm9yLCBsZWF2ZSwgam9pbiB9ID0gQ0hBTk5FTF9FVkVOVFM7XG4gICAgICAgIGNvbnN0IGV2ZW50cyA9IFtjbG9zZSwgZXJyb3IsIGxlYXZlLCBqb2luXTtcbiAgICAgICAgaWYgKHJlZiAmJiBldmVudHMuaW5kZXhPZih0eXBlTG93ZXIpID49IDAgJiYgcmVmICE9PSB0aGlzLl9qb2luUmVmKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaGFuZGxlZFBheWxvYWQgPSB0aGlzLl9vbk1lc3NhZ2UodHlwZUxvd2VyLCBwYXlsb2FkLCByZWYpO1xuICAgICAgICBpZiAocGF5bG9hZCAmJiAhaGFuZGxlZFBheWxvYWQpIHtcbiAgICAgICAgICAgIHRocm93ICdjaGFubmVsIG9uTWVzc2FnZSBjYWxsYmFja3MgbXVzdCByZXR1cm4gdGhlIHBheWxvYWQsIG1vZGlmaWVkIG9yIHVubW9kaWZpZWQnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChbJ2luc2VydCcsICd1cGRhdGUnLCAnZGVsZXRlJ10uaW5jbHVkZXModHlwZUxvd2VyKSkge1xuICAgICAgICAgICAgKF9hID0gdGhpcy5iaW5kaW5ncy5wb3N0Z3Jlc19jaGFuZ2VzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmlsdGVyKChiaW5kKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgoKF9hID0gYmluZC5maWx0ZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ldmVudCkgPT09ICcqJyB8fFxuICAgICAgICAgICAgICAgICAgICAoKF9jID0gKF9iID0gYmluZC5maWx0ZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5ldmVudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnRvTG9jYWxlTG93ZXJDYXNlKCkpID09PSB0eXBlTG93ZXIpO1xuICAgICAgICAgICAgfSkubWFwKChiaW5kKSA9PiBiaW5kLmNhbGxiYWNrKGhhbmRsZWRQYXlsb2FkLCByZWYpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIChfYiA9IHRoaXMuYmluZGluZ3NbdHlwZUxvd2VyXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmZpbHRlcigoYmluZCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICAgICAgICAgIGlmIChbJ2Jyb2FkY2FzdCcsICdwcmVzZW5jZScsICdwb3N0Z3Jlc19jaGFuZ2VzJ10uaW5jbHVkZXModHlwZUxvd2VyKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoJ2lkJyBpbiBiaW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiaW5kSWQgPSBiaW5kLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmluZEV2ZW50ID0gKF9hID0gYmluZC5maWx0ZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ldmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoYmluZElkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKChfYiA9IHBheWxvYWQuaWRzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaW5jbHVkZXMoYmluZElkKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYmluZEV2ZW50ID09PSAnKicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGJpbmRFdmVudCA9PT0gbnVsbCB8fCBiaW5kRXZlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJpbmRFdmVudC50b0xvY2FsZUxvd2VyQ2FzZSgpKSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoX2MgPSBwYXlsb2FkLmRhdGEpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy50eXBlLnRvTG9jYWxlTG93ZXJDYXNlKCkpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiaW5kRXZlbnQgPSAoX2UgPSAoX2QgPSBiaW5kID09PSBudWxsIHx8IGJpbmQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJpbmQuZmlsdGVyKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuZXZlbnQpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChiaW5kRXZlbnQgPT09ICcqJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpbmRFdmVudCA9PT0gKChfZiA9IHBheWxvYWQgPT09IG51bGwgfHwgcGF5bG9hZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGF5bG9hZC5ldmVudCkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLnRvTG9jYWxlTG93ZXJDYXNlKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJpbmQudHlwZS50b0xvY2FsZUxvd2VyQ2FzZSgpID09PSB0eXBlTG93ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkubWFwKChiaW5kKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBoYW5kbGVkUGF5bG9hZCA9PT0gJ29iamVjdCcgJiYgJ2lkcycgaW4gaGFuZGxlZFBheWxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zdGdyZXNDaGFuZ2VzID0gaGFuZGxlZFBheWxvYWQuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBzY2hlbWEsIHRhYmxlLCBjb21taXRfdGltZXN0YW1wLCB0eXBlLCBlcnJvcnMgfSA9IHBvc3RncmVzQ2hhbmdlcztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZW5yaWNoZWRQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NoZW1hOiBzY2hlbWEsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWJsZTogdGFibGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21taXRfdGltZXN0YW1wOiBjb21taXRfdGltZXN0YW1wLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRUeXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3OiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnM6IGVycm9ycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlZFBheWxvYWQgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGVucmljaGVkUGF5bG9hZCksIHRoaXMuX2dldFBheWxvYWRSZWNvcmRzKHBvc3RncmVzQ2hhbmdlcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiaW5kLmNhbGxiYWNrKGhhbmRsZWRQYXlsb2FkLCByZWYpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9pc0Nsb3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmNsb3NlZDtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9pc0pvaW5lZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmpvaW5lZDtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9pc0pvaW5pbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlID09PSBDSEFOTkVMX1NUQVRFUy5qb2luaW5nO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2lzTGVhdmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmxlYXZpbmc7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfcmVwbHlFdmVudE5hbWUocmVmKSB7XG4gICAgICAgIHJldHVybiBgY2hhbl9yZXBseV8ke3JlZn1gO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX29uKHR5cGUsIGZpbHRlciwgY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgdHlwZUxvd2VyID0gdHlwZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCBiaW5kaW5nID0ge1xuICAgICAgICAgICAgdHlwZTogdHlwZUxvd2VyLFxuICAgICAgICAgICAgZmlsdGVyOiBmaWx0ZXIsXG4gICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLmJpbmRpbmdzW3R5cGVMb3dlcl0pIHtcbiAgICAgICAgICAgIHRoaXMuYmluZGluZ3NbdHlwZUxvd2VyXS5wdXNoKGJpbmRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5iaW5kaW5nc1t0eXBlTG93ZXJdID0gW2JpbmRpbmddO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX29mZih0eXBlLCBmaWx0ZXIpIHtcbiAgICAgICAgY29uc3QgdHlwZUxvd2VyID0gdHlwZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICB0aGlzLmJpbmRpbmdzW3R5cGVMb3dlcl0gPSB0aGlzLmJpbmRpbmdzW3R5cGVMb3dlcl0uZmlsdGVyKChiaW5kKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICByZXR1cm4gISgoKF9hID0gYmluZC50eXBlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9Mb2NhbGVMb3dlckNhc2UoKSkgPT09IHR5cGVMb3dlciAmJlxuICAgICAgICAgICAgICAgIFJlYWx0aW1lQ2hhbm5lbC5pc0VxdWFsKGJpbmQuZmlsdGVyLCBmaWx0ZXIpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgc3RhdGljIGlzRXF1YWwob2JqMSwgb2JqMikge1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMob2JqMSkubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhvYmoyKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGsgaW4gb2JqMSkge1xuICAgICAgICAgICAgaWYgKG9iajFba10gIT09IG9iajJba10pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfcmVqb2luVW50aWxDb25uZWN0ZWQoKSB7XG4gICAgICAgIHRoaXMucmVqb2luVGltZXIuc2NoZWR1bGVUaW1lb3V0KCk7XG4gICAgICAgIGlmICh0aGlzLnNvY2tldC5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9yZWpvaW4oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiB0aGUgY2hhbm5lbCBjbG9zZXMuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfb25DbG9zZShjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9vbihDSEFOTkVMX0VWRU5UUy5jbG9zZSwge30sIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGNoYW5uZWwgZW5jb3VudGVyZXMgYW4gZXJyb3IuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfb25FcnJvcihjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9vbihDSEFOTkVMX0VWRU5UUy5lcnJvciwge30sIChyZWFzb24pID0+IGNhbGxiYWNrKHJlYXNvbikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgc29ja2V0IGlzIGNvbm5lY3RlZCBhbmQgdGhlIGNoYW5uZWwgaGFzIGJlZW4gam9pbmVkLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX2NhblB1c2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvY2tldC5pc0Nvbm5lY3RlZCgpICYmIHRoaXMuX2lzSm9pbmVkKCk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfcmVqb2luKHRpbWVvdXQgPSB0aGlzLnRpbWVvdXQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzTGVhdmluZygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zb2NrZXQuX2xlYXZlT3BlblRvcGljKHRoaXMudG9waWMpO1xuICAgICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuam9pbmluZztcbiAgICAgICAgdGhpcy5qb2luUHVzaC5yZXNlbmQodGltZW91dCk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfZ2V0UGF5bG9hZFJlY29yZHMocGF5bG9hZCkge1xuICAgICAgICBjb25zdCByZWNvcmRzID0ge1xuICAgICAgICAgICAgbmV3OiB7fSxcbiAgICAgICAgICAgIG9sZDoge30sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChwYXlsb2FkLnR5cGUgPT09ICdJTlNFUlQnIHx8IHBheWxvYWQudHlwZSA9PT0gJ1VQREFURScpIHtcbiAgICAgICAgICAgIHJlY29yZHMubmV3ID0gVHJhbnNmb3JtZXJzLmNvbnZlcnRDaGFuZ2VEYXRhKHBheWxvYWQuY29sdW1ucywgcGF5bG9hZC5yZWNvcmQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXlsb2FkLnR5cGUgPT09ICdVUERBVEUnIHx8IHBheWxvYWQudHlwZSA9PT0gJ0RFTEVURScpIHtcbiAgICAgICAgICAgIHJlY29yZHMub2xkID0gVHJhbnNmb3JtZXJzLmNvbnZlcnRDaGFuZ2VEYXRhKHBheWxvYWQuY29sdW1ucywgcGF5bG9hZC5vbGRfcmVjb3JkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVjb3JkcztcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZWFsdGltZUNoYW5uZWwuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/RealtimeClient.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/RealtimeClient.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ RealtimeClient)\n/* harmony export */ });\n/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/constants */ \"(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/constants.js\");\n/* harmony import */ var _lib_serializer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/serializer */ \"(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/serializer.js\");\n/* harmony import */ var _lib_timer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/timer */ \"(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/timer.js\");\n/* harmony import */ var _lib_transformers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/transformers */ \"(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/transformers.js\");\n/* harmony import */ var _RealtimeChannel__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./RealtimeChannel */ \"(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js\");\n\n\n\n\n\nconst noop = () => { };\nconst NATIVE_WEBSOCKET_AVAILABLE = typeof WebSocket !== 'undefined';\nconst WORKER_SCRIPT = `\n  addEventListener(\"message\", (e) => {\n    if (e.data.event === \"start\") {\n      setInterval(() => postMessage({ event: \"keepAlive\" }), e.data.interval);\n    }\n  });`;\nclass RealtimeClient {\n    /**\n     * Initializes the Socket.\n     *\n     * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\n     * @param httpEndpoint The string HTTP endpoint, ie, \"https://example.com\", \"/\" (inherited host & protocol)\n     * @param options.transport The Websocket Transport, for example WebSocket.\n     * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\n     * @param options.params The optional params to pass when connecting.\n     * @param options.headers The optional headers to pass when connecting.\n     * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\n     * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n     * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\n     * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\n     * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\n     * @param options.worker Use Web Worker to set a side flow. Defaults to false.\n     * @param options.workerUrl The URL of the worker script. Defaults to https://realtime.supabase.com/worker.js that includes a heartbeat event call to keep the connection alive.\n     */\n    constructor(endPoint, options) {\n        var _a;\n        this.accessTokenValue = null;\n        this.apiKey = null;\n        this.channels = [];\n        this.endPoint = '';\n        this.httpEndpoint = '';\n        this.headers = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_HEADERS;\n        this.params = {};\n        this.timeout = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_TIMEOUT;\n        this.heartbeatIntervalMs = 30000;\n        this.heartbeatTimer = undefined;\n        this.pendingHeartbeatRef = null;\n        this.ref = 0;\n        this.logger = noop;\n        this.conn = null;\n        this.sendBuffer = [];\n        this.serializer = new _lib_serializer__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n        this.stateChangeCallbacks = {\n            open: [],\n            close: [],\n            error: [],\n            message: [],\n        };\n        this.accessToken = null;\n        /**\n         * Use either custom fetch, if provided, or default fetch to make HTTP requests\n         *\n         * @internal\n         */\n        this._resolveFetch = (customFetch) => {\n            let _fetch;\n            if (customFetch) {\n                _fetch = customFetch;\n            }\n            else if (typeof fetch === 'undefined') {\n                _fetch = (...args) => Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @supabase/node-fetch */ \"(app-pages-browser)/./node_modules/@supabase/node-fetch/browser.js\")).then(({ default: fetch }) => fetch(...args));\n            }\n            else {\n                _fetch = fetch;\n            }\n            return (...args) => _fetch(...args);\n        };\n        this.endPoint = `${endPoint}/${_lib_constants__WEBPACK_IMPORTED_MODULE_0__.TRANSPORTS.websocket}`;\n        this.httpEndpoint = (0,_lib_transformers__WEBPACK_IMPORTED_MODULE_3__.httpEndpointURL)(endPoint);\n        if (options === null || options === void 0 ? void 0 : options.transport) {\n            this.transport = options.transport;\n        }\n        else {\n            this.transport = null;\n        }\n        if (options === null || options === void 0 ? void 0 : options.params)\n            this.params = options.params;\n        if (options === null || options === void 0 ? void 0 : options.headers)\n            this.headers = Object.assign(Object.assign({}, this.headers), options.headers);\n        if (options === null || options === void 0 ? void 0 : options.timeout)\n            this.timeout = options.timeout;\n        if (options === null || options === void 0 ? void 0 : options.logger)\n            this.logger = options.logger;\n        if (options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs)\n            this.heartbeatIntervalMs = options.heartbeatIntervalMs;\n        const accessTokenValue = (_a = options === null || options === void 0 ? void 0 : options.params) === null || _a === void 0 ? void 0 : _a.apikey;\n        if (accessTokenValue) {\n            this.accessTokenValue = accessTokenValue;\n            this.apiKey = accessTokenValue;\n        }\n        this.reconnectAfterMs = (options === null || options === void 0 ? void 0 : options.reconnectAfterMs)\n            ? options.reconnectAfterMs\n            : (tries) => {\n                return [1000, 2000, 5000, 10000][tries - 1] || 10000;\n            };\n        this.encode = (options === null || options === void 0 ? void 0 : options.encode)\n            ? options.encode\n            : (payload, callback) => {\n                return callback(JSON.stringify(payload));\n            };\n        this.decode = (options === null || options === void 0 ? void 0 : options.decode)\n            ? options.decode\n            : this.serializer.decode.bind(this.serializer);\n        this.reconnectTimer = new _lib_timer__WEBPACK_IMPORTED_MODULE_2__[\"default\"](async () => {\n            this.disconnect();\n            this.connect();\n        }, this.reconnectAfterMs);\n        this.fetch = this._resolveFetch(options === null || options === void 0 ? void 0 : options.fetch);\n        if (options === null || options === void 0 ? void 0 : options.worker) {\n            if (typeof window !== 'undefined' && !window.Worker) {\n                throw new Error('Web Worker is not supported');\n            }\n            this.worker = (options === null || options === void 0 ? void 0 : options.worker) || false;\n            this.workerUrl = options === null || options === void 0 ? void 0 : options.workerUrl;\n        }\n        this.accessToken = (options === null || options === void 0 ? void 0 : options.accessToken) || null;\n    }\n    /**\n     * Connects the socket, unless already connected.\n     */\n    connect() {\n        if (this.conn) {\n            return;\n        }\n        if (this.transport) {\n            this.conn = new this.transport(this.endpointURL(), undefined, {\n                headers: this.headers,\n            });\n            return;\n        }\n        if (NATIVE_WEBSOCKET_AVAILABLE) {\n            this.conn = new WebSocket(this.endpointURL());\n            this.setupConnection();\n            return;\n        }\n        this.conn = new WSWebSocketDummy(this.endpointURL(), undefined, {\n            close: () => {\n                this.conn = null;\n            },\n        });\n        __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_ws_browser_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! ws */ \"(app-pages-browser)/./node_modules/ws/browser.js\", 23)).then(({ default: WS }) => {\n            this.conn = new WS(this.endpointURL(), undefined, {\n                headers: this.headers,\n            });\n            this.setupConnection();\n        });\n    }\n    /**\n     * Returns the URL of the websocket.\n     * @returns string The URL of the websocket.\n     */\n    endpointURL() {\n        return this._appendParams(this.endPoint, Object.assign({}, this.params, { vsn: _lib_constants__WEBPACK_IMPORTED_MODULE_0__.VSN }));\n    }\n    /**\n     * Disconnects the socket.\n     *\n     * @param code A numeric status code to send on disconnect.\n     * @param reason A custom reason for the disconnect.\n     */\n    disconnect(code, reason) {\n        if (this.conn) {\n            this.conn.onclose = function () { }; // noop\n            if (code) {\n                this.conn.close(code, reason !== null && reason !== void 0 ? reason : '');\n            }\n            else {\n                this.conn.close();\n            }\n            this.conn = null;\n            // remove open handles\n            this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n            this.reconnectTimer.reset();\n        }\n    }\n    /**\n     * Returns all created channels\n     */\n    getChannels() {\n        return this.channels;\n    }\n    /**\n     * Unsubscribes and removes a single channel\n     * @param channel A RealtimeChannel instance\n     */\n    async removeChannel(channel) {\n        const status = await channel.unsubscribe();\n        if (this.channels.length === 0) {\n            this.disconnect();\n        }\n        return status;\n    }\n    /**\n     * Unsubscribes and removes all channels\n     */\n    async removeAllChannels() {\n        const values_1 = await Promise.all(this.channels.map((channel) => channel.unsubscribe()));\n        this.disconnect();\n        return values_1;\n    }\n    /**\n     * Logs the message.\n     *\n     * For customized logging, `this.logger` can be overridden.\n     */\n    log(kind, msg, data) {\n        this.logger(kind, msg, data);\n    }\n    /**\n     * Returns the current state of the socket.\n     */\n    connectionState() {\n        switch (this.conn && this.conn.readyState) {\n            case _lib_constants__WEBPACK_IMPORTED_MODULE_0__.SOCKET_STATES.connecting:\n                return _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CONNECTION_STATE.Connecting;\n            case _lib_constants__WEBPACK_IMPORTED_MODULE_0__.SOCKET_STATES.open:\n                return _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CONNECTION_STATE.Open;\n            case _lib_constants__WEBPACK_IMPORTED_MODULE_0__.SOCKET_STATES.closing:\n                return _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CONNECTION_STATE.Closing;\n            default:\n                return _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CONNECTION_STATE.Closed;\n        }\n    }\n    /**\n     * Returns `true` is the connection is open.\n     */\n    isConnected() {\n        return this.connectionState() === _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CONNECTION_STATE.Open;\n    }\n    channel(topic, params = { config: {} }) {\n        const chan = new _RealtimeChannel__WEBPACK_IMPORTED_MODULE_4__[\"default\"](`realtime:${topic}`, params, this);\n        this.channels.push(chan);\n        return chan;\n    }\n    /**\n     * Push out a message if the socket is connected.\n     *\n     * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\n     */\n    push(data) {\n        const { topic, event, payload, ref } = data;\n        const callback = () => {\n            this.encode(data, (result) => {\n                var _a;\n                (_a = this.conn) === null || _a === void 0 ? void 0 : _a.send(result);\n            });\n        };\n        this.log('push', `${topic} ${event} (${ref})`, payload);\n        if (this.isConnected()) {\n            callback();\n        }\n        else {\n            this.sendBuffer.push(callback);\n        }\n    }\n    /**\n     * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\n     *\n     * If param is null it will use the `accessToken` callback function or the token set on the client.\n     *\n     * On callback used, it will set the value of the token internal to the client.\n     *\n     * @param token A JWT string to override the token set on the client.\n     */\n    async setAuth(token = null) {\n        let tokenToSend = token ||\n            (this.accessToken && (await this.accessToken())) ||\n            this.accessTokenValue;\n        if (tokenToSend) {\n            let parsed = null;\n            try {\n                parsed = JSON.parse(atob(tokenToSend.split('.')[1]));\n            }\n            catch (_error) { }\n            if (parsed && parsed.exp) {\n                let now = Math.floor(Date.now() / 1000);\n                let valid = now - parsed.exp < 0;\n                if (!valid) {\n                    this.log('auth', `InvalidJWTToken: Invalid value for JWT claim \"exp\" with value ${parsed.exp}`);\n                    return Promise.reject(`InvalidJWTToken: Invalid value for JWT claim \"exp\" with value ${parsed.exp}`);\n                }\n            }\n            this.accessTokenValue = tokenToSend;\n            this.channels.forEach((channel) => {\n                tokenToSend && channel.updateJoinPayload({ access_token: tokenToSend });\n                if (channel.joinedOnce && channel._isJoined()) {\n                    channel._push(_lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS.access_token, {\n                        access_token: tokenToSend,\n                    });\n                }\n            });\n        }\n    }\n    /**\n     * Sends a heartbeat message if the socket is connected.\n     */\n    async sendHeartbeat() {\n        var _a;\n        if (!this.isConnected()) {\n            return;\n        }\n        if (this.pendingHeartbeatRef) {\n            this.pendingHeartbeatRef = null;\n            this.log('transport', 'heartbeat timeout. Attempting to re-establish connection');\n            (_a = this.conn) === null || _a === void 0 ? void 0 : _a.close(_lib_constants__WEBPACK_IMPORTED_MODULE_0__.WS_CLOSE_NORMAL, 'hearbeat timeout');\n            return;\n        }\n        this.pendingHeartbeatRef = this._makeRef();\n        this.push({\n            topic: 'phoenix',\n            event: 'heartbeat',\n            payload: {},\n            ref: this.pendingHeartbeatRef,\n        });\n        this.setAuth();\n    }\n    /**\n     * Flushes send buffer\n     */\n    flushSendBuffer() {\n        if (this.isConnected() && this.sendBuffer.length > 0) {\n            this.sendBuffer.forEach((callback) => callback());\n            this.sendBuffer = [];\n        }\n    }\n    /**\n     * Return the next message ref, accounting for overflows\n     *\n     * @internal\n     */\n    _makeRef() {\n        let newRef = this.ref + 1;\n        if (newRef === this.ref) {\n            this.ref = 0;\n        }\n        else {\n            this.ref = newRef;\n        }\n        return this.ref.toString();\n    }\n    /**\n     * Unsubscribe from channels with the specified topic.\n     *\n     * @internal\n     */\n    _leaveOpenTopic(topic) {\n        let dupChannel = this.channels.find((c) => c.topic === topic && (c._isJoined() || c._isJoining()));\n        if (dupChannel) {\n            this.log('transport', `leaving duplicate topic \"${topic}\"`);\n            dupChannel.unsubscribe();\n        }\n    }\n    /**\n     * Removes a subscription from the socket.\n     *\n     * @param channel An open subscription.\n     *\n     * @internal\n     */\n    _remove(channel) {\n        this.channels = this.channels.filter((c) => c._joinRef() !== channel._joinRef());\n    }\n    /**\n     * Sets up connection handlers.\n     *\n     * @internal\n     */\n    setupConnection() {\n        if (this.conn) {\n            this.conn.binaryType = 'arraybuffer';\n            this.conn.onopen = () => this._onConnOpen();\n            this.conn.onerror = (error) => this._onConnError(error);\n            this.conn.onmessage = (event) => this._onConnMessage(event);\n            this.conn.onclose = (event) => this._onConnClose(event);\n        }\n    }\n    /** @internal */\n    _onConnMessage(rawMessage) {\n        this.decode(rawMessage.data, (msg) => {\n            let { topic, event, payload, ref } = msg;\n            if (ref && ref === this.pendingHeartbeatRef) {\n                this.pendingHeartbeatRef = null;\n            }\n            this.log('receive', `${payload.status || ''} ${topic} ${event} ${(ref && '(' + ref + ')') || ''}`, payload);\n            this.channels\n                .filter((channel) => channel._isMember(topic))\n                .forEach((channel) => channel._trigger(event, payload, ref));\n            this.stateChangeCallbacks.message.forEach((callback) => callback(msg));\n        });\n    }\n    /** @internal */\n    async _onConnOpen() {\n        this.log('transport', `connected to ${this.endpointURL()}`);\n        this.flushSendBuffer();\n        this.reconnectTimer.reset();\n        if (!this.worker) {\n            this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n            this.heartbeatTimer = setInterval(() => this.sendHeartbeat(), this.heartbeatIntervalMs);\n        }\n        else {\n            if (this.workerUrl) {\n                this.log('worker', `starting worker for from ${this.workerUrl}`);\n            }\n            else {\n                this.log('worker', `starting default worker`);\n            }\n            const objectUrl = this._workerObjectUrl(this.workerUrl);\n            this.workerRef = new Worker(objectUrl);\n            this.workerRef.onerror = (error) => {\n                this.log('worker', 'worker error', error.message);\n                this.workerRef.terminate();\n            };\n            this.workerRef.onmessage = (event) => {\n                if (event.data.event === 'keepAlive') {\n                    this.sendHeartbeat();\n                }\n            };\n            this.workerRef.postMessage({\n                event: 'start',\n                interval: this.heartbeatIntervalMs,\n            });\n        }\n        this.stateChangeCallbacks.open.forEach((callback) => callback());\n    }\n    /** @internal */\n    _onConnClose(event) {\n        this.log('transport', 'close', event);\n        this._triggerChanError();\n        this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n        this.reconnectTimer.scheduleTimeout();\n        this.stateChangeCallbacks.close.forEach((callback) => callback(event));\n    }\n    /** @internal */\n    _onConnError(error) {\n        this.log('transport', error.message);\n        this._triggerChanError();\n        this.stateChangeCallbacks.error.forEach((callback) => callback(error));\n    }\n    /** @internal */\n    _triggerChanError() {\n        this.channels.forEach((channel) => channel._trigger(_lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS.error));\n    }\n    /** @internal */\n    _appendParams(url, params) {\n        if (Object.keys(params).length === 0) {\n            return url;\n        }\n        const prefix = url.match(/\\?/) ? '&' : '?';\n        const query = new URLSearchParams(params);\n        return `${url}${prefix}${query}`;\n    }\n    _workerObjectUrl(url) {\n        let result_url;\n        if (url) {\n            result_url = url;\n        }\n        else {\n            const blob = new Blob([WORKER_SCRIPT], { type: 'application/javascript' });\n            result_url = URL.createObjectURL(blob);\n        }\n        return result_url;\n    }\n}\nclass WSWebSocketDummy {\n    constructor(address, _protocols, options) {\n        this.binaryType = 'arraybuffer';\n        this.onclose = () => { };\n        this.onerror = () => { };\n        this.onmessage = () => { };\n        this.onopen = () => { };\n        this.readyState = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.SOCKET_STATES.connecting;\n        this.send = () => { };\n        this.url = null;\n        this.url = address;\n        this.close = options.close;\n    }\n}\n//# sourceMappingURL=RealtimeClient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvUmVhbHRpbWVDbGllbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQXVKO0FBQzdHO0FBQ1Y7QUFDcUI7QUFDTDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLG9CQUFvQjtBQUMxRDtBQUNBLEdBQUcsRUFBRTtBQUNVO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrR0FBK0csZUFBZSxLQUFLLElBQUksSUFBSTtBQUMzSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwyREFBZTtBQUN0QztBQUNBLHVCQUF1QiwyREFBZTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix1REFBVTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msc0xBQThCLFNBQVMsZ0JBQWdCO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTLEdBQUcsc0RBQVUsV0FBVztBQUM1RCw0QkFBNEIsa0VBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxrREFBSztBQUN2QztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULFFBQVEsOE1BQVksU0FBUyxhQUFhO0FBQzFDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLGlCQUFpQixLQUFLLCtDQUFHLEVBQUU7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseURBQWE7QUFDOUIsdUJBQXVCLDREQUFnQjtBQUN2QyxpQkFBaUIseURBQWE7QUFDOUIsdUJBQXVCLDREQUFnQjtBQUN2QyxpQkFBaUIseURBQWE7QUFDOUIsdUJBQXVCLDREQUFnQjtBQUN2QztBQUNBLHVCQUF1Qiw0REFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDREQUFnQjtBQUMxRDtBQUNBLDhCQUE4QixZQUFZO0FBQzFDLHlCQUF5Qix3REFBZSxhQUFhLE1BQU07QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDZCQUE2QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLDRCQUE0QixPQUFPLEVBQUUsT0FBTyxHQUFHLElBQUk7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHLFdBQVc7QUFDakgsMkdBQTJHLFdBQVc7QUFDdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsMkJBQTJCO0FBQ3RGO0FBQ0Esa0NBQWtDLDBEQUFjO0FBQ2hEO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLDJEQUFlO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxNQUFNO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw2QkFBNkI7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHNCQUFzQixFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsK0JBQStCO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxtQkFBbUI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxlQUFlO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCwwREFBYztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLElBQUksRUFBRSxPQUFPLEVBQUUsTUFBTTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxnQ0FBZ0M7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHlEQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvd29uZGVybGFuZG1pdGNoL0Nhc2NhZGVQcm9qZWN0cy9Xb25kZXJWaXRlLWZyb250ZW5kL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvUmVhbHRpbWVDbGllbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ0hBTk5FTF9FVkVOVFMsIENPTk5FQ1RJT05fU1RBVEUsIERFRkFVTFRfSEVBREVSUywgREVGQVVMVF9USU1FT1VULCBTT0NLRVRfU1RBVEVTLCBUUkFOU1BPUlRTLCBWU04sIFdTX0NMT1NFX05PUk1BTCwgfSBmcm9tICcuL2xpYi9jb25zdGFudHMnO1xuaW1wb3J0IFNlcmlhbGl6ZXIgZnJvbSAnLi9saWIvc2VyaWFsaXplcic7XG5pbXBvcnQgVGltZXIgZnJvbSAnLi9saWIvdGltZXInO1xuaW1wb3J0IHsgaHR0cEVuZHBvaW50VVJMIH0gZnJvbSAnLi9saWIvdHJhbnNmb3JtZXJzJztcbmltcG9ydCBSZWFsdGltZUNoYW5uZWwgZnJvbSAnLi9SZWFsdGltZUNoYW5uZWwnO1xuY29uc3Qgbm9vcCA9ICgpID0+IHsgfTtcbmNvbnN0IE5BVElWRV9XRUJTT0NLRVRfQVZBSUxBQkxFID0gdHlwZW9mIFdlYlNvY2tldCAhPT0gJ3VuZGVmaW5lZCc7XG5jb25zdCBXT1JLRVJfU0NSSVBUID0gYFxuICBhZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAoZSkgPT4ge1xuICAgIGlmIChlLmRhdGEuZXZlbnQgPT09IFwic3RhcnRcIikge1xuICAgICAgc2V0SW50ZXJ2YWwoKCkgPT4gcG9zdE1lc3NhZ2UoeyBldmVudDogXCJrZWVwQWxpdmVcIiB9KSwgZS5kYXRhLmludGVydmFsKTtcbiAgICB9XG4gIH0pO2A7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWFsdGltZUNsaWVudCB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIFNvY2tldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbmRQb2ludCBUaGUgc3RyaW5nIFdlYlNvY2tldCBlbmRwb2ludCwgaWUsIFwid3M6Ly9leGFtcGxlLmNvbS9zb2NrZXRcIiwgXCJ3c3M6Ly9leGFtcGxlLmNvbVwiLCBcIi9zb2NrZXRcIiAoaW5oZXJpdGVkIGhvc3QgJiBwcm90b2NvbClcbiAgICAgKiBAcGFyYW0gaHR0cEVuZHBvaW50IFRoZSBzdHJpbmcgSFRUUCBlbmRwb2ludCwgaWUsIFwiaHR0cHM6Ly9leGFtcGxlLmNvbVwiLCBcIi9cIiAoaW5oZXJpdGVkIGhvc3QgJiBwcm90b2NvbClcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy50cmFuc3BvcnQgVGhlIFdlYnNvY2tldCBUcmFuc3BvcnQsIGZvciBleGFtcGxlIFdlYlNvY2tldC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy50aW1lb3V0IFRoZSBkZWZhdWx0IHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIHRvIHRyaWdnZXIgcHVzaCB0aW1lb3V0cy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5wYXJhbXMgVGhlIG9wdGlvbmFsIHBhcmFtcyB0byBwYXNzIHdoZW4gY29ubmVjdGluZy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5oZWFkZXJzIFRoZSBvcHRpb25hbCBoZWFkZXJzIHRvIHBhc3Mgd2hlbiBjb25uZWN0aW5nLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmhlYXJ0YmVhdEludGVydmFsTXMgVGhlIG1pbGxpc2VjIGludGVydmFsIHRvIHNlbmQgYSBoZWFydGJlYXQgbWVzc2FnZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5sb2dnZXIgVGhlIG9wdGlvbmFsIGZ1bmN0aW9uIGZvciBzcGVjaWFsaXplZCBsb2dnaW5nLCBpZTogbG9nZ2VyOiAoa2luZCwgbXNnLCBkYXRhKSA9PiB7IGNvbnNvbGUubG9nKGAke2tpbmR9OiAke21zZ31gLCBkYXRhKSB9XG4gICAgICogQHBhcmFtIG9wdGlvbnMuZW5jb2RlIFRoZSBmdW5jdGlvbiB0byBlbmNvZGUgb3V0Z29pbmcgbWVzc2FnZXMuIERlZmF1bHRzIHRvIEpTT046IChwYXlsb2FkLCBjYWxsYmFjaykgPT4gY2FsbGJhY2soSlNPTi5zdHJpbmdpZnkocGF5bG9hZCkpXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZGVjb2RlIFRoZSBmdW5jdGlvbiB0byBkZWNvZGUgaW5jb21pbmcgbWVzc2FnZXMuIERlZmF1bHRzIHRvIFNlcmlhbGl6ZXIncyBkZWNvZGUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMucmVjb25uZWN0QWZ0ZXJNcyBoZSBvcHRpb25hbCBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIG1pbGxzZWMgcmVjb25uZWN0IGludGVydmFsLiBEZWZhdWx0cyB0byBzdGVwcGVkIGJhY2tvZmYgb2ZmLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLndvcmtlciBVc2UgV2ViIFdvcmtlciB0byBzZXQgYSBzaWRlIGZsb3cuIERlZmF1bHRzIHRvIGZhbHNlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLndvcmtlclVybCBUaGUgVVJMIG9mIHRoZSB3b3JrZXIgc2NyaXB0LiBEZWZhdWx0cyB0byBodHRwczovL3JlYWx0aW1lLnN1cGFiYXNlLmNvbS93b3JrZXIuanMgdGhhdCBpbmNsdWRlcyBhIGhlYXJ0YmVhdCBldmVudCBjYWxsIHRvIGtlZXAgdGhlIGNvbm5lY3Rpb24gYWxpdmUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZW5kUG9pbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmFjY2Vzc1Rva2VuVmFsdWUgPSBudWxsO1xuICAgICAgICB0aGlzLmFwaUtleSA9IG51bGw7XG4gICAgICAgIHRoaXMuY2hhbm5lbHMgPSBbXTtcbiAgICAgICAgdGhpcy5lbmRQb2ludCA9ICcnO1xuICAgICAgICB0aGlzLmh0dHBFbmRwb2ludCA9ICcnO1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBERUZBVUxUX0hFQURFUlM7XG4gICAgICAgIHRoaXMucGFyYW1zID0ge307XG4gICAgICAgIHRoaXMudGltZW91dCA9IERFRkFVTFRfVElNRU9VVDtcbiAgICAgICAgdGhpcy5oZWFydGJlYXRJbnRlcnZhbE1zID0gMzAwMDA7XG4gICAgICAgIHRoaXMuaGVhcnRiZWF0VGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiA9IG51bGw7XG4gICAgICAgIHRoaXMucmVmID0gMDtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBub29wO1xuICAgICAgICB0aGlzLmNvbm4gPSBudWxsO1xuICAgICAgICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbiAgICAgICAgdGhpcy5zZXJpYWxpemVyID0gbmV3IFNlcmlhbGl6ZXIoKTtcbiAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcyA9IHtcbiAgICAgICAgICAgIG9wZW46IFtdLFxuICAgICAgICAgICAgY2xvc2U6IFtdLFxuICAgICAgICAgICAgZXJyb3I6IFtdLFxuICAgICAgICAgICAgbWVzc2FnZTogW10sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWNjZXNzVG9rZW4gPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogVXNlIGVpdGhlciBjdXN0b20gZmV0Y2gsIGlmIHByb3ZpZGVkLCBvciBkZWZhdWx0IGZldGNoIHRvIG1ha2UgSFRUUCByZXF1ZXN0c1xuICAgICAgICAgKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3Jlc29sdmVGZXRjaCA9IChjdXN0b21GZXRjaCkgPT4ge1xuICAgICAgICAgICAgbGV0IF9mZXRjaDtcbiAgICAgICAgICAgIGlmIChjdXN0b21GZXRjaCkge1xuICAgICAgICAgICAgICAgIF9mZXRjaCA9IGN1c3RvbUZldGNoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGZldGNoID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIF9mZXRjaCA9ICguLi5hcmdzKSA9PiBpbXBvcnQoJ0BzdXBhYmFzZS9ub2RlLWZldGNoJykudGhlbigoeyBkZWZhdWx0OiBmZXRjaCB9KSA9PiBmZXRjaCguLi5hcmdzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfZmV0Y2ggPSBmZXRjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoLi4uYXJncykgPT4gX2ZldGNoKC4uLmFyZ3MpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmVuZFBvaW50ID0gYCR7ZW5kUG9pbnR9LyR7VFJBTlNQT1JUUy53ZWJzb2NrZXR9YDtcbiAgICAgICAgdGhpcy5odHRwRW5kcG9pbnQgPSBodHRwRW5kcG9pbnRVUkwoZW5kUG9pbnQpO1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRyYW5zcG9ydCkge1xuICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQgPSBvcHRpb25zLnRyYW5zcG9ydDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnBhcmFtcylcbiAgICAgICAgICAgIHRoaXMucGFyYW1zID0gb3B0aW9ucy5wYXJhbXM7XG4gICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaGVhZGVycylcbiAgICAgICAgICAgIHRoaXMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5oZWFkZXJzKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50aW1lb3V0KVxuICAgICAgICAgICAgdGhpcy50aW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0O1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmxvZ2dlcilcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyID0gb3B0aW9ucy5sb2dnZXI7XG4gICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaGVhcnRiZWF0SW50ZXJ2YWxNcylcbiAgICAgICAgICAgIHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxNcyA9IG9wdGlvbnMuaGVhcnRiZWF0SW50ZXJ2YWxNcztcbiAgICAgICAgY29uc3QgYWNjZXNzVG9rZW5WYWx1ZSA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wYXJhbXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hcGlrZXk7XG4gICAgICAgIGlmIChhY2Nlc3NUb2tlblZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmFjY2Vzc1Rva2VuVmFsdWUgPSBhY2Nlc3NUb2tlblZhbHVlO1xuICAgICAgICAgICAgdGhpcy5hcGlLZXkgPSBhY2Nlc3NUb2tlblZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVjb25uZWN0QWZ0ZXJNcyA9IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucmVjb25uZWN0QWZ0ZXJNcylcbiAgICAgICAgICAgID8gb3B0aW9ucy5yZWNvbm5lY3RBZnRlck1zXG4gICAgICAgICAgICA6ICh0cmllcykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMTAwMCwgMjAwMCwgNTAwMCwgMTAwMDBdW3RyaWVzIC0gMV0gfHwgMTAwMDA7XG4gICAgICAgICAgICB9O1xuICAgICAgICB0aGlzLmVuY29kZSA9IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZW5jb2RlKVxuICAgICAgICAgICAgPyBvcHRpb25zLmVuY29kZVxuICAgICAgICAgICAgOiAocGF5bG9hZCwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soSlNPTi5zdHJpbmdpZnkocGF5bG9hZCkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kZWNvZGUgPSAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRlY29kZSlcbiAgICAgICAgICAgID8gb3B0aW9ucy5kZWNvZGVcbiAgICAgICAgICAgIDogdGhpcy5zZXJpYWxpemVyLmRlY29kZS5iaW5kKHRoaXMuc2VyaWFsaXplcik7XG4gICAgICAgIHRoaXMucmVjb25uZWN0VGltZXIgPSBuZXcgVGltZXIoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3QoKTtcbiAgICAgICAgfSwgdGhpcy5yZWNvbm5lY3RBZnRlck1zKTtcbiAgICAgICAgdGhpcy5mZXRjaCA9IHRoaXMuX3Jlc29sdmVGZXRjaChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZmV0Y2gpO1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLndvcmtlcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICF3aW5kb3cuV29ya2VyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWIgV29ya2VyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMud29ya2VyID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy53b3JrZXIpIHx8IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy53b3JrZXJVcmwgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMud29ya2VyVXJsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWNjZXNzVG9rZW4gPSAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmFjY2Vzc1Rva2VuKSB8fCBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25uZWN0cyB0aGUgc29ja2V0LCB1bmxlc3MgYWxyZWFkeSBjb25uZWN0ZWQuXG4gICAgICovXG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29ubikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRyYW5zcG9ydCkge1xuICAgICAgICAgICAgdGhpcy5jb25uID0gbmV3IHRoaXMudHJhbnNwb3J0KHRoaXMuZW5kcG9pbnRVUkwoKSwgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE5BVElWRV9XRUJTT0NLRVRfQVZBSUxBQkxFKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm4gPSBuZXcgV2ViU29ja2V0KHRoaXMuZW5kcG9pbnRVUkwoKSk7XG4gICAgICAgICAgICB0aGlzLnNldHVwQ29ubmVjdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29ubiA9IG5ldyBXU1dlYlNvY2tldER1bW15KHRoaXMuZW5kcG9pbnRVUkwoKSwgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgICBjbG9zZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubiA9IG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgaW1wb3J0KCd3cycpLnRoZW4oKHsgZGVmYXVsdDogV1MgfSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jb25uID0gbmV3IFdTKHRoaXMuZW5kcG9pbnRVUkwoKSwgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnNldHVwQ29ubmVjdGlvbigpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgVVJMIG9mIHRoZSB3ZWJzb2NrZXQuXG4gICAgICogQHJldHVybnMgc3RyaW5nIFRoZSBVUkwgb2YgdGhlIHdlYnNvY2tldC5cbiAgICAgKi9cbiAgICBlbmRwb2ludFVSTCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGVuZFBhcmFtcyh0aGlzLmVuZFBvaW50LCBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnBhcmFtcywgeyB2c246IFZTTiB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc2Nvbm5lY3RzIHRoZSBzb2NrZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29kZSBBIG51bWVyaWMgc3RhdHVzIGNvZGUgdG8gc2VuZCBvbiBkaXNjb25uZWN0LlxuICAgICAqIEBwYXJhbSByZWFzb24gQSBjdXN0b20gcmVhc29uIGZvciB0aGUgZGlzY29ubmVjdC5cbiAgICAgKi9cbiAgICBkaXNjb25uZWN0KGNvZGUsIHJlYXNvbikge1xuICAgICAgICBpZiAodGhpcy5jb25uKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm4ub25jbG9zZSA9IGZ1bmN0aW9uICgpIHsgfTsgLy8gbm9vcFxuICAgICAgICAgICAgaWYgKGNvZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm4uY2xvc2UoY29kZSwgcmVhc29uICE9PSBudWxsICYmIHJlYXNvbiAhPT0gdm9pZCAwID8gcmVhc29uIDogJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25uLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbm4gPSBudWxsO1xuICAgICAgICAgICAgLy8gcmVtb3ZlIG9wZW4gaGFuZGxlc1xuICAgICAgICAgICAgdGhpcy5oZWFydGJlYXRUaW1lciAmJiBjbGVhckludGVydmFsKHRoaXMuaGVhcnRiZWF0VGltZXIpO1xuICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3RUaW1lci5yZXNldCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIGNyZWF0ZWQgY2hhbm5lbHNcbiAgICAgKi9cbiAgICBnZXRDaGFubmVscygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVuc3Vic2NyaWJlcyBhbmQgcmVtb3ZlcyBhIHNpbmdsZSBjaGFubmVsXG4gICAgICogQHBhcmFtIGNoYW5uZWwgQSBSZWFsdGltZUNoYW5uZWwgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBhc3luYyByZW1vdmVDaGFubmVsKGNoYW5uZWwpIHtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gYXdhaXQgY2hhbm5lbC51bnN1YnNjcmliZSgpO1xuICAgICAgICBpZiAodGhpcy5jaGFubmVscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0dXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVuc3Vic2NyaWJlcyBhbmQgcmVtb3ZlcyBhbGwgY2hhbm5lbHNcbiAgICAgKi9cbiAgICBhc3luYyByZW1vdmVBbGxDaGFubmVscygpIHtcbiAgICAgICAgY29uc3QgdmFsdWVzXzEgPSBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmNoYW5uZWxzLm1hcCgoY2hhbm5lbCkgPT4gY2hhbm5lbC51bnN1YnNjcmliZSgpKSk7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgICByZXR1cm4gdmFsdWVzXzE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZ3MgdGhlIG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiBGb3IgY3VzdG9taXplZCBsb2dnaW5nLCBgdGhpcy5sb2dnZXJgIGNhbiBiZSBvdmVycmlkZGVuLlxuICAgICAqL1xuICAgIGxvZyhraW5kLCBtc2csIGRhdGEpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIoa2luZCwgbXNnLCBkYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgc29ja2V0LlxuICAgICAqL1xuICAgIGNvbm5lY3Rpb25TdGF0ZSgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLmNvbm4gJiYgdGhpcy5jb25uLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgU09DS0VUX1NUQVRFUy5jb25uZWN0aW5nOlxuICAgICAgICAgICAgICAgIHJldHVybiBDT05ORUNUSU9OX1NUQVRFLkNvbm5lY3Rpbmc7XG4gICAgICAgICAgICBjYXNlIFNPQ0tFVF9TVEFURVMub3BlbjpcbiAgICAgICAgICAgICAgICByZXR1cm4gQ09OTkVDVElPTl9TVEFURS5PcGVuO1xuICAgICAgICAgICAgY2FzZSBTT0NLRVRfU1RBVEVTLmNsb3Npbmc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIENPTk5FQ1RJT05fU1RBVEUuQ2xvc2luZztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIENPTk5FQ1RJT05fU1RBVEUuQ2xvc2VkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlzIHRoZSBjb25uZWN0aW9uIGlzIG9wZW4uXG4gICAgICovXG4gICAgaXNDb25uZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb25TdGF0ZSgpID09PSBDT05ORUNUSU9OX1NUQVRFLk9wZW47XG4gICAgfVxuICAgIGNoYW5uZWwodG9waWMsIHBhcmFtcyA9IHsgY29uZmlnOiB7fSB9KSB7XG4gICAgICAgIGNvbnN0IGNoYW4gPSBuZXcgUmVhbHRpbWVDaGFubmVsKGByZWFsdGltZToke3RvcGljfWAsIHBhcmFtcywgdGhpcyk7XG4gICAgICAgIHRoaXMuY2hhbm5lbHMucHVzaChjaGFuKTtcbiAgICAgICAgcmV0dXJuIGNoYW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1c2ggb3V0IGEgbWVzc2FnZSBpZiB0aGUgc29ja2V0IGlzIGNvbm5lY3RlZC5cbiAgICAgKlxuICAgICAqIElmIHRoZSBzb2NrZXQgaXMgbm90IGNvbm5lY3RlZCwgdGhlIG1lc3NhZ2UgZ2V0cyBlbnF1ZXVlZCB3aXRoaW4gYSBsb2NhbCBidWZmZXIsIGFuZCBzZW50IG91dCB3aGVuIGEgY29ubmVjdGlvbiBpcyBuZXh0IGVzdGFibGlzaGVkLlxuICAgICAqL1xuICAgIHB1c2goZGF0YSkge1xuICAgICAgICBjb25zdCB7IHRvcGljLCBldmVudCwgcGF5bG9hZCwgcmVmIH0gPSBkYXRhO1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW5jb2RlKGRhdGEsIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgKF9hID0gdGhpcy5jb25uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2VuZChyZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubG9nKCdwdXNoJywgYCR7dG9waWN9ICR7ZXZlbnR9ICgke3JlZn0pYCwgcGF5bG9hZCk7XG4gICAgICAgIGlmICh0aGlzLmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRCdWZmZXIucHVzaChjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgSldUIGFjY2VzcyB0b2tlbiB1c2VkIGZvciBjaGFubmVsIHN1YnNjcmlwdGlvbiBhdXRob3JpemF0aW9uIGFuZCBSZWFsdGltZSBSTFMuXG4gICAgICpcbiAgICAgKiBJZiBwYXJhbSBpcyBudWxsIGl0IHdpbGwgdXNlIHRoZSBgYWNjZXNzVG9rZW5gIGNhbGxiYWNrIGZ1bmN0aW9uIG9yIHRoZSB0b2tlbiBzZXQgb24gdGhlIGNsaWVudC5cbiAgICAgKlxuICAgICAqIE9uIGNhbGxiYWNrIHVzZWQsIGl0IHdpbGwgc2V0IHRoZSB2YWx1ZSBvZiB0aGUgdG9rZW4gaW50ZXJuYWwgdG8gdGhlIGNsaWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0b2tlbiBBIEpXVCBzdHJpbmcgdG8gb3ZlcnJpZGUgdGhlIHRva2VuIHNldCBvbiB0aGUgY2xpZW50LlxuICAgICAqL1xuICAgIGFzeW5jIHNldEF1dGgodG9rZW4gPSBudWxsKSB7XG4gICAgICAgIGxldCB0b2tlblRvU2VuZCA9IHRva2VuIHx8XG4gICAgICAgICAgICAodGhpcy5hY2Nlc3NUb2tlbiAmJiAoYXdhaXQgdGhpcy5hY2Nlc3NUb2tlbigpKSkgfHxcbiAgICAgICAgICAgIHRoaXMuYWNjZXNzVG9rZW5WYWx1ZTtcbiAgICAgICAgaWYgKHRva2VuVG9TZW5kKSB7XG4gICAgICAgICAgICBsZXQgcGFyc2VkID0gbnVsbDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGFyc2VkID0gSlNPTi5wYXJzZShhdG9iKHRva2VuVG9TZW5kLnNwbGl0KCcuJylbMV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfZXJyb3IpIHsgfVxuICAgICAgICAgICAgaWYgKHBhcnNlZCAmJiBwYXJzZWQuZXhwKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5vdyA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApO1xuICAgICAgICAgICAgICAgIGxldCB2YWxpZCA9IG5vdyAtIHBhcnNlZC5leHAgPCAwO1xuICAgICAgICAgICAgICAgIGlmICghdmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2coJ2F1dGgnLCBgSW52YWxpZEpXVFRva2VuOiBJbnZhbGlkIHZhbHVlIGZvciBKV1QgY2xhaW0gXCJleHBcIiB3aXRoIHZhbHVlICR7cGFyc2VkLmV4cH1gKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGBJbnZhbGlkSldUVG9rZW46IEludmFsaWQgdmFsdWUgZm9yIEpXVCBjbGFpbSBcImV4cFwiIHdpdGggdmFsdWUgJHtwYXJzZWQuZXhwfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWNjZXNzVG9rZW5WYWx1ZSA9IHRva2VuVG9TZW5kO1xuICAgICAgICAgICAgdGhpcy5jaGFubmVscy5mb3JFYWNoKChjaGFubmVsKSA9PiB7XG4gICAgICAgICAgICAgICAgdG9rZW5Ub1NlbmQgJiYgY2hhbm5lbC51cGRhdGVKb2luUGF5bG9hZCh7IGFjY2Vzc190b2tlbjogdG9rZW5Ub1NlbmQgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5uZWwuam9pbmVkT25jZSAmJiBjaGFubmVsLl9pc0pvaW5lZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWwuX3B1c2goQ0hBTk5FTF9FVkVOVFMuYWNjZXNzX3Rva2VuLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2Nlc3NfdG9rZW46IHRva2VuVG9TZW5kLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIGhlYXJ0YmVhdCBtZXNzYWdlIGlmIHRoZSBzb2NrZXQgaXMgY29ubmVjdGVkLlxuICAgICAqL1xuICAgIGFzeW5jIHNlbmRIZWFydGJlYXQoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmKSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5sb2coJ3RyYW5zcG9ydCcsICdoZWFydGJlYXQgdGltZW91dC4gQXR0ZW1wdGluZyB0byByZS1lc3RhYmxpc2ggY29ubmVjdGlvbicpO1xuICAgICAgICAgICAgKF9hID0gdGhpcy5jb25uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xvc2UoV1NfQ0xPU0VfTk9STUFMLCAnaGVhcmJlYXQgdGltZW91dCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiA9IHRoaXMuX21ha2VSZWYoKTtcbiAgICAgICAgdGhpcy5wdXNoKHtcbiAgICAgICAgICAgIHRvcGljOiAncGhvZW5peCcsXG4gICAgICAgICAgICBldmVudDogJ2hlYXJ0YmVhdCcsXG4gICAgICAgICAgICBwYXlsb2FkOiB7fSxcbiAgICAgICAgICAgIHJlZjogdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXRBdXRoKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZsdXNoZXMgc2VuZCBidWZmZXJcbiAgICAgKi9cbiAgICBmbHVzaFNlbmRCdWZmZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ29ubmVjdGVkKCkgJiYgdGhpcy5zZW5kQnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZEJ1ZmZlci5mb3JFYWNoKChjYWxsYmFjaykgPT4gY2FsbGJhY2soKSk7XG4gICAgICAgICAgICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIG5leHQgbWVzc2FnZSByZWYsIGFjY291bnRpbmcgZm9yIG92ZXJmbG93c1xuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX21ha2VSZWYoKSB7XG4gICAgICAgIGxldCBuZXdSZWYgPSB0aGlzLnJlZiArIDE7XG4gICAgICAgIGlmIChuZXdSZWYgPT09IHRoaXMucmVmKSB7XG4gICAgICAgICAgICB0aGlzLnJlZiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlZiA9IG5ld1JlZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZWYudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5zdWJzY3JpYmUgZnJvbSBjaGFubmVscyB3aXRoIHRoZSBzcGVjaWZpZWQgdG9waWMuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfbGVhdmVPcGVuVG9waWModG9waWMpIHtcbiAgICAgICAgbGV0IGR1cENoYW5uZWwgPSB0aGlzLmNoYW5uZWxzLmZpbmQoKGMpID0+IGMudG9waWMgPT09IHRvcGljICYmIChjLl9pc0pvaW5lZCgpIHx8IGMuX2lzSm9pbmluZygpKSk7XG4gICAgICAgIGlmIChkdXBDaGFubmVsKSB7XG4gICAgICAgICAgICB0aGlzLmxvZygndHJhbnNwb3J0JywgYGxlYXZpbmcgZHVwbGljYXRlIHRvcGljIFwiJHt0b3BpY31cImApO1xuICAgICAgICAgICAgZHVwQ2hhbm5lbC51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBzdWJzY3JpcHRpb24gZnJvbSB0aGUgc29ja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNoYW5uZWwgQW4gb3BlbiBzdWJzY3JpcHRpb24uXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfcmVtb3ZlKGNoYW5uZWwpIHtcbiAgICAgICAgdGhpcy5jaGFubmVscyA9IHRoaXMuY2hhbm5lbHMuZmlsdGVyKChjKSA9PiBjLl9qb2luUmVmKCkgIT09IGNoYW5uZWwuX2pvaW5SZWYoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdXAgY29ubmVjdGlvbiBoYW5kbGVycy5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHNldHVwQ29ubmVjdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuY29ubikge1xuICAgICAgICAgICAgdGhpcy5jb25uLmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgICAgICAgdGhpcy5jb25uLm9ub3BlbiA9ICgpID0+IHRoaXMuX29uQ29ubk9wZW4oKTtcbiAgICAgICAgICAgIHRoaXMuY29ubi5vbmVycm9yID0gKGVycm9yKSA9PiB0aGlzLl9vbkNvbm5FcnJvcihlcnJvcik7XG4gICAgICAgICAgICB0aGlzLmNvbm4ub25tZXNzYWdlID0gKGV2ZW50KSA9PiB0aGlzLl9vbkNvbm5NZXNzYWdlKGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuY29ubi5vbmNsb3NlID0gKGV2ZW50KSA9PiB0aGlzLl9vbkNvbm5DbG9zZShldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9vbkNvbm5NZXNzYWdlKHJhd01lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5kZWNvZGUocmF3TWVzc2FnZS5kYXRhLCAobXNnKSA9PiB7XG4gICAgICAgICAgICBsZXQgeyB0b3BpYywgZXZlbnQsIHBheWxvYWQsIHJlZiB9ID0gbXNnO1xuICAgICAgICAgICAgaWYgKHJlZiAmJiByZWYgPT09IHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZikge1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxvZygncmVjZWl2ZScsIGAke3BheWxvYWQuc3RhdHVzIHx8ICcnfSAke3RvcGljfSAke2V2ZW50fSAkeyhyZWYgJiYgJygnICsgcmVmICsgJyknKSB8fCAnJ31gLCBwYXlsb2FkKTtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChjaGFubmVsKSA9PiBjaGFubmVsLl9pc01lbWJlcih0b3BpYykpXG4gICAgICAgICAgICAgICAgLmZvckVhY2goKGNoYW5uZWwpID0+IGNoYW5uZWwuX3RyaWdnZXIoZXZlbnQsIHBheWxvYWQsIHJlZikpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5tZXNzYWdlLmZvckVhY2goKGNhbGxiYWNrKSA9PiBjYWxsYmFjayhtc2cpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBhc3luYyBfb25Db25uT3BlbigpIHtcbiAgICAgICAgdGhpcy5sb2coJ3RyYW5zcG9ydCcsIGBjb25uZWN0ZWQgdG8gJHt0aGlzLmVuZHBvaW50VVJMKCl9YCk7XG4gICAgICAgIHRoaXMuZmx1c2hTZW5kQnVmZmVyKCk7XG4gICAgICAgIHRoaXMucmVjb25uZWN0VGltZXIucmVzZXQoKTtcbiAgICAgICAgaWYgKCF0aGlzLndvcmtlcikge1xuICAgICAgICAgICAgdGhpcy5oZWFydGJlYXRUaW1lciAmJiBjbGVhckludGVydmFsKHRoaXMuaGVhcnRiZWF0VGltZXIpO1xuICAgICAgICAgICAgdGhpcy5oZWFydGJlYXRUaW1lciA9IHNldEludGVydmFsKCgpID0+IHRoaXMuc2VuZEhlYXJ0YmVhdCgpLCB0aGlzLmhlYXJ0YmVhdEludGVydmFsTXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMud29ya2VyVXJsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2coJ3dvcmtlcicsIGBzdGFydGluZyB3b3JrZXIgZm9yIGZyb20gJHt0aGlzLndvcmtlclVybH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nKCd3b3JrZXInLCBgc3RhcnRpbmcgZGVmYXVsdCB3b3JrZXJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9iamVjdFVybCA9IHRoaXMuX3dvcmtlck9iamVjdFVybCh0aGlzLndvcmtlclVybCk7XG4gICAgICAgICAgICB0aGlzLndvcmtlclJlZiA9IG5ldyBXb3JrZXIob2JqZWN0VXJsKTtcbiAgICAgICAgICAgIHRoaXMud29ya2VyUmVmLm9uZXJyb3IgPSAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZygnd29ya2VyJywgJ3dvcmtlciBlcnJvcicsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHRoaXMud29ya2VyUmVmLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMud29ya2VyUmVmLm9ubWVzc2FnZSA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5kYXRhLmV2ZW50ID09PSAna2VlcEFsaXZlJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmRIZWFydGJlYXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy53b3JrZXJSZWYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIGV2ZW50OiAnc3RhcnQnLFxuICAgICAgICAgICAgICAgIGludGVydmFsOiB0aGlzLmhlYXJ0YmVhdEludGVydmFsTXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLm9wZW4uZm9yRWFjaCgoY2FsbGJhY2spID0+IGNhbGxiYWNrKCkpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX29uQ29ubkNsb3NlKGV2ZW50KSB7XG4gICAgICAgIHRoaXMubG9nKCd0cmFuc3BvcnQnLCAnY2xvc2UnLCBldmVudCk7XG4gICAgICAgIHRoaXMuX3RyaWdnZXJDaGFuRXJyb3IoKTtcbiAgICAgICAgdGhpcy5oZWFydGJlYXRUaW1lciAmJiBjbGVhckludGVydmFsKHRoaXMuaGVhcnRiZWF0VGltZXIpO1xuICAgICAgICB0aGlzLnJlY29ubmVjdFRpbWVyLnNjaGVkdWxlVGltZW91dCgpO1xuICAgICAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLmNsb3NlLmZvckVhY2goKGNhbGxiYWNrKSA9PiBjYWxsYmFjayhldmVudCkpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX29uQ29ubkVycm9yKGVycm9yKSB7XG4gICAgICAgIHRoaXMubG9nKCd0cmFuc3BvcnQnLCBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgdGhpcy5fdHJpZ2dlckNoYW5FcnJvcigpO1xuICAgICAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLmVycm9yLmZvckVhY2goKGNhbGxiYWNrKSA9PiBjYWxsYmFjayhlcnJvcikpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3RyaWdnZXJDaGFuRXJyb3IoKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbHMuZm9yRWFjaCgoY2hhbm5lbCkgPT4gY2hhbm5lbC5fdHJpZ2dlcihDSEFOTkVMX0VWRU5UUy5lcnJvcikpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2FwcGVuZFBhcmFtcyh1cmwsIHBhcmFtcykge1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMocGFyYW1zKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1cmw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJlZml4ID0gdXJsLm1hdGNoKC9cXD8vKSA/ICcmJyA6ICc/JztcbiAgICAgICAgY29uc3QgcXVlcnkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhcmFtcyk7XG4gICAgICAgIHJldHVybiBgJHt1cmx9JHtwcmVmaXh9JHtxdWVyeX1gO1xuICAgIH1cbiAgICBfd29ya2VyT2JqZWN0VXJsKHVybCkge1xuICAgICAgICBsZXQgcmVzdWx0X3VybDtcbiAgICAgICAgaWYgKHVybCkge1xuICAgICAgICAgICAgcmVzdWx0X3VybCA9IHVybDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbV09SS0VSX1NDUklQVF0sIHsgdHlwZTogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnIH0pO1xuICAgICAgICAgICAgcmVzdWx0X3VybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdF91cmw7XG4gICAgfVxufVxuY2xhc3MgV1NXZWJTb2NrZXREdW1teSB7XG4gICAgY29uc3RydWN0b3IoYWRkcmVzcywgX3Byb3RvY29scywgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgICB0aGlzLm9uY2xvc2UgPSAoKSA9PiB7IH07XG4gICAgICAgIHRoaXMub25lcnJvciA9ICgpID0+IHsgfTtcbiAgICAgICAgdGhpcy5vbm1lc3NhZ2UgPSAoKSA9PiB7IH07XG4gICAgICAgIHRoaXMub25vcGVuID0gKCkgPT4geyB9O1xuICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSBTT0NLRVRfU1RBVEVTLmNvbm5lY3Rpbmc7XG4gICAgICAgIHRoaXMuc2VuZCA9ICgpID0+IHsgfTtcbiAgICAgICAgdGhpcy51cmwgPSBudWxsO1xuICAgICAgICB0aGlzLnVybCA9IGFkZHJlc3M7XG4gICAgICAgIHRoaXMuY2xvc2UgPSBvcHRpb25zLmNsb3NlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlYWx0aW1lQ2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/RealtimeClient.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   REALTIME_PRESENCE_LISTEN_EVENTS: () => (/* binding */ REALTIME_PRESENCE_LISTEN_EVENTS),\n/* harmony export */   \"default\": () => (/* binding */ RealtimePresence)\n/* harmony export */ });\n/*\n  This file draws heavily from https://github.com/phoenixframework/phoenix/blob/d344ec0a732ab4ee204215b31de69cf4be72e3bf/assets/js/phoenix/presence.js\n  License: https://github.com/phoenixframework/phoenix/blob/d344ec0a732ab4ee204215b31de69cf4be72e3bf/LICENSE.md\n*/\nvar REALTIME_PRESENCE_LISTEN_EVENTS;\n(function (REALTIME_PRESENCE_LISTEN_EVENTS) {\n    REALTIME_PRESENCE_LISTEN_EVENTS[\"SYNC\"] = \"sync\";\n    REALTIME_PRESENCE_LISTEN_EVENTS[\"JOIN\"] = \"join\";\n    REALTIME_PRESENCE_LISTEN_EVENTS[\"LEAVE\"] = \"leave\";\n})(REALTIME_PRESENCE_LISTEN_EVENTS || (REALTIME_PRESENCE_LISTEN_EVENTS = {}));\nclass RealtimePresence {\n    /**\n     * Initializes the Presence.\n     *\n     * @param channel - The RealtimeChannel\n     * @param opts - The options,\n     *        for example `{events: {state: 'state', diff: 'diff'}}`\n     */\n    constructor(channel, opts) {\n        this.channel = channel;\n        this.state = {};\n        this.pendingDiffs = [];\n        this.joinRef = null;\n        this.caller = {\n            onJoin: () => { },\n            onLeave: () => { },\n            onSync: () => { },\n        };\n        const events = (opts === null || opts === void 0 ? void 0 : opts.events) || {\n            state: 'presence_state',\n            diff: 'presence_diff',\n        };\n        this.channel._on(events.state, {}, (newState) => {\n            const { onJoin, onLeave, onSync } = this.caller;\n            this.joinRef = this.channel._joinRef();\n            this.state = RealtimePresence.syncState(this.state, newState, onJoin, onLeave);\n            this.pendingDiffs.forEach((diff) => {\n                this.state = RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);\n            });\n            this.pendingDiffs = [];\n            onSync();\n        });\n        this.channel._on(events.diff, {}, (diff) => {\n            const { onJoin, onLeave, onSync } = this.caller;\n            if (this.inPendingSyncState()) {\n                this.pendingDiffs.push(diff);\n            }\n            else {\n                this.state = RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);\n                onSync();\n            }\n        });\n        this.onJoin((key, currentPresences, newPresences) => {\n            this.channel._trigger('presence', {\n                event: 'join',\n                key,\n                currentPresences,\n                newPresences,\n            });\n        });\n        this.onLeave((key, currentPresences, leftPresences) => {\n            this.channel._trigger('presence', {\n                event: 'leave',\n                key,\n                currentPresences,\n                leftPresences,\n            });\n        });\n        this.onSync(() => {\n            this.channel._trigger('presence', { event: 'sync' });\n        });\n    }\n    /**\n     * Used to sync the list of presences on the server with the\n     * client's state.\n     *\n     * An optional `onJoin` and `onLeave` callback can be provided to\n     * react to changes in the client's local presences across\n     * disconnects and reconnects with the server.\n     *\n     * @internal\n     */\n    static syncState(currentState, newState, onJoin, onLeave) {\n        const state = this.cloneDeep(currentState);\n        const transformedState = this.transformState(newState);\n        const joins = {};\n        const leaves = {};\n        this.map(state, (key, presences) => {\n            if (!transformedState[key]) {\n                leaves[key] = presences;\n            }\n        });\n        this.map(transformedState, (key, newPresences) => {\n            const currentPresences = state[key];\n            if (currentPresences) {\n                const newPresenceRefs = newPresences.map((m) => m.presence_ref);\n                const curPresenceRefs = currentPresences.map((m) => m.presence_ref);\n                const joinedPresences = newPresences.filter((m) => curPresenceRefs.indexOf(m.presence_ref) < 0);\n                const leftPresences = currentPresences.filter((m) => newPresenceRefs.indexOf(m.presence_ref) < 0);\n                if (joinedPresences.length > 0) {\n                    joins[key] = joinedPresences;\n                }\n                if (leftPresences.length > 0) {\n                    leaves[key] = leftPresences;\n                }\n            }\n            else {\n                joins[key] = newPresences;\n            }\n        });\n        return this.syncDiff(state, { joins, leaves }, onJoin, onLeave);\n    }\n    /**\n     * Used to sync a diff of presence join and leave events from the\n     * server, as they happen.\n     *\n     * Like `syncState`, `syncDiff` accepts optional `onJoin` and\n     * `onLeave` callbacks to react to a user joining or leaving from a\n     * device.\n     *\n     * @internal\n     */\n    static syncDiff(state, diff, onJoin, onLeave) {\n        const { joins, leaves } = {\n            joins: this.transformState(diff.joins),\n            leaves: this.transformState(diff.leaves),\n        };\n        if (!onJoin) {\n            onJoin = () => { };\n        }\n        if (!onLeave) {\n            onLeave = () => { };\n        }\n        this.map(joins, (key, newPresences) => {\n            var _a;\n            const currentPresences = (_a = state[key]) !== null && _a !== void 0 ? _a : [];\n            state[key] = this.cloneDeep(newPresences);\n            if (currentPresences.length > 0) {\n                const joinedPresenceRefs = state[key].map((m) => m.presence_ref);\n                const curPresences = currentPresences.filter((m) => joinedPresenceRefs.indexOf(m.presence_ref) < 0);\n                state[key].unshift(...curPresences);\n            }\n            onJoin(key, currentPresences, newPresences);\n        });\n        this.map(leaves, (key, leftPresences) => {\n            let currentPresences = state[key];\n            if (!currentPresences)\n                return;\n            const presenceRefsToRemove = leftPresences.map((m) => m.presence_ref);\n            currentPresences = currentPresences.filter((m) => presenceRefsToRemove.indexOf(m.presence_ref) < 0);\n            state[key] = currentPresences;\n            onLeave(key, currentPresences, leftPresences);\n            if (currentPresences.length === 0)\n                delete state[key];\n        });\n        return state;\n    }\n    /** @internal */\n    static map(obj, func) {\n        return Object.getOwnPropertyNames(obj).map((key) => func(key, obj[key]));\n    }\n    /**\n     * Remove 'metas' key\n     * Change 'phx_ref' to 'presence_ref'\n     * Remove 'phx_ref' and 'phx_ref_prev'\n     *\n     * @example\n     * // returns {\n     *  abc123: [\n     *    { presence_ref: '2', user_id: 1 },\n     *    { presence_ref: '3', user_id: 2 }\n     *  ]\n     * }\n     * RealtimePresence.transformState({\n     *  abc123: {\n     *    metas: [\n     *      { phx_ref: '2', phx_ref_prev: '1' user_id: 1 },\n     *      { phx_ref: '3', user_id: 2 }\n     *    ]\n     *  }\n     * })\n     *\n     * @internal\n     */\n    static transformState(state) {\n        state = this.cloneDeep(state);\n        return Object.getOwnPropertyNames(state).reduce((newState, key) => {\n            const presences = state[key];\n            if ('metas' in presences) {\n                newState[key] = presences.metas.map((presence) => {\n                    presence['presence_ref'] = presence['phx_ref'];\n                    delete presence['phx_ref'];\n                    delete presence['phx_ref_prev'];\n                    return presence;\n                });\n            }\n            else {\n                newState[key] = presences;\n            }\n            return newState;\n        }, {});\n    }\n    /** @internal */\n    static cloneDeep(obj) {\n        return JSON.parse(JSON.stringify(obj));\n    }\n    /** @internal */\n    onJoin(callback) {\n        this.caller.onJoin = callback;\n    }\n    /** @internal */\n    onLeave(callback) {\n        this.caller.onLeave = callback;\n    }\n    /** @internal */\n    onSync(callback) {\n        this.caller.onSync = callback;\n    }\n    /** @internal */\n    inPendingSyncState() {\n        return !this.joinRef || this.joinRef !== this.channel._joinRef();\n    }\n}\n//# sourceMappingURL=RealtimePresence.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvUmVhbHRpbWVQcmVzZW5jZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMEVBQTBFO0FBQzVEO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixTQUFTLDhCQUE4QjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qiw4QkFBOEI7QUFDOUIsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMsb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNULHdDQUF3QztBQUN4QyxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBLGdEQUFnRCxlQUFlO0FBQy9ELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsc0NBQXNDLGVBQWU7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrQkFBK0I7QUFDM0MsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDRDQUE0QztBQUMxRCxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvV29uZGVyVml0ZS1mcm9udGVuZC9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL1JlYWx0aW1lUHJlc2VuY2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgVGhpcyBmaWxlIGRyYXdzIGhlYXZpbHkgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vcGhvZW5peGZyYW1ld29yay9waG9lbml4L2Jsb2IvZDM0NGVjMGE3MzJhYjRlZTIwNDIxNWIzMWRlNjljZjRiZTcyZTNiZi9hc3NldHMvanMvcGhvZW5peC9wcmVzZW5jZS5qc1xuICBMaWNlbnNlOiBodHRwczovL2dpdGh1Yi5jb20vcGhvZW5peGZyYW1ld29yay9waG9lbml4L2Jsb2IvZDM0NGVjMGE3MzJhYjRlZTIwNDIxNWIzMWRlNjljZjRiZTcyZTNiZi9MSUNFTlNFLm1kXG4qL1xuZXhwb3J0IHZhciBSRUFMVElNRV9QUkVTRU5DRV9MSVNURU5fRVZFTlRTO1xuKGZ1bmN0aW9uIChSRUFMVElNRV9QUkVTRU5DRV9MSVNURU5fRVZFTlRTKSB7XG4gICAgUkVBTFRJTUVfUFJFU0VOQ0VfTElTVEVOX0VWRU5UU1tcIlNZTkNcIl0gPSBcInN5bmNcIjtcbiAgICBSRUFMVElNRV9QUkVTRU5DRV9MSVNURU5fRVZFTlRTW1wiSk9JTlwiXSA9IFwiam9pblwiO1xuICAgIFJFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFNbXCJMRUFWRVwiXSA9IFwibGVhdmVcIjtcbn0pKFJFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFMgfHwgKFJFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFMgPSB7fSkpO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVhbHRpbWVQcmVzZW5jZSB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIFByZXNlbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNoYW5uZWwgLSBUaGUgUmVhbHRpbWVDaGFubmVsXG4gICAgICogQHBhcmFtIG9wdHMgLSBUaGUgb3B0aW9ucyxcbiAgICAgKiAgICAgICAgZm9yIGV4YW1wbGUgYHtldmVudHM6IHtzdGF0ZTogJ3N0YXRlJywgZGlmZjogJ2RpZmYnfX1gXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY2hhbm5lbCwgb3B0cykge1xuICAgICAgICB0aGlzLmNoYW5uZWwgPSBjaGFubmVsO1xuICAgICAgICB0aGlzLnN0YXRlID0ge307XG4gICAgICAgIHRoaXMucGVuZGluZ0RpZmZzID0gW107XG4gICAgICAgIHRoaXMuam9pblJlZiA9IG51bGw7XG4gICAgICAgIHRoaXMuY2FsbGVyID0ge1xuICAgICAgICAgICAgb25Kb2luOiAoKSA9PiB7IH0sXG4gICAgICAgICAgICBvbkxlYXZlOiAoKSA9PiB7IH0sXG4gICAgICAgICAgICBvblN5bmM6ICgpID0+IHsgfSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZXZlbnRzID0gKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5ldmVudHMpIHx8IHtcbiAgICAgICAgICAgIHN0YXRlOiAncHJlc2VuY2Vfc3RhdGUnLFxuICAgICAgICAgICAgZGlmZjogJ3ByZXNlbmNlX2RpZmYnLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNoYW5uZWwuX29uKGV2ZW50cy5zdGF0ZSwge30sIChuZXdTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBvbkpvaW4sIG9uTGVhdmUsIG9uU3luYyB9ID0gdGhpcy5jYWxsZXI7XG4gICAgICAgICAgICB0aGlzLmpvaW5SZWYgPSB0aGlzLmNoYW5uZWwuX2pvaW5SZWYoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBSZWFsdGltZVByZXNlbmNlLnN5bmNTdGF0ZSh0aGlzLnN0YXRlLCBuZXdTdGF0ZSwgb25Kb2luLCBvbkxlYXZlKTtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0RpZmZzLmZvckVhY2goKGRpZmYpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gUmVhbHRpbWVQcmVzZW5jZS5zeW5jRGlmZih0aGlzLnN0YXRlLCBkaWZmLCBvbkpvaW4sIG9uTGVhdmUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdEaWZmcyA9IFtdO1xuICAgICAgICAgICAgb25TeW5jKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNoYW5uZWwuX29uKGV2ZW50cy5kaWZmLCB7fSwgKGRpZmYpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgb25Kb2luLCBvbkxlYXZlLCBvblN5bmMgfSA9IHRoaXMuY2FsbGVyO1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5QZW5kaW5nU3luY1N0YXRlKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdEaWZmcy5wdXNoKGRpZmYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFJlYWx0aW1lUHJlc2VuY2Uuc3luY0RpZmYodGhpcy5zdGF0ZSwgZGlmZiwgb25Kb2luLCBvbkxlYXZlKTtcbiAgICAgICAgICAgICAgICBvblN5bmMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub25Kb2luKChrZXksIGN1cnJlbnRQcmVzZW5jZXMsIG5ld1ByZXNlbmNlcykgPT4ge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsLl90cmlnZ2VyKCdwcmVzZW5jZScsIHtcbiAgICAgICAgICAgICAgICBldmVudDogJ2pvaW4nLFxuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICBjdXJyZW50UHJlc2VuY2VzLFxuICAgICAgICAgICAgICAgIG5ld1ByZXNlbmNlcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vbkxlYXZlKChrZXksIGN1cnJlbnRQcmVzZW5jZXMsIGxlZnRQcmVzZW5jZXMpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbC5fdHJpZ2dlcigncHJlc2VuY2UnLCB7XG4gICAgICAgICAgICAgICAgZXZlbnQ6ICdsZWF2ZScsXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIGN1cnJlbnRQcmVzZW5jZXMsXG4gICAgICAgICAgICAgICAgbGVmdFByZXNlbmNlcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vblN5bmMoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsLl90cmlnZ2VyKCdwcmVzZW5jZScsIHsgZXZlbnQ6ICdzeW5jJyB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gc3luYyB0aGUgbGlzdCBvZiBwcmVzZW5jZXMgb24gdGhlIHNlcnZlciB3aXRoIHRoZVxuICAgICAqIGNsaWVudCdzIHN0YXRlLlxuICAgICAqXG4gICAgICogQW4gb3B0aW9uYWwgYG9uSm9pbmAgYW5kIGBvbkxlYXZlYCBjYWxsYmFjayBjYW4gYmUgcHJvdmlkZWQgdG9cbiAgICAgKiByZWFjdCB0byBjaGFuZ2VzIGluIHRoZSBjbGllbnQncyBsb2NhbCBwcmVzZW5jZXMgYWNyb3NzXG4gICAgICogZGlzY29ubmVjdHMgYW5kIHJlY29ubmVjdHMgd2l0aCB0aGUgc2VydmVyLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgc3RhdGljIHN5bmNTdGF0ZShjdXJyZW50U3RhdGUsIG5ld1N0YXRlLCBvbkpvaW4sIG9uTGVhdmUpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLmNsb25lRGVlcChjdXJyZW50U3RhdGUpO1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZFN0YXRlID0gdGhpcy50cmFuc2Zvcm1TdGF0ZShuZXdTdGF0ZSk7XG4gICAgICAgIGNvbnN0IGpvaW5zID0ge307XG4gICAgICAgIGNvbnN0IGxlYXZlcyA9IHt9O1xuICAgICAgICB0aGlzLm1hcChzdGF0ZSwgKGtleSwgcHJlc2VuY2VzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRyYW5zZm9ybWVkU3RhdGVba2V5XSkge1xuICAgICAgICAgICAgICAgIGxlYXZlc1trZXldID0gcHJlc2VuY2VzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tYXAodHJhbnNmb3JtZWRTdGF0ZSwgKGtleSwgbmV3UHJlc2VuY2VzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50UHJlc2VuY2VzID0gc3RhdGVba2V5XTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UHJlc2VuY2VzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3UHJlc2VuY2VSZWZzID0gbmV3UHJlc2VuY2VzLm1hcCgobSkgPT4gbS5wcmVzZW5jZV9yZWYpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1clByZXNlbmNlUmVmcyA9IGN1cnJlbnRQcmVzZW5jZXMubWFwKChtKSA9PiBtLnByZXNlbmNlX3JlZik7XG4gICAgICAgICAgICAgICAgY29uc3Qgam9pbmVkUHJlc2VuY2VzID0gbmV3UHJlc2VuY2VzLmZpbHRlcigobSkgPT4gY3VyUHJlc2VuY2VSZWZzLmluZGV4T2YobS5wcmVzZW5jZV9yZWYpIDwgMCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVmdFByZXNlbmNlcyA9IGN1cnJlbnRQcmVzZW5jZXMuZmlsdGVyKChtKSA9PiBuZXdQcmVzZW5jZVJlZnMuaW5kZXhPZihtLnByZXNlbmNlX3JlZikgPCAwKTtcbiAgICAgICAgICAgICAgICBpZiAoam9pbmVkUHJlc2VuY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgam9pbnNba2V5XSA9IGpvaW5lZFByZXNlbmNlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxlZnRQcmVzZW5jZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBsZWF2ZXNba2V5XSA9IGxlZnRQcmVzZW5jZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgam9pbnNba2V5XSA9IG5ld1ByZXNlbmNlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnN5bmNEaWZmKHN0YXRlLCB7IGpvaW5zLCBsZWF2ZXMgfSwgb25Kb2luLCBvbkxlYXZlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNlZCB0byBzeW5jIGEgZGlmZiBvZiBwcmVzZW5jZSBqb2luIGFuZCBsZWF2ZSBldmVudHMgZnJvbSB0aGVcbiAgICAgKiBzZXJ2ZXIsIGFzIHRoZXkgaGFwcGVuLlxuICAgICAqXG4gICAgICogTGlrZSBgc3luY1N0YXRlYCwgYHN5bmNEaWZmYCBhY2NlcHRzIG9wdGlvbmFsIGBvbkpvaW5gIGFuZFxuICAgICAqIGBvbkxlYXZlYCBjYWxsYmFja3MgdG8gcmVhY3QgdG8gYSB1c2VyIGpvaW5pbmcgb3IgbGVhdmluZyBmcm9tIGFcbiAgICAgKiBkZXZpY2UuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzdGF0aWMgc3luY0RpZmYoc3RhdGUsIGRpZmYsIG9uSm9pbiwgb25MZWF2ZSkge1xuICAgICAgICBjb25zdCB7IGpvaW5zLCBsZWF2ZXMgfSA9IHtcbiAgICAgICAgICAgIGpvaW5zOiB0aGlzLnRyYW5zZm9ybVN0YXRlKGRpZmYuam9pbnMpLFxuICAgICAgICAgICAgbGVhdmVzOiB0aGlzLnRyYW5zZm9ybVN0YXRlKGRpZmYubGVhdmVzKSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFvbkpvaW4pIHtcbiAgICAgICAgICAgIG9uSm9pbiA9ICgpID0+IHsgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9uTGVhdmUpIHtcbiAgICAgICAgICAgIG9uTGVhdmUgPSAoKSA9PiB7IH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXAoam9pbnMsIChrZXksIG5ld1ByZXNlbmNlcykgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFByZXNlbmNlcyA9IChfYSA9IHN0YXRlW2tleV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdO1xuICAgICAgICAgICAgc3RhdGVba2V5XSA9IHRoaXMuY2xvbmVEZWVwKG5ld1ByZXNlbmNlcyk7XG4gICAgICAgICAgICBpZiAoY3VycmVudFByZXNlbmNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgam9pbmVkUHJlc2VuY2VSZWZzID0gc3RhdGVba2V5XS5tYXAoKG0pID0+IG0ucHJlc2VuY2VfcmVmKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJQcmVzZW5jZXMgPSBjdXJyZW50UHJlc2VuY2VzLmZpbHRlcigobSkgPT4gam9pbmVkUHJlc2VuY2VSZWZzLmluZGV4T2YobS5wcmVzZW5jZV9yZWYpIDwgMCk7XG4gICAgICAgICAgICAgICAgc3RhdGVba2V5XS51bnNoaWZ0KC4uLmN1clByZXNlbmNlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbkpvaW4oa2V5LCBjdXJyZW50UHJlc2VuY2VzLCBuZXdQcmVzZW5jZXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tYXAobGVhdmVzLCAoa2V5LCBsZWZ0UHJlc2VuY2VzKSA9PiB7XG4gICAgICAgICAgICBsZXQgY3VycmVudFByZXNlbmNlcyA9IHN0YXRlW2tleV07XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnRQcmVzZW5jZXMpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgcHJlc2VuY2VSZWZzVG9SZW1vdmUgPSBsZWZ0UHJlc2VuY2VzLm1hcCgobSkgPT4gbS5wcmVzZW5jZV9yZWYpO1xuICAgICAgICAgICAgY3VycmVudFByZXNlbmNlcyA9IGN1cnJlbnRQcmVzZW5jZXMuZmlsdGVyKChtKSA9PiBwcmVzZW5jZVJlZnNUb1JlbW92ZS5pbmRleE9mKG0ucHJlc2VuY2VfcmVmKSA8IDApO1xuICAgICAgICAgICAgc3RhdGVba2V5XSA9IGN1cnJlbnRQcmVzZW5jZXM7XG4gICAgICAgICAgICBvbkxlYXZlKGtleSwgY3VycmVudFByZXNlbmNlcywgbGVmdFByZXNlbmNlcyk7XG4gICAgICAgICAgICBpZiAoY3VycmVudFByZXNlbmNlcy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgZGVsZXRlIHN0YXRlW2tleV07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBzdGF0aWMgbWFwKG9iaiwgZnVuYykge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5tYXAoKGtleSkgPT4gZnVuYyhrZXksIG9ialtrZXldKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSAnbWV0YXMnIGtleVxuICAgICAqIENoYW5nZSAncGh4X3JlZicgdG8gJ3ByZXNlbmNlX3JlZidcbiAgICAgKiBSZW1vdmUgJ3BoeF9yZWYnIGFuZCAncGh4X3JlZl9wcmV2J1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyByZXR1cm5zIHtcbiAgICAgKiAgYWJjMTIzOiBbXG4gICAgICogICAgeyBwcmVzZW5jZV9yZWY6ICcyJywgdXNlcl9pZDogMSB9LFxuICAgICAqICAgIHsgcHJlc2VuY2VfcmVmOiAnMycsIHVzZXJfaWQ6IDIgfVxuICAgICAqICBdXG4gICAgICogfVxuICAgICAqIFJlYWx0aW1lUHJlc2VuY2UudHJhbnNmb3JtU3RhdGUoe1xuICAgICAqICBhYmMxMjM6IHtcbiAgICAgKiAgICBtZXRhczogW1xuICAgICAqICAgICAgeyBwaHhfcmVmOiAnMicsIHBoeF9yZWZfcHJldjogJzEnIHVzZXJfaWQ6IDEgfSxcbiAgICAgKiAgICAgIHsgcGh4X3JlZjogJzMnLCB1c2VyX2lkOiAyIH1cbiAgICAgKiAgICBdXG4gICAgICogIH1cbiAgICAgKiB9KVxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgc3RhdGljIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gICAgICAgIHN0YXRlID0gdGhpcy5jbG9uZURlZXAoc3RhdGUpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc3RhdGUpLnJlZHVjZSgobmV3U3RhdGUsIGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcHJlc2VuY2VzID0gc3RhdGVba2V5XTtcbiAgICAgICAgICAgIGlmICgnbWV0YXMnIGluIHByZXNlbmNlcykge1xuICAgICAgICAgICAgICAgIG5ld1N0YXRlW2tleV0gPSBwcmVzZW5jZXMubWV0YXMubWFwKChwcmVzZW5jZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBwcmVzZW5jZVsncHJlc2VuY2VfcmVmJ10gPSBwcmVzZW5jZVsncGh4X3JlZiddO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcHJlc2VuY2VbJ3BoeF9yZWYnXTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHByZXNlbmNlWydwaHhfcmVmX3ByZXYnXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZXNlbmNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3U3RhdGVba2V5XSA9IHByZXNlbmNlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgICAgICAgfSwge30pO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgc3RhdGljIGNsb25lRGVlcChvYmopIHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBvbkpvaW4oY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5jYWxsZXIub25Kb2luID0gY2FsbGJhY2s7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBvbkxlYXZlKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuY2FsbGVyLm9uTGVhdmUgPSBjYWxsYmFjaztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIG9uU3luYyhjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmNhbGxlci5vblN5bmMgPSBjYWxsYmFjaztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGluUGVuZGluZ1N5bmNTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmpvaW5SZWYgfHwgdGhpcy5qb2luUmVmICE9PSB0aGlzLmNoYW5uZWwuX2pvaW5SZWYoKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZWFsdGltZVByZXNlbmNlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   REALTIME_CHANNEL_STATES: () => (/* reexport safe */ _RealtimeChannel__WEBPACK_IMPORTED_MODULE_1__.REALTIME_CHANNEL_STATES),\n/* harmony export */   REALTIME_LISTEN_TYPES: () => (/* reexport safe */ _RealtimeChannel__WEBPACK_IMPORTED_MODULE_1__.REALTIME_LISTEN_TYPES),\n/* harmony export */   REALTIME_POSTGRES_CHANGES_LISTEN_EVENT: () => (/* reexport safe */ _RealtimeChannel__WEBPACK_IMPORTED_MODULE_1__.REALTIME_POSTGRES_CHANGES_LISTEN_EVENT),\n/* harmony export */   REALTIME_PRESENCE_LISTEN_EVENTS: () => (/* reexport safe */ _RealtimePresence__WEBPACK_IMPORTED_MODULE_2__.REALTIME_PRESENCE_LISTEN_EVENTS),\n/* harmony export */   REALTIME_SUBSCRIBE_STATES: () => (/* reexport safe */ _RealtimeChannel__WEBPACK_IMPORTED_MODULE_1__.REALTIME_SUBSCRIBE_STATES),\n/* harmony export */   RealtimeChannel: () => (/* reexport safe */ _RealtimeChannel__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   RealtimeClient: () => (/* reexport safe */ _RealtimeClient__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   RealtimePresence: () => (/* reexport safe */ _RealtimePresence__WEBPACK_IMPORTED_MODULE_2__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _RealtimeClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RealtimeClient */ \"(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/RealtimeClient.js\");\n/* harmony import */ var _RealtimeChannel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RealtimeChannel */ \"(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js\");\n/* harmony import */ var _RealtimePresence__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./RealtimePresence */ \"(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js\");\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBOEM7QUFDMEg7QUFDaEY7QUFDMEg7QUFDbE4iLCJzb3VyY2VzIjpbIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL1dvbmRlclZpdGUtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9yZWFsdGltZS1qcy9kaXN0L21vZHVsZS9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhbHRpbWVDbGllbnQgZnJvbSAnLi9SZWFsdGltZUNsaWVudCc7XG5pbXBvcnQgUmVhbHRpbWVDaGFubmVsLCB7IFJFQUxUSU1FX0xJU1RFTl9UWVBFUywgUkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlQsIFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMsIFJFQUxUSU1FX0NIQU5ORUxfU1RBVEVTLCB9IGZyb20gJy4vUmVhbHRpbWVDaGFubmVsJztcbmltcG9ydCBSZWFsdGltZVByZXNlbmNlLCB7IFJFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFMsIH0gZnJvbSAnLi9SZWFsdGltZVByZXNlbmNlJztcbmV4cG9ydCB7IFJlYWx0aW1lUHJlc2VuY2UsIFJlYWx0aW1lQ2hhbm5lbCwgUmVhbHRpbWVDbGllbnQsIFJFQUxUSU1FX0xJU1RFTl9UWVBFUywgUkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlQsIFJFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFMsIFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMsIFJFQUxUSU1FX0NIQU5ORUxfU1RBVEVTLCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/constants.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/lib/constants.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CHANNEL_EVENTS: () => (/* binding */ CHANNEL_EVENTS),\n/* harmony export */   CHANNEL_STATES: () => (/* binding */ CHANNEL_STATES),\n/* harmony export */   CONNECTION_STATE: () => (/* binding */ CONNECTION_STATE),\n/* harmony export */   DEFAULT_HEADERS: () => (/* binding */ DEFAULT_HEADERS),\n/* harmony export */   DEFAULT_TIMEOUT: () => (/* binding */ DEFAULT_TIMEOUT),\n/* harmony export */   SOCKET_STATES: () => (/* binding */ SOCKET_STATES),\n/* harmony export */   TRANSPORTS: () => (/* binding */ TRANSPORTS),\n/* harmony export */   VSN: () => (/* binding */ VSN),\n/* harmony export */   WS_CLOSE_NORMAL: () => (/* binding */ WS_CLOSE_NORMAL)\n/* harmony export */ });\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./version */ \"(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/version.js\");\n\nconst DEFAULT_HEADERS = { 'X-Client-Info': `realtime-js/${_version__WEBPACK_IMPORTED_MODULE_0__.version}` };\nconst VSN = '1.0.0';\nconst DEFAULT_TIMEOUT = 10000;\nconst WS_CLOSE_NORMAL = 1000;\nvar SOCKET_STATES;\n(function (SOCKET_STATES) {\n    SOCKET_STATES[SOCKET_STATES[\"connecting\"] = 0] = \"connecting\";\n    SOCKET_STATES[SOCKET_STATES[\"open\"] = 1] = \"open\";\n    SOCKET_STATES[SOCKET_STATES[\"closing\"] = 2] = \"closing\";\n    SOCKET_STATES[SOCKET_STATES[\"closed\"] = 3] = \"closed\";\n})(SOCKET_STATES || (SOCKET_STATES = {}));\nvar CHANNEL_STATES;\n(function (CHANNEL_STATES) {\n    CHANNEL_STATES[\"closed\"] = \"closed\";\n    CHANNEL_STATES[\"errored\"] = \"errored\";\n    CHANNEL_STATES[\"joined\"] = \"joined\";\n    CHANNEL_STATES[\"joining\"] = \"joining\";\n    CHANNEL_STATES[\"leaving\"] = \"leaving\";\n})(CHANNEL_STATES || (CHANNEL_STATES = {}));\nvar CHANNEL_EVENTS;\n(function (CHANNEL_EVENTS) {\n    CHANNEL_EVENTS[\"close\"] = \"phx_close\";\n    CHANNEL_EVENTS[\"error\"] = \"phx_error\";\n    CHANNEL_EVENTS[\"join\"] = \"phx_join\";\n    CHANNEL_EVENTS[\"reply\"] = \"phx_reply\";\n    CHANNEL_EVENTS[\"leave\"] = \"phx_leave\";\n    CHANNEL_EVENTS[\"access_token\"] = \"access_token\";\n})(CHANNEL_EVENTS || (CHANNEL_EVENTS = {}));\nvar TRANSPORTS;\n(function (TRANSPORTS) {\n    TRANSPORTS[\"websocket\"] = \"websocket\";\n})(TRANSPORTS || (TRANSPORTS = {}));\nvar CONNECTION_STATE;\n(function (CONNECTION_STATE) {\n    CONNECTION_STATE[\"Connecting\"] = \"connecting\";\n    CONNECTION_STATE[\"Open\"] = \"open\";\n    CONNECTION_STATE[\"Closing\"] = \"closing\";\n    CONNECTION_STATE[\"Closed\"] = \"closed\";\n})(CONNECTION_STATE || (CONNECTION_STATE = {}));\n//# sourceMappingURL=constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvbGliL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQW9DO0FBQzdCLDBCQUEwQixnQ0FBZ0MsNkNBQU8sQ0FBQztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNDQUFzQztBQUNoQztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0NBQXdDO0FBQ2xDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdDQUF3QztBQUNsQztBQUNQO0FBQ0E7QUFDQSxDQUFDLGdDQUFnQztBQUMxQjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRDQUE0QztBQUM3QyIsInNvdXJjZXMiOlsiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvV29uZGVyVml0ZS1mcm9udGVuZC9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL2xpYi9jb25zdGFudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gJy4vdmVyc2lvbic7XG5leHBvcnQgY29uc3QgREVGQVVMVF9IRUFERVJTID0geyAnWC1DbGllbnQtSW5mbyc6IGByZWFsdGltZS1qcy8ke3ZlcnNpb259YCB9O1xuZXhwb3J0IGNvbnN0IFZTTiA9ICcxLjAuMCc7XG5leHBvcnQgY29uc3QgREVGQVVMVF9USU1FT1VUID0gMTAwMDA7XG5leHBvcnQgY29uc3QgV1NfQ0xPU0VfTk9STUFMID0gMTAwMDtcbmV4cG9ydCB2YXIgU09DS0VUX1NUQVRFUztcbihmdW5jdGlvbiAoU09DS0VUX1NUQVRFUykge1xuICAgIFNPQ0tFVF9TVEFURVNbU09DS0VUX1NUQVRFU1tcImNvbm5lY3RpbmdcIl0gPSAwXSA9IFwiY29ubmVjdGluZ1wiO1xuICAgIFNPQ0tFVF9TVEFURVNbU09DS0VUX1NUQVRFU1tcIm9wZW5cIl0gPSAxXSA9IFwib3BlblwiO1xuICAgIFNPQ0tFVF9TVEFURVNbU09DS0VUX1NUQVRFU1tcImNsb3NpbmdcIl0gPSAyXSA9IFwiY2xvc2luZ1wiO1xuICAgIFNPQ0tFVF9TVEFURVNbU09DS0VUX1NUQVRFU1tcImNsb3NlZFwiXSA9IDNdID0gXCJjbG9zZWRcIjtcbn0pKFNPQ0tFVF9TVEFURVMgfHwgKFNPQ0tFVF9TVEFURVMgPSB7fSkpO1xuZXhwb3J0IHZhciBDSEFOTkVMX1NUQVRFUztcbihmdW5jdGlvbiAoQ0hBTk5FTF9TVEFURVMpIHtcbiAgICBDSEFOTkVMX1NUQVRFU1tcImNsb3NlZFwiXSA9IFwiY2xvc2VkXCI7XG4gICAgQ0hBTk5FTF9TVEFURVNbXCJlcnJvcmVkXCJdID0gXCJlcnJvcmVkXCI7XG4gICAgQ0hBTk5FTF9TVEFURVNbXCJqb2luZWRcIl0gPSBcImpvaW5lZFwiO1xuICAgIENIQU5ORUxfU1RBVEVTW1wiam9pbmluZ1wiXSA9IFwiam9pbmluZ1wiO1xuICAgIENIQU5ORUxfU1RBVEVTW1wibGVhdmluZ1wiXSA9IFwibGVhdmluZ1wiO1xufSkoQ0hBTk5FTF9TVEFURVMgfHwgKENIQU5ORUxfU1RBVEVTID0ge30pKTtcbmV4cG9ydCB2YXIgQ0hBTk5FTF9FVkVOVFM7XG4oZnVuY3Rpb24gKENIQU5ORUxfRVZFTlRTKSB7XG4gICAgQ0hBTk5FTF9FVkVOVFNbXCJjbG9zZVwiXSA9IFwicGh4X2Nsb3NlXCI7XG4gICAgQ0hBTk5FTF9FVkVOVFNbXCJlcnJvclwiXSA9IFwicGh4X2Vycm9yXCI7XG4gICAgQ0hBTk5FTF9FVkVOVFNbXCJqb2luXCJdID0gXCJwaHhfam9pblwiO1xuICAgIENIQU5ORUxfRVZFTlRTW1wicmVwbHlcIl0gPSBcInBoeF9yZXBseVwiO1xuICAgIENIQU5ORUxfRVZFTlRTW1wibGVhdmVcIl0gPSBcInBoeF9sZWF2ZVwiO1xuICAgIENIQU5ORUxfRVZFTlRTW1wiYWNjZXNzX3Rva2VuXCJdID0gXCJhY2Nlc3NfdG9rZW5cIjtcbn0pKENIQU5ORUxfRVZFTlRTIHx8IChDSEFOTkVMX0VWRU5UUyA9IHt9KSk7XG5leHBvcnQgdmFyIFRSQU5TUE9SVFM7XG4oZnVuY3Rpb24gKFRSQU5TUE9SVFMpIHtcbiAgICBUUkFOU1BPUlRTW1wid2Vic29ja2V0XCJdID0gXCJ3ZWJzb2NrZXRcIjtcbn0pKFRSQU5TUE9SVFMgfHwgKFRSQU5TUE9SVFMgPSB7fSkpO1xuZXhwb3J0IHZhciBDT05ORUNUSU9OX1NUQVRFO1xuKGZ1bmN0aW9uIChDT05ORUNUSU9OX1NUQVRFKSB7XG4gICAgQ09OTkVDVElPTl9TVEFURVtcIkNvbm5lY3RpbmdcIl0gPSBcImNvbm5lY3RpbmdcIjtcbiAgICBDT05ORUNUSU9OX1NUQVRFW1wiT3BlblwiXSA9IFwib3BlblwiO1xuICAgIENPTk5FQ1RJT05fU1RBVEVbXCJDbG9zaW5nXCJdID0gXCJjbG9zaW5nXCI7XG4gICAgQ09OTkVDVElPTl9TVEFURVtcIkNsb3NlZFwiXSA9IFwiY2xvc2VkXCI7XG59KShDT05ORUNUSU9OX1NUQVRFIHx8IChDT05ORUNUSU9OX1NUQVRFID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0YW50cy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/constants.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/push.js":
/*!********************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/lib/push.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Push)\n/* harmony export */ });\n/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/constants */ \"(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/constants.js\");\n\nclass Push {\n    /**\n     * Initializes the Push\n     *\n     * @param channel The Channel\n     * @param event The event, for example `\"phx_join\"`\n     * @param payload The payload, for example `{user_id: 123}`\n     * @param timeout The push timeout in milliseconds\n     */\n    constructor(channel, event, payload = {}, timeout = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_TIMEOUT) {\n        this.channel = channel;\n        this.event = event;\n        this.payload = payload;\n        this.timeout = timeout;\n        this.sent = false;\n        this.timeoutTimer = undefined;\n        this.ref = '';\n        this.receivedResp = null;\n        this.recHooks = [];\n        this.refEvent = null;\n    }\n    resend(timeout) {\n        this.timeout = timeout;\n        this._cancelRefEvent();\n        this.ref = '';\n        this.refEvent = null;\n        this.receivedResp = null;\n        this.sent = false;\n        this.send();\n    }\n    send() {\n        if (this._hasReceived('timeout')) {\n            return;\n        }\n        this.startTimeout();\n        this.sent = true;\n        this.channel.socket.push({\n            topic: this.channel.topic,\n            event: this.event,\n            payload: this.payload,\n            ref: this.ref,\n            join_ref: this.channel._joinRef(),\n        });\n    }\n    updatePayload(payload) {\n        this.payload = Object.assign(Object.assign({}, this.payload), payload);\n    }\n    receive(status, callback) {\n        var _a;\n        if (this._hasReceived(status)) {\n            callback((_a = this.receivedResp) === null || _a === void 0 ? void 0 : _a.response);\n        }\n        this.recHooks.push({ status, callback });\n        return this;\n    }\n    startTimeout() {\n        if (this.timeoutTimer) {\n            return;\n        }\n        this.ref = this.channel.socket._makeRef();\n        this.refEvent = this.channel._replyEventName(this.ref);\n        const callback = (payload) => {\n            this._cancelRefEvent();\n            this._cancelTimeout();\n            this.receivedResp = payload;\n            this._matchReceive(payload);\n        };\n        this.channel._on(this.refEvent, {}, callback);\n        this.timeoutTimer = setTimeout(() => {\n            this.trigger('timeout', {});\n        }, this.timeout);\n    }\n    trigger(status, response) {\n        if (this.refEvent)\n            this.channel._trigger(this.refEvent, { status, response });\n    }\n    destroy() {\n        this._cancelRefEvent();\n        this._cancelTimeout();\n    }\n    _cancelRefEvent() {\n        if (!this.refEvent) {\n            return;\n        }\n        this.channel._off(this.refEvent, {});\n    }\n    _cancelTimeout() {\n        clearTimeout(this.timeoutTimer);\n        this.timeoutTimer = undefined;\n    }\n    _matchReceive({ status, response, }) {\n        this.recHooks\n            .filter((h) => h.status === status)\n            .forEach((h) => h.callback(response));\n    }\n    _hasReceived(status) {\n        return this.receivedResp && this.receivedResp.status === status;\n    }\n}\n//# sourceMappingURL=push.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvbGliL3B1c2guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBbUQ7QUFDcEM7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGFBQWE7QUFDOUQ7QUFDQTtBQUNBLDRDQUE0QyxZQUFZLDJEQUFlO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsa0JBQWtCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQSxzQ0FBc0M7QUFDdEMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxrQkFBa0I7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvV29uZGVyVml0ZS1mcm9udGVuZC9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL2xpYi9wdXNoLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERFRkFVTFRfVElNRU9VVCB9IGZyb20gJy4uL2xpYi9jb25zdGFudHMnO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHVzaCB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIFB1c2hcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGFubmVsIFRoZSBDaGFubmVsXG4gICAgICogQHBhcmFtIGV2ZW50IFRoZSBldmVudCwgZm9yIGV4YW1wbGUgYFwicGh4X2pvaW5cImBcbiAgICAgKiBAcGFyYW0gcGF5bG9hZCBUaGUgcGF5bG9hZCwgZm9yIGV4YW1wbGUgYHt1c2VyX2lkOiAxMjN9YFxuICAgICAqIEBwYXJhbSB0aW1lb3V0IFRoZSBwdXNoIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY2hhbm5lbCwgZXZlbnQsIHBheWxvYWQgPSB7fSwgdGltZW91dCA9IERFRkFVTFRfVElNRU9VVCkge1xuICAgICAgICB0aGlzLmNoYW5uZWwgPSBjaGFubmVsO1xuICAgICAgICB0aGlzLmV2ZW50ID0gZXZlbnQ7XG4gICAgICAgIHRoaXMucGF5bG9hZCA9IHBheWxvYWQ7XG4gICAgICAgIHRoaXMudGltZW91dCA9IHRpbWVvdXQ7XG4gICAgICAgIHRoaXMuc2VudCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRpbWVvdXRUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5yZWYgPSAnJztcbiAgICAgICAgdGhpcy5yZWNlaXZlZFJlc3AgPSBudWxsO1xuICAgICAgICB0aGlzLnJlY0hvb2tzID0gW107XG4gICAgICAgIHRoaXMucmVmRXZlbnQgPSBudWxsO1xuICAgIH1cbiAgICByZXNlbmQodGltZW91dCkge1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSB0aW1lb3V0O1xuICAgICAgICB0aGlzLl9jYW5jZWxSZWZFdmVudCgpO1xuICAgICAgICB0aGlzLnJlZiA9ICcnO1xuICAgICAgICB0aGlzLnJlZkV2ZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZWNlaXZlZFJlc3AgPSBudWxsO1xuICAgICAgICB0aGlzLnNlbnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zZW5kKCk7XG4gICAgfVxuICAgIHNlbmQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9oYXNSZWNlaXZlZCgndGltZW91dCcpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGFydFRpbWVvdXQoKTtcbiAgICAgICAgdGhpcy5zZW50ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jaGFubmVsLnNvY2tldC5wdXNoKHtcbiAgICAgICAgICAgIHRvcGljOiB0aGlzLmNoYW5uZWwudG9waWMsXG4gICAgICAgICAgICBldmVudDogdGhpcy5ldmVudCxcbiAgICAgICAgICAgIHBheWxvYWQ6IHRoaXMucGF5bG9hZCxcbiAgICAgICAgICAgIHJlZjogdGhpcy5yZWYsXG4gICAgICAgICAgICBqb2luX3JlZjogdGhpcy5jaGFubmVsLl9qb2luUmVmKCksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1cGRhdGVQYXlsb2FkKHBheWxvYWQpIHtcbiAgICAgICAgdGhpcy5wYXlsb2FkID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnBheWxvYWQpLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgcmVjZWl2ZShzdGF0dXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHRoaXMuX2hhc1JlY2VpdmVkKHN0YXR1cykpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKChfYSA9IHRoaXMucmVjZWl2ZWRSZXNwKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVjSG9va3MucHVzaCh7IHN0YXR1cywgY2FsbGJhY2sgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzdGFydFRpbWVvdXQoKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVvdXRUaW1lcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVmID0gdGhpcy5jaGFubmVsLnNvY2tldC5fbWFrZVJlZigpO1xuICAgICAgICB0aGlzLnJlZkV2ZW50ID0gdGhpcy5jaGFubmVsLl9yZXBseUV2ZW50TmFtZSh0aGlzLnJlZik7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2NhbmNlbFJlZkV2ZW50KCk7XG4gICAgICAgICAgICB0aGlzLl9jYW5jZWxUaW1lb3V0KCk7XG4gICAgICAgICAgICB0aGlzLnJlY2VpdmVkUmVzcCA9IHBheWxvYWQ7XG4gICAgICAgICAgICB0aGlzLl9tYXRjaFJlY2VpdmUocGF5bG9hZCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2hhbm5lbC5fb24odGhpcy5yZWZFdmVudCwge30sIGNhbGxiYWNrKTtcbiAgICAgICAgdGhpcy50aW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcigndGltZW91dCcsIHt9KTtcbiAgICAgICAgfSwgdGhpcy50aW1lb3V0KTtcbiAgICB9XG4gICAgdHJpZ2dlcihzdGF0dXMsIHJlc3BvbnNlKSB7XG4gICAgICAgIGlmICh0aGlzLnJlZkV2ZW50KVxuICAgICAgICAgICAgdGhpcy5jaGFubmVsLl90cmlnZ2VyKHRoaXMucmVmRXZlbnQsIHsgc3RhdHVzLCByZXNwb25zZSB9KTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fY2FuY2VsUmVmRXZlbnQoKTtcbiAgICAgICAgdGhpcy5fY2FuY2VsVGltZW91dCgpO1xuICAgIH1cbiAgICBfY2FuY2VsUmVmRXZlbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5yZWZFdmVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hhbm5lbC5fb2ZmKHRoaXMucmVmRXZlbnQsIHt9KTtcbiAgICB9XG4gICAgX2NhbmNlbFRpbWVvdXQoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRUaW1lcik7XG4gICAgICAgIHRoaXMudGltZW91dFRpbWVyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBfbWF0Y2hSZWNlaXZlKHsgc3RhdHVzLCByZXNwb25zZSwgfSkge1xuICAgICAgICB0aGlzLnJlY0hvb2tzXG4gICAgICAgICAgICAuZmlsdGVyKChoKSA9PiBoLnN0YXR1cyA9PT0gc3RhdHVzKVxuICAgICAgICAgICAgLmZvckVhY2goKGgpID0+IGguY2FsbGJhY2socmVzcG9uc2UpKTtcbiAgICB9XG4gICAgX2hhc1JlY2VpdmVkKHN0YXR1cykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWNlaXZlZFJlc3AgJiYgdGhpcy5yZWNlaXZlZFJlc3Auc3RhdHVzID09PSBzdGF0dXM7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHVzaC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/push.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/serializer.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/lib/serializer.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Serializer)\n/* harmony export */ });\n// This file draws heavily from https://github.com/phoenixframework/phoenix/commit/cf098e9cf7a44ee6479d31d911a97d3c7430c6fe\n// License: https://github.com/phoenixframework/phoenix/blob/master/LICENSE.md\nclass Serializer {\n    constructor() {\n        this.HEADER_LENGTH = 1;\n    }\n    decode(rawPayload, callback) {\n        if (rawPayload.constructor === ArrayBuffer) {\n            return callback(this._binaryDecode(rawPayload));\n        }\n        if (typeof rawPayload === 'string') {\n            return callback(JSON.parse(rawPayload));\n        }\n        return callback({});\n    }\n    _binaryDecode(buffer) {\n        const view = new DataView(buffer);\n        const decoder = new TextDecoder();\n        return this._decodeBroadcast(buffer, view, decoder);\n    }\n    _decodeBroadcast(buffer, view, decoder) {\n        const topicSize = view.getUint8(1);\n        const eventSize = view.getUint8(2);\n        let offset = this.HEADER_LENGTH + 2;\n        const topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n        offset = offset + topicSize;\n        const event = decoder.decode(buffer.slice(offset, offset + eventSize));\n        offset = offset + eventSize;\n        const data = JSON.parse(decoder.decode(buffer.slice(offset, buffer.byteLength)));\n        return { ref: null, topic: topic, event: event, payload: data };\n    }\n}\n//# sourceMappingURL=serializer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvbGliL3NlcmlhbGl6ZXIuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL1dvbmRlclZpdGUtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9yZWFsdGltZS1qcy9kaXN0L21vZHVsZS9saWIvc2VyaWFsaXplci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUaGlzIGZpbGUgZHJhd3MgaGVhdmlseSBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9waG9lbml4ZnJhbWV3b3JrL3Bob2VuaXgvY29tbWl0L2NmMDk4ZTljZjdhNDRlZTY0NzlkMzFkOTExYTk3ZDNjNzQzMGM2ZmVcbi8vIExpY2Vuc2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9waG9lbml4ZnJhbWV3b3JrL3Bob2VuaXgvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZFxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VyaWFsaXplciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuSEVBREVSX0xFTkdUSCA9IDE7XG4gICAgfVxuICAgIGRlY29kZShyYXdQYXlsb2FkLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAocmF3UGF5bG9hZC5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayh0aGlzLl9iaW5hcnlEZWNvZGUocmF3UGF5bG9hZCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcmF3UGF5bG9hZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhKU09OLnBhcnNlKHJhd1BheWxvYWQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsbGJhY2soe30pO1xuICAgIH1cbiAgICBfYmluYXJ5RGVjb2RlKGJ1ZmZlcikge1xuICAgICAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlY29kZUJyb2FkY2FzdChidWZmZXIsIHZpZXcsIGRlY29kZXIpO1xuICAgIH1cbiAgICBfZGVjb2RlQnJvYWRjYXN0KGJ1ZmZlciwgdmlldywgZGVjb2Rlcikge1xuICAgICAgICBjb25zdCB0b3BpY1NpemUgPSB2aWV3LmdldFVpbnQ4KDEpO1xuICAgICAgICBjb25zdCBldmVudFNpemUgPSB2aWV3LmdldFVpbnQ4KDIpO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5IRUFERVJfTEVOR1RIICsgMjtcbiAgICAgICAgY29uc3QgdG9waWMgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyB0b3BpY1NpemUpKTtcbiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ICsgdG9waWNTaXplO1xuICAgICAgICBjb25zdCBldmVudCA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGV2ZW50U2l6ZSkpO1xuICAgICAgICBvZmZzZXQgPSBvZmZzZXQgKyBldmVudFNpemU7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIGJ1ZmZlci5ieXRlTGVuZ3RoKSkpO1xuICAgICAgICByZXR1cm4geyByZWY6IG51bGwsIHRvcGljOiB0b3BpYywgZXZlbnQ6IGV2ZW50LCBwYXlsb2FkOiBkYXRhIH07XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VyaWFsaXplci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/serializer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/timer.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/lib/timer.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Timer)\n/* harmony export */ });\n/**\n * Creates a timer that accepts a `timerCalc` function to perform calculated timeout retries, such as exponential backoff.\n *\n * @example\n *    let reconnectTimer = new Timer(() => this.connect(), function(tries){\n *      return [1000, 5000, 10000][tries - 1] || 10000\n *    })\n *    reconnectTimer.scheduleTimeout() // fires after 1000\n *    reconnectTimer.scheduleTimeout() // fires after 5000\n *    reconnectTimer.reset()\n *    reconnectTimer.scheduleTimeout() // fires after 1000\n */\nclass Timer {\n    constructor(callback, timerCalc) {\n        this.callback = callback;\n        this.timerCalc = timerCalc;\n        this.timer = undefined;\n        this.tries = 0;\n        this.callback = callback;\n        this.timerCalc = timerCalc;\n    }\n    reset() {\n        this.tries = 0;\n        clearTimeout(this.timer);\n    }\n    // Cancels any previous scheduleTimeout and schedules callback\n    scheduleTimeout() {\n        clearTimeout(this.timer);\n        this.timer = setTimeout(() => {\n            this.tries = this.tries + 1;\n            this.callback();\n        }, this.timerCalc(this.tries + 1));\n    }\n}\n//# sourceMappingURL=timer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvbGliL3RpbWVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvV29uZGVyVml0ZS1mcm9udGVuZC9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL2xpYi90aW1lci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENyZWF0ZXMgYSB0aW1lciB0aGF0IGFjY2VwdHMgYSBgdGltZXJDYWxjYCBmdW5jdGlvbiB0byBwZXJmb3JtIGNhbGN1bGF0ZWQgdGltZW91dCByZXRyaWVzLCBzdWNoIGFzIGV4cG9uZW50aWFsIGJhY2tvZmYuXG4gKlxuICogQGV4YW1wbGVcbiAqICAgIGxldCByZWNvbm5lY3RUaW1lciA9IG5ldyBUaW1lcigoKSA9PiB0aGlzLmNvbm5lY3QoKSwgZnVuY3Rpb24odHJpZXMpe1xuICogICAgICByZXR1cm4gWzEwMDAsIDUwMDAsIDEwMDAwXVt0cmllcyAtIDFdIHx8IDEwMDAwXG4gKiAgICB9KVxuICogICAgcmVjb25uZWN0VGltZXIuc2NoZWR1bGVUaW1lb3V0KCkgLy8gZmlyZXMgYWZ0ZXIgMTAwMFxuICogICAgcmVjb25uZWN0VGltZXIuc2NoZWR1bGVUaW1lb3V0KCkgLy8gZmlyZXMgYWZ0ZXIgNTAwMFxuICogICAgcmVjb25uZWN0VGltZXIucmVzZXQoKVxuICogICAgcmVjb25uZWN0VGltZXIuc2NoZWR1bGVUaW1lb3V0KCkgLy8gZmlyZXMgYWZ0ZXIgMTAwMFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaW1lciB7XG4gICAgY29uc3RydWN0b3IoY2FsbGJhY2ssIHRpbWVyQ2FsYykge1xuICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIHRoaXMudGltZXJDYWxjID0gdGltZXJDYWxjO1xuICAgICAgICB0aGlzLnRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnRyaWVzID0gMDtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICB0aGlzLnRpbWVyQ2FsYyA9IHRpbWVyQ2FsYztcbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMudHJpZXMgPSAwO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG4gICAgfVxuICAgIC8vIENhbmNlbHMgYW55IHByZXZpb3VzIHNjaGVkdWxlVGltZW91dCBhbmQgc2NoZWR1bGVzIGNhbGxiYWNrXG4gICAgc2NoZWR1bGVUaW1lb3V0KCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG4gICAgICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudHJpZXMgPSB0aGlzLnRyaWVzICsgMTtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2soKTtcbiAgICAgICAgfSwgdGhpcy50aW1lckNhbGModGhpcy50cmllcyArIDEpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aW1lci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/timer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/transformers.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/lib/transformers.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PostgresTypes: () => (/* binding */ PostgresTypes),\n/* harmony export */   convertCell: () => (/* binding */ convertCell),\n/* harmony export */   convertChangeData: () => (/* binding */ convertChangeData),\n/* harmony export */   convertColumn: () => (/* binding */ convertColumn),\n/* harmony export */   httpEndpointURL: () => (/* binding */ httpEndpointURL),\n/* harmony export */   toArray: () => (/* binding */ toArray),\n/* harmony export */   toBoolean: () => (/* binding */ toBoolean),\n/* harmony export */   toJson: () => (/* binding */ toJson),\n/* harmony export */   toNumber: () => (/* binding */ toNumber),\n/* harmony export */   toTimestampString: () => (/* binding */ toTimestampString)\n/* harmony export */ });\n/**\n * Helpers to convert the change Payload into native JS types.\n */\n// Adapted from epgsql (src/epgsql_binary.erl), this module licensed under\n// 3-clause BSD found here: https://raw.githubusercontent.com/epgsql/epgsql/devel/LICENSE\nvar PostgresTypes;\n(function (PostgresTypes) {\n    PostgresTypes[\"abstime\"] = \"abstime\";\n    PostgresTypes[\"bool\"] = \"bool\";\n    PostgresTypes[\"date\"] = \"date\";\n    PostgresTypes[\"daterange\"] = \"daterange\";\n    PostgresTypes[\"float4\"] = \"float4\";\n    PostgresTypes[\"float8\"] = \"float8\";\n    PostgresTypes[\"int2\"] = \"int2\";\n    PostgresTypes[\"int4\"] = \"int4\";\n    PostgresTypes[\"int4range\"] = \"int4range\";\n    PostgresTypes[\"int8\"] = \"int8\";\n    PostgresTypes[\"int8range\"] = \"int8range\";\n    PostgresTypes[\"json\"] = \"json\";\n    PostgresTypes[\"jsonb\"] = \"jsonb\";\n    PostgresTypes[\"money\"] = \"money\";\n    PostgresTypes[\"numeric\"] = \"numeric\";\n    PostgresTypes[\"oid\"] = \"oid\";\n    PostgresTypes[\"reltime\"] = \"reltime\";\n    PostgresTypes[\"text\"] = \"text\";\n    PostgresTypes[\"time\"] = \"time\";\n    PostgresTypes[\"timestamp\"] = \"timestamp\";\n    PostgresTypes[\"timestamptz\"] = \"timestamptz\";\n    PostgresTypes[\"timetz\"] = \"timetz\";\n    PostgresTypes[\"tsrange\"] = \"tsrange\";\n    PostgresTypes[\"tstzrange\"] = \"tstzrange\";\n})(PostgresTypes || (PostgresTypes = {}));\n/**\n * Takes an array of columns and an object of string values then converts each string value\n * to its mapped type.\n *\n * @param {{name: String, type: String}[]} columns\n * @param {Object} record\n * @param {Object} options The map of various options that can be applied to the mapper\n * @param {Array} options.skipTypes The array of types that should not be converted\n *\n * @example convertChangeData([{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age:'33'}, {})\n * //=>{ first_name: 'Paul', age: 33 }\n */\nconst convertChangeData = (columns, record, options = {}) => {\n    var _a;\n    const skipTypes = (_a = options.skipTypes) !== null && _a !== void 0 ? _a : [];\n    return Object.keys(record).reduce((acc, rec_key) => {\n        acc[rec_key] = convertColumn(rec_key, columns, record, skipTypes);\n        return acc;\n    }, {});\n};\n/**\n * Converts the value of an individual column.\n *\n * @param {String} columnName The column that you want to convert\n * @param {{name: String, type: String}[]} columns All of the columns\n * @param {Object} record The map of string values\n * @param {Array} skipTypes An array of types that should not be converted\n * @return {object} Useless information\n *\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, [])\n * //=> 33\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, ['int4'])\n * //=> \"33\"\n */\nconst convertColumn = (columnName, columns, record, skipTypes) => {\n    const column = columns.find((x) => x.name === columnName);\n    const colType = column === null || column === void 0 ? void 0 : column.type;\n    const value = record[columnName];\n    if (colType && !skipTypes.includes(colType)) {\n        return convertCell(colType, value);\n    }\n    return noop(value);\n};\n/**\n * If the value of the cell is `null`, returns null.\n * Otherwise converts the string value to the correct type.\n * @param {String} type A postgres column type\n * @param {String} value The cell value\n *\n * @example convertCell('bool', 't')\n * //=> true\n * @example convertCell('int8', '10')\n * //=> 10\n * @example convertCell('_int4', '{1,2,3,4}')\n * //=> [1,2,3,4]\n */\nconst convertCell = (type, value) => {\n    // if data type is an array\n    if (type.charAt(0) === '_') {\n        const dataType = type.slice(1, type.length);\n        return toArray(value, dataType);\n    }\n    // If not null, convert to correct type.\n    switch (type) {\n        case PostgresTypes.bool:\n            return toBoolean(value);\n        case PostgresTypes.float4:\n        case PostgresTypes.float8:\n        case PostgresTypes.int2:\n        case PostgresTypes.int4:\n        case PostgresTypes.int8:\n        case PostgresTypes.numeric:\n        case PostgresTypes.oid:\n            return toNumber(value);\n        case PostgresTypes.json:\n        case PostgresTypes.jsonb:\n            return toJson(value);\n        case PostgresTypes.timestamp:\n            return toTimestampString(value); // Format to be consistent with PostgREST\n        case PostgresTypes.abstime: // To allow users to cast it based on Timezone\n        case PostgresTypes.date: // To allow users to cast it based on Timezone\n        case PostgresTypes.daterange:\n        case PostgresTypes.int4range:\n        case PostgresTypes.int8range:\n        case PostgresTypes.money:\n        case PostgresTypes.reltime: // To allow users to cast it based on Timezone\n        case PostgresTypes.text:\n        case PostgresTypes.time: // To allow users to cast it based on Timezone\n        case PostgresTypes.timestamptz: // To allow users to cast it based on Timezone\n        case PostgresTypes.timetz: // To allow users to cast it based on Timezone\n        case PostgresTypes.tsrange:\n        case PostgresTypes.tstzrange:\n            return noop(value);\n        default:\n            // Return the value for remaining types\n            return noop(value);\n    }\n};\nconst noop = (value) => {\n    return value;\n};\nconst toBoolean = (value) => {\n    switch (value) {\n        case 't':\n            return true;\n        case 'f':\n            return false;\n        default:\n            return value;\n    }\n};\nconst toNumber = (value) => {\n    if (typeof value === 'string') {\n        const parsedValue = parseFloat(value);\n        if (!Number.isNaN(parsedValue)) {\n            return parsedValue;\n        }\n    }\n    return value;\n};\nconst toJson = (value) => {\n    if (typeof value === 'string') {\n        try {\n            return JSON.parse(value);\n        }\n        catch (error) {\n            console.log(`JSON parse error: ${error}`);\n            return value;\n        }\n    }\n    return value;\n};\n/**\n * Converts a Postgres Array into a native JS array\n *\n * @example toArray('{}', 'int4')\n * //=> []\n * @example toArray('{\"[2021-01-01,2021-12-31)\",\"(2021-01-01,2021-12-32]\"}', 'daterange')\n * //=> ['[2021-01-01,2021-12-31)', '(2021-01-01,2021-12-32]']\n * @example toArray([1,2,3,4], 'int4')\n * //=> [1,2,3,4]\n */\nconst toArray = (value, type) => {\n    if (typeof value !== 'string') {\n        return value;\n    }\n    const lastIdx = value.length - 1;\n    const closeBrace = value[lastIdx];\n    const openBrace = value[0];\n    // Confirm value is a Postgres array by checking curly brackets\n    if (openBrace === '{' && closeBrace === '}') {\n        let arr;\n        const valTrim = value.slice(1, lastIdx);\n        // TODO: find a better solution to separate Postgres array data\n        try {\n            arr = JSON.parse('[' + valTrim + ']');\n        }\n        catch (_) {\n            // WARNING: splitting on comma does not cover all edge cases\n            arr = valTrim ? valTrim.split(',') : [];\n        }\n        return arr.map((val) => convertCell(type, val));\n    }\n    return value;\n};\n/**\n * Fixes timestamp to be ISO-8601. Swaps the space between the date and time for a 'T'\n * See https://github.com/supabase/supabase/issues/18\n *\n * @example toTimestampString('2019-09-10 00:00:00')\n * //=> '2019-09-10T00:00:00'\n */\nconst toTimestampString = (value) => {\n    if (typeof value === 'string') {\n        return value.replace(' ', 'T');\n    }\n    return value;\n};\nconst httpEndpointURL = (socketUrl) => {\n    let url = socketUrl;\n    url = url.replace(/^ws/i, 'http');\n    url = url.replace(/(\\/socket\\/websocket|\\/socket|\\/websocket)\\/?$/i, '');\n    return url.replace(/\\/+$/, '');\n};\n//# sourceMappingURL=transformers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvbGliL3RyYW5zZm9ybWVycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNDQUFzQztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMkJBQTJCLElBQUk7QUFDM0MsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLE9BQU87QUFDbEI7QUFDQSxnQ0FBZ0MsaUNBQWlDLEdBQUcsMEJBQTBCLElBQUksNkJBQTZCLElBQUk7QUFDbkksU0FBUztBQUNUO0FBQ08sd0RBQXdEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLDJCQUEyQixJQUFJO0FBQzNDLFdBQVcsUUFBUTtBQUNuQixXQUFXLE9BQU87QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0EsbUNBQW1DLGlDQUFpQyxHQUFHLDBCQUEwQixJQUFJLDhCQUE4QjtBQUNuSTtBQUNBLG1DQUFtQyxpQ0FBaUMsR0FBRywwQkFBMEIsSUFBSSw4QkFBOEI7QUFDbkk7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE1BQU07QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLHNCQUFzQixvREFBb0Q7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvV29uZGVyVml0ZS1mcm9udGVuZC9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL2xpYi90cmFuc2Zvcm1lcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBIZWxwZXJzIHRvIGNvbnZlcnQgdGhlIGNoYW5nZSBQYXlsb2FkIGludG8gbmF0aXZlIEpTIHR5cGVzLlxuICovXG4vLyBBZGFwdGVkIGZyb20gZXBnc3FsIChzcmMvZXBnc3FsX2JpbmFyeS5lcmwpLCB0aGlzIG1vZHVsZSBsaWNlbnNlZCB1bmRlclxuLy8gMy1jbGF1c2UgQlNEIGZvdW5kIGhlcmU6IGh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9lcGdzcWwvZXBnc3FsL2RldmVsL0xJQ0VOU0VcbmV4cG9ydCB2YXIgUG9zdGdyZXNUeXBlcztcbihmdW5jdGlvbiAoUG9zdGdyZXNUeXBlcykge1xuICAgIFBvc3RncmVzVHlwZXNbXCJhYnN0aW1lXCJdID0gXCJhYnN0aW1lXCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcImJvb2xcIl0gPSBcImJvb2xcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1wiZGF0ZVwiXSA9IFwiZGF0ZVwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJkYXRlcmFuZ2VcIl0gPSBcImRhdGVyYW5nZVwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJmbG9hdDRcIl0gPSBcImZsb2F0NFwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJmbG9hdDhcIl0gPSBcImZsb2F0OFwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJpbnQyXCJdID0gXCJpbnQyXCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcImludDRcIl0gPSBcImludDRcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1wiaW50NHJhbmdlXCJdID0gXCJpbnQ0cmFuZ2VcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1wiaW50OFwiXSA9IFwiaW50OFwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJpbnQ4cmFuZ2VcIl0gPSBcImludDhyYW5nZVwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJqc29uXCJdID0gXCJqc29uXCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcImpzb25iXCJdID0gXCJqc29uYlwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJtb25leVwiXSA9IFwibW9uZXlcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1wibnVtZXJpY1wiXSA9IFwibnVtZXJpY1wiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJvaWRcIl0gPSBcIm9pZFwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJyZWx0aW1lXCJdID0gXCJyZWx0aW1lXCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcInRleHRcIl0gPSBcInRleHRcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1widGltZVwiXSA9IFwidGltZVwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJ0aW1lc3RhbXBcIl0gPSBcInRpbWVzdGFtcFwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJ0aW1lc3RhbXB0elwiXSA9IFwidGltZXN0YW1wdHpcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1widGltZXR6XCJdID0gXCJ0aW1ldHpcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1widHNyYW5nZVwiXSA9IFwidHNyYW5nZVwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJ0c3R6cmFuZ2VcIl0gPSBcInRzdHpyYW5nZVwiO1xufSkoUG9zdGdyZXNUeXBlcyB8fCAoUG9zdGdyZXNUeXBlcyA9IHt9KSk7XG4vKipcbiAqIFRha2VzIGFuIGFycmF5IG9mIGNvbHVtbnMgYW5kIGFuIG9iamVjdCBvZiBzdHJpbmcgdmFsdWVzIHRoZW4gY29udmVydHMgZWFjaCBzdHJpbmcgdmFsdWVcbiAqIHRvIGl0cyBtYXBwZWQgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge3tuYW1lOiBTdHJpbmcsIHR5cGU6IFN0cmluZ31bXX0gY29sdW1uc1xuICogQHBhcmFtIHtPYmplY3R9IHJlY29yZFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG1hcCBvZiB2YXJpb3VzIG9wdGlvbnMgdGhhdCBjYW4gYmUgYXBwbGllZCB0byB0aGUgbWFwcGVyXG4gKiBAcGFyYW0ge0FycmF5fSBvcHRpb25zLnNraXBUeXBlcyBUaGUgYXJyYXkgb2YgdHlwZXMgdGhhdCBzaG91bGQgbm90IGJlIGNvbnZlcnRlZFxuICpcbiAqIEBleGFtcGxlIGNvbnZlcnRDaGFuZ2VEYXRhKFt7bmFtZTogJ2ZpcnN0X25hbWUnLCB0eXBlOiAndGV4dCd9LCB7bmFtZTogJ2FnZScsIHR5cGU6ICdpbnQ0J31dLCB7Zmlyc3RfbmFtZTogJ1BhdWwnLCBhZ2U6JzMzJ30sIHt9KVxuICogLy89PnsgZmlyc3RfbmFtZTogJ1BhdWwnLCBhZ2U6IDMzIH1cbiAqL1xuZXhwb3J0IGNvbnN0IGNvbnZlcnRDaGFuZ2VEYXRhID0gKGNvbHVtbnMsIHJlY29yZCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHNraXBUeXBlcyA9IChfYSA9IG9wdGlvbnMuc2tpcFR5cGVzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMocmVjb3JkKS5yZWR1Y2UoKGFjYywgcmVjX2tleSkgPT4ge1xuICAgICAgICBhY2NbcmVjX2tleV0gPSBjb252ZXJ0Q29sdW1uKHJlY19rZXksIGNvbHVtbnMsIHJlY29yZCwgc2tpcFR5cGVzKTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyB0aGUgdmFsdWUgb2YgYW4gaW5kaXZpZHVhbCBjb2x1bW4uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGNvbHVtbk5hbWUgVGhlIGNvbHVtbiB0aGF0IHlvdSB3YW50IHRvIGNvbnZlcnRcbiAqIEBwYXJhbSB7e25hbWU6IFN0cmluZywgdHlwZTogU3RyaW5nfVtdfSBjb2x1bW5zIEFsbCBvZiB0aGUgY29sdW1uc1xuICogQHBhcmFtIHtPYmplY3R9IHJlY29yZCBUaGUgbWFwIG9mIHN0cmluZyB2YWx1ZXNcbiAqIEBwYXJhbSB7QXJyYXl9IHNraXBUeXBlcyBBbiBhcnJheSBvZiB0eXBlcyB0aGF0IHNob3VsZCBub3QgYmUgY29udmVydGVkXG4gKiBAcmV0dXJuIHtvYmplY3R9IFVzZWxlc3MgaW5mb3JtYXRpb25cbiAqXG4gKiBAZXhhbXBsZSBjb252ZXJ0Q29sdW1uKCdhZ2UnLCBbe25hbWU6ICdmaXJzdF9uYW1lJywgdHlwZTogJ3RleHQnfSwge25hbWU6ICdhZ2UnLCB0eXBlOiAnaW50NCd9XSwge2ZpcnN0X25hbWU6ICdQYXVsJywgYWdlOiAnMzMnfSwgW10pXG4gKiAvLz0+IDMzXG4gKiBAZXhhbXBsZSBjb252ZXJ0Q29sdW1uKCdhZ2UnLCBbe25hbWU6ICdmaXJzdF9uYW1lJywgdHlwZTogJ3RleHQnfSwge25hbWU6ICdhZ2UnLCB0eXBlOiAnaW50NCd9XSwge2ZpcnN0X25hbWU6ICdQYXVsJywgYWdlOiAnMzMnfSwgWydpbnQ0J10pXG4gKiAvLz0+IFwiMzNcIlxuICovXG5leHBvcnQgY29uc3QgY29udmVydENvbHVtbiA9IChjb2x1bW5OYW1lLCBjb2x1bW5zLCByZWNvcmQsIHNraXBUeXBlcykgPT4ge1xuICAgIGNvbnN0IGNvbHVtbiA9IGNvbHVtbnMuZmluZCgoeCkgPT4geC5uYW1lID09PSBjb2x1bW5OYW1lKTtcbiAgICBjb25zdCBjb2xUeXBlID0gY29sdW1uID09PSBudWxsIHx8IGNvbHVtbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29sdW1uLnR5cGU7XG4gICAgY29uc3QgdmFsdWUgPSByZWNvcmRbY29sdW1uTmFtZV07XG4gICAgaWYgKGNvbFR5cGUgJiYgIXNraXBUeXBlcy5pbmNsdWRlcyhjb2xUeXBlKSkge1xuICAgICAgICByZXR1cm4gY29udmVydENlbGwoY29sVHlwZSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gbm9vcCh2YWx1ZSk7XG59O1xuLyoqXG4gKiBJZiB0aGUgdmFsdWUgb2YgdGhlIGNlbGwgaXMgYG51bGxgLCByZXR1cm5zIG51bGwuXG4gKiBPdGhlcndpc2UgY29udmVydHMgdGhlIHN0cmluZyB2YWx1ZSB0byB0aGUgY29ycmVjdCB0eXBlLlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgQSBwb3N0Z3JlcyBjb2x1bW4gdHlwZVxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIFRoZSBjZWxsIHZhbHVlXG4gKlxuICogQGV4YW1wbGUgY29udmVydENlbGwoJ2Jvb2wnLCAndCcpXG4gKiAvLz0+IHRydWVcbiAqIEBleGFtcGxlIGNvbnZlcnRDZWxsKCdpbnQ4JywgJzEwJylcbiAqIC8vPT4gMTBcbiAqIEBleGFtcGxlIGNvbnZlcnRDZWxsKCdfaW50NCcsICd7MSwyLDMsNH0nKVxuICogLy89PiBbMSwyLDMsNF1cbiAqL1xuZXhwb3J0IGNvbnN0IGNvbnZlcnRDZWxsID0gKHR5cGUsIHZhbHVlKSA9PiB7XG4gICAgLy8gaWYgZGF0YSB0eXBlIGlzIGFuIGFycmF5XG4gICAgaWYgKHR5cGUuY2hhckF0KDApID09PSAnXycpIHtcbiAgICAgICAgY29uc3QgZGF0YVR5cGUgPSB0eXBlLnNsaWNlKDEsIHR5cGUubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHRvQXJyYXkodmFsdWUsIGRhdGFUeXBlKTtcbiAgICB9XG4gICAgLy8gSWYgbm90IG51bGwsIGNvbnZlcnQgdG8gY29ycmVjdCB0eXBlLlxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMuYm9vbDpcbiAgICAgICAgICAgIHJldHVybiB0b0Jvb2xlYW4odmFsdWUpO1xuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMuZmxvYXQ0OlxuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMuZmxvYXQ4OlxuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMuaW50MjpcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmludDQ6XG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5pbnQ4OlxuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMubnVtZXJpYzpcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLm9pZDpcbiAgICAgICAgICAgIHJldHVybiB0b051bWJlcih2YWx1ZSk7XG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5qc29uOlxuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMuanNvbmI6XG4gICAgICAgICAgICByZXR1cm4gdG9Kc29uKHZhbHVlKTtcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLnRpbWVzdGFtcDpcbiAgICAgICAgICAgIHJldHVybiB0b1RpbWVzdGFtcFN0cmluZyh2YWx1ZSk7IC8vIEZvcm1hdCB0byBiZSBjb25zaXN0ZW50IHdpdGggUG9zdGdSRVNUXG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5hYnN0aW1lOiAvLyBUbyBhbGxvdyB1c2VycyB0byBjYXN0IGl0IGJhc2VkIG9uIFRpbWV6b25lXG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5kYXRlOiAvLyBUbyBhbGxvdyB1c2VycyB0byBjYXN0IGl0IGJhc2VkIG9uIFRpbWV6b25lXG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5kYXRlcmFuZ2U6XG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5pbnQ0cmFuZ2U6XG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5pbnQ4cmFuZ2U6XG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5tb25leTpcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLnJlbHRpbWU6IC8vIFRvIGFsbG93IHVzZXJzIHRvIGNhc3QgaXQgYmFzZWQgb24gVGltZXpvbmVcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLnRleHQ6XG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy50aW1lOiAvLyBUbyBhbGxvdyB1c2VycyB0byBjYXN0IGl0IGJhc2VkIG9uIFRpbWV6b25lXG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy50aW1lc3RhbXB0ejogLy8gVG8gYWxsb3cgdXNlcnMgdG8gY2FzdCBpdCBiYXNlZCBvbiBUaW1lem9uZVxuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMudGltZXR6OiAvLyBUbyBhbGxvdyB1c2VycyB0byBjYXN0IGl0IGJhc2VkIG9uIFRpbWV6b25lXG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy50c3JhbmdlOlxuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMudHN0enJhbmdlOlxuICAgICAgICAgICAgcmV0dXJuIG5vb3AodmFsdWUpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSB2YWx1ZSBmb3IgcmVtYWluaW5nIHR5cGVzXG4gICAgICAgICAgICByZXR1cm4gbm9vcCh2YWx1ZSk7XG4gICAgfVxufTtcbmNvbnN0IG5vb3AgPSAodmFsdWUpID0+IHtcbiAgICByZXR1cm4gdmFsdWU7XG59O1xuZXhwb3J0IGNvbnN0IHRvQm9vbGVhbiA9ICh2YWx1ZSkgPT4ge1xuICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCB0b051bWJlciA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgIGlmICghTnVtYmVyLmlzTmFOKHBhcnNlZFZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlZFZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn07XG5leHBvcnQgY29uc3QgdG9Kc29uID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBKU09OIHBhcnNlIGVycm9yOiAke2Vycm9yfWApO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn07XG4vKipcbiAqIENvbnZlcnRzIGEgUG9zdGdyZXMgQXJyYXkgaW50byBhIG5hdGl2ZSBKUyBhcnJheVxuICpcbiAqIEBleGFtcGxlIHRvQXJyYXkoJ3t9JywgJ2ludDQnKVxuICogLy89PiBbXVxuICogQGV4YW1wbGUgdG9BcnJheSgne1wiWzIwMjEtMDEtMDEsMjAyMS0xMi0zMSlcIixcIigyMDIxLTAxLTAxLDIwMjEtMTItMzJdXCJ9JywgJ2RhdGVyYW5nZScpXG4gKiAvLz0+IFsnWzIwMjEtMDEtMDEsMjAyMS0xMi0zMSknLCAnKDIwMjEtMDEtMDEsMjAyMS0xMi0zMl0nXVxuICogQGV4YW1wbGUgdG9BcnJheShbMSwyLDMsNF0sICdpbnQ0JylcbiAqIC8vPT4gWzEsMiwzLDRdXG4gKi9cbmV4cG9ydCBjb25zdCB0b0FycmF5ID0gKHZhbHVlLCB0eXBlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBsYXN0SWR4ID0gdmFsdWUubGVuZ3RoIC0gMTtcbiAgICBjb25zdCBjbG9zZUJyYWNlID0gdmFsdWVbbGFzdElkeF07XG4gICAgY29uc3Qgb3BlbkJyYWNlID0gdmFsdWVbMF07XG4gICAgLy8gQ29uZmlybSB2YWx1ZSBpcyBhIFBvc3RncmVzIGFycmF5IGJ5IGNoZWNraW5nIGN1cmx5IGJyYWNrZXRzXG4gICAgaWYgKG9wZW5CcmFjZSA9PT0gJ3snICYmIGNsb3NlQnJhY2UgPT09ICd9Jykge1xuICAgICAgICBsZXQgYXJyO1xuICAgICAgICBjb25zdCB2YWxUcmltID0gdmFsdWUuc2xpY2UoMSwgbGFzdElkeCk7XG4gICAgICAgIC8vIFRPRE86IGZpbmQgYSBiZXR0ZXIgc29sdXRpb24gdG8gc2VwYXJhdGUgUG9zdGdyZXMgYXJyYXkgZGF0YVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXJyID0gSlNPTi5wYXJzZSgnWycgKyB2YWxUcmltICsgJ10nKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgLy8gV0FSTklORzogc3BsaXR0aW5nIG9uIGNvbW1hIGRvZXMgbm90IGNvdmVyIGFsbCBlZGdlIGNhc2VzXG4gICAgICAgICAgICBhcnIgPSB2YWxUcmltID8gdmFsVHJpbS5zcGxpdCgnLCcpIDogW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFyci5tYXAoKHZhbCkgPT4gY29udmVydENlbGwodHlwZSwgdmFsKSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn07XG4vKipcbiAqIEZpeGVzIHRpbWVzdGFtcCB0byBiZSBJU08tODYwMS4gU3dhcHMgdGhlIHNwYWNlIGJldHdlZW4gdGhlIGRhdGUgYW5kIHRpbWUgZm9yIGEgJ1QnXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3N1cGFiYXNlL3N1cGFiYXNlL2lzc3Vlcy8xOFxuICpcbiAqIEBleGFtcGxlIHRvVGltZXN0YW1wU3RyaW5nKCcyMDE5LTA5LTEwIDAwOjAwOjAwJylcbiAqIC8vPT4gJzIwMTktMDktMTBUMDA6MDA6MDAnXG4gKi9cbmV4cG9ydCBjb25zdCB0b1RpbWVzdGFtcFN0cmluZyA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKCcgJywgJ1QnKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcbmV4cG9ydCBjb25zdCBodHRwRW5kcG9pbnRVUkwgPSAoc29ja2V0VXJsKSA9PiB7XG4gICAgbGV0IHVybCA9IHNvY2tldFVybDtcbiAgICB1cmwgPSB1cmwucmVwbGFjZSgvXndzL2ksICdodHRwJyk7XG4gICAgdXJsID0gdXJsLnJlcGxhY2UoLyhcXC9zb2NrZXRcXC93ZWJzb2NrZXR8XFwvc29ja2V0fFxcL3dlYnNvY2tldClcXC8/JC9pLCAnJyk7XG4gICAgcmV0dXJuIHVybC5yZXBsYWNlKC9cXC8rJC8sICcnKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc2Zvcm1lcnMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/transformers.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/version.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/lib/version.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = '2.11.2';\n//# sourceMappingURL=version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvbGliL3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPO0FBQ1AiLCJzb3VyY2VzIjpbIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL1dvbmRlclZpdGUtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9yZWFsdGltZS1qcy9kaXN0L21vZHVsZS9saWIvdmVyc2lvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgdmVyc2lvbiA9ICcyLjExLjInO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/version.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/StorageClient.js":
/*!************************************************************************!*\
  !*** ./node_modules/@supabase/storage-js/dist/module/StorageClient.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StorageClient: () => (/* binding */ StorageClient)\n/* harmony export */ });\n/* harmony import */ var _packages_StorageFileApi__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./packages/StorageFileApi */ \"(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/packages/StorageFileApi.js\");\n/* harmony import */ var _packages_StorageBucketApi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./packages/StorageBucketApi */ \"(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/packages/StorageBucketApi.js\");\n\n\nclass StorageClient extends _packages_StorageBucketApi__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    constructor(url, headers = {}, fetch) {\n        super(url, headers, fetch);\n    }\n    /**\n     * Perform file operation in a bucket.\n     *\n     * @param id The bucket id to operate on.\n     */\n    from(id) {\n        return new _packages_StorageFileApi__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this.url, this.headers, id, this.fetch);\n    }\n}\n//# sourceMappingURL=StorageClient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3RvcmFnZS1qcy9kaXN0L21vZHVsZS9TdG9yYWdlQ2xpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF1RDtBQUNJO0FBQ3BELDRCQUE0QixrRUFBZ0I7QUFDbkQsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0VBQWM7QUFDakM7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvd29uZGVybGFuZG1pdGNoL0Nhc2NhZGVQcm9qZWN0cy9Xb25kZXJWaXRlLWZyb250ZW5kL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3RvcmFnZS1qcy9kaXN0L21vZHVsZS9TdG9yYWdlQ2xpZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBTdG9yYWdlRmlsZUFwaSBmcm9tICcuL3BhY2thZ2VzL1N0b3JhZ2VGaWxlQXBpJztcbmltcG9ydCBTdG9yYWdlQnVja2V0QXBpIGZyb20gJy4vcGFja2FnZXMvU3RvcmFnZUJ1Y2tldEFwaSc7XG5leHBvcnQgY2xhc3MgU3RvcmFnZUNsaWVudCBleHRlbmRzIFN0b3JhZ2VCdWNrZXRBcGkge1xuICAgIGNvbnN0cnVjdG9yKHVybCwgaGVhZGVycyA9IHt9LCBmZXRjaCkge1xuICAgICAgICBzdXBlcih1cmwsIGhlYWRlcnMsIGZldGNoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBmaWxlIG9wZXJhdGlvbiBpbiBhIGJ1Y2tldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCBUaGUgYnVja2V0IGlkIHRvIG9wZXJhdGUgb24uXG4gICAgICovXG4gICAgZnJvbShpZCkge1xuICAgICAgICByZXR1cm4gbmV3IFN0b3JhZ2VGaWxlQXBpKHRoaXMudXJsLCB0aGlzLmhlYWRlcnMsIGlkLCB0aGlzLmZldGNoKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdG9yYWdlQ2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/StorageClient.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/lib/constants.js":
/*!************************************************************************!*\
  !*** ./node_modules/@supabase/storage-js/dist/module/lib/constants.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_HEADERS: () => (/* binding */ DEFAULT_HEADERS)\n/* harmony export */ });\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./version */ \"(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/lib/version.js\");\n\nconst DEFAULT_HEADERS = { 'X-Client-Info': `storage-js/${_version__WEBPACK_IMPORTED_MODULE_0__.version}` };\n//# sourceMappingURL=constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3RvcmFnZS1qcy9kaXN0L21vZHVsZS9saWIvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQW9DO0FBQzdCLDBCQUEwQiwrQkFBK0IsNkNBQU8sQ0FBQztBQUN4RSIsInNvdXJjZXMiOlsiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvV29uZGVyVml0ZS1mcm9udGVuZC9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvZGlzdC9tb2R1bGUvbGliL2NvbnN0YW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSAnLi92ZXJzaW9uJztcbmV4cG9ydCBjb25zdCBERUZBVUxUX0hFQURFUlMgPSB7ICdYLUNsaWVudC1JbmZvJzogYHN0b3JhZ2UtanMvJHt2ZXJzaW9ufWAgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0YW50cy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/lib/constants.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/lib/errors.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@supabase/storage-js/dist/module/lib/errors.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StorageApiError: () => (/* binding */ StorageApiError),\n/* harmony export */   StorageError: () => (/* binding */ StorageError),\n/* harmony export */   StorageUnknownError: () => (/* binding */ StorageUnknownError),\n/* harmony export */   isStorageError: () => (/* binding */ isStorageError)\n/* harmony export */ });\nclass StorageError extends Error {\n    constructor(message) {\n        super(message);\n        this.__isStorageError = true;\n        this.name = 'StorageError';\n    }\n}\nfunction isStorageError(error) {\n    return typeof error === 'object' && error !== null && '__isStorageError' in error;\n}\nclass StorageApiError extends StorageError {\n    constructor(message, status) {\n        super(message);\n        this.name = 'StorageApiError';\n        this.status = status;\n    }\n    toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            status: this.status,\n        };\n    }\n}\nclass StorageUnknownError extends StorageError {\n    constructor(message, originalError) {\n        super(message);\n        this.name = 'StorageUnknownError';\n        this.originalError = originalError;\n    }\n}\n//# sourceMappingURL=errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3RvcmFnZS1qcy9kaXN0L21vZHVsZS9saWIvZXJyb3JzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvd29uZGVybGFuZG1pdGNoL0Nhc2NhZGVQcm9qZWN0cy9Xb25kZXJWaXRlLWZyb250ZW5kL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3RvcmFnZS1qcy9kaXN0L21vZHVsZS9saWIvZXJyb3JzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjbGFzcyBTdG9yYWdlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5fX2lzU3RvcmFnZUVycm9yID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1N0b3JhZ2VFcnJvcic7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzU3RvcmFnZUVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcgJiYgZXJyb3IgIT09IG51bGwgJiYgJ19faXNTdG9yYWdlRXJyb3InIGluIGVycm9yO1xufVxuZXhwb3J0IGNsYXNzIFN0b3JhZ2VBcGlFcnJvciBleHRlbmRzIFN0b3JhZ2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhdHVzKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnU3RvcmFnZUFwaUVycm9yJztcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgICAgICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFN0b3JhZ2VVbmtub3duRXJyb3IgZXh0ZW5kcyBTdG9yYWdlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG9yaWdpbmFsRXJyb3IpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdTdG9yYWdlVW5rbm93bkVycm9yJztcbiAgICAgICAgdGhpcy5vcmlnaW5hbEVycm9yID0gb3JpZ2luYWxFcnJvcjtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvcnMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/lib/errors.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/lib/fetch.js":
/*!********************************************************************!*\
  !*** ./node_modules/@supabase/storage-js/dist/module/lib/fetch.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   get: () => (/* binding */ get),\n/* harmony export */   head: () => (/* binding */ head),\n/* harmony export */   post: () => (/* binding */ post),\n/* harmony export */   put: () => (/* binding */ put),\n/* harmony export */   remove: () => (/* binding */ remove)\n/* harmony export */ });\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors */ \"(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/lib/errors.js\");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers */ \"(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/lib/helpers.js\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\nconst _getErrorMessage = (err) => err.msg || err.message || err.error_description || err.error || JSON.stringify(err);\nconst handleError = (error, reject, options) => __awaiter(void 0, void 0, void 0, function* () {\n    const Res = yield (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.resolveResponse)();\n    if (error instanceof Res && !(options === null || options === void 0 ? void 0 : options.noResolveJson)) {\n        error\n            .json()\n            .then((err) => {\n            reject(new _errors__WEBPACK_IMPORTED_MODULE_1__.StorageApiError(_getErrorMessage(err), error.status || 500));\n        })\n            .catch((err) => {\n            reject(new _errors__WEBPACK_IMPORTED_MODULE_1__.StorageUnknownError(_getErrorMessage(err), err));\n        });\n    }\n    else {\n        reject(new _errors__WEBPACK_IMPORTED_MODULE_1__.StorageUnknownError(_getErrorMessage(error), error));\n    }\n});\nconst _getRequestParams = (method, options, parameters, body) => {\n    const params = { method, headers: (options === null || options === void 0 ? void 0 : options.headers) || {} };\n    if (method === 'GET') {\n        return params;\n    }\n    params.headers = Object.assign({ 'Content-Type': 'application/json' }, options === null || options === void 0 ? void 0 : options.headers);\n    if (body) {\n        params.body = JSON.stringify(body);\n    }\n    return Object.assign(Object.assign({}, params), parameters);\n};\nfunction _handleRequest(fetcher, method, url, options, parameters, body) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return new Promise((resolve, reject) => {\n            fetcher(url, _getRequestParams(method, options, parameters, body))\n                .then((result) => {\n                if (!result.ok)\n                    throw result;\n                if (options === null || options === void 0 ? void 0 : options.noResolveJson)\n                    return result;\n                return result.json();\n            })\n                .then((data) => resolve(data))\n                .catch((error) => handleError(error, reject, options));\n        });\n    });\n}\nfunction get(fetcher, url, options, parameters) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return _handleRequest(fetcher, 'GET', url, options, parameters);\n    });\n}\nfunction post(fetcher, url, body, options, parameters) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return _handleRequest(fetcher, 'POST', url, options, parameters, body);\n    });\n}\nfunction put(fetcher, url, body, options, parameters) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return _handleRequest(fetcher, 'PUT', url, options, parameters, body);\n    });\n}\nfunction head(fetcher, url, options, parameters) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return _handleRequest(fetcher, 'HEAD', url, Object.assign(Object.assign({}, options), { noResolveJson: true }), parameters);\n    });\n}\nfunction remove(fetcher, url, body, options, parameters) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return _handleRequest(fetcher, 'DELETE', url, options, parameters, body);\n    });\n}\n//# sourceMappingURL=fetch.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3RvcmFnZS1qcy9kaXN0L21vZHVsZS9saWIvZmV0Y2guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBLGlCQUFpQixTQUFJLElBQUksU0FBSTtBQUM3Qiw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNnRTtBQUNwQjtBQUM1QztBQUNBO0FBQ0Esc0JBQXNCLHlEQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9EQUFlO0FBQ3RDLFNBQVM7QUFDVDtBQUNBLHVCQUF1Qix3REFBbUI7QUFDMUMsU0FBUztBQUNUO0FBQ0E7QUFDQSxtQkFBbUIsd0RBQW1CO0FBQ3RDO0FBQ0EsQ0FBQztBQUNEO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxvQ0FBb0M7QUFDekU7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDTztBQUNQO0FBQ0Esa0ZBQWtGLGNBQWMscUJBQXFCO0FBQ3JILEtBQUs7QUFDTDtBQUNPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvd29uZGVybGFuZG1pdGNoL0Nhc2NhZGVQcm9qZWN0cy9Xb25kZXJWaXRlLWZyb250ZW5kL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3RvcmFnZS1qcy9kaXN0L21vZHVsZS9saWIvZmV0Y2guanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBTdG9yYWdlQXBpRXJyb3IsIFN0b3JhZ2VVbmtub3duRXJyb3IgfSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQgeyByZXNvbHZlUmVzcG9uc2UgfSBmcm9tICcuL2hlbHBlcnMnO1xuY29uc3QgX2dldEVycm9yTWVzc2FnZSA9IChlcnIpID0+IGVyci5tc2cgfHwgZXJyLm1lc3NhZ2UgfHwgZXJyLmVycm9yX2Rlc2NyaXB0aW9uIHx8IGVyci5lcnJvciB8fCBKU09OLnN0cmluZ2lmeShlcnIpO1xuY29uc3QgaGFuZGxlRXJyb3IgPSAoZXJyb3IsIHJlamVjdCwgb3B0aW9ucykgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgY29uc3QgUmVzID0geWllbGQgcmVzb2x2ZVJlc3BvbnNlKCk7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgUmVzICYmICEob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm5vUmVzb2x2ZUpzb24pKSB7XG4gICAgICAgIGVycm9yXG4gICAgICAgICAgICAuanNvbigpXG4gICAgICAgICAgICAudGhlbigoZXJyKSA9PiB7XG4gICAgICAgICAgICByZWplY3QobmV3IFN0b3JhZ2VBcGlFcnJvcihfZ2V0RXJyb3JNZXNzYWdlKGVyciksIGVycm9yLnN0YXR1cyB8fCA1MDApKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICByZWplY3QobmV3IFN0b3JhZ2VVbmtub3duRXJyb3IoX2dldEVycm9yTWVzc2FnZShlcnIpLCBlcnIpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZWplY3QobmV3IFN0b3JhZ2VVbmtub3duRXJyb3IoX2dldEVycm9yTWVzc2FnZShlcnJvciksIGVycm9yKSk7XG4gICAgfVxufSk7XG5jb25zdCBfZ2V0UmVxdWVzdFBhcmFtcyA9IChtZXRob2QsIG9wdGlvbnMsIHBhcmFtZXRlcnMsIGJvZHkpID0+IHtcbiAgICBjb25zdCBwYXJhbXMgPSB7IG1ldGhvZCwgaGVhZGVyczogKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5oZWFkZXJzKSB8fCB7fSB9O1xuICAgIGlmIChtZXRob2QgPT09ICdHRVQnKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICAgIHBhcmFtcy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRlcnMpO1xuICAgIGlmIChib2R5KSB7XG4gICAgICAgIHBhcmFtcy5ib2R5ID0gSlNPTi5zdHJpbmdpZnkoYm9keSk7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcyksIHBhcmFtZXRlcnMpO1xufTtcbmZ1bmN0aW9uIF9oYW5kbGVSZXF1ZXN0KGZldGNoZXIsIG1ldGhvZCwgdXJsLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCBib2R5KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGZldGNoZXIodXJsLCBfZ2V0UmVxdWVzdFBhcmFtcyhtZXRob2QsIG9wdGlvbnMsIHBhcmFtZXRlcnMsIGJvZHkpKVxuICAgICAgICAgICAgICAgIC50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5vaylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubm9SZXNvbHZlSnNvbilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0Lmpzb24oKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGRhdGEpID0+IHJlc29sdmUoZGF0YSkpXG4gICAgICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4gaGFuZGxlRXJyb3IoZXJyb3IsIHJlamVjdCwgb3B0aW9ucykpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXQoZmV0Y2hlciwgdXJsLCBvcHRpb25zLCBwYXJhbWV0ZXJzKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgcmV0dXJuIF9oYW5kbGVSZXF1ZXN0KGZldGNoZXIsICdHRVQnLCB1cmwsIG9wdGlvbnMsIHBhcmFtZXRlcnMpO1xuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBvc3QoZmV0Y2hlciwgdXJsLCBib2R5LCBvcHRpb25zLCBwYXJhbWV0ZXJzKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgcmV0dXJuIF9oYW5kbGVSZXF1ZXN0KGZldGNoZXIsICdQT1NUJywgdXJsLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCBib2R5KTtcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwdXQoZmV0Y2hlciwgdXJsLCBib2R5LCBvcHRpb25zLCBwYXJhbWV0ZXJzKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgcmV0dXJuIF9oYW5kbGVSZXF1ZXN0KGZldGNoZXIsICdQVVQnLCB1cmwsIG9wdGlvbnMsIHBhcmFtZXRlcnMsIGJvZHkpO1xuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhlYWQoZmV0Y2hlciwgdXJsLCBvcHRpb25zLCBwYXJhbWV0ZXJzKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgcmV0dXJuIF9oYW5kbGVSZXF1ZXN0KGZldGNoZXIsICdIRUFEJywgdXJsLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7IG5vUmVzb2x2ZUpzb246IHRydWUgfSksIHBhcmFtZXRlcnMpO1xuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZShmZXRjaGVyLCB1cmwsIGJvZHksIG9wdGlvbnMsIHBhcmFtZXRlcnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICByZXR1cm4gX2hhbmRsZVJlcXVlc3QoZmV0Y2hlciwgJ0RFTEVURScsIHVybCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSk7XG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mZXRjaC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/lib/fetch.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/lib/helpers.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@supabase/storage-js/dist/module/lib/helpers.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   recursiveToCamel: () => (/* binding */ recursiveToCamel),\n/* harmony export */   resolveFetch: () => (/* binding */ resolveFetch),\n/* harmony export */   resolveResponse: () => (/* binding */ resolveResponse)\n/* harmony export */ });\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nconst resolveFetch = (customFetch) => {\n    let _fetch;\n    if (customFetch) {\n        _fetch = customFetch;\n    }\n    else if (typeof fetch === 'undefined') {\n        _fetch = (...args) => Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @supabase/node-fetch */ \"(app-pages-browser)/./node_modules/@supabase/node-fetch/browser.js\")).then(({ default: fetch }) => fetch(...args));\n    }\n    else {\n        _fetch = fetch;\n    }\n    return (...args) => _fetch(...args);\n};\nconst resolveResponse = () => __awaiter(void 0, void 0, void 0, function* () {\n    if (typeof Response === 'undefined') {\n        // @ts-ignore\n        return (yield Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @supabase/node-fetch */ \"(app-pages-browser)/./node_modules/@supabase/node-fetch/browser.js\"))).Response;\n    }\n    return Response;\n});\nconst recursiveToCamel = (item) => {\n    if (Array.isArray(item)) {\n        return item.map((el) => recursiveToCamel(el));\n    }\n    else if (typeof item === 'function' || item !== Object(item)) {\n        return item;\n    }\n    const result = {};\n    Object.entries(item).forEach(([key, value]) => {\n        const newKey = key.replace(/([-_][a-z])/gi, (c) => c.toUpperCase().replace(/[-_]/g, ''));\n        result[newKey] = recursiveToCamel(value);\n    });\n    return result;\n};\n//# sourceMappingURL=helpers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3RvcmFnZS1qcy9kaXN0L21vZHVsZS9saWIvaGVscGVycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxpQkFBaUIsU0FBSSxJQUFJLFNBQUk7QUFDN0IsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsc0xBQThCLFNBQVMsZ0JBQWdCO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLHNCQUFzQixzTEFBOEI7QUFDcEQ7QUFDQTtBQUNBLENBQUM7QUFDTTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvV29uZGVyVml0ZS1mcm9udGVuZC9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvZGlzdC9tb2R1bGUvbGliL2hlbHBlcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5leHBvcnQgY29uc3QgcmVzb2x2ZUZldGNoID0gKGN1c3RvbUZldGNoKSA9PiB7XG4gICAgbGV0IF9mZXRjaDtcbiAgICBpZiAoY3VzdG9tRmV0Y2gpIHtcbiAgICAgICAgX2ZldGNoID0gY3VzdG9tRmV0Y2g7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBmZXRjaCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgX2ZldGNoID0gKC4uLmFyZ3MpID0+IGltcG9ydCgnQHN1cGFiYXNlL25vZGUtZmV0Y2gnKS50aGVuKCh7IGRlZmF1bHQ6IGZldGNoIH0pID0+IGZldGNoKC4uLmFyZ3MpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIF9mZXRjaCA9IGZldGNoO1xuICAgIH1cbiAgICByZXR1cm4gKC4uLmFyZ3MpID0+IF9mZXRjaCguLi5hcmdzKTtcbn07XG5leHBvcnQgY29uc3QgcmVzb2x2ZVJlc3BvbnNlID0gKCkgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgaWYgKHR5cGVvZiBSZXNwb25zZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gKHlpZWxkIGltcG9ydCgnQHN1cGFiYXNlL25vZGUtZmV0Y2gnKSkuUmVzcG9uc2U7XG4gICAgfVxuICAgIHJldHVybiBSZXNwb25zZTtcbn0pO1xuZXhwb3J0IGNvbnN0IHJlY3Vyc2l2ZVRvQ2FtZWwgPSAoaXRlbSkgPT4ge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICAgIHJldHVybiBpdGVtLm1hcCgoZWwpID0+IHJlY3Vyc2l2ZVRvQ2FtZWwoZWwpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGl0ZW0gPT09ICdmdW5jdGlvbicgfHwgaXRlbSAhPT0gT2JqZWN0KGl0ZW0pKSB7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBPYmplY3QuZW50cmllcyhpdGVtKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgY29uc3QgbmV3S2V5ID0ga2V5LnJlcGxhY2UoLyhbLV9dW2Etel0pL2dpLCAoYykgPT4gYy50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoL1stX10vZywgJycpKTtcbiAgICAgICAgcmVzdWx0W25ld0tleV0gPSByZWN1cnNpdmVUb0NhbWVsKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlbHBlcnMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/lib/helpers.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/lib/version.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@supabase/storage-js/dist/module/lib/version.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n// generated by genversion\nconst version = '2.7.1';\n//# sourceMappingURL=version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3RvcmFnZS1qcy9kaXN0L21vZHVsZS9saWIvdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDTztBQUNQIiwic291cmNlcyI6WyIvVXNlcnMvd29uZGVybGFuZG1pdGNoL0Nhc2NhZGVQcm9qZWN0cy9Xb25kZXJWaXRlLWZyb250ZW5kL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3RvcmFnZS1qcy9kaXN0L21vZHVsZS9saWIvdmVyc2lvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBnZW5lcmF0ZWQgYnkgZ2VudmVyc2lvblxuZXhwb3J0IGNvbnN0IHZlcnNpb24gPSAnMi43LjEnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/lib/version.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/packages/StorageBucketApi.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@supabase/storage-js/dist/module/packages/StorageBucketApi.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ StorageBucketApi)\n/* harmony export */ });\n/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/constants */ \"(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/lib/constants.js\");\n/* harmony import */ var _lib_errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/errors */ \"(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/lib/errors.js\");\n/* harmony import */ var _lib_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/fetch */ \"(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/lib/fetch.js\");\n/* harmony import */ var _lib_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/helpers */ \"(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/lib/helpers.js\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\nclass StorageBucketApi {\n    constructor(url, headers = {}, fetch) {\n        this.url = url;\n        this.headers = Object.assign(Object.assign({}, _lib_constants__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_HEADERS), headers);\n        this.fetch = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_1__.resolveFetch)(fetch);\n    }\n    /**\n     * Retrieves the details of all Storage buckets within an existing project.\n     */\n    listBuckets() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.get)(this.fetch, `${this.url}/bucket`, { headers: this.headers });\n                return { data, error: null };\n            }\n            catch (error) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isStorageError)(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Retrieves the details of an existing Storage bucket.\n     *\n     * @param id The unique identifier of the bucket you would like to retrieve.\n     */\n    getBucket(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.get)(this.fetch, `${this.url}/bucket/${id}`, { headers: this.headers });\n                return { data, error: null };\n            }\n            catch (error) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isStorageError)(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Creates a new Storage bucket\n     *\n     * @param id A unique identifier for the bucket you are creating.\n     * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations. By default, buckets are private.\n     * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.\n     * The global file size limit takes precedence over this value.\n     * The default value is null, which doesn't set a per bucket file size limit.\n     * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.\n     * The default value is null, which allows files with all mime types to be uploaded.\n     * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.\n     * @returns newly created bucket id\n     */\n    createBucket(id, options = {\n        public: false,\n    }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.post)(this.fetch, `${this.url}/bucket`, {\n                    id,\n                    name: id,\n                    public: options.public,\n                    file_size_limit: options.fileSizeLimit,\n                    allowed_mime_types: options.allowedMimeTypes,\n                }, { headers: this.headers });\n                return { data, error: null };\n            }\n            catch (error) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isStorageError)(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Updates a Storage bucket\n     *\n     * @param id A unique identifier for the bucket you are updating.\n     * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations.\n     * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.\n     * The global file size limit takes precedence over this value.\n     * The default value is null, which doesn't set a per bucket file size limit.\n     * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.\n     * The default value is null, which allows files with all mime types to be uploaded.\n     * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.\n     */\n    updateBucket(id, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.put)(this.fetch, `${this.url}/bucket/${id}`, {\n                    id,\n                    name: id,\n                    public: options.public,\n                    file_size_limit: options.fileSizeLimit,\n                    allowed_mime_types: options.allowedMimeTypes,\n                }, { headers: this.headers });\n                return { data, error: null };\n            }\n            catch (error) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isStorageError)(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Removes all objects inside a single bucket.\n     *\n     * @param id The unique identifier of the bucket you would like to empty.\n     */\n    emptyBucket(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.post)(this.fetch, `${this.url}/bucket/${id}/empty`, {}, { headers: this.headers });\n                return { data, error: null };\n            }\n            catch (error) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isStorageError)(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Deletes an existing bucket. A bucket can't be deleted with existing objects inside it.\n     * You must first `empty()` the bucket.\n     *\n     * @param id The unique identifier of the bucket you would like to delete.\n     */\n    deleteBucket(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.remove)(this.fetch, `${this.url}/bucket/${id}`, {}, { headers: this.headers });\n                return { data, error: null };\n            }\n            catch (error) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isStorageError)(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n}\n//# sourceMappingURL=StorageBucketApi.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3RvcmFnZS1qcy9kaXN0L21vZHVsZS9wYWNrYWdlcy9TdG9yYWdlQnVja2V0QXBpLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUEsaUJBQWlCLFNBQUksSUFBSSxTQUFJO0FBQzdCLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ21EO0FBQ0o7QUFDTztBQUNSO0FBQy9CO0FBQ2YsaUNBQWlDO0FBQ2pDO0FBQ0EscURBQXFELEVBQUUsMkRBQWU7QUFDdEUscUJBQXFCLDBEQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLCtDQUFHLGdCQUFnQixTQUFTLFlBQVksdUJBQXVCO0FBQ2xHLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0Esb0JBQW9CLDJEQUFjO0FBQ2xDLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLCtDQUFHLGdCQUFnQixTQUFTLFVBQVUsR0FBRyxLQUFLLHVCQUF1QjtBQUN4Ryx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLG9CQUFvQiwyREFBYztBQUNsQyw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxtQ0FBbUMsZ0RBQUksZ0JBQWdCLFNBQVM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixJQUFJLHVCQUF1QjtBQUM1Qyx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLG9CQUFvQiwyREFBYztBQUNsQyw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLCtDQUFHLGdCQUFnQixTQUFTLFVBQVUsR0FBRztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLElBQUksdUJBQXVCO0FBQzVDLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0Esb0JBQW9CLDJEQUFjO0FBQ2xDLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdEQUFJLGdCQUFnQixTQUFTLFVBQVUsR0FBRyxXQUFXLElBQUksdUJBQXVCO0FBQ25ILHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0Esb0JBQW9CLDJEQUFjO0FBQ2xDLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsa0RBQU0sZ0JBQWdCLFNBQVMsVUFBVSxHQUFHLEtBQUssSUFBSSx1QkFBdUI7QUFDL0cseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxvQkFBb0IsMkRBQWM7QUFDbEMsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL1dvbmRlclZpdGUtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdG9yYWdlLWpzL2Rpc3QvbW9kdWxlL3BhY2thZ2VzL1N0b3JhZ2VCdWNrZXRBcGkuanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBERUZBVUxUX0hFQURFUlMgfSBmcm9tICcuLi9saWIvY29uc3RhbnRzJztcbmltcG9ydCB7IGlzU3RvcmFnZUVycm9yIH0gZnJvbSAnLi4vbGliL2Vycm9ycyc7XG5pbXBvcnQgeyBnZXQsIHBvc3QsIHB1dCwgcmVtb3ZlIH0gZnJvbSAnLi4vbGliL2ZldGNoJztcbmltcG9ydCB7IHJlc29sdmVGZXRjaCB9IGZyb20gJy4uL2xpYi9oZWxwZXJzJztcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0b3JhZ2VCdWNrZXRBcGkge1xuICAgIGNvbnN0cnVjdG9yKHVybCwgaGVhZGVycyA9IHt9LCBmZXRjaCkge1xuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX0hFQURFUlMpLCBoZWFkZXJzKTtcbiAgICAgICAgdGhpcy5mZXRjaCA9IHJlc29sdmVGZXRjaChmZXRjaCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgZGV0YWlscyBvZiBhbGwgU3RvcmFnZSBidWNrZXRzIHdpdGhpbiBhbiBleGlzdGluZyBwcm9qZWN0LlxuICAgICAqL1xuICAgIGxpc3RCdWNrZXRzKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0geWllbGQgZ2V0KHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS9idWNrZXRgLCB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgZGV0YWlscyBvZiBhbiBleGlzdGluZyBTdG9yYWdlIGJ1Y2tldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCBUaGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIGJ1Y2tldCB5b3Ugd291bGQgbGlrZSB0byByZXRyaWV2ZS5cbiAgICAgKi9cbiAgICBnZXRCdWNrZXQoaWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIGdldCh0aGlzLmZldGNoLCBgJHt0aGlzLnVybH0vYnVja2V0LyR7aWR9YCwgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFN0b3JhZ2UgYnVja2V0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWQgQSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGJ1Y2tldCB5b3UgYXJlIGNyZWF0aW5nLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnB1YmxpYyBUaGUgdmlzaWJpbGl0eSBvZiB0aGUgYnVja2V0LiBQdWJsaWMgYnVja2V0cyBkb24ndCByZXF1aXJlIGFuIGF1dGhvcml6YXRpb24gdG9rZW4gdG8gZG93bmxvYWQgb2JqZWN0cywgYnV0IHN0aWxsIHJlcXVpcmUgYSB2YWxpZCB0b2tlbiBmb3IgYWxsIG90aGVyIG9wZXJhdGlvbnMuIEJ5IGRlZmF1bHQsIGJ1Y2tldHMgYXJlIHByaXZhdGUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZmlsZVNpemVMaW1pdCBzcGVjaWZpZXMgdGhlIG1heCBmaWxlIHNpemUgaW4gYnl0ZXMgdGhhdCBjYW4gYmUgdXBsb2FkZWQgdG8gdGhpcyBidWNrZXQuXG4gICAgICogVGhlIGdsb2JhbCBmaWxlIHNpemUgbGltaXQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIHRoaXMgdmFsdWUuXG4gICAgICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgbnVsbCwgd2hpY2ggZG9lc24ndCBzZXQgYSBwZXIgYnVja2V0IGZpbGUgc2l6ZSBsaW1pdC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hbGxvd2VkTWltZVR5cGVzIHNwZWNpZmllcyB0aGUgYWxsb3dlZCBtaW1lIHR5cGVzIHRoYXQgdGhpcyBidWNrZXQgY2FuIGFjY2VwdCBkdXJpbmcgdXBsb2FkLlxuICAgICAqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIG51bGwsIHdoaWNoIGFsbG93cyBmaWxlcyB3aXRoIGFsbCBtaW1lIHR5cGVzIHRvIGJlIHVwbG9hZGVkLlxuICAgICAqIEVhY2ggbWltZSB0eXBlIHNwZWNpZmllZCBjYW4gYmUgYSB3aWxkY2FyZCwgZS5nLiBpbWFnZS8qLCBvciBhIHNwZWNpZmljIG1pbWUgdHlwZSwgZS5nLiBpbWFnZS9wbmcuXG4gICAgICogQHJldHVybnMgbmV3bHkgY3JlYXRlZCBidWNrZXQgaWRcbiAgICAgKi9cbiAgICBjcmVhdGVCdWNrZXQoaWQsIG9wdGlvbnMgPSB7XG4gICAgICAgIHB1YmxpYzogZmFsc2UsXG4gICAgfSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0geWllbGQgcG9zdCh0aGlzLmZldGNoLCBgJHt0aGlzLnVybH0vYnVja2V0YCwge1xuICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogaWQsXG4gICAgICAgICAgICAgICAgICAgIHB1YmxpYzogb3B0aW9ucy5wdWJsaWMsXG4gICAgICAgICAgICAgICAgICAgIGZpbGVfc2l6ZV9saW1pdDogb3B0aW9ucy5maWxlU2l6ZUxpbWl0LFxuICAgICAgICAgICAgICAgICAgICBhbGxvd2VkX21pbWVfdHlwZXM6IG9wdGlvbnMuYWxsb3dlZE1pbWVUeXBlcyxcbiAgICAgICAgICAgICAgICB9LCB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgYSBTdG9yYWdlIGJ1Y2tldFxuICAgICAqXG4gICAgICogQHBhcmFtIGlkIEEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBidWNrZXQgeW91IGFyZSB1cGRhdGluZy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5wdWJsaWMgVGhlIHZpc2liaWxpdHkgb2YgdGhlIGJ1Y2tldC4gUHVibGljIGJ1Y2tldHMgZG9uJ3QgcmVxdWlyZSBhbiBhdXRob3JpemF0aW9uIHRva2VuIHRvIGRvd25sb2FkIG9iamVjdHMsIGJ1dCBzdGlsbCByZXF1aXJlIGEgdmFsaWQgdG9rZW4gZm9yIGFsbCBvdGhlciBvcGVyYXRpb25zLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmZpbGVTaXplTGltaXQgc3BlY2lmaWVzIHRoZSBtYXggZmlsZSBzaXplIGluIGJ5dGVzIHRoYXQgY2FuIGJlIHVwbG9hZGVkIHRvIHRoaXMgYnVja2V0LlxuICAgICAqIFRoZSBnbG9iYWwgZmlsZSBzaXplIGxpbWl0IHRha2VzIHByZWNlZGVuY2Ugb3ZlciB0aGlzIHZhbHVlLlxuICAgICAqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIG51bGwsIHdoaWNoIGRvZXNuJ3Qgc2V0IGEgcGVyIGJ1Y2tldCBmaWxlIHNpemUgbGltaXQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYWxsb3dlZE1pbWVUeXBlcyBzcGVjaWZpZXMgdGhlIGFsbG93ZWQgbWltZSB0eXBlcyB0aGF0IHRoaXMgYnVja2V0IGNhbiBhY2NlcHQgZHVyaW5nIHVwbG9hZC5cbiAgICAgKiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBudWxsLCB3aGljaCBhbGxvd3MgZmlsZXMgd2l0aCBhbGwgbWltZSB0eXBlcyB0byBiZSB1cGxvYWRlZC5cbiAgICAgKiBFYWNoIG1pbWUgdHlwZSBzcGVjaWZpZWQgY2FuIGJlIGEgd2lsZGNhcmQsIGUuZy4gaW1hZ2UvKiwgb3IgYSBzcGVjaWZpYyBtaW1lIHR5cGUsIGUuZy4gaW1hZ2UvcG5nLlxuICAgICAqL1xuICAgIHVwZGF0ZUJ1Y2tldChpZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0geWllbGQgcHV0KHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS9idWNrZXQvJHtpZH1gLCB7XG4gICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgcHVibGljOiBvcHRpb25zLnB1YmxpYyxcbiAgICAgICAgICAgICAgICAgICAgZmlsZV9zaXplX2xpbWl0OiBvcHRpb25zLmZpbGVTaXplTGltaXQsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93ZWRfbWltZV90eXBlczogb3B0aW9ucy5hbGxvd2VkTWltZVR5cGVzLFxuICAgICAgICAgICAgICAgIH0sIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgb2JqZWN0cyBpbnNpZGUgYSBzaW5nbGUgYnVja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgYnVja2V0IHlvdSB3b3VsZCBsaWtlIHRvIGVtcHR5LlxuICAgICAqL1xuICAgIGVtcHR5QnVja2V0KGlkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB5aWVsZCBwb3N0KHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS9idWNrZXQvJHtpZH0vZW1wdHlgLCB7fSwgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGFuIGV4aXN0aW5nIGJ1Y2tldC4gQSBidWNrZXQgY2FuJ3QgYmUgZGVsZXRlZCB3aXRoIGV4aXN0aW5nIG9iamVjdHMgaW5zaWRlIGl0LlxuICAgICAqIFlvdSBtdXN0IGZpcnN0IGBlbXB0eSgpYCB0aGUgYnVja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgYnVja2V0IHlvdSB3b3VsZCBsaWtlIHRvIGRlbGV0ZS5cbiAgICAgKi9cbiAgICBkZWxldGVCdWNrZXQoaWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIHJlbW92ZSh0aGlzLmZldGNoLCBgJHt0aGlzLnVybH0vYnVja2V0LyR7aWR9YCwge30sIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdG9yYWdlQnVja2V0QXBpLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/packages/StorageBucketApi.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/packages/StorageFileApi.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@supabase/storage-js/dist/module/packages/StorageFileApi.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ StorageFileApi)\n/* harmony export */ });\n/* harmony import */ var _lib_errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/errors */ \"(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/lib/errors.js\");\n/* harmony import */ var _lib_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/fetch */ \"(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/lib/fetch.js\");\n/* harmony import */ var _lib_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/helpers */ \"(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/lib/helpers.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/../../node_modules/buffer/index.js\")[\"Buffer\"];\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\nconst DEFAULT_SEARCH_OPTIONS = {\n    limit: 100,\n    offset: 0,\n    sortBy: {\n        column: 'name',\n        order: 'asc',\n    },\n};\nconst DEFAULT_FILE_OPTIONS = {\n    cacheControl: '3600',\n    contentType: 'text/plain;charset=UTF-8',\n    upsert: false,\n};\nclass StorageFileApi {\n    constructor(url, headers = {}, bucketId, fetch) {\n        this.url = url;\n        this.headers = headers;\n        this.bucketId = bucketId;\n        this.fetch = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_0__.resolveFetch)(fetch);\n    }\n    /**\n     * Uploads a file to an existing bucket or replaces an existing file at the specified path with a new one.\n     *\n     * @param method HTTP method.\n     * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n     * @param fileBody The body of the file to be stored in the bucket.\n     */\n    uploadOrUpdate(method, path, fileBody, fileOptions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                let body;\n                const options = Object.assign(Object.assign({}, DEFAULT_FILE_OPTIONS), fileOptions);\n                let headers = Object.assign(Object.assign({}, this.headers), (method === 'POST' && { 'x-upsert': String(options.upsert) }));\n                const metadata = options.metadata;\n                if (typeof Blob !== 'undefined' && fileBody instanceof Blob) {\n                    body = new FormData();\n                    body.append('cacheControl', options.cacheControl);\n                    if (metadata) {\n                        body.append('metadata', this.encodeMetadata(metadata));\n                    }\n                    body.append('', fileBody);\n                }\n                else if (typeof FormData !== 'undefined' && fileBody instanceof FormData) {\n                    body = fileBody;\n                    body.append('cacheControl', options.cacheControl);\n                    if (metadata) {\n                        body.append('metadata', this.encodeMetadata(metadata));\n                    }\n                }\n                else {\n                    body = fileBody;\n                    headers['cache-control'] = `max-age=${options.cacheControl}`;\n                    headers['content-type'] = options.contentType;\n                    if (metadata) {\n                        headers['x-metadata'] = this.toBase64(this.encodeMetadata(metadata));\n                    }\n                }\n                if (fileOptions === null || fileOptions === void 0 ? void 0 : fileOptions.headers) {\n                    headers = Object.assign(Object.assign({}, headers), fileOptions.headers);\n                }\n                const cleanPath = this._removeEmptyFolders(path);\n                const _path = this._getFinalPath(cleanPath);\n                const res = yield this.fetch(`${this.url}/object/${_path}`, Object.assign({ method, body: body, headers }, ((options === null || options === void 0 ? void 0 : options.duplex) ? { duplex: options.duplex } : {})));\n                const data = yield res.json();\n                if (res.ok) {\n                    return {\n                        data: { path: cleanPath, id: data.Id, fullPath: data.Key },\n                        error: null,\n                    };\n                }\n                else {\n                    const error = data;\n                    return { data: null, error };\n                }\n            }\n            catch (error) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_1__.isStorageError)(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Uploads a file to an existing bucket.\n     *\n     * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n     * @param fileBody The body of the file to be stored in the bucket.\n     */\n    upload(path, fileBody, fileOptions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.uploadOrUpdate('POST', path, fileBody, fileOptions);\n        });\n    }\n    /**\n     * Upload a file with a token generated from `createSignedUploadUrl`.\n     * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n     * @param token The token generated from `createSignedUploadUrl`\n     * @param fileBody The body of the file to be stored in the bucket.\n     */\n    uploadToSignedUrl(path, token, fileBody, fileOptions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const cleanPath = this._removeEmptyFolders(path);\n            const _path = this._getFinalPath(cleanPath);\n            const url = new URL(this.url + `/object/upload/sign/${_path}`);\n            url.searchParams.set('token', token);\n            try {\n                let body;\n                const options = Object.assign({ upsert: DEFAULT_FILE_OPTIONS.upsert }, fileOptions);\n                const headers = Object.assign(Object.assign({}, this.headers), { 'x-upsert': String(options.upsert) });\n                if (typeof Blob !== 'undefined' && fileBody instanceof Blob) {\n                    body = new FormData();\n                    body.append('cacheControl', options.cacheControl);\n                    body.append('', fileBody);\n                }\n                else if (typeof FormData !== 'undefined' && fileBody instanceof FormData) {\n                    body = fileBody;\n                    body.append('cacheControl', options.cacheControl);\n                }\n                else {\n                    body = fileBody;\n                    headers['cache-control'] = `max-age=${options.cacheControl}`;\n                    headers['content-type'] = options.contentType;\n                }\n                const res = yield this.fetch(url.toString(), {\n                    method: 'PUT',\n                    body: body,\n                    headers,\n                });\n                const data = yield res.json();\n                if (res.ok) {\n                    return {\n                        data: { path: cleanPath, fullPath: data.Key },\n                        error: null,\n                    };\n                }\n                else {\n                    const error = data;\n                    return { data: null, error };\n                }\n            }\n            catch (error) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_1__.isStorageError)(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Creates a signed upload URL.\n     * Signed upload URLs can be used to upload files to the bucket without further authentication.\n     * They are valid for 2 hours.\n     * @param path The file path, including the current file name. For example `folder/image.png`.\n     * @param options.upsert If set to true, allows the file to be overwritten if it already exists.\n     */\n    createSignedUploadUrl(path, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                let _path = this._getFinalPath(path);\n                const headers = Object.assign({}, this.headers);\n                if (options === null || options === void 0 ? void 0 : options.upsert) {\n                    headers['x-upsert'] = 'true';\n                }\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.post)(this.fetch, `${this.url}/object/upload/sign/${_path}`, {}, { headers });\n                const url = new URL(this.url + data.url);\n                const token = url.searchParams.get('token');\n                if (!token) {\n                    throw new _lib_errors__WEBPACK_IMPORTED_MODULE_1__.StorageError('No token returned by API');\n                }\n                return { data: { signedUrl: url.toString(), path, token }, error: null };\n            }\n            catch (error) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_1__.isStorageError)(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Replaces an existing file at the specified path with a new one.\n     *\n     * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to update.\n     * @param fileBody The body of the file to be stored in the bucket.\n     */\n    update(path, fileBody, fileOptions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.uploadOrUpdate('PUT', path, fileBody, fileOptions);\n        });\n    }\n    /**\n     * Moves an existing file to a new path in the same bucket.\n     *\n     * @param fromPath The original file path, including the current file name. For example `folder/image.png`.\n     * @param toPath The new file path, including the new file name. For example `folder/image-new.png`.\n     * @param options The destination options.\n     */\n    move(fromPath, toPath, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.post)(this.fetch, `${this.url}/object/move`, {\n                    bucketId: this.bucketId,\n                    sourceKey: fromPath,\n                    destinationKey: toPath,\n                    destinationBucket: options === null || options === void 0 ? void 0 : options.destinationBucket,\n                }, { headers: this.headers });\n                return { data, error: null };\n            }\n            catch (error) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_1__.isStorageError)(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Copies an existing file to a new path in the same bucket.\n     *\n     * @param fromPath The original file path, including the current file name. For example `folder/image.png`.\n     * @param toPath The new file path, including the new file name. For example `folder/image-copy.png`.\n     * @param options The destination options.\n     */\n    copy(fromPath, toPath, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.post)(this.fetch, `${this.url}/object/copy`, {\n                    bucketId: this.bucketId,\n                    sourceKey: fromPath,\n                    destinationKey: toPath,\n                    destinationBucket: options === null || options === void 0 ? void 0 : options.destinationBucket,\n                }, { headers: this.headers });\n                return { data: { path: data.Key }, error: null };\n            }\n            catch (error) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_1__.isStorageError)(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Creates a signed URL. Use a signed URL to share a file for a fixed amount of time.\n     *\n     * @param path The file path, including the current file name. For example `folder/image.png`.\n     * @param expiresIn The number of seconds until the signed URL expires. For example, `60` for a URL which is valid for one minute.\n     * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n     * @param options.transform Transform the asset before serving it to the client.\n     */\n    createSignedUrl(path, expiresIn, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                let _path = this._getFinalPath(path);\n                let data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.post)(this.fetch, `${this.url}/object/sign/${_path}`, Object.assign({ expiresIn }, ((options === null || options === void 0 ? void 0 : options.transform) ? { transform: options.transform } : {})), { headers: this.headers });\n                const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download)\n                    ? `&download=${options.download === true ? '' : options.download}`\n                    : '';\n                const signedUrl = encodeURI(`${this.url}${data.signedURL}${downloadQueryParam}`);\n                data = { signedUrl };\n                return { data, error: null };\n            }\n            catch (error) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_1__.isStorageError)(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Creates multiple signed URLs. Use a signed URL to share a file for a fixed amount of time.\n     *\n     * @param paths The file paths to be downloaded, including the current file names. For example `['folder/image.png', 'folder2/image2.png']`.\n     * @param expiresIn The number of seconds until the signed URLs expire. For example, `60` for URLs which are valid for one minute.\n     * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n     */\n    createSignedUrls(paths, expiresIn, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.post)(this.fetch, `${this.url}/object/sign/${this.bucketId}`, { expiresIn, paths }, { headers: this.headers });\n                const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download)\n                    ? `&download=${options.download === true ? '' : options.download}`\n                    : '';\n                return {\n                    data: data.map((datum) => (Object.assign(Object.assign({}, datum), { signedUrl: datum.signedURL\n                            ? encodeURI(`${this.url}${datum.signedURL}${downloadQueryParam}`)\n                            : null }))),\n                    error: null,\n                };\n            }\n            catch (error) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_1__.isStorageError)(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Downloads a file from a private bucket. For public buckets, make a request to the URL returned from `getPublicUrl` instead.\n     *\n     * @param path The full path and file name of the file to be downloaded. For example `folder/image.png`.\n     * @param options.transform Transform the asset before serving it to the client.\n     */\n    download(path, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const wantsTransformation = typeof (options === null || options === void 0 ? void 0 : options.transform) !== 'undefined';\n            const renderPath = wantsTransformation ? 'render/image/authenticated' : 'object';\n            const transformationQuery = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});\n            const queryString = transformationQuery ? `?${transformationQuery}` : '';\n            try {\n                const _path = this._getFinalPath(path);\n                const res = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.get)(this.fetch, `${this.url}/${renderPath}/${_path}${queryString}`, {\n                    headers: this.headers,\n                    noResolveJson: true,\n                });\n                const data = yield res.blob();\n                return { data, error: null };\n            }\n            catch (error) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_1__.isStorageError)(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Retrieves the details of an existing file.\n     * @param path\n     */\n    info(path) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const _path = this._getFinalPath(path);\n            try {\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.get)(this.fetch, `${this.url}/object/info/${_path}`, {\n                    headers: this.headers,\n                });\n                return { data: (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_0__.recursiveToCamel)(data), error: null };\n            }\n            catch (error) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_1__.isStorageError)(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Checks the existence of a file.\n     * @param path\n     */\n    exists(path) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const _path = this._getFinalPath(path);\n            try {\n                yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.head)(this.fetch, `${this.url}/object/${_path}`, {\n                    headers: this.headers,\n                });\n                return { data: true, error: null };\n            }\n            catch (error) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_1__.isStorageError)(error) && error instanceof _lib_errors__WEBPACK_IMPORTED_MODULE_1__.StorageUnknownError) {\n                    const originalError = error.originalError;\n                    if ([400, 404].includes(originalError === null || originalError === void 0 ? void 0 : originalError.status)) {\n                        return { data: false, error };\n                    }\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * A simple convenience function to get the URL for an asset in a public bucket. If you do not want to use this function, you can construct the public URL by concatenating the bucket URL with the path to the asset.\n     * This function does not verify if the bucket is public. If a public URL is created for a bucket which is not public, you will not be able to download the asset.\n     *\n     * @param path The path and name of the file to generate the public URL for. For example `folder/image.png`.\n     * @param options.download Triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n     * @param options.transform Transform the asset before serving it to the client.\n     */\n    getPublicUrl(path, options) {\n        const _path = this._getFinalPath(path);\n        const _queryString = [];\n        const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download)\n            ? `download=${options.download === true ? '' : options.download}`\n            : '';\n        if (downloadQueryParam !== '') {\n            _queryString.push(downloadQueryParam);\n        }\n        const wantsTransformation = typeof (options === null || options === void 0 ? void 0 : options.transform) !== 'undefined';\n        const renderPath = wantsTransformation ? 'render/image' : 'object';\n        const transformationQuery = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});\n        if (transformationQuery !== '') {\n            _queryString.push(transformationQuery);\n        }\n        let queryString = _queryString.join('&');\n        if (queryString !== '') {\n            queryString = `?${queryString}`;\n        }\n        return {\n            data: { publicUrl: encodeURI(`${this.url}/${renderPath}/public/${_path}${queryString}`) },\n        };\n    }\n    /**\n     * Deletes files within the same bucket\n     *\n     * @param paths An array of files to delete, including the path and file name. For example [`'folder/image.png'`].\n     */\n    remove(paths) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.remove)(this.fetch, `${this.url}/object/${this.bucketId}`, { prefixes: paths }, { headers: this.headers });\n                return { data, error: null };\n            }\n            catch (error) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_1__.isStorageError)(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Get file metadata\n     * @param id the file id to retrieve metadata\n     */\n    // async getMetadata(\n    //   id: string\n    // ): Promise<\n    //   | {\n    //       data: Metadata\n    //       error: null\n    //     }\n    //   | {\n    //       data: null\n    //       error: StorageError\n    //     }\n    // > {\n    //   try {\n    //     const data = await get(this.fetch, `${this.url}/metadata/${id}`, { headers: this.headers })\n    //     return { data, error: null }\n    //   } catch (error) {\n    //     if (isStorageError(error)) {\n    //       return { data: null, error }\n    //     }\n    //     throw error\n    //   }\n    // }\n    /**\n     * Update file metadata\n     * @param id the file id to update metadata\n     * @param meta the new file metadata\n     */\n    // async updateMetadata(\n    //   id: string,\n    //   meta: Metadata\n    // ): Promise<\n    //   | {\n    //       data: Metadata\n    //       error: null\n    //     }\n    //   | {\n    //       data: null\n    //       error: StorageError\n    //     }\n    // > {\n    //   try {\n    //     const data = await post(\n    //       this.fetch,\n    //       `${this.url}/metadata/${id}`,\n    //       { ...meta },\n    //       { headers: this.headers }\n    //     )\n    //     return { data, error: null }\n    //   } catch (error) {\n    //     if (isStorageError(error)) {\n    //       return { data: null, error }\n    //     }\n    //     throw error\n    //   }\n    // }\n    /**\n     * Lists all the files within a bucket.\n     * @param path The folder path.\n     */\n    list(path, options, parameters) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const body = Object.assign(Object.assign(Object.assign({}, DEFAULT_SEARCH_OPTIONS), options), { prefix: path || '' });\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.post)(this.fetch, `${this.url}/object/list/${this.bucketId}`, body, { headers: this.headers }, parameters);\n                return { data, error: null };\n            }\n            catch (error) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_1__.isStorageError)(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    encodeMetadata(metadata) {\n        return JSON.stringify(metadata);\n    }\n    toBase64(data) {\n        if (typeof Buffer !== 'undefined') {\n            return Buffer.from(data).toString('base64');\n        }\n        return btoa(data);\n    }\n    _getFinalPath(path) {\n        return `${this.bucketId}/${path}`;\n    }\n    _removeEmptyFolders(path) {\n        return path.replace(/^\\/|\\/$/g, '').replace(/\\/+/g, '/');\n    }\n    transformOptsToQueryString(transform) {\n        const params = [];\n        if (transform.width) {\n            params.push(`width=${transform.width}`);\n        }\n        if (transform.height) {\n            params.push(`height=${transform.height}`);\n        }\n        if (transform.resize) {\n            params.push(`resize=${transform.resize}`);\n        }\n        if (transform.format) {\n            params.push(`format=${transform.format}`);\n        }\n        if (transform.quality) {\n            params.push(`quality=${transform.quality}`);\n        }\n        return params.join('&');\n    }\n}\n//# sourceMappingURL=StorageFileApi.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3RvcmFnZS1qcy9kaXN0L21vZHVsZS9wYWNrYWdlcy9TdG9yYWdlRmlsZUFwaS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLGlCQUFpQixTQUFJLElBQUksU0FBSTtBQUM3Qiw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNrRjtBQUMzQjtBQUNTO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNlO0FBQ2YsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwwREFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQsNERBQTRELHlDQUF5QyxvQ0FBb0M7QUFDekk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELHFCQUFxQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFNBQVMsVUFBVSxNQUFNLG1CQUFtQiw2QkFBNkIsMEVBQTBFLHlCQUF5QixJQUFJO0FBQ2hPO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrREFBa0Q7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkRBQWM7QUFDbEMsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLE1BQU07QUFDeEU7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHFDQUFxQztBQUNyRiw4REFBOEQsbUJBQW1CLG9DQUFvQztBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELHFCQUFxQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHFDQUFxQztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyREFBYztBQUNsQyw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0RBQUksZ0JBQWdCLFNBQVMsc0JBQXNCLE1BQU0sS0FBSyxJQUFJLFNBQVM7QUFDOUc7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHFEQUFZO0FBQzFDO0FBQ0EseUJBQXlCLFFBQVEsd0NBQXdDO0FBQ3pFO0FBQ0E7QUFDQSxvQkFBb0IsMkRBQWM7QUFDbEMsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdEQUFJLGdCQUFnQixTQUFTO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLElBQUksdUJBQXVCO0FBQzVDLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0Esb0JBQW9CLDJEQUFjO0FBQ2xDLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxnREFBSSxnQkFBZ0IsU0FBUztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixJQUFJLHVCQUF1QjtBQUM1Qyx5QkFBeUIsUUFBUSxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBLG9CQUFvQiwyREFBYztBQUNsQyw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdEQUFJLGdCQUFnQixTQUFTLGVBQWUsTUFBTSxtQkFBbUIsV0FBVyw2RUFBNkUsK0JBQStCLElBQUksTUFBTSx1QkFBdUI7QUFDOVA7QUFDQSxtQ0FBbUMsa0RBQWtEO0FBQ3JGO0FBQ0EsK0NBQStDLFNBQVMsRUFBRSxlQUFlLEVBQUUsbUJBQW1CO0FBQzlGLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekI7QUFDQTtBQUNBLG9CQUFvQiwyREFBYztBQUNsQyw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0RBQUksZ0JBQWdCLFNBQVMsZUFBZSxjQUFjLEtBQUssa0JBQWtCLElBQUksdUJBQXVCO0FBQy9JO0FBQ0EsbUNBQW1DLGtEQUFrRDtBQUNyRjtBQUNBO0FBQ0EsNkVBQTZFLFlBQVk7QUFDekYsMkNBQTJDLFNBQVMsRUFBRSxnQkFBZ0IsRUFBRSxtQkFBbUI7QUFDM0Ysb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJEQUFjO0FBQ2xDLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1KQUFtSjtBQUNuSiwwREFBMEQsb0JBQW9CO0FBQzlFO0FBQ0E7QUFDQSxrQ0FBa0MsK0NBQUcsZ0JBQWdCLFNBQVMsR0FBRyxXQUFXLEdBQUcsTUFBTSxFQUFFLFlBQVk7QUFDbkc7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0Esb0JBQW9CLDJEQUFjO0FBQ2xDLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLCtDQUFHLGdCQUFnQixTQUFTLGVBQWUsTUFBTTtBQUNwRjtBQUNBLGlCQUFpQjtBQUNqQix5QkFBeUIsTUFBTSw4REFBZ0I7QUFDL0M7QUFDQTtBQUNBLG9CQUFvQiwyREFBYztBQUNsQyw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnREFBSSxnQkFBZ0IsU0FBUyxVQUFVLE1BQU07QUFDbkU7QUFDQSxpQkFBaUI7QUFDakIseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxvQkFBb0IsMkRBQWMsNEJBQTRCLDREQUFtQjtBQUNqRjtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtEQUFrRDtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrSUFBK0k7QUFDL0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixZQUFZO0FBQzFDO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCLFNBQVMsR0FBRyxXQUFXLFVBQVUsTUFBTSxFQUFFLFlBQVksSUFBSTtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxrREFBTSxnQkFBZ0IsU0FBUyxVQUFVLGNBQWMsS0FBSyxpQkFBaUIsSUFBSSx1QkFBdUI7QUFDM0kseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxvQkFBb0IsMkRBQWM7QUFDbEMsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsU0FBUyxZQUFZLEdBQUcsS0FBSyx1QkFBdUI7QUFDckcsb0JBQW9CO0FBQ3BCLFdBQVc7QUFDWDtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTLFlBQVksR0FBRztBQUN4QyxlQUFlLFNBQVM7QUFDeEIsZUFBZTtBQUNmO0FBQ0Esb0JBQW9CO0FBQ3BCLFdBQVc7QUFDWDtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLHVDQUF1QyxvQkFBb0I7QUFDcEksbUNBQW1DLGdEQUFJLGdCQUFnQixTQUFTLGVBQWUsY0FBYyxXQUFXLHVCQUF1QjtBQUMvSCx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLG9CQUFvQiwyREFBYztBQUNsQyw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsTUFBTTtBQUN6QixtQkFBbUIsTUFBTTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjLEdBQUcsS0FBSztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBLGtDQUFrQyxpQkFBaUI7QUFDbkQ7QUFDQTtBQUNBLGtDQUFrQyxpQkFBaUI7QUFDbkQ7QUFDQTtBQUNBLGtDQUFrQyxpQkFBaUI7QUFDbkQ7QUFDQTtBQUNBLG1DQUFtQyxrQkFBa0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvV29uZGVyVml0ZS1mcm9udGVuZC9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvZGlzdC9tb2R1bGUvcGFja2FnZXMvU3RvcmFnZUZpbGVBcGkuanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBpc1N0b3JhZ2VFcnJvciwgU3RvcmFnZUVycm9yLCBTdG9yYWdlVW5rbm93bkVycm9yIH0gZnJvbSAnLi4vbGliL2Vycm9ycyc7XG5pbXBvcnQgeyBnZXQsIGhlYWQsIHBvc3QsIHJlbW92ZSB9IGZyb20gJy4uL2xpYi9mZXRjaCc7XG5pbXBvcnQgeyByZWN1cnNpdmVUb0NhbWVsLCByZXNvbHZlRmV0Y2ggfSBmcm9tICcuLi9saWIvaGVscGVycyc7XG5jb25zdCBERUZBVUxUX1NFQVJDSF9PUFRJT05TID0ge1xuICAgIGxpbWl0OiAxMDAsXG4gICAgb2Zmc2V0OiAwLFxuICAgIHNvcnRCeToge1xuICAgICAgICBjb2x1bW46ICduYW1lJyxcbiAgICAgICAgb3JkZXI6ICdhc2MnLFxuICAgIH0sXG59O1xuY29uc3QgREVGQVVMVF9GSUxFX09QVElPTlMgPSB7XG4gICAgY2FjaGVDb250cm9sOiAnMzYwMCcsXG4gICAgY29udGVudFR5cGU6ICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnLFxuICAgIHVwc2VydDogZmFsc2UsXG59O1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RvcmFnZUZpbGVBcGkge1xuICAgIGNvbnN0cnVjdG9yKHVybCwgaGVhZGVycyA9IHt9LCBidWNrZXRJZCwgZmV0Y2gpIHtcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgICAgIHRoaXMuYnVja2V0SWQgPSBidWNrZXRJZDtcbiAgICAgICAgdGhpcy5mZXRjaCA9IHJlc29sdmVGZXRjaChmZXRjaCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwbG9hZHMgYSBmaWxlIHRvIGFuIGV4aXN0aW5nIGJ1Y2tldCBvciByZXBsYWNlcyBhbiBleGlzdGluZyBmaWxlIGF0IHRoZSBzcGVjaWZpZWQgcGF0aCB3aXRoIGEgbmV3IG9uZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtZXRob2QgSFRUUCBtZXRob2QuXG4gICAgICogQHBhcmFtIHBhdGggVGhlIHJlbGF0aXZlIGZpbGUgcGF0aC4gU2hvdWxkIGJlIG9mIHRoZSBmb3JtYXQgYGZvbGRlci9zdWJmb2xkZXIvZmlsZW5hbWUucG5nYC4gVGhlIGJ1Y2tldCBtdXN0IGFscmVhZHkgZXhpc3QgYmVmb3JlIGF0dGVtcHRpbmcgdG8gdXBsb2FkLlxuICAgICAqIEBwYXJhbSBmaWxlQm9keSBUaGUgYm9keSBvZiB0aGUgZmlsZSB0byBiZSBzdG9yZWQgaW4gdGhlIGJ1Y2tldC5cbiAgICAgKi9cbiAgICB1cGxvYWRPclVwZGF0ZShtZXRob2QsIHBhdGgsIGZpbGVCb2R5LCBmaWxlT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgICAgICAgICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX0ZJTEVfT1BUSU9OUyksIGZpbGVPcHRpb25zKTtcbiAgICAgICAgICAgICAgICBsZXQgaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5oZWFkZXJzKSwgKG1ldGhvZCA9PT0gJ1BPU1QnICYmIHsgJ3gtdXBzZXJ0JzogU3RyaW5nKG9wdGlvbnMudXBzZXJ0KSB9KSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBvcHRpb25zLm1ldGFkYXRhO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcgJiYgZmlsZUJvZHkgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgICAgICAgICAgICAgIGJvZHkgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgYm9keS5hcHBlbmQoJ2NhY2hlQ29udHJvbCcsIG9wdGlvbnMuY2FjaGVDb250cm9sKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5LmFwcGVuZCgnbWV0YWRhdGEnLCB0aGlzLmVuY29kZU1ldGFkYXRhKG1ldGFkYXRhKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYm9keS5hcHBlbmQoJycsIGZpbGVCb2R5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIEZvcm1EYXRhICE9PSAndW5kZWZpbmVkJyAmJiBmaWxlQm9keSBpbnN0YW5jZW9mIEZvcm1EYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGJvZHkgPSBmaWxlQm9keTtcbiAgICAgICAgICAgICAgICAgICAgYm9keS5hcHBlbmQoJ2NhY2hlQ29udHJvbCcsIG9wdGlvbnMuY2FjaGVDb250cm9sKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5LmFwcGVuZCgnbWV0YWRhdGEnLCB0aGlzLmVuY29kZU1ldGFkYXRhKG1ldGFkYXRhKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJvZHkgPSBmaWxlQm9keTtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1snY2FjaGUtY29udHJvbCddID0gYG1heC1hZ2U9JHtvcHRpb25zLmNhY2hlQ29udHJvbH1gO1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzWydjb250ZW50LXR5cGUnXSA9IG9wdGlvbnMuY29udGVudFR5cGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1sneC1tZXRhZGF0YSddID0gdGhpcy50b0Jhc2U2NCh0aGlzLmVuY29kZU1ldGFkYXRhKG1ldGFkYXRhKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZpbGVPcHRpb25zID09PSBudWxsIHx8IGZpbGVPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaWxlT3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGhlYWRlcnMpLCBmaWxlT3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY2xlYW5QYXRoID0gdGhpcy5fcmVtb3ZlRW1wdHlGb2xkZXJzKHBhdGgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IF9wYXRoID0gdGhpcy5fZ2V0RmluYWxQYXRoKGNsZWFuUGF0aCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzID0geWllbGQgdGhpcy5mZXRjaChgJHt0aGlzLnVybH0vb2JqZWN0LyR7X3BhdGh9YCwgT2JqZWN0LmFzc2lnbih7IG1ldGhvZCwgYm9keTogYm9keSwgaGVhZGVycyB9LCAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kdXBsZXgpID8geyBkdXBsZXg6IG9wdGlvbnMuZHVwbGV4IH0gOiB7fSkpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0geWllbGQgcmVzLmpzb24oKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzLm9rKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7IHBhdGg6IGNsZWFuUGF0aCwgaWQ6IGRhdGEuSWQsIGZ1bGxQYXRoOiBkYXRhLktleSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwbG9hZHMgYSBmaWxlIHRvIGFuIGV4aXN0aW5nIGJ1Y2tldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBmaWxlIHBhdGgsIGluY2x1ZGluZyB0aGUgZmlsZSBuYW1lLiBTaG91bGQgYmUgb2YgdGhlIGZvcm1hdCBgZm9sZGVyL3N1YmZvbGRlci9maWxlbmFtZS5wbmdgLiBUaGUgYnVja2V0IG11c3QgYWxyZWFkeSBleGlzdCBiZWZvcmUgYXR0ZW1wdGluZyB0byB1cGxvYWQuXG4gICAgICogQHBhcmFtIGZpbGVCb2R5IFRoZSBib2R5IG9mIHRoZSBmaWxlIHRvIGJlIHN0b3JlZCBpbiB0aGUgYnVja2V0LlxuICAgICAqL1xuICAgIHVwbG9hZChwYXRoLCBmaWxlQm9keSwgZmlsZU9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVwbG9hZE9yVXBkYXRlKCdQT1NUJywgcGF0aCwgZmlsZUJvZHksIGZpbGVPcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwbG9hZCBhIGZpbGUgd2l0aCBhIHRva2VuIGdlbmVyYXRlZCBmcm9tIGBjcmVhdGVTaWduZWRVcGxvYWRVcmxgLlxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBmaWxlIHBhdGgsIGluY2x1ZGluZyB0aGUgZmlsZSBuYW1lLiBTaG91bGQgYmUgb2YgdGhlIGZvcm1hdCBgZm9sZGVyL3N1YmZvbGRlci9maWxlbmFtZS5wbmdgLiBUaGUgYnVja2V0IG11c3QgYWxyZWFkeSBleGlzdCBiZWZvcmUgYXR0ZW1wdGluZyB0byB1cGxvYWQuXG4gICAgICogQHBhcmFtIHRva2VuIFRoZSB0b2tlbiBnZW5lcmF0ZWQgZnJvbSBgY3JlYXRlU2lnbmVkVXBsb2FkVXJsYFxuICAgICAqIEBwYXJhbSBmaWxlQm9keSBUaGUgYm9keSBvZiB0aGUgZmlsZSB0byBiZSBzdG9yZWQgaW4gdGhlIGJ1Y2tldC5cbiAgICAgKi9cbiAgICB1cGxvYWRUb1NpZ25lZFVybChwYXRoLCB0b2tlbiwgZmlsZUJvZHksIGZpbGVPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBjbGVhblBhdGggPSB0aGlzLl9yZW1vdmVFbXB0eUZvbGRlcnMocGF0aCk7XG4gICAgICAgICAgICBjb25zdCBfcGF0aCA9IHRoaXMuX2dldEZpbmFsUGF0aChjbGVhblBhdGgpO1xuICAgICAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTCh0aGlzLnVybCArIGAvb2JqZWN0L3VwbG9hZC9zaWduLyR7X3BhdGh9YCk7XG4gICAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgndG9rZW4nLCB0b2tlbik7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCBib2R5O1xuICAgICAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgdXBzZXJ0OiBERUZBVUxUX0ZJTEVfT1BUSU9OUy51cHNlcnQgfSwgZmlsZU9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuaGVhZGVycyksIHsgJ3gtdXBzZXJ0JzogU3RyaW5nKG9wdGlvbnMudXBzZXJ0KSB9KTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnICYmIGZpbGVCb2R5IGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICAgICAgICAgICAgICBib2R5ID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICAgICAgICAgICAgICAgIGJvZHkuYXBwZW5kKCdjYWNoZUNvbnRyb2wnLCBvcHRpb25zLmNhY2hlQ29udHJvbCk7XG4gICAgICAgICAgICAgICAgICAgIGJvZHkuYXBwZW5kKCcnLCBmaWxlQm9keSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcgJiYgZmlsZUJvZHkgaW5zdGFuY2VvZiBGb3JtRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBib2R5ID0gZmlsZUJvZHk7XG4gICAgICAgICAgICAgICAgICAgIGJvZHkuYXBwZW5kKCdjYWNoZUNvbnRyb2wnLCBvcHRpb25zLmNhY2hlQ29udHJvbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBib2R5ID0gZmlsZUJvZHk7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnNbJ2NhY2hlLWNvbnRyb2wnXSA9IGBtYXgtYWdlPSR7b3B0aW9ucy5jYWNoZUNvbnRyb2x9YDtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1snY29udGVudC10eXBlJ10gPSBvcHRpb25zLmNvbnRlbnRUeXBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXMgPSB5aWVsZCB0aGlzLmZldGNoKHVybC50b1N0cmluZygpLCB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIHJlcy5qc29uKCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlcy5vaykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogeyBwYXRoOiBjbGVhblBhdGgsIGZ1bGxQYXRoOiBkYXRhLktleSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzaWduZWQgdXBsb2FkIFVSTC5cbiAgICAgKiBTaWduZWQgdXBsb2FkIFVSTHMgY2FuIGJlIHVzZWQgdG8gdXBsb2FkIGZpbGVzIHRvIHRoZSBidWNrZXQgd2l0aG91dCBmdXJ0aGVyIGF1dGhlbnRpY2F0aW9uLlxuICAgICAqIFRoZXkgYXJlIHZhbGlkIGZvciAyIGhvdXJzLlxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBmaWxlIHBhdGgsIGluY2x1ZGluZyB0aGUgY3VycmVudCBmaWxlIG5hbWUuIEZvciBleGFtcGxlIGBmb2xkZXIvaW1hZ2UucG5nYC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy51cHNlcnQgSWYgc2V0IHRvIHRydWUsIGFsbG93cyB0aGUgZmlsZSB0byBiZSBvdmVyd3JpdHRlbiBpZiBpdCBhbHJlYWR5IGV4aXN0cy5cbiAgICAgKi9cbiAgICBjcmVhdGVTaWduZWRVcGxvYWRVcmwocGF0aCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgX3BhdGggPSB0aGlzLl9nZXRGaW5hbFBhdGgocGF0aCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuaGVhZGVycyk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy51cHNlcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1sneC11cHNlcnQnXSA9ICd0cnVlJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIHBvc3QodGhpcy5mZXRjaCwgYCR7dGhpcy51cmx9L29iamVjdC91cGxvYWQvc2lnbi8ke19wYXRofWAsIHt9LCB7IGhlYWRlcnMgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTCh0aGlzLnVybCArIGRhdGEudXJsKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0b2tlbiA9IHVybC5zZWFyY2hQYXJhbXMuZ2V0KCd0b2tlbicpO1xuICAgICAgICAgICAgICAgIGlmICghdG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN0b3JhZ2VFcnJvcignTm8gdG9rZW4gcmV0dXJuZWQgYnkgQVBJJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgc2lnbmVkVXJsOiB1cmwudG9TdHJpbmcoKSwgcGF0aCwgdG9rZW4gfSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyBhbiBleGlzdGluZyBmaWxlIGF0IHRoZSBzcGVjaWZpZWQgcGF0aCB3aXRoIGEgbmV3IG9uZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSByZWxhdGl2ZSBmaWxlIHBhdGguIFNob3VsZCBiZSBvZiB0aGUgZm9ybWF0IGBmb2xkZXIvc3ViZm9sZGVyL2ZpbGVuYW1lLnBuZ2AuIFRoZSBidWNrZXQgbXVzdCBhbHJlYWR5IGV4aXN0IGJlZm9yZSBhdHRlbXB0aW5nIHRvIHVwZGF0ZS5cbiAgICAgKiBAcGFyYW0gZmlsZUJvZHkgVGhlIGJvZHkgb2YgdGhlIGZpbGUgdG8gYmUgc3RvcmVkIGluIHRoZSBidWNrZXQuXG4gICAgICovXG4gICAgdXBkYXRlKHBhdGgsIGZpbGVCb2R5LCBmaWxlT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBsb2FkT3JVcGRhdGUoJ1BVVCcsIHBhdGgsIGZpbGVCb2R5LCBmaWxlT3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBhbiBleGlzdGluZyBmaWxlIHRvIGEgbmV3IHBhdGggaW4gdGhlIHNhbWUgYnVja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGZyb21QYXRoIFRoZSBvcmlnaW5hbCBmaWxlIHBhdGgsIGluY2x1ZGluZyB0aGUgY3VycmVudCBmaWxlIG5hbWUuIEZvciBleGFtcGxlIGBmb2xkZXIvaW1hZ2UucG5nYC5cbiAgICAgKiBAcGFyYW0gdG9QYXRoIFRoZSBuZXcgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIG5ldyBmaWxlIG5hbWUuIEZvciBleGFtcGxlIGBmb2xkZXIvaW1hZ2UtbmV3LnBuZ2AuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIGRlc3RpbmF0aW9uIG9wdGlvbnMuXG4gICAgICovXG4gICAgbW92ZShmcm9tUGF0aCwgdG9QYXRoLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB5aWVsZCBwb3N0KHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS9vYmplY3QvbW92ZWAsIHtcbiAgICAgICAgICAgICAgICAgICAgYnVja2V0SWQ6IHRoaXMuYnVja2V0SWQsXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZUtleTogZnJvbVBhdGgsXG4gICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uS2V5OiB0b1BhdGgsXG4gICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uQnVja2V0OiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGVzdGluYXRpb25CdWNrZXQsXG4gICAgICAgICAgICAgICAgfSwgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgYW4gZXhpc3RpbmcgZmlsZSB0byBhIG5ldyBwYXRoIGluIHRoZSBzYW1lIGJ1Y2tldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmcm9tUGF0aCBUaGUgb3JpZ2luYWwgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIGN1cnJlbnQgZmlsZSBuYW1lLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLnBuZ2AuXG4gICAgICogQHBhcmFtIHRvUGF0aCBUaGUgbmV3IGZpbGUgcGF0aCwgaW5jbHVkaW5nIHRoZSBuZXcgZmlsZSBuYW1lLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLWNvcHkucG5nYC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgZGVzdGluYXRpb24gb3B0aW9ucy5cbiAgICAgKi9cbiAgICBjb3B5KGZyb21QYXRoLCB0b1BhdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIHBvc3QodGhpcy5mZXRjaCwgYCR7dGhpcy51cmx9L29iamVjdC9jb3B5YCwge1xuICAgICAgICAgICAgICAgICAgICBidWNrZXRJZDogdGhpcy5idWNrZXRJZCxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlS2V5OiBmcm9tUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb25LZXk6IHRvUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb25CdWNrZXQ6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kZXN0aW5hdGlvbkJ1Y2tldCxcbiAgICAgICAgICAgICAgICB9LCB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHBhdGg6IGRhdGEuS2V5IH0sIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNpZ25lZCBVUkwuIFVzZSBhIHNpZ25lZCBVUkwgdG8gc2hhcmUgYSBmaWxlIGZvciBhIGZpeGVkIGFtb3VudCBvZiB0aW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhdGggVGhlIGZpbGUgcGF0aCwgaW5jbHVkaW5nIHRoZSBjdXJyZW50IGZpbGUgbmFtZS4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS5wbmdgLlxuICAgICAqIEBwYXJhbSBleHBpcmVzSW4gVGhlIG51bWJlciBvZiBzZWNvbmRzIHVudGlsIHRoZSBzaWduZWQgVVJMIGV4cGlyZXMuIEZvciBleGFtcGxlLCBgNjBgIGZvciBhIFVSTCB3aGljaCBpcyB2YWxpZCBmb3Igb25lIG1pbnV0ZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5kb3dubG9hZCB0cmlnZ2VycyB0aGUgZmlsZSBhcyBhIGRvd25sb2FkIGlmIHNldCB0byB0cnVlLiBTZXQgdGhpcyBwYXJhbWV0ZXIgYXMgdGhlIG5hbWUgb2YgdGhlIGZpbGUgaWYgeW91IHdhbnQgdG8gdHJpZ2dlciB0aGUgZG93bmxvYWQgd2l0aCBhIGRpZmZlcmVudCBmaWxlbmFtZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy50cmFuc2Zvcm0gVHJhbnNmb3JtIHRoZSBhc3NldCBiZWZvcmUgc2VydmluZyBpdCB0byB0aGUgY2xpZW50LlxuICAgICAqL1xuICAgIGNyZWF0ZVNpZ25lZFVybChwYXRoLCBleHBpcmVzSW4sIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IF9wYXRoID0gdGhpcy5fZ2V0RmluYWxQYXRoKHBhdGgpO1xuICAgICAgICAgICAgICAgIGxldCBkYXRhID0geWllbGQgcG9zdCh0aGlzLmZldGNoLCBgJHt0aGlzLnVybH0vb2JqZWN0L3NpZ24vJHtfcGF0aH1gLCBPYmplY3QuYXNzaWduKHsgZXhwaXJlc0luIH0sICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRyYW5zZm9ybSkgPyB7IHRyYW5zZm9ybTogb3B0aW9ucy50cmFuc2Zvcm0gfSA6IHt9KSksIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRvd25sb2FkUXVlcnlQYXJhbSA9IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZG93bmxvYWQpXG4gICAgICAgICAgICAgICAgICAgID8gYCZkb3dubG9hZD0ke29wdGlvbnMuZG93bmxvYWQgPT09IHRydWUgPyAnJyA6IG9wdGlvbnMuZG93bmxvYWR9YFxuICAgICAgICAgICAgICAgICAgICA6ICcnO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25lZFVybCA9IGVuY29kZVVSSShgJHt0aGlzLnVybH0ke2RhdGEuc2lnbmVkVVJMfSR7ZG93bmxvYWRRdWVyeVBhcmFtfWApO1xuICAgICAgICAgICAgICAgIGRhdGEgPSB7IHNpZ25lZFVybCB9O1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBtdWx0aXBsZSBzaWduZWQgVVJMcy4gVXNlIGEgc2lnbmVkIFVSTCB0byBzaGFyZSBhIGZpbGUgZm9yIGEgZml4ZWQgYW1vdW50IG9mIHRpbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0aHMgVGhlIGZpbGUgcGF0aHMgdG8gYmUgZG93bmxvYWRlZCwgaW5jbHVkaW5nIHRoZSBjdXJyZW50IGZpbGUgbmFtZXMuIEZvciBleGFtcGxlIGBbJ2ZvbGRlci9pbWFnZS5wbmcnLCAnZm9sZGVyMi9pbWFnZTIucG5nJ11gLlxuICAgICAqIEBwYXJhbSBleHBpcmVzSW4gVGhlIG51bWJlciBvZiBzZWNvbmRzIHVudGlsIHRoZSBzaWduZWQgVVJMcyBleHBpcmUuIEZvciBleGFtcGxlLCBgNjBgIGZvciBVUkxzIHdoaWNoIGFyZSB2YWxpZCBmb3Igb25lIG1pbnV0ZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5kb3dubG9hZCB0cmlnZ2VycyB0aGUgZmlsZSBhcyBhIGRvd25sb2FkIGlmIHNldCB0byB0cnVlLiBTZXQgdGhpcyBwYXJhbWV0ZXIgYXMgdGhlIG5hbWUgb2YgdGhlIGZpbGUgaWYgeW91IHdhbnQgdG8gdHJpZ2dlciB0aGUgZG93bmxvYWQgd2l0aCBhIGRpZmZlcmVudCBmaWxlbmFtZS5cbiAgICAgKi9cbiAgICBjcmVhdGVTaWduZWRVcmxzKHBhdGhzLCBleHBpcmVzSW4sIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIHBvc3QodGhpcy5mZXRjaCwgYCR7dGhpcy51cmx9L29iamVjdC9zaWduLyR7dGhpcy5idWNrZXRJZH1gLCB7IGV4cGlyZXNJbiwgcGF0aHMgfSwgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZG93bmxvYWRRdWVyeVBhcmFtID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kb3dubG9hZClcbiAgICAgICAgICAgICAgICAgICAgPyBgJmRvd25sb2FkPSR7b3B0aW9ucy5kb3dubG9hZCA9PT0gdHJ1ZSA/ICcnIDogb3B0aW9ucy5kb3dubG9hZH1gXG4gICAgICAgICAgICAgICAgICAgIDogJyc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YS5tYXAoKGRhdHVtKSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkYXR1bSksIHsgc2lnbmVkVXJsOiBkYXR1bS5zaWduZWRVUkxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGVuY29kZVVSSShgJHt0aGlzLnVybH0ke2RhdHVtLnNpZ25lZFVSTH0ke2Rvd25sb2FkUXVlcnlQYXJhbX1gKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbCB9KSkpLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERvd25sb2FkcyBhIGZpbGUgZnJvbSBhIHByaXZhdGUgYnVja2V0LiBGb3IgcHVibGljIGJ1Y2tldHMsIG1ha2UgYSByZXF1ZXN0IHRvIHRoZSBVUkwgcmV0dXJuZWQgZnJvbSBgZ2V0UHVibGljVXJsYCBpbnN0ZWFkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhdGggVGhlIGZ1bGwgcGF0aCBhbmQgZmlsZSBuYW1lIG9mIHRoZSBmaWxlIHRvIGJlIGRvd25sb2FkZWQuIEZvciBleGFtcGxlIGBmb2xkZXIvaW1hZ2UucG5nYC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy50cmFuc2Zvcm0gVHJhbnNmb3JtIHRoZSBhc3NldCBiZWZvcmUgc2VydmluZyBpdCB0byB0aGUgY2xpZW50LlxuICAgICAqL1xuICAgIGRvd25sb2FkKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHdhbnRzVHJhbnNmb3JtYXRpb24gPSB0eXBlb2YgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50cmFuc2Zvcm0pICE9PSAndW5kZWZpbmVkJztcbiAgICAgICAgICAgIGNvbnN0IHJlbmRlclBhdGggPSB3YW50c1RyYW5zZm9ybWF0aW9uID8gJ3JlbmRlci9pbWFnZS9hdXRoZW50aWNhdGVkJyA6ICdvYmplY3QnO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtYXRpb25RdWVyeSA9IHRoaXMudHJhbnNmb3JtT3B0c1RvUXVlcnlTdHJpbmcoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50cmFuc2Zvcm0pIHx8IHt9KTtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5U3RyaW5nID0gdHJhbnNmb3JtYXRpb25RdWVyeSA/IGA/JHt0cmFuc2Zvcm1hdGlvblF1ZXJ5fWAgOiAnJztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgX3BhdGggPSB0aGlzLl9nZXRGaW5hbFBhdGgocGF0aCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzID0geWllbGQgZ2V0KHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS8ke3JlbmRlclBhdGh9LyR7X3BhdGh9JHtxdWVyeVN0cmluZ31gLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgbm9SZXNvbHZlSnNvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0geWllbGQgcmVzLmJsb2IoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgZGV0YWlscyBvZiBhbiBleGlzdGluZyBmaWxlLlxuICAgICAqIEBwYXJhbSBwYXRoXG4gICAgICovXG4gICAgaW5mbyhwYXRoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBfcGF0aCA9IHRoaXMuX2dldEZpbmFsUGF0aChwYXRoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIGdldCh0aGlzLmZldGNoLCBgJHt0aGlzLnVybH0vb2JqZWN0L2luZm8vJHtfcGF0aH1gLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiByZWN1cnNpdmVUb0NhbWVsKGRhdGEpLCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyB0aGUgZXhpc3RlbmNlIG9mIGEgZmlsZS5cbiAgICAgKiBAcGFyYW0gcGF0aFxuICAgICAqL1xuICAgIGV4aXN0cyhwYXRoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBfcGF0aCA9IHRoaXMuX2dldEZpbmFsUGF0aChwYXRoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgeWllbGQgaGVhZCh0aGlzLmZldGNoLCBgJHt0aGlzLnVybH0vb2JqZWN0LyR7X3BhdGh9YCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogdHJ1ZSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikgJiYgZXJyb3IgaW5zdGFuY2VvZiBTdG9yYWdlVW5rbm93bkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsRXJyb3IgPSBlcnJvci5vcmlnaW5hbEVycm9yO1xuICAgICAgICAgICAgICAgICAgICBpZiAoWzQwMCwgNDA0XS5pbmNsdWRlcyhvcmlnaW5hbEVycm9yID09PSBudWxsIHx8IG9yaWdpbmFsRXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsRXJyb3Iuc3RhdHVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogZmFsc2UsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIHNpbXBsZSBjb252ZW5pZW5jZSBmdW5jdGlvbiB0byBnZXQgdGhlIFVSTCBmb3IgYW4gYXNzZXQgaW4gYSBwdWJsaWMgYnVja2V0LiBJZiB5b3UgZG8gbm90IHdhbnQgdG8gdXNlIHRoaXMgZnVuY3Rpb24sIHlvdSBjYW4gY29uc3RydWN0IHRoZSBwdWJsaWMgVVJMIGJ5IGNvbmNhdGVuYXRpbmcgdGhlIGJ1Y2tldCBVUkwgd2l0aCB0aGUgcGF0aCB0byB0aGUgYXNzZXQuXG4gICAgICogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCB2ZXJpZnkgaWYgdGhlIGJ1Y2tldCBpcyBwdWJsaWMuIElmIGEgcHVibGljIFVSTCBpcyBjcmVhdGVkIGZvciBhIGJ1Y2tldCB3aGljaCBpcyBub3QgcHVibGljLCB5b3Ugd2lsbCBub3QgYmUgYWJsZSB0byBkb3dubG9hZCB0aGUgYXNzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCBhbmQgbmFtZSBvZiB0aGUgZmlsZSB0byBnZW5lcmF0ZSB0aGUgcHVibGljIFVSTCBmb3IuIEZvciBleGFtcGxlIGBmb2xkZXIvaW1hZ2UucG5nYC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5kb3dubG9hZCBUcmlnZ2VycyB0aGUgZmlsZSBhcyBhIGRvd25sb2FkIGlmIHNldCB0byB0cnVlLiBTZXQgdGhpcyBwYXJhbWV0ZXIgYXMgdGhlIG5hbWUgb2YgdGhlIGZpbGUgaWYgeW91IHdhbnQgdG8gdHJpZ2dlciB0aGUgZG93bmxvYWQgd2l0aCBhIGRpZmZlcmVudCBmaWxlbmFtZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy50cmFuc2Zvcm0gVHJhbnNmb3JtIHRoZSBhc3NldCBiZWZvcmUgc2VydmluZyBpdCB0byB0aGUgY2xpZW50LlxuICAgICAqL1xuICAgIGdldFB1YmxpY1VybChwYXRoLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IF9wYXRoID0gdGhpcy5fZ2V0RmluYWxQYXRoKHBhdGgpO1xuICAgICAgICBjb25zdCBfcXVlcnlTdHJpbmcgPSBbXTtcbiAgICAgICAgY29uc3QgZG93bmxvYWRRdWVyeVBhcmFtID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kb3dubG9hZClcbiAgICAgICAgICAgID8gYGRvd25sb2FkPSR7b3B0aW9ucy5kb3dubG9hZCA9PT0gdHJ1ZSA/ICcnIDogb3B0aW9ucy5kb3dubG9hZH1gXG4gICAgICAgICAgICA6ICcnO1xuICAgICAgICBpZiAoZG93bmxvYWRRdWVyeVBhcmFtICE9PSAnJykge1xuICAgICAgICAgICAgX3F1ZXJ5U3RyaW5nLnB1c2goZG93bmxvYWRRdWVyeVBhcmFtKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3YW50c1RyYW5zZm9ybWF0aW9uID0gdHlwZW9mIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhbnNmb3JtKSAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGNvbnN0IHJlbmRlclBhdGggPSB3YW50c1RyYW5zZm9ybWF0aW9uID8gJ3JlbmRlci9pbWFnZScgOiAnb2JqZWN0JztcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtYXRpb25RdWVyeSA9IHRoaXMudHJhbnNmb3JtT3B0c1RvUXVlcnlTdHJpbmcoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50cmFuc2Zvcm0pIHx8IHt9KTtcbiAgICAgICAgaWYgKHRyYW5zZm9ybWF0aW9uUXVlcnkgIT09ICcnKSB7XG4gICAgICAgICAgICBfcXVlcnlTdHJpbmcucHVzaCh0cmFuc2Zvcm1hdGlvblF1ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcXVlcnlTdHJpbmcgPSBfcXVlcnlTdHJpbmcuam9pbignJicpO1xuICAgICAgICBpZiAocXVlcnlTdHJpbmcgIT09ICcnKSB7XG4gICAgICAgICAgICBxdWVyeVN0cmluZyA9IGA/JHtxdWVyeVN0cmluZ31gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiB7IHB1YmxpY1VybDogZW5jb2RlVVJJKGAke3RoaXMudXJsfS8ke3JlbmRlclBhdGh9L3B1YmxpYy8ke19wYXRofSR7cXVlcnlTdHJpbmd9YCkgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBmaWxlcyB3aXRoaW4gdGhlIHNhbWUgYnVja2V0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0aHMgQW4gYXJyYXkgb2YgZmlsZXMgdG8gZGVsZXRlLCBpbmNsdWRpbmcgdGhlIHBhdGggYW5kIGZpbGUgbmFtZS4gRm9yIGV4YW1wbGUgW2AnZm9sZGVyL2ltYWdlLnBuZydgXS5cbiAgICAgKi9cbiAgICByZW1vdmUocGF0aHMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIHJlbW92ZSh0aGlzLmZldGNoLCBgJHt0aGlzLnVybH0vb2JqZWN0LyR7dGhpcy5idWNrZXRJZH1gLCB7IHByZWZpeGVzOiBwYXRocyB9LCB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBmaWxlIG1ldGFkYXRhXG4gICAgICogQHBhcmFtIGlkIHRoZSBmaWxlIGlkIHRvIHJldHJpZXZlIG1ldGFkYXRhXG4gICAgICovXG4gICAgLy8gYXN5bmMgZ2V0TWV0YWRhdGEoXG4gICAgLy8gICBpZDogc3RyaW5nXG4gICAgLy8gKTogUHJvbWlzZTxcbiAgICAvLyAgIHwge1xuICAgIC8vICAgICAgIGRhdGE6IE1ldGFkYXRhXG4gICAgLy8gICAgICAgZXJyb3I6IG51bGxcbiAgICAvLyAgICAgfVxuICAgIC8vICAgfCB7XG4gICAgLy8gICAgICAgZGF0YTogbnVsbFxuICAgIC8vICAgICAgIGVycm9yOiBTdG9yYWdlRXJyb3JcbiAgICAvLyAgICAgfVxuICAgIC8vID4ge1xuICAgIC8vICAgdHJ5IHtcbiAgICAvLyAgICAgY29uc3QgZGF0YSA9IGF3YWl0IGdldCh0aGlzLmZldGNoLCBgJHt0aGlzLnVybH0vbWV0YWRhdGEvJHtpZH1gLCB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9KVxuICAgIC8vICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9XG4gICAgLy8gICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgLy8gICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgIC8vICAgICB9XG4gICAgLy8gICAgIHRocm93IGVycm9yXG4gICAgLy8gICB9XG4gICAgLy8gfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBmaWxlIG1ldGFkYXRhXG4gICAgICogQHBhcmFtIGlkIHRoZSBmaWxlIGlkIHRvIHVwZGF0ZSBtZXRhZGF0YVxuICAgICAqIEBwYXJhbSBtZXRhIHRoZSBuZXcgZmlsZSBtZXRhZGF0YVxuICAgICAqL1xuICAgIC8vIGFzeW5jIHVwZGF0ZU1ldGFkYXRhKFxuICAgIC8vICAgaWQ6IHN0cmluZyxcbiAgICAvLyAgIG1ldGE6IE1ldGFkYXRhXG4gICAgLy8gKTogUHJvbWlzZTxcbiAgICAvLyAgIHwge1xuICAgIC8vICAgICAgIGRhdGE6IE1ldGFkYXRhXG4gICAgLy8gICAgICAgZXJyb3I6IG51bGxcbiAgICAvLyAgICAgfVxuICAgIC8vICAgfCB7XG4gICAgLy8gICAgICAgZGF0YTogbnVsbFxuICAgIC8vICAgICAgIGVycm9yOiBTdG9yYWdlRXJyb3JcbiAgICAvLyAgICAgfVxuICAgIC8vID4ge1xuICAgIC8vICAgdHJ5IHtcbiAgICAvLyAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHBvc3QoXG4gICAgLy8gICAgICAgdGhpcy5mZXRjaCxcbiAgICAvLyAgICAgICBgJHt0aGlzLnVybH0vbWV0YWRhdGEvJHtpZH1gLFxuICAgIC8vICAgICAgIHsgLi4ubWV0YSB9LFxuICAgIC8vICAgICAgIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH1cbiAgICAvLyAgICAgKVxuICAgIC8vICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9XG4gICAgLy8gICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgLy8gICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgIC8vICAgICB9XG4gICAgLy8gICAgIHRocm93IGVycm9yXG4gICAgLy8gICB9XG4gICAgLy8gfVxuICAgIC8qKlxuICAgICAqIExpc3RzIGFsbCB0aGUgZmlsZXMgd2l0aGluIGEgYnVja2V0LlxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBmb2xkZXIgcGF0aC5cbiAgICAgKi9cbiAgICBsaXN0KHBhdGgsIG9wdGlvbnMsIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYm9keSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFQVJDSF9PUFRJT05TKSwgb3B0aW9ucyksIHsgcHJlZml4OiBwYXRoIHx8ICcnIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB5aWVsZCBwb3N0KHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS9vYmplY3QvbGlzdC8ke3RoaXMuYnVja2V0SWR9YCwgYm9keSwgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfSwgcGFyYW1ldGVycyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbmNvZGVNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEpO1xuICAgIH1cbiAgICB0b0Jhc2U2NChkYXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGRhdGEpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnRvYShkYXRhKTtcbiAgICB9XG4gICAgX2dldEZpbmFsUGF0aChwYXRoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmJ1Y2tldElkfS8ke3BhdGh9YDtcbiAgICB9XG4gICAgX3JlbW92ZUVtcHR5Rm9sZGVycyhwYXRoKSB7XG4gICAgICAgIHJldHVybiBwYXRoLnJlcGxhY2UoL15cXC98XFwvJC9nLCAnJykucmVwbGFjZSgvXFwvKy9nLCAnLycpO1xuICAgIH1cbiAgICB0cmFuc2Zvcm1PcHRzVG9RdWVyeVN0cmluZyh0cmFuc2Zvcm0pIHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gW107XG4gICAgICAgIGlmICh0cmFuc2Zvcm0ud2lkdGgpIHtcbiAgICAgICAgICAgIHBhcmFtcy5wdXNoKGB3aWR0aD0ke3RyYW5zZm9ybS53aWR0aH1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhbnNmb3JtLmhlaWdodCkge1xuICAgICAgICAgICAgcGFyYW1zLnB1c2goYGhlaWdodD0ke3RyYW5zZm9ybS5oZWlnaHR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYW5zZm9ybS5yZXNpemUpIHtcbiAgICAgICAgICAgIHBhcmFtcy5wdXNoKGByZXNpemU9JHt0cmFuc2Zvcm0ucmVzaXplfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFuc2Zvcm0uZm9ybWF0KSB7XG4gICAgICAgICAgICBwYXJhbXMucHVzaChgZm9ybWF0PSR7dHJhbnNmb3JtLmZvcm1hdH1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhbnNmb3JtLnF1YWxpdHkpIHtcbiAgICAgICAgICAgIHBhcmFtcy5wdXNoKGBxdWFsaXR5PSR7dHJhbnNmb3JtLnF1YWxpdHl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmFtcy5qb2luKCcmJyk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3RvcmFnZUZpbGVBcGkuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/packages/StorageFileApi.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/SupabaseClient.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@supabase/supabase-js/dist/module/SupabaseClient.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SupabaseClient)\n/* harmony export */ });\n/* harmony import */ var _supabase_functions_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @supabase/functions-js */ \"(app-pages-browser)/./node_modules/@supabase/functions-js/dist/module/FunctionsClient.js\");\n/* harmony import */ var _supabase_postgrest_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/postgrest-js */ \"(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/esm/wrapper.mjs\");\n/* harmony import */ var _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @supabase/realtime-js */ \"(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/index.js\");\n/* harmony import */ var _supabase_storage_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @supabase/storage-js */ \"(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/StorageClient.js\");\n/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/constants */ \"(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/lib/constants.js\");\n/* harmony import */ var _lib_fetch__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/fetch */ \"(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/lib/fetch.js\");\n/* harmony import */ var _lib_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/helpers */ \"(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/lib/helpers.js\");\n/* harmony import */ var _lib_SupabaseAuthClient__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lib/SupabaseAuthClient */ \"(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/lib/SupabaseAuthClient.js\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\n\n\n/**\n * Supabase Client.\n *\n * An isomorphic Javascript client for interacting with Postgres.\n */\nclass SupabaseClient {\n    /**\n     * Create a new client for use in the browser.\n     * @param supabaseUrl The unique Supabase URL which is supplied when you create a new project in your project dashboard.\n     * @param supabaseKey The unique Supabase Key which is supplied when you create a new project in your project dashboard.\n     * @param options.db.schema You can switch in between schemas. The schema needs to be on the list of exposed schemas inside Supabase.\n     * @param options.auth.autoRefreshToken Set to \"true\" if you want to automatically refresh the token before expiring.\n     * @param options.auth.persistSession Set to \"true\" if you want to automatically save the user session into local storage.\n     * @param options.auth.detectSessionInUrl Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user.\n     * @param options.realtime Options passed along to realtime-js constructor.\n     * @param options.global.fetch A custom fetch implementation.\n     * @param options.global.headers Any additional headers to send with each network request.\n     */\n    constructor(supabaseUrl, supabaseKey, options) {\n        var _a, _b, _c;\n        this.supabaseUrl = supabaseUrl;\n        this.supabaseKey = supabaseKey;\n        if (!supabaseUrl)\n            throw new Error('supabaseUrl is required.');\n        if (!supabaseKey)\n            throw new Error('supabaseKey is required.');\n        const _supabaseUrl = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_2__.stripTrailingSlash)(supabaseUrl);\n        this.realtimeUrl = `${_supabaseUrl}/realtime/v1`.replace(/^http/i, 'ws');\n        this.authUrl = `${_supabaseUrl}/auth/v1`;\n        this.storageUrl = `${_supabaseUrl}/storage/v1`;\n        this.functionsUrl = `${_supabaseUrl}/functions/v1`;\n        // default storage key uses the supabase project ref as a namespace\n        const defaultStorageKey = `sb-${new URL(this.authUrl).hostname.split('.')[0]}-auth-token`;\n        const DEFAULTS = {\n            db: _lib_constants__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_DB_OPTIONS,\n            realtime: _lib_constants__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_REALTIME_OPTIONS,\n            auth: Object.assign(Object.assign({}, _lib_constants__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_AUTH_OPTIONS), { storageKey: defaultStorageKey }),\n            global: _lib_constants__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_GLOBAL_OPTIONS,\n        };\n        const settings = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_2__.applySettingDefaults)(options !== null && options !== void 0 ? options : {}, DEFAULTS);\n        this.storageKey = (_a = settings.auth.storageKey) !== null && _a !== void 0 ? _a : '';\n        this.headers = (_b = settings.global.headers) !== null && _b !== void 0 ? _b : {};\n        if (!settings.accessToken) {\n            this.auth = this._initSupabaseAuthClient((_c = settings.auth) !== null && _c !== void 0 ? _c : {}, this.headers, settings.global.fetch);\n        }\n        else {\n            this.accessToken = settings.accessToken;\n            this.auth = new Proxy({}, {\n                get: (_, prop) => {\n                    throw new Error(`@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(prop)} is not possible`);\n                },\n            });\n        }\n        this.fetch = (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_4__.fetchWithAuth)(supabaseKey, this._getAccessToken.bind(this), settings.global.fetch);\n        this.realtime = this._initRealtimeClient(Object.assign({ headers: this.headers, accessToken: this._getAccessToken.bind(this) }, settings.realtime));\n        this.rest = new _supabase_postgrest_js__WEBPACK_IMPORTED_MODULE_0__.PostgrestClient(`${_supabaseUrl}/rest/v1`, {\n            headers: this.headers,\n            schema: settings.db.schema,\n            fetch: this.fetch,\n        });\n        if (!settings.accessToken) {\n            this._listenForAuthEvents();\n        }\n    }\n    /**\n     * Supabase Functions allows you to deploy and invoke edge functions.\n     */\n    get functions() {\n        return new _supabase_functions_js__WEBPACK_IMPORTED_MODULE_5__.FunctionsClient(this.functionsUrl, {\n            headers: this.headers,\n            customFetch: this.fetch,\n        });\n    }\n    /**\n     * Supabase Storage allows you to manage user-generated content, such as photos or videos.\n     */\n    get storage() {\n        return new _supabase_storage_js__WEBPACK_IMPORTED_MODULE_6__.StorageClient(this.storageUrl, this.headers, this.fetch);\n    }\n    /**\n     * Perform a query on a table or a view.\n     *\n     * @param relation - The table or view name to query\n     */\n    from(relation) {\n        return this.rest.from(relation);\n    }\n    // NOTE: signatures must be kept in sync with PostgrestClient.schema\n    /**\n     * Select a schema to query or perform an function (rpc) call.\n     *\n     * The schema needs to be on the list of exposed schemas inside Supabase.\n     *\n     * @param schema - The schema to query\n     */\n    schema(schema) {\n        return this.rest.schema(schema);\n    }\n    // NOTE: signatures must be kept in sync with PostgrestClient.rpc\n    /**\n     * Perform a function call.\n     *\n     * @param fn - The function name to call\n     * @param args - The arguments to pass to the function call\n     * @param options - Named parameters\n     * @param options.head - When set to `true`, `data` will not be returned.\n     * Useful if you only need the count.\n     * @param options.get - When set to `true`, the function will be called with\n     * read-only access mode.\n     * @param options.count - Count algorithm to use to count rows returned by the\n     * function. Only applicable for [set-returning\n     * functions](https://www.postgresql.org/docs/current/functions-srf.html).\n     *\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n     * hood.\n     *\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n     * statistics under the hood.\n     *\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n     * numbers.\n     */\n    rpc(fn, args = {}, options = {}) {\n        return this.rest.rpc(fn, args, options);\n    }\n    /**\n     * Creates a Realtime channel with Broadcast, Presence, and Postgres Changes.\n     *\n     * @param {string} name - The name of the Realtime channel.\n     * @param {Object} opts - The options to pass to the Realtime channel.\n     *\n     */\n    channel(name, opts = { config: {} }) {\n        return this.realtime.channel(name, opts);\n    }\n    /**\n     * Returns all Realtime channels.\n     */\n    getChannels() {\n        return this.realtime.getChannels();\n    }\n    /**\n     * Unsubscribes and removes Realtime channel from Realtime client.\n     *\n     * @param {RealtimeChannel} channel - The name of the Realtime channel.\n     *\n     */\n    removeChannel(channel) {\n        return this.realtime.removeChannel(channel);\n    }\n    /**\n     * Unsubscribes and removes all Realtime channels from Realtime client.\n     */\n    removeAllChannels() {\n        return this.realtime.removeAllChannels();\n    }\n    _getAccessToken() {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.accessToken) {\n                return yield this.accessToken();\n            }\n            const { data } = yield this.auth.getSession();\n            return (_b = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : null;\n        });\n    }\n    _initSupabaseAuthClient({ autoRefreshToken, persistSession, detectSessionInUrl, storage, storageKey, flowType, lock, debug, }, headers, fetch) {\n        var _a;\n        const authHeaders = {\n            Authorization: `Bearer ${this.supabaseKey}`,\n            apikey: `${this.supabaseKey}`,\n        };\n        return new _lib_SupabaseAuthClient__WEBPACK_IMPORTED_MODULE_7__.SupabaseAuthClient({\n            url: this.authUrl,\n            headers: Object.assign(Object.assign({}, authHeaders), headers),\n            storageKey: storageKey,\n            autoRefreshToken,\n            persistSession,\n            detectSessionInUrl,\n            storage,\n            flowType,\n            lock,\n            debug,\n            fetch,\n            // auth checks if there is a custom authorizaiton header using this flag\n            // so it knows whether to return an error when getUser is called with no session\n            hasCustomAuthorizationHeader: (_a = 'Authorization' in this.headers) !== null && _a !== void 0 ? _a : false,\n        });\n    }\n    _initRealtimeClient(options) {\n        return new _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_1__.RealtimeClient(this.realtimeUrl, Object.assign(Object.assign({}, options), { params: Object.assign({ apikey: this.supabaseKey }, options === null || options === void 0 ? void 0 : options.params) }));\n    }\n    _listenForAuthEvents() {\n        let data = this.auth.onAuthStateChange((event, session) => {\n            this._handleTokenChanged(event, 'CLIENT', session === null || session === void 0 ? void 0 : session.access_token);\n        });\n        return data;\n    }\n    _handleTokenChanged(event, source, token) {\n        if ((event === 'TOKEN_REFRESHED' || event === 'SIGNED_IN') &&\n            this.changedAccessToken !== token) {\n            this.changedAccessToken = token;\n        }\n        else if (event === 'SIGNED_OUT') {\n            this.realtime.setAuth();\n            if (source == 'STORAGE')\n                this.auth.signOut();\n            this.changedAccessToken = undefined;\n        }\n    }\n}\n//# sourceMappingURL=SupabaseClient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3VwYWJhc2UtanMvZGlzdC9tb2R1bGUvU3VwYWJhc2VDbGllbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsaUJBQWlCLFNBQUksSUFBSSxTQUFJO0FBQzdCLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ3lEO0FBQ0M7QUFDRjtBQUNzQjtBQUNnRDtBQUNsRjtBQUM2QjtBQUNYO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZ0VBQWtCO0FBQy9DLDhCQUE4QixhQUFhO0FBQzNDLDBCQUEwQixhQUFhO0FBQ3ZDLDZCQUE2QixhQUFhO0FBQzFDLCtCQUErQixhQUFhO0FBQzVDO0FBQ0Esd0NBQXdDLDZDQUE2QztBQUNyRjtBQUNBLGdCQUFnQiw4REFBa0I7QUFDbEMsc0JBQXNCLG9FQUF3QjtBQUM5QyxnREFBZ0QsRUFBRSxnRUFBb0IsS0FBSywrQkFBK0I7QUFDMUcsb0JBQW9CLGtFQUFzQjtBQUMxQztBQUNBLHlCQUF5QixrRUFBb0Isc0RBQXNEO0FBQ25HO0FBQ0E7QUFDQTtBQUNBLDZHQUE2RztBQUM3RztBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQSxpSkFBaUosY0FBYztBQUMvSixpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0EscUJBQXFCLHlEQUFhO0FBQ2xDLGlFQUFpRSxxRUFBcUU7QUFDdEksd0JBQXdCLG1FQUFlLElBQUksYUFBYTtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtRUFBZTtBQUNsQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsK0RBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsY0FBYztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0EsMkJBQTJCLFlBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBLFNBQVM7QUFDVDtBQUNBLDhCQUE4QixtR0FBbUc7QUFDakk7QUFDQTtBQUNBLHFDQUFxQyxpQkFBaUI7QUFDdEQsdUJBQXVCLGlCQUFpQjtBQUN4QztBQUNBLG1CQUFtQix1RUFBa0I7QUFDckM7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxtQkFBbUIsaUVBQWMsaURBQWlELGNBQWMsd0JBQXdCLDBCQUEwQixxRUFBcUU7QUFDdk47QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL1dvbmRlclZpdGUtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdXBhYmFzZS1qcy9kaXN0L21vZHVsZS9TdXBhYmFzZUNsaWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmltcG9ydCB7IEZ1bmN0aW9uc0NsaWVudCB9IGZyb20gJ0BzdXBhYmFzZS9mdW5jdGlvbnMtanMnO1xuaW1wb3J0IHsgUG9zdGdyZXN0Q2xpZW50LCB9IGZyb20gJ0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMnO1xuaW1wb3J0IHsgUmVhbHRpbWVDbGllbnQsIH0gZnJvbSAnQHN1cGFiYXNlL3JlYWx0aW1lLWpzJztcbmltcG9ydCB7IFN0b3JhZ2VDbGllbnQgYXMgU3VwYWJhc2VTdG9yYWdlQ2xpZW50IH0gZnJvbSAnQHN1cGFiYXNlL3N0b3JhZ2UtanMnO1xuaW1wb3J0IHsgREVGQVVMVF9HTE9CQUxfT1BUSU9OUywgREVGQVVMVF9EQl9PUFRJT05TLCBERUZBVUxUX0FVVEhfT1BUSU9OUywgREVGQVVMVF9SRUFMVElNRV9PUFRJT05TLCB9IGZyb20gJy4vbGliL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBmZXRjaFdpdGhBdXRoIH0gZnJvbSAnLi9saWIvZmV0Y2gnO1xuaW1wb3J0IHsgc3RyaXBUcmFpbGluZ1NsYXNoLCBhcHBseVNldHRpbmdEZWZhdWx0cyB9IGZyb20gJy4vbGliL2hlbHBlcnMnO1xuaW1wb3J0IHsgU3VwYWJhc2VBdXRoQ2xpZW50IH0gZnJvbSAnLi9saWIvU3VwYWJhc2VBdXRoQ2xpZW50Jztcbi8qKlxuICogU3VwYWJhc2UgQ2xpZW50LlxuICpcbiAqIEFuIGlzb21vcnBoaWMgSmF2YXNjcmlwdCBjbGllbnQgZm9yIGludGVyYWN0aW5nIHdpdGggUG9zdGdyZXMuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN1cGFiYXNlQ2xpZW50IHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgY2xpZW50IGZvciB1c2UgaW4gdGhlIGJyb3dzZXIuXG4gICAgICogQHBhcmFtIHN1cGFiYXNlVXJsIFRoZSB1bmlxdWUgU3VwYWJhc2UgVVJMIHdoaWNoIGlzIHN1cHBsaWVkIHdoZW4geW91IGNyZWF0ZSBhIG5ldyBwcm9qZWN0IGluIHlvdXIgcHJvamVjdCBkYXNoYm9hcmQuXG4gICAgICogQHBhcmFtIHN1cGFiYXNlS2V5IFRoZSB1bmlxdWUgU3VwYWJhc2UgS2V5IHdoaWNoIGlzIHN1cHBsaWVkIHdoZW4geW91IGNyZWF0ZSBhIG5ldyBwcm9qZWN0IGluIHlvdXIgcHJvamVjdCBkYXNoYm9hcmQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZGIuc2NoZW1hIFlvdSBjYW4gc3dpdGNoIGluIGJldHdlZW4gc2NoZW1hcy4gVGhlIHNjaGVtYSBuZWVkcyB0byBiZSBvbiB0aGUgbGlzdCBvZiBleHBvc2VkIHNjaGVtYXMgaW5zaWRlIFN1cGFiYXNlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmF1dGguYXV0b1JlZnJlc2hUb2tlbiBTZXQgdG8gXCJ0cnVlXCIgaWYgeW91IHdhbnQgdG8gYXV0b21hdGljYWxseSByZWZyZXNoIHRoZSB0b2tlbiBiZWZvcmUgZXhwaXJpbmcuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYXV0aC5wZXJzaXN0U2Vzc2lvbiBTZXQgdG8gXCJ0cnVlXCIgaWYgeW91IHdhbnQgdG8gYXV0b21hdGljYWxseSBzYXZlIHRoZSB1c2VyIHNlc3Npb24gaW50byBsb2NhbCBzdG9yYWdlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmF1dGguZGV0ZWN0U2Vzc2lvbkluVXJsIFNldCB0byBcInRydWVcIiBpZiB5b3Ugd2FudCB0byBhdXRvbWF0aWNhbGx5IGRldGVjdHMgT0F1dGggZ3JhbnRzIGluIHRoZSBVUkwgYW5kIHNpZ25zIGluIHRoZSB1c2VyLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnJlYWx0aW1lIE9wdGlvbnMgcGFzc2VkIGFsb25nIHRvIHJlYWx0aW1lLWpzIGNvbnN0cnVjdG9yLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmdsb2JhbC5mZXRjaCBBIGN1c3RvbSBmZXRjaCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5nbG9iYWwuaGVhZGVycyBBbnkgYWRkaXRpb25hbCBoZWFkZXJzIHRvIHNlbmQgd2l0aCBlYWNoIG5ldHdvcmsgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzdXBhYmFzZVVybCwgc3VwYWJhc2VLZXksIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHRoaXMuc3VwYWJhc2VVcmwgPSBzdXBhYmFzZVVybDtcbiAgICAgICAgdGhpcy5zdXBhYmFzZUtleSA9IHN1cGFiYXNlS2V5O1xuICAgICAgICBpZiAoIXN1cGFiYXNlVXJsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdXBhYmFzZVVybCBpcyByZXF1aXJlZC4nKTtcbiAgICAgICAgaWYgKCFzdXBhYmFzZUtleSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc3VwYWJhc2VLZXkgaXMgcmVxdWlyZWQuJyk7XG4gICAgICAgIGNvbnN0IF9zdXBhYmFzZVVybCA9IHN0cmlwVHJhaWxpbmdTbGFzaChzdXBhYmFzZVVybCk7XG4gICAgICAgIHRoaXMucmVhbHRpbWVVcmwgPSBgJHtfc3VwYWJhc2VVcmx9L3JlYWx0aW1lL3YxYC5yZXBsYWNlKC9eaHR0cC9pLCAnd3MnKTtcbiAgICAgICAgdGhpcy5hdXRoVXJsID0gYCR7X3N1cGFiYXNlVXJsfS9hdXRoL3YxYDtcbiAgICAgICAgdGhpcy5zdG9yYWdlVXJsID0gYCR7X3N1cGFiYXNlVXJsfS9zdG9yYWdlL3YxYDtcbiAgICAgICAgdGhpcy5mdW5jdGlvbnNVcmwgPSBgJHtfc3VwYWJhc2VVcmx9L2Z1bmN0aW9ucy92MWA7XG4gICAgICAgIC8vIGRlZmF1bHQgc3RvcmFnZSBrZXkgdXNlcyB0aGUgc3VwYWJhc2UgcHJvamVjdCByZWYgYXMgYSBuYW1lc3BhY2VcbiAgICAgICAgY29uc3QgZGVmYXVsdFN0b3JhZ2VLZXkgPSBgc2ItJHtuZXcgVVJMKHRoaXMuYXV0aFVybCkuaG9zdG5hbWUuc3BsaXQoJy4nKVswXX0tYXV0aC10b2tlbmA7XG4gICAgICAgIGNvbnN0IERFRkFVTFRTID0ge1xuICAgICAgICAgICAgZGI6IERFRkFVTFRfREJfT1BUSU9OUyxcbiAgICAgICAgICAgIHJlYWx0aW1lOiBERUZBVUxUX1JFQUxUSU1FX09QVElPTlMsXG4gICAgICAgICAgICBhdXRoOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfQVVUSF9PUFRJT05TKSwgeyBzdG9yYWdlS2V5OiBkZWZhdWx0U3RvcmFnZUtleSB9KSxcbiAgICAgICAgICAgIGdsb2JhbDogREVGQVVMVF9HTE9CQUxfT1BUSU9OUyxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBhcHBseVNldHRpbmdEZWZhdWx0cyhvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fSwgREVGQVVMVFMpO1xuICAgICAgICB0aGlzLnN0b3JhZ2VLZXkgPSAoX2EgPSBzZXR0aW5ncy5hdXRoLnN0b3JhZ2VLZXkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnO1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSAoX2IgPSBzZXR0aW5ncy5nbG9iYWwuaGVhZGVycykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDoge307XG4gICAgICAgIGlmICghc2V0dGluZ3MuYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgICAgIHRoaXMuYXV0aCA9IHRoaXMuX2luaXRTdXBhYmFzZUF1dGhDbGllbnQoKF9jID0gc2V0dGluZ3MuYXV0aCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDoge30sIHRoaXMuaGVhZGVycywgc2V0dGluZ3MuZ2xvYmFsLmZldGNoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWNjZXNzVG9rZW4gPSBzZXR0aW5ncy5hY2Nlc3NUb2tlbjtcbiAgICAgICAgICAgIHRoaXMuYXV0aCA9IG5ldyBQcm94eSh7fSwge1xuICAgICAgICAgICAgICAgIGdldDogKF8sIHByb3ApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBAc3VwYWJhc2Uvc3VwYWJhc2UtanM6IFN1cGFiYXNlIENsaWVudCBpcyBjb25maWd1cmVkIHdpdGggdGhlIGFjY2Vzc1Rva2VuIG9wdGlvbiwgYWNjZXNzaW5nIHN1cGFiYXNlLmF1dGguJHtTdHJpbmcocHJvcCl9IGlzIG5vdCBwb3NzaWJsZWApO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZldGNoID0gZmV0Y2hXaXRoQXV0aChzdXBhYmFzZUtleSwgdGhpcy5fZ2V0QWNjZXNzVG9rZW4uYmluZCh0aGlzKSwgc2V0dGluZ3MuZ2xvYmFsLmZldGNoKTtcbiAgICAgICAgdGhpcy5yZWFsdGltZSA9IHRoaXMuX2luaXRSZWFsdGltZUNsaWVudChPYmplY3QuYXNzaWduKHsgaGVhZGVyczogdGhpcy5oZWFkZXJzLCBhY2Nlc3NUb2tlbjogdGhpcy5fZ2V0QWNjZXNzVG9rZW4uYmluZCh0aGlzKSB9LCBzZXR0aW5ncy5yZWFsdGltZSkpO1xuICAgICAgICB0aGlzLnJlc3QgPSBuZXcgUG9zdGdyZXN0Q2xpZW50KGAke19zdXBhYmFzZVVybH0vcmVzdC92MWAsIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNjaGVtYTogc2V0dGluZ3MuZGIuc2NoZW1hLFxuICAgICAgICAgICAgZmV0Y2g6IHRoaXMuZmV0Y2gsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXNldHRpbmdzLmFjY2Vzc1Rva2VuKSB7XG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5Gb3JBdXRoRXZlbnRzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU3VwYWJhc2UgRnVuY3Rpb25zIGFsbG93cyB5b3UgdG8gZGVwbG95IGFuZCBpbnZva2UgZWRnZSBmdW5jdGlvbnMuXG4gICAgICovXG4gICAgZ2V0IGZ1bmN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbnNDbGllbnQodGhpcy5mdW5jdGlvbnNVcmwsIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIGN1c3RvbUZldGNoOiB0aGlzLmZldGNoLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3VwYWJhc2UgU3RvcmFnZSBhbGxvd3MgeW91IHRvIG1hbmFnZSB1c2VyLWdlbmVyYXRlZCBjb250ZW50LCBzdWNoIGFzIHBob3RvcyBvciB2aWRlb3MuXG4gICAgICovXG4gICAgZ2V0IHN0b3JhZ2UoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3VwYWJhc2VTdG9yYWdlQ2xpZW50KHRoaXMuc3RvcmFnZVVybCwgdGhpcy5oZWFkZXJzLCB0aGlzLmZldGNoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBhIHF1ZXJ5IG9uIGEgdGFibGUgb3IgYSB2aWV3LlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlbGF0aW9uIC0gVGhlIHRhYmxlIG9yIHZpZXcgbmFtZSB0byBxdWVyeVxuICAgICAqL1xuICAgIGZyb20ocmVsYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdC5mcm9tKHJlbGF0aW9uKTtcbiAgICB9XG4gICAgLy8gTk9URTogc2lnbmF0dXJlcyBtdXN0IGJlIGtlcHQgaW4gc3luYyB3aXRoIFBvc3RncmVzdENsaWVudC5zY2hlbWFcbiAgICAvKipcbiAgICAgKiBTZWxlY3QgYSBzY2hlbWEgdG8gcXVlcnkgb3IgcGVyZm9ybSBhbiBmdW5jdGlvbiAocnBjKSBjYWxsLlxuICAgICAqXG4gICAgICogVGhlIHNjaGVtYSBuZWVkcyB0byBiZSBvbiB0aGUgbGlzdCBvZiBleHBvc2VkIHNjaGVtYXMgaW5zaWRlIFN1cGFiYXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNjaGVtYSAtIFRoZSBzY2hlbWEgdG8gcXVlcnlcbiAgICAgKi9cbiAgICBzY2hlbWEoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3Quc2NoZW1hKHNjaGVtYSk7XG4gICAgfVxuICAgIC8vIE5PVEU6IHNpZ25hdHVyZXMgbXVzdCBiZSBrZXB0IGluIHN5bmMgd2l0aCBQb3N0Z3Jlc3RDbGllbnQucnBjXG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBhIGZ1bmN0aW9uIGNhbGwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZm4gLSBUaGUgZnVuY3Rpb24gbmFtZSB0byBjYWxsXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIGZ1bmN0aW9uIGNhbGxcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5oZWFkIC0gV2hlbiBzZXQgdG8gYHRydWVgLCBgZGF0YWAgd2lsbCBub3QgYmUgcmV0dXJuZWQuXG4gICAgICogVXNlZnVsIGlmIHlvdSBvbmx5IG5lZWQgdGhlIGNvdW50LlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmdldCAtIFdoZW4gc2V0IHRvIGB0cnVlYCwgdGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdpdGhcbiAgICAgKiByZWFkLW9ubHkgYWNjZXNzIG1vZGUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuY291bnQgLSBDb3VudCBhbGdvcml0aG0gdG8gdXNlIHRvIGNvdW50IHJvd3MgcmV0dXJuZWQgYnkgdGhlXG4gICAgICogZnVuY3Rpb24uIE9ubHkgYXBwbGljYWJsZSBmb3IgW3NldC1yZXR1cm5pbmdcbiAgICAgKiBmdW5jdGlvbnNdKGh0dHBzOi8vd3d3LnBvc3RncmVzcWwub3JnL2RvY3MvY3VycmVudC9mdW5jdGlvbnMtc3JmLmh0bWwpLlxuICAgICAqXG4gICAgICogYFwiZXhhY3RcImA6IEV4YWN0IGJ1dCBzbG93IGNvdW50IGFsZ29yaXRobS4gUGVyZm9ybXMgYSBgQ09VTlQoKilgIHVuZGVyIHRoZVxuICAgICAqIGhvb2QuXG4gICAgICpcbiAgICAgKiBgXCJwbGFubmVkXCJgOiBBcHByb3hpbWF0ZWQgYnV0IGZhc3QgY291bnQgYWxnb3JpdGhtLiBVc2VzIHRoZSBQb3N0Z3Jlc1xuICAgICAqIHN0YXRpc3RpY3MgdW5kZXIgdGhlIGhvb2QuXG4gICAgICpcbiAgICAgKiBgXCJlc3RpbWF0ZWRcImA6IFVzZXMgZXhhY3QgY291bnQgZm9yIGxvdyBudW1iZXJzIGFuZCBwbGFubmVkIGNvdW50IGZvciBoaWdoXG4gICAgICogbnVtYmVycy5cbiAgICAgKi9cbiAgICBycGMoZm4sIGFyZ3MgPSB7fSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3QucnBjKGZuLCBhcmdzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFJlYWx0aW1lIGNoYW5uZWwgd2l0aCBCcm9hZGNhc3QsIFByZXNlbmNlLCBhbmQgUG9zdGdyZXMgQ2hhbmdlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIFJlYWx0aW1lIGNoYW5uZWwuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBUaGUgb3B0aW9ucyB0byBwYXNzIHRvIHRoZSBSZWFsdGltZSBjaGFubmVsLlxuICAgICAqXG4gICAgICovXG4gICAgY2hhbm5lbChuYW1lLCBvcHRzID0geyBjb25maWc6IHt9IH0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhbHRpbWUuY2hhbm5lbChuYW1lLCBvcHRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgUmVhbHRpbWUgY2hhbm5lbHMuXG4gICAgICovXG4gICAgZ2V0Q2hhbm5lbHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWx0aW1lLmdldENoYW5uZWxzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVuc3Vic2NyaWJlcyBhbmQgcmVtb3ZlcyBSZWFsdGltZSBjaGFubmVsIGZyb20gUmVhbHRpbWUgY2xpZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFsdGltZUNoYW5uZWx9IGNoYW5uZWwgLSBUaGUgbmFtZSBvZiB0aGUgUmVhbHRpbWUgY2hhbm5lbC5cbiAgICAgKlxuICAgICAqL1xuICAgIHJlbW92ZUNoYW5uZWwoY2hhbm5lbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFsdGltZS5yZW1vdmVDaGFubmVsKGNoYW5uZWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbnN1YnNjcmliZXMgYW5kIHJlbW92ZXMgYWxsIFJlYWx0aW1lIGNoYW5uZWxzIGZyb20gUmVhbHRpbWUgY2xpZW50LlxuICAgICAqL1xuICAgIHJlbW92ZUFsbENoYW5uZWxzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFsdGltZS5yZW1vdmVBbGxDaGFubmVscygpO1xuICAgIH1cbiAgICBfZ2V0QWNjZXNzVG9rZW4oKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hY2Nlc3NUb2tlbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmFjY2Vzc1Rva2VuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IGRhdGEgfSA9IHlpZWxkIHRoaXMuYXV0aC5nZXRTZXNzaW9uKCk7XG4gICAgICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gZGF0YS5zZXNzaW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWNjZXNzX3Rva2VuKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBudWxsO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2luaXRTdXBhYmFzZUF1dGhDbGllbnQoeyBhdXRvUmVmcmVzaFRva2VuLCBwZXJzaXN0U2Vzc2lvbiwgZGV0ZWN0U2Vzc2lvbkluVXJsLCBzdG9yYWdlLCBzdG9yYWdlS2V5LCBmbG93VHlwZSwgbG9jaywgZGVidWcsIH0sIGhlYWRlcnMsIGZldGNoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgYXV0aEhlYWRlcnMgPSB7XG4gICAgICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dGhpcy5zdXBhYmFzZUtleX1gLFxuICAgICAgICAgICAgYXBpa2V5OiBgJHt0aGlzLnN1cGFiYXNlS2V5fWAsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXcgU3VwYWJhc2VBdXRoQ2xpZW50KHtcbiAgICAgICAgICAgIHVybDogdGhpcy5hdXRoVXJsLFxuICAgICAgICAgICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhdXRoSGVhZGVycyksIGhlYWRlcnMpLFxuICAgICAgICAgICAgc3RvcmFnZUtleTogc3RvcmFnZUtleSxcbiAgICAgICAgICAgIGF1dG9SZWZyZXNoVG9rZW4sXG4gICAgICAgICAgICBwZXJzaXN0U2Vzc2lvbixcbiAgICAgICAgICAgIGRldGVjdFNlc3Npb25JblVybCxcbiAgICAgICAgICAgIHN0b3JhZ2UsXG4gICAgICAgICAgICBmbG93VHlwZSxcbiAgICAgICAgICAgIGxvY2ssXG4gICAgICAgICAgICBkZWJ1ZyxcbiAgICAgICAgICAgIGZldGNoLFxuICAgICAgICAgICAgLy8gYXV0aCBjaGVja3MgaWYgdGhlcmUgaXMgYSBjdXN0b20gYXV0aG9yaXphaXRvbiBoZWFkZXIgdXNpbmcgdGhpcyBmbGFnXG4gICAgICAgICAgICAvLyBzbyBpdCBrbm93cyB3aGV0aGVyIHRvIHJldHVybiBhbiBlcnJvciB3aGVuIGdldFVzZXIgaXMgY2FsbGVkIHdpdGggbm8gc2Vzc2lvblxuICAgICAgICAgICAgaGFzQ3VzdG9tQXV0aG9yaXphdGlvbkhlYWRlcjogKF9hID0gJ0F1dGhvcml6YXRpb24nIGluIHRoaXMuaGVhZGVycykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfaW5pdFJlYWx0aW1lQ2xpZW50KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWFsdGltZUNsaWVudCh0aGlzLnJlYWx0aW1lVXJsLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7IHBhcmFtczogT2JqZWN0LmFzc2lnbih7IGFwaWtleTogdGhpcy5zdXBhYmFzZUtleSB9LCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucGFyYW1zKSB9KSk7XG4gICAgfVxuICAgIF9saXN0ZW5Gb3JBdXRoRXZlbnRzKCkge1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuYXV0aC5vbkF1dGhTdGF0ZUNoYW5nZSgoZXZlbnQsIHNlc3Npb24pID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZVRva2VuQ2hhbmdlZChldmVudCwgJ0NMSUVOVCcsIHNlc3Npb24gPT09IG51bGwgfHwgc2Vzc2lvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2Vzc2lvbi5hY2Nlc3NfdG9rZW4pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIF9oYW5kbGVUb2tlbkNoYW5nZWQoZXZlbnQsIHNvdXJjZSwgdG9rZW4pIHtcbiAgICAgICAgaWYgKChldmVudCA9PT0gJ1RPS0VOX1JFRlJFU0hFRCcgfHwgZXZlbnQgPT09ICdTSUdORURfSU4nKSAmJlxuICAgICAgICAgICAgdGhpcy5jaGFuZ2VkQWNjZXNzVG9rZW4gIT09IHRva2VuKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZWRBY2Nlc3NUb2tlbiA9IHRva2VuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2ZW50ID09PSAnU0lHTkVEX09VVCcpIHtcbiAgICAgICAgICAgIHRoaXMucmVhbHRpbWUuc2V0QXV0aCgpO1xuICAgICAgICAgICAgaWYgKHNvdXJjZSA9PSAnU1RPUkFHRScpXG4gICAgICAgICAgICAgICAgdGhpcy5hdXRoLnNpZ25PdXQoKTtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlZEFjY2Vzc1Rva2VuID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3VwYWJhc2VDbGllbnQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/SupabaseClient.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@supabase/supabase-js/dist/module/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthAdminApi: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthAdminApi),\n/* harmony export */   AuthApiError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthApiError),\n/* harmony export */   AuthClient: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthClient),\n/* harmony export */   AuthError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthError),\n/* harmony export */   AuthImplicitGrantRedirectError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthImplicitGrantRedirectError),\n/* harmony export */   AuthInvalidCredentialsError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthInvalidCredentialsError),\n/* harmony export */   AuthInvalidTokenResponseError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthInvalidTokenResponseError),\n/* harmony export */   AuthPKCEGrantCodeExchangeError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthPKCEGrantCodeExchangeError),\n/* harmony export */   AuthRetryableFetchError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthRetryableFetchError),\n/* harmony export */   AuthSessionMissingError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthSessionMissingError),\n/* harmony export */   AuthUnknownError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthUnknownError),\n/* harmony export */   AuthWeakPasswordError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthWeakPasswordError),\n/* harmony export */   CustomAuthError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.CustomAuthError),\n/* harmony export */   FunctionRegion: () => (/* reexport safe */ _supabase_functions_js__WEBPACK_IMPORTED_MODULE_1__.FunctionRegion),\n/* harmony export */   FunctionsError: () => (/* reexport safe */ _supabase_functions_js__WEBPACK_IMPORTED_MODULE_1__.FunctionsError),\n/* harmony export */   FunctionsFetchError: () => (/* reexport safe */ _supabase_functions_js__WEBPACK_IMPORTED_MODULE_1__.FunctionsFetchError),\n/* harmony export */   FunctionsHttpError: () => (/* reexport safe */ _supabase_functions_js__WEBPACK_IMPORTED_MODULE_1__.FunctionsHttpError),\n/* harmony export */   FunctionsRelayError: () => (/* reexport safe */ _supabase_functions_js__WEBPACK_IMPORTED_MODULE_1__.FunctionsRelayError),\n/* harmony export */   GoTrueAdminApi: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.GoTrueAdminApi),\n/* harmony export */   GoTrueClient: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.GoTrueClient),\n/* harmony export */   NavigatorLockAcquireTimeoutError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.NavigatorLockAcquireTimeoutError),\n/* harmony export */   REALTIME_CHANNEL_STATES: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_2__.REALTIME_CHANNEL_STATES),\n/* harmony export */   REALTIME_LISTEN_TYPES: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_2__.REALTIME_LISTEN_TYPES),\n/* harmony export */   REALTIME_POSTGRES_CHANGES_LISTEN_EVENT: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_2__.REALTIME_POSTGRES_CHANGES_LISTEN_EVENT),\n/* harmony export */   REALTIME_PRESENCE_LISTEN_EVENTS: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_2__.REALTIME_PRESENCE_LISTEN_EVENTS),\n/* harmony export */   REALTIME_SUBSCRIBE_STATES: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_2__.REALTIME_SUBSCRIBE_STATES),\n/* harmony export */   RealtimeChannel: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_2__.RealtimeChannel),\n/* harmony export */   RealtimeClient: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_2__.RealtimeClient),\n/* harmony export */   RealtimePresence: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_2__.RealtimePresence),\n/* harmony export */   SupabaseClient: () => (/* reexport safe */ _SupabaseClient__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   createClient: () => (/* binding */ createClient),\n/* harmony export */   isAuthApiError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.isAuthApiError),\n/* harmony export */   isAuthError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.isAuthError),\n/* harmony export */   isAuthImplicitGrantRedirectError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.isAuthImplicitGrantRedirectError),\n/* harmony export */   isAuthRetryableFetchError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.isAuthRetryableFetchError),\n/* harmony export */   isAuthSessionMissingError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.isAuthSessionMissingError),\n/* harmony export */   isAuthWeakPasswordError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.isAuthWeakPasswordError),\n/* harmony export */   lockInternals: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.lockInternals),\n/* harmony export */   navigatorLock: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.navigatorLock)\n/* harmony export */ });\n/* harmony import */ var _SupabaseClient__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SupabaseClient */ \"(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/SupabaseClient.js\");\n/* harmony import */ var _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/auth-js */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/index.js\");\n/* harmony import */ var _supabase_functions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @supabase/functions-js */ \"(app-pages-browser)/./node_modules/@supabase/functions-js/dist/module/types.js\");\n/* harmony import */ var _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @supabase/realtime-js */ \"(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/index.js\");\n\n\n\n\n\n/**\n * Creates a new Supabase Client.\n */\nconst createClient = (supabaseUrl, supabaseKey, options) => {\n    return new _SupabaseClient__WEBPACK_IMPORTED_MODULE_3__[\"default\"](supabaseUrl, supabaseKey, options);\n};\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3VwYWJhc2UtanMvZGlzdC9tb2R1bGUvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE4QztBQUNaO0FBQ3FHO0FBQ2pHO0FBQ3VCO0FBQzdEO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsZUFBZSx1REFBYztBQUM3QjtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvd29uZGVybGFuZG1pdGNoL0Nhc2NhZGVQcm9qZWN0cy9Xb25kZXJWaXRlLWZyb250ZW5kL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3VwYWJhc2UtanMvZGlzdC9tb2R1bGUvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFN1cGFiYXNlQ2xpZW50IGZyb20gJy4vU3VwYWJhc2VDbGllbnQnO1xuZXhwb3J0ICogZnJvbSAnQHN1cGFiYXNlL2F1dGgtanMnO1xuZXhwb3J0IHsgRnVuY3Rpb25zSHR0cEVycm9yLCBGdW5jdGlvbnNGZXRjaEVycm9yLCBGdW5jdGlvbnNSZWxheUVycm9yLCBGdW5jdGlvbnNFcnJvciwgRnVuY3Rpb25SZWdpb24sIH0gZnJvbSAnQHN1cGFiYXNlL2Z1bmN0aW9ucy1qcyc7XG5leHBvcnQgKiBmcm9tICdAc3VwYWJhc2UvcmVhbHRpbWUtanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTdXBhYmFzZUNsaWVudCB9IGZyb20gJy4vU3VwYWJhc2VDbGllbnQnO1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFN1cGFiYXNlIENsaWVudC5cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUNsaWVudCA9IChzdXBhYmFzZVVybCwgc3VwYWJhc2VLZXksIG9wdGlvbnMpID0+IHtcbiAgICByZXR1cm4gbmV3IFN1cGFiYXNlQ2xpZW50KHN1cGFiYXNlVXJsLCBzdXBhYmFzZUtleSwgb3B0aW9ucyk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/lib/SupabaseAuthClient.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@supabase/supabase-js/dist/module/lib/SupabaseAuthClient.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SupabaseAuthClient: () => (/* binding */ SupabaseAuthClient)\n/* harmony export */ });\n/* harmony import */ var _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/auth-js */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/index.js\");\n\nclass SupabaseAuthClient extends _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthClient {\n    constructor(options) {\n        super(options);\n    }\n}\n//# sourceMappingURL=SupabaseAuthClient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3VwYWJhc2UtanMvZGlzdC9tb2R1bGUvbGliL1N1cGFiYXNlQXV0aENsaWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUErQztBQUN4QyxpQ0FBaUMseURBQVU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvV29uZGVyVml0ZS1mcm9udGVuZC9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N1cGFiYXNlLWpzL2Rpc3QvbW9kdWxlL2xpYi9TdXBhYmFzZUF1dGhDbGllbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXV0aENsaWVudCB9IGZyb20gJ0BzdXBhYmFzZS9hdXRoLWpzJztcbmV4cG9ydCBjbGFzcyBTdXBhYmFzZUF1dGhDbGllbnQgZXh0ZW5kcyBBdXRoQ2xpZW50IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN1cGFiYXNlQXV0aENsaWVudC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/lib/SupabaseAuthClient.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/lib/constants.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@supabase/supabase-js/dist/module/lib/constants.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_AUTH_OPTIONS: () => (/* binding */ DEFAULT_AUTH_OPTIONS),\n/* harmony export */   DEFAULT_DB_OPTIONS: () => (/* binding */ DEFAULT_DB_OPTIONS),\n/* harmony export */   DEFAULT_GLOBAL_OPTIONS: () => (/* binding */ DEFAULT_GLOBAL_OPTIONS),\n/* harmony export */   DEFAULT_HEADERS: () => (/* binding */ DEFAULT_HEADERS),\n/* harmony export */   DEFAULT_REALTIME_OPTIONS: () => (/* binding */ DEFAULT_REALTIME_OPTIONS)\n/* harmony export */ });\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./version */ \"(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/lib/version.js\");\n\nlet JS_ENV = '';\n// @ts-ignore\nif (typeof Deno !== 'undefined') {\n    JS_ENV = 'deno';\n}\nelse if (typeof document !== 'undefined') {\n    JS_ENV = 'web';\n}\nelse if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {\n    JS_ENV = 'react-native';\n}\nelse {\n    JS_ENV = 'node';\n}\nconst DEFAULT_HEADERS = { 'X-Client-Info': `supabase-js-${JS_ENV}/${_version__WEBPACK_IMPORTED_MODULE_0__.version}` };\nconst DEFAULT_GLOBAL_OPTIONS = {\n    headers: DEFAULT_HEADERS,\n};\nconst DEFAULT_DB_OPTIONS = {\n    schema: 'public',\n};\nconst DEFAULT_AUTH_OPTIONS = {\n    autoRefreshToken: true,\n    persistSession: true,\n    detectSessionInUrl: true,\n    flowType: 'implicit',\n};\nconst DEFAULT_REALTIME_OPTIONS = {};\n//# sourceMappingURL=constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3VwYWJhc2UtanMvZGlzdC9tb2R1bGUvbGliL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDBCQUEwQixnQ0FBZ0MsT0FBTyxHQUFHLDZDQUFPLENBQUM7QUFDNUU7QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCIsInNvdXJjZXMiOlsiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvV29uZGVyVml0ZS1mcm9udGVuZC9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N1cGFiYXNlLWpzL2Rpc3QvbW9kdWxlL2xpYi9jb25zdGFudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gJy4vdmVyc2lvbic7XG5sZXQgSlNfRU5WID0gJyc7XG4vLyBAdHMtaWdub3JlXG5pZiAodHlwZW9mIERlbm8gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgSlNfRU5WID0gJ2Rlbm8nO1xufVxuZWxzZSBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgIEpTX0VOViA9ICd3ZWInO1xufVxuZWxzZSBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdSZWFjdE5hdGl2ZScpIHtcbiAgICBKU19FTlYgPSAncmVhY3QtbmF0aXZlJztcbn1cbmVsc2Uge1xuICAgIEpTX0VOViA9ICdub2RlJztcbn1cbmV4cG9ydCBjb25zdCBERUZBVUxUX0hFQURFUlMgPSB7ICdYLUNsaWVudC1JbmZvJzogYHN1cGFiYXNlLWpzLSR7SlNfRU5WfS8ke3ZlcnNpb259YCB9O1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfR0xPQkFMX09QVElPTlMgPSB7XG4gICAgaGVhZGVyczogREVGQVVMVF9IRUFERVJTLFxufTtcbmV4cG9ydCBjb25zdCBERUZBVUxUX0RCX09QVElPTlMgPSB7XG4gICAgc2NoZW1hOiAncHVibGljJyxcbn07XG5leHBvcnQgY29uc3QgREVGQVVMVF9BVVRIX09QVElPTlMgPSB7XG4gICAgYXV0b1JlZnJlc2hUb2tlbjogdHJ1ZSxcbiAgICBwZXJzaXN0U2Vzc2lvbjogdHJ1ZSxcbiAgICBkZXRlY3RTZXNzaW9uSW5Vcmw6IHRydWUsXG4gICAgZmxvd1R5cGU6ICdpbXBsaWNpdCcsXG59O1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfUkVBTFRJTUVfT1BUSU9OUyA9IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/lib/constants.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/lib/fetch.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@supabase/supabase-js/dist/module/lib/fetch.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchWithAuth: () => (/* binding */ fetchWithAuth),\n/* harmony export */   resolveFetch: () => (/* binding */ resolveFetch),\n/* harmony export */   resolveHeadersConstructor: () => (/* binding */ resolveHeadersConstructor)\n/* harmony export */ });\n/* harmony import */ var _supabase_node_fetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/node-fetch */ \"(app-pages-browser)/./node_modules/@supabase/node-fetch/browser.js\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n// @ts-ignore\n\nconst resolveFetch = (customFetch) => {\n    let _fetch;\n    if (customFetch) {\n        _fetch = customFetch;\n    }\n    else if (typeof fetch === 'undefined') {\n        _fetch = _supabase_node_fetch__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    }\n    else {\n        _fetch = fetch;\n    }\n    return (...args) => _fetch(...args);\n};\nconst resolveHeadersConstructor = () => {\n    if (typeof Headers === 'undefined') {\n        return _supabase_node_fetch__WEBPACK_IMPORTED_MODULE_0__.Headers;\n    }\n    return Headers;\n};\nconst fetchWithAuth = (supabaseKey, getAccessToken, customFetch) => {\n    const fetch = resolveFetch(customFetch);\n    const HeadersConstructor = resolveHeadersConstructor();\n    return (input, init) => __awaiter(void 0, void 0, void 0, function* () {\n        var _a;\n        const accessToken = (_a = (yield getAccessToken())) !== null && _a !== void 0 ? _a : supabaseKey;\n        let headers = new HeadersConstructor(init === null || init === void 0 ? void 0 : init.headers);\n        if (!headers.has('apikey')) {\n            headers.set('apikey', supabaseKey);\n        }\n        if (!headers.has('Authorization')) {\n            headers.set('Authorization', `Bearer ${accessToken}`);\n        }\n        return fetch(input, Object.assign(Object.assign({}, init), { headers }));\n    });\n};\n//# sourceMappingURL=fetch.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3VwYWJhc2UtanMvZGlzdC9tb2R1bGUvbGliL2ZldGNoLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQSxpQkFBaUIsU0FBSSxJQUFJLFNBQUk7QUFDN0IsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUM4RTtBQUN2RTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNERBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGVBQWUseURBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsWUFBWTtBQUMvRDtBQUNBLDBEQUEwRCxXQUFXLFNBQVM7QUFDOUUsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL1dvbmRlclZpdGUtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdXBhYmFzZS1qcy9kaXN0L21vZHVsZS9saWIvZmV0Y2guanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG4vLyBAdHMtaWdub3JlXG5pbXBvcnQgbm9kZUZldGNoLCB7IEhlYWRlcnMgYXMgTm9kZUZldGNoSGVhZGVycyB9IGZyb20gJ0BzdXBhYmFzZS9ub2RlLWZldGNoJztcbmV4cG9ydCBjb25zdCByZXNvbHZlRmV0Y2ggPSAoY3VzdG9tRmV0Y2gpID0+IHtcbiAgICBsZXQgX2ZldGNoO1xuICAgIGlmIChjdXN0b21GZXRjaCkge1xuICAgICAgICBfZmV0Y2ggPSBjdXN0b21GZXRjaDtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGZldGNoID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBfZmV0Y2ggPSBub2RlRmV0Y2g7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBfZmV0Y2ggPSBmZXRjaDtcbiAgICB9XG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiBfZmV0Y2goLi4uYXJncyk7XG59O1xuZXhwb3J0IGNvbnN0IHJlc29sdmVIZWFkZXJzQ29uc3RydWN0b3IgPSAoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBIZWFkZXJzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gTm9kZUZldGNoSGVhZGVycztcbiAgICB9XG4gICAgcmV0dXJuIEhlYWRlcnM7XG59O1xuZXhwb3J0IGNvbnN0IGZldGNoV2l0aEF1dGggPSAoc3VwYWJhc2VLZXksIGdldEFjY2Vzc1Rva2VuLCBjdXN0b21GZXRjaCkgPT4ge1xuICAgIGNvbnN0IGZldGNoID0gcmVzb2x2ZUZldGNoKGN1c3RvbUZldGNoKTtcbiAgICBjb25zdCBIZWFkZXJzQ29uc3RydWN0b3IgPSByZXNvbHZlSGVhZGVyc0NvbnN0cnVjdG9yKCk7XG4gICAgcmV0dXJuIChpbnB1dCwgaW5pdCkgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgYWNjZXNzVG9rZW4gPSAoX2EgPSAoeWllbGQgZ2V0QWNjZXNzVG9rZW4oKSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHN1cGFiYXNlS2V5O1xuICAgICAgICBsZXQgaGVhZGVycyA9IG5ldyBIZWFkZXJzQ29uc3RydWN0b3IoaW5pdCA9PT0gbnVsbCB8fCBpbml0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbml0LmhlYWRlcnMpO1xuICAgICAgICBpZiAoIWhlYWRlcnMuaGFzKCdhcGlrZXknKSkge1xuICAgICAgICAgICAgaGVhZGVycy5zZXQoJ2FwaWtleScsIHN1cGFiYXNlS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhlYWRlcnMuaGFzKCdBdXRob3JpemF0aW9uJykpIHtcbiAgICAgICAgICAgIGhlYWRlcnMuc2V0KCdBdXRob3JpemF0aW9uJywgYEJlYXJlciAke2FjY2Vzc1Rva2VufWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmZXRjaChpbnB1dCwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpbml0KSwgeyBoZWFkZXJzIH0pKTtcbiAgICB9KTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mZXRjaC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/lib/fetch.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/lib/helpers.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@supabase/supabase-js/dist/module/lib/helpers.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applySettingDefaults: () => (/* binding */ applySettingDefaults),\n/* harmony export */   isBrowser: () => (/* binding */ isBrowser),\n/* harmony export */   stripTrailingSlash: () => (/* binding */ stripTrailingSlash),\n/* harmony export */   uuid: () => (/* binding */ uuid)\n/* harmony export */ });\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nfunction uuid() {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n        var r = (Math.random() * 16) | 0, v = c == 'x' ? r : (r & 0x3) | 0x8;\n        return v.toString(16);\n    });\n}\nfunction stripTrailingSlash(url) {\n    return url.replace(/\\/$/, '');\n}\nconst isBrowser = () => typeof window !== 'undefined';\nfunction applySettingDefaults(options, defaults) {\n    const { db: dbOptions, auth: authOptions, realtime: realtimeOptions, global: globalOptions, } = options;\n    const { db: DEFAULT_DB_OPTIONS, auth: DEFAULT_AUTH_OPTIONS, realtime: DEFAULT_REALTIME_OPTIONS, global: DEFAULT_GLOBAL_OPTIONS, } = defaults;\n    const result = {\n        db: Object.assign(Object.assign({}, DEFAULT_DB_OPTIONS), dbOptions),\n        auth: Object.assign(Object.assign({}, DEFAULT_AUTH_OPTIONS), authOptions),\n        realtime: Object.assign(Object.assign({}, DEFAULT_REALTIME_OPTIONS), realtimeOptions),\n        global: Object.assign(Object.assign({}, DEFAULT_GLOBAL_OPTIONS), globalOptions),\n        accessToken: () => __awaiter(this, void 0, void 0, function* () { return ''; }),\n    };\n    if (options.accessToken) {\n        result.accessToken = options.accessToken;\n    }\n    else {\n        // hack around Required<>\n        delete result.accessToken;\n    }\n    return result;\n}\n//# sourceMappingURL=helpers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3VwYWJhc2UtanMvZGlzdC9tb2R1bGUvbGliL2hlbHBlcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLGlCQUFpQixTQUFJLElBQUksU0FBSTtBQUM3Qiw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDQTtBQUNQLFlBQVksc0ZBQXNGO0FBQ2xHLFlBQVksMEhBQTBIO0FBQ3RJO0FBQ0EsMENBQTBDO0FBQzFDLDRDQUE0QztBQUM1QyxnREFBZ0Q7QUFDaEQsOENBQThDO0FBQzlDLDBFQUEwRSxZQUFZO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL1dvbmRlclZpdGUtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdXBhYmFzZS1qcy9kaXN0L21vZHVsZS9saWIvaGVscGVycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmV4cG9ydCBmdW5jdGlvbiB1dWlkKCkge1xuICAgIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHZhciByID0gKE1hdGgucmFuZG9tKCkgKiAxNikgfCAwLCB2ID0gYyA9PSAneCcgPyByIDogKHIgJiAweDMpIHwgMHg4O1xuICAgICAgICByZXR1cm4gdi50b1N0cmluZygxNik7XG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gc3RyaXBUcmFpbGluZ1NsYXNoKHVybCkge1xuICAgIHJldHVybiB1cmwucmVwbGFjZSgvXFwvJC8sICcnKTtcbn1cbmV4cG9ydCBjb25zdCBpc0Jyb3dzZXIgPSAoKSA9PiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbmV4cG9ydCBmdW5jdGlvbiBhcHBseVNldHRpbmdEZWZhdWx0cyhvcHRpb25zLCBkZWZhdWx0cykge1xuICAgIGNvbnN0IHsgZGI6IGRiT3B0aW9ucywgYXV0aDogYXV0aE9wdGlvbnMsIHJlYWx0aW1lOiByZWFsdGltZU9wdGlvbnMsIGdsb2JhbDogZ2xvYmFsT3B0aW9ucywgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgeyBkYjogREVGQVVMVF9EQl9PUFRJT05TLCBhdXRoOiBERUZBVUxUX0FVVEhfT1BUSU9OUywgcmVhbHRpbWU6IERFRkFVTFRfUkVBTFRJTUVfT1BUSU9OUywgZ2xvYmFsOiBERUZBVUxUX0dMT0JBTF9PUFRJT05TLCB9ID0gZGVmYXVsdHM7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICBkYjogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX0RCX09QVElPTlMpLCBkYk9wdGlvbnMpLFxuICAgICAgICBhdXRoOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfQVVUSF9PUFRJT05TKSwgYXV0aE9wdGlvbnMpLFxuICAgICAgICByZWFsdGltZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1JFQUxUSU1FX09QVElPTlMpLCByZWFsdGltZU9wdGlvbnMpLFxuICAgICAgICBnbG9iYWw6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9HTE9CQUxfT1BUSU9OUyksIGdsb2JhbE9wdGlvbnMpLFxuICAgICAgICBhY2Nlc3NUb2tlbjogKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkgeyByZXR1cm4gJyc7IH0pLFxuICAgIH07XG4gICAgaWYgKG9wdGlvbnMuYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgcmVzdWx0LmFjY2Vzc1Rva2VuID0gb3B0aW9ucy5hY2Nlc3NUb2tlbjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIGhhY2sgYXJvdW5kIFJlcXVpcmVkPD5cbiAgICAgICAgZGVsZXRlIHJlc3VsdC5hY2Nlc3NUb2tlbjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlbHBlcnMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/lib/helpers.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/lib/version.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@supabase/supabase-js/dist/module/lib/version.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = '2.47.10';\n//# sourceMappingURL=version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3VwYWJhc2UtanMvZGlzdC9tb2R1bGUvbGliL3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPO0FBQ1AiLCJzb3VyY2VzIjpbIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL1dvbmRlclZpdGUtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdXBhYmFzZS1qcy9kaXN0L21vZHVsZS9saWIvdmVyc2lvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgdmVyc2lvbiA9ICcyLjQ3LjEwJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlcnNpb24uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/lib/version.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/json-logic-js/logic.js":
/*!*********************************************!*\
  !*** ./node_modules/json-logic-js/logic.js ***!
  \*********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/* globals define,module */\n/*\nUsing a Universal Module Loader that should be browser, require, and AMD friendly\nhttp://ricostacruz.com/cheatsheets/umdjs.html\n*/\n;(function(root, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n}(this, function() {\n  \"use strict\";\n  /* globals console:false */\n\n  if ( ! Array.isArray) {\n    Array.isArray = function(arg) {\n      return Object.prototype.toString.call(arg) === \"[object Array]\";\n    };\n  }\n\n  /**\n   * Return an array that contains no duplicates (original not modified)\n   * @param  {array} array   Original reference array\n   * @return {array}         New array with no duplicates\n   */\n  function arrayUnique(array) {\n    var a = [];\n    for (var i=0, l=array.length; i<l; i++) {\n      if (a.indexOf(array[i]) === -1) {\n        a.push(array[i]);\n      }\n    }\n    return a;\n  }\n\n  var jsonLogic = {};\n  var operations = {\n    \"==\": function(a, b) {\n      return a == b;\n    },\n    \"===\": function(a, b) {\n      return a === b;\n    },\n    \"!=\": function(a, b) {\n      return a != b;\n    },\n    \"!==\": function(a, b) {\n      return a !== b;\n    },\n    \">\": function(a, b) {\n      return a > b;\n    },\n    \">=\": function(a, b) {\n      return a >= b;\n    },\n    \"<\": function(a, b, c) {\n      return (c === undefined) ? a < b : (a < b) && (b < c);\n    },\n    \"<=\": function(a, b, c) {\n      return (c === undefined) ? a <= b : (a <= b) && (b <= c);\n    },\n    \"!!\": function(a) {\n      return jsonLogic.truthy(a);\n    },\n    \"!\": function(a) {\n      return !jsonLogic.truthy(a);\n    },\n    \"%\": function(a, b) {\n      return a % b;\n    },\n    \"log\": function(a) {\n      console.log(a); return a;\n    },\n    \"in\": function(a, b) {\n      if (!b || typeof b.indexOf === \"undefined\") return false;\n      return (b.indexOf(a) !== -1);\n    },\n    \"cat\": function() {\n      return Array.prototype.join.call(arguments, \"\");\n    },\n    \"substr\": function(source, start, end) {\n      if (end < 0) {\n        // JavaScript doesn't support negative end, this emulates PHP behavior\n        var temp = String(source).substr(start);\n        return temp.substr(0, temp.length + end);\n      }\n      return String(source).substr(start, end);\n    },\n    \"+\": function() {\n      return Array.prototype.reduce.call(arguments, function(a, b) {\n        return parseFloat(a, 10) + parseFloat(b, 10);\n      }, 0);\n    },\n    \"*\": function() {\n      return Array.prototype.reduce.call(arguments, function(a, b) {\n        return parseFloat(a, 10) * parseFloat(b, 10);\n      });\n    },\n    \"-\": function(a, b) {\n      if (b === undefined) {\n        return -a;\n      } else {\n        return a - b;\n      }\n    },\n    \"/\": function(a, b) {\n      return a / b;\n    },\n    \"min\": function() {\n      return Math.min.apply(this, arguments);\n    },\n    \"max\": function() {\n      return Math.max.apply(this, arguments);\n    },\n    \"merge\": function() {\n      return Array.prototype.reduce.call(arguments, function(a, b) {\n        return a.concat(b);\n      }, []);\n    },\n    \"var\": function(a, b) {\n      var not_found = (b === undefined) ? null : b;\n      var data = this;\n      if (typeof a === \"undefined\" || a===\"\" || a===null) {\n        return data;\n      }\n      var sub_props = String(a).split(\".\");\n      for (var i = 0; i < sub_props.length; i++) {\n        if (data === null || data === undefined) {\n          return not_found;\n        }\n        // Descending into data\n        data = data[sub_props[i]];\n        if (data === undefined) {\n          return not_found;\n        }\n      }\n      return data;\n    },\n    \"missing\": function() {\n      /*\n      Missing can receive many keys as many arguments, like {\"missing:[1,2]}\n      Missing can also receive *one* argument that is an array of keys,\n      which typically happens if it's actually acting on the output of another command\n      (like 'if' or 'merge')\n      */\n\n      var missing = [];\n      var keys = Array.isArray(arguments[0]) ? arguments[0] : arguments;\n\n      for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        var value = jsonLogic.apply({\"var\": key}, this);\n        if (value === null || value === \"\") {\n          missing.push(key);\n        }\n      }\n\n      return missing;\n    },\n    \"missing_some\": function(need_count, options) {\n      // missing_some takes two arguments, how many (minimum) items must be present, and an array of keys (just like 'missing') to check for presence.\n      var are_missing = jsonLogic.apply({\"missing\": options}, this);\n\n      if (options.length - are_missing.length >= need_count) {\n        return [];\n      } else {\n        return are_missing;\n      }\n    },\n  };\n\n  jsonLogic.is_logic = function(logic) {\n    return (\n      typeof logic === \"object\" && // An object\n      logic !== null && // but not null\n      ! Array.isArray(logic) && // and not an array\n      Object.keys(logic).length === 1 // with exactly one key\n    );\n  };\n\n  /*\n  This helper will defer to the JsonLogic spec as a tie-breaker when different language interpreters define different behavior for the truthiness of primitives.  E.g., PHP considers empty arrays to be falsy, but Javascript considers them to be truthy. JsonLogic, as an ecosystem, needs one consistent answer.\n\n  Spec and rationale here: http://jsonlogic.com/truthy\n  */\n  jsonLogic.truthy = function(value) {\n    if (Array.isArray(value) && value.length === 0) {\n      return false;\n    }\n    return !! value;\n  };\n\n\n  jsonLogic.get_operator = function(logic) {\n    return Object.keys(logic)[0];\n  };\n\n  jsonLogic.get_values = function(logic) {\n    return logic[jsonLogic.get_operator(logic)];\n  };\n\n  jsonLogic.apply = function(logic, data) {\n    // Does this array contain logic? Only one way to find out.\n    if (Array.isArray(logic)) {\n      return logic.map(function(l) {\n        return jsonLogic.apply(l, data);\n      });\n    }\n    // You've recursed to a primitive, stop!\n    if ( ! jsonLogic.is_logic(logic) ) {\n      return logic;\n    }\n\n    var op = jsonLogic.get_operator(logic);\n    var values = logic[op];\n    var i;\n    var current;\n    var scopedLogic;\n    var scopedData;\n    var initial;\n\n    // easy syntax for unary operators, like {\"var\" : \"x\"} instead of strict {\"var\" : [\"x\"]}\n    if ( ! Array.isArray(values)) {\n      values = [values];\n    }\n\n    // 'if', 'and', and 'or' violate the normal rule of depth-first calculating consequents, let each manage recursion as needed.\n    if (op === \"if\" || op == \"?:\") {\n      /* 'if' should be called with a odd number of parameters, 3 or greater\n      This works on the pattern:\n      if( 0 ){ 1 }else{ 2 };\n      if( 0 ){ 1 }else if( 2 ){ 3 }else{ 4 };\n      if( 0 ){ 1 }else if( 2 ){ 3 }else if( 4 ){ 5 }else{ 6 };\n\n      The implementation is:\n      For pairs of values (0,1 then 2,3 then 4,5 etc)\n      If the first evaluates truthy, evaluate and return the second\n      If the first evaluates falsy, jump to the next pair (e.g, 0,1 to 2,3)\n      given one parameter, evaluate and return it. (it's an Else and all the If/ElseIf were false)\n      given 0 parameters, return NULL (not great practice, but there was no Else)\n      */\n      for (i = 0; i < values.length - 1; i += 2) {\n        if ( jsonLogic.truthy( jsonLogic.apply(values[i], data) ) ) {\n          return jsonLogic.apply(values[i+1], data);\n        }\n      }\n      if (values.length === i+1) {\n        return jsonLogic.apply(values[i], data);\n      }\n      return null;\n    } else if (op === \"and\") { // Return first falsy, or last\n      for (i=0; i < values.length; i+=1) {\n        current = jsonLogic.apply(values[i], data);\n        if ( ! jsonLogic.truthy(current)) {\n          return current;\n        }\n      }\n      return current; // Last\n    } else if (op === \"or\") {// Return first truthy, or last\n      for (i=0; i < values.length; i+=1) {\n        current = jsonLogic.apply(values[i], data);\n        if ( jsonLogic.truthy(current) ) {\n          return current;\n        }\n      }\n      return current; // Last\n    } else if (op === \"filter\") {\n      scopedData = jsonLogic.apply(values[0], data);\n      scopedLogic = values[1];\n\n      if ( ! Array.isArray(scopedData)) {\n        return [];\n      }\n      // Return only the elements from the array in the first argument,\n      // that return truthy when passed to the logic in the second argument.\n      // For parity with JavaScript, reindex the returned array\n      return scopedData.filter(function(datum) {\n        return jsonLogic.truthy( jsonLogic.apply(scopedLogic, datum));\n      });\n    } else if (op === \"map\") {\n      scopedData = jsonLogic.apply(values[0], data);\n      scopedLogic = values[1];\n\n      if ( ! Array.isArray(scopedData)) {\n        return [];\n      }\n\n      return scopedData.map(function(datum) {\n        return jsonLogic.apply(scopedLogic, datum);\n      });\n    } else if (op === \"reduce\") {\n      scopedData = jsonLogic.apply(values[0], data);\n      scopedLogic = values[1];\n      initial = typeof values[2] !== \"undefined\" ? jsonLogic.apply(values[2], data) : null;\n\n      if ( ! Array.isArray(scopedData)) {\n        return initial;\n      }\n\n      return scopedData.reduce(\n        function(accumulator, current) {\n          return jsonLogic.apply(\n            scopedLogic,\n            {current: current, accumulator: accumulator}\n          );\n        },\n        initial\n      );\n    } else if (op === \"all\") {\n      scopedData = jsonLogic.apply(values[0], data);\n      scopedLogic = values[1];\n      // All of an empty set is false. Note, some and none have correct fallback after the for loop\n      if ( ! Array.isArray(scopedData) || ! scopedData.length) {\n        return false;\n      }\n      for (i=0; i < scopedData.length; i+=1) {\n        if ( ! jsonLogic.truthy( jsonLogic.apply(scopedLogic, scopedData[i]) )) {\n          return false; // First falsy, short circuit\n        }\n      }\n      return true; // All were truthy\n    } else if (op === \"none\") {\n      scopedData = jsonLogic.apply(values[0], data);\n      scopedLogic = values[1];\n\n      if ( ! Array.isArray(scopedData) || ! scopedData.length) {\n        return true;\n      }\n      for (i=0; i < scopedData.length; i+=1) {\n        if ( jsonLogic.truthy( jsonLogic.apply(scopedLogic, scopedData[i]) )) {\n          return false; // First truthy, short circuit\n        }\n      }\n      return true; // None were truthy\n    } else if (op === \"some\") {\n      scopedData = jsonLogic.apply(values[0], data);\n      scopedLogic = values[1];\n\n      if ( ! Array.isArray(scopedData) || ! scopedData.length) {\n        return false;\n      }\n      for (i=0; i < scopedData.length; i+=1) {\n        if ( jsonLogic.truthy( jsonLogic.apply(scopedLogic, scopedData[i]) )) {\n          return true; // First truthy, short circuit\n        }\n      }\n      return false; // None were truthy\n    }\n\n    // Everyone else gets immediate depth-first recursion\n    values = values.map(function(val) {\n      return jsonLogic.apply(val, data);\n    });\n\n\n    // The operation is called with \"data\" bound to its \"this\" and \"values\" passed as arguments.\n    // Structured commands like % or > can name formal arguments while flexible commands (like missing or merge) can operate on the pseudo-array arguments\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments\n    if (operations.hasOwnProperty(op) && typeof operations[op] === \"function\") {\n      return operations[op].apply(data, values);\n    } else if (op.indexOf(\".\") > 0) { // Contains a dot, and not in the 0th position\n      var sub_ops = String(op).split(\".\");\n      var operation = operations;\n      for (i = 0; i < sub_ops.length; i++) {\n        if (!operation.hasOwnProperty(sub_ops[i])) {\n          throw new Error(\"Unrecognized operation \" + op +\n            \" (failed at \" + sub_ops.slice(0, i+1).join(\".\") + \")\");\n        }\n        // Descending into operations\n        operation = operation[sub_ops[i]];\n      }\n\n      return operation.apply(data, values);\n    }\n\n    throw new Error(\"Unrecognized operation \" + op );\n  };\n\n  jsonLogic.uses_data = function(logic) {\n    var collection = [];\n\n    if (jsonLogic.is_logic(logic)) {\n      var op = jsonLogic.get_operator(logic);\n      var values = logic[op];\n\n      if ( ! Array.isArray(values)) {\n        values = [values];\n      }\n\n      if (op === \"var\") {\n        // This doesn't cover the case where the arg to var is itself a rule.\n        collection.push(values[0]);\n      } else {\n        // Recursion!\n        values.forEach(function(val) {\n          collection.push.apply(collection, jsonLogic.uses_data(val) );\n        });\n      }\n    }\n\n    return arrayUnique(collection);\n  };\n\n  jsonLogic.add_operation = function(name, code) {\n    operations[name] = code;\n  };\n\n  jsonLogic.rm_operation = function(name) {\n    delete operations[name];\n  };\n\n  jsonLogic.rule_like = function(rule, pattern) {\n    // console.log(\"Is \". JSON.stringify(rule) . \" like \" . JSON.stringify(pattern) . \"?\");\n    if (pattern === rule) {\n      return true;\n    } // TODO : Deep object equivalency?\n    if (pattern === \"@\") {\n      return true;\n    } // Wildcard!\n    if (pattern === \"number\") {\n      return (typeof rule === \"number\");\n    }\n    if (pattern === \"string\") {\n      return (typeof rule === \"string\");\n    }\n    if (pattern === \"array\") {\n      // !logic test might be superfluous in JavaScript\n      return Array.isArray(rule) && ! jsonLogic.is_logic(rule);\n    }\n\n    if (jsonLogic.is_logic(pattern)) {\n      if (jsonLogic.is_logic(rule)) {\n        var pattern_op = jsonLogic.get_operator(pattern);\n        var rule_op = jsonLogic.get_operator(rule);\n\n        if (pattern_op === \"@\" || pattern_op === rule_op) {\n          // echo \"\\nOperators match, go deeper\\n\";\n          return jsonLogic.rule_like(\n            jsonLogic.get_values(rule, false),\n            jsonLogic.get_values(pattern, false)\n          );\n        }\n      }\n      return false; // pattern is logic, rule isn't, can't be eq\n    }\n\n    if (Array.isArray(pattern)) {\n      if (Array.isArray(rule)) {\n        if (pattern.length !== rule.length) {\n          return false;\n        }\n        /*\n          Note, array order MATTERS, because we're using this array test logic to consider arguments, where order can matter. (e.g., + is commutative, but '-' or 'if' or 'var' are NOT)\n        */\n        for (var i = 0; i < pattern.length; i += 1) {\n          // If any fail, we fail\n          if ( ! jsonLogic.rule_like(rule[i], pattern[i])) {\n            return false;\n          }\n        }\n        return true; // If they *all* passed, we pass\n      } else {\n        return false; // Pattern is array, rule isn't\n      }\n    }\n\n    // Not logic, not array, not a === match for rule.\n    return false;\n  };\n\n  return jsonLogic;\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qc29uLWxvZ2ljLWpzL2xvZ2ljLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTUFBTSxJQUEwQztBQUNoRCxJQUFJLG9DQUFPLE9BQU87QUFBQTtBQUFBO0FBQUE7QUFBQSxrR0FBQztBQUNuQixJQUFJLEtBQUssRUFJTjtBQUNILENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLGVBQWU7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLEtBQUs7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxzQkFBc0I7QUFDdEIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBLHFDQUFxQyxXQUFXO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx5Q0FBeUMsbUJBQW1COztBQUU1RDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUE4QyxhQUFhLG1CQUFtQjtBQUM5RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUcsTUFBTTtBQUN4QixlQUFlLEdBQUcsY0FBYyxHQUFHLE1BQU07QUFDekMsZUFBZSxHQUFHLGNBQWMsR0FBRyxjQUFjLEdBQUcsTUFBTTs7QUFFMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHlCQUF5QjtBQUMvQixnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsTUFBTSx1QkFBdUI7QUFDN0IsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVCQUF1QjtBQUN2QztBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1QkFBdUI7QUFDdkM7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxnQ0FBZ0M7QUFDdEM7QUFDQTtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFFBQVE7QUFDUixzQkFBc0I7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDIiwic291cmNlcyI6WyIvVXNlcnMvd29uZGVybGFuZG1pdGNoL0Nhc2NhZGVQcm9qZWN0cy9Xb25kZXJWaXRlLWZyb250ZW5kL25vZGVfbW9kdWxlcy9qc29uLWxvZ2ljLWpzL2xvZ2ljLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGdsb2JhbHMgZGVmaW5lLG1vZHVsZSAqL1xuLypcblVzaW5nIGEgVW5pdmVyc2FsIE1vZHVsZSBMb2FkZXIgdGhhdCBzaG91bGQgYmUgYnJvd3NlciwgcmVxdWlyZSwgYW5kIEFNRCBmcmllbmRseVxuaHR0cDovL3JpY29zdGFjcnV6LmNvbS9jaGVhdHNoZWV0cy91bWRqcy5odG1sXG4qL1xuOyhmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShmYWN0b3J5KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICB9IGVsc2Uge1xuICAgIHJvb3QuanNvbkxvZ2ljID0gZmFjdG9yeSgpO1xuICB9XG59KHRoaXMsIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgLyogZ2xvYmFscyBjb25zb2xlOmZhbHNlICovXG5cbiAgaWYgKCAhIEFycmF5LmlzQXJyYXkpIHtcbiAgICBBcnJheS5pc0FycmF5ID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZykgPT09IFwiW29iamVjdCBBcnJheV1cIjtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIG5vIGR1cGxpY2F0ZXMgKG9yaWdpbmFsIG5vdCBtb2RpZmllZClcbiAgICogQHBhcmFtICB7YXJyYXl9IGFycmF5ICAgT3JpZ2luYWwgcmVmZXJlbmNlIGFycmF5XG4gICAqIEByZXR1cm4ge2FycmF5fSAgICAgICAgIE5ldyBhcnJheSB3aXRoIG5vIGR1cGxpY2F0ZXNcbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5VW5pcXVlKGFycmF5KSB7XG4gICAgdmFyIGEgPSBbXTtcbiAgICBmb3IgKHZhciBpPTAsIGw9YXJyYXkubGVuZ3RoOyBpPGw7IGkrKykge1xuICAgICAgaWYgKGEuaW5kZXhPZihhcnJheVtpXSkgPT09IC0xKSB7XG4gICAgICAgIGEucHVzaChhcnJheVtpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9XG5cbiAgdmFyIGpzb25Mb2dpYyA9IHt9O1xuICB2YXIgb3BlcmF0aW9ucyA9IHtcbiAgICBcIj09XCI6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIHJldHVybiBhID09IGI7XG4gICAgfSxcbiAgICBcIj09PVwiOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICByZXR1cm4gYSA9PT0gYjtcbiAgICB9LFxuICAgIFwiIT1cIjogZnVuY3Rpb24oYSwgYikge1xuICAgICAgcmV0dXJuIGEgIT0gYjtcbiAgICB9LFxuICAgIFwiIT09XCI6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIHJldHVybiBhICE9PSBiO1xuICAgIH0sXG4gICAgXCI+XCI6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIHJldHVybiBhID4gYjtcbiAgICB9LFxuICAgIFwiPj1cIjogZnVuY3Rpb24oYSwgYikge1xuICAgICAgcmV0dXJuIGEgPj0gYjtcbiAgICB9LFxuICAgIFwiPFwiOiBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICByZXR1cm4gKGMgPT09IHVuZGVmaW5lZCkgPyBhIDwgYiA6IChhIDwgYikgJiYgKGIgPCBjKTtcbiAgICB9LFxuICAgIFwiPD1cIjogZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAgcmV0dXJuIChjID09PSB1bmRlZmluZWQpID8gYSA8PSBiIDogKGEgPD0gYikgJiYgKGIgPD0gYyk7XG4gICAgfSxcbiAgICBcIiEhXCI6IGZ1bmN0aW9uKGEpIHtcbiAgICAgIHJldHVybiBqc29uTG9naWMudHJ1dGh5KGEpO1xuICAgIH0sXG4gICAgXCIhXCI6IGZ1bmN0aW9uKGEpIHtcbiAgICAgIHJldHVybiAhanNvbkxvZ2ljLnRydXRoeShhKTtcbiAgICB9LFxuICAgIFwiJVwiOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICByZXR1cm4gYSAlIGI7XG4gICAgfSxcbiAgICBcImxvZ1wiOiBmdW5jdGlvbihhKSB7XG4gICAgICBjb25zb2xlLmxvZyhhKTsgcmV0dXJuIGE7XG4gICAgfSxcbiAgICBcImluXCI6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIGlmICghYiB8fCB0eXBlb2YgYi5pbmRleE9mID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gKGIuaW5kZXhPZihhKSAhPT0gLTEpO1xuICAgIH0sXG4gICAgXCJjYXRcIjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmpvaW4uY2FsbChhcmd1bWVudHMsIFwiXCIpO1xuICAgIH0sXG4gICAgXCJzdWJzdHJcIjogZnVuY3Rpb24oc291cmNlLCBzdGFydCwgZW5kKSB7XG4gICAgICBpZiAoZW5kIDwgMCkge1xuICAgICAgICAvLyBKYXZhU2NyaXB0IGRvZXNuJ3Qgc3VwcG9ydCBuZWdhdGl2ZSBlbmQsIHRoaXMgZW11bGF0ZXMgUEhQIGJlaGF2aW9yXG4gICAgICAgIHZhciB0ZW1wID0gU3RyaW5nKHNvdXJjZSkuc3Vic3RyKHN0YXJ0KTtcbiAgICAgICAgcmV0dXJuIHRlbXAuc3Vic3RyKDAsIHRlbXAubGVuZ3RoICsgZW5kKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBTdHJpbmcoc291cmNlKS5zdWJzdHIoc3RhcnQsIGVuZCk7XG4gICAgfSxcbiAgICBcIitcIjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnJlZHVjZS5jYWxsKGFyZ3VtZW50cywgZnVuY3Rpb24oYSwgYikge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChhLCAxMCkgKyBwYXJzZUZsb2F0KGIsIDEwKTtcbiAgICAgIH0sIDApO1xuICAgIH0sXG4gICAgXCIqXCI6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UuY2FsbChhcmd1bWVudHMsIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoYSwgMTApICogcGFyc2VGbG9hdChiLCAxMCk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIFwiLVwiOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICBpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAtYTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBhIC0gYjtcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiL1wiOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICByZXR1cm4gYSAvIGI7XG4gICAgfSxcbiAgICBcIm1pblwiOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBNYXRoLm1pbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgXCJtYXhcIjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXguYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIFwibWVyZ2VcIjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnJlZHVjZS5jYWxsKGFyZ3VtZW50cywgZnVuY3Rpb24oYSwgYikge1xuICAgICAgICByZXR1cm4gYS5jb25jYXQoYik7XG4gICAgICB9LCBbXSk7XG4gICAgfSxcbiAgICBcInZhclwiOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICB2YXIgbm90X2ZvdW5kID0gKGIgPT09IHVuZGVmaW5lZCkgPyBudWxsIDogYjtcbiAgICAgIHZhciBkYXRhID0gdGhpcztcbiAgICAgIGlmICh0eXBlb2YgYSA9PT0gXCJ1bmRlZmluZWRcIiB8fCBhPT09XCJcIiB8fCBhPT09bnVsbCkge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH1cbiAgICAgIHZhciBzdWJfcHJvcHMgPSBTdHJpbmcoYSkuc3BsaXQoXCIuXCIpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJfcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIG5vdF9mb3VuZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBEZXNjZW5kaW5nIGludG8gZGF0YVxuICAgICAgICBkYXRhID0gZGF0YVtzdWJfcHJvcHNbaV1dO1xuICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIG5vdF9mb3VuZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcbiAgICBcIm1pc3NpbmdcIjogZnVuY3Rpb24oKSB7XG4gICAgICAvKlxuICAgICAgTWlzc2luZyBjYW4gcmVjZWl2ZSBtYW55IGtleXMgYXMgbWFueSBhcmd1bWVudHMsIGxpa2Uge1wibWlzc2luZzpbMSwyXX1cbiAgICAgIE1pc3NpbmcgY2FuIGFsc28gcmVjZWl2ZSAqb25lKiBhcmd1bWVudCB0aGF0IGlzIGFuIGFycmF5IG9mIGtleXMsXG4gICAgICB3aGljaCB0eXBpY2FsbHkgaGFwcGVucyBpZiBpdCdzIGFjdHVhbGx5IGFjdGluZyBvbiB0aGUgb3V0cHV0IG9mIGFub3RoZXIgY29tbWFuZFxuICAgICAgKGxpa2UgJ2lmJyBvciAnbWVyZ2UnKVxuICAgICAgKi9cblxuICAgICAgdmFyIG1pc3NpbmcgPSBbXTtcbiAgICAgIHZhciBrZXlzID0gQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMF0pID8gYXJndW1lbnRzWzBdIDogYXJndW1lbnRzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgIHZhciB2YWx1ZSA9IGpzb25Mb2dpYy5hcHBseSh7XCJ2YXJcIjoga2V5fSwgdGhpcyk7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gXCJcIikge1xuICAgICAgICAgIG1pc3NpbmcucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtaXNzaW5nO1xuICAgIH0sXG4gICAgXCJtaXNzaW5nX3NvbWVcIjogZnVuY3Rpb24obmVlZF9jb3VudCwgb3B0aW9ucykge1xuICAgICAgLy8gbWlzc2luZ19zb21lIHRha2VzIHR3byBhcmd1bWVudHMsIGhvdyBtYW55IChtaW5pbXVtKSBpdGVtcyBtdXN0IGJlIHByZXNlbnQsIGFuZCBhbiBhcnJheSBvZiBrZXlzIChqdXN0IGxpa2UgJ21pc3NpbmcnKSB0byBjaGVjayBmb3IgcHJlc2VuY2UuXG4gICAgICB2YXIgYXJlX21pc3NpbmcgPSBqc29uTG9naWMuYXBwbHkoe1wibWlzc2luZ1wiOiBvcHRpb25zfSwgdGhpcyk7XG5cbiAgICAgIGlmIChvcHRpb25zLmxlbmd0aCAtIGFyZV9taXNzaW5nLmxlbmd0aCA+PSBuZWVkX2NvdW50KSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBhcmVfbWlzc2luZztcbiAgICAgIH1cbiAgICB9LFxuICB9O1xuXG4gIGpzb25Mb2dpYy5pc19sb2dpYyA9IGZ1bmN0aW9uKGxvZ2ljKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHR5cGVvZiBsb2dpYyA9PT0gXCJvYmplY3RcIiAmJiAvLyBBbiBvYmplY3RcbiAgICAgIGxvZ2ljICE9PSBudWxsICYmIC8vIGJ1dCBub3QgbnVsbFxuICAgICAgISBBcnJheS5pc0FycmF5KGxvZ2ljKSAmJiAvLyBhbmQgbm90IGFuIGFycmF5XG4gICAgICBPYmplY3Qua2V5cyhsb2dpYykubGVuZ3RoID09PSAxIC8vIHdpdGggZXhhY3RseSBvbmUga2V5XG4gICAgKTtcbiAgfTtcblxuICAvKlxuICBUaGlzIGhlbHBlciB3aWxsIGRlZmVyIHRvIHRoZSBKc29uTG9naWMgc3BlYyBhcyBhIHRpZS1icmVha2VyIHdoZW4gZGlmZmVyZW50IGxhbmd1YWdlIGludGVycHJldGVycyBkZWZpbmUgZGlmZmVyZW50IGJlaGF2aW9yIGZvciB0aGUgdHJ1dGhpbmVzcyBvZiBwcmltaXRpdmVzLiAgRS5nLiwgUEhQIGNvbnNpZGVycyBlbXB0eSBhcnJheXMgdG8gYmUgZmFsc3ksIGJ1dCBKYXZhc2NyaXB0IGNvbnNpZGVycyB0aGVtIHRvIGJlIHRydXRoeS4gSnNvbkxvZ2ljLCBhcyBhbiBlY29zeXN0ZW0sIG5lZWRzIG9uZSBjb25zaXN0ZW50IGFuc3dlci5cblxuICBTcGVjIGFuZCByYXRpb25hbGUgaGVyZTogaHR0cDovL2pzb25sb2dpYy5jb20vdHJ1dGh5XG4gICovXG4gIGpzb25Mb2dpYy50cnV0aHkgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuICEhIHZhbHVlO1xuICB9O1xuXG5cbiAganNvbkxvZ2ljLmdldF9vcGVyYXRvciA9IGZ1bmN0aW9uKGxvZ2ljKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGxvZ2ljKVswXTtcbiAgfTtcblxuICBqc29uTG9naWMuZ2V0X3ZhbHVlcyA9IGZ1bmN0aW9uKGxvZ2ljKSB7XG4gICAgcmV0dXJuIGxvZ2ljW2pzb25Mb2dpYy5nZXRfb3BlcmF0b3IobG9naWMpXTtcbiAgfTtcblxuICBqc29uTG9naWMuYXBwbHkgPSBmdW5jdGlvbihsb2dpYywgZGF0YSkge1xuICAgIC8vIERvZXMgdGhpcyBhcnJheSBjb250YWluIGxvZ2ljPyBPbmx5IG9uZSB3YXkgdG8gZmluZCBvdXQuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkobG9naWMpKSB7XG4gICAgICByZXR1cm4gbG9naWMubWFwKGZ1bmN0aW9uKGwpIHtcbiAgICAgICAgcmV0dXJuIGpzb25Mb2dpYy5hcHBseShsLCBkYXRhKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBZb3UndmUgcmVjdXJzZWQgdG8gYSBwcmltaXRpdmUsIHN0b3AhXG4gICAgaWYgKCAhIGpzb25Mb2dpYy5pc19sb2dpYyhsb2dpYykgKSB7XG4gICAgICByZXR1cm4gbG9naWM7XG4gICAgfVxuXG4gICAgdmFyIG9wID0ganNvbkxvZ2ljLmdldF9vcGVyYXRvcihsb2dpYyk7XG4gICAgdmFyIHZhbHVlcyA9IGxvZ2ljW29wXTtcbiAgICB2YXIgaTtcbiAgICB2YXIgY3VycmVudDtcbiAgICB2YXIgc2NvcGVkTG9naWM7XG4gICAgdmFyIHNjb3BlZERhdGE7XG4gICAgdmFyIGluaXRpYWw7XG5cbiAgICAvLyBlYXN5IHN5bnRheCBmb3IgdW5hcnkgb3BlcmF0b3JzLCBsaWtlIHtcInZhclwiIDogXCJ4XCJ9IGluc3RlYWQgb2Ygc3RyaWN0IHtcInZhclwiIDogW1wieFwiXX1cbiAgICBpZiAoICEgQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgICB2YWx1ZXMgPSBbdmFsdWVzXTtcbiAgICB9XG5cbiAgICAvLyAnaWYnLCAnYW5kJywgYW5kICdvcicgdmlvbGF0ZSB0aGUgbm9ybWFsIHJ1bGUgb2YgZGVwdGgtZmlyc3QgY2FsY3VsYXRpbmcgY29uc2VxdWVudHMsIGxldCBlYWNoIG1hbmFnZSByZWN1cnNpb24gYXMgbmVlZGVkLlxuICAgIGlmIChvcCA9PT0gXCJpZlwiIHx8IG9wID09IFwiPzpcIikge1xuICAgICAgLyogJ2lmJyBzaG91bGQgYmUgY2FsbGVkIHdpdGggYSBvZGQgbnVtYmVyIG9mIHBhcmFtZXRlcnMsIDMgb3IgZ3JlYXRlclxuICAgICAgVGhpcyB3b3JrcyBvbiB0aGUgcGF0dGVybjpcbiAgICAgIGlmKCAwICl7IDEgfWVsc2V7IDIgfTtcbiAgICAgIGlmKCAwICl7IDEgfWVsc2UgaWYoIDIgKXsgMyB9ZWxzZXsgNCB9O1xuICAgICAgaWYoIDAgKXsgMSB9ZWxzZSBpZiggMiApeyAzIH1lbHNlIGlmKCA0ICl7IDUgfWVsc2V7IDYgfTtcblxuICAgICAgVGhlIGltcGxlbWVudGF0aW9uIGlzOlxuICAgICAgRm9yIHBhaXJzIG9mIHZhbHVlcyAoMCwxIHRoZW4gMiwzIHRoZW4gNCw1IGV0YylcbiAgICAgIElmIHRoZSBmaXJzdCBldmFsdWF0ZXMgdHJ1dGh5LCBldmFsdWF0ZSBhbmQgcmV0dXJuIHRoZSBzZWNvbmRcbiAgICAgIElmIHRoZSBmaXJzdCBldmFsdWF0ZXMgZmFsc3ksIGp1bXAgdG8gdGhlIG5leHQgcGFpciAoZS5nLCAwLDEgdG8gMiwzKVxuICAgICAgZ2l2ZW4gb25lIHBhcmFtZXRlciwgZXZhbHVhdGUgYW5kIHJldHVybiBpdC4gKGl0J3MgYW4gRWxzZSBhbmQgYWxsIHRoZSBJZi9FbHNlSWYgd2VyZSBmYWxzZSlcbiAgICAgIGdpdmVuIDAgcGFyYW1ldGVycywgcmV0dXJuIE5VTEwgKG5vdCBncmVhdCBwcmFjdGljZSwgYnV0IHRoZXJlIHdhcyBubyBFbHNlKVxuICAgICAgKi9cbiAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoIC0gMTsgaSArPSAyKSB7XG4gICAgICAgIGlmICgganNvbkxvZ2ljLnRydXRoeSgganNvbkxvZ2ljLmFwcGx5KHZhbHVlc1tpXSwgZGF0YSkgKSApIHtcbiAgICAgICAgICByZXR1cm4ganNvbkxvZ2ljLmFwcGx5KHZhbHVlc1tpKzFdLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IGkrMSkge1xuICAgICAgICByZXR1cm4ganNvbkxvZ2ljLmFwcGx5KHZhbHVlc1tpXSwgZGF0YSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2UgaWYgKG9wID09PSBcImFuZFwiKSB7IC8vIFJldHVybiBmaXJzdCBmYWxzeSwgb3IgbGFzdFxuICAgICAgZm9yIChpPTA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKz0xKSB7XG4gICAgICAgIGN1cnJlbnQgPSBqc29uTG9naWMuYXBwbHkodmFsdWVzW2ldLCBkYXRhKTtcbiAgICAgICAgaWYgKCAhIGpzb25Mb2dpYy50cnV0aHkoY3VycmVudCkpIHtcbiAgICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGN1cnJlbnQ7IC8vIExhc3RcbiAgICB9IGVsc2UgaWYgKG9wID09PSBcIm9yXCIpIHsvLyBSZXR1cm4gZmlyc3QgdHJ1dGh5LCBvciBsYXN0XG4gICAgICBmb3IgKGk9MDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrPTEpIHtcbiAgICAgICAgY3VycmVudCA9IGpzb25Mb2dpYy5hcHBseSh2YWx1ZXNbaV0sIGRhdGEpO1xuICAgICAgICBpZiAoIGpzb25Mb2dpYy50cnV0aHkoY3VycmVudCkgKSB7XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjdXJyZW50OyAvLyBMYXN0XG4gICAgfSBlbHNlIGlmIChvcCA9PT0gXCJmaWx0ZXJcIikge1xuICAgICAgc2NvcGVkRGF0YSA9IGpzb25Mb2dpYy5hcHBseSh2YWx1ZXNbMF0sIGRhdGEpO1xuICAgICAgc2NvcGVkTG9naWMgPSB2YWx1ZXNbMV07XG5cbiAgICAgIGlmICggISBBcnJheS5pc0FycmF5KHNjb3BlZERhdGEpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIC8vIFJldHVybiBvbmx5IHRoZSBlbGVtZW50cyBmcm9tIHRoZSBhcnJheSBpbiB0aGUgZmlyc3QgYXJndW1lbnQsXG4gICAgICAvLyB0aGF0IHJldHVybiB0cnV0aHkgd2hlbiBwYXNzZWQgdG8gdGhlIGxvZ2ljIGluIHRoZSBzZWNvbmQgYXJndW1lbnQuXG4gICAgICAvLyBGb3IgcGFyaXR5IHdpdGggSmF2YVNjcmlwdCwgcmVpbmRleCB0aGUgcmV0dXJuZWQgYXJyYXlcbiAgICAgIHJldHVybiBzY29wZWREYXRhLmZpbHRlcihmdW5jdGlvbihkYXR1bSkge1xuICAgICAgICByZXR1cm4ganNvbkxvZ2ljLnRydXRoeSgganNvbkxvZ2ljLmFwcGx5KHNjb3BlZExvZ2ljLCBkYXR1bSkpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChvcCA9PT0gXCJtYXBcIikge1xuICAgICAgc2NvcGVkRGF0YSA9IGpzb25Mb2dpYy5hcHBseSh2YWx1ZXNbMF0sIGRhdGEpO1xuICAgICAgc2NvcGVkTG9naWMgPSB2YWx1ZXNbMV07XG5cbiAgICAgIGlmICggISBBcnJheS5pc0FycmF5KHNjb3BlZERhdGEpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNjb3BlZERhdGEubWFwKGZ1bmN0aW9uKGRhdHVtKSB7XG4gICAgICAgIHJldHVybiBqc29uTG9naWMuYXBwbHkoc2NvcGVkTG9naWMsIGRhdHVtKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAob3AgPT09IFwicmVkdWNlXCIpIHtcbiAgICAgIHNjb3BlZERhdGEgPSBqc29uTG9naWMuYXBwbHkodmFsdWVzWzBdLCBkYXRhKTtcbiAgICAgIHNjb3BlZExvZ2ljID0gdmFsdWVzWzFdO1xuICAgICAgaW5pdGlhbCA9IHR5cGVvZiB2YWx1ZXNbMl0gIT09IFwidW5kZWZpbmVkXCIgPyBqc29uTG9naWMuYXBwbHkodmFsdWVzWzJdLCBkYXRhKSA6IG51bGw7XG5cbiAgICAgIGlmICggISBBcnJheS5pc0FycmF5KHNjb3BlZERhdGEpKSB7XG4gICAgICAgIHJldHVybiBpbml0aWFsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2NvcGVkRGF0YS5yZWR1Y2UoXG4gICAgICAgIGZ1bmN0aW9uKGFjY3VtdWxhdG9yLCBjdXJyZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGpzb25Mb2dpYy5hcHBseShcbiAgICAgICAgICAgIHNjb3BlZExvZ2ljLFxuICAgICAgICAgICAge2N1cnJlbnQ6IGN1cnJlbnQsIGFjY3VtdWxhdG9yOiBhY2N1bXVsYXRvcn1cbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICBpbml0aWFsXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAob3AgPT09IFwiYWxsXCIpIHtcbiAgICAgIHNjb3BlZERhdGEgPSBqc29uTG9naWMuYXBwbHkodmFsdWVzWzBdLCBkYXRhKTtcbiAgICAgIHNjb3BlZExvZ2ljID0gdmFsdWVzWzFdO1xuICAgICAgLy8gQWxsIG9mIGFuIGVtcHR5IHNldCBpcyBmYWxzZS4gTm90ZSwgc29tZSBhbmQgbm9uZSBoYXZlIGNvcnJlY3QgZmFsbGJhY2sgYWZ0ZXIgdGhlIGZvciBsb29wXG4gICAgICBpZiAoICEgQXJyYXkuaXNBcnJheShzY29wZWREYXRhKSB8fCAhIHNjb3BlZERhdGEubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGZvciAoaT0wOyBpIDwgc2NvcGVkRGF0YS5sZW5ndGg7IGkrPTEpIHtcbiAgICAgICAgaWYgKCAhIGpzb25Mb2dpYy50cnV0aHkoIGpzb25Mb2dpYy5hcHBseShzY29wZWRMb2dpYywgc2NvcGVkRGF0YVtpXSkgKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gRmlyc3QgZmFsc3ksIHNob3J0IGNpcmN1aXRcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7IC8vIEFsbCB3ZXJlIHRydXRoeVxuICAgIH0gZWxzZSBpZiAob3AgPT09IFwibm9uZVwiKSB7XG4gICAgICBzY29wZWREYXRhID0ganNvbkxvZ2ljLmFwcGx5KHZhbHVlc1swXSwgZGF0YSk7XG4gICAgICBzY29wZWRMb2dpYyA9IHZhbHVlc1sxXTtcblxuICAgICAgaWYgKCAhIEFycmF5LmlzQXJyYXkoc2NvcGVkRGF0YSkgfHwgISBzY29wZWREYXRhLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGZvciAoaT0wOyBpIDwgc2NvcGVkRGF0YS5sZW5ndGg7IGkrPTEpIHtcbiAgICAgICAgaWYgKCBqc29uTG9naWMudHJ1dGh5KCBqc29uTG9naWMuYXBwbHkoc2NvcGVkTG9naWMsIHNjb3BlZERhdGFbaV0pICkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIEZpcnN0IHRydXRoeSwgc2hvcnQgY2lyY3VpdFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTsgLy8gTm9uZSB3ZXJlIHRydXRoeVxuICAgIH0gZWxzZSBpZiAob3AgPT09IFwic29tZVwiKSB7XG4gICAgICBzY29wZWREYXRhID0ganNvbkxvZ2ljLmFwcGx5KHZhbHVlc1swXSwgZGF0YSk7XG4gICAgICBzY29wZWRMb2dpYyA9IHZhbHVlc1sxXTtcblxuICAgICAgaWYgKCAhIEFycmF5LmlzQXJyYXkoc2NvcGVkRGF0YSkgfHwgISBzY29wZWREYXRhLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBmb3IgKGk9MDsgaSA8IHNjb3BlZERhdGEubGVuZ3RoOyBpKz0xKSB7XG4gICAgICAgIGlmICgganNvbkxvZ2ljLnRydXRoeSgganNvbkxvZ2ljLmFwcGx5KHNjb3BlZExvZ2ljLCBzY29wZWREYXRhW2ldKSApKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7IC8vIEZpcnN0IHRydXRoeSwgc2hvcnQgY2lyY3VpdFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7IC8vIE5vbmUgd2VyZSB0cnV0aHlcbiAgICB9XG5cbiAgICAvLyBFdmVyeW9uZSBlbHNlIGdldHMgaW1tZWRpYXRlIGRlcHRoLWZpcnN0IHJlY3Vyc2lvblxuICAgIHZhbHVlcyA9IHZhbHVlcy5tYXAoZnVuY3Rpb24odmFsKSB7XG4gICAgICByZXR1cm4ganNvbkxvZ2ljLmFwcGx5KHZhbCwgZGF0YSk7XG4gICAgfSk7XG5cblxuICAgIC8vIFRoZSBvcGVyYXRpb24gaXMgY2FsbGVkIHdpdGggXCJkYXRhXCIgYm91bmQgdG8gaXRzIFwidGhpc1wiIGFuZCBcInZhbHVlc1wiIHBhc3NlZCBhcyBhcmd1bWVudHMuXG4gICAgLy8gU3RydWN0dXJlZCBjb21tYW5kcyBsaWtlICUgb3IgPiBjYW4gbmFtZSBmb3JtYWwgYXJndW1lbnRzIHdoaWxlIGZsZXhpYmxlIGNvbW1hbmRzIChsaWtlIG1pc3Npbmcgb3IgbWVyZ2UpIGNhbiBvcGVyYXRlIG9uIHRoZSBwc2V1ZG8tYXJyYXkgYXJndW1lbnRzXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvRnVuY3Rpb25zL2FyZ3VtZW50c1xuICAgIGlmIChvcGVyYXRpb25zLmhhc093blByb3BlcnR5KG9wKSAmJiB0eXBlb2Ygb3BlcmF0aW9uc1tvcF0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIG9wZXJhdGlvbnNbb3BdLmFwcGx5KGRhdGEsIHZhbHVlcyk7XG4gICAgfSBlbHNlIGlmIChvcC5pbmRleE9mKFwiLlwiKSA+IDApIHsgLy8gQ29udGFpbnMgYSBkb3QsIGFuZCBub3QgaW4gdGhlIDB0aCBwb3NpdGlvblxuICAgICAgdmFyIHN1Yl9vcHMgPSBTdHJpbmcob3ApLnNwbGl0KFwiLlwiKTtcbiAgICAgIHZhciBvcGVyYXRpb24gPSBvcGVyYXRpb25zO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHN1Yl9vcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFvcGVyYXRpb24uaGFzT3duUHJvcGVydHkoc3ViX29wc1tpXSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgb3BlcmF0aW9uIFwiICsgb3AgK1xuICAgICAgICAgICAgXCIgKGZhaWxlZCBhdCBcIiArIHN1Yl9vcHMuc2xpY2UoMCwgaSsxKS5qb2luKFwiLlwiKSArIFwiKVwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEZXNjZW5kaW5nIGludG8gb3BlcmF0aW9uc1xuICAgICAgICBvcGVyYXRpb24gPSBvcGVyYXRpb25bc3ViX29wc1tpXV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvcGVyYXRpb24uYXBwbHkoZGF0YSwgdmFsdWVzKTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgb3BlcmF0aW9uIFwiICsgb3AgKTtcbiAgfTtcblxuICBqc29uTG9naWMudXNlc19kYXRhID0gZnVuY3Rpb24obG9naWMpIHtcbiAgICB2YXIgY29sbGVjdGlvbiA9IFtdO1xuXG4gICAgaWYgKGpzb25Mb2dpYy5pc19sb2dpYyhsb2dpYykpIHtcbiAgICAgIHZhciBvcCA9IGpzb25Mb2dpYy5nZXRfb3BlcmF0b3IobG9naWMpO1xuICAgICAgdmFyIHZhbHVlcyA9IGxvZ2ljW29wXTtcblxuICAgICAgaWYgKCAhIEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICB2YWx1ZXMgPSBbdmFsdWVzXTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wID09PSBcInZhclwiKSB7XG4gICAgICAgIC8vIFRoaXMgZG9lc24ndCBjb3ZlciB0aGUgY2FzZSB3aGVyZSB0aGUgYXJnIHRvIHZhciBpcyBpdHNlbGYgYSBydWxlLlxuICAgICAgICBjb2xsZWN0aW9uLnB1c2godmFsdWVzWzBdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJlY3Vyc2lvbiFcbiAgICAgICAgdmFsdWVzLmZvckVhY2goZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgY29sbGVjdGlvbi5wdXNoLmFwcGx5KGNvbGxlY3Rpb24sIGpzb25Mb2dpYy51c2VzX2RhdGEodmFsKSApO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXlVbmlxdWUoY29sbGVjdGlvbik7XG4gIH07XG5cbiAganNvbkxvZ2ljLmFkZF9vcGVyYXRpb24gPSBmdW5jdGlvbihuYW1lLCBjb2RlKSB7XG4gICAgb3BlcmF0aW9uc1tuYW1lXSA9IGNvZGU7XG4gIH07XG5cbiAganNvbkxvZ2ljLnJtX29wZXJhdGlvbiA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBkZWxldGUgb3BlcmF0aW9uc1tuYW1lXTtcbiAgfTtcblxuICBqc29uTG9naWMucnVsZV9saWtlID0gZnVuY3Rpb24ocnVsZSwgcGF0dGVybikge1xuICAgIC8vIGNvbnNvbGUubG9nKFwiSXMgXCIuIEpTT04uc3RyaW5naWZ5KHJ1bGUpIC4gXCIgbGlrZSBcIiAuIEpTT04uc3RyaW5naWZ5KHBhdHRlcm4pIC4gXCI/XCIpO1xuICAgIGlmIChwYXR0ZXJuID09PSBydWxlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IC8vIFRPRE8gOiBEZWVwIG9iamVjdCBlcXVpdmFsZW5jeT9cbiAgICBpZiAocGF0dGVybiA9PT0gXCJAXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gV2lsZGNhcmQhXG4gICAgaWYgKHBhdHRlcm4gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiAodHlwZW9mIHJ1bGUgPT09IFwibnVtYmVyXCIpO1xuICAgIH1cbiAgICBpZiAocGF0dGVybiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuICh0eXBlb2YgcnVsZSA9PT0gXCJzdHJpbmdcIik7XG4gICAgfVxuICAgIGlmIChwYXR0ZXJuID09PSBcImFycmF5XCIpIHtcbiAgICAgIC8vICFsb2dpYyB0ZXN0IG1pZ2h0IGJlIHN1cGVyZmx1b3VzIGluIEphdmFTY3JpcHRcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHJ1bGUpICYmICEganNvbkxvZ2ljLmlzX2xvZ2ljKHJ1bGUpO1xuICAgIH1cblxuICAgIGlmIChqc29uTG9naWMuaXNfbG9naWMocGF0dGVybikpIHtcbiAgICAgIGlmIChqc29uTG9naWMuaXNfbG9naWMocnVsZSkpIHtcbiAgICAgICAgdmFyIHBhdHRlcm5fb3AgPSBqc29uTG9naWMuZ2V0X29wZXJhdG9yKHBhdHRlcm4pO1xuICAgICAgICB2YXIgcnVsZV9vcCA9IGpzb25Mb2dpYy5nZXRfb3BlcmF0b3IocnVsZSk7XG5cbiAgICAgICAgaWYgKHBhdHRlcm5fb3AgPT09IFwiQFwiIHx8IHBhdHRlcm5fb3AgPT09IHJ1bGVfb3ApIHtcbiAgICAgICAgICAvLyBlY2hvIFwiXFxuT3BlcmF0b3JzIG1hdGNoLCBnbyBkZWVwZXJcXG5cIjtcbiAgICAgICAgICByZXR1cm4ganNvbkxvZ2ljLnJ1bGVfbGlrZShcbiAgICAgICAgICAgIGpzb25Mb2dpYy5nZXRfdmFsdWVzKHJ1bGUsIGZhbHNlKSxcbiAgICAgICAgICAgIGpzb25Mb2dpYy5nZXRfdmFsdWVzKHBhdHRlcm4sIGZhbHNlKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTsgLy8gcGF0dGVybiBpcyBsb2dpYywgcnVsZSBpc24ndCwgY2FuJ3QgYmUgZXFcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShwYXR0ZXJuKSkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocnVsZSkpIHtcbiAgICAgICAgaWYgKHBhdHRlcm4ubGVuZ3RoICE9PSBydWxlLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvKlxuICAgICAgICAgIE5vdGUsIGFycmF5IG9yZGVyIE1BVFRFUlMsIGJlY2F1c2Ugd2UncmUgdXNpbmcgdGhpcyBhcnJheSB0ZXN0IGxvZ2ljIHRvIGNvbnNpZGVyIGFyZ3VtZW50cywgd2hlcmUgb3JkZXIgY2FuIG1hdHRlci4gKGUuZy4sICsgaXMgY29tbXV0YXRpdmUsIGJ1dCAnLScgb3IgJ2lmJyBvciAndmFyJyBhcmUgTk9UKVxuICAgICAgICAqL1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdHRlcm4ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAvLyBJZiBhbnkgZmFpbCwgd2UgZmFpbFxuICAgICAgICAgIGlmICggISBqc29uTG9naWMucnVsZV9saWtlKHJ1bGVbaV0sIHBhdHRlcm5baV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBJZiB0aGV5ICphbGwqIHBhc3NlZCwgd2UgcGFzc1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBQYXR0ZXJuIGlzIGFycmF5LCBydWxlIGlzbid0XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTm90IGxvZ2ljLCBub3QgYXJyYXksIG5vdCBhID09PSBtYXRjaCBmb3IgcnVsZS5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgcmV0dXJuIGpzb25Mb2dpYztcbn0pKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/json-logic-js/logic.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/polyfills/fetch/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/fetch/index.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* globals self */ \nconst fetchModule = self.fetch.bind(self);\nmodule.exports = fetchModule;\nmodule.exports[\"default\"] = module.exports;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL2ZldGNoL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLG1CQUFnQztBQUNoQztBQUNBO0FBQ0EseUJBQXNCOztBQUV0QiIsInNvdXJjZXMiOlsiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvV29uZGVyVml0ZS1mcm9udGVuZC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3BvbHlmaWxscy9mZXRjaC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWxzIHNlbGYgKi8gXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBmZXRjaE1vZHVsZSA9IHNlbGYuZmV0Y2guYmluZChzZWxmKTtcbm1vZHVsZS5leHBvcnRzID0gZmV0Y2hNb2R1bGU7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/polyfills/fetch/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/pascalcase/index.js":
/*!******************************************!*\
  !*** ./node_modules/pascalcase/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("/*!\n * pascalcase <https://github.com/jonschlinkert/pascalcase>\n *\n * Copyright (c) 2015-present, Jon (\"Schlink\") Schlinkert.\n * Licensed under the MIT License.\n */\n\nconst titlecase = input => input[0].toLocaleUpperCase() + input.slice(1);\n\nmodule.exports = value => {\n  if (value === null || value === void 0) return '';\n  if (typeof value.toString !== 'function') return '';\n\n  let input = value.toString().trim();\n  if (input === '') return '';\n  if (input.length === 1) return input.toLocaleUpperCase();\n\n  let match = input.match(/[a-zA-Z0-9]+/g);\n  if (match) {\n    return match.map(m => titlecase(m)).join('');\n  }\n\n  return input;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wYXNjYWxjYXNlL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL1dvbmRlclZpdGUtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL3Bhc2NhbGNhc2UvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBwYXNjYWxjYXNlIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9wYXNjYWxjYXNlPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNS1wcmVzZW50LCBKb24gKFwiU2NobGlua1wiKSBTY2hsaW5rZXJ0LlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbmNvbnN0IHRpdGxlY2FzZSA9IGlucHV0ID0+IGlucHV0WzBdLnRvTG9jYWxlVXBwZXJDYXNlKCkgKyBpbnB1dC5zbGljZSgxKTtcblxubW9kdWxlLmV4cG9ydHMgPSB2YWx1ZSA9PiB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCAwKSByZXR1cm4gJyc7XG4gIGlmICh0eXBlb2YgdmFsdWUudG9TdHJpbmcgIT09ICdmdW5jdGlvbicpIHJldHVybiAnJztcblxuICBsZXQgaW5wdXQgPSB2YWx1ZS50b1N0cmluZygpLnRyaW0oKTtcbiAgaWYgKGlucHV0ID09PSAnJykgcmV0dXJuICcnO1xuICBpZiAoaW5wdXQubGVuZ3RoID09PSAxKSByZXR1cm4gaW5wdXQudG9Mb2NhbGVVcHBlckNhc2UoKTtcblxuICBsZXQgbWF0Y2ggPSBpbnB1dC5tYXRjaCgvW2EtekEtWjAtOV0rL2cpO1xuICBpZiAobWF0Y2gpIHtcbiAgICByZXR1cm4gbWF0Y2gubWFwKG0gPT4gdGl0bGVjYXNlKG0pKS5qb2luKCcnKTtcbiAgfVxuXG4gIHJldHVybiBpbnB1dDtcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/pascalcase/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/base64-js/index.js":
/*!*********************************************!*\
  !*** ../../node_modules/base64-js/index.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGtCQUFrQjtBQUNsQixtQkFBbUI7QUFDbkIscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUMsU0FBUztBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDLFVBQVU7QUFDckQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbi8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy5cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0I1VSTF9hcHBsaWNhdGlvbnNcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIGdldExlbnMgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyBUcmltIG9mZiBleHRyYSBieXRlcyBhZnRlciBwbGFjZWhvbGRlciBieXRlcyBhcmUgZm91bmRcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYmVhdGdhbW1pdC9iYXNlNjQtanMvaXNzdWVzLzQyXG4gIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKCc9JylcbiAgaWYgKHZhbGlkTGVuID09PSAtMSkgdmFsaWRMZW4gPSBsZW5cblxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlblxuICAgID8gMFxuICAgIDogNCAtICh2YWxpZExlbiAlIDQpXG5cbiAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXVxufVxuXG4vLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiBfYnl0ZUxlbmd0aCAoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuXG4gIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpXG5cbiAgdmFyIGN1ckJ5dGUgPSAwXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICB2YXIgbGVuID0gcGxhY2VIb2xkZXJzTGVuID4gMFxuICAgID8gdmFsaWRMZW4gLSA0XG4gICAgOiB2YWxpZExlblxuXG4gIHZhciBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/base64-js/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/buffer/index.js":
/*!******************************************!*\
  !*** ../../node_modules/buffer/index.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nconst base64 = __webpack_require__(/*! base64-js */ \"(app-pages-browser)/../../node_modules/base64-js/index.js\")\nconst ieee754 = __webpack_require__(/*! ieee754 */ \"(app-pages-browser)/../../node_modules/ieee754/index.js\")\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVZOztBQUVaLGVBQWUsbUJBQU8sQ0FBQyw0RUFBVztBQUNsQyxnQkFBZ0IsbUJBQU8sQ0FBQyx3RUFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Qsa0JBQWtCO0FBQ2xCLHlCQUF5Qjs7QUFFekI7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxpQkFBaUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsRUFBRTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixlQUFlO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EscUJBQXFCLFdBQVcsR0FBRyxJQUFJO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsZ0JBQWdCLFdBQVcsR0FBRyxJQUFJLEtBQUssYUFBYTtBQUNwRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEI7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1CQUFtQixLQUFLLG1EQUFtRCxjQUFjO0FBQ3pGLEdBQUc7QUFDSDtBQUNBO0FBQ0EsK0JBQStCLElBQUk7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixNQUFNLGFBQWEsU0FBUztBQUN0RDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGdCQUFnQjtBQUN6QixjQUFjLG9CQUFvQixFQUFFLElBQUk7QUFDeEM7QUFDQSxZQUFZLGdCQUFnQixFQUFFLElBQUk7QUFDbEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLEdBQUcsU0FBUyxHQUFHLEtBQUsscUJBQXFCLEVBQUUsRUFBRTtBQUNwRSxRQUFRO0FBQ1IseUJBQXlCLEdBQUcsS0FBSyx5QkFBeUIsRUFBRSxFQUFFO0FBQzlELG1CQUFtQix5QkFBeUIsRUFBRSxFQUFFO0FBQ2hEO0FBQ0EsTUFBTTtBQUNOLG9CQUFvQixJQUFJLEVBQUUsR0FBRyxTQUFTLElBQUksRUFBRSxFQUFFO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQyxjQUFjLFNBQVMsT0FBTztBQUN4RTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixZQUFZO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvd29uZGVybGFuZG1pdGNoL25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxuY29uc3QgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbmNvbnN0IGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbmNvbnN0IGN1c3RvbUluc3BlY3RTeW1ib2wgPVxuICAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sWydmb3InXSA9PT0gJ2Z1bmN0aW9uJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICA/IFN5bWJvbFsnZm9yJ10oJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICA6IG51bGxcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG5jb25zdCBLX01BWF9MRU5HVEggPSAweDdmZmZmZmZmXG5leHBvcnRzLmtNYXhMZW5ndGggPSBLX01BWF9MRU5HVEhcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgUHJpbnQgd2FybmluZyBhbmQgcmVjb21tZW5kIHVzaW5nIGBidWZmZXJgIHY0Lnggd2hpY2ggaGFzIGFuIE9iamVjdFxuICogICAgICAgICAgICAgICBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogV2UgcmVwb3J0IHRoYXQgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0eXBlZCBhcnJheXMgaWYgdGhlIGFyZSBub3Qgc3ViY2xhc3NhYmxlXG4gKiB1c2luZyBfX3Byb3RvX18uIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgXG4gKiAoU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzgpLiBJRSAxMCBsYWNrcyBzdXBwb3J0XG4gKiBmb3IgX19wcm90b19fIGFuZCBoYXMgYSBidWdneSB0eXBlZCBhcnJheSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbmlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgY29uc29sZS5lcnJvcihcbiAgICAnVGhpcyBicm93c2VyIGxhY2tzIHR5cGVkIGFycmF5IChVaW50OEFycmF5KSBzdXBwb3J0IHdoaWNoIGlzIHJlcXVpcmVkIGJ5ICcgK1xuICAgICdgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LidcbiAgKVxufVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIC8vIENhbiB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZD9cbiAgdHJ5IHtcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGNvbnN0IHByb3RvID0geyBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH0gfVxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihwcm90bywgVWludDhBcnJheS5wcm90b3R5cGUpXG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGFyciwgcHJvdG8pXG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDJcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAncGFyZW50Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ1ZmZlclxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ29mZnNldCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5ieXRlT2Zmc2V0XG4gIH1cbn0pXG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAobGVuZ3RoKSB7XG4gIGlmIChsZW5ndGggPiBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIGxlbmd0aCArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIGNvbnN0IGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGJ1ZiwgQnVmZmVyLnByb3RvdHlwZSlcbiAgcmV0dXJuIGJ1ZlxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgc3RyaW5nLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKGFyZylcbiAgfVxuICByZXR1cm4gZnJvbShhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbmZ1bmN0aW9uIGZyb20gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheVZpZXcodmFsdWUpXG4gIH1cblxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gICAgKVxuICB9XG5cbiAgaWYgKGlzSW5zdGFuY2UodmFsdWUsIEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBBcnJheUJ1ZmZlcikpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIChpc0luc3RhbmNlKHZhbHVlLCBTaGFyZWRBcnJheUJ1ZmZlcikgfHxcbiAgICAgICh2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgU2hhcmVkQXJyYXlCdWZmZXIpKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgKVxuICB9XG5cbiAgY29uc3QgdmFsdWVPZiA9IHZhbHVlLnZhbHVlT2YgJiYgdmFsdWUudmFsdWVPZigpXG4gIGlmICh2YWx1ZU9mICE9IG51bGwgJiYgdmFsdWVPZiAhPT0gdmFsdWUpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWVPZiwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgY29uc3QgYiA9IGZyb21PYmplY3QodmFsdWUpXG4gIGlmIChiKSByZXR1cm4gYlxuXG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9QcmltaXRpdmUgIT0gbnVsbCAmJlxuICAgICAgdHlwZW9mIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSgnc3RyaW5nJyksIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIE5vdGU6IENoYW5nZSBwcm90b3R5cGUgKmFmdGVyKiBCdWZmZXIuZnJvbSBpcyBkZWZpbmVkIHRvIHdvcmthcm91bmQgQ2hyb21lIGJ1Zzpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvMTQ4XG5PYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLnByb3RvdHlwZSwgVWludDhBcnJheS5wcm90b3R5cGUpXG5PYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLCBVaW50OEFycmF5KVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgc2l6ZSArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAoc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gIH1cblxuICBjb25zdCBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICBsZXQgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcblxuICBjb25zdCBhY3R1YWwgPSBidWYud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIGJ1ZiA9IGJ1Zi5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKGFycmF5KSB7XG4gIGNvbnN0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICBjb25zdCBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgYnVmW2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheVZpZXcgKGFycmF5Vmlldykge1xuICBpZiAoaXNJbnN0YW5jZShhcnJheVZpZXcsIFVpbnQ4QXJyYXkpKSB7XG4gICAgY29uc3QgY29weSA9IG5ldyBVaW50OEFycmF5KGFycmF5VmlldylcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKGNvcHkuYnVmZmVyLCBjb3B5LmJ5dGVPZmZzZXQsIGNvcHkuYnl0ZUxlbmd0aClcbiAgfVxuICByZXR1cm4gZnJvbUFycmF5TGlrZShhcnJheVZpZXcpXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJvZmZzZXRcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcImxlbmd0aFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBsZXQgYnVmXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYnVmLCBCdWZmZXIucHJvdG90eXBlKVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAob2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIGNvbnN0IGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgY29uc3QgYnVmID0gY3JlYXRlQnVmZmVyKGxlbilcblxuICAgIGlmIChidWYubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYnVmXG4gICAgfVxuXG4gICAgb2JqLmNvcHkoYnVmLCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgbnVtYmVySXNOYU4ob2JqLmxlbmd0aCkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoMClcbiAgICB9XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqKVxuICB9XG5cbiAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iai5kYXRhKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBLX01BWF9MRU5HVEhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIEtfTUFYX0xFTkdUSC50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuIGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlciA9PT0gdHJ1ZSAmJlxuICAgIGIgIT09IEJ1ZmZlci5wcm90b3R5cGUgLy8gc28gQnVmZmVyLmlzQnVmZmVyKEJ1ZmZlci5wcm90b3R5cGUpIHdpbGwgYmUgZmFsc2Vcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmIChpc0luc3RhbmNlKGEsIFVpbnQ4QXJyYXkpKSBhID0gQnVmZmVyLmZyb20oYSwgYS5vZmZzZXQsIGEuYnl0ZUxlbmd0aClcbiAgaWYgKGlzSW5zdGFuY2UoYiwgVWludDhBcnJheSkpIGIgPSBCdWZmZXIuZnJvbShiLCBiLm9mZnNldCwgYi5ieXRlTGVuZ3RoKVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJidWYxXCIsIFwiYnVmMlwiIGFyZ3VtZW50cyBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5J1xuICAgIClcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIGxldCB4ID0gYS5sZW5ndGhcbiAgbGV0IHkgPSBiLmxlbmd0aFxuXG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgbGV0IGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICBsZXQgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIGxldCBidWYgPSBsaXN0W2ldXG4gICAgaWYgKGlzSW5zdGFuY2UoYnVmLCBVaW50OEFycmF5KSkge1xuICAgICAgaWYgKHBvcyArIGJ1Zi5sZW5ndGggPiBidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIGJ1ZiA9IEJ1ZmZlci5mcm9tKGJ1ZilcbiAgICAgICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgICAgICBidWZmZXIsXG4gICAgICAgICAgYnVmLFxuICAgICAgICAgIHBvc1xuICAgICAgICApXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIH1cbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBpc0luc3RhbmNlKHN0cmluZywgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBvciBBcnJheUJ1ZmZlci4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIHN0cmluZ1xuICAgIClcbiAgfVxuXG4gIGNvbnN0IGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgY29uc3QgbXVzdE1hdGNoID0gKGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSA9PT0gdHJ1ZSlcbiAgaWYgKCFtdXN0TWF0Y2ggJiYgbGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICBsZXQgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB7XG4gICAgICAgICAgcmV0dXJuIG11c3RNYXRjaCA/IC0xIDogdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgbGV0IGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJjaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCAoYW5kIHRoZSBgaXMtYnVmZmVyYCBucG0gcGFja2FnZSlcbi8vIHRvIGRldGVjdCBhIEJ1ZmZlciBpbnN0YW5jZS4gSXQncyBub3QgcG9zc2libGUgdG8gdXNlIGBpbnN0YW5jZW9mIEJ1ZmZlcmBcbi8vIHJlbGlhYmx5IGluIGEgYnJvd3NlcmlmeSBjb250ZXh0IGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgZGlmZmVyZW50XG4vLyBjb3BpZXMgb2YgdGhlICdidWZmZXInIHBhY2thZ2UgaW4gdXNlLiBUaGlzIG1ldGhvZCB3b3JrcyBldmVuIGZvciBCdWZmZXJcbi8vIGluc3RhbmNlcyB0aGF0IHdlcmUgY3JlYXRlZCBmcm9tIGFub3RoZXIgY29weSBvZiB0aGUgYGJ1ZmZlcmAgcGFja2FnZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE1NFxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgY29uc3QgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgY29uc3QgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcgPSBCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nXG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgbGV0IHN0ciA9ICcnXG4gIGNvbnN0IG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5yZXBsYWNlKC8oLnsyfSkvZywgJyQxICcpLnRyaW0oKVxuICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5pZiAoY3VzdG9tSW5zcGVjdFN5bWJvbCkge1xuICBCdWZmZXIucHJvdG90eXBlW2N1c3RvbUluc3BlY3RTeW1ib2xdID0gQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmIChpc0luc3RhbmNlKHRhcmdldCwgVWludDhBcnJheSkpIHtcbiAgICB0YXJnZXQgPSBCdWZmZXIuZnJvbSh0YXJnZXQsIHRhcmdldC5vZmZzZXQsIHRhcmdldC5ieXRlTGVuZ3RoKVxuICB9XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInRhcmdldFwiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXkuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdGFyZ2V0KVxuICAgIClcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIGxldCB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICBsZXQgeSA9IGVuZCAtIHN0YXJ0XG4gIGNvbnN0IGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgY29uc3QgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgY29uc3QgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKG51bWJlcklzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgW3ZhbF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIGxldCBpbmRleFNpemUgPSAxXG4gIGxldCBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIGxldCB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIGxldCBpXG4gIGlmIChkaXIpIHtcbiAgICBsZXQgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBsZXQgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIGNvbnN0IHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBsZXQgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKG51bWJlcklzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggPj4+IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICBjb25zdCByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIGxldCBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgY29uc3QgcmVzID0gW11cblxuICBsZXQgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgY29uc3QgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgbGV0IGNvZGVQb2ludCA9IG51bGxcbiAgICBsZXQgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKVxuICAgICAgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKVxuICAgICAgICAgID8gM1xuICAgICAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpXG4gICAgICAgICAgICAgID8gMlxuICAgICAgICAgICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIGxldCBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbmNvbnN0IE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICBjb25zdCBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIGxldCByZXMgPSAnJ1xuICBsZXQgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgbGV0IHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGxldCByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGNvbnN0IGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICBsZXQgb3V0ID0gJydcbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gaGV4U2xpY2VMb29rdXBUYWJsZVtidWZbaV1dXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBjb25zdCBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICBsZXQgcmVzID0gJydcbiAgLy8gSWYgYnl0ZXMubGVuZ3RoIGlzIG9kZCwgdGhlIGxhc3QgOCBiaXRzIG11c3QgYmUgaWdub3JlZCAoc2FtZSBhcyBub2RlLmpzKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aCAtIDE7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgKGJ5dGVzW2kgKyAxXSAqIDI1NikpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICBjb25zdCBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihuZXdCdWYsIEJ1ZmZlci5wcm90b3R5cGUpXG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludExFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0XVxuICBsZXQgbXVsID0gMVxuICBsZXQgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50QkUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICBsZXQgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIGxldCBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDggPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDE2TEUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MTZCRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQzMkxFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDMyQkUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkQmlnVUludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ1VJbnQ2NExFIChvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdXG4gIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddXG4gIGlmIChmaXJzdCA9PT0gdW5kZWZpbmVkIHx8IGxhc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KVxuICB9XG5cbiAgY29uc3QgbG8gPSBmaXJzdCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDI0XG5cbiAgY29uc3QgaGkgPSB0aGlzWysrb2Zmc2V0XSArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgbGFzdCAqIDIgKiogMjRcblxuICByZXR1cm4gQmlnSW50KGxvKSArIChCaWdJbnQoaGkpIDw8IEJpZ0ludCgzMikpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRCaWdVSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnVUludDY0QkUgKG9mZnNldCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF1cbiAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN11cbiAgaWYgKGZpcnN0ID09PSB1bmRlZmluZWQgfHwgbGFzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpXG4gIH1cblxuICBjb25zdCBoaSA9IGZpcnN0ICogMiAqKiAyNCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF1cblxuICBjb25zdCBsbyA9IHRoaXNbKytvZmZzZXRdICogMiAqKiAyNCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgbGFzdFxuXG4gIHJldHVybiAoQmlnSW50KGhpKSA8PCBCaWdJbnQoMzIpKSArIEJpZ0ludChsbylcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIGxldCB2YWwgPSB0aGlzW29mZnNldF1cbiAgbGV0IG11bCA9IDFcbiAgbGV0IGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICBsZXQgaSA9IGJ5dGVMZW5ndGhcbiAgbGV0IG11bCA9IDFcbiAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIGNvbnN0IHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICBjb25zdCB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkQmlnSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnSW50NjRMRSAob2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XVxuICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XVxuICBpZiAoZmlyc3QgPT09IHVuZGVmaW5lZCB8fCBsYXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOClcbiAgfVxuXG4gIGNvbnN0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgNF0gK1xuICAgIHRoaXNbb2Zmc2V0ICsgNV0gKiAyICoqIDggK1xuICAgIHRoaXNbb2Zmc2V0ICsgNl0gKiAyICoqIDE2ICtcbiAgICAobGFzdCA8PCAyNCkgLy8gT3ZlcmZsb3dcblxuICByZXR1cm4gKEJpZ0ludCh2YWwpIDw8IEJpZ0ludCgzMikpICtcbiAgICBCaWdJbnQoZmlyc3QgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAyNClcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ0ludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ0ludDY0QkUgKG9mZnNldCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF1cbiAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN11cbiAgaWYgKGZpcnN0ID09PSB1bmRlZmluZWQgfHwgbGFzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpXG4gIH1cblxuICBjb25zdCB2YWwgPSAoZmlyc3QgPDwgMjQpICsgLy8gT3ZlcmZsb3dcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XVxuXG4gIHJldHVybiAoQmlnSW50KHZhbCkgPDwgQmlnSW50KDMyKSkgK1xuICAgIEJpZ0ludCh0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjQgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIGxhc3QpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnRMRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY29uc3QgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICBsZXQgbXVsID0gMVxuICBsZXQgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludEJFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjb25zdCBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIGxldCBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgbGV0IG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50OCA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQxNkxFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MTZCRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDMyTEUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQzMkJFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIHdydEJpZ1VJbnQ2NExFIChidWYsIHZhbHVlLCBvZmZzZXQsIG1pbiwgbWF4KSB7XG4gIGNoZWNrSW50QkkodmFsdWUsIG1pbiwgbWF4LCBidWYsIG9mZnNldCwgNylcblxuICBsZXQgbG8gPSBOdW1iZXIodmFsdWUgJiBCaWdJbnQoMHhmZmZmZmZmZikpXG4gIGJ1ZltvZmZzZXQrK10gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0KytdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBsb1xuICBsZXQgaGkgPSBOdW1iZXIodmFsdWUgPj4gQmlnSW50KDMyKSAmIEJpZ0ludCgweGZmZmZmZmZmKSlcbiAgYnVmW29mZnNldCsrXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0KytdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGhpXG4gIHJldHVybiBvZmZzZXRcbn1cblxuZnVuY3Rpb24gd3J0QmlnVUludDY0QkUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbWluLCBtYXgpIHtcbiAgY2hlY2tJbnRCSSh2YWx1ZSwgbWluLCBtYXgsIGJ1Ziwgb2Zmc2V0LCA3KVxuXG4gIGxldCBsbyA9IE51bWJlcih2YWx1ZSAmIEJpZ0ludCgweGZmZmZmZmZmKSlcbiAgYnVmW29mZnNldCArIDddID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQgKyA2XSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0ICsgNV0gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCArIDRdID0gbG9cbiAgbGV0IGhpID0gTnVtYmVyKHZhbHVlID4+IEJpZ0ludCgzMikgJiBCaWdJbnQoMHhmZmZmZmZmZikpXG4gIGJ1ZltvZmZzZXQgKyAzXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0ICsgMl0gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCArIDFdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXRdID0gaGlcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ1VJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnVUludDY0TEUgKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIHJldHVybiB3cnRCaWdVSW50NjRMRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBCaWdJbnQoMCksIEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmJykpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlQmlnVUludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdVSW50NjRCRSAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgcmV0dXJuIHdydEJpZ1VJbnQ2NEJFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIEJpZ0ludCgwKSwgQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmYnKSlcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY29uc3QgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgbGV0IGkgPSAwXG4gIGxldCBtdWwgPSAxXG4gIGxldCBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY29uc3QgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgbGV0IGkgPSBieXRlTGVuZ3RoIC0gMVxuICBsZXQgbXVsID0gMVxuICBsZXQgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ0ludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdJbnQ2NExFICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICByZXR1cm4gd3J0QmlnVUludDY0TEUodGhpcywgdmFsdWUsIG9mZnNldCwgLUJpZ0ludCgnMHg4MDAwMDAwMDAwMDAwMDAwJyksIEJpZ0ludCgnMHg3ZmZmZmZmZmZmZmZmZmZmJykpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlQmlnSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ0ludDY0QkUgKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIHJldHVybiB3cnRCaWdVSW50NjRCRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAtQmlnSW50KCcweDgwMDAwMDAwMDAwMDAwMDAnKSwgQmlnSW50KCcweDdmZmZmZmZmZmZmZmZmZmYnKSlcbn0pXG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlcicpXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICBjb25zdCBsZW4gPSBlbmQgLSBzdGFydFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBVc2UgYnVpbHQtaW4gd2hlbiBhdmFpbGFibGUsIG1pc3NpbmcgZnJvbSBJRTExXG4gICAgdGhpcy5jb3B5V2l0aGluKHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbnN0IGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKChlbmNvZGluZyA9PT0gJ3V0ZjgnICYmIGNvZGUgPCAxMjgpIHx8XG4gICAgICAgICAgZW5jb2RpbmcgPT09ICdsYXRpbjEnKSB7XG4gICAgICAgIC8vIEZhc3QgcGF0aDogSWYgYHZhbGAgZml0cyBpbnRvIGEgc2luZ2xlIGJ5dGUsIHVzZSB0aGF0IG51bWVyaWMgdmFsdWUuXG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnYm9vbGVhbicpIHtcbiAgICB2YWwgPSBOdW1iZXIodmFsKVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIGxldCBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgICBjb25zdCBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgXCInICsgdmFsICtcbiAgICAgICAgJ1wiIGlzIGludmFsaWQgZm9yIGFyZ3VtZW50IFwidmFsdWVcIicpXG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIENVU1RPTSBFUlJPUlNcbi8vID09PT09PT09PT09PT1cblxuLy8gU2ltcGxpZmllZCB2ZXJzaW9ucyBmcm9tIE5vZGUsIGNoYW5nZWQgZm9yIEJ1ZmZlci1vbmx5IHVzYWdlXG5jb25zdCBlcnJvcnMgPSB7fVxuZnVuY3Rpb24gRSAoc3ltLCBnZXRNZXNzYWdlLCBCYXNlKSB7XG4gIGVycm9yc1tzeW1dID0gY2xhc3MgTm9kZUVycm9yIGV4dGVuZHMgQmFzZSB7XG4gICAgY29uc3RydWN0b3IgKCkge1xuICAgICAgc3VwZXIoKVxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ21lc3NhZ2UnLCB7XG4gICAgICAgIHZhbHVlOiBnZXRNZXNzYWdlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pXG5cbiAgICAgIC8vIEFkZCB0aGUgZXJyb3IgY29kZSB0byB0aGUgbmFtZSB0byBpbmNsdWRlIGl0IGluIHRoZSBzdGFjayB0cmFjZS5cbiAgICAgIHRoaXMubmFtZSA9IGAke3RoaXMubmFtZX0gWyR7c3ltfV1gXG4gICAgICAvLyBBY2Nlc3MgdGhlIHN0YWNrIHRvIGdlbmVyYXRlIHRoZSBlcnJvciBtZXNzYWdlIGluY2x1ZGluZyB0aGUgZXJyb3IgY29kZVxuICAgICAgLy8gZnJvbSB0aGUgbmFtZS5cbiAgICAgIHRoaXMuc3RhY2sgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcbiAgICAgIC8vIFJlc2V0IHRoZSBuYW1lIHRvIHRoZSBhY3R1YWwgbmFtZS5cbiAgICAgIGRlbGV0ZSB0aGlzLm5hbWVcbiAgICB9XG5cbiAgICBnZXQgY29kZSAoKSB7XG4gICAgICByZXR1cm4gc3ltXG4gICAgfVxuXG4gICAgc2V0IGNvZGUgKHZhbHVlKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2NvZGUnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9KVxuICAgIH1cblxuICAgIHRvU3RyaW5nICgpIHtcbiAgICAgIHJldHVybiBgJHt0aGlzLm5hbWV9IFske3N5bX1dOiAke3RoaXMubWVzc2FnZX1gXG4gICAgfVxuICB9XG59XG5cbkUoJ0VSUl9CVUZGRVJfT1VUX09GX0JPVU5EUycsXG4gIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiBgJHtuYW1lfSBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHNgXG4gICAgfVxuXG4gICAgcmV0dXJuICdBdHRlbXB0IHRvIGFjY2VzcyBtZW1vcnkgb3V0c2lkZSBidWZmZXIgYm91bmRzJ1xuICB9LCBSYW5nZUVycm9yKVxuRSgnRVJSX0lOVkFMSURfQVJHX1RZUEUnLFxuICBmdW5jdGlvbiAobmFtZSwgYWN0dWFsKSB7XG4gICAgcmV0dXJuIGBUaGUgXCIke25hbWV9XCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSAke3R5cGVvZiBhY3R1YWx9YFxuICB9LCBUeXBlRXJyb3IpXG5FKCdFUlJfT1VUX09GX1JBTkdFJyxcbiAgZnVuY3Rpb24gKHN0ciwgcmFuZ2UsIGlucHV0KSB7XG4gICAgbGV0IG1zZyA9IGBUaGUgdmFsdWUgb2YgXCIke3N0cn1cIiBpcyBvdXQgb2YgcmFuZ2UuYFxuICAgIGxldCByZWNlaXZlZCA9IGlucHV0XG4gICAgaWYgKE51bWJlci5pc0ludGVnZXIoaW5wdXQpICYmIE1hdGguYWJzKGlucHV0KSA+IDIgKiogMzIpIHtcbiAgICAgIHJlY2VpdmVkID0gYWRkTnVtZXJpY2FsU2VwYXJhdG9yKFN0cmluZyhpbnB1dCkpXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdiaWdpbnQnKSB7XG4gICAgICByZWNlaXZlZCA9IFN0cmluZyhpbnB1dClcbiAgICAgIGlmIChpbnB1dCA+IEJpZ0ludCgyKSAqKiBCaWdJbnQoMzIpIHx8IGlucHV0IDwgLShCaWdJbnQoMikgKiogQmlnSW50KDMyKSkpIHtcbiAgICAgICAgcmVjZWl2ZWQgPSBhZGROdW1lcmljYWxTZXBhcmF0b3IocmVjZWl2ZWQpXG4gICAgICB9XG4gICAgICByZWNlaXZlZCArPSAnbidcbiAgICB9XG4gICAgbXNnICs9IGAgSXQgbXVzdCBiZSAke3JhbmdlfS4gUmVjZWl2ZWQgJHtyZWNlaXZlZH1gXG4gICAgcmV0dXJuIG1zZ1xuICB9LCBSYW5nZUVycm9yKVxuXG5mdW5jdGlvbiBhZGROdW1lcmljYWxTZXBhcmF0b3IgKHZhbCkge1xuICBsZXQgcmVzID0gJydcbiAgbGV0IGkgPSB2YWwubGVuZ3RoXG4gIGNvbnN0IHN0YXJ0ID0gdmFsWzBdID09PSAnLScgPyAxIDogMFxuICBmb3IgKDsgaSA+PSBzdGFydCArIDQ7IGkgLT0gMykge1xuICAgIHJlcyA9IGBfJHt2YWwuc2xpY2UoaSAtIDMsIGkpfSR7cmVzfWBcbiAgfVxuICByZXR1cm4gYCR7dmFsLnNsaWNlKDAsIGkpfSR7cmVzfWBcbn1cblxuLy8gQ0hFQ0sgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT1cblxuZnVuY3Rpb24gY2hlY2tCb3VuZHMgKGJ1Ziwgb2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGlmIChidWZbb2Zmc2V0XSA9PT0gdW5kZWZpbmVkIHx8IGJ1ZltvZmZzZXQgKyBieXRlTGVuZ3RoXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCBidWYubGVuZ3RoIC0gKGJ5dGVMZW5ndGggKyAxKSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0ludEJJICh2YWx1ZSwgbWluLCBtYXgsIGJ1Ziwgb2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikge1xuICAgIGNvbnN0IG4gPSB0eXBlb2YgbWluID09PSAnYmlnaW50JyA/ICduJyA6ICcnXG4gICAgbGV0IHJhbmdlXG4gICAgaWYgKGJ5dGVMZW5ndGggPiAzKSB7XG4gICAgICBpZiAobWluID09PSAwIHx8IG1pbiA9PT0gQmlnSW50KDApKSB7XG4gICAgICAgIHJhbmdlID0gYD49IDAke259IGFuZCA8IDIke259ICoqICR7KGJ5dGVMZW5ndGggKyAxKSAqIDh9JHtufWBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJhbmdlID0gYD49IC0oMiR7bn0gKiogJHsoYnl0ZUxlbmd0aCArIDEpICogOCAtIDF9JHtufSkgYW5kIDwgMiAqKiBgICtcbiAgICAgICAgICAgICAgICBgJHsoYnl0ZUxlbmd0aCArIDEpICogOCAtIDF9JHtufWBcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmFuZ2UgPSBgPj0gJHttaW59JHtufSBhbmQgPD0gJHttYXh9JHtufWBcbiAgICB9XG4gICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfT1VUX09GX1JBTkdFKCd2YWx1ZScsIHJhbmdlLCB2YWx1ZSlcbiAgfVxuICBjaGVja0JvdW5kcyhidWYsIG9mZnNldCwgYnl0ZUxlbmd0aClcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVOdW1iZXIgKHZhbHVlLCBuYW1lKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfSU5WQUxJRF9BUkdfVFlQRShuYW1lLCAnbnVtYmVyJywgdmFsdWUpXG4gIH1cbn1cblxuZnVuY3Rpb24gYm91bmRzRXJyb3IgKHZhbHVlLCBsZW5ndGgsIHR5cGUpIHtcbiAgaWYgKE1hdGguZmxvb3IodmFsdWUpICE9PSB2YWx1ZSkge1xuICAgIHZhbGlkYXRlTnVtYmVyKHZhbHVlLCB0eXBlKVxuICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX09VVF9PRl9SQU5HRSh0eXBlIHx8ICdvZmZzZXQnLCAnYW4gaW50ZWdlcicsIHZhbHVlKVxuICB9XG5cbiAgaWYgKGxlbmd0aCA8IDApIHtcbiAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9CVUZGRVJfT1VUX09GX0JPVU5EUygpXG4gIH1cblxuICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9PVVRfT0ZfUkFOR0UodHlwZSB8fCAnb2Zmc2V0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGA+PSAke3R5cGUgPyAxIDogMH0gYW5kIDw9ICR7bGVuZ3RofWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSlcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG5jb25zdCBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXisvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHRha2VzIGVxdWFsIHNpZ25zIGFzIGVuZCBvZiB0aGUgQmFzZTY0IGVuY29kaW5nXG4gIHN0ciA9IHN0ci5zcGxpdCgnPScpWzBdXG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgbGV0IGNvZGVQb2ludFxuICBjb25zdCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIGxldCBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICBjb25zdCBieXRlcyA9IFtdXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIGNvbnN0IGJ5dGVBcnJheSA9IFtdXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgbGV0IGMsIGhpLCBsb1xuICBjb25zdCBieXRlQXJyYXkgPSBbXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGxldCBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG4vLyBBcnJheUJ1ZmZlciBvciBVaW50OEFycmF5IG9iamVjdHMgZnJvbSBvdGhlciBjb250ZXh0cyAoaS5lLiBpZnJhbWVzKSBkbyBub3QgcGFzc1xuLy8gdGhlIGBpbnN0YW5jZW9mYCBjaGVjayBidXQgdGhleSBzaG91bGQgYmUgdHJlYXRlZCBhcyBvZiB0aGF0IHR5cGUuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNjZcbmZ1bmN0aW9uIGlzSW5zdGFuY2UgKG9iaiwgdHlwZSkge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgdHlwZSB8fFxuICAgIChvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IubmFtZSAhPSBudWxsICYmXG4gICAgICBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gdHlwZS5uYW1lKVxufVxuZnVuY3Rpb24gbnVtYmVySXNOYU4gKG9iaikge1xuICAvLyBGb3IgSUUxMSBzdXBwb3J0XG4gIHJldHVybiBvYmogIT09IG9iaiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuXG4vLyBDcmVhdGUgbG9va3VwIHRhYmxlIGZvciBgdG9TdHJpbmcoJ2hleCcpYFxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMjE5XG5jb25zdCBoZXhTbGljZUxvb2t1cFRhYmxlID0gKGZ1bmN0aW9uICgpIHtcbiAgY29uc3QgYWxwaGFiZXQgPSAnMDEyMzQ1Njc4OWFiY2RlZidcbiAgY29uc3QgdGFibGUgPSBuZXcgQXJyYXkoMjU2KVxuICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICBjb25zdCBpMTYgPSBpICogMTZcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IDE2OyArK2opIHtcbiAgICAgIHRhYmxlW2kxNiArIGpdID0gYWxwaGFiZXRbaV0gKyBhbHBoYWJldFtqXVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGFibGVcbn0pKClcblxuLy8gUmV0dXJuIG5vdCBmdW5jdGlvbiB3aXRoIEVycm9yIGlmIEJpZ0ludCBub3Qgc3VwcG9ydGVkXG5mdW5jdGlvbiBkZWZpbmVCaWdJbnRNZXRob2QgKGZuKSB7XG4gIHJldHVybiB0eXBlb2YgQmlnSW50ID09PSAndW5kZWZpbmVkJyA/IEJ1ZmZlckJpZ0ludE5vdERlZmluZWQgOiBmblxufVxuXG5mdW5jdGlvbiBCdWZmZXJCaWdJbnROb3REZWZpbmVkICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdCaWdJbnQgbm90IHN1cHBvcnRlZCcpXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/buffer/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/ieee754/index.js":
/*!*******************************************!*\
  !*** ../../node_modules/ieee754/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsV0FBVzs7QUFFcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUyxXQUFXOztBQUVwQjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLFdBQVc7O0FBRXBCO0FBQ0E7QUFDQSxTQUFTLFVBQVU7O0FBRW5CO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIGllZWU3NTQuIEJTRC0zLUNsYXVzZSBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKi9cbmV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gKGUgKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gKG0gKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAoKHZhbHVlICogYykgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/ieee754/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/globals.css":
/*!*************************!*\
  !*** ./app/globals.css ***!
  \*************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"08bceb76413f\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9nbG9iYWxzLmNzcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsY0FBYztBQUM3QixJQUFJLElBQVUsSUFBSSxpQkFBaUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL1dvbmRlclZpdGUtZnJvbnRlbmQvYXBwL2dsb2JhbHMuY3NzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiMDhiY2ViNzY0MTNmXCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/globals.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/plasmic/PlasmicWrapper.tsx":
/*!***************************************************!*\
  !*** ./src/components/plasmic/PlasmicWrapper.tsx ***!
  \***************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PlasmicWrapper: () => (/* binding */ PlasmicWrapper)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _plasmicapp_loader_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @plasmicapp/loader-react */ \"(app-pages-browser)/./node_modules/@plasmicapp/loader-react/dist/index.esm.js\");\n/* harmony import */ var _plasmic_init__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/plasmic-init */ \"(app-pages-browser)/./src/plasmic-init.ts\");\n/* __next_internal_client_entry_do_not_use__ PlasmicWrapper auto */ \n\n\nfunction PlasmicWrapper(param) {\n    let { children } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_plasmicapp_loader_react__WEBPACK_IMPORTED_MODULE_1__.PlasmicRootProvider, {\n        loader: _plasmic_init__WEBPACK_IMPORTED_MODULE_2__.PLASMIC,\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/wonderlandmitch/CascadeProjects/WonderVite-frontend/src/components/plasmic/PlasmicWrapper.tsx\",\n        lineNumber: 9,\n        columnNumber: 5\n    }, this);\n}\n_c = PlasmicWrapper;\nvar _c;\n$RefreshReg$(_c, \"PlasmicWrapper\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3BsYXNtaWMvUGxhc21pY1dyYXBwZXIudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBRThEO0FBQ3RCO0FBR2pDLFNBQVNFLGVBQWUsS0FBcUM7UUFBckMsRUFBRUMsUUFBUSxFQUEyQixHQUFyQztJQUM3QixxQkFDRSw4REFBQ0gseUVBQW1CQTtRQUFDSSxRQUFRSCxrREFBT0E7a0JBQ2pDRTs7Ozs7O0FBR1A7S0FOZ0JEIiwic291cmNlcyI6WyIvVXNlcnMvd29uZGVybGFuZG1pdGNoL0Nhc2NhZGVQcm9qZWN0cy9Xb25kZXJWaXRlLWZyb250ZW5kL3NyYy9jb21wb25lbnRzL3BsYXNtaWMvUGxhc21pY1dyYXBwZXIudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuXG5pbXBvcnQgeyBQbGFzbWljUm9vdFByb3ZpZGVyIH0gZnJvbSBcIkBwbGFzbWljYXBwL2xvYWRlci1yZWFjdFwiXG5pbXBvcnQgeyBQTEFTTUlDIH0gZnJvbSBcIkAvcGxhc21pYy1pbml0XCJcbmltcG9ydCB7IFJlYWN0Tm9kZSB9IGZyb20gXCJyZWFjdFwiXG5cbmV4cG9ydCBmdW5jdGlvbiBQbGFzbWljV3JhcHBlcih7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW46IFJlYWN0Tm9kZSB9KSB7XG4gIHJldHVybiAoXG4gICAgPFBsYXNtaWNSb290UHJvdmlkZXIgbG9hZGVyPXtQTEFTTUlDfT5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L1BsYXNtaWNSb290UHJvdmlkZXI+XG4gICk7XG59XG4iXSwibmFtZXMiOlsiUGxhc21pY1Jvb3RQcm92aWRlciIsIlBMQVNNSUMiLCJQbGFzbWljV3JhcHBlciIsImNoaWxkcmVuIiwibG9hZGVyIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/plasmic/PlasmicWrapper.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/config/queryClient.ts":
/*!***********************************!*\
  !*** ./src/config/queryClient.ts ***!
  \***********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   queryClient: () => (/* binding */ queryClient)\n/* harmony export */ });\n/* harmony import */ var _tanstack_react_query__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tanstack/react-query */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/queryClient.js\");\n\nconst queryClient = new _tanstack_react_query__WEBPACK_IMPORTED_MODULE_0__.QueryClient({\n    defaultOptions: {\n        queries: {\n            staleTime: 1000 * 60 * 5,\n            retry: 1,\n            refetchOnWindowFocus: false\n        },\n        mutations: {\n            retry: 1\n        }\n    }\n});\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb25maWcvcXVlcnlDbGllbnQudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBb0Q7QUFFN0MsTUFBTUMsY0FBYyxJQUFJRCw4REFBV0EsQ0FBQztJQUN6Q0UsZ0JBQWdCO1FBQ2RDLFNBQVM7WUFDUEMsV0FBVyxPQUFPLEtBQUs7WUFDdkJDLE9BQU87WUFDUEMsc0JBQXNCO1FBQ3hCO1FBQ0FDLFdBQVc7WUFDVEYsT0FBTztRQUNUO0lBQ0Y7QUFDRixHQUFHIiwic291cmNlcyI6WyIvVXNlcnMvd29uZGVybGFuZG1pdGNoL0Nhc2NhZGVQcm9qZWN0cy9Xb25kZXJWaXRlLWZyb250ZW5kL3NyYy9jb25maWcvcXVlcnlDbGllbnQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUXVlcnlDbGllbnQgfSBmcm9tICdAdGFuc3RhY2svcmVhY3QtcXVlcnknO1xuXG5leHBvcnQgY29uc3QgcXVlcnlDbGllbnQgPSBuZXcgUXVlcnlDbGllbnQoe1xuICBkZWZhdWx0T3B0aW9uczoge1xuICAgIHF1ZXJpZXM6IHtcbiAgICAgIHN0YWxlVGltZTogMTAwMCAqIDYwICogNSwgLy8gNSBtaW51dGVzXG4gICAgICByZXRyeTogMSxcbiAgICAgIHJlZmV0Y2hPbldpbmRvd0ZvY3VzOiBmYWxzZSxcbiAgICB9LFxuICAgIG11dGF0aW9uczoge1xuICAgICAgcmV0cnk6IDEsXG4gICAgfSxcbiAgfSxcbn0pOyJdLCJuYW1lcyI6WyJRdWVyeUNsaWVudCIsInF1ZXJ5Q2xpZW50IiwiZGVmYXVsdE9wdGlvbnMiLCJxdWVyaWVzIiwic3RhbGVUaW1lIiwicmV0cnkiLCJyZWZldGNoT25XaW5kb3dGb2N1cyIsIm11dGF0aW9ucyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/config/queryClient.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/contexts/SettingsContext.tsx":
/*!******************************************!*\
  !*** ./src/contexts/SettingsContext.tsx ***!
  \******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SettingsProvider: () => (/* binding */ SettingsProvider),\n/* harmony export */   useSettings: () => (/* reexport safe */ _settings_context_variants__WEBPACK_IMPORTED_MODULE_3__.useSettings)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _hooks_use_toast__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/hooks/use-toast */ \"(app-pages-browser)/./src/hooks/use-toast.ts\");\n/* harmony import */ var _settings_context_variants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./settings-context-variants */ \"(app-pages-browser)/./src/contexts/settings-context-variants.ts\");\n/* __next_internal_client_entry_do_not_use__ SettingsProvider,useSettings auto */ \nvar _s = $RefreshSig$();\n\n\n\nconst SettingsContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nfunction SettingsProvider(param) {\n    let { children } = param;\n    _s();\n    const { toast } = (0,_hooks_use_toast__WEBPACK_IMPORTED_MODULE_2__.useToast)();\n    const [settings, setSettings] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(_settings_context_variants__WEBPACK_IMPORTED_MODULE_3__.defaultSettings);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"SettingsProvider.useEffect\": ()=>{\n            // Load settings from localStorage on initial render\n            if (true) {\n                const savedSettings = localStorage.getItem(_settings_context_variants__WEBPACK_IMPORTED_MODULE_3__.SETTINGS_STORAGE_KEY);\n                if (savedSettings) {\n                    setSettings(JSON.parse(savedSettings));\n                }\n            }\n        }\n    }[\"SettingsProvider.useEffect\"], []);\n    // Update localStorage whenever settings change\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"SettingsProvider.useEffect\": ()=>{\n            if (true) {\n                localStorage.setItem(_settings_context_variants__WEBPACK_IMPORTED_MODULE_3__.SETTINGS_STORAGE_KEY, JSON.stringify(settings));\n            }\n        }\n    }[\"SettingsProvider.useEffect\"], [\n        settings\n    ]);\n    const updateSettings = (newSettings)=>{\n        setSettings((prev)=>({\n                ...prev,\n                ...newSettings\n            }));\n    };\n    const saveSettings = async ()=>{\n        try {\n            // Here you would typically make an API call to save the settings\n            await new Promise((resolve)=>setTimeout(resolve, 1000));\n            if (true) {\n                localStorage.setItem(_settings_context_variants__WEBPACK_IMPORTED_MODULE_3__.SETTINGS_STORAGE_KEY, JSON.stringify(settings));\n            }\n            console.log('Settings saved:', settings);\n            toast({\n                title: \"Settings saved\",\n                description: \"Your settings have been successfully updated.\"\n            });\n        } catch (error) {\n            console.error('Error saving settings:', error);\n            toast({\n                title: \"Error\",\n                description: \"Failed to save settings. Please try again.\",\n                variant: \"destructive\"\n            });\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(SettingsContext.Provider, {\n        value: {\n            settings,\n            updateSettings,\n            saveSettings\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/wonderlandmitch/CascadeProjects/WonderVite-frontend/src/contexts/SettingsContext.tsx\",\n        lineNumber: 86,\n        columnNumber: 5\n    }, this);\n}\n_s(SettingsProvider, \"HNf7pX3kot2HlWQVl9z6XQGk+zw=\", false, function() {\n    return [\n        _hooks_use_toast__WEBPACK_IMPORTED_MODULE_2__.useToast\n    ];\n});\n_c = SettingsProvider;\n\nvar _c;\n$RefreshReg$(_c, \"SettingsProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb250ZXh0cy9TZXR0aW5nc0NvbnRleHQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUVrRTtBQUNyQjtBQUN1QztBQTJCcEYsTUFBTU8sZ0NBQWtCTixvREFBYUEsQ0FBa0NPO0FBRWhFLFNBQVNDLGlCQUFpQixLQUEyQztRQUEzQyxFQUFFQyxRQUFRLEVBQWlDLEdBQTNDOztJQUMvQixNQUFNLEVBQUVDLEtBQUssRUFBRSxHQUFHUCwwREFBUUE7SUFDMUIsTUFBTSxDQUFDUSxVQUFVQyxZQUFZLEdBQUdYLCtDQUFRQSxDQUFXRyx1RUFBZUE7SUFFbEVGLGdEQUFTQTtzQ0FBQztZQUNSLG9EQUFvRDtZQUNwRCxJQUFJLElBQTZCLEVBQUU7Z0JBQ2pDLE1BQU1XLGdCQUFnQkMsYUFBYUMsT0FBTyxDQUFDViw0RUFBb0JBO2dCQUMvRCxJQUFJUSxlQUFlO29CQUNqQkQsWUFBWUksS0FBS0MsS0FBSyxDQUFDSjtnQkFDekI7WUFDRjtRQUNGO3FDQUFHLEVBQUU7SUFFTCwrQ0FBK0M7SUFDL0NYLGdEQUFTQTtzQ0FBQztZQUNSLElBQUksSUFBNkIsRUFBRTtnQkFDakNZLGFBQWFJLE9BQU8sQ0FBQ2IsNEVBQW9CQSxFQUFFVyxLQUFLRyxTQUFTLENBQUNSO1lBQzVEO1FBQ0Y7cUNBQUc7UUFBQ0E7S0FBUztJQUViLE1BQU1TLGlCQUFpQixDQUFDQztRQUN0QlQsWUFBWVUsQ0FBQUEsT0FBUztnQkFDbkIsR0FBR0EsSUFBSTtnQkFDUCxHQUFHRCxXQUFXO1lBQ2hCO0lBQ0Y7SUFFQSxNQUFNRSxlQUFlO1FBQ25CLElBQUk7WUFDRixpRUFBaUU7WUFDakUsTUFBTSxJQUFJQyxRQUFRQyxDQUFBQSxVQUFXQyxXQUFXRCxTQUFTO1lBQ2pELElBQUksSUFBNkIsRUFBRTtnQkFDakNYLGFBQWFJLE9BQU8sQ0FBQ2IsNEVBQW9CQSxFQUFFVyxLQUFLRyxTQUFTLENBQUNSO1lBQzVEO1lBQ0FnQixRQUFRQyxHQUFHLENBQUMsbUJBQW1CakI7WUFFL0JELE1BQU07Z0JBQ0ptQixPQUFPO2dCQUNQQyxhQUFhO1lBQ2Y7UUFDRixFQUFFLE9BQU9DLE9BQU87WUFDZEosUUFBUUksS0FBSyxDQUFDLDBCQUEwQkE7WUFDeENyQixNQUFNO2dCQUNKbUIsT0FBTztnQkFDUEMsYUFBYTtnQkFDYkUsU0FBUztZQUNYO1FBQ0Y7SUFDRjtJQUVBLHFCQUNFLDhEQUFDMUIsZ0JBQWdCMkIsUUFBUTtRQUFDQyxPQUFPO1lBQUV2QjtZQUFVUztZQUFnQkc7UUFBYTtrQkFDdkVkOzs7Ozs7QUFHUDtHQXhEZ0JEOztRQUNJTCxzREFBUUE7OztLQURaSztBQTBEMEMiLCJzb3VyY2VzIjpbIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL1dvbmRlclZpdGUtZnJvbnRlbmQvc3JjL2NvbnRleHRzL1NldHRpbmdzQ29udGV4dC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbmltcG9ydCBSZWFjdCwgeyBjcmVhdGVDb250ZXh0LCB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlVG9hc3QgfSBmcm9tIFwiQC9ob29rcy91c2UtdG9hc3RcIjtcbmltcG9ydCB7IGRlZmF1bHRTZXR0aW5ncywgU0VUVElOR1NfU1RPUkFHRV9LRVkgfSBmcm9tICcuL3NldHRpbmdzLWNvbnRleHQtdmFyaWFudHMnO1xuXG5pbnRlcmZhY2UgQWRkcmVzcyB7XG4gIHN0cmVldDogc3RyaW5nO1xuICB1bml0Pzogc3RyaW5nO1xuICBjaXR5OiBzdHJpbmc7XG4gIHN0YXRlOiBzdHJpbmc7XG4gIHppcENvZGU6IHN0cmluZztcbiAgY291bnRyeTogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgU2V0dGluZ3Mge1xuICBidXNpbmVzc05hbWU6IHN0cmluZztcbiAgZGlzcGxheU5hbWU6IHN0cmluZztcbiAgd2Vic2l0ZTogc3RyaW5nO1xuICBkZXNjcmlwdGlvbjogc3RyaW5nO1xuICBicmFuZENvbG9yOiBzdHJpbmc7XG4gIGxvZ28/OiBzdHJpbmc7XG4gIGFkZHJlc3M/OiBBZGRyZXNzO1xufVxuXG5pbnRlcmZhY2UgU2V0dGluZ3NDb250ZXh0VHlwZSB7XG4gIHNldHRpbmdzOiBTZXR0aW5ncztcbiAgdXBkYXRlU2V0dGluZ3M6IChuZXdTZXR0aW5nczogUGFydGlhbDxTZXR0aW5ncz4pID0+IHZvaWQ7XG4gIHNhdmVTZXR0aW5nczogKCkgPT4gUHJvbWlzZTx2b2lkPjtcbn1cblxuY29uc3QgU2V0dGluZ3NDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxTZXR0aW5nc0NvbnRleHRUeXBlIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpO1xuXG5leHBvcnQgZnVuY3Rpb24gU2V0dGluZ3NQcm92aWRlcih7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZSB9KSB7XG4gIGNvbnN0IHsgdG9hc3QgfSA9IHVzZVRvYXN0KCk7XG4gIGNvbnN0IFtzZXR0aW5ncywgc2V0U2V0dGluZ3NdID0gdXNlU3RhdGU8U2V0dGluZ3M+KGRlZmF1bHRTZXR0aW5ncyk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBMb2FkIHNldHRpbmdzIGZyb20gbG9jYWxTdG9yYWdlIG9uIGluaXRpYWwgcmVuZGVyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zdCBzYXZlZFNldHRpbmdzID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oU0VUVElOR1NfU1RPUkFHRV9LRVkpO1xuICAgICAgaWYgKHNhdmVkU2V0dGluZ3MpIHtcbiAgICAgICAgc2V0U2V0dGluZ3MoSlNPTi5wYXJzZShzYXZlZFNldHRpbmdzKSk7XG4gICAgICB9XG4gICAgfVxuICB9LCBbXSk7XG5cbiAgLy8gVXBkYXRlIGxvY2FsU3RvcmFnZSB3aGVuZXZlciBzZXR0aW5ncyBjaGFuZ2VcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFNFVFRJTkdTX1NUT1JBR0VfS0VZLCBKU09OLnN0cmluZ2lmeShzZXR0aW5ncykpO1xuICAgIH1cbiAgfSwgW3NldHRpbmdzXSk7XG5cbiAgY29uc3QgdXBkYXRlU2V0dGluZ3MgPSAobmV3U2V0dGluZ3M6IFBhcnRpYWw8U2V0dGluZ3M+KSA9PiB7XG4gICAgc2V0U2V0dGluZ3MocHJldiA9PiAoe1xuICAgICAgLi4ucHJldixcbiAgICAgIC4uLm5ld1NldHRpbmdzXG4gICAgfSkpO1xuICB9O1xuXG4gIGNvbnN0IHNhdmVTZXR0aW5ncyA9IGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgLy8gSGVyZSB5b3Ugd291bGQgdHlwaWNhbGx5IG1ha2UgYW4gQVBJIGNhbGwgdG8gc2F2ZSB0aGUgc2V0dGluZ3NcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwKSk7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oU0VUVElOR1NfU1RPUkFHRV9LRVksIEpTT04uc3RyaW5naWZ5KHNldHRpbmdzKSk7XG4gICAgICB9XG4gICAgICBjb25zb2xlLmxvZygnU2V0dGluZ3Mgc2F2ZWQ6Jywgc2V0dGluZ3MpO1xuICAgICAgXG4gICAgICB0b2FzdCh7XG4gICAgICAgIHRpdGxlOiBcIlNldHRpbmdzIHNhdmVkXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIllvdXIgc2V0dGluZ3MgaGF2ZSBiZWVuIHN1Y2Nlc3NmdWxseSB1cGRhdGVkLlwiLFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHNhdmluZyBzZXR0aW5nczonLCBlcnJvcik7XG4gICAgICB0b2FzdCh7XG4gICAgICAgIHRpdGxlOiBcIkVycm9yXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkZhaWxlZCB0byBzYXZlIHNldHRpbmdzLiBQbGVhc2UgdHJ5IGFnYWluLlwiLFxuICAgICAgICB2YXJpYW50OiBcImRlc3RydWN0aXZlXCIsXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIChcbiAgICA8U2V0dGluZ3NDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt7IHNldHRpbmdzLCB1cGRhdGVTZXR0aW5ncywgc2F2ZVNldHRpbmdzIH19PlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvU2V0dGluZ3NDb250ZXh0LlByb3ZpZGVyPlxuICApO1xufVxuXG5leHBvcnQgeyB1c2VTZXR0aW5ncyB9IGZyb20gJy4vc2V0dGluZ3MtY29udGV4dC12YXJpYW50cyc7Il0sIm5hbWVzIjpbIlJlYWN0IiwiY3JlYXRlQ29udGV4dCIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlVG9hc3QiLCJkZWZhdWx0U2V0dGluZ3MiLCJTRVRUSU5HU19TVE9SQUdFX0tFWSIsIlNldHRpbmdzQ29udGV4dCIsInVuZGVmaW5lZCIsIlNldHRpbmdzUHJvdmlkZXIiLCJjaGlsZHJlbiIsInRvYXN0Iiwic2V0dGluZ3MiLCJzZXRTZXR0aW5ncyIsInNhdmVkU2V0dGluZ3MiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiSlNPTiIsInBhcnNlIiwic2V0SXRlbSIsInN0cmluZ2lmeSIsInVwZGF0ZVNldHRpbmdzIiwibmV3U2V0dGluZ3MiLCJwcmV2Iiwic2F2ZVNldHRpbmdzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiY29uc29sZSIsImxvZyIsInRpdGxlIiwiZGVzY3JpcHRpb24iLCJlcnJvciIsInZhcmlhbnQiLCJQcm92aWRlciIsInZhbHVlIiwidXNlU2V0dGluZ3MiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/contexts/SettingsContext.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/contexts/settings-context-variants.ts":
/*!***************************************************!*\
  !*** ./src/contexts/settings-context-variants.ts ***!
  \***************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SETTINGS_STORAGE_KEY: () => (/* binding */ SETTINGS_STORAGE_KEY),\n/* harmony export */   SettingsContext: () => (/* binding */ SettingsContext),\n/* harmony export */   defaultSettings: () => (/* binding */ defaultSettings),\n/* harmony export */   useSettings: () => (/* binding */ useSettings)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nconst SETTINGS_STORAGE_KEY = 'wondervite-settings';\nconst defaultSettings = {\n    theme: 'light',\n    notifications: true,\n    brandColor: '#4F46E5',\n    displayName: 'WonderVite',\n    businessName: 'WonderVite Inc',\n    website: 'https://wondervite.com',\n    description: 'Financial operations platform'\n};\nconst SettingsContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(defaultSettings);\nfunction useSettings() {\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SettingsContext);\n    if (!context) {\n        throw new Error('useSettings must be used within SettingsProvider');\n    }\n    return context;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb250ZXh0cy9zZXR0aW5ncy1jb250ZXh0LXZhcmlhbnRzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFrRDtBQUUzQyxNQUFNRSx1QkFBdUIsc0JBQXNCO0FBWW5ELE1BQU1DLGtCQUE0QjtJQUN2Q0MsT0FBTztJQUNQQyxlQUFlO0lBQ2ZDLFlBQVk7SUFDWkMsYUFBYTtJQUNiQyxjQUFjO0lBQ2RDLFNBQVM7SUFDVEMsYUFBYTtBQUNmLEVBQUU7QUFFSyxNQUFNQyxrQkFBa0JYLG9EQUFhQSxDQUFXRyxpQkFBaUI7QUFFakUsU0FBU1M7SUFDZCxNQUFNQyxVQUFVWixpREFBVUEsQ0FBQ1U7SUFDM0IsSUFBSSxDQUFDRSxTQUFTO1FBQ1osTUFBTSxJQUFJQyxNQUFNO0lBQ2xCO0lBQ0EsT0FBT0Q7QUFDVCIsInNvdXJjZXMiOlsiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvV29uZGVyVml0ZS1mcm9udGVuZC9zcmMvY29udGV4dHMvc2V0dGluZ3MtY29udGV4dC12YXJpYW50cy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuXG5leHBvcnQgY29uc3QgU0VUVElOR1NfU1RPUkFHRV9LRVkgPSAnd29uZGVydml0ZS1zZXR0aW5ncyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2V0dGluZ3Mge1xuICB0aGVtZTogJ2xpZ2h0JyB8ICdkYXJrJztcbiAgbm90aWZpY2F0aW9uczogYm9vbGVhbjtcbiAgYnJhbmRDb2xvcjogc3RyaW5nO1xuICBkaXNwbGF5TmFtZTogc3RyaW5nO1xuICBidXNpbmVzc05hbWU6IHN0cmluZztcbiAgd2Vic2l0ZTogc3RyaW5nO1xuICBkZXNjcmlwdGlvbjogc3RyaW5nO1xufVxuXG5leHBvcnQgY29uc3QgZGVmYXVsdFNldHRpbmdzOiBTZXR0aW5ncyA9IHtcbiAgdGhlbWU6ICdsaWdodCcsXG4gIG5vdGlmaWNhdGlvbnM6IHRydWUsXG4gIGJyYW5kQ29sb3I6ICcjNEY0NkU1JyxcbiAgZGlzcGxheU5hbWU6ICdXb25kZXJWaXRlJyxcbiAgYnVzaW5lc3NOYW1lOiAnV29uZGVyVml0ZSBJbmMnLFxuICB3ZWJzaXRlOiAnaHR0cHM6Ly93b25kZXJ2aXRlLmNvbScsXG4gIGRlc2NyaXB0aW9uOiAnRmluYW5jaWFsIG9wZXJhdGlvbnMgcGxhdGZvcm0nXG59O1xuXG5leHBvcnQgY29uc3QgU2V0dGluZ3NDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxTZXR0aW5ncz4oZGVmYXVsdFNldHRpbmdzKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVNldHRpbmdzKCkge1xuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChTZXR0aW5nc0NvbnRleHQpO1xuICBpZiAoIWNvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzZVNldHRpbmdzIG11c3QgYmUgdXNlZCB3aXRoaW4gU2V0dGluZ3NQcm92aWRlcicpO1xuICB9XG4gIHJldHVybiBjb250ZXh0O1xufVxuIl0sIm5hbWVzIjpbImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwiU0VUVElOR1NfU1RPUkFHRV9LRVkiLCJkZWZhdWx0U2V0dGluZ3MiLCJ0aGVtZSIsIm5vdGlmaWNhdGlvbnMiLCJicmFuZENvbG9yIiwiZGlzcGxheU5hbWUiLCJidXNpbmVzc05hbWUiLCJ3ZWJzaXRlIiwiZGVzY3JpcHRpb24iLCJTZXR0aW5nc0NvbnRleHQiLCJ1c2VTZXR0aW5ncyIsImNvbnRleHQiLCJFcnJvciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/contexts/settings-context-variants.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/hooks/use-toast.ts":
/*!********************************!*\
  !*** ./src/hooks/use-toast.ts ***!
  \********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   reducer: () => (/* binding */ reducer),\n/* harmony export */   toast: () => (/* binding */ toast),\n/* harmony export */   useToast: () => (/* binding */ useToast)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nconst TOAST_LIMIT = 1;\nconst TOAST_REMOVE_DELAY = 1000000;\nconst actionTypes = {\n    ADD_TOAST: \"ADD_TOAST\",\n    UPDATE_TOAST: \"UPDATE_TOAST\",\n    DISMISS_TOAST: \"DISMISS_TOAST\",\n    REMOVE_TOAST: \"REMOVE_TOAST\"\n};\nlet count = 0;\nfunction genId() {\n    count = (count + 1) % Number.MAX_SAFE_INTEGER;\n    return count.toString();\n}\nconst toastTimeouts = new Map();\nconst addToRemoveQueue = (toastId)=>{\n    if (toastTimeouts.has(toastId)) {\n        return;\n    }\n    const timeout = setTimeout(()=>{\n        toastTimeouts.delete(toastId);\n        dispatch({\n            type: \"REMOVE_TOAST\",\n            toastId: toastId\n        });\n    }, TOAST_REMOVE_DELAY);\n    toastTimeouts.set(toastId, timeout);\n};\nconst reducer = (state, action)=>{\n    switch(action.type){\n        case \"ADD_TOAST\":\n            return {\n                ...state,\n                toasts: [\n                    action.toast,\n                    ...state.toasts\n                ].slice(0, TOAST_LIMIT)\n            };\n        case \"UPDATE_TOAST\":\n            return {\n                ...state,\n                toasts: state.toasts.map((t)=>t.id === action.toast.id ? {\n                        ...t,\n                        ...action.toast\n                    } : t)\n            };\n        case \"DISMISS_TOAST\":\n            {\n                const { toastId } = action;\n                // ! Side effects ! - This could be extracted into a dismissToast() action,\n                // but I'll keep it here for simplicity\n                if (toastId) {\n                    addToRemoveQueue(toastId);\n                } else {\n                    state.toasts.forEach((toast)=>{\n                        addToRemoveQueue(toast.id);\n                    });\n                }\n                return {\n                    ...state,\n                    toasts: state.toasts.map((t)=>t.id === toastId || toastId === undefined ? {\n                            ...t,\n                            open: false\n                        } : t)\n                };\n            }\n        case \"REMOVE_TOAST\":\n            if (action.toastId === undefined) {\n                return {\n                    ...state,\n                    toasts: []\n                };\n            }\n            return {\n                ...state,\n                toasts: state.toasts.filter((t)=>t.id !== action.toastId)\n            };\n    }\n};\nconst listeners = [];\nlet memoryState = {\n    toasts: []\n};\nfunction dispatch(action) {\n    memoryState = reducer(memoryState, action);\n    listeners.forEach((listener)=>{\n        listener(memoryState);\n    });\n}\nfunction toast(param) {\n    let { ...props } = param;\n    const id = genId();\n    const update = (props)=>dispatch({\n            type: \"UPDATE_TOAST\",\n            toast: {\n                ...props,\n                id\n            }\n        });\n    const dismiss = ()=>dispatch({\n            type: \"DISMISS_TOAST\",\n            toastId: id\n        });\n    dispatch({\n        type: \"ADD_TOAST\",\n        toast: {\n            ...props,\n            id,\n            open: true,\n            onOpenChange: (open)=>{\n                if (!open) dismiss();\n            }\n        }\n    });\n    return {\n        id: id,\n        dismiss,\n        update\n    };\n}\nfunction useToast() {\n    const [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useState(memoryState);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect({\n        \"useToast.useEffect\": ()=>{\n            listeners.push(setState);\n            return ({\n                \"useToast.useEffect\": ()=>{\n                    const index = listeners.indexOf(setState);\n                    if (index > -1) {\n                        listeners.splice(index, 1);\n                    }\n                }\n            })[\"useToast.useEffect\"];\n        }\n    }[\"useToast.useEffect\"], [\n        state\n    ]);\n    return {\n        ...state,\n        toast,\n        dismiss: (toastId)=>dispatch({\n                type: \"DISMISS_TOAST\",\n                toastId\n            })\n    };\n}\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2UtdG9hc3QudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBOEI7QUFPOUIsTUFBTUMsY0FBYztBQUNwQixNQUFNQyxxQkFBcUI7QUFTM0IsTUFBTUMsY0FBYztJQUNsQkMsV0FBVztJQUNYQyxjQUFjO0lBQ2RDLGVBQWU7SUFDZkMsY0FBYztBQUNoQjtBQUVBLElBQUlDLFFBQVE7QUFFWixTQUFTQztJQUNQRCxRQUFRLENBQUNBLFFBQVEsS0FBS0UsT0FBT0MsZ0JBQWdCO0lBQzdDLE9BQU9ILE1BQU1JLFFBQVE7QUFDdkI7QUEwQkEsTUFBTUMsZ0JBQWdCLElBQUlDO0FBRTFCLE1BQU1DLG1CQUFtQixDQUFDQztJQUN4QixJQUFJSCxjQUFjSSxHQUFHLENBQUNELFVBQVU7UUFDOUI7SUFDRjtJQUVBLE1BQU1FLFVBQVVDLFdBQVc7UUFDekJOLGNBQWNPLE1BQU0sQ0FBQ0o7UUFDckJLLFNBQVM7WUFDUEMsTUFBTTtZQUNOTixTQUFTQTtRQUNYO0lBQ0YsR0FBR2Q7SUFFSFcsY0FBY1UsR0FBRyxDQUFDUCxTQUFTRTtBQUM3QjtBQUVPLE1BQU1NLFVBQVUsQ0FBQ0MsT0FBY0M7SUFDcEMsT0FBUUEsT0FBT0osSUFBSTtRQUNqQixLQUFLO1lBQ0gsT0FBTztnQkFDTCxHQUFHRyxLQUFLO2dCQUNSRSxRQUFRO29CQUFDRCxPQUFPRSxLQUFLO3VCQUFLSCxNQUFNRSxNQUFNO2lCQUFDLENBQUNFLEtBQUssQ0FBQyxHQUFHNUI7WUFDbkQ7UUFFRixLQUFLO1lBQ0gsT0FBTztnQkFDTCxHQUFHd0IsS0FBSztnQkFDUkUsUUFBUUYsTUFBTUUsTUFBTSxDQUFDRyxHQUFHLENBQUMsQ0FBQ0MsSUFDeEJBLEVBQUVDLEVBQUUsS0FBS04sT0FBT0UsS0FBSyxDQUFDSSxFQUFFLEdBQUc7d0JBQUUsR0FBR0QsQ0FBQzt3QkFBRSxHQUFHTCxPQUFPRSxLQUFLO29CQUFDLElBQUlHO1lBRTNEO1FBRUYsS0FBSztZQUFpQjtnQkFDcEIsTUFBTSxFQUFFZixPQUFPLEVBQUUsR0FBR1U7Z0JBRXBCLDJFQUEyRTtnQkFDM0UsdUNBQXVDO2dCQUN2QyxJQUFJVixTQUFTO29CQUNYRCxpQkFBaUJDO2dCQUNuQixPQUFPO29CQUNMUyxNQUFNRSxNQUFNLENBQUNNLE9BQU8sQ0FBQyxDQUFDTDt3QkFDcEJiLGlCQUFpQmEsTUFBTUksRUFBRTtvQkFDM0I7Z0JBQ0Y7Z0JBRUEsT0FBTztvQkFDTCxHQUFHUCxLQUFLO29CQUNSRSxRQUFRRixNQUFNRSxNQUFNLENBQUNHLEdBQUcsQ0FBQyxDQUFDQyxJQUN4QkEsRUFBRUMsRUFBRSxLQUFLaEIsV0FBV0EsWUFBWWtCLFlBQzVCOzRCQUNFLEdBQUdILENBQUM7NEJBQ0pJLE1BQU07d0JBQ1IsSUFDQUo7Z0JBRVI7WUFDRjtRQUNBLEtBQUs7WUFDSCxJQUFJTCxPQUFPVixPQUFPLEtBQUtrQixXQUFXO2dCQUNoQyxPQUFPO29CQUNMLEdBQUdULEtBQUs7b0JBQ1JFLFFBQVEsRUFBRTtnQkFDWjtZQUNGO1lBQ0EsT0FBTztnQkFDTCxHQUFHRixLQUFLO2dCQUNSRSxRQUFRRixNQUFNRSxNQUFNLENBQUNTLE1BQU0sQ0FBQyxDQUFDTCxJQUFNQSxFQUFFQyxFQUFFLEtBQUtOLE9BQU9WLE9BQU87WUFDNUQ7SUFDSjtBQUNGLEVBQUM7QUFFRCxNQUFNcUIsWUFBMkMsRUFBRTtBQUVuRCxJQUFJQyxjQUFxQjtJQUFFWCxRQUFRLEVBQUU7QUFBQztBQUV0QyxTQUFTTixTQUFTSyxNQUFjO0lBQzlCWSxjQUFjZCxRQUFRYyxhQUFhWjtJQUNuQ1csVUFBVUosT0FBTyxDQUFDLENBQUNNO1FBQ2pCQSxTQUFTRDtJQUNYO0FBQ0Y7QUFJQSxTQUFTVixNQUFNLEtBQW1CO1FBQW5CLEVBQUUsR0FBR1ksT0FBYyxHQUFuQjtJQUNiLE1BQU1SLEtBQUt2QjtJQUVYLE1BQU1nQyxTQUFTLENBQUNELFFBQ2RuQixTQUFTO1lBQ1BDLE1BQU07WUFDTk0sT0FBTztnQkFBRSxHQUFHWSxLQUFLO2dCQUFFUjtZQUFHO1FBQ3hCO0lBQ0YsTUFBTVUsVUFBVSxJQUFNckIsU0FBUztZQUFFQyxNQUFNO1lBQWlCTixTQUFTZ0I7UUFBRztJQUVwRVgsU0FBUztRQUNQQyxNQUFNO1FBQ05NLE9BQU87WUFDTCxHQUFHWSxLQUFLO1lBQ1JSO1lBQ0FHLE1BQU07WUFDTlEsY0FBYyxDQUFDUjtnQkFDYixJQUFJLENBQUNBLE1BQU1PO1lBQ2I7UUFDRjtJQUNGO0lBRUEsT0FBTztRQUNMVixJQUFJQTtRQUNKVTtRQUNBRDtJQUNGO0FBQ0Y7QUFFQSxTQUFTRztJQUNQLE1BQU0sQ0FBQ25CLE9BQU9vQixTQUFTLEdBQUc3QywyQ0FBYyxDQUFRc0M7SUFFaER0Qyw0Q0FBZTs4QkFBQztZQUNkcUMsVUFBVVcsSUFBSSxDQUFDSDtZQUNmO3NDQUFPO29CQUNMLE1BQU1JLFFBQVFaLFVBQVVhLE9BQU8sQ0FBQ0w7b0JBQ2hDLElBQUlJLFFBQVEsQ0FBQyxHQUFHO3dCQUNkWixVQUFVYyxNQUFNLENBQUNGLE9BQU87b0JBQzFCO2dCQUNGOztRQUNGOzZCQUFHO1FBQUN4QjtLQUFNO0lBRVYsT0FBTztRQUNMLEdBQUdBLEtBQUs7UUFDUkc7UUFDQWMsU0FBUyxDQUFDMUIsVUFBcUJLLFNBQVM7Z0JBQUVDLE1BQU07Z0JBQWlCTjtZQUFRO0lBQzNFO0FBQ0Y7QUFFMEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL1dvbmRlclZpdGUtZnJvbnRlbmQvc3JjL2hvb2tzL3VzZS10b2FzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIlxuXG5pbXBvcnQgdHlwZSB7XG4gIFRvYXN0QWN0aW9uRWxlbWVudCxcbiAgVG9hc3RQcm9wcyxcbn0gZnJvbSBcIkAvY29tcG9uZW50cy91aS90b2FzdFwiXG5cbmNvbnN0IFRPQVNUX0xJTUlUID0gMVxuY29uc3QgVE9BU1RfUkVNT1ZFX0RFTEFZID0gMTAwMDAwMFxuXG50eXBlIFRvYXN0ZXJUb2FzdCA9IFRvYXN0UHJvcHMgJiB7XG4gIGlkOiBzdHJpbmdcbiAgdGl0bGU/OiBSZWFjdC5SZWFjdE5vZGVcbiAgZGVzY3JpcHRpb24/OiBSZWFjdC5SZWFjdE5vZGVcbiAgYWN0aW9uPzogVG9hc3RBY3Rpb25FbGVtZW50XG59XG5cbmNvbnN0IGFjdGlvblR5cGVzID0ge1xuICBBRERfVE9BU1Q6IFwiQUREX1RPQVNUXCIsXG4gIFVQREFURV9UT0FTVDogXCJVUERBVEVfVE9BU1RcIixcbiAgRElTTUlTU19UT0FTVDogXCJESVNNSVNTX1RPQVNUXCIsXG4gIFJFTU9WRV9UT0FTVDogXCJSRU1PVkVfVE9BU1RcIixcbn0gYXMgY29uc3RcblxubGV0IGNvdW50ID0gMFxuXG5mdW5jdGlvbiBnZW5JZCgpIHtcbiAgY291bnQgPSAoY291bnQgKyAxKSAlIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG4gIHJldHVybiBjb3VudC50b1N0cmluZygpXG59XG5cbnR5cGUgQWN0aW9uVHlwZSA9IHR5cGVvZiBhY3Rpb25UeXBlc1xuXG50eXBlIEFjdGlvbiA9XG4gIHwge1xuICAgICAgdHlwZTogQWN0aW9uVHlwZVtcIkFERF9UT0FTVFwiXVxuICAgICAgdG9hc3Q6IFRvYXN0ZXJUb2FzdFxuICAgIH1cbiAgfCB7XG4gICAgICB0eXBlOiBBY3Rpb25UeXBlW1wiVVBEQVRFX1RPQVNUXCJdXG4gICAgICB0b2FzdDogUGFydGlhbDxUb2FzdGVyVG9hc3Q+XG4gICAgfVxuICB8IHtcbiAgICAgIHR5cGU6IEFjdGlvblR5cGVbXCJESVNNSVNTX1RPQVNUXCJdXG4gICAgICB0b2FzdElkPzogVG9hc3RlclRvYXN0W1wiaWRcIl1cbiAgICB9XG4gIHwge1xuICAgICAgdHlwZTogQWN0aW9uVHlwZVtcIlJFTU9WRV9UT0FTVFwiXVxuICAgICAgdG9hc3RJZD86IFRvYXN0ZXJUb2FzdFtcImlkXCJdXG4gICAgfVxuXG5pbnRlcmZhY2UgU3RhdGUge1xuICB0b2FzdHM6IFRvYXN0ZXJUb2FzdFtdXG59XG5cbmNvbnN0IHRvYXN0VGltZW91dHMgPSBuZXcgTWFwPHN0cmluZywgUmV0dXJuVHlwZTx0eXBlb2Ygc2V0VGltZW91dD4+KClcblxuY29uc3QgYWRkVG9SZW1vdmVRdWV1ZSA9ICh0b2FzdElkOiBzdHJpbmcpID0+IHtcbiAgaWYgKHRvYXN0VGltZW91dHMuaGFzKHRvYXN0SWQpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgdG9hc3RUaW1lb3V0cy5kZWxldGUodG9hc3RJZClcbiAgICBkaXNwYXRjaCh7XG4gICAgICB0eXBlOiBcIlJFTU9WRV9UT0FTVFwiLFxuICAgICAgdG9hc3RJZDogdG9hc3RJZCxcbiAgICB9KVxuICB9LCBUT0FTVF9SRU1PVkVfREVMQVkpXG5cbiAgdG9hc3RUaW1lb3V0cy5zZXQodG9hc3RJZCwgdGltZW91dClcbn1cblxuZXhwb3J0IGNvbnN0IHJlZHVjZXIgPSAoc3RhdGU6IFN0YXRlLCBhY3Rpb246IEFjdGlvbik6IFN0YXRlID0+IHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgXCJBRERfVE9BU1RcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICB0b2FzdHM6IFthY3Rpb24udG9hc3QsIC4uLnN0YXRlLnRvYXN0c10uc2xpY2UoMCwgVE9BU1RfTElNSVQpLFxuICAgICAgfVxuXG4gICAgY2FzZSBcIlVQREFURV9UT0FTVFwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIHRvYXN0czogc3RhdGUudG9hc3RzLm1hcCgodCkgPT5cbiAgICAgICAgICB0LmlkID09PSBhY3Rpb24udG9hc3QuaWQgPyB7IC4uLnQsIC4uLmFjdGlvbi50b2FzdCB9IDogdFxuICAgICAgICApLFxuICAgICAgfVxuXG4gICAgY2FzZSBcIkRJU01JU1NfVE9BU1RcIjoge1xuICAgICAgY29uc3QgeyB0b2FzdElkIH0gPSBhY3Rpb25cblxuICAgICAgLy8gISBTaWRlIGVmZmVjdHMgISAtIFRoaXMgY291bGQgYmUgZXh0cmFjdGVkIGludG8gYSBkaXNtaXNzVG9hc3QoKSBhY3Rpb24sXG4gICAgICAvLyBidXQgSSdsbCBrZWVwIGl0IGhlcmUgZm9yIHNpbXBsaWNpdHlcbiAgICAgIGlmICh0b2FzdElkKSB7XG4gICAgICAgIGFkZFRvUmVtb3ZlUXVldWUodG9hc3RJZClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnRvYXN0cy5mb3JFYWNoKCh0b2FzdCkgPT4ge1xuICAgICAgICAgIGFkZFRvUmVtb3ZlUXVldWUodG9hc3QuaWQpXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICB0b2FzdHM6IHN0YXRlLnRvYXN0cy5tYXAoKHQpID0+XG4gICAgICAgICAgdC5pZCA9PT0gdG9hc3RJZCB8fCB0b2FzdElkID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIC4uLnQsXG4gICAgICAgICAgICAgICAgb3BlbjogZmFsc2UsXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogdFxuICAgICAgICApLFxuICAgICAgfVxuICAgIH1cbiAgICBjYXNlIFwiUkVNT1ZFX1RPQVNUXCI6XG4gICAgICBpZiAoYWN0aW9uLnRvYXN0SWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgIHRvYXN0czogW10sXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICB0b2FzdHM6IHN0YXRlLnRvYXN0cy5maWx0ZXIoKHQpID0+IHQuaWQgIT09IGFjdGlvbi50b2FzdElkKSxcbiAgICAgIH1cbiAgfVxufVxuXG5jb25zdCBsaXN0ZW5lcnM6IEFycmF5PChzdGF0ZTogU3RhdGUpID0+IHZvaWQ+ID0gW11cblxubGV0IG1lbW9yeVN0YXRlOiBTdGF0ZSA9IHsgdG9hc3RzOiBbXSB9XG5cbmZ1bmN0aW9uIGRpc3BhdGNoKGFjdGlvbjogQWN0aW9uKSB7XG4gIG1lbW9yeVN0YXRlID0gcmVkdWNlcihtZW1vcnlTdGF0ZSwgYWN0aW9uKVxuICBsaXN0ZW5lcnMuZm9yRWFjaCgobGlzdGVuZXIpID0+IHtcbiAgICBsaXN0ZW5lcihtZW1vcnlTdGF0ZSlcbiAgfSlcbn1cblxudHlwZSBUb2FzdCA9IE9taXQ8VG9hc3RlclRvYXN0LCBcImlkXCI+XG5cbmZ1bmN0aW9uIHRvYXN0KHsgLi4ucHJvcHMgfTogVG9hc3QpIHtcbiAgY29uc3QgaWQgPSBnZW5JZCgpXG5cbiAgY29uc3QgdXBkYXRlID0gKHByb3BzOiBUb2FzdGVyVG9hc3QpID0+XG4gICAgZGlzcGF0Y2goe1xuICAgICAgdHlwZTogXCJVUERBVEVfVE9BU1RcIixcbiAgICAgIHRvYXN0OiB7IC4uLnByb3BzLCBpZCB9LFxuICAgIH0pXG4gIGNvbnN0IGRpc21pc3MgPSAoKSA9PiBkaXNwYXRjaCh7IHR5cGU6IFwiRElTTUlTU19UT0FTVFwiLCB0b2FzdElkOiBpZCB9KVxuXG4gIGRpc3BhdGNoKHtcbiAgICB0eXBlOiBcIkFERF9UT0FTVFwiLFxuICAgIHRvYXN0OiB7XG4gICAgICAuLi5wcm9wcyxcbiAgICAgIGlkLFxuICAgICAgb3BlbjogdHJ1ZSxcbiAgICAgIG9uT3BlbkNoYW5nZTogKG9wZW4pID0+IHtcbiAgICAgICAgaWYgKCFvcGVuKSBkaXNtaXNzKClcbiAgICAgIH0sXG4gICAgfSxcbiAgfSlcblxuICByZXR1cm4ge1xuICAgIGlkOiBpZCxcbiAgICBkaXNtaXNzLFxuICAgIHVwZGF0ZSxcbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VUb2FzdCgpIHtcbiAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSBSZWFjdC51c2VTdGF0ZTxTdGF0ZT4obWVtb3J5U3RhdGUpXG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBsaXN0ZW5lcnMucHVzaChzZXRTdGF0ZSlcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc3QgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZihzZXRTdGF0ZSlcbiAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpXG4gICAgICB9XG4gICAgfVxuICB9LCBbc3RhdGVdKVxuXG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgdG9hc3QsXG4gICAgZGlzbWlzczogKHRvYXN0SWQ/OiBzdHJpbmcpID0+IGRpc3BhdGNoKHsgdHlwZTogXCJESVNNSVNTX1RPQVNUXCIsIHRvYXN0SWQgfSksXG4gIH1cbn1cblxuZXhwb3J0IHsgdXNlVG9hc3QsIHRvYXN0IH1cbiJdLCJuYW1lcyI6WyJSZWFjdCIsIlRPQVNUX0xJTUlUIiwiVE9BU1RfUkVNT1ZFX0RFTEFZIiwiYWN0aW9uVHlwZXMiLCJBRERfVE9BU1QiLCJVUERBVEVfVE9BU1QiLCJESVNNSVNTX1RPQVNUIiwiUkVNT1ZFX1RPQVNUIiwiY291bnQiLCJnZW5JZCIsIk51bWJlciIsIk1BWF9TQUZFX0lOVEVHRVIiLCJ0b1N0cmluZyIsInRvYXN0VGltZW91dHMiLCJNYXAiLCJhZGRUb1JlbW92ZVF1ZXVlIiwidG9hc3RJZCIsImhhcyIsInRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiZGVsZXRlIiwiZGlzcGF0Y2giLCJ0eXBlIiwic2V0IiwicmVkdWNlciIsInN0YXRlIiwiYWN0aW9uIiwidG9hc3RzIiwidG9hc3QiLCJzbGljZSIsIm1hcCIsInQiLCJpZCIsImZvckVhY2giLCJ1bmRlZmluZWQiLCJvcGVuIiwiZmlsdGVyIiwibGlzdGVuZXJzIiwibWVtb3J5U3RhdGUiLCJsaXN0ZW5lciIsInByb3BzIiwidXBkYXRlIiwiZGlzbWlzcyIsIm9uT3BlbkNoYW5nZSIsInVzZVRvYXN0Iiwic2V0U3RhdGUiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInB1c2giLCJpbmRleCIsImluZGV4T2YiLCJzcGxpY2UiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/use-toast.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/integrations/supabase/client.ts":
/*!*********************************************!*\
  !*** ./src/integrations/supabase/client.ts ***!
  \*********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   supabase: () => (/* binding */ supabase)\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/supabase-js */ \"(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/index.js\");\n\nconst supabaseUrl = 'https://zwtxebgyiknysfmpeejy.supabase.co';\nconst supabaseAnonKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inp3dHhlYmd5aWtueXNmbXBlZWp5Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3MDI0ODg5MzAsImV4cCI6MjAxODA2NDkzMH0.SbUXk6kbZzn9kY1VVZ3CZXw_cYGiknf2fGV4TBvdG0Q';\nconst supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey, {\n    auth: {\n        autoRefreshToken: true,\n        persistSession: true,\n        detectSessionInUrl: true,\n        flowType: 'pkce'\n    }\n});\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9pbnRlZ3JhdGlvbnMvc3VwYWJhc2UvY2xpZW50LnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXFEO0FBR3JELE1BQU1DLGNBQWM7QUFDcEIsTUFBTUMsa0JBQWtCO0FBRWpCLE1BQU1DLFdBQVdILG1FQUFZQSxDQUFXQyxhQUFhQyxpQkFBaUI7SUFDM0VFLE1BQU07UUFDSkMsa0JBQWtCO1FBQ2xCQyxnQkFBZ0I7UUFDaEJDLG9CQUFvQjtRQUNwQkMsVUFBVTtJQUNaO0FBQ0YsR0FBRyIsInNvdXJjZXMiOlsiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvV29uZGVyVml0ZS1mcm9udGVuZC9zcmMvaW50ZWdyYXRpb25zL3N1cGFiYXNlL2NsaWVudC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVDbGllbnQgfSBmcm9tICdAc3VwYWJhc2Uvc3VwYWJhc2UtanMnO1xuaW1wb3J0IHsgRGF0YWJhc2UgfSBmcm9tICcuL3R5cGVzJztcblxuY29uc3Qgc3VwYWJhc2VVcmwgPSAnaHR0cHM6Ly96d3R4ZWJneWlrbnlzZm1wZWVqeS5zdXBhYmFzZS5jbyc7XG5jb25zdCBzdXBhYmFzZUFub25LZXkgPSAnZXlKaGJHY2lPaUpJVXpJMU5pSXNJblI1Y0NJNklrcFhWQ0o5LmV5SnBjM01pT2lKemRYQmhZbUZ6WlNJc0luSmxaaUk2SW5wM2RIaGxZbWQ1YVd0dWVYTm1iWEJsWldwNUlpd2ljbTlzWlNJNkltRnViMjRpTENKcFlYUWlPakUzTURJME9EZzVNekFzSW1WNGNDSTZNakF4T0RBMk5Ea3pNSDAuU2JVWGs2a2Jaem45a1kxVlZaM0NaWHdfY1lHaWtuZjJmR1Y0VEJ2ZEcwUSc7XG5cbmV4cG9ydCBjb25zdCBzdXBhYmFzZSA9IGNyZWF0ZUNsaWVudDxEYXRhYmFzZT4oc3VwYWJhc2VVcmwsIHN1cGFiYXNlQW5vbktleSwge1xuICBhdXRoOiB7XG4gICAgYXV0b1JlZnJlc2hUb2tlbjogdHJ1ZSxcbiAgICBwZXJzaXN0U2Vzc2lvbjogdHJ1ZSxcbiAgICBkZXRlY3RTZXNzaW9uSW5Vcmw6IHRydWUsXG4gICAgZmxvd1R5cGU6ICdwa2NlJ1xuICB9XG59KTsiXSwibmFtZXMiOlsiY3JlYXRlQ2xpZW50Iiwic3VwYWJhc2VVcmwiLCJzdXBhYmFzZUFub25LZXkiLCJzdXBhYmFzZSIsImF1dGgiLCJhdXRvUmVmcmVzaFRva2VuIiwicGVyc2lzdFNlc3Npb24iLCJkZXRlY3RTZXNzaW9uSW5VcmwiLCJmbG93VHlwZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/integrations/supabase/client.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/plasmic-init.ts":
/*!*****************************!*\
  !*** ./src/plasmic-init.ts ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PLASMIC: () => (/* binding */ PLASMIC)\n/* harmony export */ });\n/* harmony import */ var _plasmicapp_loader_react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @plasmicapp/loader-react */ \"(app-pages-browser)/./node_modules/@plasmicapp/loader-react/dist/index.esm.js\");\n\nconst PLASMIC = (0,_plasmicapp_loader_react__WEBPACK_IMPORTED_MODULE_0__.initPlasmicLoader)({\n    projects: [\n        {\n            id: \"d8QwHC2mX9hhyJO4b6QhTXJSz8KeFcYdUdE0xTjMXp313qdoyzZVAFttkzqSfnGOofWpNEug68jRE3ShlUA\",\n            token: \"d8QwHC2mX9hhyJO4b6QhTXJSz8KeFcYdUdE0xTjMXp313qdoyzZVAFttkzqSfnGOofWpNEug68jRE3ShlUA\"\n        }\n    ]\n});\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9wbGFzbWljLWluaXQudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBNkQ7QUFFdEQsTUFBTUMsVUFBVUQsMkVBQWlCQSxDQUFDO0lBQ3ZDRSxVQUFVO1FBQUM7WUFDVEMsSUFBSTtZQUNKQyxPQUFPO1FBQ1Q7S0FBRTtBQUNKLEdBQUciLCJzb3VyY2VzIjpbIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL1dvbmRlclZpdGUtZnJvbnRlbmQvc3JjL3BsYXNtaWMtaW5pdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpbml0UGxhc21pY0xvYWRlciB9IGZyb20gXCJAcGxhc21pY2FwcC9sb2FkZXItcmVhY3RcIjtcblxuZXhwb3J0IGNvbnN0IFBMQVNNSUMgPSBpbml0UGxhc21pY0xvYWRlcih7XG4gIHByb2plY3RzOiBbe1xuICAgIGlkOiBcImQ4UXdIQzJtWDloaHlKTzRiNlFoVFhKU3o4S2VGY1lkVWRFMHhUak1YcDMxM3Fkb3l6WlZBRnR0a3pxU2ZuR09vZldwTkV1ZzY4alJFM1NobFVBXCIsXG4gICAgdG9rZW46IFwiZDhRd0hDMm1YOWhoeUpPNGI2UWhUWEpTejhLZUZjWWRVZEUweFRqTVhwMzEzcWRveXpaVkFGdHRrenFTZm5HT29mV3BORXVnNjhqUkUzU2hsVUFcIlxuICB9XSxcbn0pOyJdLCJuYW1lcyI6WyJpbml0UGxhc21pY0xvYWRlciIsIlBMQVNNSUMiLCJwcm9qZWN0cyIsImlkIiwidG9rZW4iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/plasmic-init.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/providers/AuthProvider.tsx":
/*!****************************************!*\
  !*** ./src/providers/AuthProvider.tsx ***!
  \****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthProvider: () => (/* binding */ AuthProvider),\n/* harmony export */   useAuth: () => (/* reexport safe */ _auth_provider_variants__WEBPACK_IMPORTED_MODULE_3__.useAuth)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _integrations_supabase_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/integrations/supabase/client */ \"(app-pages-browser)/./src/integrations/supabase/client.ts\");\n/* harmony import */ var _auth_provider_variants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./auth-provider-variants */ \"(app-pages-browser)/./src/providers/auth-provider-variants.ts\");\n/* __next_internal_client_entry_do_not_use__ AuthProvider,useAuth auto */ \nvar _s = $RefreshSig$();\n\n\nconst AuthContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nfunction AuthProvider(param) {\n    let { children } = param;\n    _s();\n    const [session, setSession] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"AuthProvider.useEffect\": ()=>{\n            // Get initial session\n            _integrations_supabase_client__WEBPACK_IMPORTED_MODULE_2__.supabase.auth.getSession().then({\n                \"AuthProvider.useEffect\": (param)=>{\n                    let { data: { session: initialSession } } = param;\n                    setSession(initialSession);\n                    setIsLoading(false);\n                }\n            }[\"AuthProvider.useEffect\"]);\n            // Listen for auth changes\n            const { data: { subscription } } = _integrations_supabase_client__WEBPACK_IMPORTED_MODULE_2__.supabase.auth.onAuthStateChange({\n                \"AuthProvider.useEffect\": (_event, session)=>{\n                    setSession(session);\n                    setIsLoading(false);\n                }\n            }[\"AuthProvider.useEffect\"]);\n            return ({\n                \"AuthProvider.useEffect\": ()=>subscription.unsubscribe()\n            })[\"AuthProvider.useEffect\"];\n        }\n    }[\"AuthProvider.useEffect\"], []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(AuthContext.Provider, {\n        value: {\n            session,\n            isLoading\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/wonderlandmitch/CascadeProjects/WonderVite-frontend/src/providers/AuthProvider.tsx\",\n        lineNumber: 36,\n        columnNumber: 5\n    }, this);\n}\n_s(AuthProvider, \"NQYF8RTvjGI/R0nubQ12bVpD00A=\");\n_c = AuthProvider;\n\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9wcm92aWRlcnMvQXV0aFByb3ZpZGVyLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFFa0U7QUFFUjtBQVExRCxNQUFNSyw0QkFBY0osb0RBQWFBLENBQThCSztBQUV4RCxTQUFTQyxhQUFhLEtBQTJDO1FBQTNDLEVBQUVDLFFBQVEsRUFBaUMsR0FBM0M7O0lBQzNCLE1BQU0sQ0FBQ0MsU0FBU0MsV0FBVyxHQUFHUiwrQ0FBUUEsQ0FBaUI7SUFDdkQsTUFBTSxDQUFDUyxXQUFXQyxhQUFhLEdBQUdWLCtDQUFRQSxDQUFDO0lBRTNDQyxnREFBU0E7a0NBQUM7WUFDUixzQkFBc0I7WUFDdEJDLG1FQUFRQSxDQUFDUyxJQUFJLENBQUNDLFVBQVUsR0FBR0MsSUFBSTswQ0FBQzt3QkFBQyxFQUFFQyxNQUFNLEVBQUVQLFNBQVNRLGNBQWMsRUFBRSxFQUFFO29CQUNwRVAsV0FBV087b0JBQ1hMLGFBQWE7Z0JBQ2Y7O1lBRUEsMEJBQTBCO1lBQzFCLE1BQU0sRUFBRUksTUFBTSxFQUFFRSxZQUFZLEVBQUUsRUFBRSxHQUFHZCxtRUFBUUEsQ0FBQ1MsSUFBSSxDQUFDTSxpQkFBaUI7MENBQUMsQ0FBQ0MsUUFBUVg7b0JBQzFFQyxXQUFXRDtvQkFDWEcsYUFBYTtnQkFDZjs7WUFFQTswQ0FBTyxJQUFNTSxhQUFhRyxXQUFXOztRQUN2QztpQ0FBRyxFQUFFO0lBRUwscUJBQ0UsOERBQUNoQixZQUFZaUIsUUFBUTtRQUFDQyxPQUFPO1lBQUVkO1lBQVNFO1FBQVU7a0JBQy9DSDs7Ozs7O0FBR1A7R0F6QmdCRDtLQUFBQTtBQTJCbUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL1dvbmRlclZpdGUtZnJvbnRlbmQvc3JjL3Byb3ZpZGVycy9BdXRoUHJvdmlkZXIudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcblxuaW1wb3J0IFJlYWN0LCB7IGNyZWF0ZUNvbnRleHQsIHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBTZXNzaW9uIH0gZnJvbSAnQHN1cGFiYXNlL3N1cGFiYXNlLWpzJztcbmltcG9ydCB7IHN1cGFiYXNlIH0gZnJvbSAnQC9pbnRlZ3JhdGlvbnMvc3VwYWJhc2UvY2xpZW50JztcbmltcG9ydCB7IEFVVEhfU1RPUkFHRV9LRVkgfSBmcm9tICcuL2F1dGgtcHJvdmlkZXItdmFyaWFudHMnO1xuXG5pbnRlcmZhY2UgQXV0aENvbnRleHRUeXBlIHtcbiAgc2Vzc2lvbjogU2Vzc2lvbiB8IG51bGw7XG4gIGlzTG9hZGluZzogYm9vbGVhbjtcbn1cblxuY29uc3QgQXV0aENvbnRleHQgPSBjcmVhdGVDb250ZXh0PEF1dGhDb250ZXh0VHlwZSB8IHVuZGVmaW5lZD4odW5kZWZpbmVkKTtcblxuZXhwb3J0IGZ1bmN0aW9uIEF1dGhQcm92aWRlcih7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZSB9KSB7XG4gIGNvbnN0IFtzZXNzaW9uLCBzZXRTZXNzaW9uXSA9IHVzZVN0YXRlPFNlc3Npb24gfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2lzTG9hZGluZywgc2V0SXNMb2FkaW5nXSA9IHVzZVN0YXRlKHRydWUpO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gR2V0IGluaXRpYWwgc2Vzc2lvblxuICAgIHN1cGFiYXNlLmF1dGguZ2V0U2Vzc2lvbigpLnRoZW4oKHsgZGF0YTogeyBzZXNzaW9uOiBpbml0aWFsU2Vzc2lvbiB9IH0pID0+IHtcbiAgICAgIHNldFNlc3Npb24oaW5pdGlhbFNlc3Npb24pO1xuICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICB9KTtcblxuICAgIC8vIExpc3RlbiBmb3IgYXV0aCBjaGFuZ2VzXG4gICAgY29uc3QgeyBkYXRhOiB7IHN1YnNjcmlwdGlvbiB9IH0gPSBzdXBhYmFzZS5hdXRoLm9uQXV0aFN0YXRlQ2hhbmdlKChfZXZlbnQsIHNlc3Npb24pID0+IHtcbiAgICAgIHNldFNlc3Npb24oc2Vzc2lvbik7XG4gICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuICgpID0+IHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICB9LCBbXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8QXV0aENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3sgc2Vzc2lvbiwgaXNMb2FkaW5nIH19PlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvQXV0aENvbnRleHQuUHJvdmlkZXI+XG4gICk7XG59XG5cbmV4cG9ydCB7IHVzZUF1dGggfSBmcm9tICcuL2F1dGgtcHJvdmlkZXItdmFyaWFudHMnOyJdLCJuYW1lcyI6WyJSZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInN1cGFiYXNlIiwiQXV0aENvbnRleHQiLCJ1bmRlZmluZWQiLCJBdXRoUHJvdmlkZXIiLCJjaGlsZHJlbiIsInNlc3Npb24iLCJzZXRTZXNzaW9uIiwiaXNMb2FkaW5nIiwic2V0SXNMb2FkaW5nIiwiYXV0aCIsImdldFNlc3Npb24iLCJ0aGVuIiwiZGF0YSIsImluaXRpYWxTZXNzaW9uIiwic3Vic2NyaXB0aW9uIiwib25BdXRoU3RhdGVDaGFuZ2UiLCJfZXZlbnQiLCJ1bnN1YnNjcmliZSIsIlByb3ZpZGVyIiwidmFsdWUiLCJ1c2VBdXRoIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/providers/AuthProvider.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/providers/QueryProvider.tsx":
/*!*****************************************!*\
  !*** ./src/providers/QueryProvider.tsx ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QueryProvider: () => (/* binding */ QueryProvider)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _tanstack_react_query__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tanstack/react-query */ \"(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/QueryClientProvider.js\");\n/* harmony import */ var _config_queryClient__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/config/queryClient */ \"(app-pages-browser)/./src/config/queryClient.ts\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* __next_internal_client_entry_do_not_use__ QueryProvider auto */ \n\n\n\nfunction QueryProvider(param) {\n    let { children } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_tanstack_react_query__WEBPACK_IMPORTED_MODULE_3__.QueryClientProvider, {\n        client: _config_queryClient__WEBPACK_IMPORTED_MODULE_1__.queryClient,\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/wonderlandmitch/CascadeProjects/WonderVite-frontend/src/providers/QueryProvider.tsx\",\n        lineNumber: 9,\n        columnNumber: 5\n    }, this);\n}\n_c = QueryProvider;\nvar _c;\n$RefreshReg$(_c, \"QueryProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9wcm92aWRlcnMvUXVlcnlQcm92aWRlci50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUUyRDtBQUNUO0FBQ3pCO0FBRWxCLFNBQVNHLGNBQWMsS0FBMkM7UUFBM0MsRUFBRUMsUUFBUSxFQUFpQyxHQUEzQztJQUM1QixxQkFDRSw4REFBQ0osc0VBQW1CQTtRQUFDSyxRQUFRSiw0REFBV0E7a0JBQ3JDRzs7Ozs7O0FBR1A7S0FOZ0JEIiwic291cmNlcyI6WyIvVXNlcnMvd29uZGVybGFuZG1pdGNoL0Nhc2NhZGVQcm9qZWN0cy9Xb25kZXJWaXRlLWZyb250ZW5kL3NyYy9wcm92aWRlcnMvUXVlcnlQcm92aWRlci50c3giXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbmltcG9ydCB7IFF1ZXJ5Q2xpZW50UHJvdmlkZXIgfSBmcm9tICdAdGFuc3RhY2svcmVhY3QtcXVlcnknXG5pbXBvcnQgeyBxdWVyeUNsaWVudCB9IGZyb20gJ0AvY29uZmlnL3F1ZXJ5Q2xpZW50J1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuXG5leHBvcnQgZnVuY3Rpb24gUXVlcnlQcm92aWRlcih7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZSB9KSB7XG4gIHJldHVybiAoXG4gICAgPFF1ZXJ5Q2xpZW50UHJvdmlkZXIgY2xpZW50PXtxdWVyeUNsaWVudH0+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9RdWVyeUNsaWVudFByb3ZpZGVyPlxuICApXG59Il0sIm5hbWVzIjpbIlF1ZXJ5Q2xpZW50UHJvdmlkZXIiLCJxdWVyeUNsaWVudCIsIlJlYWN0IiwiUXVlcnlQcm92aWRlciIsImNoaWxkcmVuIiwiY2xpZW50Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/providers/QueryProvider.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/providers/auth-provider-variants.ts":
/*!*************************************************!*\
  !*** ./src/providers/auth-provider-variants.ts ***!
  \*************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AUTH_STORAGE_KEY: () => (/* binding */ AUTH_STORAGE_KEY),\n/* harmony export */   AuthContext: () => (/* binding */ AuthContext),\n/* harmony export */   useAuth: () => (/* binding */ useAuth)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nconst AUTH_STORAGE_KEY = 'auth_session';\nconst AuthContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(undefined);\nfunction useAuth() {\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(AuthContext);\n    if (context === undefined) {\n        throw new Error('useAuth must be used within an AuthProvider');\n    }\n    return context;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9wcm92aWRlcnMvYXV0aC1wcm92aWRlci12YXJpYW50cy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFrRDtBQUczQyxNQUFNRSxtQkFBbUIsZUFBZTtBQU94QyxNQUFNQyxjQUFjSCxvREFBYUEsQ0FBOEJJLFdBQVc7QUFFMUUsU0FBU0M7SUFDZCxNQUFNQyxVQUFVTCxpREFBVUEsQ0FBQ0U7SUFDM0IsSUFBSUcsWUFBWUYsV0FBVztRQUN6QixNQUFNLElBQUlHLE1BQU07SUFDbEI7SUFDQSxPQUFPRDtBQUNUIiwic291cmNlcyI6WyIvVXNlcnMvd29uZGVybGFuZG1pdGNoL0Nhc2NhZGVQcm9qZWN0cy9Xb25kZXJWaXRlLWZyb250ZW5kL3NyYy9wcm92aWRlcnMvYXV0aC1wcm92aWRlci12YXJpYW50cy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgU2Vzc2lvbiB9IGZyb20gJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcyc7XG5cbmV4cG9ydCBjb25zdCBBVVRIX1NUT1JBR0VfS0VZID0gJ2F1dGhfc2Vzc2lvbic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXV0aENvbnRleHRUeXBlIHtcbiAgc2Vzc2lvbjogU2Vzc2lvbiB8IG51bGw7XG4gIGlzTG9hZGluZzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNvbnN0IEF1dGhDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxBdXRoQ29udGV4dFR5cGUgfCB1bmRlZmluZWQ+KHVuZGVmaW5lZCk7XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VBdXRoKCk6IEF1dGhDb250ZXh0VHlwZSB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KEF1dGhDb250ZXh0KTtcbiAgaWYgKGNvbnRleHQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndXNlQXV0aCBtdXN0IGJlIHVzZWQgd2l0aGluIGFuIEF1dGhQcm92aWRlcicpO1xuICB9XG4gIHJldHVybiBjb250ZXh0O1xufVxuIl0sIm5hbWVzIjpbImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwiQVVUSF9TVE9SQUdFX0tFWSIsIkF1dGhDb250ZXh0IiwidW5kZWZpbmVkIiwidXNlQXV0aCIsImNvbnRleHQiLCJFcnJvciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/providers/auth-provider-variants.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/cjs/react-dom-server-legacy.browser.development.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react-dom/cjs/react-dom-server-legacy.browser.development.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-dom-server-legacy.browser.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/*\n\n\n JS Implementation of MurmurHash3 (r136) (as of May 20, 2011)\n\n Copyright (c) 2011 Gary Court\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n SOFTWARE.\n*/\n\n true &&\n  (function () {\n    function styleReplacer(match, prefix, s, suffix) {\n      return \"\" + prefix + (\"s\" === s ? \"\\\\73 \" : \"\\\\53 \") + suffix;\n    }\n    function scriptReplacer(match, prefix, s, suffix) {\n      return \"\" + prefix + (\"s\" === s ? \"\\\\u0073\" : \"\\\\u0053\") + suffix;\n    }\n    function objectName(object) {\n      return Object.prototype.toString\n        .call(object)\n        .replace(/^\\[object (.*)\\]$/, function (m, p0) {\n          return p0;\n        });\n    }\n    function describeKeyForErrorMessage(key) {\n      var encodedKey = JSON.stringify(key);\n      return '\"' + key + '\"' === encodedKey ? key : encodedKey;\n    }\n    function describeValueForErrorMessage(value) {\n      switch (typeof value) {\n        case \"string\":\n          return JSON.stringify(\n            10 >= value.length ? value : value.slice(0, 10) + \"...\"\n          );\n        case \"object\":\n          if (isArrayImpl(value)) return \"[...]\";\n          if (null !== value && value.$$typeof === CLIENT_REFERENCE_TAG)\n            return \"client\";\n          value = objectName(value);\n          return \"Object\" === value ? \"{...}\" : value;\n        case \"function\":\n          return value.$$typeof === CLIENT_REFERENCE_TAG\n            ? \"client\"\n            : (value = value.displayName || value.name)\n              ? \"function \" + value\n              : \"function\";\n        default:\n          return String(value);\n      }\n    }\n    function describeElementType(type) {\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n      }\n      if (\"object\" === typeof type)\n        switch (type.$$typeof) {\n          case REACT_FORWARD_REF_TYPE:\n            return describeElementType(type.render);\n          case REACT_MEMO_TYPE:\n            return describeElementType(type.type);\n          case REACT_LAZY_TYPE:\n            var payload = type._payload;\n            type = type._init;\n            try {\n              return describeElementType(type(payload));\n            } catch (x) {}\n        }\n      return \"\";\n    }\n    function describeObjectForErrorMessage(objectOrArray, expandedName) {\n      var objKind = objectName(objectOrArray);\n      if (\"Object\" !== objKind && \"Array\" !== objKind) return objKind;\n      var start = -1,\n        length = 0;\n      if (isArrayImpl(objectOrArray))\n        if (jsxChildrenParents.has(objectOrArray)) {\n          var type = jsxChildrenParents.get(objectOrArray);\n          objKind = \"<\" + describeElementType(type) + \">\";\n          for (var i = 0; i < objectOrArray.length; i++) {\n            var value = objectOrArray[i];\n            value =\n              \"string\" === typeof value\n                ? value\n                : \"object\" === typeof value && null !== value\n                  ? \"{\" + describeObjectForErrorMessage(value) + \"}\"\n                  : \"{\" + describeValueForErrorMessage(value) + \"}\";\n            \"\" + i === expandedName\n              ? ((start = objKind.length),\n                (length = value.length),\n                (objKind += value))\n              : (objKind =\n                  15 > value.length && 40 > objKind.length + value.length\n                    ? objKind + value\n                    : objKind + \"{...}\");\n          }\n          objKind += \"</\" + describeElementType(type) + \">\";\n        } else {\n          objKind = \"[\";\n          for (type = 0; type < objectOrArray.length; type++)\n            0 < type && (objKind += \", \"),\n              (i = objectOrArray[type]),\n              (i =\n                \"object\" === typeof i && null !== i\n                  ? describeObjectForErrorMessage(i)\n                  : describeValueForErrorMessage(i)),\n              \"\" + type === expandedName\n                ? ((start = objKind.length),\n                  (length = i.length),\n                  (objKind += i))\n                : (objKind =\n                    10 > i.length && 40 > objKind.length + i.length\n                      ? objKind + i\n                      : objKind + \"...\");\n          objKind += \"]\";\n        }\n      else if (objectOrArray.$$typeof === REACT_ELEMENT_TYPE)\n        objKind = \"<\" + describeElementType(objectOrArray.type) + \"/>\";\n      else {\n        if (objectOrArray.$$typeof === CLIENT_REFERENCE_TAG) return \"client\";\n        if (jsxPropsParents.has(objectOrArray)) {\n          objKind = jsxPropsParents.get(objectOrArray);\n          objKind = \"<\" + (describeElementType(objKind) || \"...\");\n          type = Object.keys(objectOrArray);\n          for (i = 0; i < type.length; i++) {\n            objKind += \" \";\n            value = type[i];\n            objKind += describeKeyForErrorMessage(value) + \"=\";\n            var _value2 = objectOrArray[value];\n            var _substr2 =\n              value === expandedName &&\n              \"object\" === typeof _value2 &&\n              null !== _value2\n                ? describeObjectForErrorMessage(_value2)\n                : describeValueForErrorMessage(_value2);\n            \"string\" !== typeof _value2 && (_substr2 = \"{\" + _substr2 + \"}\");\n            value === expandedName\n              ? ((start = objKind.length),\n                (length = _substr2.length),\n                (objKind += _substr2))\n              : (objKind =\n                  10 > _substr2.length && 40 > objKind.length + _substr2.length\n                    ? objKind + _substr2\n                    : objKind + \"...\");\n          }\n          objKind += \">\";\n        } else {\n          objKind = \"{\";\n          type = Object.keys(objectOrArray);\n          for (i = 0; i < type.length; i++)\n            0 < i && (objKind += \", \"),\n              (value = type[i]),\n              (objKind += describeKeyForErrorMessage(value) + \": \"),\n              (_value2 = objectOrArray[value]),\n              (_value2 =\n                \"object\" === typeof _value2 && null !== _value2\n                  ? describeObjectForErrorMessage(_value2)\n                  : describeValueForErrorMessage(_value2)),\n              value === expandedName\n                ? ((start = objKind.length),\n                  (length = _value2.length),\n                  (objKind += _value2))\n                : (objKind =\n                    10 > _value2.length && 40 > objKind.length + _value2.length\n                      ? objKind + _value2\n                      : objKind + \"...\");\n          objKind += \"}\";\n        }\n      }\n      return void 0 === expandedName\n        ? objKind\n        : -1 < start && 0 < length\n          ? ((objectOrArray = \" \".repeat(start) + \"^\".repeat(length)),\n            \"\\n  \" + objKind + \"\\n  \" + objectOrArray)\n          : \"\\n  \" + objKind;\n    }\n    function murmurhash3_32_gc(key, seed) {\n      var remainder = key.length & 3;\n      var bytes = key.length - remainder;\n      var h1 = seed;\n      for (seed = 0; seed < bytes; ) {\n        var k1 =\n          (key.charCodeAt(seed) & 255) |\n          ((key.charCodeAt(++seed) & 255) << 8) |\n          ((key.charCodeAt(++seed) & 255) << 16) |\n          ((key.charCodeAt(++seed) & 255) << 24);\n        ++seed;\n        k1 =\n          (3432918353 * (k1 & 65535) +\n            (((3432918353 * (k1 >>> 16)) & 65535) << 16)) &\n          4294967295;\n        k1 = (k1 << 15) | (k1 >>> 17);\n        k1 =\n          (461845907 * (k1 & 65535) +\n            (((461845907 * (k1 >>> 16)) & 65535) << 16)) &\n          4294967295;\n        h1 ^= k1;\n        h1 = (h1 << 13) | (h1 >>> 19);\n        h1 =\n          (5 * (h1 & 65535) + (((5 * (h1 >>> 16)) & 65535) << 16)) & 4294967295;\n        h1 = (h1 & 65535) + 27492 + ((((h1 >>> 16) + 58964) & 65535) << 16);\n      }\n      k1 = 0;\n      switch (remainder) {\n        case 3:\n          k1 ^= (key.charCodeAt(seed + 2) & 255) << 16;\n        case 2:\n          k1 ^= (key.charCodeAt(seed + 1) & 255) << 8;\n        case 1:\n          (k1 ^= key.charCodeAt(seed) & 255),\n            (k1 =\n              (3432918353 * (k1 & 65535) +\n                (((3432918353 * (k1 >>> 16)) & 65535) << 16)) &\n              4294967295),\n            (k1 = (k1 << 15) | (k1 >>> 17)),\n            (h1 ^=\n              (461845907 * (k1 & 65535) +\n                (((461845907 * (k1 >>> 16)) & 65535) << 16)) &\n              4294967295);\n      }\n      h1 ^= key.length;\n      h1 ^= h1 >>> 16;\n      h1 =\n        (2246822507 * (h1 & 65535) +\n          (((2246822507 * (h1 >>> 16)) & 65535) << 16)) &\n        4294967295;\n      h1 ^= h1 >>> 13;\n      h1 =\n        (3266489909 * (h1 & 65535) +\n          (((3266489909 * (h1 >>> 16)) & 65535) << 16)) &\n        4294967295;\n      return (h1 ^ (h1 >>> 16)) >>> 0;\n    }\n    function typeName(value) {\n      return (\n        (\"function\" === typeof Symbol &&\n          Symbol.toStringTag &&\n          value[Symbol.toStringTag]) ||\n        value.constructor.name ||\n        \"Object\"\n      );\n    }\n    function willCoercionThrow(value) {\n      try {\n        return testStringCoercion(value), !1;\n      } catch (e) {\n        return !0;\n      }\n    }\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function checkAttributeStringCoercion(value, attributeName) {\n      if (willCoercionThrow(value))\n        return (\n          console.error(\n            \"The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before using it here.\",\n            attributeName,\n            typeName(value)\n          ),\n          testStringCoercion(value)\n        );\n    }\n    function checkCSSPropertyStringCoercion(value, propName) {\n      if (willCoercionThrow(value))\n        return (\n          console.error(\n            \"The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before using it here.\",\n            propName,\n            typeName(value)\n          ),\n          testStringCoercion(value)\n        );\n    }\n    function checkHtmlStringCoercion(value) {\n      if (willCoercionThrow(value))\n        return (\n          console.error(\n            \"The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before using it here.\",\n            typeName(value)\n          ),\n          testStringCoercion(value)\n        );\n    }\n    function isAttributeNameSafe(attributeName) {\n      if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))\n        return !0;\n      if (hasOwnProperty.call(illegalAttributeNameCache, attributeName))\n        return !1;\n      if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))\n        return (validatedAttributeNameCache[attributeName] = !0);\n      illegalAttributeNameCache[attributeName] = !0;\n      console.error(\"Invalid attribute name: `%s`\", attributeName);\n      return !1;\n    }\n    function checkControlledValueProps(tagName, props) {\n      hasReadOnlyValue[props.type] ||\n        props.onChange ||\n        props.onInput ||\n        props.readOnly ||\n        props.disabled ||\n        null == props.value ||\n        (\"select\" === tagName\n          ? console.error(\n              \"You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set `onChange`.\"\n            )\n          : console.error(\n              \"You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.\"\n            ));\n      props.onChange ||\n        props.readOnly ||\n        props.disabled ||\n        null == props.checked ||\n        console.error(\n          \"You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.\"\n        );\n    }\n    function validateProperty$1(tagName, name) {\n      if (\n        hasOwnProperty.call(warnedProperties$1, name) &&\n        warnedProperties$1[name]\n      )\n        return !0;\n      if (rARIACamel$1.test(name)) {\n        tagName = \"aria-\" + name.slice(4).toLowerCase();\n        tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;\n        if (null == tagName)\n          return (\n            console.error(\n              \"Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.\",\n              name\n            ),\n            (warnedProperties$1[name] = !0)\n          );\n        if (name !== tagName)\n          return (\n            console.error(\n              \"Invalid ARIA attribute `%s`. Did you mean `%s`?\",\n              name,\n              tagName\n            ),\n            (warnedProperties$1[name] = !0)\n          );\n      }\n      if (rARIA$1.test(name)) {\n        tagName = name.toLowerCase();\n        tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;\n        if (null == tagName) return (warnedProperties$1[name] = !0), !1;\n        name !== tagName &&\n          (console.error(\n            \"Unknown ARIA attribute `%s`. Did you mean `%s`?\",\n            name,\n            tagName\n          ),\n          (warnedProperties$1[name] = !0));\n      }\n      return !0;\n    }\n    function validateProperties$2(type, props) {\n      var invalidProps = [],\n        key;\n      for (key in props)\n        validateProperty$1(type, key) || invalidProps.push(key);\n      props = invalidProps\n        .map(function (prop) {\n          return \"`\" + prop + \"`\";\n        })\n        .join(\", \");\n      1 === invalidProps.length\n        ? console.error(\n            \"Invalid aria prop %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props\",\n            props,\n            type\n          )\n        : 1 < invalidProps.length &&\n          console.error(\n            \"Invalid aria props %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props\",\n            props,\n            type\n          );\n    }\n    function validateProperty(tagName, name, value, eventRegistry) {\n      if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name])\n        return !0;\n      var lowerCasedName = name.toLowerCase();\n      if (\"onfocusin\" === lowerCasedName || \"onfocusout\" === lowerCasedName)\n        return (\n          console.error(\n            \"React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.\"\n          ),\n          (warnedProperties[name] = !0)\n        );\n      if (\n        \"function\" === typeof value &&\n        ((\"form\" === tagName && \"action\" === name) ||\n          (\"input\" === tagName && \"formAction\" === name) ||\n          (\"button\" === tagName && \"formAction\" === name))\n      )\n        return !0;\n      if (null != eventRegistry) {\n        tagName = eventRegistry.possibleRegistrationNames;\n        if (eventRegistry.registrationNameDependencies.hasOwnProperty(name))\n          return !0;\n        eventRegistry = tagName.hasOwnProperty(lowerCasedName)\n          ? tagName[lowerCasedName]\n          : null;\n        if (null != eventRegistry)\n          return (\n            console.error(\n              \"Invalid event handler property `%s`. Did you mean `%s`?\",\n              name,\n              eventRegistry\n            ),\n            (warnedProperties[name] = !0)\n          );\n        if (EVENT_NAME_REGEX.test(name))\n          return (\n            console.error(\n              \"Unknown event handler property `%s`. It will be ignored.\",\n              name\n            ),\n            (warnedProperties[name] = !0)\n          );\n      } else if (EVENT_NAME_REGEX.test(name))\n        return (\n          INVALID_EVENT_NAME_REGEX.test(name) &&\n            console.error(\n              \"Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.\",\n              name\n            ),\n          (warnedProperties[name] = !0)\n        );\n      if (rARIA.test(name) || rARIACamel.test(name)) return !0;\n      if (\"innerhtml\" === lowerCasedName)\n        return (\n          console.error(\n            \"Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.\"\n          ),\n          (warnedProperties[name] = !0)\n        );\n      if (\"aria\" === lowerCasedName)\n        return (\n          console.error(\n            \"The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.\"\n          ),\n          (warnedProperties[name] = !0)\n        );\n      if (\n        \"is\" === lowerCasedName &&\n        null !== value &&\n        void 0 !== value &&\n        \"string\" !== typeof value\n      )\n        return (\n          console.error(\n            \"Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.\",\n            typeof value\n          ),\n          (warnedProperties[name] = !0)\n        );\n      if (\"number\" === typeof value && isNaN(value))\n        return (\n          console.error(\n            \"Received NaN for the `%s` attribute. If this is expected, cast the value to a string.\",\n            name\n          ),\n          (warnedProperties[name] = !0)\n        );\n      if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {\n        if (\n          ((lowerCasedName = possibleStandardNames[lowerCasedName]),\n          lowerCasedName !== name)\n        )\n          return (\n            console.error(\n              \"Invalid DOM property `%s`. Did you mean `%s`?\",\n              name,\n              lowerCasedName\n            ),\n            (warnedProperties[name] = !0)\n          );\n      } else if (name !== lowerCasedName)\n        return (\n          console.error(\n            \"React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.\",\n            name,\n            lowerCasedName\n          ),\n          (warnedProperties[name] = !0)\n        );\n      switch (name) {\n        case \"dangerouslySetInnerHTML\":\n        case \"children\":\n        case \"style\":\n        case \"suppressContentEditableWarning\":\n        case \"suppressHydrationWarning\":\n        case \"defaultValue\":\n        case \"defaultChecked\":\n        case \"innerHTML\":\n        case \"ref\":\n          return !0;\n        case \"innerText\":\n        case \"textContent\":\n          return !0;\n      }\n      switch (typeof value) {\n        case \"boolean\":\n          switch (name) {\n            case \"autoFocus\":\n            case \"checked\":\n            case \"multiple\":\n            case \"muted\":\n            case \"selected\":\n            case \"contentEditable\":\n            case \"spellCheck\":\n            case \"draggable\":\n            case \"value\":\n            case \"autoReverse\":\n            case \"externalResourcesRequired\":\n            case \"focusable\":\n            case \"preserveAlpha\":\n            case \"allowFullScreen\":\n            case \"async\":\n            case \"autoPlay\":\n            case \"controls\":\n            case \"default\":\n            case \"defer\":\n            case \"disabled\":\n            case \"disablePictureInPicture\":\n            case \"disableRemotePlayback\":\n            case \"formNoValidate\":\n            case \"hidden\":\n            case \"loop\":\n            case \"noModule\":\n            case \"noValidate\":\n            case \"open\":\n            case \"playsInline\":\n            case \"readOnly\":\n            case \"required\":\n            case \"reversed\":\n            case \"scoped\":\n            case \"seamless\":\n            case \"itemScope\":\n            case \"capture\":\n            case \"download\":\n            case \"inert\":\n              return !0;\n            default:\n              lowerCasedName = name.toLowerCase().slice(0, 5);\n              if (\"data-\" === lowerCasedName || \"aria-\" === lowerCasedName)\n                return !0;\n              value\n                ? console.error(\n                    'Received `%s` for a non-boolean attribute `%s`.\\n\\nIf you want to write it to the DOM, pass a string instead: %s=\"%s\" or %s={value.toString()}.',\n                    value,\n                    name,\n                    name,\n                    value,\n                    name\n                  )\n                : console.error(\n                    'Received `%s` for a non-boolean attribute `%s`.\\n\\nIf you want to write it to the DOM, pass a string instead: %s=\"%s\" or %s={value.toString()}.\\n\\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.',\n                    value,\n                    name,\n                    name,\n                    value,\n                    name,\n                    name,\n                    name\n                  );\n              return (warnedProperties[name] = !0);\n          }\n        case \"function\":\n        case \"symbol\":\n          return (warnedProperties[name] = !0), !1;\n        case \"string\":\n          if (\"false\" === value || \"true\" === value) {\n            switch (name) {\n              case \"checked\":\n              case \"selected\":\n              case \"multiple\":\n              case \"muted\":\n              case \"allowFullScreen\":\n              case \"async\":\n              case \"autoPlay\":\n              case \"controls\":\n              case \"default\":\n              case \"defer\":\n              case \"disabled\":\n              case \"disablePictureInPicture\":\n              case \"disableRemotePlayback\":\n              case \"formNoValidate\":\n              case \"hidden\":\n              case \"loop\":\n              case \"noModule\":\n              case \"noValidate\":\n              case \"open\":\n              case \"playsInline\":\n              case \"readOnly\":\n              case \"required\":\n              case \"reversed\":\n              case \"scoped\":\n              case \"seamless\":\n              case \"itemScope\":\n              case \"inert\":\n                break;\n              default:\n                return !0;\n            }\n            console.error(\n              \"Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?\",\n              value,\n              name,\n              \"false\" === value\n                ? \"The browser will interpret it as a truthy value.\"\n                : 'Although this works, it will not work as expected if you pass the string \"false\".',\n              name,\n              value\n            );\n            warnedProperties[name] = !0;\n          }\n      }\n      return !0;\n    }\n    function warnUnknownProperties(type, props, eventRegistry) {\n      var unknownProps = [],\n        key;\n      for (key in props)\n        validateProperty(type, key, props[key], eventRegistry) ||\n          unknownProps.push(key);\n      props = unknownProps\n        .map(function (prop) {\n          return \"`\" + prop + \"`\";\n        })\n        .join(\", \");\n      1 === unknownProps.length\n        ? console.error(\n            \"Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://react.dev/link/attribute-behavior \",\n            props,\n            type\n          )\n        : 1 < unknownProps.length &&\n          console.error(\n            \"Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://react.dev/link/attribute-behavior \",\n            props,\n            type\n          );\n    }\n    function camelize(string) {\n      return string.replace(hyphenPattern, function (_, character) {\n        return character.toUpperCase();\n      });\n    }\n    function escapeTextForBrowser(text) {\n      if (\n        \"boolean\" === typeof text ||\n        \"number\" === typeof text ||\n        \"bigint\" === typeof text\n      )\n        return \"\" + text;\n      checkHtmlStringCoercion(text);\n      text = \"\" + text;\n      var match = matchHtmlRegExp.exec(text);\n      if (match) {\n        var html = \"\",\n          index,\n          lastIndex = 0;\n        for (index = match.index; index < text.length; index++) {\n          switch (text.charCodeAt(index)) {\n            case 34:\n              match = \"&quot;\";\n              break;\n            case 38:\n              match = \"&amp;\";\n              break;\n            case 39:\n              match = \"&#x27;\";\n              break;\n            case 60:\n              match = \"&lt;\";\n              break;\n            case 62:\n              match = \"&gt;\";\n              break;\n            default:\n              continue;\n          }\n          lastIndex !== index && (html += text.slice(lastIndex, index));\n          lastIndex = index + 1;\n          html += match;\n        }\n        text = lastIndex !== index ? html + text.slice(lastIndex, index) : html;\n      }\n      return text;\n    }\n    function sanitizeURL(url) {\n      return isJavaScriptProtocol.test(\"\" + url)\n        ? \"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')\"\n        : url;\n    }\n    function escapeEntireInlineScriptContent(scriptText) {\n      checkHtmlStringCoercion(scriptText);\n      return (\"\" + scriptText).replace(scriptRegex, scriptReplacer);\n    }\n    function createResumableState(\n      identifierPrefix,\n      externalRuntimeConfig,\n      bootstrapScriptContent,\n      bootstrapScripts,\n      bootstrapModules\n    ) {\n      return {\n        idPrefix: void 0 === identifierPrefix ? \"\" : identifierPrefix,\n        nextFormID: 0,\n        streamingFormat: 0,\n        bootstrapScriptContent: bootstrapScriptContent,\n        bootstrapScripts: bootstrapScripts,\n        bootstrapModules: bootstrapModules,\n        instructions: NothingSent,\n        hasBody: !1,\n        hasHtml: !1,\n        unknownResources: {},\n        dnsResources: {},\n        connectResources: { default: {}, anonymous: {}, credentials: {} },\n        imageResources: {},\n        styleResources: {},\n        scriptResources: {},\n        moduleUnknownResources: {},\n        moduleScriptResources: {}\n      };\n    }\n    function createFormatContext(insertionMode, selectedValue, tagScope) {\n      return {\n        insertionMode: insertionMode,\n        selectedValue: selectedValue,\n        tagScope: tagScope\n      };\n    }\n    function getChildFormatContext(parentContext, type, props) {\n      switch (type) {\n        case \"noscript\":\n          return createFormatContext(\n            HTML_MODE,\n            null,\n            parentContext.tagScope | 1\n          );\n        case \"select\":\n          return createFormatContext(\n            HTML_MODE,\n            null != props.value ? props.value : props.defaultValue,\n            parentContext.tagScope\n          );\n        case \"svg\":\n          return createFormatContext(SVG_MODE, null, parentContext.tagScope);\n        case \"picture\":\n          return createFormatContext(\n            HTML_MODE,\n            null,\n            parentContext.tagScope | 2\n          );\n        case \"math\":\n          return createFormatContext(MATHML_MODE, null, parentContext.tagScope);\n        case \"foreignObject\":\n          return createFormatContext(HTML_MODE, null, parentContext.tagScope);\n        case \"table\":\n          return createFormatContext(\n            HTML_TABLE_MODE,\n            null,\n            parentContext.tagScope\n          );\n        case \"thead\":\n        case \"tbody\":\n        case \"tfoot\":\n          return createFormatContext(\n            HTML_TABLE_BODY_MODE,\n            null,\n            parentContext.tagScope\n          );\n        case \"colgroup\":\n          return createFormatContext(\n            HTML_COLGROUP_MODE,\n            null,\n            parentContext.tagScope\n          );\n        case \"tr\":\n          return createFormatContext(\n            HTML_TABLE_ROW_MODE,\n            null,\n            parentContext.tagScope\n          );\n      }\n      return parentContext.insertionMode >= HTML_TABLE_MODE\n        ? createFormatContext(HTML_MODE, null, parentContext.tagScope)\n        : parentContext.insertionMode === ROOT_HTML_MODE\n          ? \"html\" === type\n            ? createFormatContext(HTML_HTML_MODE, null, parentContext.tagScope)\n            : createFormatContext(HTML_MODE, null, parentContext.tagScope)\n          : parentContext.insertionMode === HTML_HTML_MODE\n            ? createFormatContext(HTML_MODE, null, parentContext.tagScope)\n            : parentContext;\n    }\n    function pushStyleAttribute(target, style) {\n      if (\"object\" !== typeof style)\n        throw Error(\n          \"The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.\"\n        );\n      var isFirst = !0,\n        styleName;\n      for (styleName in style)\n        if (hasOwnProperty.call(style, styleName)) {\n          var styleValue = style[styleName];\n          if (\n            null != styleValue &&\n            \"boolean\" !== typeof styleValue &&\n            \"\" !== styleValue\n          ) {\n            if (0 === styleName.indexOf(\"--\")) {\n              var nameChunk = escapeTextForBrowser(styleName);\n              checkCSSPropertyStringCoercion(styleValue, styleName);\n              styleValue = escapeTextForBrowser((\"\" + styleValue).trim());\n            } else {\n              nameChunk = styleName;\n              var value = styleValue;\n              if (-1 < nameChunk.indexOf(\"-\")) {\n                var name = nameChunk;\n                (warnedStyleNames.hasOwnProperty(name) &&\n                  warnedStyleNames[name]) ||\n                  ((warnedStyleNames[name] = !0),\n                  console.error(\n                    \"Unsupported style property %s. Did you mean %s?\",\n                    name,\n                    camelize(name.replace(msPattern$1, \"ms-\"))\n                  ));\n              } else if (badVendoredStyleNamePattern.test(nameChunk))\n                (name = nameChunk),\n                  (warnedStyleNames.hasOwnProperty(name) &&\n                    warnedStyleNames[name]) ||\n                    ((warnedStyleNames[name] = !0),\n                    console.error(\n                      \"Unsupported vendor-prefixed style property %s. Did you mean %s?\",\n                      name,\n                      name.charAt(0).toUpperCase() + name.slice(1)\n                    ));\n              else if (badStyleValueWithSemicolonPattern.test(value)) {\n                name = nameChunk;\n                var value$jscomp$0 = value;\n                (warnedStyleValues.hasOwnProperty(value$jscomp$0) &&\n                  warnedStyleValues[value$jscomp$0]) ||\n                  ((warnedStyleValues[value$jscomp$0] = !0),\n                  console.error(\n                    'Style property values shouldn\\'t contain a semicolon. Try \"%s: %s\" instead.',\n                    name,\n                    value$jscomp$0.replace(\n                      badStyleValueWithSemicolonPattern,\n                      \"\"\n                    )\n                  ));\n              }\n              \"number\" === typeof value &&\n                (isNaN(value)\n                  ? warnedForNaNValue ||\n                    ((warnedForNaNValue = !0),\n                    console.error(\n                      \"`NaN` is an invalid value for the `%s` css style property.\",\n                      nameChunk\n                    ))\n                  : isFinite(value) ||\n                    warnedForInfinityValue ||\n                    ((warnedForInfinityValue = !0),\n                    console.error(\n                      \"`Infinity` is an invalid value for the `%s` css style property.\",\n                      nameChunk\n                    )));\n              nameChunk = styleName;\n              value = styleNameCache.get(nameChunk);\n              void 0 !== value\n                ? (nameChunk = value)\n                : ((value = escapeTextForBrowser(\n                    nameChunk\n                      .replace(uppercasePattern, \"-$1\")\n                      .toLowerCase()\n                      .replace(msPattern, \"-ms-\")\n                  )),\n                  styleNameCache.set(nameChunk, value),\n                  (nameChunk = value));\n              \"number\" === typeof styleValue\n                ? (styleValue =\n                    0 === styleValue || unitlessNumbers.has(styleName)\n                      ? \"\" + styleValue\n                      : styleValue + \"px\")\n                : (checkCSSPropertyStringCoercion(styleValue, styleName),\n                  (styleValue = escapeTextForBrowser(\n                    (\"\" + styleValue).trim()\n                  )));\n            }\n            isFirst\n              ? ((isFirst = !1),\n                target.push(\n                  styleAttributeStart,\n                  nameChunk,\n                  styleAssign,\n                  styleValue\n                ))\n              : target.push(styleSeparator, nameChunk, styleAssign, styleValue);\n          }\n        }\n      isFirst || target.push(attributeEnd);\n    }\n    function pushBooleanAttribute(target, name, value) {\n      value &&\n        \"function\" !== typeof value &&\n        \"symbol\" !== typeof value &&\n        target.push(attributeSeparator, name, attributeEmptyString);\n    }\n    function pushStringAttribute(target, name, value) {\n      \"function\" !== typeof value &&\n        \"symbol\" !== typeof value &&\n        \"boolean\" !== typeof value &&\n        target.push(\n          attributeSeparator,\n          name,\n          attributeAssign,\n          escapeTextForBrowser(value),\n          attributeEnd\n        );\n    }\n    function pushAdditionalFormField(value, key) {\n      this.push('<input type=\"hidden\"');\n      validateAdditionalFormField(value);\n      pushStringAttribute(this, \"name\", key);\n      pushStringAttribute(this, \"value\", value);\n      this.push(endOfStartTagSelfClosing);\n    }\n    function validateAdditionalFormField(value) {\n      if (\"string\" !== typeof value)\n        throw Error(\n          \"File/Blob fields are not yet supported in progressive forms. Will fallback to client hydration.\"\n        );\n    }\n    function getCustomFormFields(resumableState, formAction) {\n      if (\"function\" === typeof formAction.$$FORM_ACTION) {\n        var id = resumableState.nextFormID++;\n        resumableState = resumableState.idPrefix + id;\n        try {\n          var customFields = formAction.$$FORM_ACTION(resumableState);\n          if (customFields) {\n            var formData = customFields.data;\n            null != formData && formData.forEach(validateAdditionalFormField);\n          }\n          return customFields;\n        } catch (x) {\n          if (\n            \"object\" === typeof x &&\n            null !== x &&\n            \"function\" === typeof x.then\n          )\n            throw x;\n          console.error(\n            \"Failed to serialize an action for progressive enhancement:\\n%s\",\n            x\n          );\n        }\n      }\n      return null;\n    }\n    function pushFormActionAttribute(\n      target,\n      resumableState,\n      renderState,\n      formAction,\n      formEncType,\n      formMethod,\n      formTarget,\n      name\n    ) {\n      var formData = null;\n      if (\"function\" === typeof formAction) {\n        null === name ||\n          didWarnFormActionName ||\n          ((didWarnFormActionName = !0),\n          console.error(\n            'Cannot specify a \"name\" prop for a button that specifies a function as a formAction. React needs it to encode which action should be invoked. It will get overridden.'\n          ));\n        (null === formEncType && null === formMethod) ||\n          didWarnFormActionMethod ||\n          ((didWarnFormActionMethod = !0),\n          console.error(\n            \"Cannot specify a formEncType or formMethod for a button that specifies a function as a formAction. React provides those automatically. They will get overridden.\"\n          ));\n        null === formTarget ||\n          didWarnFormActionTarget ||\n          ((didWarnFormActionTarget = !0),\n          console.error(\n            \"Cannot specify a formTarget for a button that specifies a function as a formAction. The function will always be executed in the same window.\"\n          ));\n        var customFields = getCustomFormFields(resumableState, formAction);\n        null !== customFields\n          ? ((name = customFields.name),\n            (formAction = customFields.action || \"\"),\n            (formEncType = customFields.encType),\n            (formMethod = customFields.method),\n            (formTarget = customFields.target),\n            (formData = customFields.data))\n          : (target.push(\n              attributeSeparator,\n              \"formAction\",\n              attributeAssign,\n              actionJavaScriptURL,\n              attributeEnd\n            ),\n            (formTarget = formMethod = formEncType = formAction = name = null),\n            injectFormReplayingRuntime(resumableState, renderState));\n      }\n      null != name && pushAttribute(target, \"name\", name);\n      null != formAction && pushAttribute(target, \"formAction\", formAction);\n      null != formEncType && pushAttribute(target, \"formEncType\", formEncType);\n      null != formMethod && pushAttribute(target, \"formMethod\", formMethod);\n      null != formTarget && pushAttribute(target, \"formTarget\", formTarget);\n      return formData;\n    }\n    function pushAttribute(target, name, value) {\n      switch (name) {\n        case \"className\":\n          pushStringAttribute(target, \"class\", value);\n          break;\n        case \"tabIndex\":\n          pushStringAttribute(target, \"tabindex\", value);\n          break;\n        case \"dir\":\n        case \"role\":\n        case \"viewBox\":\n        case \"width\":\n        case \"height\":\n          pushStringAttribute(target, name, value);\n          break;\n        case \"style\":\n          pushStyleAttribute(target, value);\n          break;\n        case \"src\":\n        case \"href\":\n          if (\"\" === value) {\n            \"src\" === name\n              ? console.error(\n                  'An empty string (\"\") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',\n                  name,\n                  name\n                )\n              : console.error(\n                  'An empty string (\"\") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',\n                  name,\n                  name\n                );\n            break;\n          }\n        case \"action\":\n        case \"formAction\":\n          if (\n            null == value ||\n            \"function\" === typeof value ||\n            \"symbol\" === typeof value ||\n            \"boolean\" === typeof value\n          )\n            break;\n          checkAttributeStringCoercion(value, name);\n          value = sanitizeURL(\"\" + value);\n          target.push(\n            attributeSeparator,\n            name,\n            attributeAssign,\n            escapeTextForBrowser(value),\n            attributeEnd\n          );\n          break;\n        case \"defaultValue\":\n        case \"defaultChecked\":\n        case \"innerHTML\":\n        case \"suppressContentEditableWarning\":\n        case \"suppressHydrationWarning\":\n        case \"ref\":\n          break;\n        case \"autoFocus\":\n        case \"multiple\":\n        case \"muted\":\n          pushBooleanAttribute(target, name.toLowerCase(), value);\n          break;\n        case \"xlinkHref\":\n          if (\n            \"function\" === typeof value ||\n            \"symbol\" === typeof value ||\n            \"boolean\" === typeof value\n          )\n            break;\n          checkAttributeStringCoercion(value, name);\n          value = sanitizeURL(\"\" + value);\n          target.push(\n            attributeSeparator,\n            \"xlink:href\",\n            attributeAssign,\n            escapeTextForBrowser(value),\n            attributeEnd\n          );\n          break;\n        case \"contentEditable\":\n        case \"spellCheck\":\n        case \"draggable\":\n        case \"value\":\n        case \"autoReverse\":\n        case \"externalResourcesRequired\":\n        case \"focusable\":\n        case \"preserveAlpha\":\n          \"function\" !== typeof value &&\n            \"symbol\" !== typeof value &&\n            target.push(\n              attributeSeparator,\n              name,\n              attributeAssign,\n              escapeTextForBrowser(value),\n              attributeEnd\n            );\n          break;\n        case \"inert\":\n          \"\" !== value ||\n            didWarnForNewBooleanPropsWithEmptyValue[name] ||\n            ((didWarnForNewBooleanPropsWithEmptyValue[name] = !0),\n            console.error(\n              \"Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.\",\n              name\n            ));\n        case \"allowFullScreen\":\n        case \"async\":\n        case \"autoPlay\":\n        case \"controls\":\n        case \"default\":\n        case \"defer\":\n        case \"disabled\":\n        case \"disablePictureInPicture\":\n        case \"disableRemotePlayback\":\n        case \"formNoValidate\":\n        case \"hidden\":\n        case \"loop\":\n        case \"noModule\":\n        case \"noValidate\":\n        case \"open\":\n        case \"playsInline\":\n        case \"readOnly\":\n        case \"required\":\n        case \"reversed\":\n        case \"scoped\":\n        case \"seamless\":\n        case \"itemScope\":\n          value &&\n            \"function\" !== typeof value &&\n            \"symbol\" !== typeof value &&\n            target.push(attributeSeparator, name, attributeEmptyString);\n          break;\n        case \"capture\":\n        case \"download\":\n          !0 === value\n            ? target.push(attributeSeparator, name, attributeEmptyString)\n            : !1 !== value &&\n              \"function\" !== typeof value &&\n              \"symbol\" !== typeof value &&\n              target.push(\n                attributeSeparator,\n                name,\n                attributeAssign,\n                escapeTextForBrowser(value),\n                attributeEnd\n              );\n          break;\n        case \"cols\":\n        case \"rows\":\n        case \"size\":\n        case \"span\":\n          \"function\" !== typeof value &&\n            \"symbol\" !== typeof value &&\n            !isNaN(value) &&\n            1 <= value &&\n            target.push(\n              attributeSeparator,\n              name,\n              attributeAssign,\n              escapeTextForBrowser(value),\n              attributeEnd\n            );\n          break;\n        case \"rowSpan\":\n        case \"start\":\n          \"function\" === typeof value ||\n            \"symbol\" === typeof value ||\n            isNaN(value) ||\n            target.push(\n              attributeSeparator,\n              name,\n              attributeAssign,\n              escapeTextForBrowser(value),\n              attributeEnd\n            );\n          break;\n        case \"xlinkActuate\":\n          pushStringAttribute(target, \"xlink:actuate\", value);\n          break;\n        case \"xlinkArcrole\":\n          pushStringAttribute(target, \"xlink:arcrole\", value);\n          break;\n        case \"xlinkRole\":\n          pushStringAttribute(target, \"xlink:role\", value);\n          break;\n        case \"xlinkShow\":\n          pushStringAttribute(target, \"xlink:show\", value);\n          break;\n        case \"xlinkTitle\":\n          pushStringAttribute(target, \"xlink:title\", value);\n          break;\n        case \"xlinkType\":\n          pushStringAttribute(target, \"xlink:type\", value);\n          break;\n        case \"xmlBase\":\n          pushStringAttribute(target, \"xml:base\", value);\n          break;\n        case \"xmlLang\":\n          pushStringAttribute(target, \"xml:lang\", value);\n          break;\n        case \"xmlSpace\":\n          pushStringAttribute(target, \"xml:space\", value);\n          break;\n        default:\n          if (\n            !(2 < name.length) ||\n            (\"o\" !== name[0] && \"O\" !== name[0]) ||\n            (\"n\" !== name[1] && \"N\" !== name[1])\n          )\n            if (\n              ((name = aliases.get(name) || name), isAttributeNameSafe(name))\n            ) {\n              switch (typeof value) {\n                case \"function\":\n                case \"symbol\":\n                  return;\n                case \"boolean\":\n                  var prefix = name.toLowerCase().slice(0, 5);\n                  if (\"data-\" !== prefix && \"aria-\" !== prefix) return;\n              }\n              target.push(\n                attributeSeparator,\n                name,\n                attributeAssign,\n                escapeTextForBrowser(value),\n                attributeEnd\n              );\n            }\n      }\n    }\n    function pushInnerHTML(target, innerHTML, children) {\n      if (null != innerHTML) {\n        if (null != children)\n          throw Error(\n            \"Can only set one of `children` or `props.dangerouslySetInnerHTML`.\"\n          );\n        if (\"object\" !== typeof innerHTML || !(\"__html\" in innerHTML))\n          throw Error(\n            \"`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information.\"\n          );\n        innerHTML = innerHTML.__html;\n        null !== innerHTML &&\n          void 0 !== innerHTML &&\n          (checkHtmlStringCoercion(innerHTML), target.push(\"\" + innerHTML));\n      }\n    }\n    function checkSelectProp(props, propName) {\n      var value = props[propName];\n      null != value &&\n        ((value = isArrayImpl(value)),\n        props.multiple && !value\n          ? console.error(\n              \"The `%s` prop supplied to <select> must be an array if `multiple` is true.\",\n              propName\n            )\n          : !props.multiple &&\n            value &&\n            console.error(\n              \"The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.\",\n              propName\n            ));\n    }\n    function flattenOptionChildren(children) {\n      var content = \"\";\n      React.Children.forEach(children, function (child) {\n        null != child &&\n          ((content += child),\n          didWarnInvalidOptionChildren ||\n            \"string\" === typeof child ||\n            \"number\" === typeof child ||\n            \"bigint\" === typeof child ||\n            ((didWarnInvalidOptionChildren = !0),\n            console.error(\n              \"Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.\"\n            )));\n      });\n      return content;\n    }\n    function injectFormReplayingRuntime(resumableState, renderState) {\n      (resumableState.instructions & 16) === NothingSent &&\n        ((resumableState.instructions |= 16),\n        renderState.bootstrapChunks.unshift(\n          renderState.startInlineScript,\n          formReplayingRuntimeScript,\n          \"\\x3c/script>\"\n        ));\n    }\n    function pushLinkImpl(target, props) {\n      target.push(startChunkForTag(\"link\"));\n      for (var propKey in props)\n        if (hasOwnProperty.call(props, propKey)) {\n          var propValue = props[propKey];\n          if (null != propValue)\n            switch (propKey) {\n              case \"children\":\n              case \"dangerouslySetInnerHTML\":\n                throw Error(\n                  \"link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.\"\n                );\n              default:\n                pushAttribute(target, propKey, propValue);\n            }\n        }\n      target.push(endOfStartTagSelfClosing);\n      return null;\n    }\n    function escapeStyleTextContent(styleText) {\n      checkHtmlStringCoercion(styleText);\n      return (\"\" + styleText).replace(styleRegex, styleReplacer);\n    }\n    function pushSelfClosing(target, props, tag) {\n      target.push(startChunkForTag(tag));\n      for (var propKey in props)\n        if (hasOwnProperty.call(props, propKey)) {\n          var propValue = props[propKey];\n          if (null != propValue)\n            switch (propKey) {\n              case \"children\":\n              case \"dangerouslySetInnerHTML\":\n                throw Error(\n                  tag +\n                    \" is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.\"\n                );\n              default:\n                pushAttribute(target, propKey, propValue);\n            }\n        }\n      target.push(endOfStartTagSelfClosing);\n      return null;\n    }\n    function pushTitleImpl(target, props) {\n      target.push(startChunkForTag(\"title\"));\n      var children = null,\n        innerHTML = null,\n        propKey;\n      for (propKey in props)\n        if (hasOwnProperty.call(props, propKey)) {\n          var propValue = props[propKey];\n          if (null != propValue)\n            switch (propKey) {\n              case \"children\":\n                children = propValue;\n                break;\n              case \"dangerouslySetInnerHTML\":\n                innerHTML = propValue;\n                break;\n              default:\n                pushAttribute(target, propKey, propValue);\n            }\n        }\n      target.push(endOfStartTag);\n      props = Array.isArray(children)\n        ? 2 > children.length\n          ? children[0]\n          : null\n        : children;\n      \"function\" !== typeof props &&\n        \"symbol\" !== typeof props &&\n        null !== props &&\n        void 0 !== props &&\n        target.push(escapeTextForBrowser(\"\" + props));\n      pushInnerHTML(target, innerHTML, children);\n      target.push(endChunkForTag(\"title\"));\n      return null;\n    }\n    function pushScriptImpl(target, props) {\n      target.push(startChunkForTag(\"script\"));\n      var children = null,\n        innerHTML = null,\n        propKey;\n      for (propKey in props)\n        if (hasOwnProperty.call(props, propKey)) {\n          var propValue = props[propKey];\n          if (null != propValue)\n            switch (propKey) {\n              case \"children\":\n                children = propValue;\n                break;\n              case \"dangerouslySetInnerHTML\":\n                innerHTML = propValue;\n                break;\n              default:\n                pushAttribute(target, propKey, propValue);\n            }\n        }\n      target.push(endOfStartTag);\n      null != children &&\n        \"string\" !== typeof children &&\n        ((props =\n          \"number\" === typeof children\n            ? \"a number for children\"\n            : Array.isArray(children)\n              ? \"an array for children\"\n              : \"something unexpected for children\"),\n        console.error(\n          \"A script element was rendered with %s. If script element has children it must be a single string. Consider using dangerouslySetInnerHTML or passing a plain string as children.\",\n          props\n        ));\n      pushInnerHTML(target, innerHTML, children);\n      \"string\" === typeof children &&\n        target.push(escapeEntireInlineScriptContent(children));\n      target.push(endChunkForTag(\"script\"));\n      return null;\n    }\n    function pushStartGenericElement(target, props, tag) {\n      target.push(startChunkForTag(tag));\n      var innerHTML = (tag = null),\n        propKey;\n      for (propKey in props)\n        if (hasOwnProperty.call(props, propKey)) {\n          var propValue = props[propKey];\n          if (null != propValue)\n            switch (propKey) {\n              case \"children\":\n                tag = propValue;\n                break;\n              case \"dangerouslySetInnerHTML\":\n                innerHTML = propValue;\n                break;\n              default:\n                pushAttribute(target, propKey, propValue);\n            }\n        }\n      target.push(endOfStartTag);\n      pushInnerHTML(target, innerHTML, tag);\n      return \"string\" === typeof tag\n        ? (target.push(escapeTextForBrowser(tag)), null)\n        : tag;\n    }\n    function startChunkForTag(tag) {\n      var tagStartChunk = validatedTagCache.get(tag);\n      if (void 0 === tagStartChunk) {\n        if (!VALID_TAG_REGEX.test(tag)) throw Error(\"Invalid tag: \" + tag);\n        tagStartChunk = \"<\" + tag;\n        validatedTagCache.set(tag, tagStartChunk);\n      }\n      return tagStartChunk;\n    }\n    function pushStartInstance(\n      target$jscomp$0,\n      type,\n      props,\n      resumableState,\n      renderState,\n      hoistableState,\n      formatContext,\n      textEmbedded,\n      isFallback\n    ) {\n      validateProperties$2(type, props);\n      (\"input\" !== type && \"textarea\" !== type && \"select\" !== type) ||\n        null == props ||\n        null !== props.value ||\n        didWarnValueNull ||\n        ((didWarnValueNull = !0),\n        \"select\" === type && props.multiple\n          ? console.error(\n              \"`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.\",\n              type\n            )\n          : console.error(\n              \"`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.\",\n              type\n            ));\n      b: if (-1 === type.indexOf(\"-\")) var JSCompiler_inline_result = !1;\n      else\n        switch (type) {\n          case \"annotation-xml\":\n          case \"color-profile\":\n          case \"font-face\":\n          case \"font-face-src\":\n          case \"font-face-uri\":\n          case \"font-face-format\":\n          case \"font-face-name\":\n          case \"missing-glyph\":\n            JSCompiler_inline_result = !1;\n            break b;\n          default:\n            JSCompiler_inline_result = !0;\n        }\n      JSCompiler_inline_result ||\n        \"string\" === typeof props.is ||\n        warnUnknownProperties(type, props, null);\n      !props.suppressContentEditableWarning &&\n        props.contentEditable &&\n        null != props.children &&\n        console.error(\n          \"A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.\"\n        );\n      formatContext.insertionMode !== SVG_MODE &&\n        formatContext.insertionMode !== MATHML_MODE &&\n        -1 === type.indexOf(\"-\") &&\n        type.toLowerCase() !== type &&\n        console.error(\n          \"<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.\",\n          type\n        );\n      switch (type) {\n        case \"div\":\n        case \"span\":\n        case \"svg\":\n        case \"path\":\n          break;\n        case \"a\":\n          target$jscomp$0.push(startChunkForTag(\"a\"));\n          var children = null,\n            innerHTML = null,\n            propKey;\n          for (propKey in props)\n            if (hasOwnProperty.call(props, propKey)) {\n              var propValue = props[propKey];\n              if (null != propValue)\n                switch (propKey) {\n                  case \"children\":\n                    children = propValue;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML = propValue;\n                    break;\n                  case \"href\":\n                    \"\" === propValue\n                      ? pushStringAttribute(target$jscomp$0, \"href\", \"\")\n                      : pushAttribute(target$jscomp$0, propKey, propValue);\n                    break;\n                  default:\n                    pushAttribute(target$jscomp$0, propKey, propValue);\n                }\n            }\n          target$jscomp$0.push(endOfStartTag);\n          pushInnerHTML(target$jscomp$0, innerHTML, children);\n          if (\"string\" === typeof children) {\n            target$jscomp$0.push(escapeTextForBrowser(children));\n            var JSCompiler_inline_result$jscomp$0 = null;\n          } else JSCompiler_inline_result$jscomp$0 = children;\n          return JSCompiler_inline_result$jscomp$0;\n        case \"g\":\n        case \"p\":\n        case \"li\":\n          break;\n        case \"select\":\n          checkControlledValueProps(\"select\", props);\n          checkSelectProp(props, \"value\");\n          checkSelectProp(props, \"defaultValue\");\n          void 0 === props.value ||\n            void 0 === props.defaultValue ||\n            didWarnDefaultSelectValue ||\n            (console.error(\n              \"Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://react.dev/link/controlled-components\"\n            ),\n            (didWarnDefaultSelectValue = !0));\n          target$jscomp$0.push(startChunkForTag(\"select\"));\n          var children$jscomp$0 = null,\n            innerHTML$jscomp$0 = null,\n            propKey$jscomp$0;\n          for (propKey$jscomp$0 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$0)) {\n              var propValue$jscomp$0 = props[propKey$jscomp$0];\n              if (null != propValue$jscomp$0)\n                switch (propKey$jscomp$0) {\n                  case \"children\":\n                    children$jscomp$0 = propValue$jscomp$0;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML$jscomp$0 = propValue$jscomp$0;\n                    break;\n                  case \"defaultValue\":\n                  case \"value\":\n                    break;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$0,\n                      propValue$jscomp$0\n                    );\n                }\n            }\n          target$jscomp$0.push(endOfStartTag);\n          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$0, children$jscomp$0);\n          return children$jscomp$0;\n        case \"option\":\n          var selectedValue = formatContext.selectedValue;\n          target$jscomp$0.push(startChunkForTag(\"option\"));\n          var children$jscomp$1 = null,\n            value = null,\n            selected = null,\n            innerHTML$jscomp$1 = null,\n            propKey$jscomp$1;\n          for (propKey$jscomp$1 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$1)) {\n              var propValue$jscomp$1 = props[propKey$jscomp$1];\n              if (null != propValue$jscomp$1)\n                switch (propKey$jscomp$1) {\n                  case \"children\":\n                    children$jscomp$1 = propValue$jscomp$1;\n                    break;\n                  case \"selected\":\n                    selected = propValue$jscomp$1;\n                    didWarnSelectedSetOnOption ||\n                      (console.error(\n                        \"Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.\"\n                      ),\n                      (didWarnSelectedSetOnOption = !0));\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML$jscomp$1 = propValue$jscomp$1;\n                    break;\n                  case \"value\":\n                    value = propValue$jscomp$1;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$1,\n                      propValue$jscomp$1\n                    );\n                }\n            }\n          if (null != selectedValue) {\n            if (null !== value) {\n              checkAttributeStringCoercion(value, \"value\");\n              var stringValue = \"\" + value;\n            } else\n              null === innerHTML$jscomp$1 ||\n                didWarnInvalidOptionInnerHTML ||\n                ((didWarnInvalidOptionInnerHTML = !0),\n                console.error(\n                  \"Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.\"\n                )),\n                (stringValue = flattenOptionChildren(children$jscomp$1));\n            if (isArrayImpl(selectedValue))\n              for (var i = 0; i < selectedValue.length; i++) {\n                if (\n                  (checkAttributeStringCoercion(selectedValue[i], \"value\"),\n                  \"\" + selectedValue[i] === stringValue)\n                ) {\n                  target$jscomp$0.push(' selected=\"\"');\n                  break;\n                }\n              }\n            else\n              checkAttributeStringCoercion(selectedValue, \"select.value\"),\n                \"\" + selectedValue === stringValue &&\n                  target$jscomp$0.push(' selected=\"\"');\n          } else selected && target$jscomp$0.push(' selected=\"\"');\n          target$jscomp$0.push(endOfStartTag);\n          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$1, children$jscomp$1);\n          return children$jscomp$1;\n        case \"textarea\":\n          checkControlledValueProps(\"textarea\", props);\n          void 0 === props.value ||\n            void 0 === props.defaultValue ||\n            didWarnDefaultTextareaValue ||\n            (console.error(\n              \"Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://react.dev/link/controlled-components\"\n            ),\n            (didWarnDefaultTextareaValue = !0));\n          target$jscomp$0.push(startChunkForTag(\"textarea\"));\n          var value$jscomp$0 = null,\n            defaultValue = null,\n            children$jscomp$2 = null,\n            propKey$jscomp$2;\n          for (propKey$jscomp$2 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$2)) {\n              var propValue$jscomp$2 = props[propKey$jscomp$2];\n              if (null != propValue$jscomp$2)\n                switch (propKey$jscomp$2) {\n                  case \"children\":\n                    children$jscomp$2 = propValue$jscomp$2;\n                    break;\n                  case \"value\":\n                    value$jscomp$0 = propValue$jscomp$2;\n                    break;\n                  case \"defaultValue\":\n                    defaultValue = propValue$jscomp$2;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    throw Error(\n                      \"`dangerouslySetInnerHTML` does not make sense on <textarea>.\"\n                    );\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$2,\n                      propValue$jscomp$2\n                    );\n                }\n            }\n          null === value$jscomp$0 &&\n            null !== defaultValue &&\n            (value$jscomp$0 = defaultValue);\n          target$jscomp$0.push(endOfStartTag);\n          if (null != children$jscomp$2) {\n            console.error(\n              \"Use the `defaultValue` or `value` props instead of setting children on <textarea>.\"\n            );\n            if (null != value$jscomp$0)\n              throw Error(\n                \"If you supply `defaultValue` on a <textarea>, do not pass children.\"\n              );\n            if (isArrayImpl(children$jscomp$2)) {\n              if (1 < children$jscomp$2.length)\n                throw Error(\"<textarea> can only have at most one child.\");\n              checkHtmlStringCoercion(children$jscomp$2[0]);\n              value$jscomp$0 = \"\" + children$jscomp$2[0];\n            }\n            checkHtmlStringCoercion(children$jscomp$2);\n            value$jscomp$0 = \"\" + children$jscomp$2;\n          }\n          \"string\" === typeof value$jscomp$0 &&\n            \"\\n\" === value$jscomp$0[0] &&\n            target$jscomp$0.push(leadingNewline);\n          null !== value$jscomp$0 &&\n            (checkAttributeStringCoercion(value$jscomp$0, \"value\"),\n            target$jscomp$0.push(escapeTextForBrowser(\"\" + value$jscomp$0)));\n          return null;\n        case \"input\":\n          checkControlledValueProps(\"input\", props);\n          target$jscomp$0.push(startChunkForTag(\"input\"));\n          var name = null,\n            formAction = null,\n            formEncType = null,\n            formMethod = null,\n            formTarget = null,\n            value$jscomp$1 = null,\n            defaultValue$jscomp$0 = null,\n            checked = null,\n            defaultChecked = null,\n            propKey$jscomp$3;\n          for (propKey$jscomp$3 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$3)) {\n              var propValue$jscomp$3 = props[propKey$jscomp$3];\n              if (null != propValue$jscomp$3)\n                switch (propKey$jscomp$3) {\n                  case \"children\":\n                  case \"dangerouslySetInnerHTML\":\n                    throw Error(\n                      \"input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.\"\n                    );\n                  case \"name\":\n                    name = propValue$jscomp$3;\n                    break;\n                  case \"formAction\":\n                    formAction = propValue$jscomp$3;\n                    break;\n                  case \"formEncType\":\n                    formEncType = propValue$jscomp$3;\n                    break;\n                  case \"formMethod\":\n                    formMethod = propValue$jscomp$3;\n                    break;\n                  case \"formTarget\":\n                    formTarget = propValue$jscomp$3;\n                    break;\n                  case \"defaultChecked\":\n                    defaultChecked = propValue$jscomp$3;\n                    break;\n                  case \"defaultValue\":\n                    defaultValue$jscomp$0 = propValue$jscomp$3;\n                    break;\n                  case \"checked\":\n                    checked = propValue$jscomp$3;\n                    break;\n                  case \"value\":\n                    value$jscomp$1 = propValue$jscomp$3;\n                    break;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$3,\n                      propValue$jscomp$3\n                    );\n                }\n            }\n          null === formAction ||\n            \"image\" === props.type ||\n            \"submit\" === props.type ||\n            didWarnFormActionType ||\n            ((didWarnFormActionType = !0),\n            console.error(\n              'An input can only specify a formAction along with type=\"submit\" or type=\"image\".'\n            ));\n          var formData = pushFormActionAttribute(\n            target$jscomp$0,\n            resumableState,\n            renderState,\n            formAction,\n            formEncType,\n            formMethod,\n            formTarget,\n            name\n          );\n          null === checked ||\n            null === defaultChecked ||\n            didWarnDefaultChecked ||\n            (console.error(\n              \"%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components\",\n              \"A component\",\n              props.type\n            ),\n            (didWarnDefaultChecked = !0));\n          null === value$jscomp$1 ||\n            null === defaultValue$jscomp$0 ||\n            didWarnDefaultInputValue ||\n            (console.error(\n              \"%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components\",\n              \"A component\",\n              props.type\n            ),\n            (didWarnDefaultInputValue = !0));\n          null !== checked\n            ? pushBooleanAttribute(target$jscomp$0, \"checked\", checked)\n            : null !== defaultChecked &&\n              pushBooleanAttribute(target$jscomp$0, \"checked\", defaultChecked);\n          null !== value$jscomp$1\n            ? pushAttribute(target$jscomp$0, \"value\", value$jscomp$1)\n            : null !== defaultValue$jscomp$0 &&\n              pushAttribute(target$jscomp$0, \"value\", defaultValue$jscomp$0);\n          target$jscomp$0.push(endOfStartTagSelfClosing);\n          null != formData &&\n            formData.forEach(pushAdditionalFormField, target$jscomp$0);\n          return null;\n        case \"button\":\n          target$jscomp$0.push(startChunkForTag(\"button\"));\n          var children$jscomp$3 = null,\n            innerHTML$jscomp$2 = null,\n            name$jscomp$0 = null,\n            formAction$jscomp$0 = null,\n            formEncType$jscomp$0 = null,\n            formMethod$jscomp$0 = null,\n            formTarget$jscomp$0 = null,\n            propKey$jscomp$4;\n          for (propKey$jscomp$4 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$4)) {\n              var propValue$jscomp$4 = props[propKey$jscomp$4];\n              if (null != propValue$jscomp$4)\n                switch (propKey$jscomp$4) {\n                  case \"children\":\n                    children$jscomp$3 = propValue$jscomp$4;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML$jscomp$2 = propValue$jscomp$4;\n                    break;\n                  case \"name\":\n                    name$jscomp$0 = propValue$jscomp$4;\n                    break;\n                  case \"formAction\":\n                    formAction$jscomp$0 = propValue$jscomp$4;\n                    break;\n                  case \"formEncType\":\n                    formEncType$jscomp$0 = propValue$jscomp$4;\n                    break;\n                  case \"formMethod\":\n                    formMethod$jscomp$0 = propValue$jscomp$4;\n                    break;\n                  case \"formTarget\":\n                    formTarget$jscomp$0 = propValue$jscomp$4;\n                    break;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$4,\n                      propValue$jscomp$4\n                    );\n                }\n            }\n          null === formAction$jscomp$0 ||\n            null == props.type ||\n            \"submit\" === props.type ||\n            didWarnFormActionType ||\n            ((didWarnFormActionType = !0),\n            console.error(\n              'A button can only specify a formAction along with type=\"submit\" or no type.'\n            ));\n          var formData$jscomp$0 = pushFormActionAttribute(\n            target$jscomp$0,\n            resumableState,\n            renderState,\n            formAction$jscomp$0,\n            formEncType$jscomp$0,\n            formMethod$jscomp$0,\n            formTarget$jscomp$0,\n            name$jscomp$0\n          );\n          target$jscomp$0.push(endOfStartTag);\n          null != formData$jscomp$0 &&\n            formData$jscomp$0.forEach(pushAdditionalFormField, target$jscomp$0);\n          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$2, children$jscomp$3);\n          if (\"string\" === typeof children$jscomp$3) {\n            target$jscomp$0.push(escapeTextForBrowser(children$jscomp$3));\n            var JSCompiler_inline_result$jscomp$1 = null;\n          } else JSCompiler_inline_result$jscomp$1 = children$jscomp$3;\n          return JSCompiler_inline_result$jscomp$1;\n        case \"form\":\n          target$jscomp$0.push(startChunkForTag(\"form\"));\n          var children$jscomp$4 = null,\n            innerHTML$jscomp$3 = null,\n            formAction$jscomp$1 = null,\n            formEncType$jscomp$1 = null,\n            formMethod$jscomp$1 = null,\n            formTarget$jscomp$1 = null,\n            propKey$jscomp$5;\n          for (propKey$jscomp$5 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$5)) {\n              var propValue$jscomp$5 = props[propKey$jscomp$5];\n              if (null != propValue$jscomp$5)\n                switch (propKey$jscomp$5) {\n                  case \"children\":\n                    children$jscomp$4 = propValue$jscomp$5;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML$jscomp$3 = propValue$jscomp$5;\n                    break;\n                  case \"action\":\n                    formAction$jscomp$1 = propValue$jscomp$5;\n                    break;\n                  case \"encType\":\n                    formEncType$jscomp$1 = propValue$jscomp$5;\n                    break;\n                  case \"method\":\n                    formMethod$jscomp$1 = propValue$jscomp$5;\n                    break;\n                  case \"target\":\n                    formTarget$jscomp$1 = propValue$jscomp$5;\n                    break;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$5,\n                      propValue$jscomp$5\n                    );\n                }\n            }\n          var formData$jscomp$1 = null,\n            formActionName = null;\n          if (\"function\" === typeof formAction$jscomp$1) {\n            (null === formEncType$jscomp$1 && null === formMethod$jscomp$1) ||\n              didWarnFormActionMethod ||\n              ((didWarnFormActionMethod = !0),\n              console.error(\n                \"Cannot specify a encType or method for a form that specifies a function as the action. React provides those automatically. They will get overridden.\"\n              ));\n            null === formTarget$jscomp$1 ||\n              didWarnFormActionTarget ||\n              ((didWarnFormActionTarget = !0),\n              console.error(\n                \"Cannot specify a target for a form that specifies a function as the action. The function will always be executed in the same window.\"\n              ));\n            var customFields = getCustomFormFields(\n              resumableState,\n              formAction$jscomp$1\n            );\n            null !== customFields\n              ? ((formAction$jscomp$1 = customFields.action || \"\"),\n                (formEncType$jscomp$1 = customFields.encType),\n                (formMethod$jscomp$1 = customFields.method),\n                (formTarget$jscomp$1 = customFields.target),\n                (formData$jscomp$1 = customFields.data),\n                (formActionName = customFields.name))\n              : (target$jscomp$0.push(\n                  attributeSeparator,\n                  \"action\",\n                  attributeAssign,\n                  actionJavaScriptURL,\n                  attributeEnd\n                ),\n                (formTarget$jscomp$1 =\n                  formMethod$jscomp$1 =\n                  formEncType$jscomp$1 =\n                  formAction$jscomp$1 =\n                    null),\n                injectFormReplayingRuntime(resumableState, renderState));\n          }\n          null != formAction$jscomp$1 &&\n            pushAttribute(target$jscomp$0, \"action\", formAction$jscomp$1);\n          null != formEncType$jscomp$1 &&\n            pushAttribute(target$jscomp$0, \"encType\", formEncType$jscomp$1);\n          null != formMethod$jscomp$1 &&\n            pushAttribute(target$jscomp$0, \"method\", formMethod$jscomp$1);\n          null != formTarget$jscomp$1 &&\n            pushAttribute(target$jscomp$0, \"target\", formTarget$jscomp$1);\n          target$jscomp$0.push(endOfStartTag);\n          null !== formActionName &&\n            (target$jscomp$0.push('<input type=\"hidden\"'),\n            pushStringAttribute(target$jscomp$0, \"name\", formActionName),\n            target$jscomp$0.push(endOfStartTagSelfClosing),\n            null != formData$jscomp$1 &&\n              formData$jscomp$1.forEach(\n                pushAdditionalFormField,\n                target$jscomp$0\n              ));\n          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$3, children$jscomp$4);\n          if (\"string\" === typeof children$jscomp$4) {\n            target$jscomp$0.push(escapeTextForBrowser(children$jscomp$4));\n            var JSCompiler_inline_result$jscomp$2 = null;\n          } else JSCompiler_inline_result$jscomp$2 = children$jscomp$4;\n          return JSCompiler_inline_result$jscomp$2;\n        case \"menuitem\":\n          target$jscomp$0.push(startChunkForTag(\"menuitem\"));\n          for (var propKey$jscomp$6 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$6)) {\n              var propValue$jscomp$6 = props[propKey$jscomp$6];\n              if (null != propValue$jscomp$6)\n                switch (propKey$jscomp$6) {\n                  case \"children\":\n                  case \"dangerouslySetInnerHTML\":\n                    throw Error(\n                      \"menuitems cannot have `children` nor `dangerouslySetInnerHTML`.\"\n                    );\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$6,\n                      propValue$jscomp$6\n                    );\n                }\n            }\n          target$jscomp$0.push(endOfStartTag);\n          return null;\n        case \"object\":\n          target$jscomp$0.push(startChunkForTag(\"object\"));\n          var children$jscomp$5 = null,\n            innerHTML$jscomp$4 = null,\n            propKey$jscomp$7;\n          for (propKey$jscomp$7 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$7)) {\n              var propValue$jscomp$7 = props[propKey$jscomp$7];\n              if (null != propValue$jscomp$7)\n                switch (propKey$jscomp$7) {\n                  case \"children\":\n                    children$jscomp$5 = propValue$jscomp$7;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML$jscomp$4 = propValue$jscomp$7;\n                    break;\n                  case \"data\":\n                    checkAttributeStringCoercion(propValue$jscomp$7, \"data\");\n                    var sanitizedValue = sanitizeURL(\"\" + propValue$jscomp$7);\n                    if (\"\" === sanitizedValue) {\n                      console.error(\n                        'An empty string (\"\") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',\n                        propKey$jscomp$7,\n                        propKey$jscomp$7\n                      );\n                      break;\n                    }\n                    target$jscomp$0.push(\n                      attributeSeparator,\n                      \"data\",\n                      attributeAssign,\n                      escapeTextForBrowser(sanitizedValue),\n                      attributeEnd\n                    );\n                    break;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$7,\n                      propValue$jscomp$7\n                    );\n                }\n            }\n          target$jscomp$0.push(endOfStartTag);\n          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$4, children$jscomp$5);\n          if (\"string\" === typeof children$jscomp$5) {\n            target$jscomp$0.push(escapeTextForBrowser(children$jscomp$5));\n            var JSCompiler_inline_result$jscomp$3 = null;\n          } else JSCompiler_inline_result$jscomp$3 = children$jscomp$5;\n          return JSCompiler_inline_result$jscomp$3;\n        case \"title\":\n          var insertionMode = formatContext.insertionMode,\n            noscriptTagInScope = !!(formatContext.tagScope & 1);\n          if (hasOwnProperty.call(props, \"children\")) {\n            var children$jscomp$6 = props.children,\n              child = Array.isArray(children$jscomp$6)\n                ? 2 > children$jscomp$6.length\n                  ? children$jscomp$6[0]\n                  : null\n                : children$jscomp$6;\n            Array.isArray(children$jscomp$6) && 1 < children$jscomp$6.length\n              ? console.error(\n                  \"React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an Array with length %s instead. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert `children` of <title> tags to a single string value which is why Arrays of length greater than 1 are not supported. When using JSX it can be commong to combine text nodes and value nodes. For example: <title>hello {nameOfUser}</title>. While not immediately apparent, `children` in this case is an Array with length 2. If your `children` prop is using this form try rewriting it using a template string: <title>{`hello ${nameOfUser}`}</title>.\",\n                  children$jscomp$6.length\n                )\n              : \"function\" === typeof child || \"symbol\" === typeof child\n                ? console.error(\n                    \"React expect children of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found %s instead. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value.\",\n                    \"function\" === typeof child ? \"a Function\" : \"a Sybmol\"\n                  )\n                : child &&\n                  child.toString === {}.toString &&\n                  (null != child.$$typeof\n                    ? console.error(\n                        \"React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an object that appears to be a React element which never implements a suitable `toString` method. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value which is why rendering React elements is not supported. If the `children` of <title> is a React Component try moving the <title> tag into that component. If the `children` of <title> is some HTML markup change it to be Text only to be valid HTML.\"\n                      )\n                    : console.error(\n                        \"React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an object that does not implement a suitable `toString` method. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value. Using the default `toString` method available on every object is almost certainly an error. Consider whether the `children` of this <title> is an object in error and change it to a string or number value if so. Otherwise implement a `toString` method that React can use to produce a valid <title>.\"\n                      ));\n          }\n          if (\n            insertionMode === SVG_MODE ||\n            noscriptTagInScope ||\n            null != props.itemProp\n          )\n            var JSCompiler_inline_result$jscomp$4 = pushTitleImpl(\n              target$jscomp$0,\n              props\n            );\n          else\n            isFallback\n              ? (JSCompiler_inline_result$jscomp$4 = null)\n              : (pushTitleImpl(renderState.hoistableChunks, props),\n                (JSCompiler_inline_result$jscomp$4 = void 0));\n          return JSCompiler_inline_result$jscomp$4;\n        case \"link\":\n          var rel = props.rel,\n            href = props.href,\n            precedence = props.precedence;\n          if (\n            formatContext.insertionMode === SVG_MODE ||\n            formatContext.tagScope & 1 ||\n            null != props.itemProp ||\n            \"string\" !== typeof rel ||\n            \"string\" !== typeof href ||\n            \"\" === href\n          ) {\n            \"stylesheet\" === rel &&\n              \"string\" === typeof props.precedence &&\n              ((\"string\" === typeof href && href) ||\n                console.error(\n                  'React encountered a `<link rel=\"stylesheet\" .../>` with a `precedence` prop and expected the `href` prop to be a non-empty string but ecountered %s instead. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop ensure there is a non-empty string `href` prop as well, otherwise remove the `precedence` prop.',\n                  null === href\n                    ? \"`null`\"\n                    : void 0 === href\n                      ? \"`undefined`\"\n                      : \"\" === href\n                        ? \"an empty string\"\n                        : 'something with type \"' + typeof href + '\"'\n                ));\n            pushLinkImpl(target$jscomp$0, props);\n            var JSCompiler_inline_result$jscomp$5 = null;\n          } else if (\"stylesheet\" === props.rel)\n            if (\n              \"string\" !== typeof precedence ||\n              null != props.disabled ||\n              props.onLoad ||\n              props.onError\n            ) {\n              if (\"string\" === typeof precedence)\n                if (null != props.disabled)\n                  console.error(\n                    'React encountered a `<link rel=\"stylesheet\" .../>` with a `precedence` prop and a `disabled` prop. The presence of the `disabled` prop indicates an intent to manage the stylesheet active state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the `disabled` prop, otherwise remove the `precedence` prop.'\n                  );\n                else if (props.onLoad || props.onError) {\n                  var propDescription =\n                    props.onLoad && props.onError\n                      ? \"`onLoad` and `onError` props\"\n                      : props.onLoad\n                        ? \"`onLoad` prop\"\n                        : \"`onError` prop\";\n                  console.error(\n                    'React encountered a `<link rel=\"stylesheet\" .../>` with a `precedence` prop and %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.',\n                    propDescription,\n                    propDescription\n                  );\n                }\n              JSCompiler_inline_result$jscomp$5 = pushLinkImpl(\n                target$jscomp$0,\n                props\n              );\n            } else {\n              var styleQueue = renderState.styles.get(precedence),\n                resourceState = resumableState.styleResources.hasOwnProperty(\n                  href\n                )\n                  ? resumableState.styleResources[href]\n                  : void 0;\n              if (resourceState !== EXISTS) {\n                resumableState.styleResources[href] = EXISTS;\n                styleQueue ||\n                  ((styleQueue = {\n                    precedence: escapeTextForBrowser(precedence),\n                    rules: [],\n                    hrefs: [],\n                    sheets: new Map()\n                  }),\n                  renderState.styles.set(precedence, styleQueue));\n                var resource = {\n                  state: PENDING$1,\n                  props: assign({}, props, {\n                    \"data-precedence\": props.precedence,\n                    precedence: null\n                  })\n                };\n                if (resourceState) {\n                  2 === resourceState.length &&\n                    adoptPreloadCredentials(resource.props, resourceState);\n                  var preloadResource =\n                    renderState.preloads.stylesheets.get(href);\n                  preloadResource && 0 < preloadResource.length\n                    ? (preloadResource.length = 0)\n                    : (resource.state = PRELOADED);\n                }\n                styleQueue.sheets.set(href, resource);\n                hoistableState && hoistableState.stylesheets.add(resource);\n              } else if (styleQueue) {\n                var _resource = styleQueue.sheets.get(href);\n                _resource &&\n                  hoistableState &&\n                  hoistableState.stylesheets.add(_resource);\n              }\n              textEmbedded && target$jscomp$0.push(\"\\x3c!-- --\\x3e\");\n              JSCompiler_inline_result$jscomp$5 = null;\n            }\n          else\n            props.onLoad || props.onError\n              ? (JSCompiler_inline_result$jscomp$5 = pushLinkImpl(\n                  target$jscomp$0,\n                  props\n                ))\n              : (textEmbedded && target$jscomp$0.push(\"\\x3c!-- --\\x3e\"),\n                (JSCompiler_inline_result$jscomp$5 = isFallback\n                  ? null\n                  : pushLinkImpl(renderState.hoistableChunks, props)));\n          return JSCompiler_inline_result$jscomp$5;\n        case \"script\":\n          var asyncProp = props.async;\n          if (\n            \"string\" !== typeof props.src ||\n            !props.src ||\n            !asyncProp ||\n            \"function\" === typeof asyncProp ||\n            \"symbol\" === typeof asyncProp ||\n            props.onLoad ||\n            props.onError ||\n            formatContext.insertionMode === SVG_MODE ||\n            formatContext.tagScope & 1 ||\n            null != props.itemProp\n          )\n            var JSCompiler_inline_result$jscomp$6 = pushScriptImpl(\n              target$jscomp$0,\n              props\n            );\n          else {\n            var key = props.src;\n            if (\"module\" === props.type) {\n              var resources = resumableState.moduleScriptResources;\n              var preloads = renderState.preloads.moduleScripts;\n            } else\n              (resources = resumableState.scriptResources),\n                (preloads = renderState.preloads.scripts);\n            var resourceState$jscomp$0 = resources.hasOwnProperty(key)\n              ? resources[key]\n              : void 0;\n            if (resourceState$jscomp$0 !== EXISTS) {\n              resources[key] = EXISTS;\n              var scriptProps = props;\n              if (resourceState$jscomp$0) {\n                2 === resourceState$jscomp$0.length &&\n                  ((scriptProps = assign({}, props)),\n                  adoptPreloadCredentials(scriptProps, resourceState$jscomp$0));\n                var preloadResource$jscomp$0 = preloads.get(key);\n                preloadResource$jscomp$0 &&\n                  (preloadResource$jscomp$0.length = 0);\n              }\n              var resource$jscomp$0 = [];\n              renderState.scripts.add(resource$jscomp$0);\n              pushScriptImpl(resource$jscomp$0, scriptProps);\n            }\n            textEmbedded && target$jscomp$0.push(\"\\x3c!-- --\\x3e\");\n            JSCompiler_inline_result$jscomp$6 = null;\n          }\n          return JSCompiler_inline_result$jscomp$6;\n        case \"style\":\n          var insertionMode$jscomp$0 = formatContext.insertionMode,\n            noscriptTagInScope$jscomp$0 = !!(formatContext.tagScope & 1);\n          if (hasOwnProperty.call(props, \"children\")) {\n            var children$jscomp$7 = props.children,\n              child$jscomp$0 = Array.isArray(children$jscomp$7)\n                ? 2 > children$jscomp$7.length\n                  ? children$jscomp$7[0]\n                  : null\n                : children$jscomp$7;\n            (\"function\" === typeof child$jscomp$0 ||\n              \"symbol\" === typeof child$jscomp$0 ||\n              Array.isArray(child$jscomp$0)) &&\n              console.error(\n                \"React expect children of <style> tags to be a string, number, or object with a `toString` method but found %s instead. In browsers style Elements can only have `Text` Nodes as children.\",\n                \"function\" === typeof child$jscomp$0\n                  ? \"a Function\"\n                  : \"symbol\" === typeof child$jscomp$0\n                    ? \"a Sybmol\"\n                    : \"an Array\"\n              );\n          }\n          var precedence$jscomp$0 = props.precedence,\n            href$jscomp$0 = props.href;\n          if (\n            insertionMode$jscomp$0 === SVG_MODE ||\n            noscriptTagInScope$jscomp$0 ||\n            null != props.itemProp ||\n            \"string\" !== typeof precedence$jscomp$0 ||\n            \"string\" !== typeof href$jscomp$0 ||\n            \"\" === href$jscomp$0\n          ) {\n            target$jscomp$0.push(startChunkForTag(\"style\"));\n            var children$jscomp$8 = null,\n              innerHTML$jscomp$5 = null,\n              propKey$jscomp$8;\n            for (propKey$jscomp$8 in props)\n              if (hasOwnProperty.call(props, propKey$jscomp$8)) {\n                var propValue$jscomp$8 = props[propKey$jscomp$8];\n                if (null != propValue$jscomp$8)\n                  switch (propKey$jscomp$8) {\n                    case \"children\":\n                      children$jscomp$8 = propValue$jscomp$8;\n                      break;\n                    case \"dangerouslySetInnerHTML\":\n                      innerHTML$jscomp$5 = propValue$jscomp$8;\n                      break;\n                    default:\n                      pushAttribute(\n                        target$jscomp$0,\n                        propKey$jscomp$8,\n                        propValue$jscomp$8\n                      );\n                  }\n              }\n            target$jscomp$0.push(endOfStartTag);\n            var child$jscomp$1 = Array.isArray(children$jscomp$8)\n              ? 2 > children$jscomp$8.length\n                ? children$jscomp$8[0]\n                : null\n              : children$jscomp$8;\n            \"function\" !== typeof child$jscomp$1 &&\n              \"symbol\" !== typeof child$jscomp$1 &&\n              null !== child$jscomp$1 &&\n              void 0 !== child$jscomp$1 &&\n              target$jscomp$0.push(escapeStyleTextContent(child$jscomp$1));\n            pushInnerHTML(\n              target$jscomp$0,\n              innerHTML$jscomp$5,\n              children$jscomp$8\n            );\n            target$jscomp$0.push(endChunkForTag(\"style\"));\n            var JSCompiler_inline_result$jscomp$7 = null;\n          } else {\n            href$jscomp$0.includes(\" \") &&\n              console.error(\n                'React expected the `href` prop for a <style> tag opting into hoisting semantics using the `precedence` prop to not have any spaces but ecountered spaces instead. using spaces in this prop will cause hydration of this style to fail on the client. The href for the <style> where this ocurred is \"%s\".',\n                href$jscomp$0\n              );\n            var styleQueue$jscomp$0 =\n                renderState.styles.get(precedence$jscomp$0),\n              resourceState$jscomp$1 =\n                resumableState.styleResources.hasOwnProperty(href$jscomp$0)\n                  ? resumableState.styleResources[href$jscomp$0]\n                  : void 0;\n            if (resourceState$jscomp$1 !== EXISTS) {\n              resumableState.styleResources[href$jscomp$0] = EXISTS;\n              resourceState$jscomp$1 &&\n                console.error(\n                  'React encountered a hoistable style tag for the same href as a preload: \"%s\". When using a style tag to inline styles you should not also preload it as a stylsheet.',\n                  href$jscomp$0\n                );\n              styleQueue$jscomp$0\n                ? styleQueue$jscomp$0.hrefs.push(\n                    escapeTextForBrowser(href$jscomp$0)\n                  )\n                : ((styleQueue$jscomp$0 = {\n                    precedence: escapeTextForBrowser(precedence$jscomp$0),\n                    rules: [],\n                    hrefs: [escapeTextForBrowser(href$jscomp$0)],\n                    sheets: new Map()\n                  }),\n                  renderState.styles.set(\n                    precedence$jscomp$0,\n                    styleQueue$jscomp$0\n                  ));\n              var target = styleQueue$jscomp$0.rules,\n                children$jscomp$9 = null,\n                innerHTML$jscomp$6 = null,\n                propKey$jscomp$9;\n              for (propKey$jscomp$9 in props)\n                if (hasOwnProperty.call(props, propKey$jscomp$9)) {\n                  var propValue$jscomp$9 = props[propKey$jscomp$9];\n                  if (null != propValue$jscomp$9)\n                    switch (propKey$jscomp$9) {\n                      case \"children\":\n                        children$jscomp$9 = propValue$jscomp$9;\n                        break;\n                      case \"dangerouslySetInnerHTML\":\n                        innerHTML$jscomp$6 = propValue$jscomp$9;\n                    }\n                }\n              var child$jscomp$2 = Array.isArray(children$jscomp$9)\n                ? 2 > children$jscomp$9.length\n                  ? children$jscomp$9[0]\n                  : null\n                : children$jscomp$9;\n              \"function\" !== typeof child$jscomp$2 &&\n                \"symbol\" !== typeof child$jscomp$2 &&\n                null !== child$jscomp$2 &&\n                void 0 !== child$jscomp$2 &&\n                target.push(escapeStyleTextContent(child$jscomp$2));\n              pushInnerHTML(target, innerHTML$jscomp$6, children$jscomp$9);\n            }\n            styleQueue$jscomp$0 &&\n              hoistableState &&\n              hoistableState.styles.add(styleQueue$jscomp$0);\n            textEmbedded && target$jscomp$0.push(\"\\x3c!-- --\\x3e\");\n            JSCompiler_inline_result$jscomp$7 = void 0;\n          }\n          return JSCompiler_inline_result$jscomp$7;\n        case \"meta\":\n          if (\n            formatContext.insertionMode === SVG_MODE ||\n            formatContext.tagScope & 1 ||\n            null != props.itemProp\n          )\n            var JSCompiler_inline_result$jscomp$8 = pushSelfClosing(\n              target$jscomp$0,\n              props,\n              \"meta\"\n            );\n          else\n            textEmbedded && target$jscomp$0.push(\"\\x3c!-- --\\x3e\"),\n              (JSCompiler_inline_result$jscomp$8 = isFallback\n                ? null\n                : \"string\" === typeof props.charSet\n                  ? pushSelfClosing(renderState.charsetChunks, props, \"meta\")\n                  : \"viewport\" === props.name\n                    ? pushSelfClosing(renderState.viewportChunks, props, \"meta\")\n                    : pushSelfClosing(\n                        renderState.hoistableChunks,\n                        props,\n                        \"meta\"\n                      ));\n          return JSCompiler_inline_result$jscomp$8;\n        case \"listing\":\n        case \"pre\":\n          target$jscomp$0.push(startChunkForTag(type));\n          var children$jscomp$10 = null,\n            innerHTML$jscomp$7 = null,\n            propKey$jscomp$10;\n          for (propKey$jscomp$10 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$10)) {\n              var propValue$jscomp$10 = props[propKey$jscomp$10];\n              if (null != propValue$jscomp$10)\n                switch (propKey$jscomp$10) {\n                  case \"children\":\n                    children$jscomp$10 = propValue$jscomp$10;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML$jscomp$7 = propValue$jscomp$10;\n                    break;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$10,\n                      propValue$jscomp$10\n                    );\n                }\n            }\n          target$jscomp$0.push(endOfStartTag);\n          if (null != innerHTML$jscomp$7) {\n            if (null != children$jscomp$10)\n              throw Error(\n                \"Can only set one of `children` or `props.dangerouslySetInnerHTML`.\"\n              );\n            if (\n              \"object\" !== typeof innerHTML$jscomp$7 ||\n              !(\"__html\" in innerHTML$jscomp$7)\n            )\n              throw Error(\n                \"`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information.\"\n              );\n            var html = innerHTML$jscomp$7.__html;\n            null !== html &&\n              void 0 !== html &&\n              (\"string\" === typeof html && 0 < html.length && \"\\n\" === html[0]\n                ? target$jscomp$0.push(leadingNewline, html)\n                : (checkHtmlStringCoercion(html),\n                  target$jscomp$0.push(\"\" + html)));\n          }\n          \"string\" === typeof children$jscomp$10 &&\n            \"\\n\" === children$jscomp$10[0] &&\n            target$jscomp$0.push(leadingNewline);\n          return children$jscomp$10;\n        case \"img\":\n          var src = props.src,\n            srcSet = props.srcSet;\n          if (\n            !(\n              \"lazy\" === props.loading ||\n              (!src && !srcSet) ||\n              (\"string\" !== typeof src && null != src) ||\n              (\"string\" !== typeof srcSet && null != srcSet)\n            ) &&\n            \"low\" !== props.fetchPriority &&\n            !1 === !!(formatContext.tagScope & 3) &&\n            (\"string\" !== typeof src ||\n              \":\" !== src[4] ||\n              (\"d\" !== src[0] && \"D\" !== src[0]) ||\n              (\"a\" !== src[1] && \"A\" !== src[1]) ||\n              (\"t\" !== src[2] && \"T\" !== src[2]) ||\n              (\"a\" !== src[3] && \"A\" !== src[3])) &&\n            (\"string\" !== typeof srcSet ||\n              \":\" !== srcSet[4] ||\n              (\"d\" !== srcSet[0] && \"D\" !== srcSet[0]) ||\n              (\"a\" !== srcSet[1] && \"A\" !== srcSet[1]) ||\n              (\"t\" !== srcSet[2] && \"T\" !== srcSet[2]) ||\n              (\"a\" !== srcSet[3] && \"A\" !== srcSet[3]))\n          ) {\n            var sizes = \"string\" === typeof props.sizes ? props.sizes : void 0,\n              key$jscomp$0 = srcSet ? srcSet + \"\\n\" + (sizes || \"\") : src,\n              promotablePreloads = renderState.preloads.images,\n              resource$jscomp$1 = promotablePreloads.get(key$jscomp$0);\n            if (resource$jscomp$1) {\n              if (\n                \"high\" === props.fetchPriority ||\n                10 > renderState.highImagePreloads.size\n              )\n                promotablePreloads.delete(key$jscomp$0),\n                  renderState.highImagePreloads.add(resource$jscomp$1);\n            } else if (\n              !resumableState.imageResources.hasOwnProperty(key$jscomp$0)\n            ) {\n              resumableState.imageResources[key$jscomp$0] = PRELOAD_NO_CREDS;\n              var input = props.crossOrigin;\n              var crossOrigin =\n                \"string\" === typeof input\n                  ? \"use-credentials\" === input\n                    ? input\n                    : \"\"\n                  : void 0;\n              var headers = renderState.headers,\n                header;\n              headers &&\n              0 < headers.remainingCapacity &&\n              (\"high\" === props.fetchPriority ||\n                500 > headers.highImagePreloads.length) &&\n              ((header = getPreloadAsHeader(src, \"image\", {\n                imageSrcSet: props.srcSet,\n                imageSizes: props.sizes,\n                crossOrigin: crossOrigin,\n                integrity: props.integrity,\n                nonce: props.nonce,\n                type: props.type,\n                fetchPriority: props.fetchPriority,\n                referrerPolicy: props.refererPolicy\n              })),\n              0 <= (headers.remainingCapacity -= header.length + 2))\n                ? ((renderState.resets.image[key$jscomp$0] = PRELOAD_NO_CREDS),\n                  headers.highImagePreloads &&\n                    (headers.highImagePreloads += \", \"),\n                  (headers.highImagePreloads += header))\n                : ((resource$jscomp$1 = []),\n                  pushLinkImpl(resource$jscomp$1, {\n                    rel: \"preload\",\n                    as: \"image\",\n                    href: srcSet ? void 0 : src,\n                    imageSrcSet: srcSet,\n                    imageSizes: sizes,\n                    crossOrigin: crossOrigin,\n                    integrity: props.integrity,\n                    type: props.type,\n                    fetchPriority: props.fetchPriority,\n                    referrerPolicy: props.referrerPolicy\n                  }),\n                  \"high\" === props.fetchPriority ||\n                  10 > renderState.highImagePreloads.size\n                    ? renderState.highImagePreloads.add(resource$jscomp$1)\n                    : (renderState.bulkPreloads.add(resource$jscomp$1),\n                      promotablePreloads.set(key$jscomp$0, resource$jscomp$1)));\n            }\n          }\n          return pushSelfClosing(target$jscomp$0, props, \"img\");\n        case \"base\":\n        case \"area\":\n        case \"br\":\n        case \"col\":\n        case \"embed\":\n        case \"hr\":\n        case \"keygen\":\n        case \"param\":\n        case \"source\":\n        case \"track\":\n        case \"wbr\":\n          return pushSelfClosing(target$jscomp$0, props, type);\n        case \"annotation-xml\":\n        case \"color-profile\":\n        case \"font-face\":\n        case \"font-face-src\":\n        case \"font-face-uri\":\n        case \"font-face-format\":\n        case \"font-face-name\":\n        case \"missing-glyph\":\n          break;\n        case \"head\":\n          if (\n            formatContext.insertionMode < HTML_MODE &&\n            null === renderState.headChunks\n          ) {\n            renderState.headChunks = [];\n            var JSCompiler_inline_result$jscomp$9 = pushStartGenericElement(\n              renderState.headChunks,\n              props,\n              \"head\"\n            );\n          } else\n            JSCompiler_inline_result$jscomp$9 = pushStartGenericElement(\n              target$jscomp$0,\n              props,\n              \"head\"\n            );\n          return JSCompiler_inline_result$jscomp$9;\n        case \"html\":\n          if (\n            formatContext.insertionMode === ROOT_HTML_MODE &&\n            null === renderState.htmlChunks\n          ) {\n            renderState.htmlChunks = [doctypeChunk];\n            var JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(\n              renderState.htmlChunks,\n              props,\n              \"html\"\n            );\n          } else\n            JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(\n              target$jscomp$0,\n              props,\n              \"html\"\n            );\n          return JSCompiler_inline_result$jscomp$10;\n        default:\n          if (-1 !== type.indexOf(\"-\")) {\n            target$jscomp$0.push(startChunkForTag(type));\n            var children$jscomp$11 = null,\n              innerHTML$jscomp$8 = null,\n              propKey$jscomp$11;\n            for (propKey$jscomp$11 in props)\n              if (hasOwnProperty.call(props, propKey$jscomp$11)) {\n                var propValue$jscomp$11 = props[propKey$jscomp$11];\n                if (null != propValue$jscomp$11) {\n                  var attributeName = propKey$jscomp$11;\n                  switch (propKey$jscomp$11) {\n                    case \"children\":\n                      children$jscomp$11 = propValue$jscomp$11;\n                      break;\n                    case \"dangerouslySetInnerHTML\":\n                      innerHTML$jscomp$8 = propValue$jscomp$11;\n                      break;\n                    case \"style\":\n                      pushStyleAttribute(target$jscomp$0, propValue$jscomp$11);\n                      break;\n                    case \"suppressContentEditableWarning\":\n                    case \"suppressHydrationWarning\":\n                    case \"ref\":\n                      break;\n                    case \"className\":\n                      attributeName = \"class\";\n                    default:\n                      if (\n                        isAttributeNameSafe(propKey$jscomp$11) &&\n                        \"function\" !== typeof propValue$jscomp$11 &&\n                        \"symbol\" !== typeof propValue$jscomp$11 &&\n                        !1 !== propValue$jscomp$11\n                      ) {\n                        if (!0 === propValue$jscomp$11)\n                          propValue$jscomp$11 = \"\";\n                        else if (\"object\" === typeof propValue$jscomp$11)\n                          continue;\n                        target$jscomp$0.push(\n                          attributeSeparator,\n                          attributeName,\n                          attributeAssign,\n                          escapeTextForBrowser(propValue$jscomp$11),\n                          attributeEnd\n                        );\n                      }\n                  }\n                }\n              }\n            target$jscomp$0.push(endOfStartTag);\n            pushInnerHTML(\n              target$jscomp$0,\n              innerHTML$jscomp$8,\n              children$jscomp$11\n            );\n            return children$jscomp$11;\n          }\n      }\n      return pushStartGenericElement(target$jscomp$0, props, type);\n    }\n    function endChunkForTag(tag) {\n      var chunk = endTagCache.get(tag);\n      void 0 === chunk &&\n        ((chunk = \"</\" + tag + \">\"), endTagCache.set(tag, chunk));\n      return chunk;\n    }\n    function writeBootstrap(destination, renderState) {\n      renderState = renderState.bootstrapChunks;\n      for (var i = 0; i < renderState.length - 1; i++)\n        destination.push(renderState[i]);\n      return i < renderState.length\n        ? ((i = renderState[i]), (renderState.length = 0), destination.push(i))\n        : !0;\n    }\n    function writeStartPendingSuspenseBoundary(destination, renderState, id) {\n      destination.push(startPendingSuspenseBoundary1);\n      if (null === id)\n        throw Error(\n          \"An ID must have been assigned before we can complete the boundary.\"\n        );\n      destination.push(renderState.boundaryPrefix);\n      renderState = id.toString(16);\n      destination.push(renderState);\n      return destination.push(startPendingSuspenseBoundary2);\n    }\n    function writeStartSegment(destination, renderState, formatContext, id) {\n      switch (formatContext.insertionMode) {\n        case ROOT_HTML_MODE:\n        case HTML_HTML_MODE:\n        case HTML_MODE:\n          return (\n            destination.push(startSegmentHTML),\n            destination.push(renderState.segmentPrefix),\n            (renderState = id.toString(16)),\n            destination.push(renderState),\n            destination.push(startSegmentHTML2)\n          );\n        case SVG_MODE:\n          return (\n            destination.push(startSegmentSVG),\n            destination.push(renderState.segmentPrefix),\n            (renderState = id.toString(16)),\n            destination.push(renderState),\n            destination.push(startSegmentSVG2)\n          );\n        case MATHML_MODE:\n          return (\n            destination.push(startSegmentMathML),\n            destination.push(renderState.segmentPrefix),\n            (renderState = id.toString(16)),\n            destination.push(renderState),\n            destination.push(startSegmentMathML2)\n          );\n        case HTML_TABLE_MODE:\n          return (\n            destination.push(startSegmentTable),\n            destination.push(renderState.segmentPrefix),\n            (renderState = id.toString(16)),\n            destination.push(renderState),\n            destination.push(startSegmentTable2)\n          );\n        case HTML_TABLE_BODY_MODE:\n          return (\n            destination.push(startSegmentTableBody),\n            destination.push(renderState.segmentPrefix),\n            (renderState = id.toString(16)),\n            destination.push(renderState),\n            destination.push(startSegmentTableBody2)\n          );\n        case HTML_TABLE_ROW_MODE:\n          return (\n            destination.push(startSegmentTableRow),\n            destination.push(renderState.segmentPrefix),\n            (renderState = id.toString(16)),\n            destination.push(renderState),\n            destination.push(startSegmentTableRow2)\n          );\n        case HTML_COLGROUP_MODE:\n          return (\n            destination.push(startSegmentColGroup),\n            destination.push(renderState.segmentPrefix),\n            (renderState = id.toString(16)),\n            destination.push(renderState),\n            destination.push(startSegmentColGroup2)\n          );\n        default:\n          throw Error(\"Unknown insertion mode. This is a bug in React.\");\n      }\n    }\n    function writeEndSegment(destination, formatContext) {\n      switch (formatContext.insertionMode) {\n        case ROOT_HTML_MODE:\n        case HTML_HTML_MODE:\n        case HTML_MODE:\n          return destination.push(endSegmentHTML);\n        case SVG_MODE:\n          return destination.push(endSegmentSVG);\n        case MATHML_MODE:\n          return destination.push(endSegmentMathML);\n        case HTML_TABLE_MODE:\n          return destination.push(endSegmentTable);\n        case HTML_TABLE_BODY_MODE:\n          return destination.push(endSegmentTableBody);\n        case HTML_TABLE_ROW_MODE:\n          return destination.push(endSegmentTableRow);\n        case HTML_COLGROUP_MODE:\n          return destination.push(endSegmentColGroup);\n        default:\n          throw Error(\"Unknown insertion mode. This is a bug in React.\");\n      }\n    }\n    function escapeJSStringsForInstructionScripts(input) {\n      return JSON.stringify(input).replace(\n        regexForJSStringsInInstructionScripts,\n        function (match) {\n          switch (match) {\n            case \"<\":\n              return \"\\\\u003c\";\n            case \"\\u2028\":\n              return \"\\\\u2028\";\n            case \"\\u2029\":\n              return \"\\\\u2029\";\n            default:\n              throw Error(\n                \"escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\"\n              );\n          }\n        }\n      );\n    }\n    function escapeJSObjectForInstructionScripts(input) {\n      return JSON.stringify(input).replace(\n        regexForJSStringsInScripts,\n        function (match) {\n          switch (match) {\n            case \"&\":\n              return \"\\\\u0026\";\n            case \">\":\n              return \"\\\\u003e\";\n            case \"<\":\n              return \"\\\\u003c\";\n            case \"\\u2028\":\n              return \"\\\\u2028\";\n            case \"\\u2029\":\n              return \"\\\\u2029\";\n            default:\n              throw Error(\n                \"escapeJSObjectForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\"\n              );\n          }\n        }\n      );\n    }\n    function flushStyleTagsLateForBoundary(styleQueue) {\n      var rules = styleQueue.rules,\n        hrefs = styleQueue.hrefs;\n      0 < rules.length &&\n        0 === hrefs.length &&\n        console.error(\n          \"React expected to have at least one href for an a hoistable style but found none. This is a bug in React.\"\n        );\n      var i = 0;\n      if (hrefs.length) {\n        this.push(lateStyleTagResourceOpen1);\n        this.push(styleQueue.precedence);\n        for (this.push(lateStyleTagResourceOpen2); i < hrefs.length - 1; i++)\n          this.push(hrefs[i]), this.push(spaceSeparator);\n        this.push(hrefs[i]);\n        this.push(lateStyleTagResourceOpen3);\n        for (i = 0; i < rules.length; i++) this.push(rules[i]);\n        destinationHasCapacity = this.push(lateStyleTagTemplateClose);\n        currentlyRenderingBoundaryHasStylesToHoist = !0;\n        rules.length = 0;\n        hrefs.length = 0;\n      }\n    }\n    function hasStylesToHoist(stylesheet) {\n      return stylesheet.state !== PREAMBLE\n        ? (currentlyRenderingBoundaryHasStylesToHoist = !0)\n        : !1;\n    }\n    function writeHoistablesForBoundary(\n      destination,\n      hoistableState,\n      renderState\n    ) {\n      currentlyRenderingBoundaryHasStylesToHoist = !1;\n      destinationHasCapacity = !0;\n      hoistableState.styles.forEach(flushStyleTagsLateForBoundary, destination);\n      hoistableState.stylesheets.forEach(hasStylesToHoist);\n      currentlyRenderingBoundaryHasStylesToHoist &&\n        (renderState.stylesToHoist = !0);\n      return destinationHasCapacity;\n    }\n    function flushResource(resource) {\n      for (var i = 0; i < resource.length; i++) this.push(resource[i]);\n      resource.length = 0;\n    }\n    function flushStyleInPreamble(stylesheet) {\n      pushLinkImpl(stylesheetFlushingQueue, stylesheet.props);\n      for (var i = 0; i < stylesheetFlushingQueue.length; i++)\n        this.push(stylesheetFlushingQueue[i]);\n      stylesheetFlushingQueue.length = 0;\n      stylesheet.state = PREAMBLE;\n    }\n    function flushStylesInPreamble(styleQueue) {\n      var hasStylesheets = 0 < styleQueue.sheets.size;\n      styleQueue.sheets.forEach(flushStyleInPreamble, this);\n      styleQueue.sheets.clear();\n      var rules = styleQueue.rules,\n        hrefs = styleQueue.hrefs;\n      if (!hasStylesheets || hrefs.length) {\n        this.push(styleTagResourceOpen1);\n        this.push(styleQueue.precedence);\n        styleQueue = 0;\n        if (hrefs.length) {\n          for (\n            this.push(styleTagResourceOpen2);\n            styleQueue < hrefs.length - 1;\n            styleQueue++\n          )\n            this.push(hrefs[styleQueue]), this.push(spaceSeparator);\n          this.push(hrefs[styleQueue]);\n        }\n        this.push(styleTagResourceOpen3);\n        for (styleQueue = 0; styleQueue < rules.length; styleQueue++)\n          this.push(rules[styleQueue]);\n        this.push(styleTagResourceClose);\n        rules.length = 0;\n        hrefs.length = 0;\n      }\n    }\n    function preloadLateStyle(stylesheet) {\n      if (stylesheet.state === PENDING$1) {\n        stylesheet.state = PRELOADED;\n        var props = stylesheet.props;\n        pushLinkImpl(stylesheetFlushingQueue, {\n          rel: \"preload\",\n          as: \"style\",\n          href: stylesheet.props.href,\n          crossOrigin: props.crossOrigin,\n          fetchPriority: props.fetchPriority,\n          integrity: props.integrity,\n          media: props.media,\n          hrefLang: props.hrefLang,\n          referrerPolicy: props.referrerPolicy\n        });\n        for (\n          stylesheet = 0;\n          stylesheet < stylesheetFlushingQueue.length;\n          stylesheet++\n        )\n          this.push(stylesheetFlushingQueue[stylesheet]);\n        stylesheetFlushingQueue.length = 0;\n      }\n    }\n    function preloadLateStyles(styleQueue) {\n      styleQueue.sheets.forEach(preloadLateStyle, this);\n      styleQueue.sheets.clear();\n    }\n    function writeStyleResourceDependenciesInJS(destination, hoistableState) {\n      destination.push(arrayFirstOpenBracket);\n      var nextArrayOpenBrackChunk = arrayFirstOpenBracket;\n      hoistableState.stylesheets.forEach(function (resource) {\n        if (resource.state !== PREAMBLE)\n          if (resource.state === LATE)\n            destination.push(nextArrayOpenBrackChunk),\n              (resource = resource.props.href),\n              checkAttributeStringCoercion(resource, \"href\"),\n              (resource = escapeJSObjectForInstructionScripts(\"\" + resource)),\n              destination.push(resource),\n              destination.push(arrayCloseBracket),\n              (nextArrayOpenBrackChunk = arraySubsequentOpenBracket);\n          else {\n            destination.push(nextArrayOpenBrackChunk);\n            var precedence = resource.props[\"data-precedence\"],\n              props = resource.props,\n              coercedHref = sanitizeURL(\"\" + resource.props.href);\n            coercedHref = escapeJSObjectForInstructionScripts(coercedHref);\n            destination.push(coercedHref);\n            checkAttributeStringCoercion(precedence, \"precedence\");\n            precedence = \"\" + precedence;\n            destination.push(arrayInterstitial);\n            precedence = escapeJSObjectForInstructionScripts(precedence);\n            destination.push(precedence);\n            for (var propKey in props)\n              if (\n                hasOwnProperty.call(props, propKey) &&\n                ((precedence = props[propKey]), null != precedence)\n              )\n                switch (propKey) {\n                  case \"href\":\n                  case \"rel\":\n                  case \"precedence\":\n                  case \"data-precedence\":\n                    break;\n                  case \"children\":\n                  case \"dangerouslySetInnerHTML\":\n                    throw Error(\n                      \"link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.\"\n                    );\n                  default:\n                    writeStyleResourceAttributeInJS(\n                      destination,\n                      propKey,\n                      precedence\n                    );\n                }\n            destination.push(arrayCloseBracket);\n            nextArrayOpenBrackChunk = arraySubsequentOpenBracket;\n            resource.state = LATE;\n          }\n      });\n      destination.push(arrayCloseBracket);\n    }\n    function writeStyleResourceAttributeInJS(destination, name, value) {\n      var attributeName = name.toLowerCase();\n      switch (typeof value) {\n        case \"function\":\n        case \"symbol\":\n          return;\n      }\n      switch (name) {\n        case \"innerHTML\":\n        case \"dangerouslySetInnerHTML\":\n        case \"suppressContentEditableWarning\":\n        case \"suppressHydrationWarning\":\n        case \"style\":\n        case \"ref\":\n          return;\n        case \"className\":\n          attributeName = \"class\";\n          checkAttributeStringCoercion(value, attributeName);\n          name = \"\" + value;\n          break;\n        case \"hidden\":\n          if (!1 === value) return;\n          name = \"\";\n          break;\n        case \"src\":\n        case \"href\":\n          value = sanitizeURL(value);\n          checkAttributeStringCoercion(value, attributeName);\n          name = \"\" + value;\n          break;\n        default:\n          if (\n            (2 < name.length &&\n              (\"o\" === name[0] || \"O\" === name[0]) &&\n              (\"n\" === name[1] || \"N\" === name[1])) ||\n            !isAttributeNameSafe(name)\n          )\n            return;\n          checkAttributeStringCoercion(value, attributeName);\n          name = \"\" + value;\n      }\n      destination.push(arrayInterstitial);\n      attributeName = escapeJSObjectForInstructionScripts(attributeName);\n      destination.push(attributeName);\n      destination.push(arrayInterstitial);\n      attributeName = escapeJSObjectForInstructionScripts(name);\n      destination.push(attributeName);\n    }\n    function createHoistableState() {\n      return { styles: new Set(), stylesheets: new Set() };\n    }\n    function preloadBootstrapScriptOrModule(\n      resumableState,\n      renderState,\n      href,\n      props\n    ) {\n      (resumableState.scriptResources.hasOwnProperty(href) ||\n        resumableState.moduleScriptResources.hasOwnProperty(href)) &&\n        console.error(\n          'Internal React Error: React expected bootstrap script or module with src \"%s\" to not have been preloaded already. please file an issue',\n          href\n        );\n      resumableState.scriptResources[href] = EXISTS;\n      resumableState.moduleScriptResources[href] = EXISTS;\n      resumableState = [];\n      pushLinkImpl(resumableState, props);\n      renderState.bootstrapScripts.add(resumableState);\n    }\n    function adoptPreloadCredentials(target, preloadState) {\n      null == target.crossOrigin && (target.crossOrigin = preloadState[0]);\n      null == target.integrity && (target.integrity = preloadState[1]);\n    }\n    function getPreloadAsHeader(href, as, params) {\n      href = escapeHrefForLinkHeaderURLContext(href);\n      as = escapeStringForLinkHeaderQuotedParamValueContext(as, \"as\");\n      as = \"<\" + href + '>; rel=preload; as=\"' + as + '\"';\n      for (var paramName in params)\n        hasOwnProperty.call(params, paramName) &&\n          ((href = params[paramName]),\n          \"string\" === typeof href &&\n            (as +=\n              \"; \" +\n              paramName.toLowerCase() +\n              '=\"' +\n              escapeStringForLinkHeaderQuotedParamValueContext(\n                href,\n                paramName\n              ) +\n              '\"'));\n      return as;\n    }\n    function escapeHrefForLinkHeaderURLContext(hrefInput) {\n      checkAttributeStringCoercion(hrefInput, \"href\");\n      return (\"\" + hrefInput).replace(\n        regexForHrefInLinkHeaderURLContext,\n        escapeHrefForLinkHeaderURLContextReplacer\n      );\n    }\n    function escapeHrefForLinkHeaderURLContextReplacer(match) {\n      switch (match) {\n        case \"<\":\n          return \"%3C\";\n        case \">\":\n          return \"%3E\";\n        case \"\\n\":\n          return \"%0A\";\n        case \"\\r\":\n          return \"%0D\";\n        default:\n          throw Error(\n            \"escapeLinkHrefForHeaderContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\"\n          );\n      }\n    }\n    function escapeStringForLinkHeaderQuotedParamValueContext(value, name) {\n      willCoercionThrow(value) &&\n        (console.error(\n          \"The provided `%s` option is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          name,\n          typeName(value)\n        ),\n        testStringCoercion(value));\n      return (\"\" + value).replace(\n        regexForLinkHeaderQuotedParamValueContext,\n        escapeStringForLinkHeaderQuotedParamValueContextReplacer\n      );\n    }\n    function escapeStringForLinkHeaderQuotedParamValueContextReplacer(match) {\n      switch (match) {\n        case '\"':\n          return \"%22\";\n        case \"'\":\n          return \"%27\";\n        case \";\":\n          return \"%3B\";\n        case \",\":\n          return \"%2C\";\n        case \"\\n\":\n          return \"%0A\";\n        case \"\\r\":\n          return \"%0D\";\n        default:\n          throw Error(\n            \"escapeStringForLinkHeaderQuotedParamValueContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\"\n          );\n      }\n    }\n    function hoistStyleQueueDependency(styleQueue) {\n      this.styles.add(styleQueue);\n    }\n    function hoistStylesheetDependency(stylesheet) {\n      this.stylesheets.add(stylesheet);\n    }\n    function createRenderState(resumableState, generateStaticMarkup) {\n      var idPrefix = resumableState.idPrefix,\n        bootstrapChunks = [],\n        bootstrapScriptContent = resumableState.bootstrapScriptContent,\n        bootstrapScripts = resumableState.bootstrapScripts,\n        bootstrapModules = resumableState.bootstrapModules;\n      void 0 !== bootstrapScriptContent &&\n        bootstrapChunks.push(\n          \"<script>\",\n          escapeEntireInlineScriptContent(bootstrapScriptContent),\n          \"\\x3c/script>\"\n        );\n      idPrefix = {\n        placeholderPrefix: idPrefix + \"P:\",\n        segmentPrefix: idPrefix + \"S:\",\n        boundaryPrefix: idPrefix + \"B:\",\n        startInlineScript: \"<script>\",\n        htmlChunks: null,\n        headChunks: null,\n        externalRuntimeScript: null,\n        bootstrapChunks: bootstrapChunks,\n        importMapChunks: [],\n        onHeaders: void 0,\n        headers: null,\n        resets: {\n          font: {},\n          dns: {},\n          connect: { default: {}, anonymous: {}, credentials: {} },\n          image: {},\n          style: {}\n        },\n        charsetChunks: [],\n        viewportChunks: [],\n        hoistableChunks: [],\n        preconnects: new Set(),\n        fontPreloads: new Set(),\n        highImagePreloads: new Set(),\n        styles: new Map(),\n        bootstrapScripts: new Set(),\n        scripts: new Set(),\n        bulkPreloads: new Set(),\n        preloads: {\n          images: new Map(),\n          stylesheets: new Map(),\n          scripts: new Map(),\n          moduleScripts: new Map()\n        },\n        nonce: void 0,\n        hoistableState: null,\n        stylesToHoist: !1\n      };\n      if (void 0 !== bootstrapScripts)\n        for (\n          bootstrapScriptContent = 0;\n          bootstrapScriptContent < bootstrapScripts.length;\n          bootstrapScriptContent++\n        ) {\n          var scriptConfig = bootstrapScripts[bootstrapScriptContent],\n            src,\n            crossOrigin = void 0,\n            integrity = void 0,\n            props = {\n              rel: \"preload\",\n              as: \"script\",\n              fetchPriority: \"low\",\n              nonce: void 0\n            };\n          \"string\" === typeof scriptConfig\n            ? (props.href = src = scriptConfig)\n            : ((props.href = src = scriptConfig.src),\n              (props.integrity = integrity =\n                \"string\" === typeof scriptConfig.integrity\n                  ? scriptConfig.integrity\n                  : void 0),\n              (props.crossOrigin = crossOrigin =\n                \"string\" === typeof scriptConfig ||\n                null == scriptConfig.crossOrigin\n                  ? void 0\n                  : \"use-credentials\" === scriptConfig.crossOrigin\n                    ? \"use-credentials\"\n                    : \"\"));\n          preloadBootstrapScriptOrModule(resumableState, idPrefix, src, props);\n          bootstrapChunks.push('<script src=\"', escapeTextForBrowser(src));\n          \"string\" === typeof integrity &&\n            bootstrapChunks.push(\n              '\" integrity=\"',\n              escapeTextForBrowser(integrity)\n            );\n          \"string\" === typeof crossOrigin &&\n            bootstrapChunks.push(\n              '\" crossorigin=\"',\n              escapeTextForBrowser(crossOrigin)\n            );\n          bootstrapChunks.push('\" async=\"\">\\x3c/script>');\n        }\n      if (void 0 !== bootstrapModules)\n        for (\n          bootstrapScripts = 0;\n          bootstrapScripts < bootstrapModules.length;\n          bootstrapScripts++\n        )\n          (bootstrapScriptContent = bootstrapModules[bootstrapScripts]),\n            (crossOrigin = src = void 0),\n            (integrity = {\n              rel: \"modulepreload\",\n              fetchPriority: \"low\",\n              nonce: void 0\n            }),\n            \"string\" === typeof bootstrapScriptContent\n              ? (integrity.href = scriptConfig = bootstrapScriptContent)\n              : ((integrity.href = scriptConfig = bootstrapScriptContent.src),\n                (integrity.integrity = crossOrigin =\n                  \"string\" === typeof bootstrapScriptContent.integrity\n                    ? bootstrapScriptContent.integrity\n                    : void 0),\n                (integrity.crossOrigin = src =\n                  \"string\" === typeof bootstrapScriptContent ||\n                  null == bootstrapScriptContent.crossOrigin\n                    ? void 0\n                    : \"use-credentials\" === bootstrapScriptContent.crossOrigin\n                      ? \"use-credentials\"\n                      : \"\")),\n            preloadBootstrapScriptOrModule(\n              resumableState,\n              idPrefix,\n              scriptConfig,\n              integrity\n            ),\n            bootstrapChunks.push(\n              '<script type=\"module\" src=\"',\n              escapeTextForBrowser(scriptConfig)\n            ),\n            \"string\" === typeof crossOrigin &&\n              bootstrapChunks.push(\n                '\" integrity=\"',\n                escapeTextForBrowser(crossOrigin)\n              ),\n            \"string\" === typeof src &&\n              bootstrapChunks.push(\n                '\" crossorigin=\"',\n                escapeTextForBrowser(src)\n              ),\n            bootstrapChunks.push('\" async=\"\">\\x3c/script>');\n      return {\n        placeholderPrefix: idPrefix.placeholderPrefix,\n        segmentPrefix: idPrefix.segmentPrefix,\n        boundaryPrefix: idPrefix.boundaryPrefix,\n        startInlineScript: idPrefix.startInlineScript,\n        htmlChunks: idPrefix.htmlChunks,\n        headChunks: idPrefix.headChunks,\n        externalRuntimeScript: idPrefix.externalRuntimeScript,\n        bootstrapChunks: idPrefix.bootstrapChunks,\n        importMapChunks: idPrefix.importMapChunks,\n        onHeaders: idPrefix.onHeaders,\n        headers: idPrefix.headers,\n        resets: idPrefix.resets,\n        charsetChunks: idPrefix.charsetChunks,\n        viewportChunks: idPrefix.viewportChunks,\n        hoistableChunks: idPrefix.hoistableChunks,\n        preconnects: idPrefix.preconnects,\n        fontPreloads: idPrefix.fontPreloads,\n        highImagePreloads: idPrefix.highImagePreloads,\n        styles: idPrefix.styles,\n        bootstrapScripts: idPrefix.bootstrapScripts,\n        scripts: idPrefix.scripts,\n        bulkPreloads: idPrefix.bulkPreloads,\n        preloads: idPrefix.preloads,\n        stylesToHoist: idPrefix.stylesToHoist,\n        generateStaticMarkup: generateStaticMarkup\n      };\n    }\n    function pushTextInstance(target, text, renderState, textEmbedded) {\n      if (renderState.generateStaticMarkup)\n        return target.push(escapeTextForBrowser(text)), !1;\n      \"\" === text\n        ? (target = textEmbedded)\n        : (textEmbedded && target.push(\"\\x3c!-- --\\x3e\"),\n          target.push(escapeTextForBrowser(text)),\n          (target = !0));\n      return target;\n    }\n    function pushSegmentFinale(\n      target,\n      renderState,\n      lastPushedText,\n      textEmbedded\n    ) {\n      renderState.generateStaticMarkup ||\n        (lastPushedText && textEmbedded && target.push(\"\\x3c!-- --\\x3e\"));\n    }\n    function getComponentNameFromType(type) {\n      if (null == type) return null;\n      if (\"function\" === typeof type)\n        return type.$$typeof === REACT_CLIENT_REFERENCE\n          ? null\n          : type.displayName || type.name || null;\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n        case REACT_PORTAL_TYPE:\n          return \"Portal\";\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n      }\n      if (\"object\" === typeof type)\n        switch (\n          (\"number\" === typeof type.tag &&\n            console.error(\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n            ),\n          type.$$typeof)\n        ) {\n          case REACT_CONTEXT_TYPE:\n            return (type.displayName || \"Context\") + \".Provider\";\n          case REACT_CONSUMER_TYPE:\n            return (type._context.displayName || \"Context\") + \".Consumer\";\n          case REACT_FORWARD_REF_TYPE:\n            var innerType = type.render;\n            type = type.displayName;\n            type ||\n              ((type = innerType.displayName || innerType.name || \"\"),\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n            return type;\n          case REACT_MEMO_TYPE:\n            return (\n              (innerType = type.displayName || null),\n              null !== innerType\n                ? innerType\n                : getComponentNameFromType(type.type) || \"Memo\"\n            );\n          case REACT_LAZY_TYPE:\n            innerType = type._payload;\n            type = type._init;\n            try {\n              return getComponentNameFromType(type(innerType));\n            } catch (x) {}\n        }\n      return null;\n    }\n    function popToNearestCommonAncestor(prev, next) {\n      if (prev !== next) {\n        prev.context._currentValue2 = prev.parentValue;\n        prev = prev.parent;\n        var parentNext = next.parent;\n        if (null === prev) {\n          if (null !== parentNext)\n            throw Error(\n              \"The stacks must reach the root at the same time. This is a bug in React.\"\n            );\n        } else {\n          if (null === parentNext)\n            throw Error(\n              \"The stacks must reach the root at the same time. This is a bug in React.\"\n            );\n          popToNearestCommonAncestor(prev, parentNext);\n        }\n        next.context._currentValue2 = next.value;\n      }\n    }\n    function popAllPrevious(prev) {\n      prev.context._currentValue2 = prev.parentValue;\n      prev = prev.parent;\n      null !== prev && popAllPrevious(prev);\n    }\n    function pushAllNext(next) {\n      var parentNext = next.parent;\n      null !== parentNext && pushAllNext(parentNext);\n      next.context._currentValue2 = next.value;\n    }\n    function popPreviousToCommonLevel(prev, next) {\n      prev.context._currentValue2 = prev.parentValue;\n      prev = prev.parent;\n      if (null === prev)\n        throw Error(\n          \"The depth must equal at least at zero before reaching the root. This is a bug in React.\"\n        );\n      prev.depth === next.depth\n        ? popToNearestCommonAncestor(prev, next)\n        : popPreviousToCommonLevel(prev, next);\n    }\n    function popNextToCommonLevel(prev, next) {\n      var parentNext = next.parent;\n      if (null === parentNext)\n        throw Error(\n          \"The depth must equal at least at zero before reaching the root. This is a bug in React.\"\n        );\n      prev.depth === parentNext.depth\n        ? popToNearestCommonAncestor(prev, parentNext)\n        : popNextToCommonLevel(prev, parentNext);\n      next.context._currentValue2 = next.value;\n    }\n    function switchContext(newSnapshot) {\n      var prev = currentActiveSnapshot;\n      prev !== newSnapshot &&\n        (null === prev\n          ? pushAllNext(newSnapshot)\n          : null === newSnapshot\n            ? popAllPrevious(prev)\n            : prev.depth === newSnapshot.depth\n              ? popToNearestCommonAncestor(prev, newSnapshot)\n              : prev.depth > newSnapshot.depth\n                ? popPreviousToCommonLevel(prev, newSnapshot)\n                : popNextToCommonLevel(prev, newSnapshot),\n        (currentActiveSnapshot = newSnapshot));\n    }\n    function warnOnInvalidCallback(callback) {\n      if (null !== callback && \"function\" !== typeof callback) {\n        var key = String(callback);\n        didWarnOnInvalidCallback.has(key) ||\n          (didWarnOnInvalidCallback.add(key),\n          console.error(\n            \"Expected the last optional `callback` argument to be a function. Instead received: %s.\",\n            callback\n          ));\n      }\n    }\n    function warnNoop(publicInstance, callerName) {\n      publicInstance =\n        ((publicInstance = publicInstance.constructor) &&\n          getComponentNameFromType(publicInstance)) ||\n        \"ReactClass\";\n      var warningKey = publicInstance + \".\" + callerName;\n      didWarnAboutNoopUpdateForComponent[warningKey] ||\n        (console.error(\n          \"Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.\\n\\nPlease check the code for the %s component.\",\n          callerName,\n          publicInstance\n        ),\n        (didWarnAboutNoopUpdateForComponent[warningKey] = !0));\n    }\n    function pushTreeContext(baseContext, totalChildren, index) {\n      var baseIdWithLeadingBit = baseContext.id;\n      baseContext = baseContext.overflow;\n      var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;\n      baseIdWithLeadingBit &= ~(1 << baseLength);\n      index += 1;\n      var length = 32 - clz32(totalChildren) + baseLength;\n      if (30 < length) {\n        var numberOfOverflowBits = baseLength - (baseLength % 5);\n        length = (\n          baseIdWithLeadingBit &\n          ((1 << numberOfOverflowBits) - 1)\n        ).toString(32);\n        baseIdWithLeadingBit >>= numberOfOverflowBits;\n        baseLength -= numberOfOverflowBits;\n        return {\n          id:\n            (1 << (32 - clz32(totalChildren) + baseLength)) |\n            (index << baseLength) |\n            baseIdWithLeadingBit,\n          overflow: length + baseContext\n        };\n      }\n      return {\n        id: (1 << length) | (index << baseLength) | baseIdWithLeadingBit,\n        overflow: baseContext\n      };\n    }\n    function clz32Fallback(x) {\n      x >>>= 0;\n      return 0 === x ? 32 : (31 - ((log(x) / LN2) | 0)) | 0;\n    }\n    function noop$2() {}\n    function trackUsedThenable(thenableState, thenable, index) {\n      index = thenableState[index];\n      void 0 === index\n        ? thenableState.push(thenable)\n        : index !== thenable &&\n          (thenable.then(noop$2, noop$2), (thenable = index));\n      switch (thenable.status) {\n        case \"fulfilled\":\n          return thenable.value;\n        case \"rejected\":\n          throw thenable.reason;\n        default:\n          \"string\" === typeof thenable.status\n            ? thenable.then(noop$2, noop$2)\n            : ((thenableState = thenable),\n              (thenableState.status = \"pending\"),\n              thenableState.then(\n                function (fulfilledValue) {\n                  if (\"pending\" === thenable.status) {\n                    var fulfilledThenable = thenable;\n                    fulfilledThenable.status = \"fulfilled\";\n                    fulfilledThenable.value = fulfilledValue;\n                  }\n                },\n                function (error) {\n                  if (\"pending\" === thenable.status) {\n                    var rejectedThenable = thenable;\n                    rejectedThenable.status = \"rejected\";\n                    rejectedThenable.reason = error;\n                  }\n                }\n              ));\n          switch (thenable.status) {\n            case \"fulfilled\":\n              return thenable.value;\n            case \"rejected\":\n              throw thenable.reason;\n          }\n          suspendedThenable = thenable;\n          throw SuspenseException;\n      }\n    }\n    function getSuspendedThenable() {\n      if (null === suspendedThenable)\n        throw Error(\n          \"Expected a suspended thenable. This is a bug in React. Please file an issue.\"\n        );\n      var thenable = suspendedThenable;\n      suspendedThenable = null;\n      return thenable;\n    }\n    function is(x, y) {\n      return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);\n    }\n    function resolveCurrentlyRenderingComponent() {\n      if (null === currentlyRenderingComponent)\n        throw Error(\n          \"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\\n1. You might have mismatching versions of React and the renderer (such as React DOM)\\n2. You might be breaking the Rules of Hooks\\n3. You might have more than one copy of React in the same app\\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.\"\n        );\n      isInHookUserCodeInDev &&\n        console.error(\n          \"Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks\"\n        );\n      return currentlyRenderingComponent;\n    }\n    function createHook() {\n      if (0 < numberOfReRenders)\n        throw Error(\"Rendered more hooks than during the previous render\");\n      return { memoizedState: null, queue: null, next: null };\n    }\n    function createWorkInProgressHook() {\n      null === workInProgressHook\n        ? null === firstWorkInProgressHook\n          ? ((isReRender = !1),\n            (firstWorkInProgressHook = workInProgressHook = createHook()))\n          : ((isReRender = !0), (workInProgressHook = firstWorkInProgressHook))\n        : null === workInProgressHook.next\n          ? ((isReRender = !1),\n            (workInProgressHook = workInProgressHook.next = createHook()))\n          : ((isReRender = !0), (workInProgressHook = workInProgressHook.next));\n      return workInProgressHook;\n    }\n    function getThenableStateAfterSuspending() {\n      var state = thenableState;\n      thenableState = null;\n      return state;\n    }\n    function resetHooksState() {\n      isInHookUserCodeInDev = !1;\n      currentlyRenderingKeyPath =\n        currentlyRenderingRequest =\n        currentlyRenderingTask =\n        currentlyRenderingComponent =\n          null;\n      didScheduleRenderPhaseUpdate = !1;\n      firstWorkInProgressHook = null;\n      numberOfReRenders = 0;\n      workInProgressHook = renderPhaseUpdates = null;\n    }\n    function readContext(context) {\n      isInHookUserCodeInDev &&\n        console.error(\n          \"Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().\"\n        );\n      return context._currentValue2;\n    }\n    function basicStateReducer(state, action) {\n      return \"function\" === typeof action ? action(state) : action;\n    }\n    function useReducer(reducer, initialArg, init) {\n      reducer !== basicStateReducer && (currentHookNameInDev = \"useReducer\");\n      currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n      workInProgressHook = createWorkInProgressHook();\n      if (isReRender) {\n        init = workInProgressHook.queue;\n        initialArg = init.dispatch;\n        if (null !== renderPhaseUpdates) {\n          var firstRenderPhaseUpdate = renderPhaseUpdates.get(init);\n          if (void 0 !== firstRenderPhaseUpdate) {\n            renderPhaseUpdates.delete(init);\n            init = workInProgressHook.memoizedState;\n            do {\n              var action = firstRenderPhaseUpdate.action;\n              isInHookUserCodeInDev = !0;\n              init = reducer(init, action);\n              isInHookUserCodeInDev = !1;\n              firstRenderPhaseUpdate = firstRenderPhaseUpdate.next;\n            } while (null !== firstRenderPhaseUpdate);\n            workInProgressHook.memoizedState = init;\n            return [init, initialArg];\n          }\n        }\n        return [workInProgressHook.memoizedState, initialArg];\n      }\n      isInHookUserCodeInDev = !0;\n      reducer =\n        reducer === basicStateReducer\n          ? \"function\" === typeof initialArg\n            ? initialArg()\n            : initialArg\n          : void 0 !== init\n            ? init(initialArg)\n            : initialArg;\n      isInHookUserCodeInDev = !1;\n      workInProgressHook.memoizedState = reducer;\n      reducer = workInProgressHook.queue = { last: null, dispatch: null };\n      reducer = reducer.dispatch = dispatchAction.bind(\n        null,\n        currentlyRenderingComponent,\n        reducer\n      );\n      return [workInProgressHook.memoizedState, reducer];\n    }\n    function useMemo(nextCreate, deps) {\n      currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n      workInProgressHook = createWorkInProgressHook();\n      deps = void 0 === deps ? null : deps;\n      if (null !== workInProgressHook) {\n        var prevState = workInProgressHook.memoizedState;\n        if (null !== prevState && null !== deps) {\n          a: {\n            var JSCompiler_inline_result = prevState[1];\n            if (null === JSCompiler_inline_result)\n              console.error(\n                \"%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.\",\n                currentHookNameInDev\n              ),\n                (JSCompiler_inline_result = !1);\n            else {\n              deps.length !== JSCompiler_inline_result.length &&\n                console.error(\n                  \"The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\\n\\nPrevious: %s\\nIncoming: %s\",\n                  currentHookNameInDev,\n                  \"[\" + deps.join(\", \") + \"]\",\n                  \"[\" + JSCompiler_inline_result.join(\", \") + \"]\"\n                );\n              for (\n                var i = 0;\n                i < JSCompiler_inline_result.length && i < deps.length;\n                i++\n              )\n                if (!objectIs(deps[i], JSCompiler_inline_result[i])) {\n                  JSCompiler_inline_result = !1;\n                  break a;\n                }\n              JSCompiler_inline_result = !0;\n            }\n          }\n          if (JSCompiler_inline_result) return prevState[0];\n        }\n      }\n      isInHookUserCodeInDev = !0;\n      nextCreate = nextCreate();\n      isInHookUserCodeInDev = !1;\n      workInProgressHook.memoizedState = [nextCreate, deps];\n      return nextCreate;\n    }\n    function dispatchAction(componentIdentity, queue, action) {\n      if (25 <= numberOfReRenders)\n        throw Error(\n          \"Too many re-renders. React limits the number of renders to prevent an infinite loop.\"\n        );\n      if (componentIdentity === currentlyRenderingComponent)\n        if (\n          ((didScheduleRenderPhaseUpdate = !0),\n          (componentIdentity = { action: action, next: null }),\n          null === renderPhaseUpdates && (renderPhaseUpdates = new Map()),\n          (action = renderPhaseUpdates.get(queue)),\n          void 0 === action)\n        )\n          renderPhaseUpdates.set(queue, componentIdentity);\n        else {\n          for (queue = action; null !== queue.next; ) queue = queue.next;\n          queue.next = componentIdentity;\n        }\n    }\n    function unsupportedStartTransition() {\n      throw Error(\"startTransition cannot be called during server rendering.\");\n    }\n    function unsupportedSetOptimisticState() {\n      throw Error(\"Cannot update optimistic state while rendering.\");\n    }\n    function useActionState(action, initialState, permalink) {\n      resolveCurrentlyRenderingComponent();\n      var actionStateHookIndex = actionStateCounter++,\n        request = currentlyRenderingRequest;\n      if (\"function\" === typeof action.$$FORM_ACTION) {\n        var nextPostbackStateKey = null,\n          componentKeyPath = currentlyRenderingKeyPath;\n        request = request.formState;\n        var isSignatureEqual = action.$$IS_SIGNATURE_EQUAL;\n        if (null !== request && \"function\" === typeof isSignatureEqual) {\n          var postbackKey = request[1];\n          isSignatureEqual.call(action, request[2], request[3]) &&\n            ((nextPostbackStateKey =\n              void 0 !== permalink\n                ? \"p\" + permalink\n                : \"k\" +\n                  murmurhash3_32_gc(\n                    JSON.stringify([\n                      componentKeyPath,\n                      null,\n                      actionStateHookIndex\n                    ]),\n                    0\n                  )),\n            postbackKey === nextPostbackStateKey &&\n              ((actionStateMatchingIndex = actionStateHookIndex),\n              (initialState = request[0])));\n        }\n        var boundAction = action.bind(null, initialState);\n        action = function (payload) {\n          boundAction(payload);\n        };\n        \"function\" === typeof boundAction.$$FORM_ACTION &&\n          (action.$$FORM_ACTION = function (prefix) {\n            prefix = boundAction.$$FORM_ACTION(prefix);\n            void 0 !== permalink &&\n              (checkAttributeStringCoercion(permalink, \"target\"),\n              (permalink += \"\"),\n              (prefix.action = permalink));\n            var formData = prefix.data;\n            formData &&\n              (null === nextPostbackStateKey &&\n                (nextPostbackStateKey =\n                  void 0 !== permalink\n                    ? \"p\" + permalink\n                    : \"k\" +\n                      murmurhash3_32_gc(\n                        JSON.stringify([\n                          componentKeyPath,\n                          null,\n                          actionStateHookIndex\n                        ]),\n                        0\n                      )),\n              formData.append(\"$ACTION_KEY\", nextPostbackStateKey));\n            return prefix;\n          });\n        return [initialState, action, !1];\n      }\n      var _boundAction = action.bind(null, initialState);\n      return [\n        initialState,\n        function (payload) {\n          _boundAction(payload);\n        },\n        !1\n      ];\n    }\n    function unwrapThenable(thenable) {\n      var index = thenableIndexCounter;\n      thenableIndexCounter += 1;\n      null === thenableState && (thenableState = []);\n      return trackUsedThenable(thenableState, thenable, index);\n    }\n    function unsupportedRefresh() {\n      throw Error(\"Cache cannot be refreshed during server rendering.\");\n    }\n    function noop$1() {}\n    function disabledLog() {}\n    function disableLogs() {\n      if (0 === disabledDepth) {\n        prevLog = console.log;\n        prevInfo = console.info;\n        prevWarn = console.warn;\n        prevError = console.error;\n        prevGroup = console.group;\n        prevGroupCollapsed = console.groupCollapsed;\n        prevGroupEnd = console.groupEnd;\n        var props = {\n          configurable: !0,\n          enumerable: !0,\n          value: disabledLog,\n          writable: !0\n        };\n        Object.defineProperties(console, {\n          info: props,\n          log: props,\n          warn: props,\n          error: props,\n          group: props,\n          groupCollapsed: props,\n          groupEnd: props\n        });\n      }\n      disabledDepth++;\n    }\n    function reenableLogs() {\n      disabledDepth--;\n      if (0 === disabledDepth) {\n        var props = { configurable: !0, enumerable: !0, writable: !0 };\n        Object.defineProperties(console, {\n          log: assign({}, props, { value: prevLog }),\n          info: assign({}, props, { value: prevInfo }),\n          warn: assign({}, props, { value: prevWarn }),\n          error: assign({}, props, { value: prevError }),\n          group: assign({}, props, { value: prevGroup }),\n          groupCollapsed: assign({}, props, { value: prevGroupCollapsed }),\n          groupEnd: assign({}, props, { value: prevGroupEnd })\n        });\n      }\n      0 > disabledDepth &&\n        console.error(\n          \"disabledDepth fell below zero. This is a bug in React. Please file an issue.\"\n        );\n    }\n    function describeBuiltInComponentFrame(name) {\n      if (void 0 === prefix)\n        try {\n          throw Error();\n        } catch (x) {\n          var match = x.stack.trim().match(/\\n( *(at )?)/);\n          prefix = (match && match[1]) || \"\";\n          suffix =\n            -1 < x.stack.indexOf(\"\\n    at\")\n              ? \" (<anonymous>)\"\n              : -1 < x.stack.indexOf(\"@\")\n                ? \"@unknown:0:0\"\n                : \"\";\n        }\n      return \"\\n\" + prefix + name + suffix;\n    }\n    function describeNativeComponentFrame(fn, construct) {\n      if (!fn || reentry) return \"\";\n      var frame = componentFrameCache.get(fn);\n      if (void 0 !== frame) return frame;\n      reentry = !0;\n      frame = Error.prepareStackTrace;\n      Error.prepareStackTrace = void 0;\n      var previousDispatcher = null;\n      previousDispatcher = ReactSharedInternals.H;\n      ReactSharedInternals.H = null;\n      disableLogs();\n      try {\n        var RunInRootFrame = {\n          DetermineComponentFrameRoot: function () {\n            try {\n              if (construct) {\n                var Fake = function () {\n                  throw Error();\n                };\n                Object.defineProperty(Fake.prototype, \"props\", {\n                  set: function () {\n                    throw Error();\n                  }\n                });\n                if (\"object\" === typeof Reflect && Reflect.construct) {\n                  try {\n                    Reflect.construct(Fake, []);\n                  } catch (x) {\n                    var control = x;\n                  }\n                  Reflect.construct(fn, [], Fake);\n                } else {\n                  try {\n                    Fake.call();\n                  } catch (x$0) {\n                    control = x$0;\n                  }\n                  fn.call(Fake.prototype);\n                }\n              } else {\n                try {\n                  throw Error();\n                } catch (x$1) {\n                  control = x$1;\n                }\n                (Fake = fn()) &&\n                  \"function\" === typeof Fake.catch &&\n                  Fake.catch(function () {});\n              }\n            } catch (sample) {\n              if (sample && control && \"string\" === typeof sample.stack)\n                return [sample.stack, control.stack];\n            }\n            return [null, null];\n          }\n        };\n        RunInRootFrame.DetermineComponentFrameRoot.displayName =\n          \"DetermineComponentFrameRoot\";\n        var namePropDescriptor = Object.getOwnPropertyDescriptor(\n          RunInRootFrame.DetermineComponentFrameRoot,\n          \"name\"\n        );\n        namePropDescriptor &&\n          namePropDescriptor.configurable &&\n          Object.defineProperty(\n            RunInRootFrame.DetermineComponentFrameRoot,\n            \"name\",\n            { value: \"DetermineComponentFrameRoot\" }\n          );\n        var _RunInRootFrame$Deter =\n            RunInRootFrame.DetermineComponentFrameRoot(),\n          sampleStack = _RunInRootFrame$Deter[0],\n          controlStack = _RunInRootFrame$Deter[1];\n        if (sampleStack && controlStack) {\n          var sampleLines = sampleStack.split(\"\\n\"),\n            controlLines = controlStack.split(\"\\n\");\n          for (\n            _RunInRootFrame$Deter = namePropDescriptor = 0;\n            namePropDescriptor < sampleLines.length &&\n            !sampleLines[namePropDescriptor].includes(\n              \"DetermineComponentFrameRoot\"\n            );\n\n          )\n            namePropDescriptor++;\n          for (\n            ;\n            _RunInRootFrame$Deter < controlLines.length &&\n            !controlLines[_RunInRootFrame$Deter].includes(\n              \"DetermineComponentFrameRoot\"\n            );\n\n          )\n            _RunInRootFrame$Deter++;\n          if (\n            namePropDescriptor === sampleLines.length ||\n            _RunInRootFrame$Deter === controlLines.length\n          )\n            for (\n              namePropDescriptor = sampleLines.length - 1,\n                _RunInRootFrame$Deter = controlLines.length - 1;\n              1 <= namePropDescriptor &&\n              0 <= _RunInRootFrame$Deter &&\n              sampleLines[namePropDescriptor] !==\n                controlLines[_RunInRootFrame$Deter];\n\n            )\n              _RunInRootFrame$Deter--;\n          for (\n            ;\n            1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter;\n            namePropDescriptor--, _RunInRootFrame$Deter--\n          )\n            if (\n              sampleLines[namePropDescriptor] !==\n              controlLines[_RunInRootFrame$Deter]\n            ) {\n              if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {\n                do\n                  if (\n                    (namePropDescriptor--,\n                    _RunInRootFrame$Deter--,\n                    0 > _RunInRootFrame$Deter ||\n                      sampleLines[namePropDescriptor] !==\n                        controlLines[_RunInRootFrame$Deter])\n                  ) {\n                    var _frame =\n                      \"\\n\" +\n                      sampleLines[namePropDescriptor].replace(\n                        \" at new \",\n                        \" at \"\n                      );\n                    fn.displayName &&\n                      _frame.includes(\"<anonymous>\") &&\n                      (_frame = _frame.replace(\"<anonymous>\", fn.displayName));\n                    \"function\" === typeof fn &&\n                      componentFrameCache.set(fn, _frame);\n                    return _frame;\n                  }\n                while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);\n              }\n              break;\n            }\n        }\n      } finally {\n        (reentry = !1),\n          (ReactSharedInternals.H = previousDispatcher),\n          reenableLogs(),\n          (Error.prepareStackTrace = frame);\n      }\n      sampleLines = (sampleLines = fn ? fn.displayName || fn.name : \"\")\n        ? describeBuiltInComponentFrame(sampleLines)\n        : \"\";\n      \"function\" === typeof fn && componentFrameCache.set(fn, sampleLines);\n      return sampleLines;\n    }\n    function describeComponentStackByType(type) {\n      if (\"string\" === typeof type) return describeBuiltInComponentFrame(type);\n      if (\"function\" === typeof type)\n        return type.prototype && type.prototype.isReactComponent\n          ? ((type = describeNativeComponentFrame(type, !0)), type)\n          : describeNativeComponentFrame(type, !1);\n      if (\"object\" === typeof type && null !== type) {\n        switch (type.$$typeof) {\n          case REACT_FORWARD_REF_TYPE:\n            return describeNativeComponentFrame(type.render, !1);\n          case REACT_MEMO_TYPE:\n            return describeNativeComponentFrame(type.type, !1);\n          case REACT_LAZY_TYPE:\n            var lazyComponent = type,\n              payload = lazyComponent._payload;\n            lazyComponent = lazyComponent._init;\n            try {\n              type = lazyComponent(payload);\n            } catch (x) {\n              return describeBuiltInComponentFrame(\"Lazy\");\n            }\n            return describeComponentStackByType(type);\n        }\n        if (\"string\" === typeof type.name)\n          return (\n            (payload = type.env),\n            describeBuiltInComponentFrame(\n              type.name + (payload ? \" [\" + payload + \"]\" : \"\")\n            )\n          );\n      }\n      switch (type) {\n        case REACT_SUSPENSE_LIST_TYPE:\n          return describeBuiltInComponentFrame(\"SuspenseList\");\n        case REACT_SUSPENSE_TYPE:\n          return describeBuiltInComponentFrame(\"Suspense\");\n      }\n      return \"\";\n    }\n    function getStackByComponentStackNode(componentStack) {\n      try {\n        var info = \"\";\n        do\n          (info += describeComponentStackByType(componentStack.type)),\n            (componentStack = componentStack.parent);\n        while (componentStack);\n        return info;\n      } catch (x) {\n        return \"\\nError generating stack: \" + x.message + \"\\n\" + x.stack;\n      }\n    }\n    function defaultErrorHandler(error) {\n      if (\n        \"object\" === typeof error &&\n        null !== error &&\n        \"string\" === typeof error.environmentName\n      ) {\n        var JSCompiler_inline_result = error.environmentName;\n        error = [error].slice(0);\n        \"string\" === typeof error[0]\n          ? error.splice(\n              0,\n              1,\n              \"[%s] \" + error[0],\n              \" \" + JSCompiler_inline_result + \" \"\n            )\n          : error.splice(0, 0, \"[%s] \", \" \" + JSCompiler_inline_result + \" \");\n        error.unshift(console);\n        JSCompiler_inline_result = bind.apply(console.error, error);\n        JSCompiler_inline_result();\n      } else console.error(error);\n      return null;\n    }\n    function noop() {}\n    function RequestInstance(\n      resumableState,\n      renderState,\n      rootFormatContext,\n      progressiveChunkSize,\n      onError,\n      onAllReady,\n      onShellReady,\n      onShellError,\n      onFatalError,\n      onPostpone,\n      formState\n    ) {\n      var abortSet = new Set();\n      this.destination = null;\n      this.flushScheduled = !1;\n      this.resumableState = resumableState;\n      this.renderState = renderState;\n      this.rootFormatContext = rootFormatContext;\n      this.progressiveChunkSize =\n        void 0 === progressiveChunkSize ? 12800 : progressiveChunkSize;\n      this.status = 10;\n      this.fatalError = null;\n      this.pendingRootTasks = this.allPendingTasks = this.nextSegmentId = 0;\n      this.completedRootSegment = null;\n      this.abortableTasks = abortSet;\n      this.pingedTasks = [];\n      this.clientRenderedBoundaries = [];\n      this.completedBoundaries = [];\n      this.partialBoundaries = [];\n      this.trackedPostpones = null;\n      this.onError = void 0 === onError ? defaultErrorHandler : onError;\n      this.onPostpone = void 0 === onPostpone ? noop : onPostpone;\n      this.onAllReady = void 0 === onAllReady ? noop : onAllReady;\n      this.onShellReady = void 0 === onShellReady ? noop : onShellReady;\n      this.onShellError = void 0 === onShellError ? noop : onShellError;\n      this.onFatalError = void 0 === onFatalError ? noop : onFatalError;\n      this.formState = void 0 === formState ? null : formState;\n      this.didWarnForKey = null;\n    }\n    function createRequest(\n      children,\n      resumableState,\n      renderState,\n      rootFormatContext,\n      progressiveChunkSize,\n      onError,\n      onAllReady,\n      onShellReady,\n      onShellError,\n      onFatalError,\n      onPostpone,\n      formState\n    ) {\n      resumableState = new RequestInstance(\n        resumableState,\n        renderState,\n        rootFormatContext,\n        progressiveChunkSize,\n        onError,\n        onAllReady,\n        onShellReady,\n        onShellError,\n        onFatalError,\n        onPostpone,\n        formState\n      );\n      renderState = createPendingSegment(\n        resumableState,\n        0,\n        null,\n        rootFormatContext,\n        !1,\n        !1\n      );\n      renderState.parentFlushed = !0;\n      children = createRenderTask(\n        resumableState,\n        null,\n        children,\n        -1,\n        null,\n        renderState,\n        null,\n        resumableState.abortableTasks,\n        null,\n        rootFormatContext,\n        null,\n        emptyTreeContext,\n        null,\n        !1\n      );\n      pushComponentStack(children);\n      resumableState.pingedTasks.push(children);\n      return resumableState;\n    }\n    function pingTask(request, task) {\n      request.pingedTasks.push(task);\n      1 === request.pingedTasks.length &&\n        ((request.flushScheduled = null !== request.destination),\n        performWork(request));\n    }\n    function createSuspenseBoundary(request, fallbackAbortableTasks) {\n      return {\n        status: PENDING,\n        rootSegmentID: -1,\n        parentFlushed: !1,\n        pendingTasks: 0,\n        completedSegments: [],\n        byteSize: 0,\n        fallbackAbortableTasks: fallbackAbortableTasks,\n        errorDigest: null,\n        contentState: createHoistableState(),\n        fallbackState: createHoistableState(),\n        trackedContentKeyPath: null,\n        trackedFallbackNode: null,\n        errorMessage: null,\n        errorStack: null,\n        errorComponentStack: null\n      };\n    }\n    function createRenderTask(\n      request,\n      thenableState,\n      node,\n      childIndex,\n      blockedBoundary,\n      blockedSegment,\n      hoistableState,\n      abortSet,\n      keyPath,\n      formatContext,\n      context,\n      treeContext,\n      componentStack,\n      isFallback\n    ) {\n      request.allPendingTasks++;\n      null === blockedBoundary\n        ? request.pendingRootTasks++\n        : blockedBoundary.pendingTasks++;\n      var task = {\n        replay: null,\n        node: node,\n        childIndex: childIndex,\n        ping: function () {\n          return pingTask(request, task);\n        },\n        blockedBoundary: blockedBoundary,\n        blockedSegment: blockedSegment,\n        hoistableState: hoistableState,\n        abortSet: abortSet,\n        keyPath: keyPath,\n        formatContext: formatContext,\n        context: context,\n        treeContext: treeContext,\n        componentStack: componentStack,\n        thenableState: thenableState,\n        isFallback: isFallback\n      };\n      abortSet.add(task);\n      return task;\n    }\n    function createReplayTask(\n      request,\n      thenableState,\n      replay,\n      node,\n      childIndex,\n      blockedBoundary,\n      hoistableState,\n      abortSet,\n      keyPath,\n      formatContext,\n      context,\n      treeContext,\n      componentStack,\n      isFallback\n    ) {\n      request.allPendingTasks++;\n      null === blockedBoundary\n        ? request.pendingRootTasks++\n        : blockedBoundary.pendingTasks++;\n      replay.pendingTasks++;\n      var task = {\n        replay: replay,\n        node: node,\n        childIndex: childIndex,\n        ping: function () {\n          return pingTask(request, task);\n        },\n        blockedBoundary: blockedBoundary,\n        blockedSegment: null,\n        hoistableState: hoistableState,\n        abortSet: abortSet,\n        keyPath: keyPath,\n        formatContext: formatContext,\n        context: context,\n        treeContext: treeContext,\n        componentStack: componentStack,\n        thenableState: thenableState,\n        isFallback: isFallback\n      };\n      abortSet.add(task);\n      return task;\n    }\n    function createPendingSegment(\n      request,\n      index,\n      boundary,\n      parentFormatContext,\n      lastPushedText,\n      textEmbedded\n    ) {\n      return {\n        status: PENDING,\n        id: -1,\n        index: index,\n        parentFlushed: !1,\n        chunks: [],\n        children: [],\n        parentFormatContext: parentFormatContext,\n        boundary: boundary,\n        lastPushedText: lastPushedText,\n        textEmbedded: textEmbedded\n      };\n    }\n    function getCurrentStackInDEV() {\n      return null === currentTaskInDEV ||\n        null === currentTaskInDEV.componentStack\n        ? \"\"\n        : getStackByComponentStackNode(currentTaskInDEV.componentStack);\n    }\n    function pushServerComponentStack(task, debugInfo) {\n      if (null != debugInfo)\n        for (var i = 0; i < debugInfo.length; i++) {\n          var componentInfo = debugInfo[i];\n          \"string\" === typeof componentInfo.name &&\n            (task.componentStack = {\n              parent: task.componentStack,\n              type: componentInfo,\n              owner: componentInfo.owner,\n              stack: null\n            });\n        }\n    }\n    function pushComponentStack(task) {\n      var node = task.node;\n      if (\"object\" === typeof node && null !== node)\n        switch (node.$$typeof) {\n          case REACT_ELEMENT_TYPE:\n            var type = node.type,\n              owner = node._owner;\n            pushServerComponentStack(task, node._debugInfo);\n            task.componentStack = {\n              parent: task.componentStack,\n              type: type,\n              owner: owner,\n              stack: null\n            };\n            break;\n          case REACT_LAZY_TYPE:\n            pushServerComponentStack(task, node._debugInfo);\n            break;\n          default:\n            \"function\" === typeof node.then &&\n              pushServerComponentStack(task, node._debugInfo);\n        }\n    }\n    function getThrownInfo(node) {\n      var errorInfo = {};\n      node &&\n        Object.defineProperty(errorInfo, \"componentStack\", {\n          configurable: !0,\n          enumerable: !0,\n          get: function () {\n            var stack = getStackByComponentStackNode(node);\n            Object.defineProperty(errorInfo, \"componentStack\", {\n              value: stack\n            });\n            return stack;\n          }\n        });\n      return errorInfo;\n    }\n    function encodeErrorForBoundary(\n      boundary,\n      digest,\n      error,\n      thrownInfo,\n      wasAborted\n    ) {\n      boundary.errorDigest = digest;\n      error instanceof Error\n        ? ((digest = String(error.message)), (error = String(error.stack)))\n        : ((digest =\n            \"object\" === typeof error && null !== error\n              ? describeObjectForErrorMessage(error)\n              : String(error)),\n          (error = null));\n      wasAborted = wasAborted\n        ? \"Switched to client rendering because the server rendering aborted due to:\\n\\n\"\n        : \"Switched to client rendering because the server rendering errored:\\n\\n\";\n      boundary.errorMessage = wasAborted + digest;\n      boundary.errorStack = null !== error ? wasAborted + error : null;\n      boundary.errorComponentStack = thrownInfo.componentStack;\n    }\n    function logRecoverableError(request, error, errorInfo) {\n      request = request.onError;\n      error = request(error, errorInfo);\n      if (null != error && \"string\" !== typeof error)\n        console.error(\n          'onError returned something with a type other than \"string\". onError should return a string and may return null or undefined but must not return anything else. It received something of type \"%s\" instead',\n          typeof error\n        );\n      else return error;\n    }\n    function fatalError(request, error) {\n      var onShellError = request.onShellError,\n        onFatalError = request.onFatalError;\n      onShellError(error);\n      onFatalError(error);\n      null !== request.destination\n        ? ((request.status = CLOSED), request.destination.destroy(error))\n        : ((request.status = 13), (request.fatalError = error));\n    }\n    function renderWithHooks(\n      request,\n      task,\n      keyPath,\n      Component,\n      props,\n      secondArg\n    ) {\n      var prevThenableState = task.thenableState;\n      task.thenableState = null;\n      currentlyRenderingComponent = {};\n      currentlyRenderingTask = task;\n      currentlyRenderingRequest = request;\n      currentlyRenderingKeyPath = keyPath;\n      isInHookUserCodeInDev = !1;\n      actionStateCounter = localIdCounter = 0;\n      actionStateMatchingIndex = -1;\n      thenableIndexCounter = 0;\n      thenableState = prevThenableState;\n      for (\n        request = callComponentInDEV(Component, props, secondArg);\n        didScheduleRenderPhaseUpdate;\n\n      )\n        (didScheduleRenderPhaseUpdate = !1),\n          (actionStateCounter = localIdCounter = 0),\n          (actionStateMatchingIndex = -1),\n          (thenableIndexCounter = 0),\n          (numberOfReRenders += 1),\n          (workInProgressHook = null),\n          (request = Component(props, secondArg));\n      resetHooksState();\n      return request;\n    }\n    function finishFunctionComponent(\n      request,\n      task,\n      keyPath,\n      children,\n      hasId,\n      actionStateCount,\n      actionStateMatchingIndex\n    ) {\n      var didEmitActionStateMarkers = !1;\n      if (0 !== actionStateCount && null !== request.formState) {\n        var segment = task.blockedSegment;\n        if (null !== segment) {\n          didEmitActionStateMarkers = !0;\n          segment = segment.chunks;\n          for (var i = 0; i < actionStateCount; i++)\n            i === actionStateMatchingIndex\n              ? segment.push(\"\\x3c!--F!--\\x3e\")\n              : segment.push(\"\\x3c!--F--\\x3e\");\n        }\n      }\n      actionStateCount = task.keyPath;\n      task.keyPath = keyPath;\n      hasId\n        ? ((keyPath = task.treeContext),\n          (task.treeContext = pushTreeContext(keyPath, 1, 0)),\n          renderNode(request, task, children, -1),\n          (task.treeContext = keyPath))\n        : didEmitActionStateMarkers\n          ? renderNode(request, task, children, -1)\n          : renderNodeDestructive(request, task, children, -1);\n      task.keyPath = actionStateCount;\n    }\n    function renderElement(request, task, keyPath, type, props, ref) {\n      if (\"function\" === typeof type)\n        if (type.prototype && type.prototype.isReactComponent) {\n          var newProps = props;\n          if (\"ref\" in props) {\n            newProps = {};\n            for (var propName in props)\n              \"ref\" !== propName && (newProps[propName] = props[propName]);\n          }\n          var defaultProps = type.defaultProps;\n          if (defaultProps) {\n            newProps === props && (newProps = assign({}, newProps, props));\n            for (var _propName in defaultProps)\n              void 0 === newProps[_propName] &&\n                (newProps[_propName] = defaultProps[_propName]);\n          }\n          var resolvedProps = newProps;\n          var context = emptyContextObject,\n            contextType = type.contextType;\n          if (\n            \"contextType\" in type &&\n            null !== contextType &&\n            (void 0 === contextType ||\n              contextType.$$typeof !== REACT_CONTEXT_TYPE) &&\n            !didWarnAboutInvalidateContextType.has(type)\n          ) {\n            didWarnAboutInvalidateContextType.add(type);\n            var addendum =\n              void 0 === contextType\n                ? \" However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.\"\n                : \"object\" !== typeof contextType\n                  ? \" However, it is set to a \" + typeof contextType + \".\"\n                  : contextType.$$typeof === REACT_CONSUMER_TYPE\n                    ? \" Did you accidentally pass the Context.Consumer instead?\"\n                    : \" However, it is set to an object with keys {\" +\n                      Object.keys(contextType).join(\", \") +\n                      \"}.\";\n            console.error(\n              \"%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s\",\n              getComponentNameFromType(type) || \"Component\",\n              addendum\n            );\n          }\n          \"object\" === typeof contextType &&\n            null !== contextType &&\n            (context = contextType._currentValue2);\n          var instance = new type(resolvedProps, context);\n          if (\n            \"function\" === typeof type.getDerivedStateFromProps &&\n            (null === instance.state || void 0 === instance.state)\n          ) {\n            var componentName = getComponentNameFromType(type) || \"Component\";\n            didWarnAboutUninitializedState.has(componentName) ||\n              (didWarnAboutUninitializedState.add(componentName),\n              console.error(\n                \"`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.\",\n                componentName,\n                null === instance.state ? \"null\" : \"undefined\",\n                componentName\n              ));\n          }\n          if (\n            \"function\" === typeof type.getDerivedStateFromProps ||\n            \"function\" === typeof instance.getSnapshotBeforeUpdate\n          ) {\n            var foundWillMountName = null,\n              foundWillReceivePropsName = null,\n              foundWillUpdateName = null;\n            \"function\" === typeof instance.componentWillMount &&\n            !0 !== instance.componentWillMount.__suppressDeprecationWarning\n              ? (foundWillMountName = \"componentWillMount\")\n              : \"function\" === typeof instance.UNSAFE_componentWillMount &&\n                (foundWillMountName = \"UNSAFE_componentWillMount\");\n            \"function\" === typeof instance.componentWillReceiveProps &&\n            !0 !==\n              instance.componentWillReceiveProps.__suppressDeprecationWarning\n              ? (foundWillReceivePropsName = \"componentWillReceiveProps\")\n              : \"function\" ===\n                  typeof instance.UNSAFE_componentWillReceiveProps &&\n                (foundWillReceivePropsName =\n                  \"UNSAFE_componentWillReceiveProps\");\n            \"function\" === typeof instance.componentWillUpdate &&\n            !0 !== instance.componentWillUpdate.__suppressDeprecationWarning\n              ? (foundWillUpdateName = \"componentWillUpdate\")\n              : \"function\" === typeof instance.UNSAFE_componentWillUpdate &&\n                (foundWillUpdateName = \"UNSAFE_componentWillUpdate\");\n            if (\n              null !== foundWillMountName ||\n              null !== foundWillReceivePropsName ||\n              null !== foundWillUpdateName\n            ) {\n              var _componentName =\n                  getComponentNameFromType(type) || \"Component\",\n                newApiName =\n                  \"function\" === typeof type.getDerivedStateFromProps\n                    ? \"getDerivedStateFromProps()\"\n                    : \"getSnapshotBeforeUpdate()\";\n              didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName) ||\n                (didWarnAboutLegacyLifecyclesAndDerivedState.add(\n                  _componentName\n                ),\n                console.error(\n                  \"Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\nThe above lifecycles should be removed. Learn more about this warning here:\\nhttps://react.dev/link/unsafe-component-lifecycles\",\n                  _componentName,\n                  newApiName,\n                  null !== foundWillMountName\n                    ? \"\\n  \" + foundWillMountName\n                    : \"\",\n                  null !== foundWillReceivePropsName\n                    ? \"\\n  \" + foundWillReceivePropsName\n                    : \"\",\n                  null !== foundWillUpdateName\n                    ? \"\\n  \" + foundWillUpdateName\n                    : \"\"\n                ));\n            }\n          }\n          var name = getComponentNameFromType(type) || \"Component\";\n          instance.render ||\n            (type.prototype && \"function\" === typeof type.prototype.render\n              ? console.error(\n                  \"No `render` method found on the %s instance: did you accidentally return an object from the constructor?\",\n                  name\n                )\n              : console.error(\n                  \"No `render` method found on the %s instance: you may have forgotten to define `render`.\",\n                  name\n                ));\n          !instance.getInitialState ||\n            instance.getInitialState.isReactClassApproved ||\n            instance.state ||\n            console.error(\n              \"getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?\",\n              name\n            );\n          instance.getDefaultProps &&\n            !instance.getDefaultProps.isReactClassApproved &&\n            console.error(\n              \"getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.\",\n              name\n            );\n          instance.contextType &&\n            console.error(\n              \"contextType was defined as an instance property on %s. Use a static property to define contextType instead.\",\n              name\n            );\n          type.childContextTypes &&\n            !didWarnAboutChildContextTypes.has(type) &&\n            (didWarnAboutChildContextTypes.add(type),\n            console.error(\n              \"%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)\",\n              name\n            ));\n          type.contextTypes &&\n            !didWarnAboutContextTypes$1.has(type) &&\n            (didWarnAboutContextTypes$1.add(type),\n            console.error(\n              \"%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)\",\n              name\n            ));\n          \"function\" === typeof instance.componentShouldUpdate &&\n            console.error(\n              \"%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.\",\n              name\n            );\n          type.prototype &&\n            type.prototype.isPureReactComponent &&\n            \"undefined\" !== typeof instance.shouldComponentUpdate &&\n            console.error(\n              \"%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.\",\n              getComponentNameFromType(type) || \"A pure component\"\n            );\n          \"function\" === typeof instance.componentDidUnmount &&\n            console.error(\n              \"%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?\",\n              name\n            );\n          \"function\" === typeof instance.componentDidReceiveProps &&\n            console.error(\n              \"%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().\",\n              name\n            );\n          \"function\" === typeof instance.componentWillRecieveProps &&\n            console.error(\n              \"%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?\",\n              name\n            );\n          \"function\" === typeof instance.UNSAFE_componentWillRecieveProps &&\n            console.error(\n              \"%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?\",\n              name\n            );\n          var hasMutatedProps = instance.props !== resolvedProps;\n          void 0 !== instance.props &&\n            hasMutatedProps &&\n            console.error(\n              \"When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.\",\n              name\n            );\n          instance.defaultProps &&\n            console.error(\n              \"Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.\",\n              name,\n              name\n            );\n          \"function\" !== typeof instance.getSnapshotBeforeUpdate ||\n            \"function\" === typeof instance.componentDidUpdate ||\n            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(type) ||\n            (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(type),\n            console.error(\n              \"%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.\",\n              getComponentNameFromType(type)\n            ));\n          \"function\" === typeof instance.getDerivedStateFromProps &&\n            console.error(\n              \"%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.\",\n              name\n            );\n          \"function\" === typeof instance.getDerivedStateFromError &&\n            console.error(\n              \"%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.\",\n              name\n            );\n          \"function\" === typeof type.getSnapshotBeforeUpdate &&\n            console.error(\n              \"%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.\",\n              name\n            );\n          var state = instance.state;\n          state &&\n            (\"object\" !== typeof state || isArrayImpl(state)) &&\n            console.error(\"%s.state: must be set to an object or null\", name);\n          \"function\" === typeof instance.getChildContext &&\n            \"object\" !== typeof type.childContextTypes &&\n            console.error(\n              \"%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().\",\n              name\n            );\n          var initialState = void 0 !== instance.state ? instance.state : null;\n          instance.updater = classComponentUpdater;\n          instance.props = resolvedProps;\n          instance.state = initialState;\n          var internalInstance = { queue: [], replace: !1 };\n          instance._reactInternals = internalInstance;\n          var contextType$jscomp$0 = type.contextType;\n          instance.context =\n            \"object\" === typeof contextType$jscomp$0 &&\n            null !== contextType$jscomp$0\n              ? contextType$jscomp$0._currentValue2\n              : emptyContextObject;\n          if (instance.state === resolvedProps) {\n            var componentName$jscomp$0 =\n              getComponentNameFromType(type) || \"Component\";\n            didWarnAboutDirectlyAssigningPropsToState.has(\n              componentName$jscomp$0\n            ) ||\n              (didWarnAboutDirectlyAssigningPropsToState.add(\n                componentName$jscomp$0\n              ),\n              console.error(\n                \"%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.\",\n                componentName$jscomp$0\n              ));\n          }\n          var getDerivedStateFromProps = type.getDerivedStateFromProps;\n          if (\"function\" === typeof getDerivedStateFromProps) {\n            var partialState = getDerivedStateFromProps(\n              resolvedProps,\n              initialState\n            );\n            if (void 0 === partialState) {\n              var componentName$jscomp$1 =\n                getComponentNameFromType(type) || \"Component\";\n              didWarnAboutUndefinedDerivedState.has(componentName$jscomp$1) ||\n                (didWarnAboutUndefinedDerivedState.add(componentName$jscomp$1),\n                console.error(\n                  \"%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.\",\n                  componentName$jscomp$1\n                ));\n            }\n            var JSCompiler_inline_result =\n              null === partialState || void 0 === partialState\n                ? initialState\n                : assign({}, initialState, partialState);\n            instance.state = JSCompiler_inline_result;\n          }\n          if (\n            \"function\" !== typeof type.getDerivedStateFromProps &&\n            \"function\" !== typeof instance.getSnapshotBeforeUpdate &&\n            (\"function\" === typeof instance.UNSAFE_componentWillMount ||\n              \"function\" === typeof instance.componentWillMount)\n          ) {\n            var oldState = instance.state;\n            if (\"function\" === typeof instance.componentWillMount) {\n              if (\n                !0 !== instance.componentWillMount.__suppressDeprecationWarning\n              ) {\n                var componentName$jscomp$2 =\n                  getComponentNameFromType(type) || \"Unknown\";\n                didWarnAboutDeprecatedWillMount[componentName$jscomp$2] ||\n                  (console.warn(\n                    \"componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.\\n\\nPlease update the following components: %s\",\n                    componentName$jscomp$2\n                  ),\n                  (didWarnAboutDeprecatedWillMount[componentName$jscomp$2] =\n                    !0));\n              }\n              instance.componentWillMount();\n            }\n            \"function\" === typeof instance.UNSAFE_componentWillMount &&\n              instance.UNSAFE_componentWillMount();\n            oldState !== instance.state &&\n              (console.error(\n                \"%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.\",\n                getComponentNameFromType(type) || \"Component\"\n              ),\n              classComponentUpdater.enqueueReplaceState(\n                instance,\n                instance.state,\n                null\n              ));\n            if (\n              null !== internalInstance.queue &&\n              0 < internalInstance.queue.length\n            ) {\n              var oldQueue = internalInstance.queue,\n                oldReplace = internalInstance.replace;\n              internalInstance.queue = null;\n              internalInstance.replace = !1;\n              if (oldReplace && 1 === oldQueue.length)\n                instance.state = oldQueue[0];\n              else {\n                for (\n                  var nextState = oldReplace ? oldQueue[0] : instance.state,\n                    dontMutate = !0,\n                    i = oldReplace ? 1 : 0;\n                  i < oldQueue.length;\n                  i++\n                ) {\n                  var partial = oldQueue[i],\n                    partialState$jscomp$0 =\n                      \"function\" === typeof partial\n                        ? partial.call(\n                            instance,\n                            nextState,\n                            resolvedProps,\n                            void 0\n                          )\n                        : partial;\n                  null != partialState$jscomp$0 &&\n                    (dontMutate\n                      ? ((dontMutate = !1),\n                        (nextState = assign(\n                          {},\n                          nextState,\n                          partialState$jscomp$0\n                        )))\n                      : assign(nextState, partialState$jscomp$0));\n                }\n                instance.state = nextState;\n              }\n            } else internalInstance.queue = null;\n          }\n          var nextChildren = callRenderInDEV(instance);\n          if (12 === request.status) throw null;\n          instance.props !== resolvedProps &&\n            (didWarnAboutReassigningProps ||\n              console.error(\n                \"It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.\",\n                getComponentNameFromType(type) || \"a component\"\n              ),\n            (didWarnAboutReassigningProps = !0));\n          var prevKeyPath = task.keyPath;\n          task.keyPath = keyPath;\n          renderNodeDestructive(request, task, nextChildren, -1);\n          task.keyPath = prevKeyPath;\n        } else {\n          if (type.prototype && \"function\" === typeof type.prototype.render) {\n            var componentName$jscomp$3 =\n              getComponentNameFromType(type) || \"Unknown\";\n            didWarnAboutBadClass[componentName$jscomp$3] ||\n              (console.error(\n                \"The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.\",\n                componentName$jscomp$3,\n                componentName$jscomp$3\n              ),\n              (didWarnAboutBadClass[componentName$jscomp$3] = !0));\n          }\n          var value = renderWithHooks(\n            request,\n            task,\n            keyPath,\n            type,\n            props,\n            void 0\n          );\n          if (12 === request.status) throw null;\n          var hasId = 0 !== localIdCounter,\n            actionStateCount = actionStateCounter,\n            actionStateMatchingIndex$jscomp$0 = actionStateMatchingIndex;\n          if (type.contextTypes) {\n            var _componentName$jscomp$0 =\n              getComponentNameFromType(type) || \"Unknown\";\n            didWarnAboutContextTypes[_componentName$jscomp$0] ||\n              ((didWarnAboutContextTypes[_componentName$jscomp$0] = !0),\n              console.error(\n                \"%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)\",\n                _componentName$jscomp$0\n              ));\n          }\n          type &&\n            type.childContextTypes &&\n            console.error(\n              \"childContextTypes cannot be defined on a function component.\\n  %s.childContextTypes = ...\",\n              type.displayName || type.name || \"Component\"\n            );\n          if (\"function\" === typeof type.getDerivedStateFromProps) {\n            var _componentName2 = getComponentNameFromType(type) || \"Unknown\";\n            didWarnAboutGetDerivedStateOnFunctionComponent[_componentName2] ||\n              (console.error(\n                \"%s: Function components do not support getDerivedStateFromProps.\",\n                _componentName2\n              ),\n              (didWarnAboutGetDerivedStateOnFunctionComponent[_componentName2] =\n                !0));\n          }\n          if (\n            \"object\" === typeof type.contextType &&\n            null !== type.contextType\n          ) {\n            var _componentName3 = getComponentNameFromType(type) || \"Unknown\";\n            didWarnAboutContextTypeOnFunctionComponent[_componentName3] ||\n              (console.error(\n                \"%s: Function components do not support contextType.\",\n                _componentName3\n              ),\n              (didWarnAboutContextTypeOnFunctionComponent[_componentName3] =\n                !0));\n          }\n          finishFunctionComponent(\n            request,\n            task,\n            keyPath,\n            value,\n            hasId,\n            actionStateCount,\n            actionStateMatchingIndex$jscomp$0\n          );\n        }\n      else if (\"string\" === typeof type) {\n        var segment = task.blockedSegment;\n        if (null === segment) {\n          var children = props.children,\n            prevContext = task.formatContext,\n            prevKeyPath$jscomp$0 = task.keyPath;\n          task.formatContext = getChildFormatContext(prevContext, type, props);\n          task.keyPath = keyPath;\n          renderNode(request, task, children, -1);\n          task.formatContext = prevContext;\n          task.keyPath = prevKeyPath$jscomp$0;\n        } else {\n          var _children = pushStartInstance(\n            segment.chunks,\n            type,\n            props,\n            request.resumableState,\n            request.renderState,\n            task.hoistableState,\n            task.formatContext,\n            segment.lastPushedText,\n            task.isFallback\n          );\n          segment.lastPushedText = !1;\n          var _prevContext = task.formatContext,\n            _prevKeyPath2 = task.keyPath;\n          task.formatContext = getChildFormatContext(_prevContext, type, props);\n          task.keyPath = keyPath;\n          renderNode(request, task, _children, -1);\n          task.formatContext = _prevContext;\n          task.keyPath = _prevKeyPath2;\n          a: {\n            var target = segment.chunks,\n              resumableState = request.resumableState;\n            switch (type) {\n              case \"title\":\n              case \"style\":\n              case \"script\":\n              case \"area\":\n              case \"base\":\n              case \"br\":\n              case \"col\":\n              case \"embed\":\n              case \"hr\":\n              case \"img\":\n              case \"input\":\n              case \"keygen\":\n              case \"link\":\n              case \"meta\":\n              case \"param\":\n              case \"source\":\n              case \"track\":\n              case \"wbr\":\n                break a;\n              case \"body\":\n                if (_prevContext.insertionMode <= HTML_HTML_MODE) {\n                  resumableState.hasBody = !0;\n                  break a;\n                }\n                break;\n              case \"html\":\n                if (_prevContext.insertionMode === ROOT_HTML_MODE) {\n                  resumableState.hasHtml = !0;\n                  break a;\n                }\n            }\n            target.push(endChunkForTag(type));\n          }\n          segment.lastPushedText = !1;\n        }\n      } else {\n        switch (type) {\n          case REACT_LEGACY_HIDDEN_TYPE:\n          case REACT_DEBUG_TRACING_MODE_TYPE:\n          case REACT_STRICT_MODE_TYPE:\n          case REACT_PROFILER_TYPE:\n          case REACT_FRAGMENT_TYPE:\n            var prevKeyPath$jscomp$1 = task.keyPath;\n            task.keyPath = keyPath;\n            renderNodeDestructive(request, task, props.children, -1);\n            task.keyPath = prevKeyPath$jscomp$1;\n            return;\n          case REACT_OFFSCREEN_TYPE:\n            if (\"hidden\" !== props.mode) {\n              var prevKeyPath$jscomp$2 = task.keyPath;\n              task.keyPath = keyPath;\n              renderNodeDestructive(request, task, props.children, -1);\n              task.keyPath = prevKeyPath$jscomp$2;\n            }\n            return;\n          case REACT_SUSPENSE_LIST_TYPE:\n            var _prevKeyPath3 = task.keyPath;\n            task.keyPath = keyPath;\n            renderNodeDestructive(request, task, props.children, -1);\n            task.keyPath = _prevKeyPath3;\n            return;\n          case REACT_SCOPE_TYPE:\n            throw Error(\n              \"ReactDOMServer does not yet support scope components.\"\n            );\n          case REACT_SUSPENSE_TYPE:\n            a: if (null !== task.replay) {\n              var _prevKeyPath = task.keyPath;\n              task.keyPath = keyPath;\n              var _content = props.children;\n              try {\n                renderNode(request, task, _content, -1);\n              } finally {\n                task.keyPath = _prevKeyPath;\n              }\n            } else {\n              var prevKeyPath$jscomp$3 = task.keyPath,\n                parentBoundary = task.blockedBoundary,\n                parentHoistableState = task.hoistableState,\n                parentSegment = task.blockedSegment,\n                fallback = props.fallback,\n                content = props.children,\n                fallbackAbortSet = new Set(),\n                newBoundary = createSuspenseBoundary(request, fallbackAbortSet);\n              null !== request.trackedPostpones &&\n                (newBoundary.trackedContentKeyPath = keyPath);\n              var boundarySegment = createPendingSegment(\n                request,\n                parentSegment.chunks.length,\n                newBoundary,\n                task.formatContext,\n                !1,\n                !1\n              );\n              parentSegment.children.push(boundarySegment);\n              parentSegment.lastPushedText = !1;\n              var contentRootSegment = createPendingSegment(\n                request,\n                0,\n                null,\n                task.formatContext,\n                !1,\n                !1\n              );\n              contentRootSegment.parentFlushed = !0;\n              if (null !== request.trackedPostpones) {\n                var fallbackKeyPath = [\n                    keyPath[0],\n                    \"Suspense Fallback\",\n                    keyPath[2]\n                  ],\n                  fallbackReplayNode = [\n                    fallbackKeyPath[1],\n                    fallbackKeyPath[2],\n                    [],\n                    null\n                  ];\n                request.trackedPostpones.workingMap.set(\n                  fallbackKeyPath,\n                  fallbackReplayNode\n                );\n                newBoundary.trackedFallbackNode = fallbackReplayNode;\n                task.blockedSegment = boundarySegment;\n                task.keyPath = fallbackKeyPath;\n                boundarySegment.status = 6;\n                try {\n                  renderNode(request, task, fallback, -1),\n                    pushSegmentFinale(\n                      boundarySegment.chunks,\n                      request.renderState,\n                      boundarySegment.lastPushedText,\n                      boundarySegment.textEmbedded\n                    ),\n                    (boundarySegment.status = COMPLETED);\n                } catch (thrownValue) {\n                  throw (\n                    ((boundarySegment.status = 12 === request.status ? 3 : 4),\n                    thrownValue)\n                  );\n                } finally {\n                  (task.blockedSegment = parentSegment),\n                    (task.keyPath = prevKeyPath$jscomp$3);\n                }\n                var suspendedPrimaryTask = createRenderTask(\n                  request,\n                  null,\n                  content,\n                  -1,\n                  newBoundary,\n                  contentRootSegment,\n                  newBoundary.contentState,\n                  task.abortSet,\n                  keyPath,\n                  task.formatContext,\n                  task.context,\n                  task.treeContext,\n                  task.componentStack,\n                  task.isFallback\n                );\n                pushComponentStack(suspendedPrimaryTask);\n                request.pingedTasks.push(suspendedPrimaryTask);\n              } else {\n                task.blockedBoundary = newBoundary;\n                task.hoistableState = newBoundary.contentState;\n                task.blockedSegment = contentRootSegment;\n                task.keyPath = keyPath;\n                contentRootSegment.status = 6;\n                try {\n                  if (\n                    (renderNode(request, task, content, -1),\n                    pushSegmentFinale(\n                      contentRootSegment.chunks,\n                      request.renderState,\n                      contentRootSegment.lastPushedText,\n                      contentRootSegment.textEmbedded\n                    ),\n                    (contentRootSegment.status = COMPLETED),\n                    queueCompletedSegment(newBoundary, contentRootSegment),\n                    0 === newBoundary.pendingTasks &&\n                      newBoundary.status === PENDING)\n                  ) {\n                    newBoundary.status = COMPLETED;\n                    break a;\n                  }\n                } catch (thrownValue$2) {\n                  newBoundary.status = CLIENT_RENDERED;\n                  if (12 === request.status) {\n                    contentRootSegment.status = 3;\n                    var error = request.fatalError;\n                  } else\n                    (contentRootSegment.status = 4), (error = thrownValue$2);\n                  var thrownInfo = getThrownInfo(task.componentStack);\n                  var errorDigest = logRecoverableError(\n                    request,\n                    error,\n                    thrownInfo\n                  );\n                  encodeErrorForBoundary(\n                    newBoundary,\n                    errorDigest,\n                    error,\n                    thrownInfo,\n                    !1\n                  );\n                  untrackBoundary(request, newBoundary);\n                } finally {\n                  (task.blockedBoundary = parentBoundary),\n                    (task.hoistableState = parentHoistableState),\n                    (task.blockedSegment = parentSegment),\n                    (task.keyPath = prevKeyPath$jscomp$3);\n                }\n                var suspendedFallbackTask = createRenderTask(\n                  request,\n                  null,\n                  fallback,\n                  -1,\n                  parentBoundary,\n                  boundarySegment,\n                  newBoundary.fallbackState,\n                  fallbackAbortSet,\n                  [keyPath[0], \"Suspense Fallback\", keyPath[2]],\n                  task.formatContext,\n                  task.context,\n                  task.treeContext,\n                  task.componentStack,\n                  !0\n                );\n                pushComponentStack(suspendedFallbackTask);\n                request.pingedTasks.push(suspendedFallbackTask);\n              }\n            }\n            return;\n        }\n        if (\"object\" === typeof type && null !== type)\n          switch (type.$$typeof) {\n            case REACT_FORWARD_REF_TYPE:\n              if (\"ref\" in props) {\n                var propsWithoutRef = {};\n                for (var key in props)\n                  \"ref\" !== key && (propsWithoutRef[key] = props[key]);\n              } else propsWithoutRef = props;\n              var children$jscomp$0 = renderWithHooks(\n                request,\n                task,\n                keyPath,\n                type.render,\n                propsWithoutRef,\n                ref\n              );\n              finishFunctionComponent(\n                request,\n                task,\n                keyPath,\n                children$jscomp$0,\n                0 !== localIdCounter,\n                actionStateCounter,\n                actionStateMatchingIndex\n              );\n              return;\n            case REACT_MEMO_TYPE:\n              renderElement(request, task, keyPath, type.type, props, ref);\n              return;\n            case REACT_PROVIDER_TYPE:\n            case REACT_CONTEXT_TYPE:\n              var value$jscomp$0 = props.value,\n                children$jscomp$1 = props.children;\n              var prevSnapshot = task.context;\n              var prevKeyPath$jscomp$4 = task.keyPath;\n              var prevValue = type._currentValue2;\n              type._currentValue2 = value$jscomp$0;\n              void 0 !== type._currentRenderer2 &&\n                null !== type._currentRenderer2 &&\n                type._currentRenderer2 !== rendererSigil &&\n                console.error(\n                  \"Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.\"\n                );\n              type._currentRenderer2 = rendererSigil;\n              var prevNode = currentActiveSnapshot,\n                newNode = {\n                  parent: prevNode,\n                  depth: null === prevNode ? 0 : prevNode.depth + 1,\n                  context: type,\n                  parentValue: prevValue,\n                  value: value$jscomp$0\n                };\n              currentActiveSnapshot = newNode;\n              task.context = newNode;\n              task.keyPath = keyPath;\n              renderNodeDestructive(request, task, children$jscomp$1, -1);\n              var prevSnapshot$jscomp$0 = currentActiveSnapshot;\n              if (null === prevSnapshot$jscomp$0)\n                throw Error(\n                  \"Tried to pop a Context at the root of the app. This is a bug in React.\"\n                );\n              prevSnapshot$jscomp$0.context !== type &&\n                console.error(\n                  \"The parent context is not the expected context. This is probably a bug in React.\"\n                );\n              prevSnapshot$jscomp$0.context._currentValue2 =\n                prevSnapshot$jscomp$0.parentValue;\n              void 0 !== type._currentRenderer2 &&\n                null !== type._currentRenderer2 &&\n                type._currentRenderer2 !== rendererSigil &&\n                console.error(\n                  \"Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.\"\n                );\n              type._currentRenderer2 = rendererSigil;\n              var JSCompiler_inline_result$jscomp$0 = (currentActiveSnapshot =\n                prevSnapshot$jscomp$0.parent);\n              task.context = JSCompiler_inline_result$jscomp$0;\n              task.keyPath = prevKeyPath$jscomp$4;\n              prevSnapshot !== task.context &&\n                console.error(\n                  \"Popping the context provider did not return back to the original snapshot. This is a bug in React.\"\n                );\n              return;\n            case REACT_CONSUMER_TYPE:\n              var context$jscomp$0 = type._context,\n                render = props.children;\n              \"function\" !== typeof render &&\n                console.error(\n                  \"A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.\"\n                );\n              var newChildren = render(context$jscomp$0._currentValue2),\n                prevKeyPath$jscomp$5 = task.keyPath;\n              task.keyPath = keyPath;\n              renderNodeDestructive(request, task, newChildren, -1);\n              task.keyPath = prevKeyPath$jscomp$5;\n              return;\n            case REACT_LAZY_TYPE:\n              var Component = callLazyInitInDEV(type);\n              if (12 === request.status) throw null;\n              renderElement(request, task, keyPath, Component, props, ref);\n              return;\n          }\n        var info = \"\";\n        if (\n          void 0 === type ||\n          (\"object\" === typeof type &&\n            null !== type &&\n            0 === Object.keys(type).length)\n        )\n          info +=\n            \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\";\n        throw Error(\n          \"Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: \" +\n            ((null == type ? type : typeof type) + \".\" + info)\n        );\n      }\n    }\n    function resumeNode(request, task, segmentId, node, childIndex) {\n      var prevReplay = task.replay,\n        blockedBoundary = task.blockedBoundary,\n        resumedSegment = createPendingSegment(\n          request,\n          0,\n          null,\n          task.formatContext,\n          !1,\n          !1\n        );\n      resumedSegment.id = segmentId;\n      resumedSegment.parentFlushed = !0;\n      try {\n        (task.replay = null),\n          (task.blockedSegment = resumedSegment),\n          renderNode(request, task, node, childIndex),\n          (resumedSegment.status = COMPLETED),\n          null === blockedBoundary\n            ? (request.completedRootSegment = resumedSegment)\n            : (queueCompletedSegment(blockedBoundary, resumedSegment),\n              blockedBoundary.parentFlushed &&\n                request.partialBoundaries.push(blockedBoundary));\n      } finally {\n        (task.replay = prevReplay), (task.blockedSegment = null);\n      }\n    }\n    function renderNodeDestructive(request, task, node, childIndex) {\n      null !== task.replay && \"number\" === typeof task.replay.slots\n        ? resumeNode(request, task, task.replay.slots, node, childIndex)\n        : ((task.node = node),\n          (task.childIndex = childIndex),\n          (node = task.componentStack),\n          pushComponentStack(task),\n          retryNode(request, task),\n          (task.componentStack = node));\n    }\n    function retryNode(request, task) {\n      var node = task.node,\n        childIndex = task.childIndex;\n      if (null !== node) {\n        if (\"object\" === typeof node) {\n          switch (node.$$typeof) {\n            case REACT_ELEMENT_TYPE:\n              var type = node.type,\n                key = node.key,\n                props = node.props;\n              node = props.ref;\n              var ref = void 0 !== node ? node : null,\n                name = getComponentNameFromType(type),\n                keyOrIndex =\n                  null == key ? (-1 === childIndex ? 0 : childIndex) : key,\n                keyPath = [task.keyPath, name, keyOrIndex];\n              if (null !== task.replay) {\n                var replay = task.replay;\n                childIndex = replay.nodes;\n                for (node = 0; node < childIndex.length; node++)\n                  if (((key = childIndex[node]), keyOrIndex === key[1])) {\n                    if (4 === key.length) {\n                      if (null !== name && name !== key[0])\n                        throw Error(\n                          \"Expected the resume to render <\" +\n                            key[0] +\n                            \"> in this slot but instead it rendered <\" +\n                            name +\n                            \">. The tree doesn't match so React will fallback to client rendering.\"\n                        );\n                      var childNodes = key[2];\n                      key = key[3];\n                      name = task.node;\n                      task.replay = {\n                        nodes: childNodes,\n                        slots: key,\n                        pendingTasks: 1\n                      };\n                      try {\n                        renderElement(request, task, keyPath, type, props, ref);\n                        if (\n                          1 === task.replay.pendingTasks &&\n                          0 < task.replay.nodes.length\n                        )\n                          throw Error(\n                            \"Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.\"\n                          );\n                        task.replay.pendingTasks--;\n                      } catch (x) {\n                        if (\n                          \"object\" === typeof x &&\n                          null !== x &&\n                          (x === SuspenseException ||\n                            \"function\" === typeof x.then)\n                        )\n                          throw (\n                            (task.node === name && (task.replay = replay), x)\n                          );\n                        task.replay.pendingTasks--;\n                        props = getThrownInfo(task.componentStack);\n                        erroredReplay(\n                          request,\n                          task.blockedBoundary,\n                          x,\n                          props,\n                          childNodes,\n                          key\n                        );\n                      }\n                      task.replay = replay;\n                    } else {\n                      if (type !== REACT_SUSPENSE_TYPE)\n                        throw Error(\n                          \"Expected the resume to render <Suspense> in this slot but instead it rendered <\" +\n                            (getComponentNameFromType(type) || \"Unknown\") +\n                            \">. The tree doesn't match so React will fallback to client rendering.\"\n                        );\n                      a: {\n                        type = void 0;\n                        ref = key[5];\n                        replay = key[2];\n                        name = key[3];\n                        keyOrIndex = null === key[4] ? [] : key[4][2];\n                        key = null === key[4] ? null : key[4][3];\n                        var prevKeyPath = task.keyPath,\n                          previousReplaySet = task.replay,\n                          parentBoundary = task.blockedBoundary,\n                          parentHoistableState = task.hoistableState,\n                          content = props.children;\n                        props = props.fallback;\n                        var fallbackAbortSet = new Set(),\n                          resumedBoundary = createSuspenseBoundary(\n                            request,\n                            fallbackAbortSet\n                          );\n                        resumedBoundary.parentFlushed = !0;\n                        resumedBoundary.rootSegmentID = ref;\n                        task.blockedBoundary = resumedBoundary;\n                        task.hoistableState = resumedBoundary.contentState;\n                        task.keyPath = keyPath;\n                        task.replay = {\n                          nodes: replay,\n                          slots: name,\n                          pendingTasks: 1\n                        };\n                        try {\n                          renderNode(request, task, content, -1);\n                          if (\n                            1 === task.replay.pendingTasks &&\n                            0 < task.replay.nodes.length\n                          )\n                            throw Error(\n                              \"Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.\"\n                            );\n                          task.replay.pendingTasks--;\n                          if (\n                            0 === resumedBoundary.pendingTasks &&\n                            resumedBoundary.status === PENDING\n                          ) {\n                            resumedBoundary.status = COMPLETED;\n                            request.completedBoundaries.push(resumedBoundary);\n                            break a;\n                          }\n                        } catch (error) {\n                          (resumedBoundary.status = CLIENT_RENDERED),\n                            (childNodes = getThrownInfo(task.componentStack)),\n                            (type = logRecoverableError(\n                              request,\n                              error,\n                              childNodes\n                            )),\n                            encodeErrorForBoundary(\n                              resumedBoundary,\n                              type,\n                              error,\n                              childNodes,\n                              !1\n                            ),\n                            task.replay.pendingTasks--,\n                            request.clientRenderedBoundaries.push(\n                              resumedBoundary\n                            );\n                        } finally {\n                          (task.blockedBoundary = parentBoundary),\n                            (task.hoistableState = parentHoistableState),\n                            (task.replay = previousReplaySet),\n                            (task.keyPath = prevKeyPath);\n                        }\n                        childNodes = createReplayTask(\n                          request,\n                          null,\n                          { nodes: keyOrIndex, slots: key, pendingTasks: 0 },\n                          props,\n                          -1,\n                          parentBoundary,\n                          resumedBoundary.fallbackState,\n                          fallbackAbortSet,\n                          [keyPath[0], \"Suspense Fallback\", keyPath[2]],\n                          task.formatContext,\n                          task.context,\n                          task.treeContext,\n                          task.componentStack,\n                          !0\n                        );\n                        pushComponentStack(childNodes);\n                        request.pingedTasks.push(childNodes);\n                      }\n                    }\n                    childIndex.splice(node, 1);\n                    break;\n                  }\n              } else renderElement(request, task, keyPath, type, props, ref);\n              return;\n            case REACT_PORTAL_TYPE:\n              throw Error(\n                \"Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.\"\n              );\n            case REACT_LAZY_TYPE:\n              node = callLazyInitInDEV(node);\n              if (12 === request.status) throw null;\n              renderNodeDestructive(request, task, node, childIndex);\n              return;\n          }\n          if (isArrayImpl(node)) {\n            renderChildrenArray(request, task, node, childIndex);\n            return;\n          }\n          null === node || \"object\" !== typeof node\n            ? (props = null)\n            : ((childNodes =\n                (MAYBE_ITERATOR_SYMBOL && node[MAYBE_ITERATOR_SYMBOL]) ||\n                node[\"@@iterator\"]),\n              (props = \"function\" === typeof childNodes ? childNodes : null));\n          if (props && (childNodes = props.call(node))) {\n            if (childNodes === node) {\n              if (\n                -1 !== childIndex ||\n                null === task.componentStack ||\n                \"function\" !== typeof task.componentStack.type ||\n                \"[object GeneratorFunction]\" !==\n                  Object.prototype.toString.call(task.componentStack.type) ||\n                \"[object Generator]\" !==\n                  Object.prototype.toString.call(childNodes)\n              )\n                didWarnAboutGenerators ||\n                  console.error(\n                    \"Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items.\"\n                  ),\n                  (didWarnAboutGenerators = !0);\n            } else\n              node.entries !== props ||\n                didWarnAboutMaps ||\n                (console.error(\n                  \"Using Maps as children is not supported. Use an array of keyed ReactElements instead.\"\n                ),\n                (didWarnAboutMaps = !0));\n            node = childNodes.next();\n            if (!node.done) {\n              props = [];\n              do props.push(node.value), (node = childNodes.next());\n              while (!node.done);\n              renderChildrenArray(request, task, props, childIndex);\n            }\n            return;\n          }\n          if (\"function\" === typeof node.then)\n            return (\n              (task.thenableState = null),\n              renderNodeDestructive(\n                request,\n                task,\n                unwrapThenable(node),\n                childIndex\n              )\n            );\n          if (node.$$typeof === REACT_CONTEXT_TYPE)\n            return renderNodeDestructive(\n              request,\n              task,\n              node._currentValue2,\n              childIndex\n            );\n          childIndex = Object.prototype.toString.call(node);\n          throw Error(\n            \"Objects are not valid as a React child (found: \" +\n              (\"[object Object]\" === childIndex\n                ? \"object with keys {\" + Object.keys(node).join(\", \") + \"}\"\n                : childIndex) +\n              \"). If you meant to render a collection of children, use an array instead.\"\n          );\n        }\n        \"string\" === typeof node\n          ? ((childIndex = task.blockedSegment),\n            null !== childIndex &&\n              (childIndex.lastPushedText = pushTextInstance(\n                childIndex.chunks,\n                node,\n                request.renderState,\n                childIndex.lastPushedText\n              )))\n          : \"number\" === typeof node || \"bigint\" === typeof node\n            ? ((childIndex = task.blockedSegment),\n              null !== childIndex &&\n                (childIndex.lastPushedText = pushTextInstance(\n                  childIndex.chunks,\n                  \"\" + node,\n                  request.renderState,\n                  childIndex.lastPushedText\n                )))\n            : (\"function\" === typeof node &&\n                ((childIndex = node.displayName || node.name || \"Component\"),\n                console.error(\n                  \"Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\",\n                  childIndex,\n                  childIndex\n                )),\n              \"symbol\" === typeof node &&\n                console.error(\n                  \"Symbols are not valid as a React child.\\n  %s\",\n                  String(node)\n                ));\n      }\n    }\n    function renderChildrenArray(request$jscomp$0, task, children, childIndex) {\n      var prevKeyPath = task.keyPath,\n        previousComponentStack = task.componentStack;\n      pushServerComponentStack(task, task.node._debugInfo);\n      if (\n        -1 !== childIndex &&\n        ((task.keyPath = [task.keyPath, \"Fragment\", childIndex]),\n        null !== task.replay)\n      ) {\n        for (\n          var replay = task.replay, replayNodes = replay.nodes, j = 0;\n          j < replayNodes.length;\n          j++\n        ) {\n          var node = replayNodes[j];\n          if (node[1] === childIndex) {\n            childIndex = node[2];\n            node = node[3];\n            task.replay = { nodes: childIndex, slots: node, pendingTasks: 1 };\n            try {\n              renderChildrenArray(request$jscomp$0, task, children, -1);\n              if (\n                1 === task.replay.pendingTasks &&\n                0 < task.replay.nodes.length\n              )\n                throw Error(\n                  \"Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.\"\n                );\n              task.replay.pendingTasks--;\n            } catch (x) {\n              if (\n                \"object\" === typeof x &&\n                null !== x &&\n                (x === SuspenseException || \"function\" === typeof x.then)\n              )\n                throw x;\n              task.replay.pendingTasks--;\n              children = getThrownInfo(task.componentStack);\n              erroredReplay(\n                request$jscomp$0,\n                task.blockedBoundary,\n                x,\n                children,\n                childIndex,\n                node\n              );\n            }\n            task.replay = replay;\n            replayNodes.splice(j, 1);\n            break;\n          }\n        }\n        task.keyPath = prevKeyPath;\n        task.componentStack = previousComponentStack;\n        return;\n      }\n      replay = task.treeContext;\n      replayNodes = children.length;\n      if (\n        null !== task.replay &&\n        ((j = task.replay.slots), null !== j && \"object\" === typeof j)\n      ) {\n        for (childIndex = 0; childIndex < replayNodes; childIndex++) {\n          node = children[childIndex];\n          task.treeContext = pushTreeContext(replay, replayNodes, childIndex);\n          var resumeSegmentID = j[childIndex];\n          \"number\" === typeof resumeSegmentID\n            ? (resumeNode(\n                request$jscomp$0,\n                task,\n                resumeSegmentID,\n                node,\n                childIndex\n              ),\n              delete j[childIndex])\n            : renderNode(request$jscomp$0, task, node, childIndex);\n        }\n        task.treeContext = replay;\n        task.keyPath = prevKeyPath;\n        task.componentStack = previousComponentStack;\n        return;\n      }\n      for (j = 0; j < replayNodes; j++) {\n        childIndex = children[j];\n        var request = request$jscomp$0;\n        node = task;\n        resumeSegmentID = childIndex;\n        if (\n          null !== resumeSegmentID &&\n          \"object\" === typeof resumeSegmentID &&\n          (resumeSegmentID.$$typeof === REACT_ELEMENT_TYPE ||\n            resumeSegmentID.$$typeof === REACT_PORTAL_TYPE) &&\n          resumeSegmentID._store &&\n          ((!resumeSegmentID._store.validated && null == resumeSegmentID.key) ||\n            2 === resumeSegmentID._store.validated)\n        ) {\n          if (\"object\" !== typeof resumeSegmentID._store)\n            throw Error(\n              \"React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.\"\n            );\n          resumeSegmentID._store.validated = 1;\n          var didWarnForKey = request.didWarnForKey;\n          null == didWarnForKey &&\n            (didWarnForKey = request.didWarnForKey = new WeakSet());\n          request = node.componentStack;\n          if (null !== request && !didWarnForKey.has(request)) {\n            didWarnForKey.add(request);\n            var componentName = getComponentNameFromType(resumeSegmentID.type);\n            didWarnForKey = resumeSegmentID._owner;\n            var parentOwner = request.owner;\n            request = \"\";\n            if (parentOwner && \"undefined\" !== typeof parentOwner.type) {\n              var name = getComponentNameFromType(parentOwner.type);\n              name &&\n                (request = \"\\n\\nCheck the render method of `\" + name + \"`.\");\n            }\n            request ||\n              (componentName &&\n                (request =\n                  \"\\n\\nCheck the top-level render call using <\" +\n                  componentName +\n                  \">.\"));\n            componentName = \"\";\n            null != didWarnForKey &&\n              parentOwner !== didWarnForKey &&\n              ((parentOwner = null),\n              \"undefined\" !== typeof didWarnForKey.type\n                ? (parentOwner = getComponentNameFromType(didWarnForKey.type))\n                : \"string\" === typeof didWarnForKey.name &&\n                  (parentOwner = didWarnForKey.name),\n              parentOwner &&\n                (componentName =\n                  \" It was passed a child from \" + parentOwner + \".\"));\n            didWarnForKey = node.componentStack;\n            node.componentStack = {\n              parent: node.componentStack,\n              type: resumeSegmentID.type,\n              owner: resumeSegmentID._owner,\n              stack: null\n            };\n            console.error(\n              'Each child in a list should have a unique \"key\" prop.%s%s See https://react.dev/link/warning-keys for more information.',\n              request,\n              componentName\n            );\n            node.componentStack = didWarnForKey;\n          }\n        }\n        task.treeContext = pushTreeContext(replay, replayNodes, j);\n        renderNode(request$jscomp$0, task, childIndex, j);\n      }\n      task.treeContext = replay;\n      task.keyPath = prevKeyPath;\n      task.componentStack = previousComponentStack;\n    }\n    function untrackBoundary(request, boundary) {\n      request = request.trackedPostpones;\n      null !== request &&\n        ((boundary = boundary.trackedContentKeyPath),\n        null !== boundary &&\n          ((boundary = request.workingMap.get(boundary)),\n          void 0 !== boundary &&\n            ((boundary.length = 4), (boundary[2] = []), (boundary[3] = null))));\n    }\n    function spawnNewSuspendedReplayTask(request, task, thenableState) {\n      return createReplayTask(\n        request,\n        thenableState,\n        task.replay,\n        task.node,\n        task.childIndex,\n        task.blockedBoundary,\n        task.hoistableState,\n        task.abortSet,\n        task.keyPath,\n        task.formatContext,\n        task.context,\n        task.treeContext,\n        task.componentStack,\n        task.isFallback\n      );\n    }\n    function spawnNewSuspendedRenderTask(request, task, thenableState) {\n      var segment = task.blockedSegment,\n        newSegment = createPendingSegment(\n          request,\n          segment.chunks.length,\n          null,\n          task.formatContext,\n          segment.lastPushedText,\n          !0\n        );\n      segment.children.push(newSegment);\n      segment.lastPushedText = !1;\n      return createRenderTask(\n        request,\n        thenableState,\n        task.node,\n        task.childIndex,\n        task.blockedBoundary,\n        newSegment,\n        task.hoistableState,\n        task.abortSet,\n        task.keyPath,\n        task.formatContext,\n        task.context,\n        task.treeContext,\n        task.componentStack,\n        task.isFallback\n      );\n    }\n    function renderNode(request, task, node, childIndex) {\n      var previousFormatContext = task.formatContext,\n        previousContext = task.context,\n        previousKeyPath = task.keyPath,\n        previousTreeContext = task.treeContext,\n        previousComponentStack = task.componentStack,\n        segment = task.blockedSegment;\n      if (null === segment)\n        try {\n          return renderNodeDestructive(request, task, node, childIndex);\n        } catch (thrownValue) {\n          if (\n            (resetHooksState(),\n            (node =\n              thrownValue === SuspenseException\n                ? getSuspendedThenable()\n                : thrownValue),\n            \"object\" === typeof node && null !== node)\n          ) {\n            if (\"function\" === typeof node.then) {\n              childIndex = getThenableStateAfterSuspending();\n              request = spawnNewSuspendedReplayTask(\n                request,\n                task,\n                childIndex\n              ).ping;\n              node.then(request, request);\n              task.formatContext = previousFormatContext;\n              task.context = previousContext;\n              task.keyPath = previousKeyPath;\n              task.treeContext = previousTreeContext;\n              task.componentStack = previousComponentStack;\n              switchContext(previousContext);\n              return;\n            }\n            if (\"Maximum call stack size exceeded\" === node.message) {\n              node = getThenableStateAfterSuspending();\n              node = spawnNewSuspendedReplayTask(request, task, node);\n              request.pingedTasks.push(node);\n              task.formatContext = previousFormatContext;\n              task.context = previousContext;\n              task.keyPath = previousKeyPath;\n              task.treeContext = previousTreeContext;\n              task.componentStack = previousComponentStack;\n              switchContext(previousContext);\n              return;\n            }\n          }\n        }\n      else {\n        var childrenLength = segment.children.length,\n          chunkLength = segment.chunks.length;\n        try {\n          return renderNodeDestructive(request, task, node, childIndex);\n        } catch (thrownValue$3) {\n          if (\n            (resetHooksState(),\n            (segment.children.length = childrenLength),\n            (segment.chunks.length = chunkLength),\n            (node =\n              thrownValue$3 === SuspenseException\n                ? getSuspendedThenable()\n                : thrownValue$3),\n            \"object\" === typeof node && null !== node)\n          ) {\n            if (\"function\" === typeof node.then) {\n              childIndex = getThenableStateAfterSuspending();\n              request = spawnNewSuspendedRenderTask(\n                request,\n                task,\n                childIndex\n              ).ping;\n              node.then(request, request);\n              task.formatContext = previousFormatContext;\n              task.context = previousContext;\n              task.keyPath = previousKeyPath;\n              task.treeContext = previousTreeContext;\n              task.componentStack = previousComponentStack;\n              switchContext(previousContext);\n              return;\n            }\n            if (\"Maximum call stack size exceeded\" === node.message) {\n              node = getThenableStateAfterSuspending();\n              node = spawnNewSuspendedRenderTask(request, task, node);\n              request.pingedTasks.push(node);\n              task.formatContext = previousFormatContext;\n              task.context = previousContext;\n              task.keyPath = previousKeyPath;\n              task.treeContext = previousTreeContext;\n              task.componentStack = previousComponentStack;\n              switchContext(previousContext);\n              return;\n            }\n          }\n        }\n      }\n      task.formatContext = previousFormatContext;\n      task.context = previousContext;\n      task.keyPath = previousKeyPath;\n      task.treeContext = previousTreeContext;\n      switchContext(previousContext);\n      throw node;\n    }\n    function erroredReplay(\n      request,\n      boundary,\n      error,\n      errorInfo,\n      replayNodes,\n      resumeSlots\n    ) {\n      var errorDigest = logRecoverableError(request, error, errorInfo);\n      abortRemainingReplayNodes(\n        request,\n        boundary,\n        replayNodes,\n        resumeSlots,\n        error,\n        errorDigest,\n        errorInfo,\n        !1\n      );\n    }\n    function abortTaskSoft(task) {\n      var boundary = task.blockedBoundary;\n      task = task.blockedSegment;\n      null !== task && ((task.status = 3), finishedTask(this, boundary, task));\n    }\n    function abortRemainingReplayNodes(\n      request$jscomp$0,\n      boundary,\n      nodes,\n      slots,\n      error$jscomp$0,\n      errorDigest$jscomp$0,\n      errorInfo$jscomp$0,\n      aborted\n    ) {\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        if (4 === node.length)\n          abortRemainingReplayNodes(\n            request$jscomp$0,\n            boundary,\n            node[2],\n            node[3],\n            error$jscomp$0,\n            errorDigest$jscomp$0,\n            errorInfo$jscomp$0,\n            aborted\n          );\n        else {\n          var request = request$jscomp$0;\n          node = node[5];\n          var error = error$jscomp$0,\n            errorDigest = errorDigest$jscomp$0,\n            errorInfo = errorInfo$jscomp$0,\n            wasAborted = aborted,\n            resumedBoundary = createSuspenseBoundary(request, new Set());\n          resumedBoundary.parentFlushed = !0;\n          resumedBoundary.rootSegmentID = node;\n          resumedBoundary.status = CLIENT_RENDERED;\n          encodeErrorForBoundary(\n            resumedBoundary,\n            errorDigest,\n            error,\n            errorInfo,\n            wasAborted\n          );\n          resumedBoundary.parentFlushed &&\n            request.clientRenderedBoundaries.push(resumedBoundary);\n        }\n      }\n      nodes.length = 0;\n      if (null !== slots) {\n        if (null === boundary)\n          throw Error(\n            \"We should not have any resumable nodes in the shell. This is a bug in React.\"\n          );\n        boundary.status !== CLIENT_RENDERED &&\n          ((boundary.status = CLIENT_RENDERED),\n          encodeErrorForBoundary(\n            boundary,\n            errorDigest$jscomp$0,\n            error$jscomp$0,\n            errorInfo$jscomp$0,\n            aborted\n          ),\n          boundary.parentFlushed &&\n            request$jscomp$0.clientRenderedBoundaries.push(boundary));\n        if (\"object\" === typeof slots)\n          for (var index in slots) delete slots[index];\n      }\n    }\n    function abortTask(task, request, error) {\n      var boundary = task.blockedBoundary,\n        segment = task.blockedSegment;\n      if (null !== segment) {\n        if (6 === segment.status) return;\n        segment.status = 3;\n      }\n      segment = getThrownInfo(task.componentStack);\n      if (null === boundary) {\n        if (13 !== request.status && request.status !== CLOSED) {\n          boundary = task.replay;\n          if (null === boundary) {\n            logRecoverableError(request, error, segment);\n            fatalError(request, error);\n            return;\n          }\n          boundary.pendingTasks--;\n          0 === boundary.pendingTasks &&\n            0 < boundary.nodes.length &&\n            ((task = logRecoverableError(request, error, segment)),\n            abortRemainingReplayNodes(\n              request,\n              null,\n              boundary.nodes,\n              boundary.slots,\n              error,\n              task,\n              segment,\n              !0\n            ));\n          request.pendingRootTasks--;\n          0 === request.pendingRootTasks && completeShell(request);\n        }\n      } else\n        boundary.pendingTasks--,\n          boundary.status !== CLIENT_RENDERED &&\n            ((boundary.status = CLIENT_RENDERED),\n            (task = logRecoverableError(request, error, segment)),\n            (boundary.status = CLIENT_RENDERED),\n            encodeErrorForBoundary(boundary, task, error, segment, !0),\n            untrackBoundary(request, boundary),\n            boundary.parentFlushed &&\n              request.clientRenderedBoundaries.push(boundary)),\n          boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {\n            return abortTask(fallbackTask, request, error);\n          }),\n          boundary.fallbackAbortableTasks.clear();\n      request.allPendingTasks--;\n      0 === request.allPendingTasks && completeAll(request);\n    }\n    function safelyEmitEarlyPreloads(request, shellComplete) {\n      try {\n        var renderState = request.renderState,\n          onHeaders = renderState.onHeaders;\n        if (onHeaders) {\n          var headers = renderState.headers;\n          if (headers) {\n            renderState.headers = null;\n            var linkHeader = headers.preconnects;\n            headers.fontPreloads &&\n              (linkHeader && (linkHeader += \", \"),\n              (linkHeader += headers.fontPreloads));\n            headers.highImagePreloads &&\n              (linkHeader && (linkHeader += \", \"),\n              (linkHeader += headers.highImagePreloads));\n            if (!shellComplete) {\n              var queueIter = renderState.styles.values(),\n                queueStep = queueIter.next();\n              b: for (\n                ;\n                0 < headers.remainingCapacity && !queueStep.done;\n                queueStep = queueIter.next()\n              )\n                for (\n                  var sheetIter = queueStep.value.sheets.values(),\n                    sheetStep = sheetIter.next();\n                  0 < headers.remainingCapacity && !sheetStep.done;\n                  sheetStep = sheetIter.next()\n                ) {\n                  var sheet = sheetStep.value,\n                    props = sheet.props,\n                    key = props.href,\n                    props$jscomp$0 = sheet.props;\n                  var header = getPreloadAsHeader(\n                    props$jscomp$0.href,\n                    \"style\",\n                    {\n                      crossOrigin: props$jscomp$0.crossOrigin,\n                      integrity: props$jscomp$0.integrity,\n                      nonce: props$jscomp$0.nonce,\n                      type: props$jscomp$0.type,\n                      fetchPriority: props$jscomp$0.fetchPriority,\n                      referrerPolicy: props$jscomp$0.referrerPolicy,\n                      media: props$jscomp$0.media\n                    }\n                  );\n                  if (0 <= (headers.remainingCapacity -= header.length + 2))\n                    (renderState.resets.style[key] = PRELOAD_NO_CREDS),\n                      linkHeader && (linkHeader += \", \"),\n                      (linkHeader += header),\n                      (renderState.resets.style[key] =\n                        \"string\" === typeof props.crossOrigin ||\n                        \"string\" === typeof props.integrity\n                          ? [props.crossOrigin, props.integrity]\n                          : PRELOAD_NO_CREDS);\n                  else break b;\n                }\n            }\n            linkHeader ? onHeaders({ Link: linkHeader }) : onHeaders({});\n          }\n        }\n      } catch (error) {\n        logRecoverableError(request, error, {});\n      }\n    }\n    function completeShell(request) {\n      null === request.trackedPostpones && safelyEmitEarlyPreloads(request, !0);\n      request.onShellError = noop;\n      request = request.onShellReady;\n      request();\n    }\n    function completeAll(request) {\n      safelyEmitEarlyPreloads(\n        request,\n        null === request.trackedPostpones\n          ? !0\n          : null === request.completedRootSegment ||\n              request.completedRootSegment.status !== POSTPONED\n      );\n      request = request.onAllReady;\n      request();\n    }\n    function queueCompletedSegment(boundary, segment) {\n      if (\n        0 === segment.chunks.length &&\n        1 === segment.children.length &&\n        null === segment.children[0].boundary &&\n        -1 === segment.children[0].id\n      ) {\n        var childSegment = segment.children[0];\n        childSegment.id = segment.id;\n        childSegment.parentFlushed = !0;\n        childSegment.status === COMPLETED &&\n          queueCompletedSegment(boundary, childSegment);\n      } else boundary.completedSegments.push(segment);\n    }\n    function finishedTask(request, boundary, segment) {\n      if (null === boundary) {\n        if (null !== segment && segment.parentFlushed) {\n          if (null !== request.completedRootSegment)\n            throw Error(\n              \"There can only be one root segment. This is a bug in React.\"\n            );\n          request.completedRootSegment = segment;\n        }\n        request.pendingRootTasks--;\n        0 === request.pendingRootTasks && completeShell(request);\n      } else\n        boundary.pendingTasks--,\n          boundary.status !== CLIENT_RENDERED &&\n            (0 === boundary.pendingTasks\n              ? (boundary.status === PENDING && (boundary.status = COMPLETED),\n                null !== segment &&\n                  segment.parentFlushed &&\n                  segment.status === COMPLETED &&\n                  queueCompletedSegment(boundary, segment),\n                boundary.parentFlushed &&\n                  request.completedBoundaries.push(boundary),\n                boundary.status === COMPLETED &&\n                  (boundary.fallbackAbortableTasks.forEach(\n                    abortTaskSoft,\n                    request\n                  ),\n                  boundary.fallbackAbortableTasks.clear()))\n              : null !== segment &&\n                segment.parentFlushed &&\n                segment.status === COMPLETED &&\n                (queueCompletedSegment(boundary, segment),\n                1 === boundary.completedSegments.length &&\n                  boundary.parentFlushed &&\n                  request.partialBoundaries.push(boundary)));\n      request.allPendingTasks--;\n      0 === request.allPendingTasks && completeAll(request);\n    }\n    function performWork(request$jscomp$1) {\n      if (\n        request$jscomp$1.status !== CLOSED &&\n        13 !== request$jscomp$1.status\n      ) {\n        var prevContext = currentActiveSnapshot,\n          prevDispatcher = ReactSharedInternals.H;\n        ReactSharedInternals.H = HooksDispatcher;\n        var prevAsyncDispatcher = ReactSharedInternals.A;\n        ReactSharedInternals.A = DefaultAsyncDispatcher;\n        var prevRequest = currentRequest;\n        currentRequest = request$jscomp$1;\n        var prevGetCurrentStackImpl = ReactSharedInternals.getCurrentStack;\n        ReactSharedInternals.getCurrentStack = getCurrentStackInDEV;\n        var prevResumableState = currentResumableState;\n        currentResumableState = request$jscomp$1.resumableState;\n        try {\n          var pingedTasks = request$jscomp$1.pingedTasks,\n            i;\n          for (i = 0; i < pingedTasks.length; i++) {\n            var request = request$jscomp$1,\n              task = pingedTasks[i],\n              segment = task.blockedSegment;\n            if (null === segment) {\n              var prevTaskInDEV = void 0,\n                request$jscomp$0 = request;\n              request = task;\n              if (0 !== request.replay.pendingTasks) {\n                switchContext(request.context);\n                prevTaskInDEV = currentTaskInDEV;\n                currentTaskInDEV = request;\n                try {\n                  \"number\" === typeof request.replay.slots\n                    ? resumeNode(\n                        request$jscomp$0,\n                        request,\n                        request.replay.slots,\n                        request.node,\n                        request.childIndex\n                      )\n                    : retryNode(request$jscomp$0, request);\n                  if (\n                    1 === request.replay.pendingTasks &&\n                    0 < request.replay.nodes.length\n                  )\n                    throw Error(\n                      \"Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.\"\n                    );\n                  request.replay.pendingTasks--;\n                  request.abortSet.delete(request);\n                  finishedTask(request$jscomp$0, request.blockedBoundary, null);\n                } catch (thrownValue) {\n                  resetHooksState();\n                  var x =\n                    thrownValue === SuspenseException\n                      ? getSuspendedThenable()\n                      : thrownValue;\n                  if (\n                    \"object\" === typeof x &&\n                    null !== x &&\n                    \"function\" === typeof x.then\n                  ) {\n                    var ping = request.ping;\n                    x.then(ping, ping);\n                    request.thenableState = getThenableStateAfterSuspending();\n                  } else {\n                    request.replay.pendingTasks--;\n                    request.abortSet.delete(request);\n                    var errorInfo = getThrownInfo(request.componentStack);\n                    erroredReplay(\n                      request$jscomp$0,\n                      request.blockedBoundary,\n                      12 === request$jscomp$0.status\n                        ? request$jscomp$0.fatalError\n                        : x,\n                      errorInfo,\n                      request.replay.nodes,\n                      request.replay.slots\n                    );\n                    request$jscomp$0.pendingRootTasks--;\n                    0 === request$jscomp$0.pendingRootTasks &&\n                      completeShell(request$jscomp$0);\n                    request$jscomp$0.allPendingTasks--;\n                    0 === request$jscomp$0.allPendingTasks &&\n                      completeAll(request$jscomp$0);\n                  }\n                } finally {\n                  currentTaskInDEV = prevTaskInDEV;\n                }\n              }\n            } else {\n              request$jscomp$0 = prevTaskInDEV = void 0;\n              var task$jscomp$0 = task,\n                segment$jscomp$0 = segment;\n              if (segment$jscomp$0.status === PENDING) {\n                segment$jscomp$0.status = 6;\n                switchContext(task$jscomp$0.context);\n                request$jscomp$0 = currentTaskInDEV;\n                currentTaskInDEV = task$jscomp$0;\n                var childrenLength = segment$jscomp$0.children.length,\n                  chunkLength = segment$jscomp$0.chunks.length;\n                try {\n                  retryNode(request, task$jscomp$0),\n                    pushSegmentFinale(\n                      segment$jscomp$0.chunks,\n                      request.renderState,\n                      segment$jscomp$0.lastPushedText,\n                      segment$jscomp$0.textEmbedded\n                    ),\n                    task$jscomp$0.abortSet.delete(task$jscomp$0),\n                    (segment$jscomp$0.status = COMPLETED),\n                    finishedTask(\n                      request,\n                      task$jscomp$0.blockedBoundary,\n                      segment$jscomp$0\n                    );\n                } catch (thrownValue) {\n                  resetHooksState();\n                  segment$jscomp$0.children.length = childrenLength;\n                  segment$jscomp$0.chunks.length = chunkLength;\n                  var x$jscomp$0 =\n                    thrownValue === SuspenseException\n                      ? getSuspendedThenable()\n                      : 12 === request.status\n                        ? request.fatalError\n                        : thrownValue;\n                  if (\n                    \"object\" === typeof x$jscomp$0 &&\n                    null !== x$jscomp$0 &&\n                    \"function\" === typeof x$jscomp$0.then\n                  ) {\n                    segment$jscomp$0.status = PENDING;\n                    task$jscomp$0.thenableState =\n                      getThenableStateAfterSuspending();\n                    var ping$jscomp$0 = task$jscomp$0.ping;\n                    x$jscomp$0.then(ping$jscomp$0, ping$jscomp$0);\n                  } else {\n                    var errorInfo$jscomp$0 = getThrownInfo(\n                      task$jscomp$0.componentStack\n                    );\n                    task$jscomp$0.abortSet.delete(task$jscomp$0);\n                    segment$jscomp$0.status = 4;\n                    var boundary = task$jscomp$0.blockedBoundary;\n                    prevTaskInDEV = logRecoverableError(\n                      request,\n                      x$jscomp$0,\n                      errorInfo$jscomp$0\n                    );\n                    null === boundary\n                      ? fatalError(request, x$jscomp$0)\n                      : (boundary.pendingTasks--,\n                        boundary.status !== CLIENT_RENDERED &&\n                          ((boundary.status = CLIENT_RENDERED),\n                          encodeErrorForBoundary(\n                            boundary,\n                            prevTaskInDEV,\n                            x$jscomp$0,\n                            errorInfo$jscomp$0,\n                            !1\n                          ),\n                          untrackBoundary(request, boundary),\n                          boundary.parentFlushed &&\n                            request.clientRenderedBoundaries.push(boundary)));\n                    request.allPendingTasks--;\n                    0 === request.allPendingTasks && completeAll(request);\n                  }\n                } finally {\n                  currentTaskInDEV = request$jscomp$0;\n                }\n              }\n            }\n          }\n          pingedTasks.splice(0, i);\n          null !== request$jscomp$1.destination &&\n            flushCompletedQueues(\n              request$jscomp$1,\n              request$jscomp$1.destination\n            );\n        } catch (error) {\n          logRecoverableError(request$jscomp$1, error, {}),\n            fatalError(request$jscomp$1, error);\n        } finally {\n          (currentResumableState = prevResumableState),\n            (ReactSharedInternals.H = prevDispatcher),\n            (ReactSharedInternals.A = prevAsyncDispatcher),\n            (ReactSharedInternals.getCurrentStack = prevGetCurrentStackImpl),\n            prevDispatcher === HooksDispatcher && switchContext(prevContext),\n            (currentRequest = prevRequest);\n        }\n      }\n    }\n    function flushSubtree(request, destination, segment, hoistableState) {\n      segment.parentFlushed = !0;\n      switch (segment.status) {\n        case PENDING:\n          segment.id = request.nextSegmentId++;\n        case POSTPONED:\n          return (\n            (hoistableState = segment.id),\n            (segment.lastPushedText = !1),\n            (segment.textEmbedded = !1),\n            (request = request.renderState),\n            destination.push(placeholder1),\n            destination.push(request.placeholderPrefix),\n            (request = hoistableState.toString(16)),\n            destination.push(request),\n            destination.push(placeholder2)\n          );\n        case COMPLETED:\n          segment.status = FLUSHED;\n          var r = !0,\n            chunks = segment.chunks,\n            chunkIdx = 0;\n          segment = segment.children;\n          for (var childIdx = 0; childIdx < segment.length; childIdx++) {\n            for (r = segment[childIdx]; chunkIdx < r.index; chunkIdx++)\n              destination.push(chunks[chunkIdx]);\n            r = flushSegment(request, destination, r, hoistableState);\n          }\n          for (; chunkIdx < chunks.length - 1; chunkIdx++)\n            destination.push(chunks[chunkIdx]);\n          chunkIdx < chunks.length && (r = destination.push(chunks[chunkIdx]));\n          return r;\n        default:\n          throw Error(\n            \"Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.\"\n          );\n      }\n    }\n    function flushSegment(request, destination, segment, hoistableState) {\n      var boundary = segment.boundary;\n      if (null === boundary)\n        return flushSubtree(request, destination, segment, hoistableState);\n      boundary.parentFlushed = !0;\n      if (boundary.status === CLIENT_RENDERED) {\n        if (!request.renderState.generateStaticMarkup) {\n          var errorDigest = boundary.errorDigest,\n            errorMessage = boundary.errorMessage,\n            errorStack = boundary.errorStack;\n          boundary = boundary.errorComponentStack;\n          destination.push(startClientRenderedSuspenseBoundary);\n          destination.push(clientRenderedSuspenseBoundaryError1);\n          errorDigest &&\n            (destination.push(clientRenderedSuspenseBoundaryError1A),\n            (errorDigest = escapeTextForBrowser(errorDigest)),\n            destination.push(errorDigest),\n            destination.push(\n              clientRenderedSuspenseBoundaryErrorAttrInterstitial\n            ));\n          errorMessage &&\n            (destination.push(clientRenderedSuspenseBoundaryError1B),\n            (errorMessage = escapeTextForBrowser(errorMessage)),\n            destination.push(errorMessage),\n            destination.push(\n              clientRenderedSuspenseBoundaryErrorAttrInterstitial\n            ));\n          errorStack &&\n            (destination.push(clientRenderedSuspenseBoundaryError1C),\n            (errorStack = escapeTextForBrowser(errorStack)),\n            destination.push(errorStack),\n            destination.push(\n              clientRenderedSuspenseBoundaryErrorAttrInterstitial\n            ));\n          boundary &&\n            (destination.push(clientRenderedSuspenseBoundaryError1D),\n            (errorStack = escapeTextForBrowser(boundary)),\n            destination.push(errorStack),\n            destination.push(\n              clientRenderedSuspenseBoundaryErrorAttrInterstitial\n            ));\n          destination.push(clientRenderedSuspenseBoundaryError2);\n        }\n        flushSubtree(request, destination, segment, hoistableState);\n        request = request.renderState.generateStaticMarkup\n          ? !0\n          : destination.push(endSuspenseBoundary);\n        return request;\n      }\n      if (boundary.status !== COMPLETED)\n        return (\n          boundary.status === PENDING &&\n            (boundary.rootSegmentID = request.nextSegmentId++),\n          0 < boundary.completedSegments.length &&\n            request.partialBoundaries.push(boundary),\n          writeStartPendingSuspenseBoundary(\n            destination,\n            request.renderState,\n            boundary.rootSegmentID\n          ),\n          hoistableState &&\n            ((errorStack = boundary.fallbackState),\n            errorStack.styles.forEach(\n              hoistStyleQueueDependency,\n              hoistableState\n            ),\n            errorStack.stylesheets.forEach(\n              hoistStylesheetDependency,\n              hoistableState\n            )),\n          flushSubtree(request, destination, segment, hoistableState),\n          destination.push(endSuspenseBoundary)\n        );\n      if (boundary.byteSize > request.progressiveChunkSize)\n        return (\n          (boundary.rootSegmentID = request.nextSegmentId++),\n          request.completedBoundaries.push(boundary),\n          writeStartPendingSuspenseBoundary(\n            destination,\n            request.renderState,\n            boundary.rootSegmentID\n          ),\n          flushSubtree(request, destination, segment, hoistableState),\n          destination.push(endSuspenseBoundary)\n        );\n      hoistableState &&\n        ((segment = boundary.contentState),\n        segment.styles.forEach(hoistStyleQueueDependency, hoistableState),\n        segment.stylesheets.forEach(hoistStylesheetDependency, hoistableState));\n      request.renderState.generateStaticMarkup ||\n        destination.push(startCompletedSuspenseBoundary);\n      segment = boundary.completedSegments;\n      if (1 !== segment.length)\n        throw Error(\n          \"A previously unvisited boundary must have exactly one root segment. This is a bug in React.\"\n        );\n      flushSegment(request, destination, segment[0], hoistableState);\n      request = request.renderState.generateStaticMarkup\n        ? !0\n        : destination.push(endSuspenseBoundary);\n      return request;\n    }\n    function flushSegmentContainer(\n      request,\n      destination,\n      segment,\n      hoistableState\n    ) {\n      writeStartSegment(\n        destination,\n        request.renderState,\n        segment.parentFormatContext,\n        segment.id\n      );\n      flushSegment(request, destination, segment, hoistableState);\n      return writeEndSegment(destination, segment.parentFormatContext);\n    }\n    function flushCompletedBoundary(request, destination, boundary) {\n      for (\n        var completedSegments = boundary.completedSegments, i = 0;\n        i < completedSegments.length;\n        i++\n      )\n        flushPartiallyCompletedSegment(\n          request,\n          destination,\n          boundary,\n          completedSegments[i]\n        );\n      completedSegments.length = 0;\n      writeHoistablesForBoundary(\n        destination,\n        boundary.contentState,\n        request.renderState\n      );\n      completedSegments = request.resumableState;\n      request = request.renderState;\n      i = boundary.rootSegmentID;\n      boundary = boundary.contentState;\n      var requiresStyleInsertion = request.stylesToHoist;\n      request.stylesToHoist = !1;\n      destination.push(request.startInlineScript);\n      requiresStyleInsertion\n        ? (completedSegments.instructions & SentCompleteBoundaryFunction) ===\n          NothingSent\n          ? ((completedSegments.instructions =\n              completedSegments.instructions |\n              SentStyleInsertionFunction |\n              SentCompleteBoundaryFunction),\n            destination.push(completeBoundaryWithStylesScript1FullBoth))\n          : (completedSegments.instructions & SentStyleInsertionFunction) ===\n              NothingSent\n            ? ((completedSegments.instructions |= SentStyleInsertionFunction),\n              destination.push(completeBoundaryWithStylesScript1FullPartial))\n            : destination.push(completeBoundaryWithStylesScript1Partial)\n        : (completedSegments.instructions & SentCompleteBoundaryFunction) ===\n            NothingSent\n          ? ((completedSegments.instructions |= SentCompleteBoundaryFunction),\n            destination.push(completeBoundaryScript1Full))\n          : destination.push(completeBoundaryScript1Partial);\n      completedSegments = i.toString(16);\n      destination.push(request.boundaryPrefix);\n      destination.push(completedSegments);\n      destination.push(completeBoundaryScript2);\n      destination.push(request.segmentPrefix);\n      destination.push(completedSegments);\n      requiresStyleInsertion\n        ? (destination.push(completeBoundaryScript3a),\n          writeStyleResourceDependenciesInJS(destination, boundary))\n        : destination.push(completeBoundaryScript3b);\n      boundary = destination.push(completeBoundaryScriptEnd);\n      return writeBootstrap(destination, request) && boundary;\n    }\n    function flushPartiallyCompletedSegment(\n      request,\n      destination,\n      boundary,\n      segment\n    ) {\n      if (segment.status === FLUSHED) return !0;\n      var hoistableState = boundary.contentState,\n        segmentID = segment.id;\n      if (-1 === segmentID) {\n        if (-1 === (segment.id = boundary.rootSegmentID))\n          throw Error(\n            \"A root segment ID must have been assigned by now. This is a bug in React.\"\n          );\n        return flushSegmentContainer(\n          request,\n          destination,\n          segment,\n          hoistableState\n        );\n      }\n      if (segmentID === boundary.rootSegmentID)\n        return flushSegmentContainer(\n          request,\n          destination,\n          segment,\n          hoistableState\n        );\n      flushSegmentContainer(request, destination, segment, hoistableState);\n      boundary = request.resumableState;\n      request = request.renderState;\n      destination.push(request.startInlineScript);\n      (boundary.instructions & SentCompleteSegmentFunction) === NothingSent\n        ? ((boundary.instructions |= SentCompleteSegmentFunction),\n          destination.push(completeSegmentScript1Full))\n        : destination.push(completeSegmentScript1Partial);\n      destination.push(request.segmentPrefix);\n      segmentID = segmentID.toString(16);\n      destination.push(segmentID);\n      destination.push(completeSegmentScript2);\n      destination.push(request.placeholderPrefix);\n      destination.push(segmentID);\n      destination = destination.push(completeSegmentScriptEnd);\n      return destination;\n    }\n    function flushCompletedQueues(request, destination) {\n      try {\n        if (!(0 < request.pendingRootTasks)) {\n          var i,\n            completedRootSegment = request.completedRootSegment;\n          if (null !== completedRootSegment) {\n            if (completedRootSegment.status === POSTPONED) return;\n            var renderState = request.renderState,\n              htmlChunks = renderState.htmlChunks,\n              headChunks = renderState.headChunks,\n              i$jscomp$0;\n            if (htmlChunks) {\n              for (i$jscomp$0 = 0; i$jscomp$0 < htmlChunks.length; i$jscomp$0++)\n                destination.push(htmlChunks[i$jscomp$0]);\n              if (headChunks)\n                for (\n                  i$jscomp$0 = 0;\n                  i$jscomp$0 < headChunks.length;\n                  i$jscomp$0++\n                )\n                  destination.push(headChunks[i$jscomp$0]);\n              else {\n                var chunk = startChunkForTag(\"head\");\n                destination.push(chunk);\n                destination.push(endOfStartTag);\n              }\n            } else if (headChunks)\n              for (i$jscomp$0 = 0; i$jscomp$0 < headChunks.length; i$jscomp$0++)\n                destination.push(headChunks[i$jscomp$0]);\n            var charsetChunks = renderState.charsetChunks;\n            for (\n              i$jscomp$0 = 0;\n              i$jscomp$0 < charsetChunks.length;\n              i$jscomp$0++\n            )\n              destination.push(charsetChunks[i$jscomp$0]);\n            charsetChunks.length = 0;\n            renderState.preconnects.forEach(flushResource, destination);\n            renderState.preconnects.clear();\n            var viewportChunks = renderState.viewportChunks;\n            for (\n              i$jscomp$0 = 0;\n              i$jscomp$0 < viewportChunks.length;\n              i$jscomp$0++\n            )\n              destination.push(viewportChunks[i$jscomp$0]);\n            viewportChunks.length = 0;\n            renderState.fontPreloads.forEach(flushResource, destination);\n            renderState.fontPreloads.clear();\n            renderState.highImagePreloads.forEach(flushResource, destination);\n            renderState.highImagePreloads.clear();\n            renderState.styles.forEach(flushStylesInPreamble, destination);\n            var importMapChunks = renderState.importMapChunks;\n            for (\n              i$jscomp$0 = 0;\n              i$jscomp$0 < importMapChunks.length;\n              i$jscomp$0++\n            )\n              destination.push(importMapChunks[i$jscomp$0]);\n            importMapChunks.length = 0;\n            renderState.bootstrapScripts.forEach(flushResource, destination);\n            renderState.scripts.forEach(flushResource, destination);\n            renderState.scripts.clear();\n            renderState.bulkPreloads.forEach(flushResource, destination);\n            renderState.bulkPreloads.clear();\n            var hoistableChunks = renderState.hoistableChunks;\n            for (\n              i$jscomp$0 = 0;\n              i$jscomp$0 < hoistableChunks.length;\n              i$jscomp$0++\n            )\n              destination.push(hoistableChunks[i$jscomp$0]);\n            hoistableChunks.length = 0;\n            if (htmlChunks && null === headChunks) {\n              var chunk$jscomp$0 = endChunkForTag(\"head\");\n              destination.push(chunk$jscomp$0);\n            }\n            flushSegment(request, destination, completedRootSegment, null);\n            request.completedRootSegment = null;\n            writeBootstrap(destination, request.renderState);\n          }\n          var renderState$jscomp$0 = request.renderState;\n          completedRootSegment = 0;\n          var viewportChunks$jscomp$0 = renderState$jscomp$0.viewportChunks;\n          for (\n            completedRootSegment = 0;\n            completedRootSegment < viewportChunks$jscomp$0.length;\n            completedRootSegment++\n          )\n            destination.push(viewportChunks$jscomp$0[completedRootSegment]);\n          viewportChunks$jscomp$0.length = 0;\n          renderState$jscomp$0.preconnects.forEach(flushResource, destination);\n          renderState$jscomp$0.preconnects.clear();\n          renderState$jscomp$0.fontPreloads.forEach(flushResource, destination);\n          renderState$jscomp$0.fontPreloads.clear();\n          renderState$jscomp$0.highImagePreloads.forEach(\n            flushResource,\n            destination\n          );\n          renderState$jscomp$0.highImagePreloads.clear();\n          renderState$jscomp$0.styles.forEach(preloadLateStyles, destination);\n          renderState$jscomp$0.scripts.forEach(flushResource, destination);\n          renderState$jscomp$0.scripts.clear();\n          renderState$jscomp$0.bulkPreloads.forEach(flushResource, destination);\n          renderState$jscomp$0.bulkPreloads.clear();\n          var hoistableChunks$jscomp$0 = renderState$jscomp$0.hoistableChunks;\n          for (\n            completedRootSegment = 0;\n            completedRootSegment < hoistableChunks$jscomp$0.length;\n            completedRootSegment++\n          )\n            destination.push(hoistableChunks$jscomp$0[completedRootSegment]);\n          hoistableChunks$jscomp$0.length = 0;\n          var clientRenderedBoundaries = request.clientRenderedBoundaries;\n          for (i = 0; i < clientRenderedBoundaries.length; i++) {\n            var boundary = clientRenderedBoundaries[i];\n            renderState$jscomp$0 = destination;\n            var resumableState = request.resumableState,\n              renderState$jscomp$1 = request.renderState,\n              id = boundary.rootSegmentID,\n              errorDigest = boundary.errorDigest,\n              errorMessage = boundary.errorMessage,\n              errorStack = boundary.errorStack,\n              errorComponentStack = boundary.errorComponentStack;\n            renderState$jscomp$0.push(renderState$jscomp$1.startInlineScript);\n            (resumableState.instructions & SentClientRenderFunction) ===\n            NothingSent\n              ? ((resumableState.instructions |= SentClientRenderFunction),\n                renderState$jscomp$0.push(clientRenderScript1Full))\n              : renderState$jscomp$0.push(clientRenderScript1Partial);\n            renderState$jscomp$0.push(renderState$jscomp$1.boundaryPrefix);\n            var chunk$jscomp$1 = id.toString(16);\n            renderState$jscomp$0.push(chunk$jscomp$1);\n            renderState$jscomp$0.push(clientRenderScript1A);\n            if (\n              errorDigest ||\n              errorMessage ||\n              errorStack ||\n              errorComponentStack\n            ) {\n              renderState$jscomp$0.push(clientRenderErrorScriptArgInterstitial);\n              var chunk$jscomp$2 = escapeJSStringsForInstructionScripts(\n                errorDigest || \"\"\n              );\n              renderState$jscomp$0.push(chunk$jscomp$2);\n            }\n            if (errorMessage || errorStack || errorComponentStack) {\n              renderState$jscomp$0.push(clientRenderErrorScriptArgInterstitial);\n              var chunk$jscomp$3 = escapeJSStringsForInstructionScripts(\n                errorMessage || \"\"\n              );\n              renderState$jscomp$0.push(chunk$jscomp$3);\n            }\n            if (errorStack || errorComponentStack) {\n              renderState$jscomp$0.push(clientRenderErrorScriptArgInterstitial);\n              var chunk$jscomp$4 = escapeJSStringsForInstructionScripts(\n                errorStack || \"\"\n              );\n              renderState$jscomp$0.push(chunk$jscomp$4);\n            }\n            if (errorComponentStack) {\n              renderState$jscomp$0.push(clientRenderErrorScriptArgInterstitial);\n              var chunk$jscomp$5 =\n                escapeJSStringsForInstructionScripts(errorComponentStack);\n              renderState$jscomp$0.push(chunk$jscomp$5);\n            }\n            var JSCompiler_inline_result = renderState$jscomp$0.push(\n              clientRenderScriptEnd\n            );\n            if (!JSCompiler_inline_result) {\n              request.destination = null;\n              i++;\n              clientRenderedBoundaries.splice(0, i);\n              return;\n            }\n          }\n          clientRenderedBoundaries.splice(0, i);\n          var completedBoundaries = request.completedBoundaries;\n          for (i = 0; i < completedBoundaries.length; i++)\n            if (\n              !flushCompletedBoundary(\n                request,\n                destination,\n                completedBoundaries[i]\n              )\n            ) {\n              request.destination = null;\n              i++;\n              completedBoundaries.splice(0, i);\n              return;\n            }\n          completedBoundaries.splice(0, i);\n          var partialBoundaries = request.partialBoundaries;\n          for (i = 0; i < partialBoundaries.length; i++) {\n            a: {\n              clientRenderedBoundaries = request;\n              boundary = destination;\n              var boundary$jscomp$0 = partialBoundaries[i],\n                completedSegments = boundary$jscomp$0.completedSegments;\n              for (\n                JSCompiler_inline_result = 0;\n                JSCompiler_inline_result < completedSegments.length;\n                JSCompiler_inline_result++\n              )\n                if (\n                  !flushPartiallyCompletedSegment(\n                    clientRenderedBoundaries,\n                    boundary,\n                    boundary$jscomp$0,\n                    completedSegments[JSCompiler_inline_result]\n                  )\n                ) {\n                  JSCompiler_inline_result++;\n                  completedSegments.splice(0, JSCompiler_inline_result);\n                  var JSCompiler_inline_result$jscomp$0 = !1;\n                  break a;\n                }\n              completedSegments.splice(0, JSCompiler_inline_result);\n              JSCompiler_inline_result$jscomp$0 = writeHoistablesForBoundary(\n                boundary,\n                boundary$jscomp$0.contentState,\n                clientRenderedBoundaries.renderState\n              );\n            }\n            if (!JSCompiler_inline_result$jscomp$0) {\n              request.destination = null;\n              i++;\n              partialBoundaries.splice(0, i);\n              return;\n            }\n          }\n          partialBoundaries.splice(0, i);\n          var largeBoundaries = request.completedBoundaries;\n          for (i = 0; i < largeBoundaries.length; i++)\n            if (\n              !flushCompletedBoundary(request, destination, largeBoundaries[i])\n            ) {\n              request.destination = null;\n              i++;\n              largeBoundaries.splice(0, i);\n              return;\n            }\n          largeBoundaries.splice(0, i);\n        }\n      } finally {\n        0 === request.allPendingTasks &&\n          0 === request.pingedTasks.length &&\n          0 === request.clientRenderedBoundaries.length &&\n          0 === request.completedBoundaries.length &&\n          ((request.flushScheduled = !1),\n          (i = request.resumableState),\n          i.hasBody &&\n            ((partialBoundaries = endChunkForTag(\"body\")),\n            destination.push(partialBoundaries)),\n          i.hasHtml && ((i = endChunkForTag(\"html\")), destination.push(i)),\n          0 !== request.abortableTasks.size &&\n            console.error(\n              \"There was still abortable task at the root when we closed. This is a bug in React.\"\n            ),\n          (request.status = CLOSED),\n          destination.push(null),\n          (request.destination = null));\n      }\n    }\n    function startWork(request) {\n      request.flushScheduled = null !== request.destination;\n      performWork(request);\n      10 === request.status && (request.status = 11);\n      null === request.trackedPostpones &&\n        safelyEmitEarlyPreloads(request, 0 === request.pendingRootTasks);\n    }\n    function enqueueFlush(request) {\n      if (\n        !1 === request.flushScheduled &&\n        0 === request.pingedTasks.length &&\n        null !== request.destination\n      ) {\n        request.flushScheduled = !0;\n        var destination = request.destination;\n        destination\n          ? flushCompletedQueues(request, destination)\n          : (request.flushScheduled = !1);\n      }\n    }\n    function startFlowing(request, destination) {\n      if (13 === request.status)\n        (request.status = CLOSED), destination.destroy(request.fatalError);\n      else if (request.status !== CLOSED && null === request.destination) {\n        request.destination = destination;\n        try {\n          flushCompletedQueues(request, destination);\n        } catch (error) {\n          logRecoverableError(request, error, {}), fatalError(request, error);\n        }\n      }\n    }\n    function abort(request, reason) {\n      if (11 === request.status || 10 === request.status) request.status = 12;\n      try {\n        var abortableTasks = request.abortableTasks;\n        if (0 < abortableTasks.size) {\n          var error =\n            void 0 === reason\n              ? Error(\"The render was aborted by the server without a reason.\")\n              : \"object\" === typeof reason &&\n                  null !== reason &&\n                  \"function\" === typeof reason.then\n                ? Error(\"The render was aborted by the server with a promise.\")\n                : reason;\n          request.fatalError = error;\n          abortableTasks.forEach(function (task) {\n            return abortTask(task, request, error);\n          });\n          abortableTasks.clear();\n        }\n        null !== request.destination &&\n          flushCompletedQueues(request, request.destination);\n      } catch (error$4) {\n        logRecoverableError(request, error$4, {}), fatalError(request, error$4);\n      }\n    }\n    function onError() {}\n    function renderToStringImpl(\n      children,\n      options,\n      generateStaticMarkup,\n      abortReason\n    ) {\n      var didFatal = !1,\n        fatalError = null,\n        result = \"\",\n        readyToStream = !1;\n      options = createResumableState(\n        options ? options.identifierPrefix : void 0\n      );\n      children = createRequest(\n        children,\n        options,\n        createRenderState(options, generateStaticMarkup),\n        createFormatContext(ROOT_HTML_MODE, null, 0),\n        Infinity,\n        onError,\n        void 0,\n        function () {\n          readyToStream = !0;\n        },\n        void 0,\n        void 0,\n        void 0\n      );\n      startWork(children);\n      abort(children, abortReason);\n      startFlowing(children, {\n        push: function (chunk) {\n          null !== chunk && (result += chunk);\n          return !0;\n        },\n        destroy: function (error) {\n          didFatal = !0;\n          fatalError = error;\n        }\n      });\n      if (didFatal && fatalError !== abortReason) throw fatalError;\n      if (!readyToStream)\n        throw Error(\n          \"A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.\"\n        );\n      return result;\n    }\n    var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"),\n      ReactDOM = __webpack_require__(/*! next/dist/compiled/react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\"),\n      REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\"),\n      REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\"),\n      REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_SCOPE_TYPE = Symbol.for(\"react.scope\"),\n      REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for(\"react.debug_trace_mode\"),\n      REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\"),\n      REACT_LEGACY_HIDDEN_TYPE = Symbol.for(\"react.legacy_hidden\"),\n      REACT_MEMO_CACHE_SENTINEL = Symbol.for(\"react.memo_cache_sentinel\"),\n      MAYBE_ITERATOR_SYMBOL = Symbol.iterator,\n      isArrayImpl = Array.isArray,\n      jsxPropsParents = new WeakMap(),\n      jsxChildrenParents = new WeakMap(),\n      CLIENT_REFERENCE_TAG = Symbol.for(\"react.client.reference\"),\n      assign = Object.assign,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      VALID_ATTRIBUTE_NAME_REGEX = RegExp(\n        \"^[:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD][:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]*$\"\n      ),\n      illegalAttributeNameCache = {},\n      validatedAttributeNameCache = {},\n      unitlessNumbers = new Set(\n        \"animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp\".split(\n          \" \"\n        )\n      ),\n      aliases = new Map([\n        [\"acceptCharset\", \"accept-charset\"],\n        [\"htmlFor\", \"for\"],\n        [\"httpEquiv\", \"http-equiv\"],\n        [\"crossOrigin\", \"crossorigin\"],\n        [\"accentHeight\", \"accent-height\"],\n        [\"alignmentBaseline\", \"alignment-baseline\"],\n        [\"arabicForm\", \"arabic-form\"],\n        [\"baselineShift\", \"baseline-shift\"],\n        [\"capHeight\", \"cap-height\"],\n        [\"clipPath\", \"clip-path\"],\n        [\"clipRule\", \"clip-rule\"],\n        [\"colorInterpolation\", \"color-interpolation\"],\n        [\"colorInterpolationFilters\", \"color-interpolation-filters\"],\n        [\"colorProfile\", \"color-profile\"],\n        [\"colorRendering\", \"color-rendering\"],\n        [\"dominantBaseline\", \"dominant-baseline\"],\n        [\"enableBackground\", \"enable-background\"],\n        [\"fillOpacity\", \"fill-opacity\"],\n        [\"fillRule\", \"fill-rule\"],\n        [\"floodColor\", \"flood-color\"],\n        [\"floodOpacity\", \"flood-opacity\"],\n        [\"fontFamily\", \"font-family\"],\n        [\"fontSize\", \"font-size\"],\n        [\"fontSizeAdjust\", \"font-size-adjust\"],\n        [\"fontStretch\", \"font-stretch\"],\n        [\"fontStyle\", \"font-style\"],\n        [\"fontVariant\", \"font-variant\"],\n        [\"fontWeight\", \"font-weight\"],\n        [\"glyphName\", \"glyph-name\"],\n        [\"glyphOrientationHorizontal\", \"glyph-orientation-horizontal\"],\n        [\"glyphOrientationVertical\", \"glyph-orientation-vertical\"],\n        [\"horizAdvX\", \"horiz-adv-x\"],\n        [\"horizOriginX\", \"horiz-origin-x\"],\n        [\"imageRendering\", \"image-rendering\"],\n        [\"letterSpacing\", \"letter-spacing\"],\n        [\"lightingColor\", \"lighting-color\"],\n        [\"markerEnd\", \"marker-end\"],\n        [\"markerMid\", \"marker-mid\"],\n        [\"markerStart\", \"marker-start\"],\n        [\"overlinePosition\", \"overline-position\"],\n        [\"overlineThickness\", \"overline-thickness\"],\n        [\"paintOrder\", \"paint-order\"],\n        [\"panose-1\", \"panose-1\"],\n        [\"pointerEvents\", \"pointer-events\"],\n        [\"renderingIntent\", \"rendering-intent\"],\n        [\"shapeRendering\", \"shape-rendering\"],\n        [\"stopColor\", \"stop-color\"],\n        [\"stopOpacity\", \"stop-opacity\"],\n        [\"strikethroughPosition\", \"strikethrough-position\"],\n        [\"strikethroughThickness\", \"strikethrough-thickness\"],\n        [\"strokeDasharray\", \"stroke-dasharray\"],\n        [\"strokeDashoffset\", \"stroke-dashoffset\"],\n        [\"strokeLinecap\", \"stroke-linecap\"],\n        [\"strokeLinejoin\", \"stroke-linejoin\"],\n        [\"strokeMiterlimit\", \"stroke-miterlimit\"],\n        [\"strokeOpacity\", \"stroke-opacity\"],\n        [\"strokeWidth\", \"stroke-width\"],\n        [\"textAnchor\", \"text-anchor\"],\n        [\"textDecoration\", \"text-decoration\"],\n        [\"textRendering\", \"text-rendering\"],\n        [\"transformOrigin\", \"transform-origin\"],\n        [\"underlinePosition\", \"underline-position\"],\n        [\"underlineThickness\", \"underline-thickness\"],\n        [\"unicodeBidi\", \"unicode-bidi\"],\n        [\"unicodeRange\", \"unicode-range\"],\n        [\"unitsPerEm\", \"units-per-em\"],\n        [\"vAlphabetic\", \"v-alphabetic\"],\n        [\"vHanging\", \"v-hanging\"],\n        [\"vIdeographic\", \"v-ideographic\"],\n        [\"vMathematical\", \"v-mathematical\"],\n        [\"vectorEffect\", \"vector-effect\"],\n        [\"vertAdvY\", \"vert-adv-y\"],\n        [\"vertOriginX\", \"vert-origin-x\"],\n        [\"vertOriginY\", \"vert-origin-y\"],\n        [\"wordSpacing\", \"word-spacing\"],\n        [\"writingMode\", \"writing-mode\"],\n        [\"xmlnsXlink\", \"xmlns:xlink\"],\n        [\"xHeight\", \"x-height\"]\n      ]),\n      hasReadOnlyValue = {\n        button: !0,\n        checkbox: !0,\n        image: !0,\n        hidden: !0,\n        radio: !0,\n        reset: !0,\n        submit: !0\n      },\n      ariaProperties = {\n        \"aria-current\": 0,\n        \"aria-description\": 0,\n        \"aria-details\": 0,\n        \"aria-disabled\": 0,\n        \"aria-hidden\": 0,\n        \"aria-invalid\": 0,\n        \"aria-keyshortcuts\": 0,\n        \"aria-label\": 0,\n        \"aria-roledescription\": 0,\n        \"aria-autocomplete\": 0,\n        \"aria-checked\": 0,\n        \"aria-expanded\": 0,\n        \"aria-haspopup\": 0,\n        \"aria-level\": 0,\n        \"aria-modal\": 0,\n        \"aria-multiline\": 0,\n        \"aria-multiselectable\": 0,\n        \"aria-orientation\": 0,\n        \"aria-placeholder\": 0,\n        \"aria-pressed\": 0,\n        \"aria-readonly\": 0,\n        \"aria-required\": 0,\n        \"aria-selected\": 0,\n        \"aria-sort\": 0,\n        \"aria-valuemax\": 0,\n        \"aria-valuemin\": 0,\n        \"aria-valuenow\": 0,\n        \"aria-valuetext\": 0,\n        \"aria-atomic\": 0,\n        \"aria-busy\": 0,\n        \"aria-live\": 0,\n        \"aria-relevant\": 0,\n        \"aria-dropeffect\": 0,\n        \"aria-grabbed\": 0,\n        \"aria-activedescendant\": 0,\n        \"aria-colcount\": 0,\n        \"aria-colindex\": 0,\n        \"aria-colspan\": 0,\n        \"aria-controls\": 0,\n        \"aria-describedby\": 0,\n        \"aria-errormessage\": 0,\n        \"aria-flowto\": 0,\n        \"aria-labelledby\": 0,\n        \"aria-owns\": 0,\n        \"aria-posinset\": 0,\n        \"aria-rowcount\": 0,\n        \"aria-rowindex\": 0,\n        \"aria-rowspan\": 0,\n        \"aria-setsize\": 0\n      },\n      warnedProperties$1 = {},\n      rARIA$1 = RegExp(\n        \"^(aria)-[:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]*$\"\n      ),\n      rARIACamel$1 = RegExp(\n        \"^(aria)[A-Z][:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]*$\"\n      ),\n      didWarnValueNull = !1,\n      possibleStandardNames = {\n        accept: \"accept\",\n        acceptcharset: \"acceptCharset\",\n        \"accept-charset\": \"acceptCharset\",\n        accesskey: \"accessKey\",\n        action: \"action\",\n        allowfullscreen: \"allowFullScreen\",\n        alt: \"alt\",\n        as: \"as\",\n        async: \"async\",\n        autocapitalize: \"autoCapitalize\",\n        autocomplete: \"autoComplete\",\n        autocorrect: \"autoCorrect\",\n        autofocus: \"autoFocus\",\n        autoplay: \"autoPlay\",\n        autosave: \"autoSave\",\n        capture: \"capture\",\n        cellpadding: \"cellPadding\",\n        cellspacing: \"cellSpacing\",\n        challenge: \"challenge\",\n        charset: \"charSet\",\n        checked: \"checked\",\n        children: \"children\",\n        cite: \"cite\",\n        class: \"className\",\n        classid: \"classID\",\n        classname: \"className\",\n        cols: \"cols\",\n        colspan: \"colSpan\",\n        content: \"content\",\n        contenteditable: \"contentEditable\",\n        contextmenu: \"contextMenu\",\n        controls: \"controls\",\n        controlslist: \"controlsList\",\n        coords: \"coords\",\n        crossorigin: \"crossOrigin\",\n        dangerouslysetinnerhtml: \"dangerouslySetInnerHTML\",\n        data: \"data\",\n        datetime: \"dateTime\",\n        default: \"default\",\n        defaultchecked: \"defaultChecked\",\n        defaultvalue: \"defaultValue\",\n        defer: \"defer\",\n        dir: \"dir\",\n        disabled: \"disabled\",\n        disablepictureinpicture: \"disablePictureInPicture\",\n        disableremoteplayback: \"disableRemotePlayback\",\n        download: \"download\",\n        draggable: \"draggable\",\n        enctype: \"encType\",\n        enterkeyhint: \"enterKeyHint\",\n        fetchpriority: \"fetchPriority\",\n        for: \"htmlFor\",\n        form: \"form\",\n        formmethod: \"formMethod\",\n        formaction: \"formAction\",\n        formenctype: \"formEncType\",\n        formnovalidate: \"formNoValidate\",\n        formtarget: \"formTarget\",\n        frameborder: \"frameBorder\",\n        headers: \"headers\",\n        height: \"height\",\n        hidden: \"hidden\",\n        high: \"high\",\n        href: \"href\",\n        hreflang: \"hrefLang\",\n        htmlfor: \"htmlFor\",\n        httpequiv: \"httpEquiv\",\n        \"http-equiv\": \"httpEquiv\",\n        icon: \"icon\",\n        id: \"id\",\n        imagesizes: \"imageSizes\",\n        imagesrcset: \"imageSrcSet\",\n        inert: \"inert\",\n        innerhtml: \"innerHTML\",\n        inputmode: \"inputMode\",\n        integrity: \"integrity\",\n        is: \"is\",\n        itemid: \"itemID\",\n        itemprop: \"itemProp\",\n        itemref: \"itemRef\",\n        itemscope: \"itemScope\",\n        itemtype: \"itemType\",\n        keyparams: \"keyParams\",\n        keytype: \"keyType\",\n        kind: \"kind\",\n        label: \"label\",\n        lang: \"lang\",\n        list: \"list\",\n        loop: \"loop\",\n        low: \"low\",\n        manifest: \"manifest\",\n        marginwidth: \"marginWidth\",\n        marginheight: \"marginHeight\",\n        max: \"max\",\n        maxlength: \"maxLength\",\n        media: \"media\",\n        mediagroup: \"mediaGroup\",\n        method: \"method\",\n        min: \"min\",\n        minlength: \"minLength\",\n        multiple: \"multiple\",\n        muted: \"muted\",\n        name: \"name\",\n        nomodule: \"noModule\",\n        nonce: \"nonce\",\n        novalidate: \"noValidate\",\n        open: \"open\",\n        optimum: \"optimum\",\n        pattern: \"pattern\",\n        placeholder: \"placeholder\",\n        playsinline: \"playsInline\",\n        poster: \"poster\",\n        preload: \"preload\",\n        profile: \"profile\",\n        radiogroup: \"radioGroup\",\n        readonly: \"readOnly\",\n        referrerpolicy: \"referrerPolicy\",\n        rel: \"rel\",\n        required: \"required\",\n        reversed: \"reversed\",\n        role: \"role\",\n        rows: \"rows\",\n        rowspan: \"rowSpan\",\n        sandbox: \"sandbox\",\n        scope: \"scope\",\n        scoped: \"scoped\",\n        scrolling: \"scrolling\",\n        seamless: \"seamless\",\n        selected: \"selected\",\n        shape: \"shape\",\n        size: \"size\",\n        sizes: \"sizes\",\n        span: \"span\",\n        spellcheck: \"spellCheck\",\n        src: \"src\",\n        srcdoc: \"srcDoc\",\n        srclang: \"srcLang\",\n        srcset: \"srcSet\",\n        start: \"start\",\n        step: \"step\",\n        style: \"style\",\n        summary: \"summary\",\n        tabindex: \"tabIndex\",\n        target: \"target\",\n        title: \"title\",\n        type: \"type\",\n        usemap: \"useMap\",\n        value: \"value\",\n        width: \"width\",\n        wmode: \"wmode\",\n        wrap: \"wrap\",\n        about: \"about\",\n        accentheight: \"accentHeight\",\n        \"accent-height\": \"accentHeight\",\n        accumulate: \"accumulate\",\n        additive: \"additive\",\n        alignmentbaseline: \"alignmentBaseline\",\n        \"alignment-baseline\": \"alignmentBaseline\",\n        allowreorder: \"allowReorder\",\n        alphabetic: \"alphabetic\",\n        amplitude: \"amplitude\",\n        arabicform: \"arabicForm\",\n        \"arabic-form\": \"arabicForm\",\n        ascent: \"ascent\",\n        attributename: \"attributeName\",\n        attributetype: \"attributeType\",\n        autoreverse: \"autoReverse\",\n        azimuth: \"azimuth\",\n        basefrequency: \"baseFrequency\",\n        baselineshift: \"baselineShift\",\n        \"baseline-shift\": \"baselineShift\",\n        baseprofile: \"baseProfile\",\n        bbox: \"bbox\",\n        begin: \"begin\",\n        bias: \"bias\",\n        by: \"by\",\n        calcmode: \"calcMode\",\n        capheight: \"capHeight\",\n        \"cap-height\": \"capHeight\",\n        clip: \"clip\",\n        clippath: \"clipPath\",\n        \"clip-path\": \"clipPath\",\n        clippathunits: \"clipPathUnits\",\n        cliprule: \"clipRule\",\n        \"clip-rule\": \"clipRule\",\n        color: \"color\",\n        colorinterpolation: \"colorInterpolation\",\n        \"color-interpolation\": \"colorInterpolation\",\n        colorinterpolationfilters: \"colorInterpolationFilters\",\n        \"color-interpolation-filters\": \"colorInterpolationFilters\",\n        colorprofile: \"colorProfile\",\n        \"color-profile\": \"colorProfile\",\n        colorrendering: \"colorRendering\",\n        \"color-rendering\": \"colorRendering\",\n        contentscripttype: \"contentScriptType\",\n        contentstyletype: \"contentStyleType\",\n        cursor: \"cursor\",\n        cx: \"cx\",\n        cy: \"cy\",\n        d: \"d\",\n        datatype: \"datatype\",\n        decelerate: \"decelerate\",\n        descent: \"descent\",\n        diffuseconstant: \"diffuseConstant\",\n        direction: \"direction\",\n        display: \"display\",\n        divisor: \"divisor\",\n        dominantbaseline: \"dominantBaseline\",\n        \"dominant-baseline\": \"dominantBaseline\",\n        dur: \"dur\",\n        dx: \"dx\",\n        dy: \"dy\",\n        edgemode: \"edgeMode\",\n        elevation: \"elevation\",\n        enablebackground: \"enableBackground\",\n        \"enable-background\": \"enableBackground\",\n        end: \"end\",\n        exponent: \"exponent\",\n        externalresourcesrequired: \"externalResourcesRequired\",\n        fill: \"fill\",\n        fillopacity: \"fillOpacity\",\n        \"fill-opacity\": \"fillOpacity\",\n        fillrule: \"fillRule\",\n        \"fill-rule\": \"fillRule\",\n        filter: \"filter\",\n        filterres: \"filterRes\",\n        filterunits: \"filterUnits\",\n        floodopacity: \"floodOpacity\",\n        \"flood-opacity\": \"floodOpacity\",\n        floodcolor: \"floodColor\",\n        \"flood-color\": \"floodColor\",\n        focusable: \"focusable\",\n        fontfamily: \"fontFamily\",\n        \"font-family\": \"fontFamily\",\n        fontsize: \"fontSize\",\n        \"font-size\": \"fontSize\",\n        fontsizeadjust: \"fontSizeAdjust\",\n        \"font-size-adjust\": \"fontSizeAdjust\",\n        fontstretch: \"fontStretch\",\n        \"font-stretch\": \"fontStretch\",\n        fontstyle: \"fontStyle\",\n        \"font-style\": \"fontStyle\",\n        fontvariant: \"fontVariant\",\n        \"font-variant\": \"fontVariant\",\n        fontweight: \"fontWeight\",\n        \"font-weight\": \"fontWeight\",\n        format: \"format\",\n        from: \"from\",\n        fx: \"fx\",\n        fy: \"fy\",\n        g1: \"g1\",\n        g2: \"g2\",\n        glyphname: \"glyphName\",\n        \"glyph-name\": \"glyphName\",\n        glyphorientationhorizontal: \"glyphOrientationHorizontal\",\n        \"glyph-orientation-horizontal\": \"glyphOrientationHorizontal\",\n        glyphorientationvertical: \"glyphOrientationVertical\",\n        \"glyph-orientation-vertical\": \"glyphOrientationVertical\",\n        glyphref: \"glyphRef\",\n        gradienttransform: \"gradientTransform\",\n        gradientunits: \"gradientUnits\",\n        hanging: \"hanging\",\n        horizadvx: \"horizAdvX\",\n        \"horiz-adv-x\": \"horizAdvX\",\n        horizoriginx: \"horizOriginX\",\n        \"horiz-origin-x\": \"horizOriginX\",\n        ideographic: \"ideographic\",\n        imagerendering: \"imageRendering\",\n        \"image-rendering\": \"imageRendering\",\n        in2: \"in2\",\n        in: \"in\",\n        inlist: \"inlist\",\n        intercept: \"intercept\",\n        k1: \"k1\",\n        k2: \"k2\",\n        k3: \"k3\",\n        k4: \"k4\",\n        k: \"k\",\n        kernelmatrix: \"kernelMatrix\",\n        kernelunitlength: \"kernelUnitLength\",\n        kerning: \"kerning\",\n        keypoints: \"keyPoints\",\n        keysplines: \"keySplines\",\n        keytimes: \"keyTimes\",\n        lengthadjust: \"lengthAdjust\",\n        letterspacing: \"letterSpacing\",\n        \"letter-spacing\": \"letterSpacing\",\n        lightingcolor: \"lightingColor\",\n        \"lighting-color\": \"lightingColor\",\n        limitingconeangle: \"limitingConeAngle\",\n        local: \"local\",\n        markerend: \"markerEnd\",\n        \"marker-end\": \"markerEnd\",\n        markerheight: \"markerHeight\",\n        markermid: \"markerMid\",\n        \"marker-mid\": \"markerMid\",\n        markerstart: \"markerStart\",\n        \"marker-start\": \"markerStart\",\n        markerunits: \"markerUnits\",\n        markerwidth: \"markerWidth\",\n        mask: \"mask\",\n        maskcontentunits: \"maskContentUnits\",\n        maskunits: \"maskUnits\",\n        mathematical: \"mathematical\",\n        mode: \"mode\",\n        numoctaves: \"numOctaves\",\n        offset: \"offset\",\n        opacity: \"opacity\",\n        operator: \"operator\",\n        order: \"order\",\n        orient: \"orient\",\n        orientation: \"orientation\",\n        origin: \"origin\",\n        overflow: \"overflow\",\n        overlineposition: \"overlinePosition\",\n        \"overline-position\": \"overlinePosition\",\n        overlinethickness: \"overlineThickness\",\n        \"overline-thickness\": \"overlineThickness\",\n        paintorder: \"paintOrder\",\n        \"paint-order\": \"paintOrder\",\n        panose1: \"panose1\",\n        \"panose-1\": \"panose1\",\n        pathlength: \"pathLength\",\n        patterncontentunits: \"patternContentUnits\",\n        patterntransform: \"patternTransform\",\n        patternunits: \"patternUnits\",\n        pointerevents: \"pointerEvents\",\n        \"pointer-events\": \"pointerEvents\",\n        points: \"points\",\n        pointsatx: \"pointsAtX\",\n        pointsaty: \"pointsAtY\",\n        pointsatz: \"pointsAtZ\",\n        popover: \"popover\",\n        popovertarget: \"popoverTarget\",\n        popovertargetaction: \"popoverTargetAction\",\n        prefix: \"prefix\",\n        preservealpha: \"preserveAlpha\",\n        preserveaspectratio: \"preserveAspectRatio\",\n        primitiveunits: \"primitiveUnits\",\n        property: \"property\",\n        r: \"r\",\n        radius: \"radius\",\n        refx: \"refX\",\n        refy: \"refY\",\n        renderingintent: \"renderingIntent\",\n        \"rendering-intent\": \"renderingIntent\",\n        repeatcount: \"repeatCount\",\n        repeatdur: \"repeatDur\",\n        requiredextensions: \"requiredExtensions\",\n        requiredfeatures: \"requiredFeatures\",\n        resource: \"resource\",\n        restart: \"restart\",\n        result: \"result\",\n        results: \"results\",\n        rotate: \"rotate\",\n        rx: \"rx\",\n        ry: \"ry\",\n        scale: \"scale\",\n        security: \"security\",\n        seed: \"seed\",\n        shaperendering: \"shapeRendering\",\n        \"shape-rendering\": \"shapeRendering\",\n        slope: \"slope\",\n        spacing: \"spacing\",\n        specularconstant: \"specularConstant\",\n        specularexponent: \"specularExponent\",\n        speed: \"speed\",\n        spreadmethod: \"spreadMethod\",\n        startoffset: \"startOffset\",\n        stddeviation: \"stdDeviation\",\n        stemh: \"stemh\",\n        stemv: \"stemv\",\n        stitchtiles: \"stitchTiles\",\n        stopcolor: \"stopColor\",\n        \"stop-color\": \"stopColor\",\n        stopopacity: \"stopOpacity\",\n        \"stop-opacity\": \"stopOpacity\",\n        strikethroughposition: \"strikethroughPosition\",\n        \"strikethrough-position\": \"strikethroughPosition\",\n        strikethroughthickness: \"strikethroughThickness\",\n        \"strikethrough-thickness\": \"strikethroughThickness\",\n        string: \"string\",\n        stroke: \"stroke\",\n        strokedasharray: \"strokeDasharray\",\n        \"stroke-dasharray\": \"strokeDasharray\",\n        strokedashoffset: \"strokeDashoffset\",\n        \"stroke-dashoffset\": \"strokeDashoffset\",\n        strokelinecap: \"strokeLinecap\",\n        \"stroke-linecap\": \"strokeLinecap\",\n        strokelinejoin: \"strokeLinejoin\",\n        \"stroke-linejoin\": \"strokeLinejoin\",\n        strokemiterlimit: \"strokeMiterlimit\",\n        \"stroke-miterlimit\": \"strokeMiterlimit\",\n        strokewidth: \"strokeWidth\",\n        \"stroke-width\": \"strokeWidth\",\n        strokeopacity: \"strokeOpacity\",\n        \"stroke-opacity\": \"strokeOpacity\",\n        suppresscontenteditablewarning: \"suppressContentEditableWarning\",\n        suppresshydrationwarning: \"suppressHydrationWarning\",\n        surfacescale: \"surfaceScale\",\n        systemlanguage: \"systemLanguage\",\n        tablevalues: \"tableValues\",\n        targetx: \"targetX\",\n        targety: \"targetY\",\n        textanchor: \"textAnchor\",\n        \"text-anchor\": \"textAnchor\",\n        textdecoration: \"textDecoration\",\n        \"text-decoration\": \"textDecoration\",\n        textlength: \"textLength\",\n        textrendering: \"textRendering\",\n        \"text-rendering\": \"textRendering\",\n        to: \"to\",\n        transform: \"transform\",\n        transformorigin: \"transformOrigin\",\n        \"transform-origin\": \"transformOrigin\",\n        typeof: \"typeof\",\n        u1: \"u1\",\n        u2: \"u2\",\n        underlineposition: \"underlinePosition\",\n        \"underline-position\": \"underlinePosition\",\n        underlinethickness: \"underlineThickness\",\n        \"underline-thickness\": \"underlineThickness\",\n        unicode: \"unicode\",\n        unicodebidi: \"unicodeBidi\",\n        \"unicode-bidi\": \"unicodeBidi\",\n        unicoderange: \"unicodeRange\",\n        \"unicode-range\": \"unicodeRange\",\n        unitsperem: \"unitsPerEm\",\n        \"units-per-em\": \"unitsPerEm\",\n        unselectable: \"unselectable\",\n        valphabetic: \"vAlphabetic\",\n        \"v-alphabetic\": \"vAlphabetic\",\n        values: \"values\",\n        vectoreffect: \"vectorEffect\",\n        \"vector-effect\": \"vectorEffect\",\n        version: \"version\",\n        vertadvy: \"vertAdvY\",\n        \"vert-adv-y\": \"vertAdvY\",\n        vertoriginx: \"vertOriginX\",\n        \"vert-origin-x\": \"vertOriginX\",\n        vertoriginy: \"vertOriginY\",\n        \"vert-origin-y\": \"vertOriginY\",\n        vhanging: \"vHanging\",\n        \"v-hanging\": \"vHanging\",\n        videographic: \"vIdeographic\",\n        \"v-ideographic\": \"vIdeographic\",\n        viewbox: \"viewBox\",\n        viewtarget: \"viewTarget\",\n        visibility: \"visibility\",\n        vmathematical: \"vMathematical\",\n        \"v-mathematical\": \"vMathematical\",\n        vocab: \"vocab\",\n        widths: \"widths\",\n        wordspacing: \"wordSpacing\",\n        \"word-spacing\": \"wordSpacing\",\n        writingmode: \"writingMode\",\n        \"writing-mode\": \"writingMode\",\n        x1: \"x1\",\n        x2: \"x2\",\n        x: \"x\",\n        xchannelselector: \"xChannelSelector\",\n        xheight: \"xHeight\",\n        \"x-height\": \"xHeight\",\n        xlinkactuate: \"xlinkActuate\",\n        \"xlink:actuate\": \"xlinkActuate\",\n        xlinkarcrole: \"xlinkArcrole\",\n        \"xlink:arcrole\": \"xlinkArcrole\",\n        xlinkhref: \"xlinkHref\",\n        \"xlink:href\": \"xlinkHref\",\n        xlinkrole: \"xlinkRole\",\n        \"xlink:role\": \"xlinkRole\",\n        xlinkshow: \"xlinkShow\",\n        \"xlink:show\": \"xlinkShow\",\n        xlinktitle: \"xlinkTitle\",\n        \"xlink:title\": \"xlinkTitle\",\n        xlinktype: \"xlinkType\",\n        \"xlink:type\": \"xlinkType\",\n        xmlbase: \"xmlBase\",\n        \"xml:base\": \"xmlBase\",\n        xmllang: \"xmlLang\",\n        \"xml:lang\": \"xmlLang\",\n        xmlns: \"xmlns\",\n        \"xml:space\": \"xmlSpace\",\n        xmlnsxlink: \"xmlnsXlink\",\n        \"xmlns:xlink\": \"xmlnsXlink\",\n        xmlspace: \"xmlSpace\",\n        y1: \"y1\",\n        y2: \"y2\",\n        y: \"y\",\n        ychannelselector: \"yChannelSelector\",\n        z: \"z\",\n        zoomandpan: \"zoomAndPan\"\n      },\n      warnedProperties = {},\n      EVENT_NAME_REGEX = /^on./,\n      INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/,\n      rARIA = RegExp(\n        \"^(aria)-[:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]*$\"\n      ),\n      rARIACamel = RegExp(\n        \"^(aria)[A-Z][:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]*$\"\n      ),\n      badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/,\n      msPattern$1 = /^-ms-/,\n      hyphenPattern = /-(.)/g,\n      badStyleValueWithSemicolonPattern = /;\\s*$/,\n      warnedStyleNames = {},\n      warnedStyleValues = {},\n      warnedForNaNValue = !1,\n      warnedForInfinityValue = !1,\n      matchHtmlRegExp = /[\"'&<>]/,\n      uppercasePattern = /([A-Z])/g,\n      msPattern = /^ms-/,\n      isJavaScriptProtocol =\n        /^[\\u0000-\\u001F ]*j[\\r\\n\\t]*a[\\r\\n\\t]*v[\\r\\n\\t]*a[\\r\\n\\t]*s[\\r\\n\\t]*c[\\r\\n\\t]*r[\\r\\n\\t]*i[\\r\\n\\t]*p[\\r\\n\\t]*t[\\r\\n\\t]*:/i,\n      ReactSharedInternals =\n        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      ReactDOMSharedInternals =\n        ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      NotPending = Object.freeze({\n        pending: !1,\n        data: null,\n        method: null,\n        action: null\n      }),\n      previousDispatcher = ReactDOMSharedInternals.d;\n    ReactDOMSharedInternals.d = {\n      f: previousDispatcher.f,\n      r: previousDispatcher.r,\n      D: function (href) {\n        var request = currentRequest ? currentRequest : null;\n        if (request) {\n          var resumableState = request.resumableState,\n            renderState = request.renderState;\n          if (\"string\" === typeof href && href) {\n            if (!resumableState.dnsResources.hasOwnProperty(href)) {\n              resumableState.dnsResources[href] = EXISTS;\n              resumableState = renderState.headers;\n              var header, JSCompiler_temp;\n              if (\n                (JSCompiler_temp =\n                  resumableState && 0 < resumableState.remainingCapacity)\n              )\n                JSCompiler_temp =\n                  ((header =\n                    \"<\" +\n                    escapeHrefForLinkHeaderURLContext(href) +\n                    \">; rel=dns-prefetch\"),\n                  0 <= (resumableState.remainingCapacity -= header.length + 2));\n              JSCompiler_temp\n                ? ((renderState.resets.dns[href] = EXISTS),\n                  resumableState.preconnects &&\n                    (resumableState.preconnects += \", \"),\n                  (resumableState.preconnects += header))\n                : ((header = []),\n                  pushLinkImpl(header, { href: href, rel: \"dns-prefetch\" }),\n                  renderState.preconnects.add(header));\n            }\n            enqueueFlush(request);\n          }\n        } else previousDispatcher.D(href);\n      },\n      C: function (href, crossOrigin) {\n        var request = currentRequest ? currentRequest : null;\n        if (request) {\n          var resumableState = request.resumableState,\n            renderState = request.renderState;\n          if (\"string\" === typeof href && href) {\n            var bucket =\n              \"use-credentials\" === crossOrigin\n                ? \"credentials\"\n                : \"string\" === typeof crossOrigin\n                  ? \"anonymous\"\n                  : \"default\";\n            if (!resumableState.connectResources[bucket].hasOwnProperty(href)) {\n              resumableState.connectResources[bucket][href] = EXISTS;\n              resumableState = renderState.headers;\n              var header, JSCompiler_temp;\n              if (\n                (JSCompiler_temp =\n                  resumableState && 0 < resumableState.remainingCapacity)\n              ) {\n                JSCompiler_temp =\n                  \"<\" +\n                  escapeHrefForLinkHeaderURLContext(href) +\n                  \">; rel=preconnect\";\n                if (\"string\" === typeof crossOrigin) {\n                  var escapedCrossOrigin =\n                    escapeStringForLinkHeaderQuotedParamValueContext(\n                      crossOrigin,\n                      \"crossOrigin\"\n                    );\n                  JSCompiler_temp +=\n                    '; crossorigin=\"' + escapedCrossOrigin + '\"';\n                }\n                JSCompiler_temp =\n                  ((header = JSCompiler_temp),\n                  0 <= (resumableState.remainingCapacity -= header.length + 2));\n              }\n              JSCompiler_temp\n                ? ((renderState.resets.connect[bucket][href] = EXISTS),\n                  resumableState.preconnects &&\n                    (resumableState.preconnects += \", \"),\n                  (resumableState.preconnects += header))\n                : ((bucket = []),\n                  pushLinkImpl(bucket, {\n                    rel: \"preconnect\",\n                    href: href,\n                    crossOrigin: crossOrigin\n                  }),\n                  renderState.preconnects.add(bucket));\n            }\n            enqueueFlush(request);\n          }\n        } else previousDispatcher.C(href, crossOrigin);\n      },\n      L: function (href, as, options) {\n        var request = currentRequest ? currentRequest : null;\n        if (request) {\n          var resumableState = request.resumableState,\n            renderState = request.renderState;\n          if (as && href) {\n            switch (as) {\n              case \"image\":\n                if (options) {\n                  var imageSrcSet = options.imageSrcSet;\n                  var imageSizes = options.imageSizes;\n                  var fetchPriority = options.fetchPriority;\n                }\n                var key = imageSrcSet\n                  ? imageSrcSet + \"\\n\" + (imageSizes || \"\")\n                  : href;\n                if (resumableState.imageResources.hasOwnProperty(key)) return;\n                resumableState.imageResources[key] = PRELOAD_NO_CREDS;\n                resumableState = renderState.headers;\n                var header;\n                resumableState &&\n                0 < resumableState.remainingCapacity &&\n                \"high\" === fetchPriority &&\n                ((header = getPreloadAsHeader(href, as, options)),\n                0 <= (resumableState.remainingCapacity -= header.length + 2))\n                  ? ((renderState.resets.image[key] = PRELOAD_NO_CREDS),\n                    resumableState.highImagePreloads &&\n                      (resumableState.highImagePreloads += \", \"),\n                    (resumableState.highImagePreloads += header))\n                  : ((resumableState = []),\n                    pushLinkImpl(\n                      resumableState,\n                      assign(\n                        {\n                          rel: \"preload\",\n                          href: imageSrcSet ? void 0 : href,\n                          as: as\n                        },\n                        options\n                      )\n                    ),\n                    \"high\" === fetchPriority\n                      ? renderState.highImagePreloads.add(resumableState)\n                      : (renderState.bulkPreloads.add(resumableState),\n                        renderState.preloads.images.set(key, resumableState)));\n                break;\n              case \"style\":\n                if (resumableState.styleResources.hasOwnProperty(href)) return;\n                imageSrcSet = [];\n                pushLinkImpl(\n                  imageSrcSet,\n                  assign({ rel: \"preload\", href: href, as: as }, options)\n                );\n                resumableState.styleResources[href] =\n                  !options ||\n                  (\"string\" !== typeof options.crossOrigin &&\n                    \"string\" !== typeof options.integrity)\n                    ? PRELOAD_NO_CREDS\n                    : [options.crossOrigin, options.integrity];\n                renderState.preloads.stylesheets.set(href, imageSrcSet);\n                renderState.bulkPreloads.add(imageSrcSet);\n                break;\n              case \"script\":\n                if (resumableState.scriptResources.hasOwnProperty(href)) return;\n                imageSrcSet = [];\n                renderState.preloads.scripts.set(href, imageSrcSet);\n                renderState.bulkPreloads.add(imageSrcSet);\n                pushLinkImpl(\n                  imageSrcSet,\n                  assign({ rel: \"preload\", href: href, as: as }, options)\n                );\n                resumableState.scriptResources[href] =\n                  !options ||\n                  (\"string\" !== typeof options.crossOrigin &&\n                    \"string\" !== typeof options.integrity)\n                    ? PRELOAD_NO_CREDS\n                    : [options.crossOrigin, options.integrity];\n                break;\n              default:\n                if (resumableState.unknownResources.hasOwnProperty(as)) {\n                  if (\n                    ((imageSrcSet = resumableState.unknownResources[as]),\n                    imageSrcSet.hasOwnProperty(href))\n                  )\n                    return;\n                } else\n                  (imageSrcSet = {}),\n                    (resumableState.unknownResources[as] = imageSrcSet);\n                imageSrcSet[href] = PRELOAD_NO_CREDS;\n                if (\n                  (resumableState = renderState.headers) &&\n                  0 < resumableState.remainingCapacity &&\n                  \"font\" === as &&\n                  ((key = getPreloadAsHeader(href, as, options)),\n                  0 <= (resumableState.remainingCapacity -= key.length + 2))\n                )\n                  (renderState.resets.font[href] = PRELOAD_NO_CREDS),\n                    resumableState.fontPreloads &&\n                      (resumableState.fontPreloads += \", \"),\n                    (resumableState.fontPreloads += key);\n                else\n                  switch (\n                    ((resumableState = []),\n                    (href = assign(\n                      { rel: \"preload\", href: href, as: as },\n                      options\n                    )),\n                    pushLinkImpl(resumableState, href),\n                    as)\n                  ) {\n                    case \"font\":\n                      renderState.fontPreloads.add(resumableState);\n                      break;\n                    default:\n                      renderState.bulkPreloads.add(resumableState);\n                  }\n            }\n            enqueueFlush(request);\n          }\n        } else previousDispatcher.L(href, as, options);\n      },\n      m: function (href, options) {\n        var request = currentRequest ? currentRequest : null;\n        if (request) {\n          var resumableState = request.resumableState,\n            renderState = request.renderState;\n          if (href) {\n            var as =\n              options && \"string\" === typeof options.as ? options.as : \"script\";\n            switch (as) {\n              case \"script\":\n                if (resumableState.moduleScriptResources.hasOwnProperty(href))\n                  return;\n                as = [];\n                resumableState.moduleScriptResources[href] =\n                  !options ||\n                  (\"string\" !== typeof options.crossOrigin &&\n                    \"string\" !== typeof options.integrity)\n                    ? PRELOAD_NO_CREDS\n                    : [options.crossOrigin, options.integrity];\n                renderState.preloads.moduleScripts.set(href, as);\n                break;\n              default:\n                if (resumableState.moduleUnknownResources.hasOwnProperty(as)) {\n                  var resources = resumableState.unknownResources[as];\n                  if (resources.hasOwnProperty(href)) return;\n                } else\n                  (resources = {}),\n                    (resumableState.moduleUnknownResources[as] = resources);\n                as = [];\n                resources[href] = PRELOAD_NO_CREDS;\n            }\n            pushLinkImpl(\n              as,\n              assign({ rel: \"modulepreload\", href: href }, options)\n            );\n            renderState.bulkPreloads.add(as);\n            enqueueFlush(request);\n          }\n        } else previousDispatcher.m(href, options);\n      },\n      X: function (src, options) {\n        var request = currentRequest ? currentRequest : null;\n        if (request) {\n          var resumableState = request.resumableState,\n            renderState = request.renderState;\n          if (src) {\n            var resourceState = resumableState.scriptResources.hasOwnProperty(\n              src\n            )\n              ? resumableState.scriptResources[src]\n              : void 0;\n            resourceState !== EXISTS &&\n              ((resumableState.scriptResources[src] = EXISTS),\n              (options = assign({ src: src, async: !0 }, options)),\n              resourceState &&\n                (2 === resourceState.length &&\n                  adoptPreloadCredentials(options, resourceState),\n                (src = renderState.preloads.scripts.get(src))) &&\n                (src.length = 0),\n              (src = []),\n              renderState.scripts.add(src),\n              pushScriptImpl(src, options),\n              enqueueFlush(request));\n          }\n        } else previousDispatcher.X(src, options);\n      },\n      S: function (href, precedence, options) {\n        var request = currentRequest ? currentRequest : null;\n        if (request) {\n          var resumableState = request.resumableState,\n            renderState = request.renderState;\n          if (href) {\n            precedence = precedence || \"default\";\n            var styleQueue = renderState.styles.get(precedence),\n              resourceState = resumableState.styleResources.hasOwnProperty(href)\n                ? resumableState.styleResources[href]\n                : void 0;\n            resourceState !== EXISTS &&\n              ((resumableState.styleResources[href] = EXISTS),\n              styleQueue ||\n                ((styleQueue = {\n                  precedence: escapeTextForBrowser(precedence),\n                  rules: [],\n                  hrefs: [],\n                  sheets: new Map()\n                }),\n                renderState.styles.set(precedence, styleQueue)),\n              (precedence = {\n                state: PENDING$1,\n                props: assign(\n                  {\n                    rel: \"stylesheet\",\n                    href: href,\n                    \"data-precedence\": precedence\n                  },\n                  options\n                )\n              }),\n              resourceState &&\n                (2 === resourceState.length &&\n                  adoptPreloadCredentials(precedence.props, resourceState),\n                (renderState = renderState.preloads.stylesheets.get(href)) &&\n                0 < renderState.length\n                  ? (renderState.length = 0)\n                  : (precedence.state = PRELOADED)),\n              styleQueue.sheets.set(href, precedence),\n              enqueueFlush(request));\n          }\n        } else previousDispatcher.S(href, precedence, options);\n      },\n      M: function (src, options) {\n        var request = currentRequest ? currentRequest : null;\n        if (request) {\n          var resumableState = request.resumableState,\n            renderState = request.renderState;\n          if (src) {\n            var resourceState =\n              resumableState.moduleScriptResources.hasOwnProperty(src)\n                ? resumableState.moduleScriptResources[src]\n                : void 0;\n            resourceState !== EXISTS &&\n              ((resumableState.moduleScriptResources[src] = EXISTS),\n              (options = assign(\n                { src: src, type: \"module\", async: !0 },\n                options\n              )),\n              resourceState &&\n                (2 === resourceState.length &&\n                  adoptPreloadCredentials(options, resourceState),\n                (src = renderState.preloads.moduleScripts.get(src))) &&\n                (src.length = 0),\n              (src = []),\n              renderState.scripts.add(src),\n              pushScriptImpl(src, options),\n              enqueueFlush(request));\n          }\n        } else previousDispatcher.M(src, options);\n      }\n    };\n    var NothingSent = 0,\n      SentCompleteSegmentFunction = 1,\n      SentCompleteBoundaryFunction = 2,\n      SentClientRenderFunction = 4,\n      SentStyleInsertionFunction = 8,\n      EXISTS = null,\n      PRELOAD_NO_CREDS = [];\n    Object.freeze(PRELOAD_NO_CREDS);\n    var scriptRegex = /(<\\/|<)(s)(cript)/gi;\n    var didWarnForNewBooleanPropsWithEmptyValue = {};\n    var ROOT_HTML_MODE = 0,\n      HTML_HTML_MODE = 1,\n      HTML_MODE = 2,\n      SVG_MODE = 3,\n      MATHML_MODE = 4,\n      HTML_TABLE_MODE = 5,\n      HTML_TABLE_BODY_MODE = 6,\n      HTML_TABLE_ROW_MODE = 7,\n      HTML_COLGROUP_MODE = 8,\n      styleNameCache = new Map(),\n      styleAttributeStart = ' style=\"',\n      styleAssign = \":\",\n      styleSeparator = \";\",\n      attributeSeparator = \" \",\n      attributeAssign = '=\"',\n      attributeEnd = '\"',\n      attributeEmptyString = '=\"\"',\n      actionJavaScriptURL = escapeTextForBrowser(\n        \"javascript:throw new Error('React form unexpectedly submitted.')\"\n      ),\n      endOfStartTag = \">\",\n      endOfStartTagSelfClosing = \"/>\",\n      didWarnDefaultInputValue = !1,\n      didWarnDefaultChecked = !1,\n      didWarnDefaultSelectValue = !1,\n      didWarnDefaultTextareaValue = !1,\n      didWarnInvalidOptionChildren = !1,\n      didWarnInvalidOptionInnerHTML = !1,\n      didWarnSelectedSetOnOption = !1,\n      didWarnFormActionType = !1,\n      didWarnFormActionName = !1,\n      didWarnFormActionTarget = !1,\n      didWarnFormActionMethod = !1,\n      formReplayingRuntimeScript =\n        'addEventListener(\"submit\",function(a){if(!a.defaultPrevented){var c=a.target,d=a.submitter,e=c.action,b=d;if(d){var f=d.getAttribute(\"formAction\");null!=f&&(e=f,b=null)}\"javascript:throw new Error(\\'React form unexpectedly submitted.\\')\"===e&&(a.preventDefault(),b?(a=document.createElement(\"input\"),a.name=b.name,a.value=b.value,b.parentNode.insertBefore(a,b),b=new FormData(c),a.parentNode.removeChild(a)):b=new FormData(c),a=c.ownerDocument||c,(a.$$reactFormReplay=a.$$reactFormReplay||[]).push(c,d,b))}});',\n      styleRegex = /(<\\/|<)(s)(tyle)/gi,\n      leadingNewline = \"\\n\",\n      VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\\.\\-\\d]*$/,\n      validatedTagCache = new Map(),\n      endTagCache = new Map(),\n      placeholder1 = '<template id=\"',\n      placeholder2 = '\"></template>',\n      startCompletedSuspenseBoundary = \"\\x3c!--$--\\x3e\",\n      startPendingSuspenseBoundary1 = '\\x3c!--$?--\\x3e<template id=\"',\n      startPendingSuspenseBoundary2 = '\"></template>',\n      startClientRenderedSuspenseBoundary = \"\\x3c!--$!--\\x3e\",\n      endSuspenseBoundary = \"\\x3c!--/$--\\x3e\",\n      clientRenderedSuspenseBoundaryError1 = \"<template\",\n      clientRenderedSuspenseBoundaryErrorAttrInterstitial = '\"',\n      clientRenderedSuspenseBoundaryError1A = ' data-dgst=\"',\n      clientRenderedSuspenseBoundaryError1B = ' data-msg=\"',\n      clientRenderedSuspenseBoundaryError1C = ' data-stck=\"',\n      clientRenderedSuspenseBoundaryError1D = ' data-cstck=\"',\n      clientRenderedSuspenseBoundaryError2 = \"></template>\",\n      startSegmentHTML = '<div hidden id=\"',\n      startSegmentHTML2 = '\">',\n      endSegmentHTML = \"</div>\",\n      startSegmentSVG = '<svg aria-hidden=\"true\" style=\"display:none\" id=\"',\n      startSegmentSVG2 = '\">',\n      endSegmentSVG = \"</svg>\",\n      startSegmentMathML = '<math aria-hidden=\"true\" style=\"display:none\" id=\"',\n      startSegmentMathML2 = '\">',\n      endSegmentMathML = \"</math>\",\n      startSegmentTable = '<table hidden id=\"',\n      startSegmentTable2 = '\">',\n      endSegmentTable = \"</table>\",\n      startSegmentTableBody = '<table hidden><tbody id=\"',\n      startSegmentTableBody2 = '\">',\n      endSegmentTableBody = \"</tbody></table>\",\n      startSegmentTableRow = '<table hidden><tr id=\"',\n      startSegmentTableRow2 = '\">',\n      endSegmentTableRow = \"</tr></table>\",\n      startSegmentColGroup = '<table hidden><colgroup id=\"',\n      startSegmentColGroup2 = '\">',\n      endSegmentColGroup = \"</colgroup></table>\",\n      completeSegmentScript1Full =\n        '$RS=function(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS(\"',\n      completeSegmentScript1Partial = '$RS(\"',\n      completeSegmentScript2 = '\",\"',\n      completeSegmentScriptEnd = '\")\\x3c/script>',\n      completeBoundaryScript1Full =\n        '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data=\"$!\",a.setAttribute(\"data-dgst\",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if(\"/$\"===d)if(0===f)break;else f--;else\"$\"!==d&&\"$?\"!==d&&\"$!\"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data=\"$\"}b._reactRetry&&b._reactRetry()}};$RC(\"',\n      completeBoundaryScript1Partial = '$RC(\"',\n      completeBoundaryWithStylesScript1FullBoth =\n        '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data=\"$!\",a.setAttribute(\"data-dgst\",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if(\"/$\"===d)if(0===f)break;else f--;else\"$\"!==d&&\"$?\"!==d&&\"$!\"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data=\"$\"}b._reactRetry&&b._reactRetry()}};$RM=new Map;\\n$RR=function(t,u,y){function v(n){this._p=null;n()}for(var w=$RC,p=$RM,q=new Map,r=document,g,b,h=r.querySelectorAll(\"link[data-precedence],style[data-precedence]\"),x=[],k=0;b=h[k++];)\"not all\"===b.getAttribute(\"media\")?x.push(b):(\"LINK\"===b.tagName&&p.set(b.getAttribute(\"href\"),b),q.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var e=y[b++];if(!e){k=!1;b=0;continue}var c=!1,m=0;var d=e[m++];if(a=p.get(d)){var f=a._p;c=!0}else{a=r.createElement(\"link\");a.href=\\nd;a.rel=\"stylesheet\";for(a.dataset.precedence=l=e[m++];f=e[m++];)a.setAttribute(f,e[m++]);f=a._p=new Promise(function(n,z){a.onload=v.bind(a,n);a.onerror=v.bind(a,z)});p.set(d,a)}d=a.getAttribute(\"media\");!f||d&&!matchMedia(d).matches||h.push(f);if(c)continue}else{a=x[b++];if(!a)break;l=a.getAttribute(\"data-precedence\");a.removeAttribute(\"media\")}c=q.get(l)||g;c===g&&(g=a);q.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=r.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(w.bind(null,\\nt,u,\"\"),w.bind(null,t,u,\"Resource failed to load\"))};$RR(\"',\n      completeBoundaryWithStylesScript1FullPartial =\n        '$RM=new Map;\\n$RR=function(t,u,y){function v(n){this._p=null;n()}for(var w=$RC,p=$RM,q=new Map,r=document,g,b,h=r.querySelectorAll(\"link[data-precedence],style[data-precedence]\"),x=[],k=0;b=h[k++];)\"not all\"===b.getAttribute(\"media\")?x.push(b):(\"LINK\"===b.tagName&&p.set(b.getAttribute(\"href\"),b),q.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var e=y[b++];if(!e){k=!1;b=0;continue}var c=!1,m=0;var d=e[m++];if(a=p.get(d)){var f=a._p;c=!0}else{a=r.createElement(\"link\");a.href=\\nd;a.rel=\"stylesheet\";for(a.dataset.precedence=l=e[m++];f=e[m++];)a.setAttribute(f,e[m++]);f=a._p=new Promise(function(n,z){a.onload=v.bind(a,n);a.onerror=v.bind(a,z)});p.set(d,a)}d=a.getAttribute(\"media\");!f||d&&!matchMedia(d).matches||h.push(f);if(c)continue}else{a=x[b++];if(!a)break;l=a.getAttribute(\"data-precedence\");a.removeAttribute(\"media\")}c=q.get(l)||g;c===g&&(g=a);q.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=r.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(w.bind(null,\\nt,u,\"\"),w.bind(null,t,u,\"Resource failed to load\"))};$RR(\"',\n      completeBoundaryWithStylesScript1Partial = '$RR(\"',\n      completeBoundaryScript2 = '\",\"',\n      completeBoundaryScript3a = '\",',\n      completeBoundaryScript3b = '\"',\n      completeBoundaryScriptEnd = \")\\x3c/script>\",\n      clientRenderScript1Full =\n        '$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data=\"$!\",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};;$RX(\"',\n      clientRenderScript1Partial = '$RX(\"',\n      clientRenderScript1A = '\"',\n      clientRenderErrorScriptArgInterstitial = \",\",\n      clientRenderScriptEnd = \")\\x3c/script>\",\n      regexForJSStringsInInstructionScripts = /[<\\u2028\\u2029]/g,\n      regexForJSStringsInScripts = /[&><\\u2028\\u2029]/g,\n      lateStyleTagResourceOpen1 = '<style media=\"not all\" data-precedence=\"',\n      lateStyleTagResourceOpen2 = '\" data-href=\"',\n      lateStyleTagResourceOpen3 = '\">',\n      lateStyleTagTemplateClose = \"</style>\",\n      currentlyRenderingBoundaryHasStylesToHoist = !1,\n      destinationHasCapacity = !0,\n      stylesheetFlushingQueue = [],\n      styleTagResourceOpen1 = '<style data-precedence=\"',\n      styleTagResourceOpen2 = '\" data-href=\"',\n      spaceSeparator = \" \",\n      styleTagResourceOpen3 = '\">',\n      styleTagResourceClose = \"</style>\",\n      arrayFirstOpenBracket = \"[\",\n      arraySubsequentOpenBracket = \",[\",\n      arrayInterstitial = \",\",\n      arrayCloseBracket = \"]\",\n      PENDING$1 = 0,\n      PRELOADED = 1,\n      PREAMBLE = 2,\n      LATE = 3,\n      regexForHrefInLinkHeaderURLContext = /[<>\\r\\n]/g,\n      regexForLinkHeaderQuotedParamValueContext = /[\"';,\\r\\n]/g,\n      doctypeChunk = \"\",\n      bind = Function.prototype.bind,\n      REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n      emptyContextObject = {};\n    Object.freeze(emptyContextObject);\n    var rendererSigil = {};\n    var currentActiveSnapshot = null,\n      didWarnAboutNoopUpdateForComponent = {},\n      didWarnAboutDeprecatedWillMount = {};\n    var didWarnAboutUninitializedState = new Set();\n    var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\n    var didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\n    var didWarnAboutDirectlyAssigningPropsToState = new Set();\n    var didWarnAboutUndefinedDerivedState = new Set();\n    var didWarnAboutContextTypes$1 = new Set();\n    var didWarnAboutChildContextTypes = new Set();\n    var didWarnAboutInvalidateContextType = new Set();\n    var didWarnOnInvalidCallback = new Set();\n    var classComponentUpdater = {\n        isMounted: function () {\n          return !1;\n        },\n        enqueueSetState: function (inst, payload, callback) {\n          var internals = inst._reactInternals;\n          null === internals.queue\n            ? warnNoop(inst, \"setState\")\n            : (internals.queue.push(payload),\n              void 0 !== callback &&\n                null !== callback &&\n                warnOnInvalidCallback(callback));\n        },\n        enqueueReplaceState: function (inst, payload, callback) {\n          inst = inst._reactInternals;\n          inst.replace = !0;\n          inst.queue = [payload];\n          void 0 !== callback &&\n            null !== callback &&\n            warnOnInvalidCallback(callback);\n        },\n        enqueueForceUpdate: function (inst, callback) {\n          null === inst._reactInternals.queue\n            ? warnNoop(inst, \"forceUpdate\")\n            : void 0 !== callback &&\n              null !== callback &&\n              warnOnInvalidCallback(callback);\n        }\n      },\n      emptyTreeContext = { id: 1, overflow: \"\" },\n      clz32 = Math.clz32 ? Math.clz32 : clz32Fallback,\n      log = Math.log,\n      LN2 = Math.LN2,\n      SuspenseException = Error(\n        \"Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\\n\\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`.\"\n      ),\n      suspendedThenable = null,\n      objectIs = \"function\" === typeof Object.is ? Object.is : is,\n      currentlyRenderingComponent = null,\n      currentlyRenderingTask = null,\n      currentlyRenderingRequest = null,\n      currentlyRenderingKeyPath = null,\n      firstWorkInProgressHook = null,\n      workInProgressHook = null,\n      isReRender = !1,\n      didScheduleRenderPhaseUpdate = !1,\n      localIdCounter = 0,\n      actionStateCounter = 0,\n      actionStateMatchingIndex = -1,\n      thenableIndexCounter = 0,\n      thenableState = null,\n      renderPhaseUpdates = null,\n      numberOfReRenders = 0,\n      isInHookUserCodeInDev = !1,\n      currentHookNameInDev,\n      HooksDispatcher = {\n        readContext: readContext,\n        use: function (usable) {\n          if (null !== usable && \"object\" === typeof usable) {\n            if (\"function\" === typeof usable.then)\n              return unwrapThenable(usable);\n            if (usable.$$typeof === REACT_CONTEXT_TYPE)\n              return readContext(usable);\n          }\n          throw Error(\n            \"An unsupported type was passed to use(): \" + String(usable)\n          );\n        },\n        useContext: function (context) {\n          currentHookNameInDev = \"useContext\";\n          resolveCurrentlyRenderingComponent();\n          return context._currentValue2;\n        },\n        useMemo: useMemo,\n        useReducer: useReducer,\n        useRef: function (initialValue) {\n          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n          workInProgressHook = createWorkInProgressHook();\n          var previousRef = workInProgressHook.memoizedState;\n          return null === previousRef\n            ? ((initialValue = { current: initialValue }),\n              Object.seal(initialValue),\n              (workInProgressHook.memoizedState = initialValue))\n            : previousRef;\n        },\n        useState: function (initialState) {\n          currentHookNameInDev = \"useState\";\n          return useReducer(basicStateReducer, initialState);\n        },\n        useInsertionEffect: noop$1,\n        useLayoutEffect: noop$1,\n        useCallback: function (callback, deps) {\n          return useMemo(function () {\n            return callback;\n          }, deps);\n        },\n        useImperativeHandle: noop$1,\n        useEffect: noop$1,\n        useDebugValue: noop$1,\n        useDeferredValue: function (value, initialValue) {\n          resolveCurrentlyRenderingComponent();\n          return void 0 !== initialValue ? initialValue : value;\n        },\n        useTransition: function () {\n          resolveCurrentlyRenderingComponent();\n          return [!1, unsupportedStartTransition];\n        },\n        useId: function () {\n          var treeId = currentlyRenderingTask.treeContext;\n          var overflow = treeId.overflow;\n          treeId = treeId.id;\n          treeId =\n            (treeId & ~(1 << (32 - clz32(treeId) - 1))).toString(32) + overflow;\n          var resumableState = currentResumableState;\n          if (null === resumableState)\n            throw Error(\n              \"Invalid hook call. Hooks can only be called inside of the body of a function component.\"\n            );\n          overflow = localIdCounter++;\n          treeId = \":\" + resumableState.idPrefix + \"R\" + treeId;\n          0 < overflow && (treeId += \"H\" + overflow.toString(32));\n          return treeId + \":\";\n        },\n        useSyncExternalStore: function (\n          subscribe,\n          getSnapshot,\n          getServerSnapshot\n        ) {\n          if (void 0 === getServerSnapshot)\n            throw Error(\n              \"Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.\"\n            );\n          return getServerSnapshot();\n        },\n        useCacheRefresh: function () {\n          return unsupportedRefresh;\n        },\n        useMemoCache: function (size) {\n          for (var data = Array(size), i = 0; i < size; i++)\n            data[i] = REACT_MEMO_CACHE_SENTINEL;\n          return data;\n        },\n        useHostTransitionStatus: function () {\n          resolveCurrentlyRenderingComponent();\n          return NotPending;\n        },\n        useOptimistic: function (passthrough) {\n          resolveCurrentlyRenderingComponent();\n          return [passthrough, unsupportedSetOptimisticState];\n        }\n      };\n    HooksDispatcher.useFormState = useActionState;\n    HooksDispatcher.useActionState = useActionState;\n    var currentResumableState = null,\n      currentTaskInDEV = null,\n      DefaultAsyncDispatcher = {\n        getCacheForType: function () {\n          throw Error(\"Not implemented.\");\n        },\n        getOwner: function () {\n          return null === currentTaskInDEV\n            ? null\n            : currentTaskInDEV.componentStack;\n        }\n      },\n      disabledDepth = 0,\n      prevLog,\n      prevInfo,\n      prevWarn,\n      prevError,\n      prevGroup,\n      prevGroupCollapsed,\n      prevGroupEnd;\n    disabledLog.__reactDisabledLog = !0;\n    var prefix,\n      suffix,\n      reentry = !1;\n    var componentFrameCache = new (\n      \"function\" === typeof WeakMap ? WeakMap : Map\n    )();\n    var callComponent = {\n        \"react-stack-bottom-frame\": function (Component, props, secondArg) {\n          return Component(props, secondArg);\n        }\n      },\n      callComponentInDEV =\n        callComponent[\"react-stack-bottom-frame\"].bind(callComponent),\n      callRender = {\n        \"react-stack-bottom-frame\": function (instance) {\n          return instance.render();\n        }\n      },\n      callRenderInDEV = callRender[\"react-stack-bottom-frame\"].bind(callRender),\n      callLazyInit = {\n        \"react-stack-bottom-frame\": function (lazy) {\n          var init = lazy._init;\n          return init(lazy._payload);\n        }\n      },\n      callLazyInitInDEV =\n        callLazyInit[\"react-stack-bottom-frame\"].bind(callLazyInit),\n      CLIENT_RENDERED = 4,\n      PENDING = 0,\n      COMPLETED = 1,\n      FLUSHED = 2,\n      POSTPONED = 5,\n      CLOSED = 14,\n      currentRequest = null,\n      didWarnAboutBadClass = {},\n      didWarnAboutContextTypes = {},\n      didWarnAboutContextTypeOnFunctionComponent = {},\n      didWarnAboutGetDerivedStateOnFunctionComponent = {},\n      didWarnAboutReassigningProps = !1,\n      didWarnAboutGenerators = !1,\n      didWarnAboutMaps = !1;\n    exports.renderToStaticMarkup = function (children, options) {\n      return renderToStringImpl(\n        children,\n        options,\n        !0,\n        'The server used \"renderToStaticMarkup\" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to \"renderToReadableStream\" which supports Suspense on the server'\n      );\n    };\n    exports.renderToString = function (children, options) {\n      return renderToStringImpl(\n        children,\n        options,\n        !1,\n        'The server used \"renderToString\" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to \"renderToReadableStream\" which supports Suspense on the server'\n      );\n    };\n    exports.version = \"19.0.0-rc-65e06cb7-20241218\";\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QtZG9tL2Nqcy9yZWFjdC1kb20tc2VydmVyLWxlZ2FjeS5icm93c2VyLmRldmVsb3BtZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7QUFDYixLQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsSUFBSTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwwQkFBMEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw2Q0FBNkM7QUFDbkUsc0JBQXNCLDRDQUE0QztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxJQUFJO0FBQ3RDO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSx5QkFBeUIsNkJBQTZCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsaUJBQWlCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLHNCQUFzQjtBQUN0QjtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsY0FBYztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtKQUFrSixpQkFBaUI7QUFDbks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrSkFBa0osaUJBQWlCLG1EQUFtRCxtQkFBbUIsV0FBVywrQkFBK0I7QUFDblI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGLEdBQUc7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MscUJBQXFCO0FBQ3ZEO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLHdCQUF3QjtBQUN4Qiw0QkFBNEIsV0FBVyxlQUFlLG1CQUFtQjtBQUN6RSwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLDJCQUEyQjtBQUMzQixrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrSEFBa0gsOEJBQThCO0FBQ2hKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxZQUFZO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwwQkFBMEI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdWZBQXVmLFdBQVcsMExBQTBMLFNBQVMsV0FBVyxFQUFFO0FBQ2x0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLFlBQVk7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNEJBQTRCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxzQkFBc0I7QUFDekU7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0NBQW9DO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwyQkFBMkI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGFBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixpQkFBaUI7QUFDakIscUJBQXFCLFdBQVcsZUFBZSxtQkFBbUI7QUFDbEUsbUJBQW1CO0FBQ25CO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyw0QkFBNEI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHFCQUFxQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHdCQUF3QixXQUFXLGdCQUFnQjtBQUNuRCx5QkFBeUIsV0FBVyxpQkFBaUI7QUFDckQseUJBQXlCLFdBQVcsaUJBQWlCO0FBQ3JELDBCQUEwQixXQUFXLGtCQUFrQjtBQUN2RCwwQkFBMEIsV0FBVyxrQkFBa0I7QUFDdkQsbUNBQW1DLFdBQVcsMkJBQTJCO0FBQ3pFLDZCQUE2QixXQUFXLHFCQUFxQjtBQUM3RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixzQkFBc0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDBCQUEwQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0RBQWdEO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxxQ0FBcUM7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMEJBQTBCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGtCQUFrQixnQkFBZ0I7QUFDdkU7QUFDQTtBQUNBLFFBQVE7QUFDUiw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix3QkFBd0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLHlEQUF5RDtBQUN6RDtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDJCQUEyQjtBQUM1RCx3Q0FBd0Msb0JBQW9CO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw4QkFBOEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxnQ0FBZ0M7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsbUNBQW1DLGdDQUFnQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFDQUFxQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0NBQWdDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsOEJBQThCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw0QkFBNEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsc0dBQTBCO0FBQ2xELGlCQUFpQixtQkFBTyxDQUFDLDhHQUE4QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsMkJBQTJCO0FBQzNCLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxpQ0FBaUM7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixvQ0FBb0M7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixvQ0FBb0M7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9DQUFvQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtDQUFrQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MscUJBQXFCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFDQUFxQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyx3QkFBd0IsNENBQTRDLE1BQU0sbUNBQW1DLHNCQUFzQixrVkFBa1YsRUFBRTtBQUN0Z0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw2QkFBNkIsNkJBQTZCLGdDQUFnQyxhQUFhLDJDQUEyQyw2QkFBNkI7QUFDMU07QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNkJBQTZCLDRCQUE0QixpQ0FBaUMsTUFBTSxvQkFBb0IsK0NBQStDLEtBQUssZUFBZSxnQkFBZ0IsUUFBUSxHQUFHLHNCQUFzQixhQUFhLDJCQUEyQixTQUFTLHFDQUFxQyxnQkFBZ0IsaUJBQWlCLElBQUksU0FBUyxLQUFLLGFBQWEsZ0NBQWdDLFdBQVcsaUNBQWlDO0FBQ3ZlO0FBQ0E7QUFDQSw2QkFBNkIsNkJBQTZCLDRCQUE0QixpQ0FBaUMsTUFBTSxvQkFBb0IsK0NBQStDLEtBQUssZUFBZSxnQkFBZ0IsUUFBUSxHQUFHLHNCQUFzQixhQUFhLDJCQUEyQixTQUFTLHFDQUFxQyxnQkFBZ0IsaUJBQWlCLElBQUksU0FBUyxLQUFLLGFBQWEsZ0NBQWdDLFdBQVcsaUNBQWlDLFlBQVksc0JBQXNCLGNBQWMsYUFBYSxJQUFJLDJIQUEySCxTQUFTLHFJQUFxSSxJQUFJLEtBQUssUUFBUSxVQUFVLEVBQUUsTUFBTSxhQUFhLE9BQU8sS0FBSyxJQUFJLFNBQVMsYUFBYSxhQUFhLGVBQWUsV0FBVyxLQUFLLEtBQUssMEJBQTBCLFdBQVcsbUJBQW1CLGtDQUFrQyxTQUFTLDBCQUEwQixpQ0FBaUMscUJBQXFCLHNCQUFzQixFQUFFLFdBQVcsMEJBQTBCLHlDQUF5QyxjQUFjLEtBQUssU0FBUyxZQUFZLG9DQUFvQywyQkFBMkIsY0FBYyxhQUFhLFdBQVcsdUZBQXVGLHVGQUF1RjtBQUM1Z0Q7QUFDQSxxQkFBcUIsc0JBQXNCLGNBQWMsYUFBYSxJQUFJLDJIQUEySCxTQUFTLHFJQUFxSSxJQUFJLEtBQUssUUFBUSxVQUFVLEVBQUUsTUFBTSxhQUFhLE9BQU8sS0FBSyxJQUFJLFNBQVMsYUFBYSxhQUFhLGVBQWUsV0FBVyxLQUFLLEtBQUssMEJBQTBCLFdBQVcsbUJBQW1CLGtDQUFrQyxTQUFTLDBCQUEwQixpQ0FBaUMscUJBQXFCLHNCQUFzQixFQUFFLFdBQVcsMEJBQTBCLHlDQUF5QyxjQUFjLEtBQUssU0FBUyxZQUFZLG9DQUFvQywyQkFBMkIsY0FBYyxhQUFhLFdBQVcsdUZBQXVGLHVGQUF1RjtBQUM5aUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGlDQUFpQywwSUFBMEk7QUFDNU07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsMkJBQTJCLHFCQUFxQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx1QkFBdUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsOENBQThDLFVBQVU7QUFDeEQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsbUNBQW1DO0FBQ25DLHFEQUFxRDtBQUNyRCx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsSUFBSSw0QkFBNEI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHNCQUFzQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZUFBZTtBQUNuQixHQUFHIiwic291cmNlcyI6WyIvVXNlcnMvd29uZGVybGFuZG1pdGNoL0Nhc2NhZGVQcm9qZWN0cy9Xb25kZXJWaXRlLWZyb250ZW5kL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QtZG9tL2Nqcy9yZWFjdC1kb20tc2VydmVyLWxlZ2FjeS5icm93c2VyLmRldmVsb3BtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWRvbS1zZXJ2ZXItbGVnYWN5LmJyb3dzZXIuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbi8qXG5cblxuIEpTIEltcGxlbWVudGF0aW9uIG9mIE11cm11ckhhc2gzIChyMTM2KSAoYXMgb2YgTWF5IDIwLCAyMDExKVxuXG4gQ29weXJpZ2h0IChjKSAyMDExIEdhcnkgQ291cnRcbiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiBTT0ZUV0FSRS5cbiovXG5cInVzZSBzdHJpY3RcIjtcblwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViAmJlxuICAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIHN0eWxlUmVwbGFjZXIobWF0Y2gsIHByZWZpeCwgcywgc3VmZml4KSB7XG4gICAgICByZXR1cm4gXCJcIiArIHByZWZpeCArIChcInNcIiA9PT0gcyA/IFwiXFxcXDczIFwiIDogXCJcXFxcNTMgXCIpICsgc3VmZml4O1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY3JpcHRSZXBsYWNlcihtYXRjaCwgcHJlZml4LCBzLCBzdWZmaXgpIHtcbiAgICAgIHJldHVybiBcIlwiICsgcHJlZml4ICsgKFwic1wiID09PSBzID8gXCJcXFxcdTAwNzNcIiA6IFwiXFxcXHUwMDUzXCIpICsgc3VmZml4O1xuICAgIH1cbiAgICBmdW5jdGlvbiBvYmplY3ROYW1lKG9iamVjdCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcbiAgICAgICAgLmNhbGwob2JqZWN0KVxuICAgICAgICAucmVwbGFjZSgvXlxcW29iamVjdCAoLiopXFxdJC8sIGZ1bmN0aW9uIChtLCBwMCkge1xuICAgICAgICAgIHJldHVybiBwMDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlS2V5Rm9yRXJyb3JNZXNzYWdlKGtleSkge1xuICAgICAgdmFyIGVuY29kZWRLZXkgPSBKU09OLnN0cmluZ2lmeShrZXkpO1xuICAgICAgcmV0dXJuICdcIicgKyBrZXkgKyAnXCInID09PSBlbmNvZGVkS2V5ID8ga2V5IDogZW5jb2RlZEtleTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVWYWx1ZUZvckVycm9yTWVzc2FnZSh2YWx1ZSkge1xuICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgIDEwID49IHZhbHVlLmxlbmd0aCA/IHZhbHVlIDogdmFsdWUuc2xpY2UoMCwgMTApICsgXCIuLi5cIlxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICBpZiAoaXNBcnJheUltcGwodmFsdWUpKSByZXR1cm4gXCJbLi4uXVwiO1xuICAgICAgICAgIGlmIChudWxsICE9PSB2YWx1ZSAmJiB2YWx1ZS4kJHR5cGVvZiA9PT0gQ0xJRU5UX1JFRkVSRU5DRV9UQUcpXG4gICAgICAgICAgICByZXR1cm4gXCJjbGllbnRcIjtcbiAgICAgICAgICB2YWx1ZSA9IG9iamVjdE5hbWUodmFsdWUpO1xuICAgICAgICAgIHJldHVybiBcIk9iamVjdFwiID09PSB2YWx1ZSA/IFwiey4uLn1cIiA6IHZhbHVlO1xuICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICByZXR1cm4gdmFsdWUuJCR0eXBlb2YgPT09IENMSUVOVF9SRUZFUkVOQ0VfVEFHXG4gICAgICAgICAgICA/IFwiY2xpZW50XCJcbiAgICAgICAgICAgIDogKHZhbHVlID0gdmFsdWUuZGlzcGxheU5hbWUgfHwgdmFsdWUubmFtZSlcbiAgICAgICAgICAgICAgPyBcImZ1bmN0aW9uIFwiICsgdmFsdWVcbiAgICAgICAgICAgICAgOiBcImZ1bmN0aW9uXCI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlRWxlbWVudFR5cGUodHlwZSkge1xuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKSByZXR1cm4gdHlwZTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VMaXN0XCI7XG4gICAgICB9XG4gICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZUVsZW1lbnRUeXBlKHR5cGUucmVuZGVyKTtcbiAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZUVsZW1lbnRUeXBlKHR5cGUudHlwZSk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICB2YXIgcGF5bG9hZCA9IHR5cGUuX3BheWxvYWQ7XG4gICAgICAgICAgICB0eXBlID0gdHlwZS5faW5pdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiBkZXNjcmliZUVsZW1lbnRUeXBlKHR5cGUocGF5bG9hZCkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlT2JqZWN0Rm9yRXJyb3JNZXNzYWdlKG9iamVjdE9yQXJyYXksIGV4cGFuZGVkTmFtZSkge1xuICAgICAgdmFyIG9iaktpbmQgPSBvYmplY3ROYW1lKG9iamVjdE9yQXJyYXkpO1xuICAgICAgaWYgKFwiT2JqZWN0XCIgIT09IG9iaktpbmQgJiYgXCJBcnJheVwiICE9PSBvYmpLaW5kKSByZXR1cm4gb2JqS2luZDtcbiAgICAgIHZhciBzdGFydCA9IC0xLFxuICAgICAgICBsZW5ndGggPSAwO1xuICAgICAgaWYgKGlzQXJyYXlJbXBsKG9iamVjdE9yQXJyYXkpKVxuICAgICAgICBpZiAoanN4Q2hpbGRyZW5QYXJlbnRzLmhhcyhvYmplY3RPckFycmF5KSkge1xuICAgICAgICAgIHZhciB0eXBlID0ganN4Q2hpbGRyZW5QYXJlbnRzLmdldChvYmplY3RPckFycmF5KTtcbiAgICAgICAgICBvYmpLaW5kID0gXCI8XCIgKyBkZXNjcmliZUVsZW1lbnRUeXBlKHR5cGUpICsgXCI+XCI7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3RPckFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBvYmplY3RPckFycmF5W2ldO1xuICAgICAgICAgICAgdmFsdWUgPVxuICAgICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgdmFsdWVcbiAgICAgICAgICAgICAgICA/IHZhbHVlXG4gICAgICAgICAgICAgICAgOiBcIm9iamVjdFwiID09PSB0eXBlb2YgdmFsdWUgJiYgbnVsbCAhPT0gdmFsdWVcbiAgICAgICAgICAgICAgICAgID8gXCJ7XCIgKyBkZXNjcmliZU9iamVjdEZvckVycm9yTWVzc2FnZSh2YWx1ZSkgKyBcIn1cIlxuICAgICAgICAgICAgICAgICAgOiBcIntcIiArIGRlc2NyaWJlVmFsdWVGb3JFcnJvck1lc3NhZ2UodmFsdWUpICsgXCJ9XCI7XG4gICAgICAgICAgICBcIlwiICsgaSA9PT0gZXhwYW5kZWROYW1lXG4gICAgICAgICAgICAgID8gKChzdGFydCA9IG9iaktpbmQubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAobGVuZ3RoID0gdmFsdWUubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAob2JqS2luZCArPSB2YWx1ZSkpXG4gICAgICAgICAgICAgIDogKG9iaktpbmQgPVxuICAgICAgICAgICAgICAgICAgMTUgPiB2YWx1ZS5sZW5ndGggJiYgNDAgPiBvYmpLaW5kLmxlbmd0aCArIHZhbHVlLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICA/IG9iaktpbmQgKyB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICA6IG9iaktpbmQgKyBcInsuLi59XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvYmpLaW5kICs9IFwiPC9cIiArIGRlc2NyaWJlRWxlbWVudFR5cGUodHlwZSkgKyBcIj5cIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvYmpLaW5kID0gXCJbXCI7XG4gICAgICAgICAgZm9yICh0eXBlID0gMDsgdHlwZSA8IG9iamVjdE9yQXJyYXkubGVuZ3RoOyB0eXBlKyspXG4gICAgICAgICAgICAwIDwgdHlwZSAmJiAob2JqS2luZCArPSBcIiwgXCIpLFxuICAgICAgICAgICAgICAoaSA9IG9iamVjdE9yQXJyYXlbdHlwZV0pLFxuICAgICAgICAgICAgICAoaSA9XG4gICAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGkgJiYgbnVsbCAhPT0gaVxuICAgICAgICAgICAgICAgICAgPyBkZXNjcmliZU9iamVjdEZvckVycm9yTWVzc2FnZShpKVxuICAgICAgICAgICAgICAgICAgOiBkZXNjcmliZVZhbHVlRm9yRXJyb3JNZXNzYWdlKGkpKSxcbiAgICAgICAgICAgICAgXCJcIiArIHR5cGUgPT09IGV4cGFuZGVkTmFtZVxuICAgICAgICAgICAgICAgID8gKChzdGFydCA9IG9iaktpbmQubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgIChsZW5ndGggPSBpLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgICAob2JqS2luZCArPSBpKSlcbiAgICAgICAgICAgICAgICA6IChvYmpLaW5kID1cbiAgICAgICAgICAgICAgICAgICAgMTAgPiBpLmxlbmd0aCAmJiA0MCA+IG9iaktpbmQubGVuZ3RoICsgaS5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICA/IG9iaktpbmQgKyBpXG4gICAgICAgICAgICAgICAgICAgICAgOiBvYmpLaW5kICsgXCIuLi5cIik7XG4gICAgICAgICAgb2JqS2luZCArPSBcIl1cIjtcbiAgICAgICAgfVxuICAgICAgZWxzZSBpZiAob2JqZWN0T3JBcnJheS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKVxuICAgICAgICBvYmpLaW5kID0gXCI8XCIgKyBkZXNjcmliZUVsZW1lbnRUeXBlKG9iamVjdE9yQXJyYXkudHlwZSkgKyBcIi8+XCI7XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKG9iamVjdE9yQXJyYXkuJCR0eXBlb2YgPT09IENMSUVOVF9SRUZFUkVOQ0VfVEFHKSByZXR1cm4gXCJjbGllbnRcIjtcbiAgICAgICAgaWYgKGpzeFByb3BzUGFyZW50cy5oYXMob2JqZWN0T3JBcnJheSkpIHtcbiAgICAgICAgICBvYmpLaW5kID0ganN4UHJvcHNQYXJlbnRzLmdldChvYmplY3RPckFycmF5KTtcbiAgICAgICAgICBvYmpLaW5kID0gXCI8XCIgKyAoZGVzY3JpYmVFbGVtZW50VHlwZShvYmpLaW5kKSB8fCBcIi4uLlwiKTtcbiAgICAgICAgICB0eXBlID0gT2JqZWN0LmtleXMob2JqZWN0T3JBcnJheSk7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IHR5cGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG9iaktpbmQgKz0gXCIgXCI7XG4gICAgICAgICAgICB2YWx1ZSA9IHR5cGVbaV07XG4gICAgICAgICAgICBvYmpLaW5kICs9IGRlc2NyaWJlS2V5Rm9yRXJyb3JNZXNzYWdlKHZhbHVlKSArIFwiPVwiO1xuICAgICAgICAgICAgdmFyIF92YWx1ZTIgPSBvYmplY3RPckFycmF5W3ZhbHVlXTtcbiAgICAgICAgICAgIHZhciBfc3Vic3RyMiA9XG4gICAgICAgICAgICAgIHZhbHVlID09PSBleHBhbmRlZE5hbWUgJiZcbiAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIF92YWx1ZTIgJiZcbiAgICAgICAgICAgICAgbnVsbCAhPT0gX3ZhbHVlMlxuICAgICAgICAgICAgICAgID8gZGVzY3JpYmVPYmplY3RGb3JFcnJvck1lc3NhZ2UoX3ZhbHVlMilcbiAgICAgICAgICAgICAgICA6IGRlc2NyaWJlVmFsdWVGb3JFcnJvck1lc3NhZ2UoX3ZhbHVlMik7XG4gICAgICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2YgX3ZhbHVlMiAmJiAoX3N1YnN0cjIgPSBcIntcIiArIF9zdWJzdHIyICsgXCJ9XCIpO1xuICAgICAgICAgICAgdmFsdWUgPT09IGV4cGFuZGVkTmFtZVxuICAgICAgICAgICAgICA/ICgoc3RhcnQgPSBvYmpLaW5kLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgKGxlbmd0aCA9IF9zdWJzdHIyLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgKG9iaktpbmQgKz0gX3N1YnN0cjIpKVxuICAgICAgICAgICAgICA6IChvYmpLaW5kID1cbiAgICAgICAgICAgICAgICAgIDEwID4gX3N1YnN0cjIubGVuZ3RoICYmIDQwID4gb2JqS2luZC5sZW5ndGggKyBfc3Vic3RyMi5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgPyBvYmpLaW5kICsgX3N1YnN0cjJcbiAgICAgICAgICAgICAgICAgICAgOiBvYmpLaW5kICsgXCIuLi5cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9iaktpbmQgKz0gXCI+XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2JqS2luZCA9IFwie1wiO1xuICAgICAgICAgIHR5cGUgPSBPYmplY3Qua2V5cyhvYmplY3RPckFycmF5KTtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdHlwZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIDAgPCBpICYmIChvYmpLaW5kICs9IFwiLCBcIiksXG4gICAgICAgICAgICAgICh2YWx1ZSA9IHR5cGVbaV0pLFxuICAgICAgICAgICAgICAob2JqS2luZCArPSBkZXNjcmliZUtleUZvckVycm9yTWVzc2FnZSh2YWx1ZSkgKyBcIjogXCIpLFxuICAgICAgICAgICAgICAoX3ZhbHVlMiA9IG9iamVjdE9yQXJyYXlbdmFsdWVdKSxcbiAgICAgICAgICAgICAgKF92YWx1ZTIgPVxuICAgICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBfdmFsdWUyICYmIG51bGwgIT09IF92YWx1ZTJcbiAgICAgICAgICAgICAgICAgID8gZGVzY3JpYmVPYmplY3RGb3JFcnJvck1lc3NhZ2UoX3ZhbHVlMilcbiAgICAgICAgICAgICAgICAgIDogZGVzY3JpYmVWYWx1ZUZvckVycm9yTWVzc2FnZShfdmFsdWUyKSksXG4gICAgICAgICAgICAgIHZhbHVlID09PSBleHBhbmRlZE5hbWVcbiAgICAgICAgICAgICAgICA/ICgoc3RhcnQgPSBvYmpLaW5kLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgICAobGVuZ3RoID0gX3ZhbHVlMi5sZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgKG9iaktpbmQgKz0gX3ZhbHVlMikpXG4gICAgICAgICAgICAgICAgOiAob2JqS2luZCA9XG4gICAgICAgICAgICAgICAgICAgIDEwID4gX3ZhbHVlMi5sZW5ndGggJiYgNDAgPiBvYmpLaW5kLmxlbmd0aCArIF92YWx1ZTIubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgPyBvYmpLaW5kICsgX3ZhbHVlMlxuICAgICAgICAgICAgICAgICAgICAgIDogb2JqS2luZCArIFwiLi4uXCIpO1xuICAgICAgICAgIG9iaktpbmQgKz0gXCJ9XCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDAgPT09IGV4cGFuZGVkTmFtZVxuICAgICAgICA/IG9iaktpbmRcbiAgICAgICAgOiAtMSA8IHN0YXJ0ICYmIDAgPCBsZW5ndGhcbiAgICAgICAgICA/ICgob2JqZWN0T3JBcnJheSA9IFwiIFwiLnJlcGVhdChzdGFydCkgKyBcIl5cIi5yZXBlYXQobGVuZ3RoKSksXG4gICAgICAgICAgICBcIlxcbiAgXCIgKyBvYmpLaW5kICsgXCJcXG4gIFwiICsgb2JqZWN0T3JBcnJheSlcbiAgICAgICAgICA6IFwiXFxuICBcIiArIG9iaktpbmQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG11cm11cmhhc2gzXzMyX2djKGtleSwgc2VlZCkge1xuICAgICAgdmFyIHJlbWFpbmRlciA9IGtleS5sZW5ndGggJiAzO1xuICAgICAgdmFyIGJ5dGVzID0ga2V5Lmxlbmd0aCAtIHJlbWFpbmRlcjtcbiAgICAgIHZhciBoMSA9IHNlZWQ7XG4gICAgICBmb3IgKHNlZWQgPSAwOyBzZWVkIDwgYnl0ZXM7ICkge1xuICAgICAgICB2YXIgazEgPVxuICAgICAgICAgIChrZXkuY2hhckNvZGVBdChzZWVkKSAmIDI1NSkgfFxuICAgICAgICAgICgoa2V5LmNoYXJDb2RlQXQoKytzZWVkKSAmIDI1NSkgPDwgOCkgfFxuICAgICAgICAgICgoa2V5LmNoYXJDb2RlQXQoKytzZWVkKSAmIDI1NSkgPDwgMTYpIHxcbiAgICAgICAgICAoKGtleS5jaGFyQ29kZUF0KCsrc2VlZCkgJiAyNTUpIDw8IDI0KTtcbiAgICAgICAgKytzZWVkO1xuICAgICAgICBrMSA9XG4gICAgICAgICAgKDM0MzI5MTgzNTMgKiAoazEgJiA2NTUzNSkgK1xuICAgICAgICAgICAgKCgoMzQzMjkxODM1MyAqIChrMSA+Pj4gMTYpKSAmIDY1NTM1KSA8PCAxNikpICZcbiAgICAgICAgICA0Mjk0OTY3Mjk1O1xuICAgICAgICBrMSA9IChrMSA8PCAxNSkgfCAoazEgPj4+IDE3KTtcbiAgICAgICAgazEgPVxuICAgICAgICAgICg0NjE4NDU5MDcgKiAoazEgJiA2NTUzNSkgK1xuICAgICAgICAgICAgKCgoNDYxODQ1OTA3ICogKGsxID4+PiAxNikpICYgNjU1MzUpIDw8IDE2KSkgJlxuICAgICAgICAgIDQyOTQ5NjcyOTU7XG4gICAgICAgIGgxIF49IGsxO1xuICAgICAgICBoMSA9IChoMSA8PCAxMykgfCAoaDEgPj4+IDE5KTtcbiAgICAgICAgaDEgPVxuICAgICAgICAgICg1ICogKGgxICYgNjU1MzUpICsgKCgoNSAqIChoMSA+Pj4gMTYpKSAmIDY1NTM1KSA8PCAxNikpICYgNDI5NDk2NzI5NTtcbiAgICAgICAgaDEgPSAoaDEgJiA2NTUzNSkgKyAyNzQ5MiArICgoKChoMSA+Pj4gMTYpICsgNTg5NjQpICYgNjU1MzUpIDw8IDE2KTtcbiAgICAgIH1cbiAgICAgIGsxID0gMDtcbiAgICAgIHN3aXRjaCAocmVtYWluZGVyKSB7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBrMSBePSAoa2V5LmNoYXJDb2RlQXQoc2VlZCArIDIpICYgMjU1KSA8PCAxNjtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGsxIF49IChrZXkuY2hhckNvZGVBdChzZWVkICsgMSkgJiAyNTUpIDw8IDg7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAoazEgXj0ga2V5LmNoYXJDb2RlQXQoc2VlZCkgJiAyNTUpLFxuICAgICAgICAgICAgKGsxID1cbiAgICAgICAgICAgICAgKDM0MzI5MTgzNTMgKiAoazEgJiA2NTUzNSkgK1xuICAgICAgICAgICAgICAgICgoKDM0MzI5MTgzNTMgKiAoazEgPj4+IDE2KSkgJiA2NTUzNSkgPDwgMTYpKSAmXG4gICAgICAgICAgICAgIDQyOTQ5NjcyOTUpLFxuICAgICAgICAgICAgKGsxID0gKGsxIDw8IDE1KSB8IChrMSA+Pj4gMTcpKSxcbiAgICAgICAgICAgIChoMSBePVxuICAgICAgICAgICAgICAoNDYxODQ1OTA3ICogKGsxICYgNjU1MzUpICtcbiAgICAgICAgICAgICAgICAoKCg0NjE4NDU5MDcgKiAoazEgPj4+IDE2KSkgJiA2NTUzNSkgPDwgMTYpKSAmXG4gICAgICAgICAgICAgIDQyOTQ5NjcyOTUpO1xuICAgICAgfVxuICAgICAgaDEgXj0ga2V5Lmxlbmd0aDtcbiAgICAgIGgxIF49IGgxID4+PiAxNjtcbiAgICAgIGgxID1cbiAgICAgICAgKDIyNDY4MjI1MDcgKiAoaDEgJiA2NTUzNSkgK1xuICAgICAgICAgICgoKDIyNDY4MjI1MDcgKiAoaDEgPj4+IDE2KSkgJiA2NTUzNSkgPDwgMTYpKSAmXG4gICAgICAgIDQyOTQ5NjcyOTU7XG4gICAgICBoMSBePSBoMSA+Pj4gMTM7XG4gICAgICBoMSA9XG4gICAgICAgICgzMjY2NDg5OTA5ICogKGgxICYgNjU1MzUpICtcbiAgICAgICAgICAoKCgzMjY2NDg5OTA5ICogKGgxID4+PiAxNikpICYgNjU1MzUpIDw8IDE2KSkgJlxuICAgICAgICA0Mjk0OTY3Mjk1O1xuICAgICAgcmV0dXJuIChoMSBeIChoMSA+Pj4gMTYpKSA+Pj4gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdHlwZU5hbWUodmFsdWUpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBTeW1ib2wgJiZcbiAgICAgICAgICBTeW1ib2wudG9TdHJpbmdUYWcgJiZcbiAgICAgICAgICB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddKSB8fFxuICAgICAgICB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8XG4gICAgICAgIFwiT2JqZWN0XCJcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSwgITE7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBhdHRyaWJ1dGVOYW1lKSB7XG4gICAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIlRoZSBwcm92aWRlZCBgJXNgIGF0dHJpYnV0ZSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLiBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS5cIixcbiAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWUsXG4gICAgICAgICAgICB0eXBlTmFtZSh2YWx1ZSlcbiAgICAgICAgICApLFxuICAgICAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSlcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tDU1NQcm9wZXJ0eVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBwcm9wTmFtZSkge1xuICAgICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJUaGUgcHJvdmlkZWQgYCVzYCBDU1MgcHJvcGVydHkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuXCIsXG4gICAgICAgICAgICBwcm9wTmFtZSxcbiAgICAgICAgICAgIHR5cGVOYW1lKHZhbHVlKVxuICAgICAgICAgICksXG4gICAgICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKVxuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0h0bWxTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAgICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJUaGUgcHJvdmlkZWQgSFRNTCBtYXJrdXAgdXNlcyBhIHZhbHVlIG9mIHVuc3VwcG9ydGVkIHR5cGUgJXMuIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLlwiLFxuICAgICAgICAgICAgdHlwZU5hbWUodmFsdWUpXG4gICAgICAgICAgKSxcbiAgICAgICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzQXR0cmlidXRlTmFtZVNhZmUoYXR0cmlidXRlTmFtZSkge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlLCBhdHRyaWJ1dGVOYW1lKSlcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSwgYXR0cmlidXRlTmFtZSkpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGlmIChWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWC50ZXN0KGF0dHJpYnV0ZU5hbWUpKVxuICAgICAgICByZXR1cm4gKHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZVthdHRyaWJ1dGVOYW1lXSA9ICEwKTtcbiAgICAgIGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSAhMDtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lOiBgJXNgXCIsIGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0NvbnRyb2xsZWRWYWx1ZVByb3BzKHRhZ05hbWUsIHByb3BzKSB7XG4gICAgICBoYXNSZWFkT25seVZhbHVlW3Byb3BzLnR5cGVdIHx8XG4gICAgICAgIHByb3BzLm9uQ2hhbmdlIHx8XG4gICAgICAgIHByb3BzLm9uSW5wdXQgfHxcbiAgICAgICAgcHJvcHMucmVhZE9ubHkgfHxcbiAgICAgICAgcHJvcHMuZGlzYWJsZWQgfHxcbiAgICAgICAgbnVsbCA9PSBwcm9wcy52YWx1ZSB8fFxuICAgICAgICAoXCJzZWxlY3RcIiA9PT0gdGFnTmFtZVxuICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJZb3UgcHJvdmlkZWQgYSBgdmFsdWVgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiB0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0VmFsdWVgLiBPdGhlcndpc2UsIHNldCBgb25DaGFuZ2VgLlwiXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIllvdSBwcm92aWRlZCBhIGB2YWx1ZWAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiBgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmIHRoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRWYWx1ZWAuIE90aGVyd2lzZSwgc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuXCJcbiAgICAgICAgICAgICkpO1xuICAgICAgcHJvcHMub25DaGFuZ2UgfHxcbiAgICAgICAgcHJvcHMucmVhZE9ubHkgfHxcbiAgICAgICAgcHJvcHMuZGlzYWJsZWQgfHxcbiAgICAgICAgbnVsbCA9PSBwcm9wcy5jaGVja2VkIHx8XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJZb3UgcHJvdmlkZWQgYSBgY2hlY2tlZGAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiBgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmIHRoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRDaGVja2VkYC4gT3RoZXJ3aXNlLCBzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC5cIlxuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnR5JDEodGFnTmFtZSwgbmFtZSkge1xuICAgICAgaWYgKFxuICAgICAgICBoYXNPd25Qcm9wZXJ0eS5jYWxsKHdhcm5lZFByb3BlcnRpZXMkMSwgbmFtZSkgJiZcbiAgICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdXG4gICAgICApXG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIGlmIChyQVJJQUNhbWVsJDEudGVzdChuYW1lKSkge1xuICAgICAgICB0YWdOYW1lID0gXCJhcmlhLVwiICsgbmFtZS5zbGljZSg0KS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB0YWdOYW1lID0gYXJpYVByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkodGFnTmFtZSkgPyB0YWdOYW1lIDogbnVsbDtcbiAgICAgICAgaWYgKG51bGwgPT0gdGFnTmFtZSlcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJJbnZhbGlkIEFSSUEgYXR0cmlidXRlIGAlc2AuIEFSSUEgYXR0cmlidXRlcyBmb2xsb3cgdGhlIHBhdHRlcm4gYXJpYS0qIGFuZCBtdXN0IGJlIGxvd2VyY2FzZS5cIixcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICh3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSAhMClcbiAgICAgICAgICApO1xuICAgICAgICBpZiAobmFtZSAhPT0gdGFnTmFtZSlcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJJbnZhbGlkIEFSSUEgYXR0cmlidXRlIGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgP1wiLFxuICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICB0YWdOYW1lXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgKHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9ICEwKVxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAockFSSUEkMS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHRhZ05hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHRhZ05hbWUgPSBhcmlhUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eSh0YWdOYW1lKSA/IHRhZ05hbWUgOiBudWxsO1xuICAgICAgICBpZiAobnVsbCA9PSB0YWdOYW1lKSByZXR1cm4gKHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9ICEwKSwgITE7XG4gICAgICAgIG5hbWUgIT09IHRhZ05hbWUgJiZcbiAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiVW5rbm93biBBUklBIGF0dHJpYnV0ZSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD9cIixcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICB0YWdOYW1lXG4gICAgICAgICAgKSxcbiAgICAgICAgICAod2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gITApKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzJDIodHlwZSwgcHJvcHMpIHtcbiAgICAgIHZhciBpbnZhbGlkUHJvcHMgPSBbXSxcbiAgICAgICAga2V5O1xuICAgICAgZm9yIChrZXkgaW4gcHJvcHMpXG4gICAgICAgIHZhbGlkYXRlUHJvcGVydHkkMSh0eXBlLCBrZXkpIHx8IGludmFsaWRQcm9wcy5wdXNoKGtleSk7XG4gICAgICBwcm9wcyA9IGludmFsaWRQcm9wc1xuICAgICAgICAubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgcmV0dXJuIFwiYFwiICsgcHJvcCArIFwiYFwiO1xuICAgICAgICB9KVxuICAgICAgICAuam9pbihcIiwgXCIpO1xuICAgICAgMSA9PT0gaW52YWxpZFByb3BzLmxlbmd0aFxuICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkludmFsaWQgYXJpYSBwcm9wICVzIG9uIDwlcz4gdGFnLiBGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvaW52YWxpZC1hcmlhLXByb3BzXCIsXG4gICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgIHR5cGVcbiAgICAgICAgICApXG4gICAgICAgIDogMSA8IGludmFsaWRQcm9wcy5sZW5ndGggJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJJbnZhbGlkIGFyaWEgcHJvcHMgJXMgb24gPCVzPiB0YWcuIEZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9pbnZhbGlkLWFyaWEtcHJvcHNcIixcbiAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgdHlwZVxuICAgICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydHkodGFnTmFtZSwgbmFtZSwgdmFsdWUsIGV2ZW50UmVnaXN0cnkpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHdhcm5lZFByb3BlcnRpZXMsIG5hbWUpICYmIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0pXG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmIChcIm9uZm9jdXNpblwiID09PSBsb3dlckNhc2VkTmFtZSB8fCBcIm9uZm9jdXNvdXRcIiA9PT0gbG93ZXJDYXNlZE5hbWUpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiUmVhY3QgdXNlcyBvbkZvY3VzIGFuZCBvbkJsdXIgaW5zdGVhZCBvZiBvbkZvY3VzSW4gYW5kIG9uRm9jdXNPdXQuIEFsbCBSZWFjdCBldmVudHMgYXJlIG5vcm1hbGl6ZWQgdG8gYnViYmxlLCBzbyBvbkZvY3VzSW4gYW5kIG9uRm9jdXNPdXQgYXJlIG5vdCBuZWVkZWQvc3VwcG9ydGVkIGJ5IFJlYWN0LlwiXG4gICAgICAgICAgKSxcbiAgICAgICAgICAod2FybmVkUHJvcGVydGllc1tuYW1lXSA9ICEwKVxuICAgICAgICApO1xuICAgICAgaWYgKFxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICAoKFwiZm9ybVwiID09PSB0YWdOYW1lICYmIFwiYWN0aW9uXCIgPT09IG5hbWUpIHx8XG4gICAgICAgICAgKFwiaW5wdXRcIiA9PT0gdGFnTmFtZSAmJiBcImZvcm1BY3Rpb25cIiA9PT0gbmFtZSkgfHxcbiAgICAgICAgICAoXCJidXR0b25cIiA9PT0gdGFnTmFtZSAmJiBcImZvcm1BY3Rpb25cIiA9PT0gbmFtZSkpXG4gICAgICApXG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIGlmIChudWxsICE9IGV2ZW50UmVnaXN0cnkpIHtcbiAgICAgICAgdGFnTmFtZSA9IGV2ZW50UmVnaXN0cnkucG9zc2libGVSZWdpc3RyYXRpb25OYW1lcztcbiAgICAgICAgaWYgKGV2ZW50UmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSlcbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgIGV2ZW50UmVnaXN0cnkgPSB0YWdOYW1lLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKVxuICAgICAgICAgID8gdGFnTmFtZVtsb3dlckNhc2VkTmFtZV1cbiAgICAgICAgICA6IG51bGw7XG4gICAgICAgIGlmIChudWxsICE9IGV2ZW50UmVnaXN0cnkpXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiSW52YWxpZCBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgP1wiLFxuICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICBldmVudFJlZ2lzdHJ5XG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgKHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSAhMClcbiAgICAgICAgICApO1xuICAgICAgICBpZiAoRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlVua25vd24gZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiBJdCB3aWxsIGJlIGlnbm9yZWQuXCIsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAod2FybmVkUHJvcGVydGllc1tuYW1lXSA9ICEwKVxuICAgICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKEVWRU5UX05BTUVfUkVHRVgudGVzdChuYW1lKSlcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBJTlZBTElEX0VWRU5UX05BTUVfUkVHRVgudGVzdChuYW1lKSAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJJbnZhbGlkIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gUmVhY3QgZXZlbnRzIHVzZSB0aGUgY2FtZWxDYXNlIG5hbWluZyBjb252ZW50aW9uLCBmb3IgZXhhbXBsZSBgb25DbGlja2AuXCIsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICksXG4gICAgICAgICAgKHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSAhMClcbiAgICAgICAgKTtcbiAgICAgIGlmIChyQVJJQS50ZXN0KG5hbWUpIHx8IHJBUklBQ2FtZWwudGVzdChuYW1lKSkgcmV0dXJuICEwO1xuICAgICAgaWYgKFwiaW5uZXJodG1sXCIgPT09IGxvd2VyQ2FzZWROYW1lKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkRpcmVjdGx5IHNldHRpbmcgcHJvcGVydHkgYGlubmVySFRNTGAgaXMgbm90IHBlcm1pdHRlZC4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIGxvb2t1cCBkb2N1bWVudGF0aW9uIG9uIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuXCJcbiAgICAgICAgICApLFxuICAgICAgICAgICh3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gITApXG4gICAgICAgICk7XG4gICAgICBpZiAoXCJhcmlhXCIgPT09IGxvd2VyQ2FzZWROYW1lKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIlRoZSBgYXJpYWAgYXR0cmlidXRlIGlzIHJlc2VydmVkIGZvciBmdXR1cmUgdXNlIGluIFJlYWN0LiBQYXNzIGluZGl2aWR1YWwgYGFyaWEtYCBhdHRyaWJ1dGVzIGluc3RlYWQuXCJcbiAgICAgICAgICApLFxuICAgICAgICAgICh3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gITApXG4gICAgICAgICk7XG4gICAgICBpZiAoXG4gICAgICAgIFwiaXNcIiA9PT0gbG93ZXJDYXNlZE5hbWUgJiZcbiAgICAgICAgbnVsbCAhPT0gdmFsdWUgJiZcbiAgICAgICAgdm9pZCAwICE9PSB2YWx1ZSAmJlxuICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2YgdmFsdWVcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJSZWNlaXZlZCBhIGAlc2AgZm9yIGEgc3RyaW5nIGF0dHJpYnV0ZSBgaXNgLiBJZiB0aGlzIGlzIGV4cGVjdGVkLCBjYXN0IHRoZSB2YWx1ZSB0byBhIHN0cmluZy5cIixcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZVxuICAgICAgICAgICksXG4gICAgICAgICAgKHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSAhMClcbiAgICAgICAgKTtcbiAgICAgIGlmIChcIm51bWJlclwiID09PSB0eXBlb2YgdmFsdWUgJiYgaXNOYU4odmFsdWUpKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIlJlY2VpdmVkIE5hTiBmb3IgdGhlIGAlc2AgYXR0cmlidXRlLiBJZiB0aGlzIGlzIGV4cGVjdGVkLCBjYXN0IHRoZSB2YWx1ZSB0byBhIHN0cmluZy5cIixcbiAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICApLFxuICAgICAgICAgICh3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gITApXG4gICAgICAgICk7XG4gICAgICBpZiAocG9zc2libGVTdGFuZGFyZE5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgKChsb3dlckNhc2VkTmFtZSA9IHBvc3NpYmxlU3RhbmRhcmROYW1lc1tsb3dlckNhc2VkTmFtZV0pLFxuICAgICAgICAgIGxvd2VyQ2FzZWROYW1lICE9PSBuYW1lKVxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiSW52YWxpZCBET00gcHJvcGVydHkgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/XCIsXG4gICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgIGxvd2VyQ2FzZWROYW1lXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgKHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSAhMClcbiAgICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmIChuYW1lICE9PSBsb3dlckNhc2VkTmFtZSlcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJSZWFjdCBkb2VzIG5vdCByZWNvZ25pemUgdGhlIGAlc2AgcHJvcCBvbiBhIERPTSBlbGVtZW50LiBJZiB5b3UgaW50ZW50aW9uYWxseSB3YW50IGl0IHRvIGFwcGVhciBpbiB0aGUgRE9NIGFzIGEgY3VzdG9tIGF0dHJpYnV0ZSwgc3BlbGwgaXQgYXMgbG93ZXJjYXNlIGAlc2AgaW5zdGVhZC4gSWYgeW91IGFjY2lkZW50YWxseSBwYXNzZWQgaXQgZnJvbSBhIHBhcmVudCBjb21wb25lbnQsIHJlbW92ZSBpdCBmcm9tIHRoZSBET00gZWxlbWVudC5cIixcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBsb3dlckNhc2VkTmFtZVxuICAgICAgICAgICksXG4gICAgICAgICAgKHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSAhMClcbiAgICAgICAgKTtcbiAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgICBjYXNlIFwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nXCI6XG4gICAgICAgIGNhc2UgXCJzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmdcIjpcbiAgICAgICAgY2FzZSBcImRlZmF1bHRWYWx1ZVwiOlxuICAgICAgICBjYXNlIFwiZGVmYXVsdENoZWNrZWRcIjpcbiAgICAgICAgY2FzZSBcImlubmVySFRNTFwiOlxuICAgICAgICBjYXNlIFwicmVmXCI6XG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICBjYXNlIFwiaW5uZXJUZXh0XCI6XG4gICAgICAgIGNhc2UgXCJ0ZXh0Q29udGVudFwiOlxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgICBjYXNlIFwiYXV0b0ZvY3VzXCI6XG4gICAgICAgICAgICBjYXNlIFwiY2hlY2tlZFwiOlxuICAgICAgICAgICAgY2FzZSBcIm11bHRpcGxlXCI6XG4gICAgICAgICAgICBjYXNlIFwibXV0ZWRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzZWxlY3RlZFwiOlxuICAgICAgICAgICAgY2FzZSBcImNvbnRlbnRFZGl0YWJsZVwiOlxuICAgICAgICAgICAgY2FzZSBcInNwZWxsQ2hlY2tcIjpcbiAgICAgICAgICAgIGNhc2UgXCJkcmFnZ2FibGVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJ2YWx1ZVwiOlxuICAgICAgICAgICAgY2FzZSBcImF1dG9SZXZlcnNlXCI6XG4gICAgICAgICAgICBjYXNlIFwiZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZFwiOlxuICAgICAgICAgICAgY2FzZSBcImZvY3VzYWJsZVwiOlxuICAgICAgICAgICAgY2FzZSBcInByZXNlcnZlQWxwaGFcIjpcbiAgICAgICAgICAgIGNhc2UgXCJhbGxvd0Z1bGxTY3JlZW5cIjpcbiAgICAgICAgICAgIGNhc2UgXCJhc3luY1wiOlxuICAgICAgICAgICAgY2FzZSBcImF1dG9QbGF5XCI6XG4gICAgICAgICAgICBjYXNlIFwiY29udHJvbHNcIjpcbiAgICAgICAgICAgIGNhc2UgXCJkZWZhdWx0XCI6XG4gICAgICAgICAgICBjYXNlIFwiZGVmZXJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJkaXNhYmxlZFwiOlxuICAgICAgICAgICAgY2FzZSBcImRpc2FibGVQaWN0dXJlSW5QaWN0dXJlXCI6XG4gICAgICAgICAgICBjYXNlIFwiZGlzYWJsZVJlbW90ZVBsYXliYWNrXCI6XG4gICAgICAgICAgICBjYXNlIFwiZm9ybU5vVmFsaWRhdGVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJoaWRkZW5cIjpcbiAgICAgICAgICAgIGNhc2UgXCJsb29wXCI6XG4gICAgICAgICAgICBjYXNlIFwibm9Nb2R1bGVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJub1ZhbGlkYXRlXCI6XG4gICAgICAgICAgICBjYXNlIFwib3BlblwiOlxuICAgICAgICAgICAgY2FzZSBcInBsYXlzSW5saW5lXCI6XG4gICAgICAgICAgICBjYXNlIFwicmVhZE9ubHlcIjpcbiAgICAgICAgICAgIGNhc2UgXCJyZXF1aXJlZFwiOlxuICAgICAgICAgICAgY2FzZSBcInJldmVyc2VkXCI6XG4gICAgICAgICAgICBjYXNlIFwic2NvcGVkXCI6XG4gICAgICAgICAgICBjYXNlIFwic2VhbWxlc3NcIjpcbiAgICAgICAgICAgIGNhc2UgXCJpdGVtU2NvcGVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJjYXB0dXJlXCI6XG4gICAgICAgICAgICBjYXNlIFwiZG93bmxvYWRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJpbmVydFwiOlxuICAgICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKS5zbGljZSgwLCA1KTtcbiAgICAgICAgICAgICAgaWYgKFwiZGF0YS1cIiA9PT0gbG93ZXJDYXNlZE5hbWUgfHwgXCJhcmlhLVwiID09PSBsb3dlckNhc2VkTmFtZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAnUmVjZWl2ZWQgYCVzYCBmb3IgYSBub24tYm9vbGVhbiBhdHRyaWJ1dGUgYCVzYC5cXG5cXG5JZiB5b3Ugd2FudCB0byB3cml0ZSBpdCB0byB0aGUgRE9NLCBwYXNzIGEgc3RyaW5nIGluc3RlYWQ6ICVzPVwiJXNcIiBvciAlcz17dmFsdWUudG9TdHJpbmcoKX0uJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgOiBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAnUmVjZWl2ZWQgYCVzYCBmb3IgYSBub24tYm9vbGVhbiBhdHRyaWJ1dGUgYCVzYC5cXG5cXG5JZiB5b3Ugd2FudCB0byB3cml0ZSBpdCB0byB0aGUgRE9NLCBwYXNzIGEgc3RyaW5nIGluc3RlYWQ6ICVzPVwiJXNcIiBvciAlcz17dmFsdWUudG9TdHJpbmcoKX0uXFxuXFxuSWYgeW91IHVzZWQgdG8gY29uZGl0aW9uYWxseSBvbWl0IGl0IHdpdGggJXM9e2NvbmRpdGlvbiAmJiB2YWx1ZX0sIHBhc3MgJXM9e2NvbmRpdGlvbiA/IHZhbHVlIDogdW5kZWZpbmVkfSBpbnN0ZWFkLicsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuICh3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gITApO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgICAgICByZXR1cm4gKHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSAhMCksICExO1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgaWYgKFwiZmFsc2VcIiA9PT0gdmFsdWUgfHwgXCJ0cnVlXCIgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcImNoZWNrZWRcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInNlbGVjdGVkXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJtdWx0aXBsZVwiOlxuICAgICAgICAgICAgICBjYXNlIFwibXV0ZWRcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImFsbG93RnVsbFNjcmVlblwiOlxuICAgICAgICAgICAgICBjYXNlIFwiYXN5bmNcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImF1dG9QbGF5XCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJjb250cm9sc1wiOlxuICAgICAgICAgICAgICBjYXNlIFwiZGVmYXVsdFwiOlxuICAgICAgICAgICAgICBjYXNlIFwiZGVmZXJcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImRpc2FibGVkXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJkaXNhYmxlUGljdHVyZUluUGljdHVyZVwiOlxuICAgICAgICAgICAgICBjYXNlIFwiZGlzYWJsZVJlbW90ZVBsYXliYWNrXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJmb3JtTm9WYWxpZGF0ZVwiOlxuICAgICAgICAgICAgICBjYXNlIFwiaGlkZGVuXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJsb29wXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJub01vZHVsZVwiOlxuICAgICAgICAgICAgICBjYXNlIFwibm9WYWxpZGF0ZVwiOlxuICAgICAgICAgICAgICBjYXNlIFwib3BlblwiOlxuICAgICAgICAgICAgICBjYXNlIFwicGxheXNJbmxpbmVcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInJlYWRPbmx5XCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJyZXF1aXJlZFwiOlxuICAgICAgICAgICAgICBjYXNlIFwicmV2ZXJzZWRcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInNjb3BlZFwiOlxuICAgICAgICAgICAgICBjYXNlIFwic2VhbWxlc3NcIjpcbiAgICAgICAgICAgICAgY2FzZSBcIml0ZW1TY29wZVwiOlxuICAgICAgICAgICAgICBjYXNlIFwiaW5lcnRcIjpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlY2VpdmVkIHRoZSBzdHJpbmcgYCVzYCBmb3IgdGhlIGJvb2xlYW4gYXR0cmlidXRlIGAlc2AuICVzIERpZCB5b3UgbWVhbiAlcz17JXN9P1wiLFxuICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgXCJmYWxzZVwiID09PSB2YWx1ZVxuICAgICAgICAgICAgICAgID8gXCJUaGUgYnJvd3NlciB3aWxsIGludGVycHJldCBpdCBhcyBhIHRydXRoeSB2YWx1ZS5cIlxuICAgICAgICAgICAgICAgIDogJ0FsdGhvdWdoIHRoaXMgd29ya3MsIGl0IHdpbGwgbm90IHdvcmsgYXMgZXhwZWN0ZWQgaWYgeW91IHBhc3MgdGhlIHN0cmluZyBcImZhbHNlXCIuJyxcbiAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gITA7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuICEwO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3YXJuVW5rbm93blByb3BlcnRpZXModHlwZSwgcHJvcHMsIGV2ZW50UmVnaXN0cnkpIHtcbiAgICAgIHZhciB1bmtub3duUHJvcHMgPSBbXSxcbiAgICAgICAga2V5O1xuICAgICAgZm9yIChrZXkgaW4gcHJvcHMpXG4gICAgICAgIHZhbGlkYXRlUHJvcGVydHkodHlwZSwga2V5LCBwcm9wc1trZXldLCBldmVudFJlZ2lzdHJ5KSB8fFxuICAgICAgICAgIHVua25vd25Qcm9wcy5wdXNoKGtleSk7XG4gICAgICBwcm9wcyA9IHVua25vd25Qcm9wc1xuICAgICAgICAubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgcmV0dXJuIFwiYFwiICsgcHJvcCArIFwiYFwiO1xuICAgICAgICB9KVxuICAgICAgICAuam9pbihcIiwgXCIpO1xuICAgICAgMSA9PT0gdW5rbm93blByb3BzLmxlbmd0aFxuICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkludmFsaWQgdmFsdWUgZm9yIHByb3AgJXMgb24gPCVzPiB0YWcuIEVpdGhlciByZW1vdmUgaXQgZnJvbSB0aGUgZWxlbWVudCwgb3IgcGFzcyBhIHN0cmluZyBvciBudW1iZXIgdmFsdWUgdG8ga2VlcCBpdCBpbiB0aGUgRE9NLiBGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvYXR0cmlidXRlLWJlaGF2aW9yIFwiLFxuICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICB0eXBlXG4gICAgICAgICAgKVxuICAgICAgICA6IDEgPCB1bmtub3duUHJvcHMubGVuZ3RoICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiSW52YWxpZCB2YWx1ZXMgZm9yIHByb3BzICVzIG9uIDwlcz4gdGFnLiBFaXRoZXIgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgZWxlbWVudCwgb3IgcGFzcyBhIHN0cmluZyBvciBudW1iZXIgdmFsdWUgdG8ga2VlcCB0aGVtIGluIHRoZSBET00uIEZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9hdHRyaWJ1dGUtYmVoYXZpb3IgXCIsXG4gICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgIHR5cGVcbiAgICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjYW1lbGl6ZShzdHJpbmcpIHtcbiAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShoeXBoZW5QYXR0ZXJuLCBmdW5jdGlvbiAoXywgY2hhcmFjdGVyKSB7XG4gICAgICAgIHJldHVybiBjaGFyYWN0ZXIudG9VcHBlckNhc2UoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlc2NhcGVUZXh0Rm9yQnJvd3Nlcih0ZXh0KSB7XG4gICAgICBpZiAoXG4gICAgICAgIFwiYm9vbGVhblwiID09PSB0eXBlb2YgdGV4dCB8fFxuICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgdGV4dCB8fFxuICAgICAgICBcImJpZ2ludFwiID09PSB0eXBlb2YgdGV4dFxuICAgICAgKVxuICAgICAgICByZXR1cm4gXCJcIiArIHRleHQ7XG4gICAgICBjaGVja0h0bWxTdHJpbmdDb2VyY2lvbih0ZXh0KTtcbiAgICAgIHRleHQgPSBcIlwiICsgdGV4dDtcbiAgICAgIHZhciBtYXRjaCA9IG1hdGNoSHRtbFJlZ0V4cC5leGVjKHRleHQpO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIHZhciBodG1sID0gXCJcIixcbiAgICAgICAgICBpbmRleCxcbiAgICAgICAgICBsYXN0SW5kZXggPSAwO1xuICAgICAgICBmb3IgKGluZGV4ID0gbWF0Y2guaW5kZXg7IGluZGV4IDwgdGV4dC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICBzd2l0Y2ggKHRleHQuY2hhckNvZGVBdChpbmRleCkpIHtcbiAgICAgICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgICAgIG1hdGNoID0gXCImcXVvdDtcIjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM4OlxuICAgICAgICAgICAgICBtYXRjaCA9IFwiJmFtcDtcIjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM5OlxuICAgICAgICAgICAgICBtYXRjaCA9IFwiJiN4Mjc7XCI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA2MDpcbiAgICAgICAgICAgICAgbWF0Y2ggPSBcIiZsdDtcIjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDYyOlxuICAgICAgICAgICAgICBtYXRjaCA9IFwiJmd0O1wiO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsYXN0SW5kZXggIT09IGluZGV4ICYmIChodG1sICs9IHRleHQuc2xpY2UobGFzdEluZGV4LCBpbmRleCkpO1xuICAgICAgICAgIGxhc3RJbmRleCA9IGluZGV4ICsgMTtcbiAgICAgICAgICBodG1sICs9IG1hdGNoO1xuICAgICAgICB9XG4gICAgICAgIHRleHQgPSBsYXN0SW5kZXggIT09IGluZGV4ID8gaHRtbCArIHRleHQuc2xpY2UobGFzdEluZGV4LCBpbmRleCkgOiBodG1sO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNhbml0aXplVVJMKHVybCkge1xuICAgICAgcmV0dXJuIGlzSmF2YVNjcmlwdFByb3RvY29sLnRlc3QoXCJcIiArIHVybClcbiAgICAgICAgPyBcImphdmFzY3JpcHQ6dGhyb3cgbmV3IEVycm9yKCdSZWFjdCBoYXMgYmxvY2tlZCBhIGphdmFzY3JpcHQ6IFVSTCBhcyBhIHNlY3VyaXR5IHByZWNhdXRpb24uJylcIlxuICAgICAgICA6IHVybDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXNjYXBlRW50aXJlSW5saW5lU2NyaXB0Q29udGVudChzY3JpcHRUZXh0KSB7XG4gICAgICBjaGVja0h0bWxTdHJpbmdDb2VyY2lvbihzY3JpcHRUZXh0KTtcbiAgICAgIHJldHVybiAoXCJcIiArIHNjcmlwdFRleHQpLnJlcGxhY2Uoc2NyaXB0UmVnZXgsIHNjcmlwdFJlcGxhY2VyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlUmVzdW1hYmxlU3RhdGUoXG4gICAgICBpZGVudGlmaWVyUHJlZml4LFxuICAgICAgZXh0ZXJuYWxSdW50aW1lQ29uZmlnLFxuICAgICAgYm9vdHN0cmFwU2NyaXB0Q29udGVudCxcbiAgICAgIGJvb3RzdHJhcFNjcmlwdHMsXG4gICAgICBib290c3RyYXBNb2R1bGVzXG4gICAgKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpZFByZWZpeDogdm9pZCAwID09PSBpZGVudGlmaWVyUHJlZml4ID8gXCJcIiA6IGlkZW50aWZpZXJQcmVmaXgsXG4gICAgICAgIG5leHRGb3JtSUQ6IDAsXG4gICAgICAgIHN0cmVhbWluZ0Zvcm1hdDogMCxcbiAgICAgICAgYm9vdHN0cmFwU2NyaXB0Q29udGVudDogYm9vdHN0cmFwU2NyaXB0Q29udGVudCxcbiAgICAgICAgYm9vdHN0cmFwU2NyaXB0czogYm9vdHN0cmFwU2NyaXB0cyxcbiAgICAgICAgYm9vdHN0cmFwTW9kdWxlczogYm9vdHN0cmFwTW9kdWxlcyxcbiAgICAgICAgaW5zdHJ1Y3Rpb25zOiBOb3RoaW5nU2VudCxcbiAgICAgICAgaGFzQm9keTogITEsXG4gICAgICAgIGhhc0h0bWw6ICExLFxuICAgICAgICB1bmtub3duUmVzb3VyY2VzOiB7fSxcbiAgICAgICAgZG5zUmVzb3VyY2VzOiB7fSxcbiAgICAgICAgY29ubmVjdFJlc291cmNlczogeyBkZWZhdWx0OiB7fSwgYW5vbnltb3VzOiB7fSwgY3JlZGVudGlhbHM6IHt9IH0sXG4gICAgICAgIGltYWdlUmVzb3VyY2VzOiB7fSxcbiAgICAgICAgc3R5bGVSZXNvdXJjZXM6IHt9LFxuICAgICAgICBzY3JpcHRSZXNvdXJjZXM6IHt9LFxuICAgICAgICBtb2R1bGVVbmtub3duUmVzb3VyY2VzOiB7fSxcbiAgICAgICAgbW9kdWxlU2NyaXB0UmVzb3VyY2VzOiB7fVxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlRm9ybWF0Q29udGV4dChpbnNlcnRpb25Nb2RlLCBzZWxlY3RlZFZhbHVlLCB0YWdTY29wZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5zZXJ0aW9uTW9kZTogaW5zZXJ0aW9uTW9kZSxcbiAgICAgICAgc2VsZWN0ZWRWYWx1ZTogc2VsZWN0ZWRWYWx1ZSxcbiAgICAgICAgdGFnU2NvcGU6IHRhZ1Njb3BlXG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDaGlsZEZvcm1hdENvbnRleHQocGFyZW50Q29udGV4dCwgdHlwZSwgcHJvcHMpIHtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwibm9zY3JpcHRcIjpcbiAgICAgICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChcbiAgICAgICAgICAgIEhUTUxfTU9ERSxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBwYXJlbnRDb250ZXh0LnRhZ1Njb3BlIHwgMVxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgXCJzZWxlY3RcIjpcbiAgICAgICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChcbiAgICAgICAgICAgIEhUTUxfTU9ERSxcbiAgICAgICAgICAgIG51bGwgIT0gcHJvcHMudmFsdWUgPyBwcm9wcy52YWx1ZSA6IHByb3BzLmRlZmF1bHRWYWx1ZSxcbiAgICAgICAgICAgIHBhcmVudENvbnRleHQudGFnU2NvcGVcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIFwic3ZnXCI6XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoU1ZHX01PREUsIG51bGwsIHBhcmVudENvbnRleHQudGFnU2NvcGUpO1xuICAgICAgICBjYXNlIFwicGljdHVyZVwiOlxuICAgICAgICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KFxuICAgICAgICAgICAgSFRNTF9NT0RFLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHBhcmVudENvbnRleHQudGFnU2NvcGUgfCAyXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBcIm1hdGhcIjpcbiAgICAgICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChNQVRITUxfTU9ERSwgbnVsbCwgcGFyZW50Q29udGV4dC50YWdTY29wZSk7XG4gICAgICAgIGNhc2UgXCJmb3JlaWduT2JqZWN0XCI6XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoSFRNTF9NT0RFLCBudWxsLCBwYXJlbnRDb250ZXh0LnRhZ1Njb3BlKTtcbiAgICAgICAgY2FzZSBcInRhYmxlXCI6XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoXG4gICAgICAgICAgICBIVE1MX1RBQkxFX01PREUsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgcGFyZW50Q29udGV4dC50YWdTY29wZVxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgXCJ0aGVhZFwiOlxuICAgICAgICBjYXNlIFwidGJvZHlcIjpcbiAgICAgICAgY2FzZSBcInRmb290XCI6XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoXG4gICAgICAgICAgICBIVE1MX1RBQkxFX0JPRFlfTU9ERSxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBwYXJlbnRDb250ZXh0LnRhZ1Njb3BlXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBcImNvbGdyb3VwXCI6XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoXG4gICAgICAgICAgICBIVE1MX0NPTEdST1VQX01PREUsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgcGFyZW50Q29udGV4dC50YWdTY29wZVxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgXCJ0clwiOlxuICAgICAgICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KFxuICAgICAgICAgICAgSFRNTF9UQUJMRV9ST1dfTU9ERSxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBwYXJlbnRDb250ZXh0LnRhZ1Njb3BlXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJlbnRDb250ZXh0Lmluc2VydGlvbk1vZGUgPj0gSFRNTF9UQUJMRV9NT0RFXG4gICAgICAgID8gY3JlYXRlRm9ybWF0Q29udGV4dChIVE1MX01PREUsIG51bGwsIHBhcmVudENvbnRleHQudGFnU2NvcGUpXG4gICAgICAgIDogcGFyZW50Q29udGV4dC5pbnNlcnRpb25Nb2RlID09PSBST09UX0hUTUxfTU9ERVxuICAgICAgICAgID8gXCJodG1sXCIgPT09IHR5cGVcbiAgICAgICAgICAgID8gY3JlYXRlRm9ybWF0Q29udGV4dChIVE1MX0hUTUxfTU9ERSwgbnVsbCwgcGFyZW50Q29udGV4dC50YWdTY29wZSlcbiAgICAgICAgICAgIDogY3JlYXRlRm9ybWF0Q29udGV4dChIVE1MX01PREUsIG51bGwsIHBhcmVudENvbnRleHQudGFnU2NvcGUpXG4gICAgICAgICAgOiBwYXJlbnRDb250ZXh0Lmluc2VydGlvbk1vZGUgPT09IEhUTUxfSFRNTF9NT0RFXG4gICAgICAgICAgICA/IGNyZWF0ZUZvcm1hdENvbnRleHQoSFRNTF9NT0RFLCBudWxsLCBwYXJlbnRDb250ZXh0LnRhZ1Njb3BlKVxuICAgICAgICAgICAgOiBwYXJlbnRDb250ZXh0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoU3R5bGVBdHRyaWJ1dGUodGFyZ2V0LCBzdHlsZSkge1xuICAgICAgaWYgKFwib2JqZWN0XCIgIT09IHR5cGVvZiBzdHlsZSlcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJUaGUgYHN0eWxlYCBwcm9wIGV4cGVjdHMgYSBtYXBwaW5nIGZyb20gc3R5bGUgcHJvcGVydGllcyB0byB2YWx1ZXMsIG5vdCBhIHN0cmluZy4gRm9yIGV4YW1wbGUsIHN0eWxlPXt7bWFyZ2luUmlnaHQ6IHNwYWNpbmcgKyAnZW0nfX0gd2hlbiB1c2luZyBKU1guXCJcbiAgICAgICAgKTtcbiAgICAgIHZhciBpc0ZpcnN0ID0gITAsXG4gICAgICAgIHN0eWxlTmFtZTtcbiAgICAgIGZvciAoc3R5bGVOYW1lIGluIHN0eWxlKVxuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChzdHlsZSwgc3R5bGVOYW1lKSkge1xuICAgICAgICAgIHZhciBzdHlsZVZhbHVlID0gc3R5bGVbc3R5bGVOYW1lXTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBudWxsICE9IHN0eWxlVmFsdWUgJiZcbiAgICAgICAgICAgIFwiYm9vbGVhblwiICE9PSB0eXBlb2Ygc3R5bGVWYWx1ZSAmJlxuICAgICAgICAgICAgXCJcIiAhPT0gc3R5bGVWYWx1ZVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaWYgKDAgPT09IHN0eWxlTmFtZS5pbmRleE9mKFwiLS1cIikpIHtcbiAgICAgICAgICAgICAgdmFyIG5hbWVDaHVuayA9IGVzY2FwZVRleHRGb3JCcm93c2VyKHN0eWxlTmFtZSk7XG4gICAgICAgICAgICAgIGNoZWNrQ1NTUHJvcGVydHlTdHJpbmdDb2VyY2lvbihzdHlsZVZhbHVlLCBzdHlsZU5hbWUpO1xuICAgICAgICAgICAgICBzdHlsZVZhbHVlID0gZXNjYXBlVGV4dEZvckJyb3dzZXIoKFwiXCIgKyBzdHlsZVZhbHVlKS50cmltKCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmFtZUNodW5rID0gc3R5bGVOYW1lO1xuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBzdHlsZVZhbHVlO1xuICAgICAgICAgICAgICBpZiAoLTEgPCBuYW1lQ2h1bmsuaW5kZXhPZihcIi1cIikpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IG5hbWVDaHVuaztcbiAgICAgICAgICAgICAgICAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJlxuICAgICAgICAgICAgICAgICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSkgfHxcbiAgICAgICAgICAgICAgICAgICgod2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9ICEwKSxcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiVW5zdXBwb3J0ZWQgc3R5bGUgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz9cIixcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgY2FtZWxpemUobmFtZS5yZXBsYWNlKG1zUGF0dGVybiQxLCBcIm1zLVwiKSlcbiAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybi50ZXN0KG5hbWVDaHVuaykpXG4gICAgICAgICAgICAgICAgKG5hbWUgPSBuYW1lQ2h1bmspLFxuICAgICAgICAgICAgICAgICAgKHdhcm5lZFN0eWxlTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKCh3YXJuZWRTdHlsZU5hbWVzW25hbWVdID0gITApLFxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgIFwiVW5zdXBwb3J0ZWQgdmVuZG9yLXByZWZpeGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/XCIsXG4gICAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKVxuICAgICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgZWxzZSBpZiAoYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IG5hbWVDaHVuaztcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUkanNjb21wJDAgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAod2FybmVkU3R5bGVWYWx1ZXMuaGFzT3duUHJvcGVydHkodmFsdWUkanNjb21wJDApICYmXG4gICAgICAgICAgICAgICAgICB3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZSRqc2NvbXAkMF0pIHx8XG4gICAgICAgICAgICAgICAgICAoKHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlJGpzY29tcCQwXSA9ICEwKSxcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICdTdHlsZSBwcm9wZXJ0eSB2YWx1ZXMgc2hvdWxkblxcJ3QgY29udGFpbiBhIHNlbWljb2xvbi4gVHJ5IFwiJXM6ICVzXCIgaW5zdGVhZC4nLFxuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSRqc2NvbXAkMC5yZXBsYWNlKFxuICAgICAgICAgICAgICAgICAgICAgIGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybixcbiAgICAgICAgICAgICAgICAgICAgICBcIlwiXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICAgICAgICAgIChpc05hTih2YWx1ZSlcbiAgICAgICAgICAgICAgICAgID8gd2FybmVkRm9yTmFOVmFsdWUgfHxcbiAgICAgICAgICAgICAgICAgICAgKCh3YXJuZWRGb3JOYU5WYWx1ZSA9ICEwKSxcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICBcImBOYU5gIGlzIGFuIGludmFsaWQgdmFsdWUgZm9yIHRoZSBgJXNgIGNzcyBzdHlsZSBwcm9wZXJ0eS5cIixcbiAgICAgICAgICAgICAgICAgICAgICBuYW1lQ2h1bmtcbiAgICAgICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgICAgIDogaXNGaW5pdGUodmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgICAgIHdhcm5lZEZvckluZmluaXR5VmFsdWUgfHxcbiAgICAgICAgICAgICAgICAgICAgKCh3YXJuZWRGb3JJbmZpbml0eVZhbHVlID0gITApLFxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgIFwiYEluZmluaXR5YCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgbmFtZUNodW5rXG4gICAgICAgICAgICAgICAgICAgICkpKTtcbiAgICAgICAgICAgICAgbmFtZUNodW5rID0gc3R5bGVOYW1lO1xuICAgICAgICAgICAgICB2YWx1ZSA9IHN0eWxlTmFtZUNhY2hlLmdldChuYW1lQ2h1bmspO1xuICAgICAgICAgICAgICB2b2lkIDAgIT09IHZhbHVlXG4gICAgICAgICAgICAgICAgPyAobmFtZUNodW5rID0gdmFsdWUpXG4gICAgICAgICAgICAgICAgOiAoKHZhbHVlID0gZXNjYXBlVGV4dEZvckJyb3dzZXIoXG4gICAgICAgICAgICAgICAgICAgIG5hbWVDaHVua1xuICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKHVwcGVyY2FzZVBhdHRlcm4sIFwiLSQxXCIpXG4gICAgICAgICAgICAgICAgICAgICAgLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShtc1BhdHRlcm4sIFwiLW1zLVwiKVxuICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICBzdHlsZU5hbWVDYWNoZS5zZXQobmFtZUNodW5rLCB2YWx1ZSksXG4gICAgICAgICAgICAgICAgICAobmFtZUNodW5rID0gdmFsdWUpKTtcbiAgICAgICAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIHN0eWxlVmFsdWVcbiAgICAgICAgICAgICAgICA/IChzdHlsZVZhbHVlID1cbiAgICAgICAgICAgICAgICAgICAgMCA9PT0gc3R5bGVWYWx1ZSB8fCB1bml0bGVzc051bWJlcnMuaGFzKHN0eWxlTmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICA/IFwiXCIgKyBzdHlsZVZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgOiBzdHlsZVZhbHVlICsgXCJweFwiKVxuICAgICAgICAgICAgICAgIDogKGNoZWNrQ1NTUHJvcGVydHlTdHJpbmdDb2VyY2lvbihzdHlsZVZhbHVlLCBzdHlsZU5hbWUpLFxuICAgICAgICAgICAgICAgICAgKHN0eWxlVmFsdWUgPSBlc2NhcGVUZXh0Rm9yQnJvd3NlcihcbiAgICAgICAgICAgICAgICAgICAgKFwiXCIgKyBzdHlsZVZhbHVlKS50cmltKClcbiAgICAgICAgICAgICAgICAgICkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzRmlyc3RcbiAgICAgICAgICAgICAgPyAoKGlzRmlyc3QgPSAhMSksXG4gICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2goXG4gICAgICAgICAgICAgICAgICBzdHlsZUF0dHJpYnV0ZVN0YXJ0LFxuICAgICAgICAgICAgICAgICAgbmFtZUNodW5rLFxuICAgICAgICAgICAgICAgICAgc3R5bGVBc3NpZ24sXG4gICAgICAgICAgICAgICAgICBzdHlsZVZhbHVlXG4gICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgOiB0YXJnZXQucHVzaChzdHlsZVNlcGFyYXRvciwgbmFtZUNodW5rLCBzdHlsZUFzc2lnbiwgc3R5bGVWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBpc0ZpcnN0IHx8IHRhcmdldC5wdXNoKGF0dHJpYnV0ZUVuZCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hCb29sZWFuQXR0cmlidXRlKHRhcmdldCwgbmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhbHVlICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHZhbHVlICYmXG4gICAgICAgIFwic3ltYm9sXCIgIT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICB0YXJnZXQucHVzaChhdHRyaWJ1dGVTZXBhcmF0b3IsIG5hbWUsIGF0dHJpYnV0ZUVtcHR5U3RyaW5nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsIG5hbWUsIHZhbHVlKSB7XG4gICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICBcInN5bWJvbFwiICE9PSB0eXBlb2YgdmFsdWUgJiZcbiAgICAgICAgXCJib29sZWFuXCIgIT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICB0YXJnZXQucHVzaChcbiAgICAgICAgICBhdHRyaWJ1dGVTZXBhcmF0b3IsXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBhdHRyaWJ1dGVBc3NpZ24sXG4gICAgICAgICAgZXNjYXBlVGV4dEZvckJyb3dzZXIodmFsdWUpLFxuICAgICAgICAgIGF0dHJpYnV0ZUVuZFxuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoQWRkaXRpb25hbEZvcm1GaWVsZCh2YWx1ZSwga2V5KSB7XG4gICAgICB0aGlzLnB1c2goJzxpbnB1dCB0eXBlPVwiaGlkZGVuXCInKTtcbiAgICAgIHZhbGlkYXRlQWRkaXRpb25hbEZvcm1GaWVsZCh2YWx1ZSk7XG4gICAgICBwdXNoU3RyaW5nQXR0cmlidXRlKHRoaXMsIFwibmFtZVwiLCBrZXkpO1xuICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0aGlzLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgIHRoaXMucHVzaChlbmRPZlN0YXJ0VGFnU2VsZkNsb3NpbmcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUFkZGl0aW9uYWxGb3JtRmllbGQodmFsdWUpIHtcbiAgICAgIGlmIChcInN0cmluZ1wiICE9PSB0eXBlb2YgdmFsdWUpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiRmlsZS9CbG9iIGZpZWxkcyBhcmUgbm90IHlldCBzdXBwb3J0ZWQgaW4gcHJvZ3Jlc3NpdmUgZm9ybXMuIFdpbGwgZmFsbGJhY2sgdG8gY2xpZW50IGh5ZHJhdGlvbi5cIlxuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDdXN0b21Gb3JtRmllbGRzKHJlc3VtYWJsZVN0YXRlLCBmb3JtQWN0aW9uKSB7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZm9ybUFjdGlvbi4kJEZPUk1fQUNUSU9OKSB7XG4gICAgICAgIHZhciBpZCA9IHJlc3VtYWJsZVN0YXRlLm5leHRGb3JtSUQrKztcbiAgICAgICAgcmVzdW1hYmxlU3RhdGUgPSByZXN1bWFibGVTdGF0ZS5pZFByZWZpeCArIGlkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBjdXN0b21GaWVsZHMgPSBmb3JtQWN0aW9uLiQkRk9STV9BQ1RJT04ocmVzdW1hYmxlU3RhdGUpO1xuICAgICAgICAgIGlmIChjdXN0b21GaWVsZHMpIHtcbiAgICAgICAgICAgIHZhciBmb3JtRGF0YSA9IGN1c3RvbUZpZWxkcy5kYXRhO1xuICAgICAgICAgICAgbnVsbCAhPSBmb3JtRGF0YSAmJiBmb3JtRGF0YS5mb3JFYWNoKHZhbGlkYXRlQWRkaXRpb25hbEZvcm1GaWVsZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjdXN0b21GaWVsZHM7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgeCAmJlxuICAgICAgICAgICAgbnVsbCAhPT0geCAmJlxuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgeC50aGVuXG4gICAgICAgICAgKVxuICAgICAgICAgICAgdGhyb3cgeDtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJGYWlsZWQgdG8gc2VyaWFsaXplIGFuIGFjdGlvbiBmb3IgcHJvZ3Jlc3NpdmUgZW5oYW5jZW1lbnQ6XFxuJXNcIixcbiAgICAgICAgICAgIHhcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaEZvcm1BY3Rpb25BdHRyaWJ1dGUoXG4gICAgICB0YXJnZXQsXG4gICAgICByZXN1bWFibGVTdGF0ZSxcbiAgICAgIHJlbmRlclN0YXRlLFxuICAgICAgZm9ybUFjdGlvbixcbiAgICAgIGZvcm1FbmNUeXBlLFxuICAgICAgZm9ybU1ldGhvZCxcbiAgICAgIGZvcm1UYXJnZXQsXG4gICAgICBuYW1lXG4gICAgKSB7XG4gICAgICB2YXIgZm9ybURhdGEgPSBudWxsO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGZvcm1BY3Rpb24pIHtcbiAgICAgICAgbnVsbCA9PT0gbmFtZSB8fFxuICAgICAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uTmFtZSB8fFxuICAgICAgICAgICgoZGlkV2FybkZvcm1BY3Rpb25OYW1lID0gITApLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAnQ2Fubm90IHNwZWNpZnkgYSBcIm5hbWVcIiBwcm9wIGZvciBhIGJ1dHRvbiB0aGF0IHNwZWNpZmllcyBhIGZ1bmN0aW9uIGFzIGEgZm9ybUFjdGlvbi4gUmVhY3QgbmVlZHMgaXQgdG8gZW5jb2RlIHdoaWNoIGFjdGlvbiBzaG91bGQgYmUgaW52b2tlZC4gSXQgd2lsbCBnZXQgb3ZlcnJpZGRlbi4nXG4gICAgICAgICAgKSk7XG4gICAgICAgIChudWxsID09PSBmb3JtRW5jVHlwZSAmJiBudWxsID09PSBmb3JtTWV0aG9kKSB8fFxuICAgICAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uTWV0aG9kIHx8XG4gICAgICAgICAgKChkaWRXYXJuRm9ybUFjdGlvbk1ldGhvZCA9ICEwKSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJDYW5ub3Qgc3BlY2lmeSBhIGZvcm1FbmNUeXBlIG9yIGZvcm1NZXRob2QgZm9yIGEgYnV0dG9uIHRoYXQgc3BlY2lmaWVzIGEgZnVuY3Rpb24gYXMgYSBmb3JtQWN0aW9uLiBSZWFjdCBwcm92aWRlcyB0aG9zZSBhdXRvbWF0aWNhbGx5LiBUaGV5IHdpbGwgZ2V0IG92ZXJyaWRkZW4uXCJcbiAgICAgICAgICApKTtcbiAgICAgICAgbnVsbCA9PT0gZm9ybVRhcmdldCB8fFxuICAgICAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uVGFyZ2V0IHx8XG4gICAgICAgICAgKChkaWRXYXJuRm9ybUFjdGlvblRhcmdldCA9ICEwKSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJDYW5ub3Qgc3BlY2lmeSBhIGZvcm1UYXJnZXQgZm9yIGEgYnV0dG9uIHRoYXQgc3BlY2lmaWVzIGEgZnVuY3Rpb24gYXMgYSBmb3JtQWN0aW9uLiBUaGUgZnVuY3Rpb24gd2lsbCBhbHdheXMgYmUgZXhlY3V0ZWQgaW4gdGhlIHNhbWUgd2luZG93LlwiXG4gICAgICAgICAgKSk7XG4gICAgICAgIHZhciBjdXN0b21GaWVsZHMgPSBnZXRDdXN0b21Gb3JtRmllbGRzKHJlc3VtYWJsZVN0YXRlLCBmb3JtQWN0aW9uKTtcbiAgICAgICAgbnVsbCAhPT0gY3VzdG9tRmllbGRzXG4gICAgICAgICAgPyAoKG5hbWUgPSBjdXN0b21GaWVsZHMubmFtZSksXG4gICAgICAgICAgICAoZm9ybUFjdGlvbiA9IGN1c3RvbUZpZWxkcy5hY3Rpb24gfHwgXCJcIiksXG4gICAgICAgICAgICAoZm9ybUVuY1R5cGUgPSBjdXN0b21GaWVsZHMuZW5jVHlwZSksXG4gICAgICAgICAgICAoZm9ybU1ldGhvZCA9IGN1c3RvbUZpZWxkcy5tZXRob2QpLFxuICAgICAgICAgICAgKGZvcm1UYXJnZXQgPSBjdXN0b21GaWVsZHMudGFyZ2V0KSxcbiAgICAgICAgICAgIChmb3JtRGF0YSA9IGN1c3RvbUZpZWxkcy5kYXRhKSlcbiAgICAgICAgICA6ICh0YXJnZXQucHVzaChcbiAgICAgICAgICAgICAgYXR0cmlidXRlU2VwYXJhdG9yLFxuICAgICAgICAgICAgICBcImZvcm1BY3Rpb25cIixcbiAgICAgICAgICAgICAgYXR0cmlidXRlQXNzaWduLFxuICAgICAgICAgICAgICBhY3Rpb25KYXZhU2NyaXB0VVJMLFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVFbmRcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAoZm9ybVRhcmdldCA9IGZvcm1NZXRob2QgPSBmb3JtRW5jVHlwZSA9IGZvcm1BY3Rpb24gPSBuYW1lID0gbnVsbCksXG4gICAgICAgICAgICBpbmplY3RGb3JtUmVwbGF5aW5nUnVudGltZShyZXN1bWFibGVTdGF0ZSwgcmVuZGVyU3RhdGUpKTtcbiAgICAgIH1cbiAgICAgIG51bGwgIT0gbmFtZSAmJiBwdXNoQXR0cmlidXRlKHRhcmdldCwgXCJuYW1lXCIsIG5hbWUpO1xuICAgICAgbnVsbCAhPSBmb3JtQWN0aW9uICYmIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBcImZvcm1BY3Rpb25cIiwgZm9ybUFjdGlvbik7XG4gICAgICBudWxsICE9IGZvcm1FbmNUeXBlICYmIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBcImZvcm1FbmNUeXBlXCIsIGZvcm1FbmNUeXBlKTtcbiAgICAgIG51bGwgIT0gZm9ybU1ldGhvZCAmJiBwdXNoQXR0cmlidXRlKHRhcmdldCwgXCJmb3JtTWV0aG9kXCIsIGZvcm1NZXRob2QpO1xuICAgICAgbnVsbCAhPSBmb3JtVGFyZ2V0ICYmIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBcImZvcm1UYXJnZXRcIiwgZm9ybVRhcmdldCk7XG4gICAgICByZXR1cm4gZm9ybURhdGE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBuYW1lLCB2YWx1ZSkge1xuICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgIGNhc2UgXCJjbGFzc05hbWVcIjpcbiAgICAgICAgICBwdXNoU3RyaW5nQXR0cmlidXRlKHRhcmdldCwgXCJjbGFzc1wiLCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ0YWJJbmRleFwiOlxuICAgICAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCBcInRhYmluZGV4XCIsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRpclwiOlxuICAgICAgICBjYXNlIFwicm9sZVwiOlxuICAgICAgICBjYXNlIFwidmlld0JveFwiOlxuICAgICAgICBjYXNlIFwid2lkdGhcIjpcbiAgICAgICAgY2FzZSBcImhlaWdodFwiOlxuICAgICAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgICAgIHB1c2hTdHlsZUF0dHJpYnV0ZSh0YXJnZXQsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNyY1wiOlxuICAgICAgICBjYXNlIFwiaHJlZlwiOlxuICAgICAgICAgIGlmIChcIlwiID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgXCJzcmNcIiA9PT0gbmFtZVxuICAgICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAnQW4gZW1wdHkgc3RyaW5nIChcIlwiKSB3YXMgcGFzc2VkIHRvIHRoZSAlcyBhdHRyaWJ1dGUuIFRoaXMgbWF5IGNhdXNlIHRoZSBicm93c2VyIHRvIGRvd25sb2FkIHRoZSB3aG9sZSBwYWdlIGFnYWluIG92ZXIgdGhlIG5ldHdvcmsuIFRvIGZpeCB0aGlzLCBlaXRoZXIgZG8gbm90IHJlbmRlciB0aGUgZWxlbWVudCBhdCBhbGwgb3IgcGFzcyBudWxsIHRvICVzIGluc3RlYWQgb2YgYW4gZW1wdHkgc3RyaW5nLicsXG4gICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgJ0FuIGVtcHR5IHN0cmluZyAoXCJcIikgd2FzIHBhc3NlZCB0byB0aGUgJXMgYXR0cmlidXRlLiBUbyBmaXggdGhpcywgZWl0aGVyIGRvIG5vdCByZW5kZXIgdGhlIGVsZW1lbnQgYXQgYWxsIG9yIHBhc3MgbnVsbCB0byAlcyBpbnN0ZWFkIG9mIGFuIGVtcHR5IHN0cmluZy4nLFxuICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIFwiYWN0aW9uXCI6XG4gICAgICAgIGNhc2UgXCJmb3JtQWN0aW9uXCI6XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgbnVsbCA9PSB2YWx1ZSB8fFxuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdmFsdWUgfHxcbiAgICAgICAgICAgIFwic3ltYm9sXCIgPT09IHR5cGVvZiB2YWx1ZSB8fFxuICAgICAgICAgICAgXCJib29sZWFuXCIgPT09IHR5cGVvZiB2YWx1ZVxuICAgICAgICAgIClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odmFsdWUsIG5hbWUpO1xuICAgICAgICAgIHZhbHVlID0gc2FuaXRpemVVUkwoXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICB0YXJnZXQucHVzaChcbiAgICAgICAgICAgIGF0dHJpYnV0ZVNlcGFyYXRvcixcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBhdHRyaWJ1dGVBc3NpZ24sXG4gICAgICAgICAgICBlc2NhcGVUZXh0Rm9yQnJvd3Nlcih2YWx1ZSksXG4gICAgICAgICAgICBhdHRyaWJ1dGVFbmRcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZGVmYXVsdFZhbHVlXCI6XG4gICAgICAgIGNhc2UgXCJkZWZhdWx0Q2hlY2tlZFwiOlxuICAgICAgICBjYXNlIFwiaW5uZXJIVE1MXCI6XG4gICAgICAgIGNhc2UgXCJzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmdcIjpcbiAgICAgICAgY2FzZSBcInN1cHByZXNzSHlkcmF0aW9uV2FybmluZ1wiOlxuICAgICAgICBjYXNlIFwicmVmXCI6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJhdXRvRm9jdXNcIjpcbiAgICAgICAgY2FzZSBcIm11bHRpcGxlXCI6XG4gICAgICAgIGNhc2UgXCJtdXRlZFwiOlxuICAgICAgICAgIHB1c2hCb29sZWFuQXR0cmlidXRlKHRhcmdldCwgbmFtZS50b0xvd2VyQ2FzZSgpLCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ4bGlua0hyZWZcIjpcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB2YWx1ZSB8fFxuICAgICAgICAgICAgXCJzeW1ib2xcIiA9PT0gdHlwZW9mIHZhbHVlIHx8XG4gICAgICAgICAgICBcImJvb2xlYW5cIiA9PT0gdHlwZW9mIHZhbHVlXG4gICAgICAgICAgKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgbmFtZSk7XG4gICAgICAgICAgdmFsdWUgPSBzYW5pdGl6ZVVSTChcIlwiICsgdmFsdWUpO1xuICAgICAgICAgIHRhcmdldC5wdXNoKFxuICAgICAgICAgICAgYXR0cmlidXRlU2VwYXJhdG9yLFxuICAgICAgICAgICAgXCJ4bGluazpocmVmXCIsXG4gICAgICAgICAgICBhdHRyaWJ1dGVBc3NpZ24sXG4gICAgICAgICAgICBlc2NhcGVUZXh0Rm9yQnJvd3Nlcih2YWx1ZSksXG4gICAgICAgICAgICBhdHRyaWJ1dGVFbmRcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiY29udGVudEVkaXRhYmxlXCI6XG4gICAgICAgIGNhc2UgXCJzcGVsbENoZWNrXCI6XG4gICAgICAgIGNhc2UgXCJkcmFnZ2FibGVcIjpcbiAgICAgICAgY2FzZSBcInZhbHVlXCI6XG4gICAgICAgIGNhc2UgXCJhdXRvUmV2ZXJzZVwiOlxuICAgICAgICBjYXNlIFwiZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZFwiOlxuICAgICAgICBjYXNlIFwiZm9jdXNhYmxlXCI6XG4gICAgICAgIGNhc2UgXCJwcmVzZXJ2ZUFscGhhXCI6XG4gICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgdmFsdWUgJiZcbiAgICAgICAgICAgIFwic3ltYm9sXCIgIT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICAgICAgdGFyZ2V0LnB1c2goXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZVNlcGFyYXRvcixcbiAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgYXR0cmlidXRlQXNzaWduLFxuICAgICAgICAgICAgICBlc2NhcGVUZXh0Rm9yQnJvd3Nlcih2YWx1ZSksXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZUVuZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImluZXJ0XCI6XG4gICAgICAgICAgXCJcIiAhPT0gdmFsdWUgfHxcbiAgICAgICAgICAgIGRpZFdhcm5Gb3JOZXdCb29sZWFuUHJvcHNXaXRoRW1wdHlWYWx1ZVtuYW1lXSB8fFxuICAgICAgICAgICAgKChkaWRXYXJuRm9yTmV3Qm9vbGVhblByb3BzV2l0aEVtcHR5VmFsdWVbbmFtZV0gPSAhMCksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlY2VpdmVkIGFuIGVtcHR5IHN0cmluZyBmb3IgYSBib29sZWFuIGF0dHJpYnV0ZSBgJXNgLiBUaGlzIHdpbGwgdHJlYXQgdGhlIGF0dHJpYnV0ZSBhcyBpZiBpdCB3ZXJlIGZhbHNlLiBFaXRoZXIgcGFzcyBgZmFsc2VgIHRvIHNpbGVuY2UgdGhpcyB3YXJuaW5nLCBvciBwYXNzIGB0cnVlYCBpZiB5b3UgdXNlZCBhbiBlbXB0eSBzdHJpbmcgaW4gZWFybGllciB2ZXJzaW9ucyBvZiBSZWFjdCB0byBpbmRpY2F0ZSB0aGlzIGF0dHJpYnV0ZSBpcyB0cnVlLlwiLFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApKTtcbiAgICAgICAgY2FzZSBcImFsbG93RnVsbFNjcmVlblwiOlxuICAgICAgICBjYXNlIFwiYXN5bmNcIjpcbiAgICAgICAgY2FzZSBcImF1dG9QbGF5XCI6XG4gICAgICAgIGNhc2UgXCJjb250cm9sc1wiOlxuICAgICAgICBjYXNlIFwiZGVmYXVsdFwiOlxuICAgICAgICBjYXNlIFwiZGVmZXJcIjpcbiAgICAgICAgY2FzZSBcImRpc2FibGVkXCI6XG4gICAgICAgIGNhc2UgXCJkaXNhYmxlUGljdHVyZUluUGljdHVyZVwiOlxuICAgICAgICBjYXNlIFwiZGlzYWJsZVJlbW90ZVBsYXliYWNrXCI6XG4gICAgICAgIGNhc2UgXCJmb3JtTm9WYWxpZGF0ZVwiOlxuICAgICAgICBjYXNlIFwiaGlkZGVuXCI6XG4gICAgICAgIGNhc2UgXCJsb29wXCI6XG4gICAgICAgIGNhc2UgXCJub01vZHVsZVwiOlxuICAgICAgICBjYXNlIFwibm9WYWxpZGF0ZVwiOlxuICAgICAgICBjYXNlIFwib3BlblwiOlxuICAgICAgICBjYXNlIFwicGxheXNJbmxpbmVcIjpcbiAgICAgICAgY2FzZSBcInJlYWRPbmx5XCI6XG4gICAgICAgIGNhc2UgXCJyZXF1aXJlZFwiOlxuICAgICAgICBjYXNlIFwicmV2ZXJzZWRcIjpcbiAgICAgICAgY2FzZSBcInNjb3BlZFwiOlxuICAgICAgICBjYXNlIFwic2VhbWxlc3NcIjpcbiAgICAgICAgY2FzZSBcIml0ZW1TY29wZVwiOlxuICAgICAgICAgIHZhbHVlICYmXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICAgICAgXCJzeW1ib2xcIiAhPT0gdHlwZW9mIHZhbHVlICYmXG4gICAgICAgICAgICB0YXJnZXQucHVzaChhdHRyaWJ1dGVTZXBhcmF0b3IsIG5hbWUsIGF0dHJpYnV0ZUVtcHR5U3RyaW5nKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImNhcHR1cmVcIjpcbiAgICAgICAgY2FzZSBcImRvd25sb2FkXCI6XG4gICAgICAgICAgITAgPT09IHZhbHVlXG4gICAgICAgICAgICA/IHRhcmdldC5wdXNoKGF0dHJpYnV0ZVNlcGFyYXRvciwgbmFtZSwgYXR0cmlidXRlRW1wdHlTdHJpbmcpXG4gICAgICAgICAgICA6ICExICE9PSB2YWx1ZSAmJlxuICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICAgICAgICBcInN5bWJvbFwiICE9PSB0eXBlb2YgdmFsdWUgJiZcbiAgICAgICAgICAgICAgdGFyZ2V0LnB1c2goXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlU2VwYXJhdG9yLFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlQXNzaWduLFxuICAgICAgICAgICAgICAgIGVzY2FwZVRleHRGb3JCcm93c2VyKHZhbHVlKSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVFbmRcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImNvbHNcIjpcbiAgICAgICAgY2FzZSBcInJvd3NcIjpcbiAgICAgICAgY2FzZSBcInNpemVcIjpcbiAgICAgICAgY2FzZSBcInNwYW5cIjpcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICAgICAgXCJzeW1ib2xcIiAhPT0gdHlwZW9mIHZhbHVlICYmXG4gICAgICAgICAgICAhaXNOYU4odmFsdWUpICYmXG4gICAgICAgICAgICAxIDw9IHZhbHVlICYmXG4gICAgICAgICAgICB0YXJnZXQucHVzaChcbiAgICAgICAgICAgICAgYXR0cmlidXRlU2VwYXJhdG9yLFxuICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVBc3NpZ24sXG4gICAgICAgICAgICAgIGVzY2FwZVRleHRGb3JCcm93c2VyKHZhbHVlKSxcbiAgICAgICAgICAgICAgYXR0cmlidXRlRW5kXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicm93U3BhblwiOlxuICAgICAgICBjYXNlIFwic3RhcnRcIjpcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB2YWx1ZSB8fFxuICAgICAgICAgICAgXCJzeW1ib2xcIiA9PT0gdHlwZW9mIHZhbHVlIHx8XG4gICAgICAgICAgICBpc05hTih2YWx1ZSkgfHxcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVTZXBhcmF0b3IsXG4gICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZUFzc2lnbixcbiAgICAgICAgICAgICAgZXNjYXBlVGV4dEZvckJyb3dzZXIodmFsdWUpLFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVFbmRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ4bGlua0FjdHVhdGVcIjpcbiAgICAgICAgICBwdXNoU3RyaW5nQXR0cmlidXRlKHRhcmdldCwgXCJ4bGluazphY3R1YXRlXCIsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInhsaW5rQXJjcm9sZVwiOlxuICAgICAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCBcInhsaW5rOmFyY3JvbGVcIiwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwieGxpbmtSb2xlXCI6XG4gICAgICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsIFwieGxpbms6cm9sZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ4bGlua1Nob3dcIjpcbiAgICAgICAgICBwdXNoU3RyaW5nQXR0cmlidXRlKHRhcmdldCwgXCJ4bGluazpzaG93XCIsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInhsaW5rVGl0bGVcIjpcbiAgICAgICAgICBwdXNoU3RyaW5nQXR0cmlidXRlKHRhcmdldCwgXCJ4bGluazp0aXRsZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ4bGlua1R5cGVcIjpcbiAgICAgICAgICBwdXNoU3RyaW5nQXR0cmlidXRlKHRhcmdldCwgXCJ4bGluazp0eXBlXCIsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInhtbEJhc2VcIjpcbiAgICAgICAgICBwdXNoU3RyaW5nQXR0cmlidXRlKHRhcmdldCwgXCJ4bWw6YmFzZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ4bWxMYW5nXCI6XG4gICAgICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsIFwieG1sOmxhbmdcIiwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwieG1sU3BhY2VcIjpcbiAgICAgICAgICBwdXNoU3RyaW5nQXR0cmlidXRlKHRhcmdldCwgXCJ4bWw6c3BhY2VcIiwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICEoMiA8IG5hbWUubGVuZ3RoKSB8fFxuICAgICAgICAgICAgKFwib1wiICE9PSBuYW1lWzBdICYmIFwiT1wiICE9PSBuYW1lWzBdKSB8fFxuICAgICAgICAgICAgKFwiblwiICE9PSBuYW1lWzFdICYmIFwiTlwiICE9PSBuYW1lWzFdKVxuICAgICAgICAgIClcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgKChuYW1lID0gYWxpYXNlcy5nZXQobmFtZSkgfHwgbmFtZSksIGlzQXR0cmlidXRlTmFtZVNhZmUobmFtZSkpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgICAgICAgIHZhciBwcmVmaXggPSBuYW1lLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCwgNSk7XG4gICAgICAgICAgICAgICAgICBpZiAoXCJkYXRhLVwiICE9PSBwcmVmaXggJiYgXCJhcmlhLVwiICE9PSBwcmVmaXgpIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0YXJnZXQucHVzaChcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVTZXBhcmF0b3IsXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVBc3NpZ24sXG4gICAgICAgICAgICAgICAgZXNjYXBlVGV4dEZvckJyb3dzZXIodmFsdWUpLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUVuZFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoSW5uZXJIVE1MKHRhcmdldCwgaW5uZXJIVE1MLCBjaGlsZHJlbikge1xuICAgICAgaWYgKG51bGwgIT0gaW5uZXJIVE1MKSB7XG4gICAgICAgIGlmIChudWxsICE9IGNoaWxkcmVuKVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJDYW4gb25seSBzZXQgb25lIG9mIGBjaGlsZHJlbmAgb3IgYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC5cIlxuICAgICAgICAgICk7XG4gICAgICAgIGlmIChcIm9iamVjdFwiICE9PSB0eXBlb2YgaW5uZXJIVE1MIHx8ICEoXCJfX2h0bWxcIiBpbiBpbm5lckhUTUwpKVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIG11c3QgYmUgaW4gdGhlIGZvcm0gYHtfX2h0bWw6IC4uLn1gLiBQbGVhc2UgdmlzaXQgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9kYW5nZXJvdXNseS1zZXQtaW5uZXItaHRtbCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cIlxuICAgICAgICAgICk7XG4gICAgICAgIGlubmVySFRNTCA9IGlubmVySFRNTC5fX2h0bWw7XG4gICAgICAgIG51bGwgIT09IGlubmVySFRNTCAmJlxuICAgICAgICAgIHZvaWQgMCAhPT0gaW5uZXJIVE1MICYmXG4gICAgICAgICAgKGNoZWNrSHRtbFN0cmluZ0NvZXJjaW9uKGlubmVySFRNTCksIHRhcmdldC5wdXNoKFwiXCIgKyBpbm5lckhUTUwpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tTZWxlY3RQcm9wKHByb3BzLCBwcm9wTmFtZSkge1xuICAgICAgdmFyIHZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgbnVsbCAhPSB2YWx1ZSAmJlxuICAgICAgICAoKHZhbHVlID0gaXNBcnJheUltcGwodmFsdWUpKSxcbiAgICAgICAgcHJvcHMubXVsdGlwbGUgJiYgIXZhbHVlXG4gICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlRoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhbiBhcnJheSBpZiBgbXVsdGlwbGVgIGlzIHRydWUuXCIsXG4gICAgICAgICAgICAgIHByb3BOYW1lXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiAhcHJvcHMubXVsdGlwbGUgJiZcbiAgICAgICAgICAgIHZhbHVlICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlRoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhIHNjYWxhciB2YWx1ZSBpZiBgbXVsdGlwbGVgIGlzIGZhbHNlLlwiLFxuICAgICAgICAgICAgICBwcm9wTmFtZVxuICAgICAgICAgICAgKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsYXR0ZW5PcHRpb25DaGlsZHJlbihjaGlsZHJlbikge1xuICAgICAgdmFyIGNvbnRlbnQgPSBcIlwiO1xuICAgICAgUmVhY3QuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIG51bGwgIT0gY2hpbGQgJiZcbiAgICAgICAgICAoKGNvbnRlbnQgKz0gY2hpbGQpLFxuICAgICAgICAgIGRpZFdhcm5JbnZhbGlkT3B0aW9uQ2hpbGRyZW4gfHxcbiAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBjaGlsZCB8fFxuICAgICAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIGNoaWxkIHx8XG4gICAgICAgICAgICBcImJpZ2ludFwiID09PSB0eXBlb2YgY2hpbGQgfHxcbiAgICAgICAgICAgICgoZGlkV2FybkludmFsaWRPcHRpb25DaGlsZHJlbiA9ICEwKSxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiQ2Fubm90IGluZmVyIHRoZSBvcHRpb24gdmFsdWUgb2YgY29tcGxleCBjaGlsZHJlbi4gUGFzcyBhIGB2YWx1ZWAgcHJvcCBvciB1c2UgYSBwbGFpbiBzdHJpbmcgYXMgY2hpbGRyZW4gdG8gPG9wdGlvbj4uXCJcbiAgICAgICAgICAgICkpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGluamVjdEZvcm1SZXBsYXlpbmdSdW50aW1lKHJlc3VtYWJsZVN0YXRlLCByZW5kZXJTdGF0ZSkge1xuICAgICAgKHJlc3VtYWJsZVN0YXRlLmluc3RydWN0aW9ucyAmIDE2KSA9PT0gTm90aGluZ1NlbnQgJiZcbiAgICAgICAgKChyZXN1bWFibGVTdGF0ZS5pbnN0cnVjdGlvbnMgfD0gMTYpLFxuICAgICAgICByZW5kZXJTdGF0ZS5ib290c3RyYXBDaHVua3MudW5zaGlmdChcbiAgICAgICAgICByZW5kZXJTdGF0ZS5zdGFydElubGluZVNjcmlwdCxcbiAgICAgICAgICBmb3JtUmVwbGF5aW5nUnVudGltZVNjcmlwdCxcbiAgICAgICAgICBcIlxceDNjL3NjcmlwdD5cIlxuICAgICAgICApKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaExpbmtJbXBsKHRhcmdldCwgcHJvcHMpIHtcbiAgICAgIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoXCJsaW5rXCIpKTtcbiAgICAgIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpXG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcbiAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wVmFsdWUpXG4gICAgICAgICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJsaW5rIGlzIGEgc2VsZi1jbG9zaW5nIHRhZyBhbmQgbXVzdCBuZWl0aGVyIGhhdmUgYGNoaWxkcmVuYCBub3IgdXNlIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB0YXJnZXQucHVzaChlbmRPZlN0YXJ0VGFnU2VsZkNsb3NpbmcpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVzY2FwZVN0eWxlVGV4dENvbnRlbnQoc3R5bGVUZXh0KSB7XG4gICAgICBjaGVja0h0bWxTdHJpbmdDb2VyY2lvbihzdHlsZVRleHQpO1xuICAgICAgcmV0dXJuIChcIlwiICsgc3R5bGVUZXh0KS5yZXBsYWNlKHN0eWxlUmVnZXgsIHN0eWxlUmVwbGFjZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoU2VsZkNsb3NpbmcodGFyZ2V0LCBwcm9wcywgdGFnKSB7XG4gICAgICB0YXJnZXQucHVzaChzdGFydENodW5rRm9yVGFnKHRhZykpO1xuICAgICAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcylcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuICAgICAgICAgIGlmIChudWxsICE9IHByb3BWYWx1ZSlcbiAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICB0YWcgK1xuICAgICAgICAgICAgICAgICAgICBcIiBpcyBhIHNlbGYtY2xvc2luZyB0YWcgYW5kIG11c3QgbmVpdGhlciBoYXZlIGBjaGlsZHJlbmAgbm9yIHVzZSBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLlwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZ1NlbGZDbG9zaW5nKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoVGl0bGVJbXBsKHRhcmdldCwgcHJvcHMpIHtcbiAgICAgIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoXCJ0aXRsZVwiKSk7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBudWxsLFxuICAgICAgICBpbm5lckhUTUwgPSBudWxsLFxuICAgICAgICBwcm9wS2V5O1xuICAgICAgZm9yIChwcm9wS2V5IGluIHByb3BzKVxuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG4gICAgICAgICAgaWYgKG51bGwgIT0gcHJvcFZhbHVlKVxuICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gcHJvcFZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICBpbm5lckhUTUwgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIHRhcmdldC5wdXNoKGVuZE9mU3RhcnRUYWcpO1xuICAgICAgcHJvcHMgPSBBcnJheS5pc0FycmF5KGNoaWxkcmVuKVxuICAgICAgICA/IDIgPiBjaGlsZHJlbi5sZW5ndGhcbiAgICAgICAgICA/IGNoaWxkcmVuWzBdXG4gICAgICAgICAgOiBudWxsXG4gICAgICAgIDogY2hpbGRyZW47XG4gICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBwcm9wcyAmJlxuICAgICAgICBcInN5bWJvbFwiICE9PSB0eXBlb2YgcHJvcHMgJiZcbiAgICAgICAgbnVsbCAhPT0gcHJvcHMgJiZcbiAgICAgICAgdm9pZCAwICE9PSBwcm9wcyAmJlxuICAgICAgICB0YXJnZXQucHVzaChlc2NhcGVUZXh0Rm9yQnJvd3NlcihcIlwiICsgcHJvcHMpKTtcbiAgICAgIHB1c2hJbm5lckhUTUwodGFyZ2V0LCBpbm5lckhUTUwsIGNoaWxkcmVuKTtcbiAgICAgIHRhcmdldC5wdXNoKGVuZENodW5rRm9yVGFnKFwidGl0bGVcIikpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hTY3JpcHRJbXBsKHRhcmdldCwgcHJvcHMpIHtcbiAgICAgIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoXCJzY3JpcHRcIikpO1xuICAgICAgdmFyIGNoaWxkcmVuID0gbnVsbCxcbiAgICAgICAgaW5uZXJIVE1MID0gbnVsbCxcbiAgICAgICAgcHJvcEtleTtcbiAgICAgIGZvciAocHJvcEtleSBpbiBwcm9wcylcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuICAgICAgICAgIGlmIChudWxsICE9IHByb3BWYWx1ZSlcbiAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICBjaGlsZHJlbiA9IHByb3BWYWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgaW5uZXJIVE1MID0gcHJvcFZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB0YXJnZXQucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgICAgIG51bGwgIT0gY2hpbGRyZW4gJiZcbiAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIGNoaWxkcmVuICYmXG4gICAgICAgICgocHJvcHMgPVxuICAgICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiBjaGlsZHJlblxuICAgICAgICAgICAgPyBcImEgbnVtYmVyIGZvciBjaGlsZHJlblwiXG4gICAgICAgICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pXG4gICAgICAgICAgICAgID8gXCJhbiBhcnJheSBmb3IgY2hpbGRyZW5cIlxuICAgICAgICAgICAgICA6IFwic29tZXRoaW5nIHVuZXhwZWN0ZWQgZm9yIGNoaWxkcmVuXCIpLFxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiQSBzY3JpcHQgZWxlbWVudCB3YXMgcmVuZGVyZWQgd2l0aCAlcy4gSWYgc2NyaXB0IGVsZW1lbnQgaGFzIGNoaWxkcmVuIGl0IG11c3QgYmUgYSBzaW5nbGUgc3RyaW5nLiBDb25zaWRlciB1c2luZyBkYW5nZXJvdXNseVNldElubmVySFRNTCBvciBwYXNzaW5nIGEgcGxhaW4gc3RyaW5nIGFzIGNoaWxkcmVuLlwiLFxuICAgICAgICAgIHByb3BzXG4gICAgICAgICkpO1xuICAgICAgcHVzaElubmVySFRNTCh0YXJnZXQsIGlubmVySFRNTCwgY2hpbGRyZW4pO1xuICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGNoaWxkcmVuICYmXG4gICAgICAgIHRhcmdldC5wdXNoKGVzY2FwZUVudGlyZUlubGluZVNjcmlwdENvbnRlbnQoY2hpbGRyZW4pKTtcbiAgICAgIHRhcmdldC5wdXNoKGVuZENodW5rRm9yVGFnKFwic2NyaXB0XCIpKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoU3RhcnRHZW5lcmljRWxlbWVudCh0YXJnZXQsIHByb3BzLCB0YWcpIHtcbiAgICAgIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcodGFnKSk7XG4gICAgICB2YXIgaW5uZXJIVE1MID0gKHRhZyA9IG51bGwpLFxuICAgICAgICBwcm9wS2V5O1xuICAgICAgZm9yIChwcm9wS2V5IGluIHByb3BzKVxuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG4gICAgICAgICAgaWYgKG51bGwgIT0gcHJvcFZhbHVlKVxuICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICAgIHRhZyA9IHByb3BWYWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgaW5uZXJIVE1MID0gcHJvcFZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB0YXJnZXQucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgICAgIHB1c2hJbm5lckhUTUwodGFyZ2V0LCBpbm5lckhUTUwsIHRhZyk7XG4gICAgICByZXR1cm4gXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHRhZ1xuICAgICAgICA/ICh0YXJnZXQucHVzaChlc2NhcGVUZXh0Rm9yQnJvd3Nlcih0YWcpKSwgbnVsbClcbiAgICAgICAgOiB0YWc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0YXJ0Q2h1bmtGb3JUYWcodGFnKSB7XG4gICAgICB2YXIgdGFnU3RhcnRDaHVuayA9IHZhbGlkYXRlZFRhZ0NhY2hlLmdldCh0YWcpO1xuICAgICAgaWYgKHZvaWQgMCA9PT0gdGFnU3RhcnRDaHVuaykge1xuICAgICAgICBpZiAoIVZBTElEX1RBR19SRUdFWC50ZXN0KHRhZykpIHRocm93IEVycm9yKFwiSW52YWxpZCB0YWc6IFwiICsgdGFnKTtcbiAgICAgICAgdGFnU3RhcnRDaHVuayA9IFwiPFwiICsgdGFnO1xuICAgICAgICB2YWxpZGF0ZWRUYWdDYWNoZS5zZXQodGFnLCB0YWdTdGFydENodW5rKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YWdTdGFydENodW5rO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoU3RhcnRJbnN0YW5jZShcbiAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgIHR5cGUsXG4gICAgICBwcm9wcyxcbiAgICAgIHJlc3VtYWJsZVN0YXRlLFxuICAgICAgcmVuZGVyU3RhdGUsXG4gICAgICBob2lzdGFibGVTdGF0ZSxcbiAgICAgIGZvcm1hdENvbnRleHQsXG4gICAgICB0ZXh0RW1iZWRkZWQsXG4gICAgICBpc0ZhbGxiYWNrXG4gICAgKSB7XG4gICAgICB2YWxpZGF0ZVByb3BlcnRpZXMkMih0eXBlLCBwcm9wcyk7XG4gICAgICAoXCJpbnB1dFwiICE9PSB0eXBlICYmIFwidGV4dGFyZWFcIiAhPT0gdHlwZSAmJiBcInNlbGVjdFwiICE9PSB0eXBlKSB8fFxuICAgICAgICBudWxsID09IHByb3BzIHx8XG4gICAgICAgIG51bGwgIT09IHByb3BzLnZhbHVlIHx8XG4gICAgICAgIGRpZFdhcm5WYWx1ZU51bGwgfHxcbiAgICAgICAgKChkaWRXYXJuVmFsdWVOdWxsID0gITApLFxuICAgICAgICBcInNlbGVjdFwiID09PSB0eXBlICYmIHByb3BzLm11bHRpcGxlXG4gICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcImB2YWx1ZWAgcHJvcCBvbiBgJXNgIHNob3VsZCBub3QgYmUgbnVsbC4gQ29uc2lkZXIgdXNpbmcgYW4gZW1wdHkgYXJyYXkgd2hlbiBgbXVsdGlwbGVgIGlzIHNldCB0byBgdHJ1ZWAgdG8gY2xlYXIgdGhlIGNvbXBvbmVudCBvciBgdW5kZWZpbmVkYCBmb3IgdW5jb250cm9sbGVkIGNvbXBvbmVudHMuXCIsXG4gICAgICAgICAgICAgIHR5cGVcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiYHZhbHVlYCBwcm9wIG9uIGAlc2Agc2hvdWxkIG5vdCBiZSBudWxsLiBDb25zaWRlciB1c2luZyBhbiBlbXB0eSBzdHJpbmcgdG8gY2xlYXIgdGhlIGNvbXBvbmVudCBvciBgdW5kZWZpbmVkYCBmb3IgdW5jb250cm9sbGVkIGNvbXBvbmVudHMuXCIsXG4gICAgICAgICAgICAgIHR5cGVcbiAgICAgICAgICAgICkpO1xuICAgICAgYjogaWYgKC0xID09PSB0eXBlLmluZGV4T2YoXCItXCIpKSB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITE7XG4gICAgICBlbHNlXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJhbm5vdGF0aW9uLXhtbFwiOlxuICAgICAgICAgIGNhc2UgXCJjb2xvci1wcm9maWxlXCI6XG4gICAgICAgICAgY2FzZSBcImZvbnQtZmFjZVwiOlxuICAgICAgICAgIGNhc2UgXCJmb250LWZhY2Utc3JjXCI6XG4gICAgICAgICAgY2FzZSBcImZvbnQtZmFjZS11cmlcIjpcbiAgICAgICAgICBjYXNlIFwiZm9udC1mYWNlLWZvcm1hdFwiOlxuICAgICAgICAgIGNhc2UgXCJmb250LWZhY2UtbmFtZVwiOlxuICAgICAgICAgIGNhc2UgXCJtaXNzaW5nLWdseXBoXCI6XG4gICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMTtcbiAgICAgICAgICAgIGJyZWFrIGI7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICEwO1xuICAgICAgICB9XG4gICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgfHxcbiAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHByb3BzLmlzIHx8XG4gICAgICAgIHdhcm5Vbmtub3duUHJvcGVydGllcyh0eXBlLCBwcm9wcywgbnVsbCk7XG4gICAgICAhcHJvcHMuc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nICYmXG4gICAgICAgIHByb3BzLmNvbnRlbnRFZGl0YWJsZSAmJlxuICAgICAgICBudWxsICE9IHByb3BzLmNoaWxkcmVuICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJBIGNvbXBvbmVudCBpcyBgY29udGVudEVkaXRhYmxlYCBhbmQgY29udGFpbnMgYGNoaWxkcmVuYCBtYW5hZ2VkIGJ5IFJlYWN0LiBJdCBpcyBub3cgeW91ciByZXNwb25zaWJpbGl0eSB0byBndWFyYW50ZWUgdGhhdCBub25lIG9mIHRob3NlIG5vZGVzIGFyZSB1bmV4cGVjdGVkbHkgbW9kaWZpZWQgb3IgZHVwbGljYXRlZC4gVGhpcyBpcyBwcm9iYWJseSBub3QgaW50ZW50aW9uYWwuXCJcbiAgICAgICAgKTtcbiAgICAgIGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSAhPT0gU1ZHX01PREUgJiZcbiAgICAgICAgZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlICE9PSBNQVRITUxfTU9ERSAmJlxuICAgICAgICAtMSA9PT0gdHlwZS5pbmRleE9mKFwiLVwiKSAmJlxuICAgICAgICB0eXBlLnRvTG93ZXJDYXNlKCkgIT09IHR5cGUgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIjwlcyAvPiBpcyB1c2luZyBpbmNvcnJlY3QgY2FzaW5nLiBVc2UgUGFzY2FsQ2FzZSBmb3IgUmVhY3QgY29tcG9uZW50cywgb3IgbG93ZXJjYXNlIGZvciBIVE1MIGVsZW1lbnRzLlwiLFxuICAgICAgICAgIHR5cGVcbiAgICAgICAgKTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwiZGl2XCI6XG4gICAgICAgIGNhc2UgXCJzcGFuXCI6XG4gICAgICAgIGNhc2UgXCJzdmdcIjpcbiAgICAgICAgY2FzZSBcInBhdGhcIjpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImFcIjpcbiAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChzdGFydENodW5rRm9yVGFnKFwiYVwiKSk7XG4gICAgICAgICAgdmFyIGNoaWxkcmVuID0gbnVsbCxcbiAgICAgICAgICAgIGlubmVySFRNTCA9IG51bGwsXG4gICAgICAgICAgICBwcm9wS2V5O1xuICAgICAgICAgIGZvciAocHJvcEtleSBpbiBwcm9wcylcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG4gICAgICAgICAgICAgIGlmIChudWxsICE9IHByb3BWYWx1ZSlcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbiA9IHByb3BWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJIVE1MID0gcHJvcFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJocmVmXCI6XG4gICAgICAgICAgICAgICAgICAgIFwiXCIgPT09IHByb3BWYWx1ZVxuICAgICAgICAgICAgICAgICAgICAgID8gcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQkanNjb21wJDAsIFwiaHJlZlwiLCBcIlwiKVxuICAgICAgICAgICAgICAgICAgICAgIDogcHVzaEF0dHJpYnV0ZSh0YXJnZXQkanNjb21wJDAsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQkanNjb21wJDAsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKGVuZE9mU3RhcnRUYWcpO1xuICAgICAgICAgIHB1c2hJbm5lckhUTUwodGFyZ2V0JGpzY29tcCQwLCBpbm5lckhUTUwsIGNoaWxkcmVuKTtcbiAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGNoaWxkcmVuKSB7XG4gICAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChlc2NhcGVUZXh0Rm9yQnJvd3NlcihjaGlsZHJlbikpO1xuICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMCA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMCA9IGNoaWxkcmVuO1xuICAgICAgICAgIHJldHVybiBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDA7XG4gICAgICAgIGNhc2UgXCJnXCI6XG4gICAgICAgIGNhc2UgXCJwXCI6XG4gICAgICAgIGNhc2UgXCJsaVwiOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic2VsZWN0XCI6XG4gICAgICAgICAgY2hlY2tDb250cm9sbGVkVmFsdWVQcm9wcyhcInNlbGVjdFwiLCBwcm9wcyk7XG4gICAgICAgICAgY2hlY2tTZWxlY3RQcm9wKHByb3BzLCBcInZhbHVlXCIpO1xuICAgICAgICAgIGNoZWNrU2VsZWN0UHJvcChwcm9wcywgXCJkZWZhdWx0VmFsdWVcIik7XG4gICAgICAgICAgdm9pZCAwID09PSBwcm9wcy52YWx1ZSB8fFxuICAgICAgICAgICAgdm9pZCAwID09PSBwcm9wcy5kZWZhdWx0VmFsdWUgfHxcbiAgICAgICAgICAgIGRpZFdhcm5EZWZhdWx0U2VsZWN0VmFsdWUgfHxcbiAgICAgICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlNlbGVjdCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCBib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBzZWxlY3QgZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiBodHRwczovL3JlYWN0LmRldi9saW5rL2NvbnRyb2xsZWQtY29tcG9uZW50c1wiXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgKGRpZFdhcm5EZWZhdWx0U2VsZWN0VmFsdWUgPSAhMCkpO1xuICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoXCJzZWxlY3RcIikpO1xuICAgICAgICAgIHZhciBjaGlsZHJlbiRqc2NvbXAkMCA9IG51bGwsXG4gICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDAgPSBudWxsLFxuICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkMDtcbiAgICAgICAgICBmb3IgKHByb3BLZXkkanNjb21wJDAgaW4gcHJvcHMpXG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSRqc2NvbXAkMCkpIHtcbiAgICAgICAgICAgICAgdmFyIHByb3BWYWx1ZSRqc2NvbXAkMCA9IHByb3BzW3Byb3BLZXkkanNjb21wJDBdO1xuICAgICAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wVmFsdWUkanNjb21wJDApXG4gICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5JGpzY29tcCQwKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4kanNjb21wJDAgPSBwcm9wVmFsdWUkanNjb21wJDA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgICAgIGlubmVySFRNTCRqc2NvbXAkMCA9IHByb3BWYWx1ZSRqc2NvbXAkMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZGVmYXVsdFZhbHVlXCI6XG4gICAgICAgICAgICAgICAgICBjYXNlIFwidmFsdWVcIjpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBwdXNoQXR0cmlidXRlKFxuICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BWYWx1ZSRqc2NvbXAkMFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgICAgICAgICBwdXNoSW5uZXJIVE1MKHRhcmdldCRqc2NvbXAkMCwgaW5uZXJIVE1MJGpzY29tcCQwLCBjaGlsZHJlbiRqc2NvbXAkMCk7XG4gICAgICAgICAgcmV0dXJuIGNoaWxkcmVuJGpzY29tcCQwO1xuICAgICAgICBjYXNlIFwib3B0aW9uXCI6XG4gICAgICAgICAgdmFyIHNlbGVjdGVkVmFsdWUgPSBmb3JtYXRDb250ZXh0LnNlbGVjdGVkVmFsdWU7XG4gICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goc3RhcnRDaHVua0ZvclRhZyhcIm9wdGlvblwiKSk7XG4gICAgICAgICAgdmFyIGNoaWxkcmVuJGpzY29tcCQxID0gbnVsbCxcbiAgICAgICAgICAgIHZhbHVlID0gbnVsbCxcbiAgICAgICAgICAgIHNlbGVjdGVkID0gbnVsbCxcbiAgICAgICAgICAgIGlubmVySFRNTCRqc2NvbXAkMSA9IG51bGwsXG4gICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQxO1xuICAgICAgICAgIGZvciAocHJvcEtleSRqc2NvbXAkMSBpbiBwcm9wcylcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5JGpzY29tcCQxKSkge1xuICAgICAgICAgICAgICB2YXIgcHJvcFZhbHVlJGpzY29tcCQxID0gcHJvcHNbcHJvcEtleSRqc2NvbXAkMV07XG4gICAgICAgICAgICAgIGlmIChudWxsICE9IHByb3BWYWx1ZSRqc2NvbXAkMSlcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHByb3BLZXkkanNjb21wJDEpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbiRqc2NvbXAkMSA9IHByb3BWYWx1ZSRqc2NvbXAkMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwic2VsZWN0ZWRcIjpcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSBwcm9wVmFsdWUkanNjb21wJDE7XG4gICAgICAgICAgICAgICAgICAgIGRpZFdhcm5TZWxlY3RlZFNldE9uT3B0aW9uIHx8XG4gICAgICAgICAgICAgICAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlVzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBvbiA8c2VsZWN0PiBpbnN0ZWFkIG9mIHNldHRpbmcgYHNlbGVjdGVkYCBvbiA8b3B0aW9uPi5cIlxuICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgKGRpZFdhcm5TZWxlY3RlZFNldE9uT3B0aW9uID0gITApKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJIVE1MJGpzY29tcCQxID0gcHJvcFZhbHVlJGpzY29tcCQxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJ2YWx1ZVwiOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHByb3BWYWx1ZSRqc2NvbXAkMTtcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHB1c2hBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BLZXkkanNjb21wJDEsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcFZhbHVlJGpzY29tcCQxXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIGlmIChudWxsICE9IHNlbGVjdGVkVmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChudWxsICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBcInZhbHVlXCIpO1xuICAgICAgICAgICAgICB2YXIgc3RyaW5nVmFsdWUgPSBcIlwiICsgdmFsdWU7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgbnVsbCA9PT0gaW5uZXJIVE1MJGpzY29tcCQxIHx8XG4gICAgICAgICAgICAgICAgZGlkV2FybkludmFsaWRPcHRpb25Jbm5lckhUTUwgfHxcbiAgICAgICAgICAgICAgICAoKGRpZFdhcm5JbnZhbGlkT3B0aW9uSW5uZXJIVE1MID0gITApLFxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlBhc3MgYSBgdmFsdWVgIHByb3AgaWYgeW91IHNldCBkYW5nZXJvdXNseUlubmVySFRNTCBzbyBSZWFjdCBrbm93cyB3aGljaCB2YWx1ZSBzaG91bGQgYmUgc2VsZWN0ZWQuXCJcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAoc3RyaW5nVmFsdWUgPSBmbGF0dGVuT3B0aW9uQ2hpbGRyZW4oY2hpbGRyZW4kanNjb21wJDEpKTtcbiAgICAgICAgICAgIGlmIChpc0FycmF5SW1wbChzZWxlY3RlZFZhbHVlKSlcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxlY3RlZFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgKGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24oc2VsZWN0ZWRWYWx1ZVtpXSwgXCJ2YWx1ZVwiKSxcbiAgICAgICAgICAgICAgICAgIFwiXCIgKyBzZWxlY3RlZFZhbHVlW2ldID09PSBzdHJpbmdWYWx1ZSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKCcgc2VsZWN0ZWQ9XCJcIicpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24oc2VsZWN0ZWRWYWx1ZSwgXCJzZWxlY3QudmFsdWVcIiksXG4gICAgICAgICAgICAgICAgXCJcIiArIHNlbGVjdGVkVmFsdWUgPT09IHN0cmluZ1ZhbHVlICYmXG4gICAgICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaCgnIHNlbGVjdGVkPVwiXCInKTtcbiAgICAgICAgICB9IGVsc2Ugc2VsZWN0ZWQgJiYgdGFyZ2V0JGpzY29tcCQwLnB1c2goJyBzZWxlY3RlZD1cIlwiJyk7XG4gICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gICAgICAgICAgcHVzaElubmVySFRNTCh0YXJnZXQkanNjb21wJDAsIGlubmVySFRNTCRqc2NvbXAkMSwgY2hpbGRyZW4kanNjb21wJDEpO1xuICAgICAgICAgIHJldHVybiBjaGlsZHJlbiRqc2NvbXAkMTtcbiAgICAgICAgY2FzZSBcInRleHRhcmVhXCI6XG4gICAgICAgICAgY2hlY2tDb250cm9sbGVkVmFsdWVQcm9wcyhcInRleHRhcmVhXCIsIHByb3BzKTtcbiAgICAgICAgICB2b2lkIDAgPT09IHByb3BzLnZhbHVlIHx8XG4gICAgICAgICAgICB2b2lkIDAgPT09IHByb3BzLmRlZmF1bHRWYWx1ZSB8fFxuICAgICAgICAgICAgZGlkV2FybkRlZmF1bHRUZXh0YXJlYVZhbHVlIHx8XG4gICAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJUZXh0YXJlYSBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCBib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCB0ZXh0YXJlYSBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiBodHRwczovL3JlYWN0LmRldi9saW5rL2NvbnRyb2xsZWQtY29tcG9uZW50c1wiXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgKGRpZFdhcm5EZWZhdWx0VGV4dGFyZWFWYWx1ZSA9ICEwKSk7XG4gICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goc3RhcnRDaHVua0ZvclRhZyhcInRleHRhcmVhXCIpKTtcbiAgICAgICAgICB2YXIgdmFsdWUkanNjb21wJDAgPSBudWxsLFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlID0gbnVsbCxcbiAgICAgICAgICAgIGNoaWxkcmVuJGpzY29tcCQyID0gbnVsbCxcbiAgICAgICAgICAgIHByb3BLZXkkanNjb21wJDI7XG4gICAgICAgICAgZm9yIChwcm9wS2V5JGpzY29tcCQyIGluIHByb3BzKVxuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkkanNjb21wJDIpKSB7XG4gICAgICAgICAgICAgIHZhciBwcm9wVmFsdWUkanNjb21wJDIgPSBwcm9wc1twcm9wS2V5JGpzY29tcCQyXTtcbiAgICAgICAgICAgICAgaWYgKG51bGwgIT0gcHJvcFZhbHVlJGpzY29tcCQyKVxuICAgICAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSRqc2NvbXAkMikge1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuJGpzY29tcCQyID0gcHJvcFZhbHVlJGpzY29tcCQyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJ2YWx1ZVwiOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSRqc2NvbXAkMCA9IHByb3BWYWx1ZSRqc2NvbXAkMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZGVmYXVsdFZhbHVlXCI6XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9IHByb3BWYWx1ZSRqc2NvbXAkMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgXCJgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIGRvZXMgbm90IG1ha2Ugc2Vuc2Ugb24gPHRleHRhcmVhPi5cIlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkMixcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wVmFsdWUkanNjb21wJDJcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgbnVsbCA9PT0gdmFsdWUkanNjb21wJDAgJiZcbiAgICAgICAgICAgIG51bGwgIT09IGRlZmF1bHRWYWx1ZSAmJlxuICAgICAgICAgICAgKHZhbHVlJGpzY29tcCQwID0gZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgICAgICAgICBpZiAobnVsbCAhPSBjaGlsZHJlbiRqc2NvbXAkMikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJVc2UgdGhlIGBkZWZhdWx0VmFsdWVgIG9yIGB2YWx1ZWAgcHJvcHMgaW5zdGVhZCBvZiBzZXR0aW5nIGNoaWxkcmVuIG9uIDx0ZXh0YXJlYT4uXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAobnVsbCAhPSB2YWx1ZSRqc2NvbXAkMClcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJJZiB5b3Ugc3VwcGx5IGBkZWZhdWx0VmFsdWVgIG9uIGEgPHRleHRhcmVhPiwgZG8gbm90IHBhc3MgY2hpbGRyZW4uXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChpc0FycmF5SW1wbChjaGlsZHJlbiRqc2NvbXAkMikpIHtcbiAgICAgICAgICAgICAgaWYgKDEgPCBjaGlsZHJlbiRqc2NvbXAkMi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCI8dGV4dGFyZWE+IGNhbiBvbmx5IGhhdmUgYXQgbW9zdCBvbmUgY2hpbGQuXCIpO1xuICAgICAgICAgICAgICBjaGVja0h0bWxTdHJpbmdDb2VyY2lvbihjaGlsZHJlbiRqc2NvbXAkMlswXSk7XG4gICAgICAgICAgICAgIHZhbHVlJGpzY29tcCQwID0gXCJcIiArIGNoaWxkcmVuJGpzY29tcCQyWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hlY2tIdG1sU3RyaW5nQ29lcmNpb24oY2hpbGRyZW4kanNjb21wJDIpO1xuICAgICAgICAgICAgdmFsdWUkanNjb21wJDAgPSBcIlwiICsgY2hpbGRyZW4kanNjb21wJDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiB2YWx1ZSRqc2NvbXAkMCAmJlxuICAgICAgICAgICAgXCJcXG5cIiA9PT0gdmFsdWUkanNjb21wJDBbMF0gJiZcbiAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKGxlYWRpbmdOZXdsaW5lKTtcbiAgICAgICAgICBudWxsICE9PSB2YWx1ZSRqc2NvbXAkMCAmJlxuICAgICAgICAgICAgKGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odmFsdWUkanNjb21wJDAsIFwidmFsdWVcIiksXG4gICAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChlc2NhcGVUZXh0Rm9yQnJvd3NlcihcIlwiICsgdmFsdWUkanNjb21wJDApKSk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNhc2UgXCJpbnB1dFwiOlxuICAgICAgICAgIGNoZWNrQ29udHJvbGxlZFZhbHVlUHJvcHMoXCJpbnB1dFwiLCBwcm9wcyk7XG4gICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goc3RhcnRDaHVua0ZvclRhZyhcImlucHV0XCIpKTtcbiAgICAgICAgICB2YXIgbmFtZSA9IG51bGwsXG4gICAgICAgICAgICBmb3JtQWN0aW9uID0gbnVsbCxcbiAgICAgICAgICAgIGZvcm1FbmNUeXBlID0gbnVsbCxcbiAgICAgICAgICAgIGZvcm1NZXRob2QgPSBudWxsLFxuICAgICAgICAgICAgZm9ybVRhcmdldCA9IG51bGwsXG4gICAgICAgICAgICB2YWx1ZSRqc2NvbXAkMSA9IG51bGwsXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWUkanNjb21wJDAgPSBudWxsLFxuICAgICAgICAgICAgY2hlY2tlZCA9IG51bGwsXG4gICAgICAgICAgICBkZWZhdWx0Q2hlY2tlZCA9IG51bGwsXG4gICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQzO1xuICAgICAgICAgIGZvciAocHJvcEtleSRqc2NvbXAkMyBpbiBwcm9wcylcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5JGpzY29tcCQzKSkge1xuICAgICAgICAgICAgICB2YXIgcHJvcFZhbHVlJGpzY29tcCQzID0gcHJvcHNbcHJvcEtleSRqc2NvbXAkM107XG4gICAgICAgICAgICAgIGlmIChudWxsICE9IHByb3BWYWx1ZSRqc2NvbXAkMylcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHByb3BLZXkkanNjb21wJDMpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgIFwiaW5wdXQgaXMgYSBzZWxmLWNsb3NpbmcgdGFnIGFuZCBtdXN0IG5laXRoZXIgaGF2ZSBgY2hpbGRyZW5gIG5vciB1c2UgYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC5cIlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcIm5hbWVcIjpcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IHByb3BWYWx1ZSRqc2NvbXAkMztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZm9ybUFjdGlvblwiOlxuICAgICAgICAgICAgICAgICAgICBmb3JtQWN0aW9uID0gcHJvcFZhbHVlJGpzY29tcCQzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJmb3JtRW5jVHlwZVwiOlxuICAgICAgICAgICAgICAgICAgICBmb3JtRW5jVHlwZSA9IHByb3BWYWx1ZSRqc2NvbXAkMztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZm9ybU1ldGhvZFwiOlxuICAgICAgICAgICAgICAgICAgICBmb3JtTWV0aG9kID0gcHJvcFZhbHVlJGpzY29tcCQzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJmb3JtVGFyZ2V0XCI6XG4gICAgICAgICAgICAgICAgICAgIGZvcm1UYXJnZXQgPSBwcm9wVmFsdWUkanNjb21wJDM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImRlZmF1bHRDaGVja2VkXCI6XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRDaGVja2VkID0gcHJvcFZhbHVlJGpzY29tcCQzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJkZWZhdWx0VmFsdWVcIjpcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlJGpzY29tcCQwID0gcHJvcFZhbHVlJGpzY29tcCQzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJjaGVja2VkXCI6XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrZWQgPSBwcm9wVmFsdWUkanNjb21wJDM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcInZhbHVlXCI6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlJGpzY29tcCQxID0gcHJvcFZhbHVlJGpzY29tcCQzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHB1c2hBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BLZXkkanNjb21wJDMsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcFZhbHVlJGpzY29tcCQzXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIG51bGwgPT09IGZvcm1BY3Rpb24gfHxcbiAgICAgICAgICAgIFwiaW1hZ2VcIiA9PT0gcHJvcHMudHlwZSB8fFxuICAgICAgICAgICAgXCJzdWJtaXRcIiA9PT0gcHJvcHMudHlwZSB8fFxuICAgICAgICAgICAgZGlkV2FybkZvcm1BY3Rpb25UeXBlIHx8XG4gICAgICAgICAgICAoKGRpZFdhcm5Gb3JtQWN0aW9uVHlwZSA9ICEwKSxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICdBbiBpbnB1dCBjYW4gb25seSBzcGVjaWZ5IGEgZm9ybUFjdGlvbiBhbG9uZyB3aXRoIHR5cGU9XCJzdWJtaXRcIiBvciB0eXBlPVwiaW1hZ2VcIi4nXG4gICAgICAgICAgICApKTtcbiAgICAgICAgICB2YXIgZm9ybURhdGEgPSBwdXNoRm9ybUFjdGlvbkF0dHJpYnV0ZShcbiAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLFxuICAgICAgICAgICAgcmVuZGVyU3RhdGUsXG4gICAgICAgICAgICBmb3JtQWN0aW9uLFxuICAgICAgICAgICAgZm9ybUVuY1R5cGUsXG4gICAgICAgICAgICBmb3JtTWV0aG9kLFxuICAgICAgICAgICAgZm9ybVRhcmdldCxcbiAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICApO1xuICAgICAgICAgIG51bGwgPT09IGNoZWNrZWQgfHxcbiAgICAgICAgICAgIG51bGwgPT09IGRlZmF1bHRDaGVja2VkIHx8XG4gICAgICAgICAgICBkaWRXYXJuRGVmYXVsdENoZWNrZWQgfHxcbiAgICAgICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzIGNvbnRhaW5zIGFuIGlucHV0IG9mIHR5cGUgJXMgd2l0aCBib3RoIGNoZWNrZWQgYW5kIGRlZmF1bHRDaGVja2VkIHByb3BzLiBJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAoc3BlY2lmeSBlaXRoZXIgdGhlIGNoZWNrZWQgcHJvcCwgb3IgdGhlIGRlZmF1bHRDaGVja2VkIHByb3AsIGJ1dCBub3QgYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiBodHRwczovL3JlYWN0LmRldi9saW5rL2NvbnRyb2xsZWQtY29tcG9uZW50c1wiLFxuICAgICAgICAgICAgICBcIkEgY29tcG9uZW50XCIsXG4gICAgICAgICAgICAgIHByb3BzLnR5cGVcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAoZGlkV2FybkRlZmF1bHRDaGVja2VkID0gITApKTtcbiAgICAgICAgICBudWxsID09PSB2YWx1ZSRqc2NvbXAkMSB8fFxuICAgICAgICAgICAgbnVsbCA9PT0gZGVmYXVsdFZhbHVlJGpzY29tcCQwIHx8XG4gICAgICAgICAgICBkaWRXYXJuRGVmYXVsdElucHV0VmFsdWUgfHxcbiAgICAgICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzIGNvbnRhaW5zIGFuIGlucHV0IG9mIHR5cGUgJXMgd2l0aCBib3RoIHZhbHVlIGFuZCBkZWZhdWx0VmFsdWUgcHJvcHMuIElucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIChzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90IGJvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0IGVsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHNcIixcbiAgICAgICAgICAgICAgXCJBIGNvbXBvbmVudFwiLFxuICAgICAgICAgICAgICBwcm9wcy50eXBlXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgKGRpZFdhcm5EZWZhdWx0SW5wdXRWYWx1ZSA9ICEwKSk7XG4gICAgICAgICAgbnVsbCAhPT0gY2hlY2tlZFxuICAgICAgICAgICAgPyBwdXNoQm9vbGVhbkF0dHJpYnV0ZSh0YXJnZXQkanNjb21wJDAsIFwiY2hlY2tlZFwiLCBjaGVja2VkKVxuICAgICAgICAgICAgOiBudWxsICE9PSBkZWZhdWx0Q2hlY2tlZCAmJlxuICAgICAgICAgICAgICBwdXNoQm9vbGVhbkF0dHJpYnV0ZSh0YXJnZXQkanNjb21wJDAsIFwiY2hlY2tlZFwiLCBkZWZhdWx0Q2hlY2tlZCk7XG4gICAgICAgICAgbnVsbCAhPT0gdmFsdWUkanNjb21wJDFcbiAgICAgICAgICAgID8gcHVzaEF0dHJpYnV0ZSh0YXJnZXQkanNjb21wJDAsIFwidmFsdWVcIiwgdmFsdWUkanNjb21wJDEpXG4gICAgICAgICAgICA6IG51bGwgIT09IGRlZmF1bHRWYWx1ZSRqc2NvbXAkMCAmJlxuICAgICAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCRqc2NvbXAkMCwgXCJ2YWx1ZVwiLCBkZWZhdWx0VmFsdWUkanNjb21wJDApO1xuICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKGVuZE9mU3RhcnRUYWdTZWxmQ2xvc2luZyk7XG4gICAgICAgICAgbnVsbCAhPSBmb3JtRGF0YSAmJlxuICAgICAgICAgICAgZm9ybURhdGEuZm9yRWFjaChwdXNoQWRkaXRpb25hbEZvcm1GaWVsZCwgdGFyZ2V0JGpzY29tcCQwKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSBcImJ1dHRvblwiOlxuICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoXCJidXR0b25cIikpO1xuICAgICAgICAgIHZhciBjaGlsZHJlbiRqc2NvbXAkMyA9IG51bGwsXG4gICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDIgPSBudWxsLFxuICAgICAgICAgICAgbmFtZSRqc2NvbXAkMCA9IG51bGwsXG4gICAgICAgICAgICBmb3JtQWN0aW9uJGpzY29tcCQwID0gbnVsbCxcbiAgICAgICAgICAgIGZvcm1FbmNUeXBlJGpzY29tcCQwID0gbnVsbCxcbiAgICAgICAgICAgIGZvcm1NZXRob2QkanNjb21wJDAgPSBudWxsLFxuICAgICAgICAgICAgZm9ybVRhcmdldCRqc2NvbXAkMCA9IG51bGwsXG4gICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQ0O1xuICAgICAgICAgIGZvciAocHJvcEtleSRqc2NvbXAkNCBpbiBwcm9wcylcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5JGpzY29tcCQ0KSkge1xuICAgICAgICAgICAgICB2YXIgcHJvcFZhbHVlJGpzY29tcCQ0ID0gcHJvcHNbcHJvcEtleSRqc2NvbXAkNF07XG4gICAgICAgICAgICAgIGlmIChudWxsICE9IHByb3BWYWx1ZSRqc2NvbXAkNClcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHByb3BLZXkkanNjb21wJDQpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbiRqc2NvbXAkMyA9IHByb3BWYWx1ZSRqc2NvbXAkNDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJIVE1MJGpzY29tcCQyID0gcHJvcFZhbHVlJGpzY29tcCQ0O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJuYW1lXCI6XG4gICAgICAgICAgICAgICAgICAgIG5hbWUkanNjb21wJDAgPSBwcm9wVmFsdWUkanNjb21wJDQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImZvcm1BY3Rpb25cIjpcbiAgICAgICAgICAgICAgICAgICAgZm9ybUFjdGlvbiRqc2NvbXAkMCA9IHByb3BWYWx1ZSRqc2NvbXAkNDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZm9ybUVuY1R5cGVcIjpcbiAgICAgICAgICAgICAgICAgICAgZm9ybUVuY1R5cGUkanNjb21wJDAgPSBwcm9wVmFsdWUkanNjb21wJDQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImZvcm1NZXRob2RcIjpcbiAgICAgICAgICAgICAgICAgICAgZm9ybU1ldGhvZCRqc2NvbXAkMCA9IHByb3BWYWx1ZSRqc2NvbXAkNDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZm9ybVRhcmdldFwiOlxuICAgICAgICAgICAgICAgICAgICBmb3JtVGFyZ2V0JGpzY29tcCQwID0gcHJvcFZhbHVlJGpzY29tcCQ0O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHB1c2hBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BLZXkkanNjb21wJDQsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcFZhbHVlJGpzY29tcCQ0XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIG51bGwgPT09IGZvcm1BY3Rpb24kanNjb21wJDAgfHxcbiAgICAgICAgICAgIG51bGwgPT0gcHJvcHMudHlwZSB8fFxuICAgICAgICAgICAgXCJzdWJtaXRcIiA9PT0gcHJvcHMudHlwZSB8fFxuICAgICAgICAgICAgZGlkV2FybkZvcm1BY3Rpb25UeXBlIHx8XG4gICAgICAgICAgICAoKGRpZFdhcm5Gb3JtQWN0aW9uVHlwZSA9ICEwKSxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICdBIGJ1dHRvbiBjYW4gb25seSBzcGVjaWZ5IGEgZm9ybUFjdGlvbiBhbG9uZyB3aXRoIHR5cGU9XCJzdWJtaXRcIiBvciBubyB0eXBlLidcbiAgICAgICAgICAgICkpO1xuICAgICAgICAgIHZhciBmb3JtRGF0YSRqc2NvbXAkMCA9IHB1c2hGb3JtQWN0aW9uQXR0cmlidXRlKFxuICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLFxuICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICByZW5kZXJTdGF0ZSxcbiAgICAgICAgICAgIGZvcm1BY3Rpb24kanNjb21wJDAsXG4gICAgICAgICAgICBmb3JtRW5jVHlwZSRqc2NvbXAkMCxcbiAgICAgICAgICAgIGZvcm1NZXRob2QkanNjb21wJDAsXG4gICAgICAgICAgICBmb3JtVGFyZ2V0JGpzY29tcCQwLFxuICAgICAgICAgICAgbmFtZSRqc2NvbXAkMFxuICAgICAgICAgICk7XG4gICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gICAgICAgICAgbnVsbCAhPSBmb3JtRGF0YSRqc2NvbXAkMCAmJlxuICAgICAgICAgICAgZm9ybURhdGEkanNjb21wJDAuZm9yRWFjaChwdXNoQWRkaXRpb25hbEZvcm1GaWVsZCwgdGFyZ2V0JGpzY29tcCQwKTtcbiAgICAgICAgICBwdXNoSW5uZXJIVE1MKHRhcmdldCRqc2NvbXAkMCwgaW5uZXJIVE1MJGpzY29tcCQyLCBjaGlsZHJlbiRqc2NvbXAkMyk7XG4gICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBjaGlsZHJlbiRqc2NvbXAkMykge1xuICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZXNjYXBlVGV4dEZvckJyb3dzZXIoY2hpbGRyZW4kanNjb21wJDMpKTtcbiAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDEgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDEgPSBjaGlsZHJlbiRqc2NvbXAkMztcbiAgICAgICAgICByZXR1cm4gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQxO1xuICAgICAgICBjYXNlIFwiZm9ybVwiOlxuICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoXCJmb3JtXCIpKTtcbiAgICAgICAgICB2YXIgY2hpbGRyZW4kanNjb21wJDQgPSBudWxsLFxuICAgICAgICAgICAgaW5uZXJIVE1MJGpzY29tcCQzID0gbnVsbCxcbiAgICAgICAgICAgIGZvcm1BY3Rpb24kanNjb21wJDEgPSBudWxsLFxuICAgICAgICAgICAgZm9ybUVuY1R5cGUkanNjb21wJDEgPSBudWxsLFxuICAgICAgICAgICAgZm9ybU1ldGhvZCRqc2NvbXAkMSA9IG51bGwsXG4gICAgICAgICAgICBmb3JtVGFyZ2V0JGpzY29tcCQxID0gbnVsbCxcbiAgICAgICAgICAgIHByb3BLZXkkanNjb21wJDU7XG4gICAgICAgICAgZm9yIChwcm9wS2V5JGpzY29tcCQ1IGluIHByb3BzKVxuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkkanNjb21wJDUpKSB7XG4gICAgICAgICAgICAgIHZhciBwcm9wVmFsdWUkanNjb21wJDUgPSBwcm9wc1twcm9wS2V5JGpzY29tcCQ1XTtcbiAgICAgICAgICAgICAgaWYgKG51bGwgIT0gcHJvcFZhbHVlJGpzY29tcCQ1KVxuICAgICAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSRqc2NvbXAkNSkge1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuJGpzY29tcCQ0ID0gcHJvcFZhbHVlJGpzY29tcCQ1O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDMgPSBwcm9wVmFsdWUkanNjb21wJDU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImFjdGlvblwiOlxuICAgICAgICAgICAgICAgICAgICBmb3JtQWN0aW9uJGpzY29tcCQxID0gcHJvcFZhbHVlJGpzY29tcCQ1O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmNUeXBlXCI6XG4gICAgICAgICAgICAgICAgICAgIGZvcm1FbmNUeXBlJGpzY29tcCQxID0gcHJvcFZhbHVlJGpzY29tcCQ1O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJtZXRob2RcIjpcbiAgICAgICAgICAgICAgICAgICAgZm9ybU1ldGhvZCRqc2NvbXAkMSA9IHByb3BWYWx1ZSRqc2NvbXAkNTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwidGFyZ2V0XCI6XG4gICAgICAgICAgICAgICAgICAgIGZvcm1UYXJnZXQkanNjb21wJDEgPSBwcm9wVmFsdWUkanNjb21wJDU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkNSxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wVmFsdWUkanNjb21wJDVcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGZvcm1EYXRhJGpzY29tcCQxID0gbnVsbCxcbiAgICAgICAgICAgIGZvcm1BY3Rpb25OYW1lID0gbnVsbDtcbiAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZm9ybUFjdGlvbiRqc2NvbXAkMSkge1xuICAgICAgICAgICAgKG51bGwgPT09IGZvcm1FbmNUeXBlJGpzY29tcCQxICYmIG51bGwgPT09IGZvcm1NZXRob2QkanNjb21wJDEpIHx8XG4gICAgICAgICAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uTWV0aG9kIHx8XG4gICAgICAgICAgICAgICgoZGlkV2FybkZvcm1BY3Rpb25NZXRob2QgPSAhMCksXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJDYW5ub3Qgc3BlY2lmeSBhIGVuY1R5cGUgb3IgbWV0aG9kIGZvciBhIGZvcm0gdGhhdCBzcGVjaWZpZXMgYSBmdW5jdGlvbiBhcyB0aGUgYWN0aW9uLiBSZWFjdCBwcm92aWRlcyB0aG9zZSBhdXRvbWF0aWNhbGx5LiBUaGV5IHdpbGwgZ2V0IG92ZXJyaWRkZW4uXCJcbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICBudWxsID09PSBmb3JtVGFyZ2V0JGpzY29tcCQxIHx8XG4gICAgICAgICAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uVGFyZ2V0IHx8XG4gICAgICAgICAgICAgICgoZGlkV2FybkZvcm1BY3Rpb25UYXJnZXQgPSAhMCksXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJDYW5ub3Qgc3BlY2lmeSBhIHRhcmdldCBmb3IgYSBmb3JtIHRoYXQgc3BlY2lmaWVzIGEgZnVuY3Rpb24gYXMgdGhlIGFjdGlvbi4gVGhlIGZ1bmN0aW9uIHdpbGwgYWx3YXlzIGJlIGV4ZWN1dGVkIGluIHRoZSBzYW1lIHdpbmRvdy5cIlxuICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIHZhciBjdXN0b21GaWVsZHMgPSBnZXRDdXN0b21Gb3JtRmllbGRzKFxuICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZSxcbiAgICAgICAgICAgICAgZm9ybUFjdGlvbiRqc2NvbXAkMVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG51bGwgIT09IGN1c3RvbUZpZWxkc1xuICAgICAgICAgICAgICA/ICgoZm9ybUFjdGlvbiRqc2NvbXAkMSA9IGN1c3RvbUZpZWxkcy5hY3Rpb24gfHwgXCJcIiksXG4gICAgICAgICAgICAgICAgKGZvcm1FbmNUeXBlJGpzY29tcCQxID0gY3VzdG9tRmllbGRzLmVuY1R5cGUpLFxuICAgICAgICAgICAgICAgIChmb3JtTWV0aG9kJGpzY29tcCQxID0gY3VzdG9tRmllbGRzLm1ldGhvZCksXG4gICAgICAgICAgICAgICAgKGZvcm1UYXJnZXQkanNjb21wJDEgPSBjdXN0b21GaWVsZHMudGFyZ2V0KSxcbiAgICAgICAgICAgICAgICAoZm9ybURhdGEkanNjb21wJDEgPSBjdXN0b21GaWVsZHMuZGF0YSksXG4gICAgICAgICAgICAgICAgKGZvcm1BY3Rpb25OYW1lID0gY3VzdG9tRmllbGRzLm5hbWUpKVxuICAgICAgICAgICAgICA6ICh0YXJnZXQkanNjb21wJDAucHVzaChcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZVNlcGFyYXRvcixcbiAgICAgICAgICAgICAgICAgIFwiYWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVBc3NpZ24sXG4gICAgICAgICAgICAgICAgICBhY3Rpb25KYXZhU2NyaXB0VVJMLFxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlRW5kXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAoZm9ybVRhcmdldCRqc2NvbXAkMSA9XG4gICAgICAgICAgICAgICAgICBmb3JtTWV0aG9kJGpzY29tcCQxID1cbiAgICAgICAgICAgICAgICAgIGZvcm1FbmNUeXBlJGpzY29tcCQxID1cbiAgICAgICAgICAgICAgICAgIGZvcm1BY3Rpb24kanNjb21wJDEgPVxuICAgICAgICAgICAgICAgICAgICBudWxsKSxcbiAgICAgICAgICAgICAgICBpbmplY3RGb3JtUmVwbGF5aW5nUnVudGltZShyZXN1bWFibGVTdGF0ZSwgcmVuZGVyU3RhdGUpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbnVsbCAhPSBmb3JtQWN0aW9uJGpzY29tcCQxICYmXG4gICAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCRqc2NvbXAkMCwgXCJhY3Rpb25cIiwgZm9ybUFjdGlvbiRqc2NvbXAkMSk7XG4gICAgICAgICAgbnVsbCAhPSBmb3JtRW5jVHlwZSRqc2NvbXAkMSAmJlxuICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQkanNjb21wJDAsIFwiZW5jVHlwZVwiLCBmb3JtRW5jVHlwZSRqc2NvbXAkMSk7XG4gICAgICAgICAgbnVsbCAhPSBmb3JtTWV0aG9kJGpzY29tcCQxICYmXG4gICAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCRqc2NvbXAkMCwgXCJtZXRob2RcIiwgZm9ybU1ldGhvZCRqc2NvbXAkMSk7XG4gICAgICAgICAgbnVsbCAhPSBmb3JtVGFyZ2V0JGpzY29tcCQxICYmXG4gICAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCRqc2NvbXAkMCwgXCJ0YXJnZXRcIiwgZm9ybVRhcmdldCRqc2NvbXAkMSk7XG4gICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gICAgICAgICAgbnVsbCAhPT0gZm9ybUFjdGlvbk5hbWUgJiZcbiAgICAgICAgICAgICh0YXJnZXQkanNjb21wJDAucHVzaCgnPGlucHV0IHR5cGU9XCJoaWRkZW5cIicpLFxuICAgICAgICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQkanNjb21wJDAsIFwibmFtZVwiLCBmb3JtQWN0aW9uTmFtZSksXG4gICAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChlbmRPZlN0YXJ0VGFnU2VsZkNsb3NpbmcpLFxuICAgICAgICAgICAgbnVsbCAhPSBmb3JtRGF0YSRqc2NvbXAkMSAmJlxuICAgICAgICAgICAgICBmb3JtRGF0YSRqc2NvbXAkMS5mb3JFYWNoKFxuICAgICAgICAgICAgICAgIHB1c2hBZGRpdGlvbmFsRm9ybUZpZWxkLFxuICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMFxuICAgICAgICAgICAgICApKTtcbiAgICAgICAgICBwdXNoSW5uZXJIVE1MKHRhcmdldCRqc2NvbXAkMCwgaW5uZXJIVE1MJGpzY29tcCQzLCBjaGlsZHJlbiRqc2NvbXAkNCk7XG4gICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBjaGlsZHJlbiRqc2NvbXAkNCkge1xuICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZXNjYXBlVGV4dEZvckJyb3dzZXIoY2hpbGRyZW4kanNjb21wJDQpKTtcbiAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDIgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDIgPSBjaGlsZHJlbiRqc2NvbXAkNDtcbiAgICAgICAgICByZXR1cm4gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQyO1xuICAgICAgICBjYXNlIFwibWVudWl0ZW1cIjpcbiAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChzdGFydENodW5rRm9yVGFnKFwibWVudWl0ZW1cIikpO1xuICAgICAgICAgIGZvciAodmFyIHByb3BLZXkkanNjb21wJDYgaW4gcHJvcHMpXG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSRqc2NvbXAkNikpIHtcbiAgICAgICAgICAgICAgdmFyIHByb3BWYWx1ZSRqc2NvbXAkNiA9IHByb3BzW3Byb3BLZXkkanNjb21wJDZdO1xuICAgICAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wVmFsdWUkanNjb21wJDYpXG4gICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5JGpzY29tcCQ2KSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICBcIm1lbnVpdGVtcyBjYW5ub3QgaGF2ZSBgY2hpbGRyZW5gIG5vciBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLlwiXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBwdXNoQXR0cmlidXRlKFxuICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQ2LFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BWYWx1ZSRqc2NvbXAkNlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoXCJvYmplY3RcIikpO1xuICAgICAgICAgIHZhciBjaGlsZHJlbiRqc2NvbXAkNSA9IG51bGwsXG4gICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDQgPSBudWxsLFxuICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkNztcbiAgICAgICAgICBmb3IgKHByb3BLZXkkanNjb21wJDcgaW4gcHJvcHMpXG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSRqc2NvbXAkNykpIHtcbiAgICAgICAgICAgICAgdmFyIHByb3BWYWx1ZSRqc2NvbXAkNyA9IHByb3BzW3Byb3BLZXkkanNjb21wJDddO1xuICAgICAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wVmFsdWUkanNjb21wJDcpXG4gICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5JGpzY29tcCQ3KSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4kanNjb21wJDUgPSBwcm9wVmFsdWUkanNjb21wJDc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgICAgIGlubmVySFRNTCRqc2NvbXAkNCA9IHByb3BWYWx1ZSRqc2NvbXAkNztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZGF0YVwiOlxuICAgICAgICAgICAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHByb3BWYWx1ZSRqc2NvbXAkNywgXCJkYXRhXCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2FuaXRpemVkVmFsdWUgPSBzYW5pdGl6ZVVSTChcIlwiICsgcHJvcFZhbHVlJGpzY29tcCQ3KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwiXCIgPT09IHNhbml0aXplZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICdBbiBlbXB0eSBzdHJpbmcgKFwiXCIpIHdhcyBwYXNzZWQgdG8gdGhlICVzIGF0dHJpYnV0ZS4gVG8gZml4IHRoaXMsIGVpdGhlciBkbyBub3QgcmVuZGVyIHRoZSBlbGVtZW50IGF0IGFsbCBvciBwYXNzIG51bGwgdG8gJXMgaW5zdGVhZCBvZiBhbiBlbXB0eSBzdHJpbmcuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BLZXkkanNjb21wJDcsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQ3XG4gICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVTZXBhcmF0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgXCJkYXRhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlQXNzaWduLFxuICAgICAgICAgICAgICAgICAgICAgIGVzY2FwZVRleHRGb3JCcm93c2VyKHNhbml0aXplZFZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVFbmRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBwdXNoQXR0cmlidXRlKFxuICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQ3LFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BWYWx1ZSRqc2NvbXAkN1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgICAgICAgICBwdXNoSW5uZXJIVE1MKHRhcmdldCRqc2NvbXAkMCwgaW5uZXJIVE1MJGpzY29tcCQ0LCBjaGlsZHJlbiRqc2NvbXAkNSk7XG4gICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBjaGlsZHJlbiRqc2NvbXAkNSkge1xuICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZXNjYXBlVGV4dEZvckJyb3dzZXIoY2hpbGRyZW4kanNjb21wJDUpKTtcbiAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDMgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDMgPSBjaGlsZHJlbiRqc2NvbXAkNTtcbiAgICAgICAgICByZXR1cm4gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQzO1xuICAgICAgICBjYXNlIFwidGl0bGVcIjpcbiAgICAgICAgICB2YXIgaW5zZXJ0aW9uTW9kZSA9IGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSxcbiAgICAgICAgICAgIG5vc2NyaXB0VGFnSW5TY29wZSA9ICEhKGZvcm1hdENvbnRleHQudGFnU2NvcGUgJiAxKTtcbiAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgXCJjaGlsZHJlblwiKSkge1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuJGpzY29tcCQ2ID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICAgICAgICAgIGNoaWxkID0gQXJyYXkuaXNBcnJheShjaGlsZHJlbiRqc2NvbXAkNilcbiAgICAgICAgICAgICAgICA/IDIgPiBjaGlsZHJlbiRqc2NvbXAkNi5sZW5ndGhcbiAgICAgICAgICAgICAgICAgID8gY2hpbGRyZW4kanNjb21wJDZbMF1cbiAgICAgICAgICAgICAgICAgIDogbnVsbFxuICAgICAgICAgICAgICAgIDogY2hpbGRyZW4kanNjb21wJDY7XG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KGNoaWxkcmVuJGpzY29tcCQ2KSAmJiAxIDwgY2hpbGRyZW4kanNjb21wJDYubGVuZ3RoXG4gICAgICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiUmVhY3QgZXhwZWN0cyB0aGUgYGNoaWxkcmVuYCBwcm9wIG9mIDx0aXRsZT4gdGFncyB0byBiZSBhIHN0cmluZywgbnVtYmVyLCBiaWdpbnQsIG9yIG9iamVjdCB3aXRoIGEgbm92ZWwgYHRvU3RyaW5nYCBtZXRob2QgYnV0IGZvdW5kIGFuIEFycmF5IHdpdGggbGVuZ3RoICVzIGluc3RlYWQuIEJyb3dzZXJzIHRyZWF0IGFsbCBjaGlsZCBOb2RlcyBvZiA8dGl0bGU+IHRhZ3MgYXMgVGV4dCBjb250ZW50IGFuZCBSZWFjdCBleHBlY3RzIHRvIGJlIGFibGUgdG8gY29udmVydCBgY2hpbGRyZW5gIG9mIDx0aXRsZT4gdGFncyB0byBhIHNpbmdsZSBzdHJpbmcgdmFsdWUgd2hpY2ggaXMgd2h5IEFycmF5cyBvZiBsZW5ndGggZ3JlYXRlciB0aGFuIDEgYXJlIG5vdCBzdXBwb3J0ZWQuIFdoZW4gdXNpbmcgSlNYIGl0IGNhbiBiZSBjb21tb25nIHRvIGNvbWJpbmUgdGV4dCBub2RlcyBhbmQgdmFsdWUgbm9kZXMuIEZvciBleGFtcGxlOiA8dGl0bGU+aGVsbG8ge25hbWVPZlVzZXJ9PC90aXRsZT4uIFdoaWxlIG5vdCBpbW1lZGlhdGVseSBhcHBhcmVudCwgYGNoaWxkcmVuYCBpbiB0aGlzIGNhc2UgaXMgYW4gQXJyYXkgd2l0aCBsZW5ndGggMi4gSWYgeW91ciBgY2hpbGRyZW5gIHByb3AgaXMgdXNpbmcgdGhpcyBmb3JtIHRyeSByZXdyaXRpbmcgaXQgdXNpbmcgYSB0ZW1wbGF0ZSBzdHJpbmc6IDx0aXRsZT57YGhlbGxvICR7bmFtZU9mVXNlcn1gfTwvdGl0bGU+LlwiLFxuICAgICAgICAgICAgICAgICAgY2hpbGRyZW4kanNjb21wJDYubGVuZ3RoXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNoaWxkIHx8IFwic3ltYm9sXCIgPT09IHR5cGVvZiBjaGlsZFxuICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJSZWFjdCBleHBlY3QgY2hpbGRyZW4gb2YgPHRpdGxlPiB0YWdzIHRvIGJlIGEgc3RyaW5nLCBudW1iZXIsIGJpZ2ludCwgb3Igb2JqZWN0IHdpdGggYSBub3ZlbCBgdG9TdHJpbmdgIG1ldGhvZCBidXQgZm91bmQgJXMgaW5zdGVhZC4gQnJvd3NlcnMgdHJlYXQgYWxsIGNoaWxkIE5vZGVzIG9mIDx0aXRsZT4gdGFncyBhcyBUZXh0IGNvbnRlbnQgYW5kIFJlYWN0IGV4cGVjdHMgdG8gYmUgYWJsZSB0byBjb252ZXJ0IGNoaWxkcmVuIG9mIDx0aXRsZT4gdGFncyB0byBhIHNpbmdsZSBzdHJpbmcgdmFsdWUuXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNoaWxkID8gXCJhIEZ1bmN0aW9uXCIgOiBcImEgU3libW9sXCJcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICA6IGNoaWxkICYmXG4gICAgICAgICAgICAgICAgICBjaGlsZC50b1N0cmluZyA9PT0ge30udG9TdHJpbmcgJiZcbiAgICAgICAgICAgICAgICAgIChudWxsICE9IGNoaWxkLiQkdHlwZW9mXG4gICAgICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiUmVhY3QgZXhwZWN0cyB0aGUgYGNoaWxkcmVuYCBwcm9wIG9mIDx0aXRsZT4gdGFncyB0byBiZSBhIHN0cmluZywgbnVtYmVyLCBiaWdpbnQsIG9yIG9iamVjdCB3aXRoIGEgbm92ZWwgYHRvU3RyaW5nYCBtZXRob2QgYnV0IGZvdW5kIGFuIG9iamVjdCB0aGF0IGFwcGVhcnMgdG8gYmUgYSBSZWFjdCBlbGVtZW50IHdoaWNoIG5ldmVyIGltcGxlbWVudHMgYSBzdWl0YWJsZSBgdG9TdHJpbmdgIG1ldGhvZC4gQnJvd3NlcnMgdHJlYXQgYWxsIGNoaWxkIE5vZGVzIG9mIDx0aXRsZT4gdGFncyBhcyBUZXh0IGNvbnRlbnQgYW5kIFJlYWN0IGV4cGVjdHMgdG8gYmUgYWJsZSB0byBjb252ZXJ0IGNoaWxkcmVuIG9mIDx0aXRsZT4gdGFncyB0byBhIHNpbmdsZSBzdHJpbmcgdmFsdWUgd2hpY2ggaXMgd2h5IHJlbmRlcmluZyBSZWFjdCBlbGVtZW50cyBpcyBub3Qgc3VwcG9ydGVkLiBJZiB0aGUgYGNoaWxkcmVuYCBvZiA8dGl0bGU+IGlzIGEgUmVhY3QgQ29tcG9uZW50IHRyeSBtb3ZpbmcgdGhlIDx0aXRsZT4gdGFnIGludG8gdGhhdCBjb21wb25lbnQuIElmIHRoZSBgY2hpbGRyZW5gIG9mIDx0aXRsZT4gaXMgc29tZSBIVE1MIG1hcmt1cCBjaGFuZ2UgaXQgdG8gYmUgVGV4dCBvbmx5IHRvIGJlIHZhbGlkIEhUTUwuXCJcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIDogY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiUmVhY3QgZXhwZWN0cyB0aGUgYGNoaWxkcmVuYCBwcm9wIG9mIDx0aXRsZT4gdGFncyB0byBiZSBhIHN0cmluZywgbnVtYmVyLCBiaWdpbnQsIG9yIG9iamVjdCB3aXRoIGEgbm92ZWwgYHRvU3RyaW5nYCBtZXRob2QgYnV0IGZvdW5kIGFuIG9iamVjdCB0aGF0IGRvZXMgbm90IGltcGxlbWVudCBhIHN1aXRhYmxlIGB0b1N0cmluZ2AgbWV0aG9kLiBCcm93c2VycyB0cmVhdCBhbGwgY2hpbGQgTm9kZXMgb2YgPHRpdGxlPiB0YWdzIGFzIFRleHQgY29udGVudCBhbmQgUmVhY3QgZXhwZWN0cyB0byBiZSBhYmxlIHRvIGNvbnZlcnQgY2hpbGRyZW4gb2YgPHRpdGxlPiB0YWdzIHRvIGEgc2luZ2xlIHN0cmluZyB2YWx1ZS4gVXNpbmcgdGhlIGRlZmF1bHQgYHRvU3RyaW5nYCBtZXRob2QgYXZhaWxhYmxlIG9uIGV2ZXJ5IG9iamVjdCBpcyBhbG1vc3QgY2VydGFpbmx5IGFuIGVycm9yLiBDb25zaWRlciB3aGV0aGVyIHRoZSBgY2hpbGRyZW5gIG9mIHRoaXMgPHRpdGxlPiBpcyBhbiBvYmplY3QgaW4gZXJyb3IgYW5kIGNoYW5nZSBpdCB0byBhIHN0cmluZyBvciBudW1iZXIgdmFsdWUgaWYgc28uIE90aGVyd2lzZSBpbXBsZW1lbnQgYSBgdG9TdHJpbmdgIG1ldGhvZCB0aGF0IFJlYWN0IGNhbiB1c2UgdG8gcHJvZHVjZSBhIHZhbGlkIDx0aXRsZT4uXCJcbiAgICAgICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgaW5zZXJ0aW9uTW9kZSA9PT0gU1ZHX01PREUgfHxcbiAgICAgICAgICAgIG5vc2NyaXB0VGFnSW5TY29wZSB8fFxuICAgICAgICAgICAgbnVsbCAhPSBwcm9wcy5pdGVtUHJvcFxuICAgICAgICAgIClcbiAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDQgPSBwdXNoVGl0bGVJbXBsKFxuICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICAgIHByb3BzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGlzRmFsbGJhY2tcbiAgICAgICAgICAgICAgPyAoSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ0ID0gbnVsbClcbiAgICAgICAgICAgICAgOiAocHVzaFRpdGxlSW1wbChyZW5kZXJTdGF0ZS5ob2lzdGFibGVDaHVua3MsIHByb3BzKSxcbiAgICAgICAgICAgICAgICAoSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ0ID0gdm9pZCAwKSk7XG4gICAgICAgICAgcmV0dXJuIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkNDtcbiAgICAgICAgY2FzZSBcImxpbmtcIjpcbiAgICAgICAgICB2YXIgcmVsID0gcHJvcHMucmVsLFxuICAgICAgICAgICAgaHJlZiA9IHByb3BzLmhyZWYsXG4gICAgICAgICAgICBwcmVjZWRlbmNlID0gcHJvcHMucHJlY2VkZW5jZTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBmb3JtYXRDb250ZXh0Lmluc2VydGlvbk1vZGUgPT09IFNWR19NT0RFIHx8XG4gICAgICAgICAgICBmb3JtYXRDb250ZXh0LnRhZ1Njb3BlICYgMSB8fFxuICAgICAgICAgICAgbnVsbCAhPSBwcm9wcy5pdGVtUHJvcCB8fFxuICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIHJlbCB8fFxuICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIGhyZWYgfHxcbiAgICAgICAgICAgIFwiXCIgPT09IGhyZWZcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIFwic3R5bGVzaGVldFwiID09PSByZWwgJiZcbiAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHByb3BzLnByZWNlZGVuY2UgJiZcbiAgICAgICAgICAgICAgKChcInN0cmluZ1wiID09PSB0eXBlb2YgaHJlZiAmJiBocmVmKSB8fFxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAnUmVhY3QgZW5jb3VudGVyZWQgYSBgPGxpbmsgcmVsPVwic3R5bGVzaGVldFwiIC4uLi8+YCB3aXRoIGEgYHByZWNlZGVuY2VgIHByb3AgYW5kIGV4cGVjdGVkIHRoZSBgaHJlZmAgcHJvcCB0byBiZSBhIG5vbi1lbXB0eSBzdHJpbmcgYnV0IGVjb3VudGVyZWQgJXMgaW5zdGVhZC4gSWYgeW91ciBpbnRlbnQgd2FzIHRvIGhhdmUgUmVhY3QgaG9pc3QgYW5kIGRlZHVwbGNpYXRlIHRoaXMgc3R5bGVzaGVldCB1c2luZyB0aGUgYHByZWNlZGVuY2VgIHByb3AgZW5zdXJlIHRoZXJlIGlzIGEgbm9uLWVtcHR5IHN0cmluZyBgaHJlZmAgcHJvcCBhcyB3ZWxsLCBvdGhlcndpc2UgcmVtb3ZlIHRoZSBgcHJlY2VkZW5jZWAgcHJvcC4nLFxuICAgICAgICAgICAgICAgICAgbnVsbCA9PT0gaHJlZlxuICAgICAgICAgICAgICAgICAgICA/IFwiYG51bGxgXCJcbiAgICAgICAgICAgICAgICAgICAgOiB2b2lkIDAgPT09IGhyZWZcbiAgICAgICAgICAgICAgICAgICAgICA/IFwiYHVuZGVmaW5lZGBcIlxuICAgICAgICAgICAgICAgICAgICAgIDogXCJcIiA9PT0gaHJlZlxuICAgICAgICAgICAgICAgICAgICAgICAgPyBcImFuIGVtcHR5IHN0cmluZ1wiXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICdzb21ldGhpbmcgd2l0aCB0eXBlIFwiJyArIHR5cGVvZiBocmVmICsgJ1wiJ1xuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgcHVzaExpbmtJbXBsKHRhcmdldCRqc2NvbXAkMCwgcHJvcHMpO1xuICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkNSA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIGlmIChcInN0eWxlc2hlZXRcIiA9PT0gcHJvcHMucmVsKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2YgcHJlY2VkZW5jZSB8fFxuICAgICAgICAgICAgICBudWxsICE9IHByb3BzLmRpc2FibGVkIHx8XG4gICAgICAgICAgICAgIHByb3BzLm9uTG9hZCB8fFxuICAgICAgICAgICAgICBwcm9wcy5vbkVycm9yXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBwcmVjZWRlbmNlKVxuICAgICAgICAgICAgICAgIGlmIChudWxsICE9IHByb3BzLmRpc2FibGVkKVxuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgJ1JlYWN0IGVuY291bnRlcmVkIGEgYDxsaW5rIHJlbD1cInN0eWxlc2hlZXRcIiAuLi4vPmAgd2l0aCBhIGBwcmVjZWRlbmNlYCBwcm9wIGFuZCBhIGBkaXNhYmxlZGAgcHJvcC4gVGhlIHByZXNlbmNlIG9mIHRoZSBgZGlzYWJsZWRgIHByb3AgaW5kaWNhdGVzIGFuIGludGVudCB0byBtYW5hZ2UgdGhlIHN0eWxlc2hlZXQgYWN0aXZlIHN0YXRlIGZyb20geW91ciBmcm9tIHlvdXIgQ29tcG9uZW50IGNvZGUgYW5kIFJlYWN0IHdpbGwgbm90IGhvaXN0IG9yIGRlZHVwbGljYXRlIHRoaXMgc3R5bGVzaGVldC4gSWYgeW91ciBpbnRlbnQgd2FzIHRvIGhhdmUgUmVhY3QgaG9pc3QgYW5kIGRlZHVwbGNpYXRlIHRoaXMgc3R5bGVzaGVldCB1c2luZyB0aGUgYHByZWNlZGVuY2VgIHByb3AgcmVtb3ZlIHRoZSBgZGlzYWJsZWRgIHByb3AsIG90aGVyd2lzZSByZW1vdmUgdGhlIGBwcmVjZWRlbmNlYCBwcm9wLidcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJvcHMub25Mb2FkIHx8IHByb3BzLm9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBwcm9wRGVzY3JpcHRpb24gPVxuICAgICAgICAgICAgICAgICAgICBwcm9wcy5vbkxvYWQgJiYgcHJvcHMub25FcnJvclxuICAgICAgICAgICAgICAgICAgICAgID8gXCJgb25Mb2FkYCBhbmQgYG9uRXJyb3JgIHByb3BzXCJcbiAgICAgICAgICAgICAgICAgICAgICA6IHByb3BzLm9uTG9hZFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBcImBvbkxvYWRgIHByb3BcIlxuICAgICAgICAgICAgICAgICAgICAgICAgOiBcImBvbkVycm9yYCBwcm9wXCI7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAnUmVhY3QgZW5jb3VudGVyZWQgYSBgPGxpbmsgcmVsPVwic3R5bGVzaGVldFwiIC4uLi8+YCB3aXRoIGEgYHByZWNlZGVuY2VgIHByb3AgYW5kICVzLiBUaGUgcHJlc2VuY2Ugb2YgbG9hZGluZyBhbmQgZXJyb3IgaGFuZGxlcnMgaW5kaWNhdGVzIGFuIGludGVudCB0byBtYW5hZ2UgdGhlIHN0eWxlc2hlZXQgbG9hZGluZyBzdGF0ZSBmcm9tIHlvdXIgZnJvbSB5b3VyIENvbXBvbmVudCBjb2RlIGFuZCBSZWFjdCB3aWxsIG5vdCBob2lzdCBvciBkZWR1cGxpY2F0ZSB0aGlzIHN0eWxlc2hlZXQuIElmIHlvdXIgaW50ZW50IHdhcyB0byBoYXZlIFJlYWN0IGhvaXN0IGFuZCBkZWR1cGxjaWF0ZSB0aGlzIHN0eWxlc2hlZXQgdXNpbmcgdGhlIGBwcmVjZWRlbmNlYCBwcm9wIHJlbW92ZSB0aGUgJXMsIG90aGVyd2lzZSByZW1vdmUgdGhlIGBwcmVjZWRlbmNlYCBwcm9wLicsXG4gICAgICAgICAgICAgICAgICAgIHByb3BEZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgcHJvcERlc2NyaXB0aW9uXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ1ID0gcHVzaExpbmtJbXBsKFxuICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICBwcm9wc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHN0eWxlUXVldWUgPSByZW5kZXJTdGF0ZS5zdHlsZXMuZ2V0KHByZWNlZGVuY2UpLFxuICAgICAgICAgICAgICAgIHJlc291cmNlU3RhdGUgPSByZXN1bWFibGVTdGF0ZS5zdHlsZVJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShcbiAgICAgICAgICAgICAgICAgIGhyZWZcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICA/IHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzW2hyZWZdXG4gICAgICAgICAgICAgICAgICA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgaWYgKHJlc291cmNlU3RhdGUgIT09IEVYSVNUUykge1xuICAgICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzW2hyZWZdID0gRVhJU1RTO1xuICAgICAgICAgICAgICAgIHN0eWxlUXVldWUgfHxcbiAgICAgICAgICAgICAgICAgICgoc3R5bGVRdWV1ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogZXNjYXBlVGV4dEZvckJyb3dzZXIocHJlY2VkZW5jZSksXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgaHJlZnM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBzaGVldHM6IG5ldyBNYXAoKVxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5zdHlsZXMuc2V0KHByZWNlZGVuY2UsIHN0eWxlUXVldWUpKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVzb3VyY2UgPSB7XG4gICAgICAgICAgICAgICAgICBzdGF0ZTogUEVORElORyQxLFxuICAgICAgICAgICAgICAgICAgcHJvcHM6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICAgICAgICAgICAgXCJkYXRhLXByZWNlZGVuY2VcIjogcHJvcHMucHJlY2VkZW5jZSxcbiAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogbnVsbFxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChyZXNvdXJjZVN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAyID09PSByZXNvdXJjZVN0YXRlLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICBhZG9wdFByZWxvYWRDcmVkZW50aWFscyhyZXNvdXJjZS5wcm9wcywgcmVzb3VyY2VTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICB2YXIgcHJlbG9hZFJlc291cmNlID1cbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUucHJlbG9hZHMuc3R5bGVzaGVldHMuZ2V0KGhyZWYpO1xuICAgICAgICAgICAgICAgICAgcHJlbG9hZFJlc291cmNlICYmIDAgPCBwcmVsb2FkUmVzb3VyY2UubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgID8gKHByZWxvYWRSZXNvdXJjZS5sZW5ndGggPSAwKVxuICAgICAgICAgICAgICAgICAgICA6IChyZXNvdXJjZS5zdGF0ZSA9IFBSRUxPQURFRCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0eWxlUXVldWUuc2hlZXRzLnNldChocmVmLCByZXNvdXJjZSk7XG4gICAgICAgICAgICAgICAgaG9pc3RhYmxlU3RhdGUgJiYgaG9pc3RhYmxlU3RhdGUuc3R5bGVzaGVldHMuYWRkKHJlc291cmNlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHlsZVF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9yZXNvdXJjZSA9IHN0eWxlUXVldWUuc2hlZXRzLmdldChocmVmKTtcbiAgICAgICAgICAgICAgICBfcmVzb3VyY2UgJiZcbiAgICAgICAgICAgICAgICAgIGhvaXN0YWJsZVN0YXRlICYmXG4gICAgICAgICAgICAgICAgICBob2lzdGFibGVTdGF0ZS5zdHlsZXNoZWV0cy5hZGQoX3Jlc291cmNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0ZXh0RW1iZWRkZWQgJiYgdGFyZ2V0JGpzY29tcCQwLnB1c2goXCJcXHgzYyEtLSAtLVxceDNlXCIpO1xuICAgICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHByb3BzLm9uTG9hZCB8fCBwcm9wcy5vbkVycm9yXG4gICAgICAgICAgICAgID8gKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkNSA9IHB1c2hMaW5rSW1wbChcbiAgICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgIHByb3BzXG4gICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgOiAodGV4dEVtYmVkZGVkICYmIHRhcmdldCRqc2NvbXAkMC5wdXNoKFwiXFx4M2MhLS0gLS1cXHgzZVwiKSxcbiAgICAgICAgICAgICAgICAoSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ1ID0gaXNGYWxsYmFja1xuICAgICAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgICAgICA6IHB1c2hMaW5rSW1wbChyZW5kZXJTdGF0ZS5ob2lzdGFibGVDaHVua3MsIHByb3BzKSkpO1xuICAgICAgICAgIHJldHVybiBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDU7XG4gICAgICAgIGNhc2UgXCJzY3JpcHRcIjpcbiAgICAgICAgICB2YXIgYXN5bmNQcm9wID0gcHJvcHMuYXN5bmM7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIHByb3BzLnNyYyB8fFxuICAgICAgICAgICAgIXByb3BzLnNyYyB8fFxuICAgICAgICAgICAgIWFzeW5jUHJvcCB8fFxuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgYXN5bmNQcm9wIHx8XG4gICAgICAgICAgICBcInN5bWJvbFwiID09PSB0eXBlb2YgYXN5bmNQcm9wIHx8XG4gICAgICAgICAgICBwcm9wcy5vbkxvYWQgfHxcbiAgICAgICAgICAgIHByb3BzLm9uRXJyb3IgfHxcbiAgICAgICAgICAgIGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSA9PT0gU1ZHX01PREUgfHxcbiAgICAgICAgICAgIGZvcm1hdENvbnRleHQudGFnU2NvcGUgJiAxIHx8XG4gICAgICAgICAgICBudWxsICE9IHByb3BzLml0ZW1Qcm9wXG4gICAgICAgICAgKVxuICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkNiA9IHB1c2hTY3JpcHRJbXBsKFxuICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICAgIHByb3BzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGtleSA9IHByb3BzLnNyYztcbiAgICAgICAgICAgIGlmIChcIm1vZHVsZVwiID09PSBwcm9wcy50eXBlKSB7XG4gICAgICAgICAgICAgIHZhciByZXNvdXJjZXMgPSByZXN1bWFibGVTdGF0ZS5tb2R1bGVTY3JpcHRSZXNvdXJjZXM7XG4gICAgICAgICAgICAgIHZhciBwcmVsb2FkcyA9IHJlbmRlclN0YXRlLnByZWxvYWRzLm1vZHVsZVNjcmlwdHM7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgKHJlc291cmNlcyA9IHJlc3VtYWJsZVN0YXRlLnNjcmlwdFJlc291cmNlcyksXG4gICAgICAgICAgICAgICAgKHByZWxvYWRzID0gcmVuZGVyU3RhdGUucHJlbG9hZHMuc2NyaXB0cyk7XG4gICAgICAgICAgICB2YXIgcmVzb3VyY2VTdGF0ZSRqc2NvbXAkMCA9IHJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShrZXkpXG4gICAgICAgICAgICAgID8gcmVzb3VyY2VzW2tleV1cbiAgICAgICAgICAgICAgOiB2b2lkIDA7XG4gICAgICAgICAgICBpZiAocmVzb3VyY2VTdGF0ZSRqc2NvbXAkMCAhPT0gRVhJU1RTKSB7XG4gICAgICAgICAgICAgIHJlc291cmNlc1trZXldID0gRVhJU1RTO1xuICAgICAgICAgICAgICB2YXIgc2NyaXB0UHJvcHMgPSBwcm9wcztcbiAgICAgICAgICAgICAgaWYgKHJlc291cmNlU3RhdGUkanNjb21wJDApIHtcbiAgICAgICAgICAgICAgICAyID09PSByZXNvdXJjZVN0YXRlJGpzY29tcCQwLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgKChzY3JpcHRQcm9wcyA9IGFzc2lnbih7fSwgcHJvcHMpKSxcbiAgICAgICAgICAgICAgICAgIGFkb3B0UHJlbG9hZENyZWRlbnRpYWxzKHNjcmlwdFByb3BzLCByZXNvdXJjZVN0YXRlJGpzY29tcCQwKSk7XG4gICAgICAgICAgICAgICAgdmFyIHByZWxvYWRSZXNvdXJjZSRqc2NvbXAkMCA9IHByZWxvYWRzLmdldChrZXkpO1xuICAgICAgICAgICAgICAgIHByZWxvYWRSZXNvdXJjZSRqc2NvbXAkMCAmJlxuICAgICAgICAgICAgICAgICAgKHByZWxvYWRSZXNvdXJjZSRqc2NvbXAkMC5sZW5ndGggPSAwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgcmVzb3VyY2UkanNjb21wJDAgPSBbXTtcbiAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuc2NyaXB0cy5hZGQocmVzb3VyY2UkanNjb21wJDApO1xuICAgICAgICAgICAgICBwdXNoU2NyaXB0SW1wbChyZXNvdXJjZSRqc2NvbXAkMCwgc2NyaXB0UHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGV4dEVtYmVkZGVkICYmIHRhcmdldCRqc2NvbXAkMC5wdXNoKFwiXFx4M2MhLS0gLS1cXHgzZVwiKTtcbiAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkNiA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDY7XG4gICAgICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgICAgIHZhciBpbnNlcnRpb25Nb2RlJGpzY29tcCQwID0gZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlLFxuICAgICAgICAgICAgbm9zY3JpcHRUYWdJblNjb3BlJGpzY29tcCQwID0gISEoZm9ybWF0Q29udGV4dC50YWdTY29wZSAmIDEpO1xuICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBcImNoaWxkcmVuXCIpKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4kanNjb21wJDcgPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgICAgICAgICAgY2hpbGQkanNjb21wJDAgPSBBcnJheS5pc0FycmF5KGNoaWxkcmVuJGpzY29tcCQ3KVxuICAgICAgICAgICAgICAgID8gMiA+IGNoaWxkcmVuJGpzY29tcCQ3Lmxlbmd0aFxuICAgICAgICAgICAgICAgICAgPyBjaGlsZHJlbiRqc2NvbXAkN1swXVxuICAgICAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgICAgICAgOiBjaGlsZHJlbiRqc2NvbXAkNztcbiAgICAgICAgICAgIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjaGlsZCRqc2NvbXAkMCB8fFxuICAgICAgICAgICAgICBcInN5bWJvbFwiID09PSB0eXBlb2YgY2hpbGQkanNjb21wJDAgfHxcbiAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShjaGlsZCRqc2NvbXAkMCkpICYmXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJSZWFjdCBleHBlY3QgY2hpbGRyZW4gb2YgPHN0eWxlPiB0YWdzIHRvIGJlIGEgc3RyaW5nLCBudW1iZXIsIG9yIG9iamVjdCB3aXRoIGEgYHRvU3RyaW5nYCBtZXRob2QgYnV0IGZvdW5kICVzIGluc3RlYWQuIEluIGJyb3dzZXJzIHN0eWxlIEVsZW1lbnRzIGNhbiBvbmx5IGhhdmUgYFRleHRgIE5vZGVzIGFzIGNoaWxkcmVuLlwiLFxuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNoaWxkJGpzY29tcCQwXG4gICAgICAgICAgICAgICAgICA/IFwiYSBGdW5jdGlvblwiXG4gICAgICAgICAgICAgICAgICA6IFwic3ltYm9sXCIgPT09IHR5cGVvZiBjaGlsZCRqc2NvbXAkMFxuICAgICAgICAgICAgICAgICAgICA/IFwiYSBTeWJtb2xcIlxuICAgICAgICAgICAgICAgICAgICA6IFwiYW4gQXJyYXlcIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcHJlY2VkZW5jZSRqc2NvbXAkMCA9IHByb3BzLnByZWNlZGVuY2UsXG4gICAgICAgICAgICBocmVmJGpzY29tcCQwID0gcHJvcHMuaHJlZjtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBpbnNlcnRpb25Nb2RlJGpzY29tcCQwID09PSBTVkdfTU9ERSB8fFxuICAgICAgICAgICAgbm9zY3JpcHRUYWdJblNjb3BlJGpzY29tcCQwIHx8XG4gICAgICAgICAgICBudWxsICE9IHByb3BzLml0ZW1Qcm9wIHx8XG4gICAgICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2YgcHJlY2VkZW5jZSRqc2NvbXAkMCB8fFxuICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIGhyZWYkanNjb21wJDAgfHxcbiAgICAgICAgICAgIFwiXCIgPT09IGhyZWYkanNjb21wJDBcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoXCJzdHlsZVwiKSk7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4kanNjb21wJDggPSBudWxsLFxuICAgICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDUgPSBudWxsLFxuICAgICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQ4O1xuICAgICAgICAgICAgZm9yIChwcm9wS2V5JGpzY29tcCQ4IGluIHByb3BzKVxuICAgICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSRqc2NvbXAkOCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcFZhbHVlJGpzY29tcCQ4ID0gcHJvcHNbcHJvcEtleSRqc2NvbXAkOF07XG4gICAgICAgICAgICAgICAgaWYgKG51bGwgIT0gcHJvcFZhbHVlJGpzY29tcCQ4KVxuICAgICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5JGpzY29tcCQ4KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuJGpzY29tcCQ4ID0gcHJvcFZhbHVlJGpzY29tcCQ4O1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDUgPSBwcm9wVmFsdWUkanNjb21wJDg7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BLZXkkanNjb21wJDgsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wVmFsdWUkanNjb21wJDhcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgICAgICAgICAgIHZhciBjaGlsZCRqc2NvbXAkMSA9IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4kanNjb21wJDgpXG4gICAgICAgICAgICAgID8gMiA+IGNoaWxkcmVuJGpzY29tcCQ4Lmxlbmd0aFxuICAgICAgICAgICAgICAgID8gY2hpbGRyZW4kanNjb21wJDhbMF1cbiAgICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICAgICAgOiBjaGlsZHJlbiRqc2NvbXAkODtcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGNoaWxkJGpzY29tcCQxICYmXG4gICAgICAgICAgICAgIFwic3ltYm9sXCIgIT09IHR5cGVvZiBjaGlsZCRqc2NvbXAkMSAmJlxuICAgICAgICAgICAgICBudWxsICE9PSBjaGlsZCRqc2NvbXAkMSAmJlxuICAgICAgICAgICAgICB2b2lkIDAgIT09IGNoaWxkJGpzY29tcCQxICYmXG4gICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKGVzY2FwZVN0eWxlVGV4dENvbnRlbnQoY2hpbGQkanNjb21wJDEpKTtcbiAgICAgICAgICAgIHB1c2hJbm5lckhUTUwoXG4gICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgaW5uZXJIVE1MJGpzY29tcCQ1LFxuICAgICAgICAgICAgICBjaGlsZHJlbiRqc2NvbXAkOFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKGVuZENodW5rRm9yVGFnKFwic3R5bGVcIikpO1xuICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkNyA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhyZWYkanNjb21wJDAuaW5jbHVkZXMoXCIgXCIpICYmXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgJ1JlYWN0IGV4cGVjdGVkIHRoZSBgaHJlZmAgcHJvcCBmb3IgYSA8c3R5bGU+IHRhZyBvcHRpbmcgaW50byBob2lzdGluZyBzZW1hbnRpY3MgdXNpbmcgdGhlIGBwcmVjZWRlbmNlYCBwcm9wIHRvIG5vdCBoYXZlIGFueSBzcGFjZXMgYnV0IGVjb3VudGVyZWQgc3BhY2VzIGluc3RlYWQuIHVzaW5nIHNwYWNlcyBpbiB0aGlzIHByb3Agd2lsbCBjYXVzZSBoeWRyYXRpb24gb2YgdGhpcyBzdHlsZSB0byBmYWlsIG9uIHRoZSBjbGllbnQuIFRoZSBocmVmIGZvciB0aGUgPHN0eWxlPiB3aGVyZSB0aGlzIG9jdXJyZWQgaXMgXCIlc1wiLicsXG4gICAgICAgICAgICAgICAgaHJlZiRqc2NvbXAkMFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgdmFyIHN0eWxlUXVldWUkanNjb21wJDAgPVxuICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLnN0eWxlcy5nZXQocHJlY2VkZW5jZSRqc2NvbXAkMCksXG4gICAgICAgICAgICAgIHJlc291cmNlU3RhdGUkanNjb21wJDEgPVxuICAgICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzLmhhc093blByb3BlcnR5KGhyZWYkanNjb21wJDApXG4gICAgICAgICAgICAgICAgICA/IHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzW2hyZWYkanNjb21wJDBdXG4gICAgICAgICAgICAgICAgICA6IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChyZXNvdXJjZVN0YXRlJGpzY29tcCQxICE9PSBFWElTVFMpIHtcbiAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUuc3R5bGVSZXNvdXJjZXNbaHJlZiRqc2NvbXAkMF0gPSBFWElTVFM7XG4gICAgICAgICAgICAgIHJlc291cmNlU3RhdGUkanNjb21wJDEgJiZcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgJ1JlYWN0IGVuY291bnRlcmVkIGEgaG9pc3RhYmxlIHN0eWxlIHRhZyBmb3IgdGhlIHNhbWUgaHJlZiBhcyBhIHByZWxvYWQ6IFwiJXNcIi4gV2hlbiB1c2luZyBhIHN0eWxlIHRhZyB0byBpbmxpbmUgc3R5bGVzIHlvdSBzaG91bGQgbm90IGFsc28gcHJlbG9hZCBpdCBhcyBhIHN0eWxzaGVldC4nLFxuICAgICAgICAgICAgICAgICAgaHJlZiRqc2NvbXAkMFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHN0eWxlUXVldWUkanNjb21wJDBcbiAgICAgICAgICAgICAgICA/IHN0eWxlUXVldWUkanNjb21wJDAuaHJlZnMucHVzaChcbiAgICAgICAgICAgICAgICAgICAgZXNjYXBlVGV4dEZvckJyb3dzZXIoaHJlZiRqc2NvbXAkMClcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICA6ICgoc3R5bGVRdWV1ZSRqc2NvbXAkMCA9IHtcbiAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogZXNjYXBlVGV4dEZvckJyb3dzZXIocHJlY2VkZW5jZSRqc2NvbXAkMCksXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgaHJlZnM6IFtlc2NhcGVUZXh0Rm9yQnJvd3NlcihocmVmJGpzY29tcCQwKV0sXG4gICAgICAgICAgICAgICAgICAgIHNoZWV0czogbmV3IE1hcCgpXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLnN0eWxlcy5zZXQoXG4gICAgICAgICAgICAgICAgICAgIHByZWNlZGVuY2UkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlUXVldWUkanNjb21wJDBcbiAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gc3R5bGVRdWV1ZSRqc2NvbXAkMC5ydWxlcyxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbiRqc2NvbXAkOSA9IG51bGwsXG4gICAgICAgICAgICAgICAgaW5uZXJIVE1MJGpzY29tcCQ2ID0gbnVsbCxcbiAgICAgICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQ5O1xuICAgICAgICAgICAgICBmb3IgKHByb3BLZXkkanNjb21wJDkgaW4gcHJvcHMpXG4gICAgICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkkanNjb21wJDkpKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcHJvcFZhbHVlJGpzY29tcCQ5ID0gcHJvcHNbcHJvcEtleSRqc2NvbXAkOV07XG4gICAgICAgICAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wVmFsdWUkanNjb21wJDkpXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSRqc2NvbXAkOSkge1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4kanNjb21wJDkgPSBwcm9wVmFsdWUkanNjb21wJDk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlubmVySFRNTCRqc2NvbXAkNiA9IHByb3BWYWx1ZSRqc2NvbXAkOTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIGNoaWxkJGpzY29tcCQyID0gQXJyYXkuaXNBcnJheShjaGlsZHJlbiRqc2NvbXAkOSlcbiAgICAgICAgICAgICAgICA/IDIgPiBjaGlsZHJlbiRqc2NvbXAkOS5sZW5ndGhcbiAgICAgICAgICAgICAgICAgID8gY2hpbGRyZW4kanNjb21wJDlbMF1cbiAgICAgICAgICAgICAgICAgIDogbnVsbFxuICAgICAgICAgICAgICAgIDogY2hpbGRyZW4kanNjb21wJDk7XG4gICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGNoaWxkJGpzY29tcCQyICYmXG4gICAgICAgICAgICAgICAgXCJzeW1ib2xcIiAhPT0gdHlwZW9mIGNoaWxkJGpzY29tcCQyICYmXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gY2hpbGQkanNjb21wJDIgJiZcbiAgICAgICAgICAgICAgICB2b2lkIDAgIT09IGNoaWxkJGpzY29tcCQyICYmXG4gICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2goZXNjYXBlU3R5bGVUZXh0Q29udGVudChjaGlsZCRqc2NvbXAkMikpO1xuICAgICAgICAgICAgICBwdXNoSW5uZXJIVE1MKHRhcmdldCwgaW5uZXJIVE1MJGpzY29tcCQ2LCBjaGlsZHJlbiRqc2NvbXAkOSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHlsZVF1ZXVlJGpzY29tcCQwICYmXG4gICAgICAgICAgICAgIGhvaXN0YWJsZVN0YXRlICYmXG4gICAgICAgICAgICAgIGhvaXN0YWJsZVN0YXRlLnN0eWxlcy5hZGQoc3R5bGVRdWV1ZSRqc2NvbXAkMCk7XG4gICAgICAgICAgICB0ZXh0RW1iZWRkZWQgJiYgdGFyZ2V0JGpzY29tcCQwLnB1c2goXCJcXHgzYyEtLSAtLVxceDNlXCIpO1xuICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ3ID0gdm9pZCAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ3O1xuICAgICAgICBjYXNlIFwibWV0YVwiOlxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSA9PT0gU1ZHX01PREUgfHxcbiAgICAgICAgICAgIGZvcm1hdENvbnRleHQudGFnU2NvcGUgJiAxIHx8XG4gICAgICAgICAgICBudWxsICE9IHByb3BzLml0ZW1Qcm9wXG4gICAgICAgICAgKVxuICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkOCA9IHB1c2hTZWxmQ2xvc2luZyhcbiAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLFxuICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgICAgXCJtZXRhXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGV4dEVtYmVkZGVkICYmIHRhcmdldCRqc2NvbXAkMC5wdXNoKFwiXFx4M2MhLS0gLS1cXHgzZVwiKSxcbiAgICAgICAgICAgICAgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkOCA9IGlzRmFsbGJhY2tcbiAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICA6IFwic3RyaW5nXCIgPT09IHR5cGVvZiBwcm9wcy5jaGFyU2V0XG4gICAgICAgICAgICAgICAgICA/IHB1c2hTZWxmQ2xvc2luZyhyZW5kZXJTdGF0ZS5jaGFyc2V0Q2h1bmtzLCBwcm9wcywgXCJtZXRhXCIpXG4gICAgICAgICAgICAgICAgICA6IFwidmlld3BvcnRcIiA9PT0gcHJvcHMubmFtZVxuICAgICAgICAgICAgICAgICAgICA/IHB1c2hTZWxmQ2xvc2luZyhyZW5kZXJTdGF0ZS52aWV3cG9ydENodW5rcywgcHJvcHMsIFwibWV0YVwiKVxuICAgICAgICAgICAgICAgICAgICA6IHB1c2hTZWxmQ2xvc2luZyhcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLmhvaXN0YWJsZUNodW5rcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJtZXRhXCJcbiAgICAgICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICByZXR1cm4gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ4O1xuICAgICAgICBjYXNlIFwibGlzdGluZ1wiOlxuICAgICAgICBjYXNlIFwicHJlXCI6XG4gICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goc3RhcnRDaHVua0ZvclRhZyh0eXBlKSk7XG4gICAgICAgICAgdmFyIGNoaWxkcmVuJGpzY29tcCQxMCA9IG51bGwsXG4gICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDcgPSBudWxsLFxuICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkMTA7XG4gICAgICAgICAgZm9yIChwcm9wS2V5JGpzY29tcCQxMCBpbiBwcm9wcylcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5JGpzY29tcCQxMCkpIHtcbiAgICAgICAgICAgICAgdmFyIHByb3BWYWx1ZSRqc2NvbXAkMTAgPSBwcm9wc1twcm9wS2V5JGpzY29tcCQxMF07XG4gICAgICAgICAgICAgIGlmIChudWxsICE9IHByb3BWYWx1ZSRqc2NvbXAkMTApXG4gICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5JGpzY29tcCQxMCkge1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuJGpzY29tcCQxMCA9IHByb3BWYWx1ZSRqc2NvbXAkMTA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgICAgIGlubmVySFRNTCRqc2NvbXAkNyA9IHByb3BWYWx1ZSRqc2NvbXAkMTA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkMTAsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcFZhbHVlJGpzY29tcCQxMFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgICAgICAgICBpZiAobnVsbCAhPSBpbm5lckhUTUwkanNjb21wJDcpIHtcbiAgICAgICAgICAgIGlmIChudWxsICE9IGNoaWxkcmVuJGpzY29tcCQxMClcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJDYW4gb25seSBzZXQgb25lIG9mIGBjaGlsZHJlbmAgb3IgYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBcIm9iamVjdFwiICE9PSB0eXBlb2YgaW5uZXJIVE1MJGpzY29tcCQ3IHx8XG4gICAgICAgICAgICAgICEoXCJfX2h0bWxcIiBpbiBpbm5lckhUTUwkanNjb21wJDcpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBtdXN0IGJlIGluIHRoZSBmb3JtIGB7X19odG1sOiAuLi59YC4gUGxlYXNlIHZpc2l0IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvZGFuZ2Vyb3VzbHktc2V0LWlubmVyLWh0bWwgZm9yIG1vcmUgaW5mb3JtYXRpb24uXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHZhciBodG1sID0gaW5uZXJIVE1MJGpzY29tcCQ3Ll9faHRtbDtcbiAgICAgICAgICAgIG51bGwgIT09IGh0bWwgJiZcbiAgICAgICAgICAgICAgdm9pZCAwICE9PSBodG1sICYmXG4gICAgICAgICAgICAgIChcInN0cmluZ1wiID09PSB0eXBlb2YgaHRtbCAmJiAwIDwgaHRtbC5sZW5ndGggJiYgXCJcXG5cIiA9PT0gaHRtbFswXVxuICAgICAgICAgICAgICAgID8gdGFyZ2V0JGpzY29tcCQwLnB1c2gobGVhZGluZ05ld2xpbmUsIGh0bWwpXG4gICAgICAgICAgICAgICAgOiAoY2hlY2tIdG1sU3RyaW5nQ29lcmNpb24oaHRtbCksXG4gICAgICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChcIlwiICsgaHRtbCkpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGNoaWxkcmVuJGpzY29tcCQxMCAmJlxuICAgICAgICAgICAgXCJcXG5cIiA9PT0gY2hpbGRyZW4kanNjb21wJDEwWzBdICYmXG4gICAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChsZWFkaW5nTmV3bGluZSk7XG4gICAgICAgICAgcmV0dXJuIGNoaWxkcmVuJGpzY29tcCQxMDtcbiAgICAgICAgY2FzZSBcImltZ1wiOlxuICAgICAgICAgIHZhciBzcmMgPSBwcm9wcy5zcmMsXG4gICAgICAgICAgICBzcmNTZXQgPSBwcm9wcy5zcmNTZXQ7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIShcbiAgICAgICAgICAgICAgXCJsYXp5XCIgPT09IHByb3BzLmxvYWRpbmcgfHxcbiAgICAgICAgICAgICAgKCFzcmMgJiYgIXNyY1NldCkgfHxcbiAgICAgICAgICAgICAgKFwic3RyaW5nXCIgIT09IHR5cGVvZiBzcmMgJiYgbnVsbCAhPSBzcmMpIHx8XG4gICAgICAgICAgICAgIChcInN0cmluZ1wiICE9PSB0eXBlb2Ygc3JjU2V0ICYmIG51bGwgIT0gc3JjU2V0KVxuICAgICAgICAgICAgKSAmJlxuICAgICAgICAgICAgXCJsb3dcIiAhPT0gcHJvcHMuZmV0Y2hQcmlvcml0eSAmJlxuICAgICAgICAgICAgITEgPT09ICEhKGZvcm1hdENvbnRleHQudGFnU2NvcGUgJiAzKSAmJlxuICAgICAgICAgICAgKFwic3RyaW5nXCIgIT09IHR5cGVvZiBzcmMgfHxcbiAgICAgICAgICAgICAgXCI6XCIgIT09IHNyY1s0XSB8fFxuICAgICAgICAgICAgICAoXCJkXCIgIT09IHNyY1swXSAmJiBcIkRcIiAhPT0gc3JjWzBdKSB8fFxuICAgICAgICAgICAgICAoXCJhXCIgIT09IHNyY1sxXSAmJiBcIkFcIiAhPT0gc3JjWzFdKSB8fFxuICAgICAgICAgICAgICAoXCJ0XCIgIT09IHNyY1syXSAmJiBcIlRcIiAhPT0gc3JjWzJdKSB8fFxuICAgICAgICAgICAgICAoXCJhXCIgIT09IHNyY1szXSAmJiBcIkFcIiAhPT0gc3JjWzNdKSkgJiZcbiAgICAgICAgICAgIChcInN0cmluZ1wiICE9PSB0eXBlb2Ygc3JjU2V0IHx8XG4gICAgICAgICAgICAgIFwiOlwiICE9PSBzcmNTZXRbNF0gfHxcbiAgICAgICAgICAgICAgKFwiZFwiICE9PSBzcmNTZXRbMF0gJiYgXCJEXCIgIT09IHNyY1NldFswXSkgfHxcbiAgICAgICAgICAgICAgKFwiYVwiICE9PSBzcmNTZXRbMV0gJiYgXCJBXCIgIT09IHNyY1NldFsxXSkgfHxcbiAgICAgICAgICAgICAgKFwidFwiICE9PSBzcmNTZXRbMl0gJiYgXCJUXCIgIT09IHNyY1NldFsyXSkgfHxcbiAgICAgICAgICAgICAgKFwiYVwiICE9PSBzcmNTZXRbM10gJiYgXCJBXCIgIT09IHNyY1NldFszXSkpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgc2l6ZXMgPSBcInN0cmluZ1wiID09PSB0eXBlb2YgcHJvcHMuc2l6ZXMgPyBwcm9wcy5zaXplcyA6IHZvaWQgMCxcbiAgICAgICAgICAgICAga2V5JGpzY29tcCQwID0gc3JjU2V0ID8gc3JjU2V0ICsgXCJcXG5cIiArIChzaXplcyB8fCBcIlwiKSA6IHNyYyxcbiAgICAgICAgICAgICAgcHJvbW90YWJsZVByZWxvYWRzID0gcmVuZGVyU3RhdGUucHJlbG9hZHMuaW1hZ2VzLFxuICAgICAgICAgICAgICByZXNvdXJjZSRqc2NvbXAkMSA9IHByb21vdGFibGVQcmVsb2Fkcy5nZXQoa2V5JGpzY29tcCQwKTtcbiAgICAgICAgICAgIGlmIChyZXNvdXJjZSRqc2NvbXAkMSkge1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgXCJoaWdoXCIgPT09IHByb3BzLmZldGNoUHJpb3JpdHkgfHxcbiAgICAgICAgICAgICAgICAxMCA+IHJlbmRlclN0YXRlLmhpZ2hJbWFnZVByZWxvYWRzLnNpemVcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIHByb21vdGFibGVQcmVsb2Fkcy5kZWxldGUoa2V5JGpzY29tcCQwKSxcbiAgICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLmhpZ2hJbWFnZVByZWxvYWRzLmFkZChyZXNvdXJjZSRqc2NvbXAkMSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAhcmVzdW1hYmxlU3RhdGUuaW1hZ2VSZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoa2V5JGpzY29tcCQwKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLmltYWdlUmVzb3VyY2VzW2tleSRqc2NvbXAkMF0gPSBQUkVMT0FEX05PX0NSRURTO1xuICAgICAgICAgICAgICB2YXIgaW5wdXQgPSBwcm9wcy5jcm9zc09yaWdpbjtcbiAgICAgICAgICAgICAgdmFyIGNyb3NzT3JpZ2luID1cbiAgICAgICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgaW5wdXRcbiAgICAgICAgICAgICAgICAgID8gXCJ1c2UtY3JlZGVudGlhbHNcIiA9PT0gaW5wdXRcbiAgICAgICAgICAgICAgICAgICAgPyBpbnB1dFxuICAgICAgICAgICAgICAgICAgICA6IFwiXCJcbiAgICAgICAgICAgICAgICAgIDogdm9pZCAwO1xuICAgICAgICAgICAgICB2YXIgaGVhZGVycyA9IHJlbmRlclN0YXRlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgaGVhZGVyO1xuICAgICAgICAgICAgICBoZWFkZXJzICYmXG4gICAgICAgICAgICAgIDAgPCBoZWFkZXJzLnJlbWFpbmluZ0NhcGFjaXR5ICYmXG4gICAgICAgICAgICAgIChcImhpZ2hcIiA9PT0gcHJvcHMuZmV0Y2hQcmlvcml0eSB8fFxuICAgICAgICAgICAgICAgIDUwMCA+IGhlYWRlcnMuaGlnaEltYWdlUHJlbG9hZHMubGVuZ3RoKSAmJlxuICAgICAgICAgICAgICAoKGhlYWRlciA9IGdldFByZWxvYWRBc0hlYWRlcihzcmMsIFwiaW1hZ2VcIiwge1xuICAgICAgICAgICAgICAgIGltYWdlU3JjU2V0OiBwcm9wcy5zcmNTZXQsXG4gICAgICAgICAgICAgICAgaW1hZ2VTaXplczogcHJvcHMuc2l6ZXMsXG4gICAgICAgICAgICAgICAgY3Jvc3NPcmlnaW46IGNyb3NzT3JpZ2luLFxuICAgICAgICAgICAgICAgIGludGVncml0eTogcHJvcHMuaW50ZWdyaXR5LFxuICAgICAgICAgICAgICAgIG5vbmNlOiBwcm9wcy5ub25jZSxcbiAgICAgICAgICAgICAgICB0eXBlOiBwcm9wcy50eXBlLFxuICAgICAgICAgICAgICAgIGZldGNoUHJpb3JpdHk6IHByb3BzLmZldGNoUHJpb3JpdHksXG4gICAgICAgICAgICAgICAgcmVmZXJyZXJQb2xpY3k6IHByb3BzLnJlZmVyZXJQb2xpY3lcbiAgICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgICAwIDw9IChoZWFkZXJzLnJlbWFpbmluZ0NhcGFjaXR5IC09IGhlYWRlci5sZW5ndGggKyAyKSlcbiAgICAgICAgICAgICAgICA/ICgocmVuZGVyU3RhdGUucmVzZXRzLmltYWdlW2tleSRqc2NvbXAkMF0gPSBQUkVMT0FEX05PX0NSRURTKSxcbiAgICAgICAgICAgICAgICAgIGhlYWRlcnMuaGlnaEltYWdlUHJlbG9hZHMgJiZcbiAgICAgICAgICAgICAgICAgICAgKGhlYWRlcnMuaGlnaEltYWdlUHJlbG9hZHMgKz0gXCIsIFwiKSxcbiAgICAgICAgICAgICAgICAgIChoZWFkZXJzLmhpZ2hJbWFnZVByZWxvYWRzICs9IGhlYWRlcikpXG4gICAgICAgICAgICAgICAgOiAoKHJlc291cmNlJGpzY29tcCQxID0gW10pLFxuICAgICAgICAgICAgICAgICAgcHVzaExpbmtJbXBsKHJlc291cmNlJGpzY29tcCQxLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlbDogXCJwcmVsb2FkXCIsXG4gICAgICAgICAgICAgICAgICAgIGFzOiBcImltYWdlXCIsXG4gICAgICAgICAgICAgICAgICAgIGhyZWY6IHNyY1NldCA/IHZvaWQgMCA6IHNyYyxcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VTcmNTZXQ6IHNyY1NldCxcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VTaXplczogc2l6ZXMsXG4gICAgICAgICAgICAgICAgICAgIGNyb3NzT3JpZ2luOiBjcm9zc09yaWdpbixcbiAgICAgICAgICAgICAgICAgICAgaW50ZWdyaXR5OiBwcm9wcy5pbnRlZ3JpdHksXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHByb3BzLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGZldGNoUHJpb3JpdHk6IHByb3BzLmZldGNoUHJpb3JpdHksXG4gICAgICAgICAgICAgICAgICAgIHJlZmVycmVyUG9saWN5OiBwcm9wcy5yZWZlcnJlclBvbGljeVxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICBcImhpZ2hcIiA9PT0gcHJvcHMuZmV0Y2hQcmlvcml0eSB8fFxuICAgICAgICAgICAgICAgICAgMTAgPiByZW5kZXJTdGF0ZS5oaWdoSW1hZ2VQcmVsb2Fkcy5zaXplXG4gICAgICAgICAgICAgICAgICAgID8gcmVuZGVyU3RhdGUuaGlnaEltYWdlUHJlbG9hZHMuYWRkKHJlc291cmNlJGpzY29tcCQxKVxuICAgICAgICAgICAgICAgICAgICA6IChyZW5kZXJTdGF0ZS5idWxrUHJlbG9hZHMuYWRkKHJlc291cmNlJGpzY29tcCQxKSxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9tb3RhYmxlUHJlbG9hZHMuc2V0KGtleSRqc2NvbXAkMCwgcmVzb3VyY2UkanNjb21wJDEpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwdXNoU2VsZkNsb3NpbmcodGFyZ2V0JGpzY29tcCQwLCBwcm9wcywgXCJpbWdcIik7XG4gICAgICAgIGNhc2UgXCJiYXNlXCI6XG4gICAgICAgIGNhc2UgXCJhcmVhXCI6XG4gICAgICAgIGNhc2UgXCJiclwiOlxuICAgICAgICBjYXNlIFwiY29sXCI6XG4gICAgICAgIGNhc2UgXCJlbWJlZFwiOlxuICAgICAgICBjYXNlIFwiaHJcIjpcbiAgICAgICAgY2FzZSBcImtleWdlblwiOlxuICAgICAgICBjYXNlIFwicGFyYW1cIjpcbiAgICAgICAgY2FzZSBcInNvdXJjZVwiOlxuICAgICAgICBjYXNlIFwidHJhY2tcIjpcbiAgICAgICAgY2FzZSBcIndiclwiOlxuICAgICAgICAgIHJldHVybiBwdXNoU2VsZkNsb3NpbmcodGFyZ2V0JGpzY29tcCQwLCBwcm9wcywgdHlwZSk7XG4gICAgICAgIGNhc2UgXCJhbm5vdGF0aW9uLXhtbFwiOlxuICAgICAgICBjYXNlIFwiY29sb3ItcHJvZmlsZVwiOlxuICAgICAgICBjYXNlIFwiZm9udC1mYWNlXCI6XG4gICAgICAgIGNhc2UgXCJmb250LWZhY2Utc3JjXCI6XG4gICAgICAgIGNhc2UgXCJmb250LWZhY2UtdXJpXCI6XG4gICAgICAgIGNhc2UgXCJmb250LWZhY2UtZm9ybWF0XCI6XG4gICAgICAgIGNhc2UgXCJmb250LWZhY2UtbmFtZVwiOlxuICAgICAgICBjYXNlIFwibWlzc2luZy1nbHlwaFwiOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiaGVhZFwiOlxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSA8IEhUTUxfTU9ERSAmJlxuICAgICAgICAgICAgbnVsbCA9PT0gcmVuZGVyU3RhdGUuaGVhZENodW5rc1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgcmVuZGVyU3RhdGUuaGVhZENodW5rcyA9IFtdO1xuICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkOSA9IHB1c2hTdGFydEdlbmVyaWNFbGVtZW50KFxuICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5oZWFkQ2h1bmtzLFxuICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgICAgXCJoZWFkXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDkgPSBwdXNoU3RhcnRHZW5lcmljRWxlbWVudChcbiAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLFxuICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgICAgXCJoZWFkXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkOTtcbiAgICAgICAgY2FzZSBcImh0bWxcIjpcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBmb3JtYXRDb250ZXh0Lmluc2VydGlvbk1vZGUgPT09IFJPT1RfSFRNTF9NT0RFICYmXG4gICAgICAgICAgICBudWxsID09PSByZW5kZXJTdGF0ZS5odG1sQ2h1bmtzXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5odG1sQ2h1bmtzID0gW2RvY3R5cGVDaHVua107XG4gICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQxMCA9IHB1c2hTdGFydEdlbmVyaWNFbGVtZW50KFxuICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5odG1sQ2h1bmtzLFxuICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgICAgXCJodG1sXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDEwID0gcHVzaFN0YXJ0R2VuZXJpY0VsZW1lbnQoXG4gICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICAgIFwiaHRtbFwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDEwO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmICgtMSAhPT0gdHlwZS5pbmRleE9mKFwiLVwiKSkge1xuICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goc3RhcnRDaHVua0ZvclRhZyh0eXBlKSk7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4kanNjb21wJDExID0gbnVsbCxcbiAgICAgICAgICAgICAgaW5uZXJIVE1MJGpzY29tcCQ4ID0gbnVsbCxcbiAgICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkMTE7XG4gICAgICAgICAgICBmb3IgKHByb3BLZXkkanNjb21wJDExIGluIHByb3BzKVxuICAgICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSRqc2NvbXAkMTEpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb3BWYWx1ZSRqc2NvbXAkMTEgPSBwcm9wc1twcm9wS2V5JGpzY29tcCQxMV07XG4gICAgICAgICAgICAgICAgaWYgKG51bGwgIT0gcHJvcFZhbHVlJGpzY29tcCQxMSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBwcm9wS2V5JGpzY29tcCQxMTtcbiAgICAgICAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSRqc2NvbXAkMTEpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4kanNjb21wJDExID0gcHJvcFZhbHVlJGpzY29tcCQxMTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgICAgICAgaW5uZXJIVE1MJGpzY29tcCQ4ID0gcHJvcFZhbHVlJGpzY29tcCQxMTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN0eWxlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgcHVzaFN0eWxlQXR0cmlidXRlKHRhcmdldCRqc2NvbXAkMCwgcHJvcFZhbHVlJGpzY29tcCQxMSk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmdcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN1cHByZXNzSHlkcmF0aW9uV2FybmluZ1wiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwicmVmXCI6XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjbGFzc05hbWVcIjpcbiAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVOYW1lID0gXCJjbGFzc1wiO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQXR0cmlidXRlTmFtZVNhZmUocHJvcEtleSRqc2NvbXAkMTEpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBwcm9wVmFsdWUkanNjb21wJDExICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBcInN5bWJvbFwiICE9PSB0eXBlb2YgcHJvcFZhbHVlJGpzY29tcCQxMSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgITEgIT09IHByb3BWYWx1ZSRqc2NvbXAkMTFcbiAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghMCA9PT0gcHJvcFZhbHVlJGpzY29tcCQxMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcFZhbHVlJGpzY29tcCQxMSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgcHJvcFZhbHVlJGpzY29tcCQxMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlU2VwYXJhdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVBc3NpZ24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVzY2FwZVRleHRGb3JCcm93c2VyKHByb3BWYWx1ZSRqc2NvbXAkMTEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVFbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gICAgICAgICAgICBwdXNoSW5uZXJIVE1MKFxuICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICAgIGlubmVySFRNTCRqc2NvbXAkOCxcbiAgICAgICAgICAgICAgY2hpbGRyZW4kanNjb21wJDExXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkcmVuJGpzY29tcCQxMTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcHVzaFN0YXJ0R2VuZXJpY0VsZW1lbnQodGFyZ2V0JGpzY29tcCQwLCBwcm9wcywgdHlwZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVuZENodW5rRm9yVGFnKHRhZykge1xuICAgICAgdmFyIGNodW5rID0gZW5kVGFnQ2FjaGUuZ2V0KHRhZyk7XG4gICAgICB2b2lkIDAgPT09IGNodW5rICYmXG4gICAgICAgICgoY2h1bmsgPSBcIjwvXCIgKyB0YWcgKyBcIj5cIiksIGVuZFRhZ0NhY2hlLnNldCh0YWcsIGNodW5rKSk7XG4gICAgICByZXR1cm4gY2h1bms7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdyaXRlQm9vdHN0cmFwKGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZSkge1xuICAgICAgcmVuZGVyU3RhdGUgPSByZW5kZXJTdGF0ZS5ib290c3RyYXBDaHVua3M7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlbmRlclN0YXRlLmxlbmd0aCAtIDE7IGkrKylcbiAgICAgICAgZGVzdGluYXRpb24ucHVzaChyZW5kZXJTdGF0ZVtpXSk7XG4gICAgICByZXR1cm4gaSA8IHJlbmRlclN0YXRlLmxlbmd0aFxuICAgICAgICA/ICgoaSA9IHJlbmRlclN0YXRlW2ldKSwgKHJlbmRlclN0YXRlLmxlbmd0aCA9IDApLCBkZXN0aW5hdGlvbi5wdXNoKGkpKVxuICAgICAgICA6ICEwO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3cml0ZVN0YXJ0UGVuZGluZ1N1c3BlbnNlQm91bmRhcnkoZGVzdGluYXRpb24sIHJlbmRlclN0YXRlLCBpZCkge1xuICAgICAgZGVzdGluYXRpb24ucHVzaChzdGFydFBlbmRpbmdTdXNwZW5zZUJvdW5kYXJ5MSk7XG4gICAgICBpZiAobnVsbCA9PT0gaWQpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiQW4gSUQgbXVzdCBoYXZlIGJlZW4gYXNzaWduZWQgYmVmb3JlIHdlIGNhbiBjb21wbGV0ZSB0aGUgYm91bmRhcnkuXCJcbiAgICAgICAgKTtcbiAgICAgIGRlc3RpbmF0aW9uLnB1c2gocmVuZGVyU3RhdGUuYm91bmRhcnlQcmVmaXgpO1xuICAgICAgcmVuZGVyU3RhdGUgPSBpZC50b1N0cmluZygxNik7XG4gICAgICBkZXN0aW5hdGlvbi5wdXNoKHJlbmRlclN0YXRlKTtcbiAgICAgIHJldHVybiBkZXN0aW5hdGlvbi5wdXNoKHN0YXJ0UGVuZGluZ1N1c3BlbnNlQm91bmRhcnkyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd3JpdGVTdGFydFNlZ21lbnQoZGVzdGluYXRpb24sIHJlbmRlclN0YXRlLCBmb3JtYXRDb250ZXh0LCBpZCkge1xuICAgICAgc3dpdGNoIChmb3JtYXRDb250ZXh0Lmluc2VydGlvbk1vZGUpIHtcbiAgICAgICAgY2FzZSBST09UX0hUTUxfTU9ERTpcbiAgICAgICAgY2FzZSBIVE1MX0hUTUxfTU9ERTpcbiAgICAgICAgY2FzZSBIVE1MX01PREU6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goc3RhcnRTZWdtZW50SFRNTCksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHJlbmRlclN0YXRlLnNlZ21lbnRQcmVmaXgpLFxuICAgICAgICAgICAgKHJlbmRlclN0YXRlID0gaWQudG9TdHJpbmcoMTYpKSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2gocmVuZGVyU3RhdGUpLFxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChzdGFydFNlZ21lbnRIVE1MMilcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIFNWR19NT0RFOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHN0YXJ0U2VnbWVudFNWRyksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHJlbmRlclN0YXRlLnNlZ21lbnRQcmVmaXgpLFxuICAgICAgICAgICAgKHJlbmRlclN0YXRlID0gaWQudG9TdHJpbmcoMTYpKSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2gocmVuZGVyU3RhdGUpLFxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChzdGFydFNlZ21lbnRTVkcyKVxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgTUFUSE1MX01PREU6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goc3RhcnRTZWdtZW50TWF0aE1MKSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2gocmVuZGVyU3RhdGUuc2VnbWVudFByZWZpeCksXG4gICAgICAgICAgICAocmVuZGVyU3RhdGUgPSBpZC50b1N0cmluZygxNikpLFxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChyZW5kZXJTdGF0ZSksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHN0YXJ0U2VnbWVudE1hdGhNTDIpXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBIVE1MX1RBQkxFX01PREU6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goc3RhcnRTZWdtZW50VGFibGUpLFxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChyZW5kZXJTdGF0ZS5zZWdtZW50UHJlZml4KSxcbiAgICAgICAgICAgIChyZW5kZXJTdGF0ZSA9IGlkLnRvU3RyaW5nKDE2KSksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHJlbmRlclN0YXRlKSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goc3RhcnRTZWdtZW50VGFibGUyKVxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgSFRNTF9UQUJMRV9CT0RZX01PREU6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goc3RhcnRTZWdtZW50VGFibGVCb2R5KSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2gocmVuZGVyU3RhdGUuc2VnbWVudFByZWZpeCksXG4gICAgICAgICAgICAocmVuZGVyU3RhdGUgPSBpZC50b1N0cmluZygxNikpLFxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChyZW5kZXJTdGF0ZSksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHN0YXJ0U2VnbWVudFRhYmxlQm9keTIpXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBIVE1MX1RBQkxFX1JPV19NT0RFOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHN0YXJ0U2VnbWVudFRhYmxlUm93KSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2gocmVuZGVyU3RhdGUuc2VnbWVudFByZWZpeCksXG4gICAgICAgICAgICAocmVuZGVyU3RhdGUgPSBpZC50b1N0cmluZygxNikpLFxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChyZW5kZXJTdGF0ZSksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHN0YXJ0U2VnbWVudFRhYmxlUm93MilcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIEhUTUxfQ09MR1JPVVBfTU9ERTpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChzdGFydFNlZ21lbnRDb2xHcm91cCksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHJlbmRlclN0YXRlLnNlZ21lbnRQcmVmaXgpLFxuICAgICAgICAgICAgKHJlbmRlclN0YXRlID0gaWQudG9TdHJpbmcoMTYpKSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2gocmVuZGVyU3RhdGUpLFxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChzdGFydFNlZ21lbnRDb2xHcm91cDIpXG4gICAgICAgICAgKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBFcnJvcihcIlVua25vd24gaW5zZXJ0aW9uIG1vZGUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB3cml0ZUVuZFNlZ21lbnQoZGVzdGluYXRpb24sIGZvcm1hdENvbnRleHQpIHtcbiAgICAgIHN3aXRjaCAoZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlKSB7XG4gICAgICAgIGNhc2UgUk9PVF9IVE1MX01PREU6XG4gICAgICAgIGNhc2UgSFRNTF9IVE1MX01PREU6XG4gICAgICAgIGNhc2UgSFRNTF9NT0RFOlxuICAgICAgICAgIHJldHVybiBkZXN0aW5hdGlvbi5wdXNoKGVuZFNlZ21lbnRIVE1MKTtcbiAgICAgICAgY2FzZSBTVkdfTU9ERTpcbiAgICAgICAgICByZXR1cm4gZGVzdGluYXRpb24ucHVzaChlbmRTZWdtZW50U1ZHKTtcbiAgICAgICAgY2FzZSBNQVRITUxfTU9ERTpcbiAgICAgICAgICByZXR1cm4gZGVzdGluYXRpb24ucHVzaChlbmRTZWdtZW50TWF0aE1MKTtcbiAgICAgICAgY2FzZSBIVE1MX1RBQkxFX01PREU6XG4gICAgICAgICAgcmV0dXJuIGRlc3RpbmF0aW9uLnB1c2goZW5kU2VnbWVudFRhYmxlKTtcbiAgICAgICAgY2FzZSBIVE1MX1RBQkxFX0JPRFlfTU9ERTpcbiAgICAgICAgICByZXR1cm4gZGVzdGluYXRpb24ucHVzaChlbmRTZWdtZW50VGFibGVCb2R5KTtcbiAgICAgICAgY2FzZSBIVE1MX1RBQkxFX1JPV19NT0RFOlxuICAgICAgICAgIHJldHVybiBkZXN0aW5hdGlvbi5wdXNoKGVuZFNlZ21lbnRUYWJsZVJvdyk7XG4gICAgICAgIGNhc2UgSFRNTF9DT0xHUk9VUF9NT0RFOlxuICAgICAgICAgIHJldHVybiBkZXN0aW5hdGlvbi5wdXNoKGVuZFNlZ21lbnRDb2xHcm91cCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJVbmtub3duIGluc2VydGlvbiBtb2RlLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZXNjYXBlSlNTdHJpbmdzRm9ySW5zdHJ1Y3Rpb25TY3JpcHRzKGlucHV0KSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoaW5wdXQpLnJlcGxhY2UoXG4gICAgICAgIHJlZ2V4Rm9ySlNTdHJpbmdzSW5JbnN0cnVjdGlvblNjcmlwdHMsXG4gICAgICAgIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgIHN3aXRjaCAobWF0Y2gpIHtcbiAgICAgICAgICAgIGNhc2UgXCI8XCI6XG4gICAgICAgICAgICAgIHJldHVybiBcIlxcXFx1MDAzY1wiO1xuICAgICAgICAgICAgY2FzZSBcIlxcdTIwMjhcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIFwiXFxcXHUyMDI4XCI7XG4gICAgICAgICAgICBjYXNlIFwiXFx1MjAyOVwiOlxuICAgICAgICAgICAgICByZXR1cm4gXCJcXFxcdTIwMjlcIjtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiZXNjYXBlSlNTdHJpbmdzRm9ySW5zdHJ1Y3Rpb25TY3JpcHRzIGVuY291bnRlcmVkIGEgbWF0Y2ggaXQgZG9lcyBub3Qga25vdyBob3cgdG8gcmVwbGFjZS4gdGhpcyBtZWFucyB0aGUgbWF0Y2ggcmVnZXggYW5kIHRoZSByZXBsYWNlbWVudCBjaGFyYWN0ZXJzIGFyZSBubyBsb25nZXIgaW4gc3luYy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdFwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlc2NhcGVKU09iamVjdEZvckluc3RydWN0aW9uU2NyaXB0cyhpbnB1dCkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGlucHV0KS5yZXBsYWNlKFxuICAgICAgICByZWdleEZvckpTU3RyaW5nc0luU2NyaXB0cyxcbiAgICAgICAgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgc3dpdGNoIChtYXRjaCkge1xuICAgICAgICAgICAgY2FzZSBcIiZcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIFwiXFxcXHUwMDI2XCI7XG4gICAgICAgICAgICBjYXNlIFwiPlwiOlxuICAgICAgICAgICAgICByZXR1cm4gXCJcXFxcdTAwM2VcIjtcbiAgICAgICAgICAgIGNhc2UgXCI8XCI6XG4gICAgICAgICAgICAgIHJldHVybiBcIlxcXFx1MDAzY1wiO1xuICAgICAgICAgICAgY2FzZSBcIlxcdTIwMjhcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIFwiXFxcXHUyMDI4XCI7XG4gICAgICAgICAgICBjYXNlIFwiXFx1MjAyOVwiOlxuICAgICAgICAgICAgICByZXR1cm4gXCJcXFxcdTIwMjlcIjtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiZXNjYXBlSlNPYmplY3RGb3JJbnN0cnVjdGlvblNjcmlwdHMgZW5jb3VudGVyZWQgYSBtYXRjaCBpdCBkb2VzIG5vdCBrbm93IGhvdyB0byByZXBsYWNlLiB0aGlzIG1lYW5zIHRoZSBtYXRjaCByZWdleCBhbmQgdGhlIHJlcGxhY2VtZW50IGNoYXJhY3RlcnMgYXJlIG5vIGxvbmdlciBpbiBzeW5jLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0XCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsdXNoU3R5bGVUYWdzTGF0ZUZvckJvdW5kYXJ5KHN0eWxlUXVldWUpIHtcbiAgICAgIHZhciBydWxlcyA9IHN0eWxlUXVldWUucnVsZXMsXG4gICAgICAgIGhyZWZzID0gc3R5bGVRdWV1ZS5ocmVmcztcbiAgICAgIDAgPCBydWxlcy5sZW5ndGggJiZcbiAgICAgICAgMCA9PT0gaHJlZnMubGVuZ3RoICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJSZWFjdCBleHBlY3RlZCB0byBoYXZlIGF0IGxlYXN0IG9uZSBocmVmIGZvciBhbiBhIGhvaXN0YWJsZSBzdHlsZSBidXQgZm91bmQgbm9uZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICApO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgaWYgKGhyZWZzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLnB1c2gobGF0ZVN0eWxlVGFnUmVzb3VyY2VPcGVuMSk7XG4gICAgICAgIHRoaXMucHVzaChzdHlsZVF1ZXVlLnByZWNlZGVuY2UpO1xuICAgICAgICBmb3IgKHRoaXMucHVzaChsYXRlU3R5bGVUYWdSZXNvdXJjZU9wZW4yKTsgaSA8IGhyZWZzLmxlbmd0aCAtIDE7IGkrKylcbiAgICAgICAgICB0aGlzLnB1c2goaHJlZnNbaV0pLCB0aGlzLnB1c2goc3BhY2VTZXBhcmF0b3IpO1xuICAgICAgICB0aGlzLnB1c2goaHJlZnNbaV0pO1xuICAgICAgICB0aGlzLnB1c2gobGF0ZVN0eWxlVGFnUmVzb3VyY2VPcGVuMyk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykgdGhpcy5wdXNoKHJ1bGVzW2ldKTtcbiAgICAgICAgZGVzdGluYXRpb25IYXNDYXBhY2l0eSA9IHRoaXMucHVzaChsYXRlU3R5bGVUYWdUZW1wbGF0ZUNsb3NlKTtcbiAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nQm91bmRhcnlIYXNTdHlsZXNUb0hvaXN0ID0gITA7XG4gICAgICAgIHJ1bGVzLmxlbmd0aCA9IDA7XG4gICAgICAgIGhyZWZzLmxlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhc1N0eWxlc1RvSG9pc3Qoc3R5bGVzaGVldCkge1xuICAgICAgcmV0dXJuIHN0eWxlc2hlZXQuc3RhdGUgIT09IFBSRUFNQkxFXG4gICAgICAgID8gKGN1cnJlbnRseVJlbmRlcmluZ0JvdW5kYXJ5SGFzU3R5bGVzVG9Ib2lzdCA9ICEwKVxuICAgICAgICA6ICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3cml0ZUhvaXN0YWJsZXNGb3JCb3VuZGFyeShcbiAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgaG9pc3RhYmxlU3RhdGUsXG4gICAgICByZW5kZXJTdGF0ZVxuICAgICkge1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nQm91bmRhcnlIYXNTdHlsZXNUb0hvaXN0ID0gITE7XG4gICAgICBkZXN0aW5hdGlvbkhhc0NhcGFjaXR5ID0gITA7XG4gICAgICBob2lzdGFibGVTdGF0ZS5zdHlsZXMuZm9yRWFjaChmbHVzaFN0eWxlVGFnc0xhdGVGb3JCb3VuZGFyeSwgZGVzdGluYXRpb24pO1xuICAgICAgaG9pc3RhYmxlU3RhdGUuc3R5bGVzaGVldHMuZm9yRWFjaChoYXNTdHlsZXNUb0hvaXN0KTtcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0JvdW5kYXJ5SGFzU3R5bGVzVG9Ib2lzdCAmJlxuICAgICAgICAocmVuZGVyU3RhdGUuc3R5bGVzVG9Ib2lzdCA9ICEwKTtcbiAgICAgIHJldHVybiBkZXN0aW5hdGlvbkhhc0NhcGFjaXR5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBmbHVzaFJlc291cmNlKHJlc291cmNlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc291cmNlLmxlbmd0aDsgaSsrKSB0aGlzLnB1c2gocmVzb3VyY2VbaV0pO1xuICAgICAgcmVzb3VyY2UubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmx1c2hTdHlsZUluUHJlYW1ibGUoc3R5bGVzaGVldCkge1xuICAgICAgcHVzaExpbmtJbXBsKHN0eWxlc2hlZXRGbHVzaGluZ1F1ZXVlLCBzdHlsZXNoZWV0LnByb3BzKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzaGVldEZsdXNoaW5nUXVldWUubGVuZ3RoOyBpKyspXG4gICAgICAgIHRoaXMucHVzaChzdHlsZXNoZWV0Rmx1c2hpbmdRdWV1ZVtpXSk7XG4gICAgICBzdHlsZXNoZWV0Rmx1c2hpbmdRdWV1ZS5sZW5ndGggPSAwO1xuICAgICAgc3R5bGVzaGVldC5zdGF0ZSA9IFBSRUFNQkxFO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmbHVzaFN0eWxlc0luUHJlYW1ibGUoc3R5bGVRdWV1ZSkge1xuICAgICAgdmFyIGhhc1N0eWxlc2hlZXRzID0gMCA8IHN0eWxlUXVldWUuc2hlZXRzLnNpemU7XG4gICAgICBzdHlsZVF1ZXVlLnNoZWV0cy5mb3JFYWNoKGZsdXNoU3R5bGVJblByZWFtYmxlLCB0aGlzKTtcbiAgICAgIHN0eWxlUXVldWUuc2hlZXRzLmNsZWFyKCk7XG4gICAgICB2YXIgcnVsZXMgPSBzdHlsZVF1ZXVlLnJ1bGVzLFxuICAgICAgICBocmVmcyA9IHN0eWxlUXVldWUuaHJlZnM7XG4gICAgICBpZiAoIWhhc1N0eWxlc2hlZXRzIHx8IGhyZWZzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLnB1c2goc3R5bGVUYWdSZXNvdXJjZU9wZW4xKTtcbiAgICAgICAgdGhpcy5wdXNoKHN0eWxlUXVldWUucHJlY2VkZW5jZSk7XG4gICAgICAgIHN0eWxlUXVldWUgPSAwO1xuICAgICAgICBpZiAoaHJlZnMubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yIChcbiAgICAgICAgICAgIHRoaXMucHVzaChzdHlsZVRhZ1Jlc291cmNlT3BlbjIpO1xuICAgICAgICAgICAgc3R5bGVRdWV1ZSA8IGhyZWZzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBzdHlsZVF1ZXVlKytcbiAgICAgICAgICApXG4gICAgICAgICAgICB0aGlzLnB1c2goaHJlZnNbc3R5bGVRdWV1ZV0pLCB0aGlzLnB1c2goc3BhY2VTZXBhcmF0b3IpO1xuICAgICAgICAgIHRoaXMucHVzaChocmVmc1tzdHlsZVF1ZXVlXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wdXNoKHN0eWxlVGFnUmVzb3VyY2VPcGVuMyk7XG4gICAgICAgIGZvciAoc3R5bGVRdWV1ZSA9IDA7IHN0eWxlUXVldWUgPCBydWxlcy5sZW5ndGg7IHN0eWxlUXVldWUrKylcbiAgICAgICAgICB0aGlzLnB1c2gocnVsZXNbc3R5bGVRdWV1ZV0pO1xuICAgICAgICB0aGlzLnB1c2goc3R5bGVUYWdSZXNvdXJjZUNsb3NlKTtcbiAgICAgICAgcnVsZXMubGVuZ3RoID0gMDtcbiAgICAgICAgaHJlZnMubGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcHJlbG9hZExhdGVTdHlsZShzdHlsZXNoZWV0KSB7XG4gICAgICBpZiAoc3R5bGVzaGVldC5zdGF0ZSA9PT0gUEVORElORyQxKSB7XG4gICAgICAgIHN0eWxlc2hlZXQuc3RhdGUgPSBQUkVMT0FERUQ7XG4gICAgICAgIHZhciBwcm9wcyA9IHN0eWxlc2hlZXQucHJvcHM7XG4gICAgICAgIHB1c2hMaW5rSW1wbChzdHlsZXNoZWV0Rmx1c2hpbmdRdWV1ZSwge1xuICAgICAgICAgIHJlbDogXCJwcmVsb2FkXCIsXG4gICAgICAgICAgYXM6IFwic3R5bGVcIixcbiAgICAgICAgICBocmVmOiBzdHlsZXNoZWV0LnByb3BzLmhyZWYsXG4gICAgICAgICAgY3Jvc3NPcmlnaW46IHByb3BzLmNyb3NzT3JpZ2luLFxuICAgICAgICAgIGZldGNoUHJpb3JpdHk6IHByb3BzLmZldGNoUHJpb3JpdHksXG4gICAgICAgICAgaW50ZWdyaXR5OiBwcm9wcy5pbnRlZ3JpdHksXG4gICAgICAgICAgbWVkaWE6IHByb3BzLm1lZGlhLFxuICAgICAgICAgIGhyZWZMYW5nOiBwcm9wcy5ocmVmTGFuZyxcbiAgICAgICAgICByZWZlcnJlclBvbGljeTogcHJvcHMucmVmZXJyZXJQb2xpY3lcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgc3R5bGVzaGVldCA9IDA7XG4gICAgICAgICAgc3R5bGVzaGVldCA8IHN0eWxlc2hlZXRGbHVzaGluZ1F1ZXVlLmxlbmd0aDtcbiAgICAgICAgICBzdHlsZXNoZWV0KytcbiAgICAgICAgKVxuICAgICAgICAgIHRoaXMucHVzaChzdHlsZXNoZWV0Rmx1c2hpbmdRdWV1ZVtzdHlsZXNoZWV0XSk7XG4gICAgICAgIHN0eWxlc2hlZXRGbHVzaGluZ1F1ZXVlLmxlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByZWxvYWRMYXRlU3R5bGVzKHN0eWxlUXVldWUpIHtcbiAgICAgIHN0eWxlUXVldWUuc2hlZXRzLmZvckVhY2gocHJlbG9hZExhdGVTdHlsZSwgdGhpcyk7XG4gICAgICBzdHlsZVF1ZXVlLnNoZWV0cy5jbGVhcigpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3cml0ZVN0eWxlUmVzb3VyY2VEZXBlbmRlbmNpZXNJbkpTKGRlc3RpbmF0aW9uLCBob2lzdGFibGVTdGF0ZSkge1xuICAgICAgZGVzdGluYXRpb24ucHVzaChhcnJheUZpcnN0T3BlbkJyYWNrZXQpO1xuICAgICAgdmFyIG5leHRBcnJheU9wZW5CcmFja0NodW5rID0gYXJyYXlGaXJzdE9wZW5CcmFja2V0O1xuICAgICAgaG9pc3RhYmxlU3RhdGUuc3R5bGVzaGVldHMuZm9yRWFjaChmdW5jdGlvbiAocmVzb3VyY2UpIHtcbiAgICAgICAgaWYgKHJlc291cmNlLnN0YXRlICE9PSBQUkVBTUJMRSlcbiAgICAgICAgICBpZiAocmVzb3VyY2Uuc3RhdGUgPT09IExBVEUpXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKG5leHRBcnJheU9wZW5CcmFja0NodW5rKSxcbiAgICAgICAgICAgICAgKHJlc291cmNlID0gcmVzb3VyY2UucHJvcHMuaHJlZiksXG4gICAgICAgICAgICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24ocmVzb3VyY2UsIFwiaHJlZlwiKSxcbiAgICAgICAgICAgICAgKHJlc291cmNlID0gZXNjYXBlSlNPYmplY3RGb3JJbnN0cnVjdGlvblNjcmlwdHMoXCJcIiArIHJlc291cmNlKSksXG4gICAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2gocmVzb3VyY2UpLFxuICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKGFycmF5Q2xvc2VCcmFja2V0KSxcbiAgICAgICAgICAgICAgKG5leHRBcnJheU9wZW5CcmFja0NodW5rID0gYXJyYXlTdWJzZXF1ZW50T3BlbkJyYWNrZXQpO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChuZXh0QXJyYXlPcGVuQnJhY2tDaHVuayk7XG4gICAgICAgICAgICB2YXIgcHJlY2VkZW5jZSA9IHJlc291cmNlLnByb3BzW1wiZGF0YS1wcmVjZWRlbmNlXCJdLFxuICAgICAgICAgICAgICBwcm9wcyA9IHJlc291cmNlLnByb3BzLFxuICAgICAgICAgICAgICBjb2VyY2VkSHJlZiA9IHNhbml0aXplVVJMKFwiXCIgKyByZXNvdXJjZS5wcm9wcy5ocmVmKTtcbiAgICAgICAgICAgIGNvZXJjZWRIcmVmID0gZXNjYXBlSlNPYmplY3RGb3JJbnN0cnVjdGlvblNjcmlwdHMoY29lcmNlZEhyZWYpO1xuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChjb2VyY2VkSHJlZik7XG4gICAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHByZWNlZGVuY2UsIFwicHJlY2VkZW5jZVwiKTtcbiAgICAgICAgICAgIHByZWNlZGVuY2UgPSBcIlwiICsgcHJlY2VkZW5jZTtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goYXJyYXlJbnRlcnN0aXRpYWwpO1xuICAgICAgICAgICAgcHJlY2VkZW5jZSA9IGVzY2FwZUpTT2JqZWN0Rm9ySW5zdHJ1Y3Rpb25TY3JpcHRzKHByZWNlZGVuY2UpO1xuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChwcmVjZWRlbmNlKTtcbiAgICAgICAgICAgIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpXG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSAmJlxuICAgICAgICAgICAgICAgICgocHJlY2VkZW5jZSA9IHByb3BzW3Byb3BLZXldKSwgbnVsbCAhPSBwcmVjZWRlbmNlKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiaHJlZlwiOlxuICAgICAgICAgICAgICAgICAgY2FzZSBcInJlbFwiOlxuICAgICAgICAgICAgICAgICAgY2FzZSBcInByZWNlZGVuY2VcIjpcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJkYXRhLXByZWNlZGVuY2VcIjpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICBcImxpbmsgaXMgYSBzZWxmLWNsb3NpbmcgdGFnIGFuZCBtdXN0IG5laXRoZXIgaGF2ZSBgY2hpbGRyZW5gIG5vciB1c2UgYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC5cIlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVTdHlsZVJlc291cmNlQXR0cmlidXRlSW5KUyhcbiAgICAgICAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wS2V5LFxuICAgICAgICAgICAgICAgICAgICAgIHByZWNlZGVuY2VcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKGFycmF5Q2xvc2VCcmFja2V0KTtcbiAgICAgICAgICAgIG5leHRBcnJheU9wZW5CcmFja0NodW5rID0gYXJyYXlTdWJzZXF1ZW50T3BlbkJyYWNrZXQ7XG4gICAgICAgICAgICByZXNvdXJjZS5zdGF0ZSA9IExBVEU7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBkZXN0aW5hdGlvbi5wdXNoKGFycmF5Q2xvc2VCcmFja2V0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd3JpdGVTdHlsZVJlc291cmNlQXR0cmlidXRlSW5KUyhkZXN0aW5hdGlvbiwgbmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgY2FzZSBcImlubmVySFRNTFwiOlxuICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgY2FzZSBcInN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZ1wiOlxuICAgICAgICBjYXNlIFwic3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nXCI6XG4gICAgICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgICBjYXNlIFwicmVmXCI6XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIFwiY2xhc3NOYW1lXCI6XG4gICAgICAgICAgYXR0cmlidXRlTmFtZSA9IFwiY2xhc3NcIjtcbiAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICBuYW1lID0gXCJcIiArIHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiaGlkZGVuXCI6XG4gICAgICAgICAgaWYgKCExID09PSB2YWx1ZSkgcmV0dXJuO1xuICAgICAgICAgIG5hbWUgPSBcIlwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic3JjXCI6XG4gICAgICAgIGNhc2UgXCJocmVmXCI6XG4gICAgICAgICAgdmFsdWUgPSBzYW5pdGl6ZVVSTCh2YWx1ZSk7XG4gICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgYXR0cmlidXRlTmFtZSk7XG4gICAgICAgICAgbmFtZSA9IFwiXCIgKyB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAoMiA8IG5hbWUubGVuZ3RoICYmXG4gICAgICAgICAgICAgIChcIm9cIiA9PT0gbmFtZVswXSB8fCBcIk9cIiA9PT0gbmFtZVswXSkgJiZcbiAgICAgICAgICAgICAgKFwiblwiID09PSBuYW1lWzFdIHx8IFwiTlwiID09PSBuYW1lWzFdKSkgfHxcbiAgICAgICAgICAgICFpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpXG4gICAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odmFsdWUsIGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICAgIG5hbWUgPSBcIlwiICsgdmFsdWU7XG4gICAgICB9XG4gICAgICBkZXN0aW5hdGlvbi5wdXNoKGFycmF5SW50ZXJzdGl0aWFsKTtcbiAgICAgIGF0dHJpYnV0ZU5hbWUgPSBlc2NhcGVKU09iamVjdEZvckluc3RydWN0aW9uU2NyaXB0cyhhdHRyaWJ1dGVOYW1lKTtcbiAgICAgIGRlc3RpbmF0aW9uLnB1c2goYXR0cmlidXRlTmFtZSk7XG4gICAgICBkZXN0aW5hdGlvbi5wdXNoKGFycmF5SW50ZXJzdGl0aWFsKTtcbiAgICAgIGF0dHJpYnV0ZU5hbWUgPSBlc2NhcGVKU09iamVjdEZvckluc3RydWN0aW9uU2NyaXB0cyhuYW1lKTtcbiAgICAgIGRlc3RpbmF0aW9uLnB1c2goYXR0cmlidXRlTmFtZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUhvaXN0YWJsZVN0YXRlKCkge1xuICAgICAgcmV0dXJuIHsgc3R5bGVzOiBuZXcgU2V0KCksIHN0eWxlc2hlZXRzOiBuZXcgU2V0KCkgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJlbG9hZEJvb3RzdHJhcFNjcmlwdE9yTW9kdWxlKFxuICAgICAgcmVzdW1hYmxlU3RhdGUsXG4gICAgICByZW5kZXJTdGF0ZSxcbiAgICAgIGhyZWYsXG4gICAgICBwcm9wc1xuICAgICkge1xuICAgICAgKHJlc3VtYWJsZVN0YXRlLnNjcmlwdFJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShocmVmKSB8fFxuICAgICAgICByZXN1bWFibGVTdGF0ZS5tb2R1bGVTY3JpcHRSZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoaHJlZikpICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgJ0ludGVybmFsIFJlYWN0IEVycm9yOiBSZWFjdCBleHBlY3RlZCBib290c3RyYXAgc2NyaXB0IG9yIG1vZHVsZSB3aXRoIHNyYyBcIiVzXCIgdG8gbm90IGhhdmUgYmVlbiBwcmVsb2FkZWQgYWxyZWFkeS4gcGxlYXNlIGZpbGUgYW4gaXNzdWUnLFxuICAgICAgICAgIGhyZWZcbiAgICAgICAgKTtcbiAgICAgIHJlc3VtYWJsZVN0YXRlLnNjcmlwdFJlc291cmNlc1tocmVmXSA9IEVYSVNUUztcbiAgICAgIHJlc3VtYWJsZVN0YXRlLm1vZHVsZVNjcmlwdFJlc291cmNlc1tocmVmXSA9IEVYSVNUUztcbiAgICAgIHJlc3VtYWJsZVN0YXRlID0gW107XG4gICAgICBwdXNoTGlua0ltcGwocmVzdW1hYmxlU3RhdGUsIHByb3BzKTtcbiAgICAgIHJlbmRlclN0YXRlLmJvb3RzdHJhcFNjcmlwdHMuYWRkKHJlc3VtYWJsZVN0YXRlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWRvcHRQcmVsb2FkQ3JlZGVudGlhbHModGFyZ2V0LCBwcmVsb2FkU3RhdGUpIHtcbiAgICAgIG51bGwgPT0gdGFyZ2V0LmNyb3NzT3JpZ2luICYmICh0YXJnZXQuY3Jvc3NPcmlnaW4gPSBwcmVsb2FkU3RhdGVbMF0pO1xuICAgICAgbnVsbCA9PSB0YXJnZXQuaW50ZWdyaXR5ICYmICh0YXJnZXQuaW50ZWdyaXR5ID0gcHJlbG9hZFN0YXRlWzFdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0UHJlbG9hZEFzSGVhZGVyKGhyZWYsIGFzLCBwYXJhbXMpIHtcbiAgICAgIGhyZWYgPSBlc2NhcGVIcmVmRm9yTGlua0hlYWRlclVSTENvbnRleHQoaHJlZik7XG4gICAgICBhcyA9IGVzY2FwZVN0cmluZ0ZvckxpbmtIZWFkZXJRdW90ZWRQYXJhbVZhbHVlQ29udGV4dChhcywgXCJhc1wiKTtcbiAgICAgIGFzID0gXCI8XCIgKyBocmVmICsgJz47IHJlbD1wcmVsb2FkOyBhcz1cIicgKyBhcyArICdcIic7XG4gICAgICBmb3IgKHZhciBwYXJhbU5hbWUgaW4gcGFyYW1zKVxuICAgICAgICBoYXNPd25Qcm9wZXJ0eS5jYWxsKHBhcmFtcywgcGFyYW1OYW1lKSAmJlxuICAgICAgICAgICgoaHJlZiA9IHBhcmFtc1twYXJhbU5hbWVdKSxcbiAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgaHJlZiAmJlxuICAgICAgICAgICAgKGFzICs9XG4gICAgICAgICAgICAgIFwiOyBcIiArXG4gICAgICAgICAgICAgIHBhcmFtTmFtZS50b0xvd2VyQ2FzZSgpICtcbiAgICAgICAgICAgICAgJz1cIicgK1xuICAgICAgICAgICAgICBlc2NhcGVTdHJpbmdGb3JMaW5rSGVhZGVyUXVvdGVkUGFyYW1WYWx1ZUNvbnRleHQoXG4gICAgICAgICAgICAgICAgaHJlZixcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWVcbiAgICAgICAgICAgICAgKSArXG4gICAgICAgICAgICAgICdcIicpKTtcbiAgICAgIHJldHVybiBhcztcbiAgICB9XG4gICAgZnVuY3Rpb24gZXNjYXBlSHJlZkZvckxpbmtIZWFkZXJVUkxDb250ZXh0KGhyZWZJbnB1dCkge1xuICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbihocmVmSW5wdXQsIFwiaHJlZlwiKTtcbiAgICAgIHJldHVybiAoXCJcIiArIGhyZWZJbnB1dCkucmVwbGFjZShcbiAgICAgICAgcmVnZXhGb3JIcmVmSW5MaW5rSGVhZGVyVVJMQ29udGV4dCxcbiAgICAgICAgZXNjYXBlSHJlZkZvckxpbmtIZWFkZXJVUkxDb250ZXh0UmVwbGFjZXJcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVzY2FwZUhyZWZGb3JMaW5rSGVhZGVyVVJMQ29udGV4dFJlcGxhY2VyKG1hdGNoKSB7XG4gICAgICBzd2l0Y2ggKG1hdGNoKSB7XG4gICAgICAgIGNhc2UgXCI8XCI6XG4gICAgICAgICAgcmV0dXJuIFwiJTNDXCI7XG4gICAgICAgIGNhc2UgXCI+XCI6XG4gICAgICAgICAgcmV0dXJuIFwiJTNFXCI7XG4gICAgICAgIGNhc2UgXCJcXG5cIjpcbiAgICAgICAgICByZXR1cm4gXCIlMEFcIjtcbiAgICAgICAgY2FzZSBcIlxcclwiOlxuICAgICAgICAgIHJldHVybiBcIiUwRFwiO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJlc2NhcGVMaW5rSHJlZkZvckhlYWRlckNvbnRleHRSZXBsYWNlciBlbmNvdW50ZXJlZCBhIG1hdGNoIGl0IGRvZXMgbm90IGtub3cgaG93IHRvIHJlcGxhY2UuIHRoaXMgbWVhbnMgdGhlIG1hdGNoIHJlZ2V4IGFuZCB0aGUgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBhcmUgbm8gbG9uZ2VyIGluIHN5bmMuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3RcIlxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVzY2FwZVN0cmluZ0ZvckxpbmtIZWFkZXJRdW90ZWRQYXJhbVZhbHVlQ29udGV4dCh2YWx1ZSwgbmFtZSkge1xuICAgICAgd2lsbENvZXJjaW9uVGhyb3codmFsdWUpICYmXG4gICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiVGhlIHByb3ZpZGVkIGAlc2Agb3B0aW9uIGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLlwiLFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgdHlwZU5hbWUodmFsdWUpXG4gICAgICAgICksXG4gICAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkpO1xuICAgICAgcmV0dXJuIChcIlwiICsgdmFsdWUpLnJlcGxhY2UoXG4gICAgICAgIHJlZ2V4Rm9yTGlua0hlYWRlclF1b3RlZFBhcmFtVmFsdWVDb250ZXh0LFxuICAgICAgICBlc2NhcGVTdHJpbmdGb3JMaW5rSGVhZGVyUXVvdGVkUGFyYW1WYWx1ZUNvbnRleHRSZXBsYWNlclxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXNjYXBlU3RyaW5nRm9yTGlua0hlYWRlclF1b3RlZFBhcmFtVmFsdWVDb250ZXh0UmVwbGFjZXIobWF0Y2gpIHtcbiAgICAgIHN3aXRjaCAobWF0Y2gpIHtcbiAgICAgICAgY2FzZSAnXCInOlxuICAgICAgICAgIHJldHVybiBcIiUyMlwiO1xuICAgICAgICBjYXNlIFwiJ1wiOlxuICAgICAgICAgIHJldHVybiBcIiUyN1wiO1xuICAgICAgICBjYXNlIFwiO1wiOlxuICAgICAgICAgIHJldHVybiBcIiUzQlwiO1xuICAgICAgICBjYXNlIFwiLFwiOlxuICAgICAgICAgIHJldHVybiBcIiUyQ1wiO1xuICAgICAgICBjYXNlIFwiXFxuXCI6XG4gICAgICAgICAgcmV0dXJuIFwiJTBBXCI7XG4gICAgICAgIGNhc2UgXCJcXHJcIjpcbiAgICAgICAgICByZXR1cm4gXCIlMERcIjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiZXNjYXBlU3RyaW5nRm9yTGlua0hlYWRlclF1b3RlZFBhcmFtVmFsdWVDb250ZXh0UmVwbGFjZXIgZW5jb3VudGVyZWQgYSBtYXRjaCBpdCBkb2VzIG5vdCBrbm93IGhvdyB0byByZXBsYWNlLiB0aGlzIG1lYW5zIHRoZSBtYXRjaCByZWdleCBhbmQgdGhlIHJlcGxhY2VtZW50IGNoYXJhY3RlcnMgYXJlIG5vIGxvbmdlciBpbiBzeW5jLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0XCJcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBob2lzdFN0eWxlUXVldWVEZXBlbmRlbmN5KHN0eWxlUXVldWUpIHtcbiAgICAgIHRoaXMuc3R5bGVzLmFkZChzdHlsZVF1ZXVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaG9pc3RTdHlsZXNoZWV0RGVwZW5kZW5jeShzdHlsZXNoZWV0KSB7XG4gICAgICB0aGlzLnN0eWxlc2hlZXRzLmFkZChzdHlsZXNoZWV0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlUmVuZGVyU3RhdGUocmVzdW1hYmxlU3RhdGUsIGdlbmVyYXRlU3RhdGljTWFya3VwKSB7XG4gICAgICB2YXIgaWRQcmVmaXggPSByZXN1bWFibGVTdGF0ZS5pZFByZWZpeCxcbiAgICAgICAgYm9vdHN0cmFwQ2h1bmtzID0gW10sXG4gICAgICAgIGJvb3RzdHJhcFNjcmlwdENvbnRlbnQgPSByZXN1bWFibGVTdGF0ZS5ib290c3RyYXBTY3JpcHRDb250ZW50LFxuICAgICAgICBib290c3RyYXBTY3JpcHRzID0gcmVzdW1hYmxlU3RhdGUuYm9vdHN0cmFwU2NyaXB0cyxcbiAgICAgICAgYm9vdHN0cmFwTW9kdWxlcyA9IHJlc3VtYWJsZVN0YXRlLmJvb3RzdHJhcE1vZHVsZXM7XG4gICAgICB2b2lkIDAgIT09IGJvb3RzdHJhcFNjcmlwdENvbnRlbnQgJiZcbiAgICAgICAgYm9vdHN0cmFwQ2h1bmtzLnB1c2goXG4gICAgICAgICAgXCI8c2NyaXB0PlwiLFxuICAgICAgICAgIGVzY2FwZUVudGlyZUlubGluZVNjcmlwdENvbnRlbnQoYm9vdHN0cmFwU2NyaXB0Q29udGVudCksXG4gICAgICAgICAgXCJcXHgzYy9zY3JpcHQ+XCJcbiAgICAgICAgKTtcbiAgICAgIGlkUHJlZml4ID0ge1xuICAgICAgICBwbGFjZWhvbGRlclByZWZpeDogaWRQcmVmaXggKyBcIlA6XCIsXG4gICAgICAgIHNlZ21lbnRQcmVmaXg6IGlkUHJlZml4ICsgXCJTOlwiLFxuICAgICAgICBib3VuZGFyeVByZWZpeDogaWRQcmVmaXggKyBcIkI6XCIsXG4gICAgICAgIHN0YXJ0SW5saW5lU2NyaXB0OiBcIjxzY3JpcHQ+XCIsXG4gICAgICAgIGh0bWxDaHVua3M6IG51bGwsXG4gICAgICAgIGhlYWRDaHVua3M6IG51bGwsXG4gICAgICAgIGV4dGVybmFsUnVudGltZVNjcmlwdDogbnVsbCxcbiAgICAgICAgYm9vdHN0cmFwQ2h1bmtzOiBib290c3RyYXBDaHVua3MsXG4gICAgICAgIGltcG9ydE1hcENodW5rczogW10sXG4gICAgICAgIG9uSGVhZGVyczogdm9pZCAwLFxuICAgICAgICBoZWFkZXJzOiBudWxsLFxuICAgICAgICByZXNldHM6IHtcbiAgICAgICAgICBmb250OiB7fSxcbiAgICAgICAgICBkbnM6IHt9LFxuICAgICAgICAgIGNvbm5lY3Q6IHsgZGVmYXVsdDoge30sIGFub255bW91czoge30sIGNyZWRlbnRpYWxzOiB7fSB9LFxuICAgICAgICAgIGltYWdlOiB7fSxcbiAgICAgICAgICBzdHlsZToge31cbiAgICAgICAgfSxcbiAgICAgICAgY2hhcnNldENodW5rczogW10sXG4gICAgICAgIHZpZXdwb3J0Q2h1bmtzOiBbXSxcbiAgICAgICAgaG9pc3RhYmxlQ2h1bmtzOiBbXSxcbiAgICAgICAgcHJlY29ubmVjdHM6IG5ldyBTZXQoKSxcbiAgICAgICAgZm9udFByZWxvYWRzOiBuZXcgU2V0KCksXG4gICAgICAgIGhpZ2hJbWFnZVByZWxvYWRzOiBuZXcgU2V0KCksXG4gICAgICAgIHN0eWxlczogbmV3IE1hcCgpLFxuICAgICAgICBib290c3RyYXBTY3JpcHRzOiBuZXcgU2V0KCksXG4gICAgICAgIHNjcmlwdHM6IG5ldyBTZXQoKSxcbiAgICAgICAgYnVsa1ByZWxvYWRzOiBuZXcgU2V0KCksXG4gICAgICAgIHByZWxvYWRzOiB7XG4gICAgICAgICAgaW1hZ2VzOiBuZXcgTWFwKCksXG4gICAgICAgICAgc3R5bGVzaGVldHM6IG5ldyBNYXAoKSxcbiAgICAgICAgICBzY3JpcHRzOiBuZXcgTWFwKCksXG4gICAgICAgICAgbW9kdWxlU2NyaXB0czogbmV3IE1hcCgpXG4gICAgICAgIH0sXG4gICAgICAgIG5vbmNlOiB2b2lkIDAsXG4gICAgICAgIGhvaXN0YWJsZVN0YXRlOiBudWxsLFxuICAgICAgICBzdHlsZXNUb0hvaXN0OiAhMVxuICAgICAgfTtcbiAgICAgIGlmICh2b2lkIDAgIT09IGJvb3RzdHJhcFNjcmlwdHMpXG4gICAgICAgIGZvciAoXG4gICAgICAgICAgYm9vdHN0cmFwU2NyaXB0Q29udGVudCA9IDA7XG4gICAgICAgICAgYm9vdHN0cmFwU2NyaXB0Q29udGVudCA8IGJvb3RzdHJhcFNjcmlwdHMubGVuZ3RoO1xuICAgICAgICAgIGJvb3RzdHJhcFNjcmlwdENvbnRlbnQrK1xuICAgICAgICApIHtcbiAgICAgICAgICB2YXIgc2NyaXB0Q29uZmlnID0gYm9vdHN0cmFwU2NyaXB0c1tib290c3RyYXBTY3JpcHRDb250ZW50XSxcbiAgICAgICAgICAgIHNyYyxcbiAgICAgICAgICAgIGNyb3NzT3JpZ2luID0gdm9pZCAwLFxuICAgICAgICAgICAgaW50ZWdyaXR5ID0gdm9pZCAwLFxuICAgICAgICAgICAgcHJvcHMgPSB7XG4gICAgICAgICAgICAgIHJlbDogXCJwcmVsb2FkXCIsXG4gICAgICAgICAgICAgIGFzOiBcInNjcmlwdFwiLFxuICAgICAgICAgICAgICBmZXRjaFByaW9yaXR5OiBcImxvd1wiLFxuICAgICAgICAgICAgICBub25jZTogdm9pZCAwXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBzY3JpcHRDb25maWdcbiAgICAgICAgICAgID8gKHByb3BzLmhyZWYgPSBzcmMgPSBzY3JpcHRDb25maWcpXG4gICAgICAgICAgICA6ICgocHJvcHMuaHJlZiA9IHNyYyA9IHNjcmlwdENvbmZpZy5zcmMpLFxuICAgICAgICAgICAgICAocHJvcHMuaW50ZWdyaXR5ID0gaW50ZWdyaXR5ID1cbiAgICAgICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygc2NyaXB0Q29uZmlnLmludGVncml0eVxuICAgICAgICAgICAgICAgICAgPyBzY3JpcHRDb25maWcuaW50ZWdyaXR5XG4gICAgICAgICAgICAgICAgICA6IHZvaWQgMCksXG4gICAgICAgICAgICAgIChwcm9wcy5jcm9zc09yaWdpbiA9IGNyb3NzT3JpZ2luID1cbiAgICAgICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygc2NyaXB0Q29uZmlnIHx8XG4gICAgICAgICAgICAgICAgbnVsbCA9PSBzY3JpcHRDb25maWcuY3Jvc3NPcmlnaW5cbiAgICAgICAgICAgICAgICAgID8gdm9pZCAwXG4gICAgICAgICAgICAgICAgICA6IFwidXNlLWNyZWRlbnRpYWxzXCIgPT09IHNjcmlwdENvbmZpZy5jcm9zc09yaWdpblxuICAgICAgICAgICAgICAgICAgICA/IFwidXNlLWNyZWRlbnRpYWxzXCJcbiAgICAgICAgICAgICAgICAgICAgOiBcIlwiKSk7XG4gICAgICAgICAgcHJlbG9hZEJvb3RzdHJhcFNjcmlwdE9yTW9kdWxlKHJlc3VtYWJsZVN0YXRlLCBpZFByZWZpeCwgc3JjLCBwcm9wcyk7XG4gICAgICAgICAgYm9vdHN0cmFwQ2h1bmtzLnB1c2goJzxzY3JpcHQgc3JjPVwiJywgZXNjYXBlVGV4dEZvckJyb3dzZXIoc3JjKSk7XG4gICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGludGVncml0eSAmJlxuICAgICAgICAgICAgYm9vdHN0cmFwQ2h1bmtzLnB1c2goXG4gICAgICAgICAgICAgICdcIiBpbnRlZ3JpdHk9XCInLFxuICAgICAgICAgICAgICBlc2NhcGVUZXh0Rm9yQnJvd3NlcihpbnRlZ3JpdHkpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBjcm9zc09yaWdpbiAmJlxuICAgICAgICAgICAgYm9vdHN0cmFwQ2h1bmtzLnB1c2goXG4gICAgICAgICAgICAgICdcIiBjcm9zc29yaWdpbj1cIicsXG4gICAgICAgICAgICAgIGVzY2FwZVRleHRGb3JCcm93c2VyKGNyb3NzT3JpZ2luKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBib290c3RyYXBDaHVua3MucHVzaCgnXCIgYXN5bmM9XCJcIj5cXHgzYy9zY3JpcHQ+Jyk7XG4gICAgICAgIH1cbiAgICAgIGlmICh2b2lkIDAgIT09IGJvb3RzdHJhcE1vZHVsZXMpXG4gICAgICAgIGZvciAoXG4gICAgICAgICAgYm9vdHN0cmFwU2NyaXB0cyA9IDA7XG4gICAgICAgICAgYm9vdHN0cmFwU2NyaXB0cyA8IGJvb3RzdHJhcE1vZHVsZXMubGVuZ3RoO1xuICAgICAgICAgIGJvb3RzdHJhcFNjcmlwdHMrK1xuICAgICAgICApXG4gICAgICAgICAgKGJvb3RzdHJhcFNjcmlwdENvbnRlbnQgPSBib290c3RyYXBNb2R1bGVzW2Jvb3RzdHJhcFNjcmlwdHNdKSxcbiAgICAgICAgICAgIChjcm9zc09yaWdpbiA9IHNyYyA9IHZvaWQgMCksXG4gICAgICAgICAgICAoaW50ZWdyaXR5ID0ge1xuICAgICAgICAgICAgICByZWw6IFwibW9kdWxlcHJlbG9hZFwiLFxuICAgICAgICAgICAgICBmZXRjaFByaW9yaXR5OiBcImxvd1wiLFxuICAgICAgICAgICAgICBub25jZTogdm9pZCAwXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBib290c3RyYXBTY3JpcHRDb250ZW50XG4gICAgICAgICAgICAgID8gKGludGVncml0eS5ocmVmID0gc2NyaXB0Q29uZmlnID0gYm9vdHN0cmFwU2NyaXB0Q29udGVudClcbiAgICAgICAgICAgICAgOiAoKGludGVncml0eS5ocmVmID0gc2NyaXB0Q29uZmlnID0gYm9vdHN0cmFwU2NyaXB0Q29udGVudC5zcmMpLFxuICAgICAgICAgICAgICAgIChpbnRlZ3JpdHkuaW50ZWdyaXR5ID0gY3Jvc3NPcmlnaW4gPVxuICAgICAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGJvb3RzdHJhcFNjcmlwdENvbnRlbnQuaW50ZWdyaXR5XG4gICAgICAgICAgICAgICAgICAgID8gYm9vdHN0cmFwU2NyaXB0Q29udGVudC5pbnRlZ3JpdHlcbiAgICAgICAgICAgICAgICAgICAgOiB2b2lkIDApLFxuICAgICAgICAgICAgICAgIChpbnRlZ3JpdHkuY3Jvc3NPcmlnaW4gPSBzcmMgPVxuICAgICAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGJvb3RzdHJhcFNjcmlwdENvbnRlbnQgfHxcbiAgICAgICAgICAgICAgICAgIG51bGwgPT0gYm9vdHN0cmFwU2NyaXB0Q29udGVudC5jcm9zc09yaWdpblxuICAgICAgICAgICAgICAgICAgICA/IHZvaWQgMFxuICAgICAgICAgICAgICAgICAgICA6IFwidXNlLWNyZWRlbnRpYWxzXCIgPT09IGJvb3RzdHJhcFNjcmlwdENvbnRlbnQuY3Jvc3NPcmlnaW5cbiAgICAgICAgICAgICAgICAgICAgICA/IFwidXNlLWNyZWRlbnRpYWxzXCJcbiAgICAgICAgICAgICAgICAgICAgICA6IFwiXCIpKSxcbiAgICAgICAgICAgIHByZWxvYWRCb290c3RyYXBTY3JpcHRPck1vZHVsZShcbiAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICAgIGlkUHJlZml4LFxuICAgICAgICAgICAgICBzY3JpcHRDb25maWcsXG4gICAgICAgICAgICAgIGludGVncml0eVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGJvb3RzdHJhcENodW5rcy5wdXNoKFxuICAgICAgICAgICAgICAnPHNjcmlwdCB0eXBlPVwibW9kdWxlXCIgc3JjPVwiJyxcbiAgICAgICAgICAgICAgZXNjYXBlVGV4dEZvckJyb3dzZXIoc2NyaXB0Q29uZmlnKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBjcm9zc09yaWdpbiAmJlxuICAgICAgICAgICAgICBib290c3RyYXBDaHVua3MucHVzaChcbiAgICAgICAgICAgICAgICAnXCIgaW50ZWdyaXR5PVwiJyxcbiAgICAgICAgICAgICAgICBlc2NhcGVUZXh0Rm9yQnJvd3Nlcihjcm9zc09yaWdpbilcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBzcmMgJiZcbiAgICAgICAgICAgICAgYm9vdHN0cmFwQ2h1bmtzLnB1c2goXG4gICAgICAgICAgICAgICAgJ1wiIGNyb3Nzb3JpZ2luPVwiJyxcbiAgICAgICAgICAgICAgICBlc2NhcGVUZXh0Rm9yQnJvd3NlcihzcmMpXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICBib290c3RyYXBDaHVua3MucHVzaCgnXCIgYXN5bmM9XCJcIj5cXHgzYy9zY3JpcHQ+Jyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwbGFjZWhvbGRlclByZWZpeDogaWRQcmVmaXgucGxhY2Vob2xkZXJQcmVmaXgsXG4gICAgICAgIHNlZ21lbnRQcmVmaXg6IGlkUHJlZml4LnNlZ21lbnRQcmVmaXgsXG4gICAgICAgIGJvdW5kYXJ5UHJlZml4OiBpZFByZWZpeC5ib3VuZGFyeVByZWZpeCxcbiAgICAgICAgc3RhcnRJbmxpbmVTY3JpcHQ6IGlkUHJlZml4LnN0YXJ0SW5saW5lU2NyaXB0LFxuICAgICAgICBodG1sQ2h1bmtzOiBpZFByZWZpeC5odG1sQ2h1bmtzLFxuICAgICAgICBoZWFkQ2h1bmtzOiBpZFByZWZpeC5oZWFkQ2h1bmtzLFxuICAgICAgICBleHRlcm5hbFJ1bnRpbWVTY3JpcHQ6IGlkUHJlZml4LmV4dGVybmFsUnVudGltZVNjcmlwdCxcbiAgICAgICAgYm9vdHN0cmFwQ2h1bmtzOiBpZFByZWZpeC5ib290c3RyYXBDaHVua3MsXG4gICAgICAgIGltcG9ydE1hcENodW5rczogaWRQcmVmaXguaW1wb3J0TWFwQ2h1bmtzLFxuICAgICAgICBvbkhlYWRlcnM6IGlkUHJlZml4Lm9uSGVhZGVycyxcbiAgICAgICAgaGVhZGVyczogaWRQcmVmaXguaGVhZGVycyxcbiAgICAgICAgcmVzZXRzOiBpZFByZWZpeC5yZXNldHMsXG4gICAgICAgIGNoYXJzZXRDaHVua3M6IGlkUHJlZml4LmNoYXJzZXRDaHVua3MsXG4gICAgICAgIHZpZXdwb3J0Q2h1bmtzOiBpZFByZWZpeC52aWV3cG9ydENodW5rcyxcbiAgICAgICAgaG9pc3RhYmxlQ2h1bmtzOiBpZFByZWZpeC5ob2lzdGFibGVDaHVua3MsXG4gICAgICAgIHByZWNvbm5lY3RzOiBpZFByZWZpeC5wcmVjb25uZWN0cyxcbiAgICAgICAgZm9udFByZWxvYWRzOiBpZFByZWZpeC5mb250UHJlbG9hZHMsXG4gICAgICAgIGhpZ2hJbWFnZVByZWxvYWRzOiBpZFByZWZpeC5oaWdoSW1hZ2VQcmVsb2FkcyxcbiAgICAgICAgc3R5bGVzOiBpZFByZWZpeC5zdHlsZXMsXG4gICAgICAgIGJvb3RzdHJhcFNjcmlwdHM6IGlkUHJlZml4LmJvb3RzdHJhcFNjcmlwdHMsXG4gICAgICAgIHNjcmlwdHM6IGlkUHJlZml4LnNjcmlwdHMsXG4gICAgICAgIGJ1bGtQcmVsb2FkczogaWRQcmVmaXguYnVsa1ByZWxvYWRzLFxuICAgICAgICBwcmVsb2FkczogaWRQcmVmaXgucHJlbG9hZHMsXG4gICAgICAgIHN0eWxlc1RvSG9pc3Q6IGlkUHJlZml4LnN0eWxlc1RvSG9pc3QsXG4gICAgICAgIGdlbmVyYXRlU3RhdGljTWFya3VwOiBnZW5lcmF0ZVN0YXRpY01hcmt1cFxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaFRleHRJbnN0YW5jZSh0YXJnZXQsIHRleHQsIHJlbmRlclN0YXRlLCB0ZXh0RW1iZWRkZWQpIHtcbiAgICAgIGlmIChyZW5kZXJTdGF0ZS5nZW5lcmF0ZVN0YXRpY01hcmt1cClcbiAgICAgICAgcmV0dXJuIHRhcmdldC5wdXNoKGVzY2FwZVRleHRGb3JCcm93c2VyKHRleHQpKSwgITE7XG4gICAgICBcIlwiID09PSB0ZXh0XG4gICAgICAgID8gKHRhcmdldCA9IHRleHRFbWJlZGRlZClcbiAgICAgICAgOiAodGV4dEVtYmVkZGVkICYmIHRhcmdldC5wdXNoKFwiXFx4M2MhLS0gLS1cXHgzZVwiKSxcbiAgICAgICAgICB0YXJnZXQucHVzaChlc2NhcGVUZXh0Rm9yQnJvd3Nlcih0ZXh0KSksXG4gICAgICAgICAgKHRhcmdldCA9ICEwKSk7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoU2VnbWVudEZpbmFsZShcbiAgICAgIHRhcmdldCxcbiAgICAgIHJlbmRlclN0YXRlLFxuICAgICAgbGFzdFB1c2hlZFRleHQsXG4gICAgICB0ZXh0RW1iZWRkZWRcbiAgICApIHtcbiAgICAgIHJlbmRlclN0YXRlLmdlbmVyYXRlU3RhdGljTWFya3VwIHx8XG4gICAgICAgIChsYXN0UHVzaGVkVGV4dCAmJiB0ZXh0RW1iZWRkZWQgJiYgdGFyZ2V0LnB1c2goXCJcXHgzYyEtLSAtLVxceDNlXCIpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgICAgIGlmIChudWxsID09IHR5cGUpIHJldHVybiBudWxsO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHJldHVybiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFXG4gICAgICAgICAgPyBudWxsXG4gICAgICAgICAgOiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKSByZXR1cm4gdHlwZTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiRnJhZ21lbnRcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJQb3J0YWxcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlByb2ZpbGVyXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdHJpY3RNb2RlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZVwiO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZUxpc3RcIjtcbiAgICAgIH1cbiAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgc3dpdGNoIChcbiAgICAgICAgICAoXCJudW1iZXJcIiA9PT0gdHlwZW9mIHR5cGUudGFnICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgdHlwZS4kJHR5cGVvZilcbiAgICAgICAgKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKHR5cGUuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCIpICsgXCIuUHJvdmlkZXJcIjtcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlNVTUVSX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKHR5cGUuX2NvbnRleHQuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCIpICsgXCIuQ29uc3VtZXJcIjtcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICB2YXIgaW5uZXJUeXBlID0gdHlwZS5yZW5kZXI7XG4gICAgICAgICAgICB0eXBlID0gdHlwZS5kaXNwbGF5TmFtZTtcbiAgICAgICAgICAgIHR5cGUgfHxcbiAgICAgICAgICAgICAgKCh0eXBlID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8IFwiXCIpLFxuICAgICAgICAgICAgICAodHlwZSA9IFwiXCIgIT09IHR5cGUgPyBcIkZvcndhcmRSZWYoXCIgKyB0eXBlICsgXCIpXCIgOiBcIkZvcndhcmRSZWZcIikpO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAoaW5uZXJUeXBlID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsKSxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gaW5uZXJUeXBlXG4gICAgICAgICAgICAgICAgPyBpbm5lclR5cGVcbiAgICAgICAgICAgICAgICA6IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8IFwiTWVtb1wiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgaW5uZXJUeXBlID0gdHlwZS5fcGF5bG9hZDtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLl9pbml0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKGlubmVyVHlwZSkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvcFRvTmVhcmVzdENvbW1vbkFuY2VzdG9yKHByZXYsIG5leHQpIHtcbiAgICAgIGlmIChwcmV2ICE9PSBuZXh0KSB7XG4gICAgICAgIHByZXYuY29udGV4dC5fY3VycmVudFZhbHVlMiA9IHByZXYucGFyZW50VmFsdWU7XG4gICAgICAgIHByZXYgPSBwcmV2LnBhcmVudDtcbiAgICAgICAgdmFyIHBhcmVudE5leHQgPSBuZXh0LnBhcmVudDtcbiAgICAgICAgaWYgKG51bGwgPT09IHByZXYpIHtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gcGFyZW50TmV4dClcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICBcIlRoZSBzdGFja3MgbXVzdCByZWFjaCB0aGUgcm9vdCBhdCB0aGUgc2FtZSB0aW1lLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChudWxsID09PSBwYXJlbnROZXh0KVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgIFwiVGhlIHN0YWNrcyBtdXN0IHJlYWNoIHRoZSByb290IGF0IHRoZSBzYW1lIHRpbWUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgcG9wVG9OZWFyZXN0Q29tbW9uQW5jZXN0b3IocHJldiwgcGFyZW50TmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dC5jb250ZXh0Ll9jdXJyZW50VmFsdWUyID0gbmV4dC52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wQWxsUHJldmlvdXMocHJldikge1xuICAgICAgcHJldi5jb250ZXh0Ll9jdXJyZW50VmFsdWUyID0gcHJldi5wYXJlbnRWYWx1ZTtcbiAgICAgIHByZXYgPSBwcmV2LnBhcmVudDtcbiAgICAgIG51bGwgIT09IHByZXYgJiYgcG9wQWxsUHJldmlvdXMocHJldik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hBbGxOZXh0KG5leHQpIHtcbiAgICAgIHZhciBwYXJlbnROZXh0ID0gbmV4dC5wYXJlbnQ7XG4gICAgICBudWxsICE9PSBwYXJlbnROZXh0ICYmIHB1c2hBbGxOZXh0KHBhcmVudE5leHQpO1xuICAgICAgbmV4dC5jb250ZXh0Ll9jdXJyZW50VmFsdWUyID0gbmV4dC52YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wUHJldmlvdXNUb0NvbW1vbkxldmVsKHByZXYsIG5leHQpIHtcbiAgICAgIHByZXYuY29udGV4dC5fY3VycmVudFZhbHVlMiA9IHByZXYucGFyZW50VmFsdWU7XG4gICAgICBwcmV2ID0gcHJldi5wYXJlbnQ7XG4gICAgICBpZiAobnVsbCA9PT0gcHJldilcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJUaGUgZGVwdGggbXVzdCBlcXVhbCBhdCBsZWFzdCBhdCB6ZXJvIGJlZm9yZSByZWFjaGluZyB0aGUgcm9vdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICApO1xuICAgICAgcHJldi5kZXB0aCA9PT0gbmV4dC5kZXB0aFxuICAgICAgICA/IHBvcFRvTmVhcmVzdENvbW1vbkFuY2VzdG9yKHByZXYsIG5leHQpXG4gICAgICAgIDogcG9wUHJldmlvdXNUb0NvbW1vbkxldmVsKHByZXYsIG5leHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb3BOZXh0VG9Db21tb25MZXZlbChwcmV2LCBuZXh0KSB7XG4gICAgICB2YXIgcGFyZW50TmV4dCA9IG5leHQucGFyZW50O1xuICAgICAgaWYgKG51bGwgPT09IHBhcmVudE5leHQpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiVGhlIGRlcHRoIG11c3QgZXF1YWwgYXQgbGVhc3QgYXQgemVybyBiZWZvcmUgcmVhY2hpbmcgdGhlIHJvb3QuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgKTtcbiAgICAgIHByZXYuZGVwdGggPT09IHBhcmVudE5leHQuZGVwdGhcbiAgICAgICAgPyBwb3BUb05lYXJlc3RDb21tb25BbmNlc3RvcihwcmV2LCBwYXJlbnROZXh0KVxuICAgICAgICA6IHBvcE5leHRUb0NvbW1vbkxldmVsKHByZXYsIHBhcmVudE5leHQpO1xuICAgICAgbmV4dC5jb250ZXh0Ll9jdXJyZW50VmFsdWUyID0gbmV4dC52YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3dpdGNoQ29udGV4dChuZXdTbmFwc2hvdCkge1xuICAgICAgdmFyIHByZXYgPSBjdXJyZW50QWN0aXZlU25hcHNob3Q7XG4gICAgICBwcmV2ICE9PSBuZXdTbmFwc2hvdCAmJlxuICAgICAgICAobnVsbCA9PT0gcHJldlxuICAgICAgICAgID8gcHVzaEFsbE5leHQobmV3U25hcHNob3QpXG4gICAgICAgICAgOiBudWxsID09PSBuZXdTbmFwc2hvdFxuICAgICAgICAgICAgPyBwb3BBbGxQcmV2aW91cyhwcmV2KVxuICAgICAgICAgICAgOiBwcmV2LmRlcHRoID09PSBuZXdTbmFwc2hvdC5kZXB0aFxuICAgICAgICAgICAgICA/IHBvcFRvTmVhcmVzdENvbW1vbkFuY2VzdG9yKHByZXYsIG5ld1NuYXBzaG90KVxuICAgICAgICAgICAgICA6IHByZXYuZGVwdGggPiBuZXdTbmFwc2hvdC5kZXB0aFxuICAgICAgICAgICAgICAgID8gcG9wUHJldmlvdXNUb0NvbW1vbkxldmVsKHByZXYsIG5ld1NuYXBzaG90KVxuICAgICAgICAgICAgICAgIDogcG9wTmV4dFRvQ29tbW9uTGV2ZWwocHJldiwgbmV3U25hcHNob3QpLFxuICAgICAgICAoY3VycmVudEFjdGl2ZVNuYXBzaG90ID0gbmV3U25hcHNob3QpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgICBpZiAobnVsbCAhPT0gY2FsbGJhY2sgJiYgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGtleSA9IFN0cmluZyhjYWxsYmFjayk7XG4gICAgICAgIGRpZFdhcm5PbkludmFsaWRDYWxsYmFjay5oYXMoa2V5KSB8fFxuICAgICAgICAgIChkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2suYWRkKGtleSksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhIGZ1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy5cIixcbiAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgICAgKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gICAgICBwdWJsaWNJbnN0YW5jZSA9XG4gICAgICAgICgocHVibGljSW5zdGFuY2UgPSBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvcikgJiZcbiAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUocHVibGljSW5zdGFuY2UpKSB8fFxuICAgICAgICBcIlJlYWN0Q2xhc3NcIjtcbiAgICAgIHZhciB3YXJuaW5nS2V5ID0gcHVibGljSW5zdGFuY2UgKyBcIi5cIiArIGNhbGxlck5hbWU7XG4gICAgICBkaWRXYXJuQWJvdXROb29wVXBkYXRlRm9yQ29tcG9uZW50W3dhcm5pbmdLZXldIHx8XG4gICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiQ2FuIG9ubHkgdXBkYXRlIGEgbW91bnRpbmcgY29tcG9uZW50LiBUaGlzIHVzdWFsbHkgbWVhbnMgeW91IGNhbGxlZCAlcygpIG91dHNpZGUgY29tcG9uZW50V2lsbE1vdW50KCkgb24gdGhlIHNlcnZlci4gVGhpcyBpcyBhIG5vLW9wLlxcblxcblBsZWFzZSBjaGVjayB0aGUgY29kZSBmb3IgdGhlICVzIGNvbXBvbmVudC5cIixcbiAgICAgICAgICBjYWxsZXJOYW1lLFxuICAgICAgICAgIHB1YmxpY0luc3RhbmNlXG4gICAgICAgICksXG4gICAgICAgIChkaWRXYXJuQWJvdXROb29wVXBkYXRlRm9yQ29tcG9uZW50W3dhcm5pbmdLZXldID0gITApKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaFRyZWVDb250ZXh0KGJhc2VDb250ZXh0LCB0b3RhbENoaWxkcmVuLCBpbmRleCkge1xuICAgICAgdmFyIGJhc2VJZFdpdGhMZWFkaW5nQml0ID0gYmFzZUNvbnRleHQuaWQ7XG4gICAgICBiYXNlQ29udGV4dCA9IGJhc2VDb250ZXh0Lm92ZXJmbG93O1xuICAgICAgdmFyIGJhc2VMZW5ndGggPSAzMiAtIGNsejMyKGJhc2VJZFdpdGhMZWFkaW5nQml0KSAtIDE7XG4gICAgICBiYXNlSWRXaXRoTGVhZGluZ0JpdCAmPSB+KDEgPDwgYmFzZUxlbmd0aCk7XG4gICAgICBpbmRleCArPSAxO1xuICAgICAgdmFyIGxlbmd0aCA9IDMyIC0gY2x6MzIodG90YWxDaGlsZHJlbikgKyBiYXNlTGVuZ3RoO1xuICAgICAgaWYgKDMwIDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBudW1iZXJPZk92ZXJmbG93Qml0cyA9IGJhc2VMZW5ndGggLSAoYmFzZUxlbmd0aCAlIDUpO1xuICAgICAgICBsZW5ndGggPSAoXG4gICAgICAgICAgYmFzZUlkV2l0aExlYWRpbmdCaXQgJlxuICAgICAgICAgICgoMSA8PCBudW1iZXJPZk92ZXJmbG93Qml0cykgLSAxKVxuICAgICAgICApLnRvU3RyaW5nKDMyKTtcbiAgICAgICAgYmFzZUlkV2l0aExlYWRpbmdCaXQgPj49IG51bWJlck9mT3ZlcmZsb3dCaXRzO1xuICAgICAgICBiYXNlTGVuZ3RoIC09IG51bWJlck9mT3ZlcmZsb3dCaXRzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlkOlxuICAgICAgICAgICAgKDEgPDwgKDMyIC0gY2x6MzIodG90YWxDaGlsZHJlbikgKyBiYXNlTGVuZ3RoKSkgfFxuICAgICAgICAgICAgKGluZGV4IDw8IGJhc2VMZW5ndGgpIHxcbiAgICAgICAgICAgIGJhc2VJZFdpdGhMZWFkaW5nQml0LFxuICAgICAgICAgIG92ZXJmbG93OiBsZW5ndGggKyBiYXNlQ29udGV4dFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6ICgxIDw8IGxlbmd0aCkgfCAoaW5kZXggPDwgYmFzZUxlbmd0aCkgfCBiYXNlSWRXaXRoTGVhZGluZ0JpdCxcbiAgICAgICAgb3ZlcmZsb3c6IGJhc2VDb250ZXh0XG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbHozMkZhbGxiYWNrKHgpIHtcbiAgICAgIHggPj4+PSAwO1xuICAgICAgcmV0dXJuIDAgPT09IHggPyAzMiA6ICgzMSAtICgobG9nKHgpIC8gTE4yKSB8IDApKSB8IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vb3AkMigpIHt9XG4gICAgZnVuY3Rpb24gdHJhY2tVc2VkVGhlbmFibGUodGhlbmFibGVTdGF0ZSwgdGhlbmFibGUsIGluZGV4KSB7XG4gICAgICBpbmRleCA9IHRoZW5hYmxlU3RhdGVbaW5kZXhdO1xuICAgICAgdm9pZCAwID09PSBpbmRleFxuICAgICAgICA/IHRoZW5hYmxlU3RhdGUucHVzaCh0aGVuYWJsZSlcbiAgICAgICAgOiBpbmRleCAhPT0gdGhlbmFibGUgJiZcbiAgICAgICAgICAodGhlbmFibGUudGhlbihub29wJDIsIG5vb3AkMiksICh0aGVuYWJsZSA9IGluZGV4KSk7XG4gICAgICBzd2l0Y2ggKHRoZW5hYmxlLnN0YXR1cykge1xuICAgICAgICBjYXNlIFwiZnVsZmlsbGVkXCI6XG4gICAgICAgICAgcmV0dXJuIHRoZW5hYmxlLnZhbHVlO1xuICAgICAgICBjYXNlIFwicmVqZWN0ZWRcIjpcbiAgICAgICAgICB0aHJvdyB0aGVuYWJsZS5yZWFzb247XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHRoZW5hYmxlLnN0YXR1c1xuICAgICAgICAgICAgPyB0aGVuYWJsZS50aGVuKG5vb3AkMiwgbm9vcCQyKVxuICAgICAgICAgICAgOiAoKHRoZW5hYmxlU3RhdGUgPSB0aGVuYWJsZSksXG4gICAgICAgICAgICAgICh0aGVuYWJsZVN0YXRlLnN0YXR1cyA9IFwicGVuZGluZ1wiKSxcbiAgICAgICAgICAgICAgdGhlbmFibGVTdGF0ZS50aGVuKFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChmdWxmaWxsZWRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKFwicGVuZGluZ1wiID09PSB0aGVuYWJsZS5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZ1bGZpbGxlZFRoZW5hYmxlID0gdGhlbmFibGU7XG4gICAgICAgICAgICAgICAgICAgIGZ1bGZpbGxlZFRoZW5hYmxlLnN0YXR1cyA9IFwiZnVsZmlsbGVkXCI7XG4gICAgICAgICAgICAgICAgICAgIGZ1bGZpbGxlZFRoZW5hYmxlLnZhbHVlID0gZnVsZmlsbGVkVmFsdWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChcInBlbmRpbmdcIiA9PT0gdGhlbmFibGUuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWplY3RlZFRoZW5hYmxlID0gdGhlbmFibGU7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdGVkVGhlbmFibGUuc3RhdHVzID0gXCJyZWplY3RlZFwiO1xuICAgICAgICAgICAgICAgICAgICByZWplY3RlZFRoZW5hYmxlLnJlYXNvbiA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgc3dpdGNoICh0aGVuYWJsZS5zdGF0dXMpIHtcbiAgICAgICAgICAgIGNhc2UgXCJmdWxmaWxsZWRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIHRoZW5hYmxlLnZhbHVlO1xuICAgICAgICAgICAgY2FzZSBcInJlamVjdGVkXCI6XG4gICAgICAgICAgICAgIHRocm93IHRoZW5hYmxlLnJlYXNvbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3VzcGVuZGVkVGhlbmFibGUgPSB0aGVuYWJsZTtcbiAgICAgICAgICB0aHJvdyBTdXNwZW5zZUV4Y2VwdGlvbjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0U3VzcGVuZGVkVGhlbmFibGUoKSB7XG4gICAgICBpZiAobnVsbCA9PT0gc3VzcGVuZGVkVGhlbmFibGUpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiRXhwZWN0ZWQgYSBzdXNwZW5kZWQgdGhlbmFibGUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICk7XG4gICAgICB2YXIgdGhlbmFibGUgPSBzdXNwZW5kZWRUaGVuYWJsZTtcbiAgICAgIHN1c3BlbmRlZFRoZW5hYmxlID0gbnVsbDtcbiAgICAgIHJldHVybiB0aGVuYWJsZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXMoeCwgeSkge1xuICAgICAgcmV0dXJuICh4ID09PSB5ICYmICgwICE9PSB4IHx8IDEgLyB4ID09PSAxIC8geSkpIHx8ICh4ICE9PSB4ICYmIHkgIT09IHkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCkge1xuICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudClcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJJbnZhbGlkIGhvb2sgY2FsbC4gSG9va3MgY2FuIG9ubHkgYmUgY2FsbGVkIGluc2lkZSBvZiB0aGUgYm9keSBvZiBhIGZ1bmN0aW9uIGNvbXBvbmVudC4gVGhpcyBjb3VsZCBoYXBwZW4gZm9yIG9uZSBvZiB0aGUgZm9sbG93aW5nIHJlYXNvbnM6XFxuMS4gWW91IG1pZ2h0IGhhdmUgbWlzbWF0Y2hpbmcgdmVyc2lvbnMgb2YgUmVhY3QgYW5kIHRoZSByZW5kZXJlciAoc3VjaCBhcyBSZWFjdCBET00pXFxuMi4gWW91IG1pZ2h0IGJlIGJyZWFraW5nIHRoZSBSdWxlcyBvZiBIb29rc1xcbjMuIFlvdSBtaWdodCBoYXZlIG1vcmUgdGhhbiBvbmUgY29weSBvZiBSZWFjdCBpbiB0aGUgc2FtZSBhcHBcXG5TZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9pbnZhbGlkLWhvb2stY2FsbCBmb3IgdGlwcyBhYm91dCBob3cgdG8gZGVidWcgYW5kIGZpeCB0aGlzIHByb2JsZW0uXCJcbiAgICAgICAgKTtcbiAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiRG8gbm90IGNhbGwgSG9va3MgaW5zaWRlIHVzZUVmZmVjdCguLi4pLCB1c2VNZW1vKC4uLiksIG9yIG90aGVyIGJ1aWx0LWluIEhvb2tzLiBZb3UgY2FuIG9ubHkgY2FsbCBIb29rcyBhdCB0aGUgdG9wIGxldmVsIG9mIHlvdXIgUmVhY3QgZnVuY3Rpb24uIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9ydWxlcy1vZi1ob29rc1wiXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVIb29rKCkge1xuICAgICAgaWYgKDAgPCBudW1iZXJPZlJlUmVuZGVycylcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJSZW5kZXJlZCBtb3JlIGhvb2tzIHRoYW4gZHVyaW5nIHRoZSBwcmV2aW91cyByZW5kZXJcIik7XG4gICAgICByZXR1cm4geyBtZW1vaXplZFN0YXRlOiBudWxsLCBxdWV1ZTogbnVsbCwgbmV4dDogbnVsbCB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKSB7XG4gICAgICBudWxsID09PSB3b3JrSW5Qcm9ncmVzc0hvb2tcbiAgICAgICAgPyBudWxsID09PSBmaXJzdFdvcmtJblByb2dyZXNzSG9va1xuICAgICAgICAgID8gKChpc1JlUmVuZGVyID0gITEpLFxuICAgICAgICAgICAgKGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rID0gY3JlYXRlSG9vaygpKSlcbiAgICAgICAgICA6ICgoaXNSZVJlbmRlciA9ICEwKSwgKHdvcmtJblByb2dyZXNzSG9vayA9IGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rKSlcbiAgICAgICAgOiBudWxsID09PSB3b3JrSW5Qcm9ncmVzc0hvb2submV4dFxuICAgICAgICAgID8gKChpc1JlUmVuZGVyID0gITEpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0ID0gY3JlYXRlSG9vaygpKSlcbiAgICAgICAgICA6ICgoaXNSZVJlbmRlciA9ICEwKSwgKHdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0KSk7XG4gICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3NIb29rO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRUaGVuYWJsZVN0YXRlQWZ0ZXJTdXNwZW5kaW5nKCkge1xuICAgICAgdmFyIHN0YXRlID0gdGhlbmFibGVTdGF0ZTtcbiAgICAgIHRoZW5hYmxlU3RhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNldEhvb2tzU3RhdGUoKSB7XG4gICAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSAhMTtcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0tleVBhdGggPVxuICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdSZXF1ZXN0ID1cbiAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nVGFzayA9XG4gICAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCA9XG4gICAgICAgICAgbnVsbDtcbiAgICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSAhMTtcbiAgICAgIGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcbiAgICAgIG51bWJlck9mUmVSZW5kZXJzID0gMDtcbiAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9IHJlbmRlclBoYXNlVXBkYXRlcyA9IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlYWRDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiQ29udGV4dCBjYW4gb25seSBiZSByZWFkIHdoaWxlIFJlYWN0IGlzIHJlbmRlcmluZy4gSW4gY2xhc3NlcywgeW91IGNhbiByZWFkIGl0IGluIHRoZSByZW5kZXIgbWV0aG9kIG9yIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4gSW4gZnVuY3Rpb24gY29tcG9uZW50cywgeW91IGNhbiByZWFkIGl0IGRpcmVjdGx5IGluIHRoZSBmdW5jdGlvbiBib2R5LCBidXQgbm90IGluc2lkZSBIb29rcyBsaWtlIHVzZVJlZHVjZXIoKSBvciB1c2VNZW1vKCkuXCJcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiBjb250ZXh0Ll9jdXJyZW50VmFsdWUyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBiYXNpY1N0YXRlUmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgICByZXR1cm4gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgYWN0aW9uID8gYWN0aW9uKHN0YXRlKSA6IGFjdGlvbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICByZWR1Y2VyICE9PSBiYXNpY1N0YXRlUmVkdWNlciAmJiAoY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVJlZHVjZXJcIik7XG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPSByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gICAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIGlmIChpc1JlUmVuZGVyKSB7XG4gICAgICAgIGluaXQgPSB3b3JrSW5Qcm9ncmVzc0hvb2sucXVldWU7XG4gICAgICAgIGluaXRpYWxBcmcgPSBpbml0LmRpc3BhdGNoO1xuICAgICAgICBpZiAobnVsbCAhPT0gcmVuZGVyUGhhc2VVcGRhdGVzKSB7XG4gICAgICAgICAgdmFyIGZpcnN0UmVuZGVyUGhhc2VVcGRhdGUgPSByZW5kZXJQaGFzZVVwZGF0ZXMuZ2V0KGluaXQpO1xuICAgICAgICAgIGlmICh2b2lkIDAgIT09IGZpcnN0UmVuZGVyUGhhc2VVcGRhdGUpIHtcbiAgICAgICAgICAgIHJlbmRlclBoYXNlVXBkYXRlcy5kZWxldGUoaW5pdCk7XG4gICAgICAgICAgICBpbml0ID0gd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHZhciBhY3Rpb24gPSBmaXJzdFJlbmRlclBoYXNlVXBkYXRlLmFjdGlvbjtcbiAgICAgICAgICAgICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gITA7XG4gICAgICAgICAgICAgIGluaXQgPSByZWR1Y2VyKGluaXQsIGFjdGlvbik7XG4gICAgICAgICAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9ICExO1xuICAgICAgICAgICAgICBmaXJzdFJlbmRlclBoYXNlVXBkYXRlID0gZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZS5uZXh0O1xuICAgICAgICAgICAgfSB3aGlsZSAobnVsbCAhPT0gZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSk7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSA9IGluaXQ7XG4gICAgICAgICAgICByZXR1cm4gW2luaXQsIGluaXRpYWxBcmddO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3dvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlLCBpbml0aWFsQXJnXTtcbiAgICAgIH1cbiAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9ICEwO1xuICAgICAgcmVkdWNlciA9XG4gICAgICAgIHJlZHVjZXIgPT09IGJhc2ljU3RhdGVSZWR1Y2VyXG4gICAgICAgICAgPyBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbml0aWFsQXJnXG4gICAgICAgICAgICA/IGluaXRpYWxBcmcoKVxuICAgICAgICAgICAgOiBpbml0aWFsQXJnXG4gICAgICAgICAgOiB2b2lkIDAgIT09IGluaXRcbiAgICAgICAgICAgID8gaW5pdChpbml0aWFsQXJnKVxuICAgICAgICAgICAgOiBpbml0aWFsQXJnO1xuICAgICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gITE7XG4gICAgICB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSA9IHJlZHVjZXI7XG4gICAgICByZWR1Y2VyID0gd29ya0luUHJvZ3Jlc3NIb29rLnF1ZXVlID0geyBsYXN0OiBudWxsLCBkaXNwYXRjaDogbnVsbCB9O1xuICAgICAgcmVkdWNlciA9IHJlZHVjZXIuZGlzcGF0Y2ggPSBkaXNwYXRjaEFjdGlvbi5iaW5kKFxuICAgICAgICBudWxsLFxuICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQsXG4gICAgICAgIHJlZHVjZXJcbiAgICAgICk7XG4gICAgICByZXR1cm4gW3dvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlLCByZWR1Y2VyXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXNlTWVtbyhuZXh0Q3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPSByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gICAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIGRlcHMgPSB2b2lkIDAgPT09IGRlcHMgPyBudWxsIDogZGVwcztcbiAgICAgIGlmIChudWxsICE9PSB3b3JrSW5Qcm9ncmVzc0hvb2spIHtcbiAgICAgICAgdmFyIHByZXZTdGF0ZSA9IHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlO1xuICAgICAgICBpZiAobnVsbCAhPT0gcHJldlN0YXRlICYmIG51bGwgIT09IGRlcHMpIHtcbiAgICAgICAgICBhOiB7XG4gICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gcHJldlN0YXRlWzFdO1xuICAgICAgICAgICAgaWYgKG51bGwgPT09IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdClcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIiVzIHJlY2VpdmVkIGEgZmluYWwgYXJndW1lbnQgZHVyaW5nIHRoaXMgcmVuZGVyLCBidXQgbm90IGR1cmluZyB0aGUgcHJldmlvdXMgcmVuZGVyLiBFdmVuIHRob3VnaCB0aGUgZmluYWwgYXJndW1lbnQgaXMgb3B0aW9uYWwsIGl0cyB0eXBlIGNhbm5vdCBjaGFuZ2UgYmV0d2VlbiByZW5kZXJzLlwiLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2XG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICExKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBkZXBzLmxlbmd0aCAhPT0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0Lmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlRoZSBmaW5hbCBhcmd1bWVudCBwYXNzZWQgdG8gJXMgY2hhbmdlZCBzaXplIGJldHdlZW4gcmVuZGVycy4gVGhlIG9yZGVyIGFuZCBzaXplIG9mIHRoaXMgYXJyYXkgbXVzdCByZW1haW4gY29uc3RhbnQuXFxuXFxuUHJldmlvdXM6ICVzXFxuSW5jb21pbmc6ICVzXCIsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldixcbiAgICAgICAgICAgICAgICAgIFwiW1wiICsgZGVwcy5qb2luKFwiLCBcIikgKyBcIl1cIixcbiAgICAgICAgICAgICAgICAgIFwiW1wiICsgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LmpvaW4oXCIsIFwiKSArIFwiXVwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICAgICAgaSA8IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdC5sZW5ndGggJiYgaSA8IGRlcHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGkrK1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgaWYgKCFvYmplY3RJcyhkZXBzW2ldLCBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHRbaV0pKSB7XG4gICAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCkgcmV0dXJuIHByZXZTdGF0ZVswXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gITA7XG4gICAgICBuZXh0Q3JlYXRlID0gbmV4dENyZWF0ZSgpO1xuICAgICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gITE7XG4gICAgICB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSA9IFtuZXh0Q3JlYXRlLCBkZXBzXTtcbiAgICAgIHJldHVybiBuZXh0Q3JlYXRlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNwYXRjaEFjdGlvbihjb21wb25lbnRJZGVudGl0eSwgcXVldWUsIGFjdGlvbikge1xuICAgICAgaWYgKDI1IDw9IG51bWJlck9mUmVSZW5kZXJzKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIlRvbyBtYW55IHJlLXJlbmRlcnMuIFJlYWN0IGxpbWl0cyB0aGUgbnVtYmVyIG9mIHJlbmRlcnMgdG8gcHJldmVudCBhbiBpbmZpbml0ZSBsb29wLlwiXG4gICAgICAgICk7XG4gICAgICBpZiAoY29tcG9uZW50SWRlbnRpdHkgPT09IGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudClcbiAgICAgICAgaWYgKFxuICAgICAgICAgICgoZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9ICEwKSxcbiAgICAgICAgICAoY29tcG9uZW50SWRlbnRpdHkgPSB7IGFjdGlvbjogYWN0aW9uLCBuZXh0OiBudWxsIH0pLFxuICAgICAgICAgIG51bGwgPT09IHJlbmRlclBoYXNlVXBkYXRlcyAmJiAocmVuZGVyUGhhc2VVcGRhdGVzID0gbmV3IE1hcCgpKSxcbiAgICAgICAgICAoYWN0aW9uID0gcmVuZGVyUGhhc2VVcGRhdGVzLmdldChxdWV1ZSkpLFxuICAgICAgICAgIHZvaWQgMCA9PT0gYWN0aW9uKVxuICAgICAgICApXG4gICAgICAgICAgcmVuZGVyUGhhc2VVcGRhdGVzLnNldChxdWV1ZSwgY29tcG9uZW50SWRlbnRpdHkpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBmb3IgKHF1ZXVlID0gYWN0aW9uOyBudWxsICE9PSBxdWV1ZS5uZXh0OyApIHF1ZXVlID0gcXVldWUubmV4dDtcbiAgICAgICAgICBxdWV1ZS5uZXh0ID0gY29tcG9uZW50SWRlbnRpdHk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdW5zdXBwb3J0ZWRTdGFydFRyYW5zaXRpb24oKSB7XG4gICAgICB0aHJvdyBFcnJvcihcInN0YXJ0VHJhbnNpdGlvbiBjYW5ub3QgYmUgY2FsbGVkIGR1cmluZyBzZXJ2ZXIgcmVuZGVyaW5nLlwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdW5zdXBwb3J0ZWRTZXRPcHRpbWlzdGljU3RhdGUoKSB7XG4gICAgICB0aHJvdyBFcnJvcihcIkNhbm5vdCB1cGRhdGUgb3B0aW1pc3RpYyBzdGF0ZSB3aGlsZSByZW5kZXJpbmcuXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1c2VBY3Rpb25TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSwgcGVybWFsaW5rKSB7XG4gICAgICByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gICAgICB2YXIgYWN0aW9uU3RhdGVIb29rSW5kZXggPSBhY3Rpb25TdGF0ZUNvdW50ZXIrKyxcbiAgICAgICAgcmVxdWVzdCA9IGN1cnJlbnRseVJlbmRlcmluZ1JlcXVlc3Q7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgYWN0aW9uLiQkRk9STV9BQ1RJT04pIHtcbiAgICAgICAgdmFyIG5leHRQb3N0YmFja1N0YXRlS2V5ID0gbnVsbCxcbiAgICAgICAgICBjb21wb25lbnRLZXlQYXRoID0gY3VycmVudGx5UmVuZGVyaW5nS2V5UGF0aDtcbiAgICAgICAgcmVxdWVzdCA9IHJlcXVlc3QuZm9ybVN0YXRlO1xuICAgICAgICB2YXIgaXNTaWduYXR1cmVFcXVhbCA9IGFjdGlvbi4kJElTX1NJR05BVFVSRV9FUVVBTDtcbiAgICAgICAgaWYgKG51bGwgIT09IHJlcXVlc3QgJiYgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaXNTaWduYXR1cmVFcXVhbCkge1xuICAgICAgICAgIHZhciBwb3N0YmFja0tleSA9IHJlcXVlc3RbMV07XG4gICAgICAgICAgaXNTaWduYXR1cmVFcXVhbC5jYWxsKGFjdGlvbiwgcmVxdWVzdFsyXSwgcmVxdWVzdFszXSkgJiZcbiAgICAgICAgICAgICgobmV4dFBvc3RiYWNrU3RhdGVLZXkgPVxuICAgICAgICAgICAgICB2b2lkIDAgIT09IHBlcm1hbGlua1xuICAgICAgICAgICAgICAgID8gXCJwXCIgKyBwZXJtYWxpbmtcbiAgICAgICAgICAgICAgICA6IFwia1wiICtcbiAgICAgICAgICAgICAgICAgIG11cm11cmhhc2gzXzMyX2djKFxuICAgICAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShbXG4gICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50S2V5UGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgIGFjdGlvblN0YXRlSG9va0luZGV4XG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgIHBvc3RiYWNrS2V5ID09PSBuZXh0UG9zdGJhY2tTdGF0ZUtleSAmJlxuICAgICAgICAgICAgICAoKGFjdGlvblN0YXRlTWF0Y2hpbmdJbmRleCA9IGFjdGlvblN0YXRlSG9va0luZGV4KSxcbiAgICAgICAgICAgICAgKGluaXRpYWxTdGF0ZSA9IHJlcXVlc3RbMF0pKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJvdW5kQWN0aW9uID0gYWN0aW9uLmJpbmQobnVsbCwgaW5pdGlhbFN0YXRlKTtcbiAgICAgICAgYWN0aW9uID0gZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgICBib3VuZEFjdGlvbihwYXlsb2FkKTtcbiAgICAgICAgfTtcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgYm91bmRBY3Rpb24uJCRGT1JNX0FDVElPTiAmJlxuICAgICAgICAgIChhY3Rpb24uJCRGT1JNX0FDVElPTiA9IGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICAgICAgICAgIHByZWZpeCA9IGJvdW5kQWN0aW9uLiQkRk9STV9BQ1RJT04ocHJlZml4KTtcbiAgICAgICAgICAgIHZvaWQgMCAhPT0gcGVybWFsaW5rICYmXG4gICAgICAgICAgICAgIChjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHBlcm1hbGluaywgXCJ0YXJnZXRcIiksXG4gICAgICAgICAgICAgIChwZXJtYWxpbmsgKz0gXCJcIiksXG4gICAgICAgICAgICAgIChwcmVmaXguYWN0aW9uID0gcGVybWFsaW5rKSk7XG4gICAgICAgICAgICB2YXIgZm9ybURhdGEgPSBwcmVmaXguZGF0YTtcbiAgICAgICAgICAgIGZvcm1EYXRhICYmXG4gICAgICAgICAgICAgIChudWxsID09PSBuZXh0UG9zdGJhY2tTdGF0ZUtleSAmJlxuICAgICAgICAgICAgICAgIChuZXh0UG9zdGJhY2tTdGF0ZUtleSA9XG4gICAgICAgICAgICAgICAgICB2b2lkIDAgIT09IHBlcm1hbGlua1xuICAgICAgICAgICAgICAgICAgICA/IFwicFwiICsgcGVybWFsaW5rXG4gICAgICAgICAgICAgICAgICAgIDogXCJrXCIgK1xuICAgICAgICAgICAgICAgICAgICAgIG11cm11cmhhc2gzXzMyX2djKFxuICAgICAgICAgICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoW1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRLZXlQYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25TdGF0ZUhvb2tJbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChcIiRBQ1RJT05fS0VZXCIsIG5leHRQb3N0YmFja1N0YXRlS2V5KSk7XG4gICAgICAgICAgICByZXR1cm4gcHJlZml4O1xuICAgICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gW2luaXRpYWxTdGF0ZSwgYWN0aW9uLCAhMV07XG4gICAgICB9XG4gICAgICB2YXIgX2JvdW5kQWN0aW9uID0gYWN0aW9uLmJpbmQobnVsbCwgaW5pdGlhbFN0YXRlKTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIGluaXRpYWxTdGF0ZSxcbiAgICAgICAgZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgICBfYm91bmRBY3Rpb24ocGF5bG9hZCk7XG4gICAgICAgIH0sXG4gICAgICAgICExXG4gICAgICBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1bndyYXBUaGVuYWJsZSh0aGVuYWJsZSkge1xuICAgICAgdmFyIGluZGV4ID0gdGhlbmFibGVJbmRleENvdW50ZXI7XG4gICAgICB0aGVuYWJsZUluZGV4Q291bnRlciArPSAxO1xuICAgICAgbnVsbCA9PT0gdGhlbmFibGVTdGF0ZSAmJiAodGhlbmFibGVTdGF0ZSA9IFtdKTtcbiAgICAgIHJldHVybiB0cmFja1VzZWRUaGVuYWJsZSh0aGVuYWJsZVN0YXRlLCB0aGVuYWJsZSwgaW5kZXgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1bnN1cHBvcnRlZFJlZnJlc2goKSB7XG4gICAgICB0aHJvdyBFcnJvcihcIkNhY2hlIGNhbm5vdCBiZSByZWZyZXNoZWQgZHVyaW5nIHNlcnZlciByZW5kZXJpbmcuXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub29wJDEoKSB7fVxuICAgIGZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cbiAgICBmdW5jdGlvbiBkaXNhYmxlTG9ncygpIHtcbiAgICAgIGlmICgwID09PSBkaXNhYmxlZERlcHRoKSB7XG4gICAgICAgIHByZXZMb2cgPSBjb25zb2xlLmxvZztcbiAgICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgICBwcmV2RXJyb3IgPSBjb25zb2xlLmVycm9yO1xuICAgICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgICBwcmV2R3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kO1xuICAgICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICB2YWx1ZTogZGlzYWJsZWRMb2csXG4gICAgICAgICAgd3JpdGFibGU6ICEwXG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGRpc2FibGVkRGVwdGgrKztcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICAgICAgZGlzYWJsZWREZXB0aC0tO1xuICAgICAgaWYgKDAgPT09IGRpc2FibGVkRGVwdGgpIHtcbiAgICAgICAgdmFyIHByb3BzID0geyBjb25maWd1cmFibGU6ICEwLCBlbnVtZXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZMb2cgfSksXG4gICAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkluZm8gfSksXG4gICAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldldhcm4gfSksXG4gICAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZFcnJvciB9KSxcbiAgICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkdyb3VwIH0pLFxuICAgICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWQgfSksXG4gICAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZHcm91cEVuZCB9KVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIDAgPiBkaXNhYmxlZERlcHRoICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkge1xuICAgICAgaWYgKHZvaWQgMCA9PT0gcHJlZml4KVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICAgIHByZWZpeCA9IChtYXRjaCAmJiBtYXRjaFsxXSkgfHwgXCJcIjtcbiAgICAgICAgICBzdWZmaXggPVxuICAgICAgICAgICAgLTEgPCB4LnN0YWNrLmluZGV4T2YoXCJcXG4gICAgYXRcIilcbiAgICAgICAgICAgICAgPyBcIiAoPGFub255bW91cz4pXCJcbiAgICAgICAgICAgICAgOiAtMSA8IHguc3RhY2suaW5kZXhPZihcIkBcIilcbiAgICAgICAgICAgICAgICA/IFwiQHVua25vd246MDowXCJcbiAgICAgICAgICAgICAgICA6IFwiXCI7XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBcIlxcblwiICsgcHJlZml4ICsgbmFtZSArIHN1ZmZpeDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XG4gICAgICBpZiAoIWZuIHx8IHJlZW50cnkpIHJldHVybiBcIlwiO1xuICAgICAgdmFyIGZyYW1lID0gY29tcG9uZW50RnJhbWVDYWNoZS5nZXQoZm4pO1xuICAgICAgaWYgKHZvaWQgMCAhPT0gZnJhbWUpIHJldHVybiBmcmFtZTtcbiAgICAgIHJlZW50cnkgPSAhMDtcbiAgICAgIGZyYW1lID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7XG4gICAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHZvaWQgMDtcbiAgICAgIHZhciBwcmV2aW91c0Rpc3BhdGNoZXIgPSBudWxsO1xuICAgICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBudWxsO1xuICAgICAgZGlzYWJsZUxvZ3MoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBSdW5JblJvb3RGcmFtZSA9IHtcbiAgICAgICAgICBEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsIFwicHJvcHNcIiwge1xuICAgICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBSZWZsZWN0ICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250cm9sID0geDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoeCQwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2wgPSB4JDA7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoeCQxKSB7XG4gICAgICAgICAgICAgICAgICBjb250cm9sID0geCQxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAoRmFrZSA9IGZuKCkpICYmXG4gICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBGYWtlLmNhdGNoICYmXG4gICAgICAgICAgICAgICAgICBGYWtlLmNhdGNoKGZ1bmN0aW9uICgpIHt9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgICAgICAgICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiBcInN0cmluZ1wiID09PSB0eXBlb2Ygc2FtcGxlLnN0YWNrKVxuICAgICAgICAgICAgICAgIHJldHVybiBbc2FtcGxlLnN0YWNrLCBjb250cm9sLnN0YWNrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QuZGlzcGxheU5hbWUgPVxuICAgICAgICAgIFwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290XCI7XG4gICAgICAgIHZhciBuYW1lUHJvcERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFxuICAgICAgICAgIFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCxcbiAgICAgICAgICBcIm5hbWVcIlxuICAgICAgICApO1xuICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IgJiZcbiAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IuY29uZmlndXJhYmxlICYmXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICAgICAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LFxuICAgICAgICAgICAgXCJuYW1lXCIsXG4gICAgICAgICAgICB7IHZhbHVlOiBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiIH1cbiAgICAgICAgICApO1xuICAgICAgICB2YXIgX1J1bkluUm9vdEZyYW1lJERldGVyID1cbiAgICAgICAgICAgIFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCgpLFxuICAgICAgICAgIHNhbXBsZVN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzBdLFxuICAgICAgICAgIGNvbnRyb2xTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclsxXTtcbiAgICAgICAgaWYgKHNhbXBsZVN0YWNrICYmIGNvbnRyb2xTdGFjaykge1xuICAgICAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZVN0YWNrLnNwbGl0KFwiXFxuXCIpLFxuICAgICAgICAgICAgY29udHJvbExpbmVzID0gY29udHJvbFN0YWNrLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPSBuYW1lUHJvcERlc2NyaXB0b3IgPSAwO1xuICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yIDwgc2FtcGxlTGluZXMubGVuZ3RoICYmXG4gICAgICAgICAgICAhc2FtcGxlTGluZXNbbmFtZVByb3BEZXNjcmlwdG9yXS5pbmNsdWRlcyhcbiAgICAgICAgICAgICAgXCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3RcIlxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgIClcbiAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvcisrO1xuICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICA7XG4gICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPCBjb250cm9sTGluZXMubGVuZ3RoICYmXG4gICAgICAgICAgICAhY29udHJvbExpbmVzW19SdW5JblJvb3RGcmFtZSREZXRlcl0uaW5jbHVkZXMoXG4gICAgICAgICAgICAgIFwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290XCJcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICApXG4gICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXIrKztcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IgPT09IHNhbXBsZUxpbmVzLmxlbmd0aCB8fFxuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyID09PSBjb250cm9sTGluZXMubGVuZ3RoXG4gICAgICAgICAgKVxuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgMSA8PSBuYW1lUHJvcERlc2NyaXB0b3IgJiZcbiAgICAgICAgICAgICAgMCA8PSBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgJiZcbiAgICAgICAgICAgICAgc2FtcGxlTGluZXNbbmFtZVByb3BEZXNjcmlwdG9yXSAhPT1cbiAgICAgICAgICAgICAgICBjb250cm9sTGluZXNbX1J1bkluUm9vdEZyYW1lJERldGVyXTtcblxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXItLTtcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgMSA8PSBuYW1lUHJvcERlc2NyaXB0b3IgJiYgMCA8PSBfUnVuSW5Sb290RnJhbWUkRGV0ZXI7XG4gICAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3ItLSwgX1J1bkluUm9vdEZyYW1lJERldGVyLS1cbiAgICAgICAgICApXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0gIT09XG4gICAgICAgICAgICAgIGNvbnRyb2xMaW5lc1tfUnVuSW5Sb290RnJhbWUkRGV0ZXJdXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgaWYgKDEgIT09IG5hbWVQcm9wRGVzY3JpcHRvciB8fCAxICE9PSBfUnVuSW5Sb290RnJhbWUkRGV0ZXIpIHtcbiAgICAgICAgICAgICAgICBkb1xuICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAobmFtZVByb3BEZXNjcmlwdG9yLS0sXG4gICAgICAgICAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlci0tLFxuICAgICAgICAgICAgICAgICAgICAwID4gX1J1bkluUm9vdEZyYW1lJERldGVyIHx8XG4gICAgICAgICAgICAgICAgICAgICAgc2FtcGxlTGluZXNbbmFtZVByb3BEZXNjcmlwdG9yXSAhPT1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xMaW5lc1tfUnVuSW5Sb290RnJhbWUkRGV0ZXJdKVxuICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPVxuICAgICAgICAgICAgICAgICAgICAgIFwiXFxuXCIgK1xuICAgICAgICAgICAgICAgICAgICAgIHNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0ucmVwbGFjZShcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiIGF0IG5ldyBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiIGF0IFwiXG4gICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgZm4uZGlzcGxheU5hbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICBfZnJhbWUuaW5jbHVkZXMoXCI8YW5vbnltb3VzPlwiKSAmJlxuICAgICAgICAgICAgICAgICAgICAgIChfZnJhbWUgPSBfZnJhbWUucmVwbGFjZShcIjxhbm9ueW1vdXM+XCIsIGZuLmRpc3BsYXlOYW1lKSk7XG4gICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGZuICYmXG4gICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKDEgPD0gbmFtZVByb3BEZXNjcmlwdG9yICYmIDAgPD0gX1J1bkluUm9vdEZyYW1lJERldGVyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgKHJlZW50cnkgPSAhMSksXG4gICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2aW91c0Rpc3BhdGNoZXIpLFxuICAgICAgICAgIHJlZW5hYmxlTG9ncygpLFxuICAgICAgICAgIChFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IGZyYW1lKTtcbiAgICAgIH1cbiAgICAgIHNhbXBsZUxpbmVzID0gKHNhbXBsZUxpbmVzID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogXCJcIilcbiAgICAgICAgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShzYW1wbGVMaW5lcylcbiAgICAgICAgOiBcIlwiO1xuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZm4gJiYgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHNhbXBsZUxpbmVzKTtcbiAgICAgIHJldHVybiBzYW1wbGVMaW5lcztcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVDb21wb25lbnRTdGFja0J5VHlwZSh0eXBlKSB7XG4gICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGUpIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSh0eXBlKTtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICByZXR1cm4gdHlwZS5wcm90b3R5cGUgJiYgdHlwZS5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudFxuICAgICAgICAgID8gKCh0eXBlID0gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCAhMCkpLCB0eXBlKVxuICAgICAgICAgIDogZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCAhMSk7XG4gICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUgJiYgbnVsbCAhPT0gdHlwZSkge1xuICAgICAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLnJlbmRlciwgITEpO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZS50eXBlLCAhMSk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGUsXG4gICAgICAgICAgICAgIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgICAgbGF6eUNvbXBvbmVudCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB0eXBlID0gbGF6eUNvbXBvbmVudChwYXlsb2FkKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKFwiTGF6eVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZUNvbXBvbmVudFN0YWNrQnlUeXBlKHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZS5uYW1lKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAocGF5bG9hZCA9IHR5cGUuZW52KSxcbiAgICAgICAgICAgIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKFxuICAgICAgICAgICAgICB0eXBlLm5hbWUgKyAocGF5bG9hZCA/IFwiIFtcIiArIHBheWxvYWQgKyBcIl1cIiA6IFwiXCIpXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoXCJTdXNwZW5zZUxpc3RcIik7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoXCJTdXNwZW5zZVwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRTdGFja0J5Q29tcG9uZW50U3RhY2tOb2RlKGNvbXBvbmVudFN0YWNrKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgaW5mbyA9IFwiXCI7XG4gICAgICAgIGRvXG4gICAgICAgICAgKGluZm8gKz0gZGVzY3JpYmVDb21wb25lbnRTdGFja0J5VHlwZShjb21wb25lbnRTdGFjay50eXBlKSksXG4gICAgICAgICAgICAoY29tcG9uZW50U3RhY2sgPSBjb21wb25lbnRTdGFjay5wYXJlbnQpO1xuICAgICAgICB3aGlsZSAoY29tcG9uZW50U3RhY2spO1xuICAgICAgICByZXR1cm4gaW5mbztcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgcmV0dXJuIFwiXFxuRXJyb3IgZ2VuZXJhdGluZyBzdGFjazogXCIgKyB4Lm1lc3NhZ2UgKyBcIlxcblwiICsgeC5zdGFjaztcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZGVmYXVsdEVycm9ySGFuZGxlcihlcnJvcikge1xuICAgICAgaWYgKFxuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgZXJyb3IgJiZcbiAgICAgICAgbnVsbCAhPT0gZXJyb3IgJiZcbiAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGVycm9yLmVudmlyb25tZW50TmFtZVxuICAgICAgKSB7XG4gICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBlcnJvci5lbnZpcm9ubWVudE5hbWU7XG4gICAgICAgIGVycm9yID0gW2Vycm9yXS5zbGljZSgwKTtcbiAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGVycm9yWzBdXG4gICAgICAgICAgPyBlcnJvci5zcGxpY2UoXG4gICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAgIFwiWyVzXSBcIiArIGVycm9yWzBdLFxuICAgICAgICAgICAgICBcIiBcIiArIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCArIFwiIFwiXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiBlcnJvci5zcGxpY2UoMCwgMCwgXCJbJXNdIFwiLCBcIiBcIiArIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCArIFwiIFwiKTtcbiAgICAgICAgZXJyb3IudW5zaGlmdChjb25zb2xlKTtcbiAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gYmluZC5hcHBseShjb25zb2xlLmVycm9yLCBlcnJvcik7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCgpO1xuICAgICAgfSBlbHNlIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vb3AoKSB7fVxuICAgIGZ1bmN0aW9uIFJlcXVlc3RJbnN0YW5jZShcbiAgICAgIHJlc3VtYWJsZVN0YXRlLFxuICAgICAgcmVuZGVyU3RhdGUsXG4gICAgICByb290Rm9ybWF0Q29udGV4dCxcbiAgICAgIHByb2dyZXNzaXZlQ2h1bmtTaXplLFxuICAgICAgb25FcnJvcixcbiAgICAgIG9uQWxsUmVhZHksXG4gICAgICBvblNoZWxsUmVhZHksXG4gICAgICBvblNoZWxsRXJyb3IsXG4gICAgICBvbkZhdGFsRXJyb3IsXG4gICAgICBvblBvc3Rwb25lLFxuICAgICAgZm9ybVN0YXRlXG4gICAgKSB7XG4gICAgICB2YXIgYWJvcnRTZXQgPSBuZXcgU2V0KCk7XG4gICAgICB0aGlzLmRlc3RpbmF0aW9uID0gbnVsbDtcbiAgICAgIHRoaXMuZmx1c2hTY2hlZHVsZWQgPSAhMTtcbiAgICAgIHRoaXMucmVzdW1hYmxlU3RhdGUgPSByZXN1bWFibGVTdGF0ZTtcbiAgICAgIHRoaXMucmVuZGVyU3RhdGUgPSByZW5kZXJTdGF0ZTtcbiAgICAgIHRoaXMucm9vdEZvcm1hdENvbnRleHQgPSByb290Rm9ybWF0Q29udGV4dDtcbiAgICAgIHRoaXMucHJvZ3Jlc3NpdmVDaHVua1NpemUgPVxuICAgICAgICB2b2lkIDAgPT09IHByb2dyZXNzaXZlQ2h1bmtTaXplID8gMTI4MDAgOiBwcm9ncmVzc2l2ZUNodW5rU2l6ZTtcbiAgICAgIHRoaXMuc3RhdHVzID0gMTA7XG4gICAgICB0aGlzLmZhdGFsRXJyb3IgPSBudWxsO1xuICAgICAgdGhpcy5wZW5kaW5nUm9vdFRhc2tzID0gdGhpcy5hbGxQZW5kaW5nVGFza3MgPSB0aGlzLm5leHRTZWdtZW50SWQgPSAwO1xuICAgICAgdGhpcy5jb21wbGV0ZWRSb290U2VnbWVudCA9IG51bGw7XG4gICAgICB0aGlzLmFib3J0YWJsZVRhc2tzID0gYWJvcnRTZXQ7XG4gICAgICB0aGlzLnBpbmdlZFRhc2tzID0gW107XG4gICAgICB0aGlzLmNsaWVudFJlbmRlcmVkQm91bmRhcmllcyA9IFtdO1xuICAgICAgdGhpcy5jb21wbGV0ZWRCb3VuZGFyaWVzID0gW107XG4gICAgICB0aGlzLnBhcnRpYWxCb3VuZGFyaWVzID0gW107XG4gICAgICB0aGlzLnRyYWNrZWRQb3N0cG9uZXMgPSBudWxsO1xuICAgICAgdGhpcy5vbkVycm9yID0gdm9pZCAwID09PSBvbkVycm9yID8gZGVmYXVsdEVycm9ySGFuZGxlciA6IG9uRXJyb3I7XG4gICAgICB0aGlzLm9uUG9zdHBvbmUgPSB2b2lkIDAgPT09IG9uUG9zdHBvbmUgPyBub29wIDogb25Qb3N0cG9uZTtcbiAgICAgIHRoaXMub25BbGxSZWFkeSA9IHZvaWQgMCA9PT0gb25BbGxSZWFkeSA/IG5vb3AgOiBvbkFsbFJlYWR5O1xuICAgICAgdGhpcy5vblNoZWxsUmVhZHkgPSB2b2lkIDAgPT09IG9uU2hlbGxSZWFkeSA/IG5vb3AgOiBvblNoZWxsUmVhZHk7XG4gICAgICB0aGlzLm9uU2hlbGxFcnJvciA9IHZvaWQgMCA9PT0gb25TaGVsbEVycm9yID8gbm9vcCA6IG9uU2hlbGxFcnJvcjtcbiAgICAgIHRoaXMub25GYXRhbEVycm9yID0gdm9pZCAwID09PSBvbkZhdGFsRXJyb3IgPyBub29wIDogb25GYXRhbEVycm9yO1xuICAgICAgdGhpcy5mb3JtU3RhdGUgPSB2b2lkIDAgPT09IGZvcm1TdGF0ZSA/IG51bGwgOiBmb3JtU3RhdGU7XG4gICAgICB0aGlzLmRpZFdhcm5Gb3JLZXkgPSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVSZXF1ZXN0KFxuICAgICAgY2hpbGRyZW4sXG4gICAgICByZXN1bWFibGVTdGF0ZSxcbiAgICAgIHJlbmRlclN0YXRlLFxuICAgICAgcm9vdEZvcm1hdENvbnRleHQsXG4gICAgICBwcm9ncmVzc2l2ZUNodW5rU2l6ZSxcbiAgICAgIG9uRXJyb3IsXG4gICAgICBvbkFsbFJlYWR5LFxuICAgICAgb25TaGVsbFJlYWR5LFxuICAgICAgb25TaGVsbEVycm9yLFxuICAgICAgb25GYXRhbEVycm9yLFxuICAgICAgb25Qb3N0cG9uZSxcbiAgICAgIGZvcm1TdGF0ZVxuICAgICkge1xuICAgICAgcmVzdW1hYmxlU3RhdGUgPSBuZXcgUmVxdWVzdEluc3RhbmNlKFxuICAgICAgICByZXN1bWFibGVTdGF0ZSxcbiAgICAgICAgcmVuZGVyU3RhdGUsXG4gICAgICAgIHJvb3RGb3JtYXRDb250ZXh0LFxuICAgICAgICBwcm9ncmVzc2l2ZUNodW5rU2l6ZSxcbiAgICAgICAgb25FcnJvcixcbiAgICAgICAgb25BbGxSZWFkeSxcbiAgICAgICAgb25TaGVsbFJlYWR5LFxuICAgICAgICBvblNoZWxsRXJyb3IsXG4gICAgICAgIG9uRmF0YWxFcnJvcixcbiAgICAgICAgb25Qb3N0cG9uZSxcbiAgICAgICAgZm9ybVN0YXRlXG4gICAgICApO1xuICAgICAgcmVuZGVyU3RhdGUgPSBjcmVhdGVQZW5kaW5nU2VnbWVudChcbiAgICAgICAgcmVzdW1hYmxlU3RhdGUsXG4gICAgICAgIDAsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHJvb3RGb3JtYXRDb250ZXh0LFxuICAgICAgICAhMSxcbiAgICAgICAgITFcbiAgICAgICk7XG4gICAgICByZW5kZXJTdGF0ZS5wYXJlbnRGbHVzaGVkID0gITA7XG4gICAgICBjaGlsZHJlbiA9IGNyZWF0ZVJlbmRlclRhc2soXG4gICAgICAgIHJlc3VtYWJsZVN0YXRlLFxuICAgICAgICBudWxsLFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgLTEsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHJlbmRlclN0YXRlLFxuICAgICAgICBudWxsLFxuICAgICAgICByZXN1bWFibGVTdGF0ZS5hYm9ydGFibGVUYXNrcyxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgcm9vdEZvcm1hdENvbnRleHQsXG4gICAgICAgIG51bGwsXG4gICAgICAgIGVtcHR5VHJlZUNvbnRleHQsXG4gICAgICAgIG51bGwsXG4gICAgICAgICExXG4gICAgICApO1xuICAgICAgcHVzaENvbXBvbmVudFN0YWNrKGNoaWxkcmVuKTtcbiAgICAgIHJlc3VtYWJsZVN0YXRlLnBpbmdlZFRhc2tzLnB1c2goY2hpbGRyZW4pO1xuICAgICAgcmV0dXJuIHJlc3VtYWJsZVN0YXRlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwaW5nVGFzayhyZXF1ZXN0LCB0YXNrKSB7XG4gICAgICByZXF1ZXN0LnBpbmdlZFRhc2tzLnB1c2godGFzayk7XG4gICAgICAxID09PSByZXF1ZXN0LnBpbmdlZFRhc2tzLmxlbmd0aCAmJlxuICAgICAgICAoKHJlcXVlc3QuZmx1c2hTY2hlZHVsZWQgPSBudWxsICE9PSByZXF1ZXN0LmRlc3RpbmF0aW9uKSxcbiAgICAgICAgcGVyZm9ybVdvcmsocmVxdWVzdCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5KHJlcXVlc3QsIGZhbGxiYWNrQWJvcnRhYmxlVGFza3MpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXR1czogUEVORElORyxcbiAgICAgICAgcm9vdFNlZ21lbnRJRDogLTEsXG4gICAgICAgIHBhcmVudEZsdXNoZWQ6ICExLFxuICAgICAgICBwZW5kaW5nVGFza3M6IDAsXG4gICAgICAgIGNvbXBsZXRlZFNlZ21lbnRzOiBbXSxcbiAgICAgICAgYnl0ZVNpemU6IDAsXG4gICAgICAgIGZhbGxiYWNrQWJvcnRhYmxlVGFza3M6IGZhbGxiYWNrQWJvcnRhYmxlVGFza3MsXG4gICAgICAgIGVycm9yRGlnZXN0OiBudWxsLFxuICAgICAgICBjb250ZW50U3RhdGU6IGNyZWF0ZUhvaXN0YWJsZVN0YXRlKCksXG4gICAgICAgIGZhbGxiYWNrU3RhdGU6IGNyZWF0ZUhvaXN0YWJsZVN0YXRlKCksXG4gICAgICAgIHRyYWNrZWRDb250ZW50S2V5UGF0aDogbnVsbCxcbiAgICAgICAgdHJhY2tlZEZhbGxiYWNrTm9kZTogbnVsbCxcbiAgICAgICAgZXJyb3JNZXNzYWdlOiBudWxsLFxuICAgICAgICBlcnJvclN0YWNrOiBudWxsLFxuICAgICAgICBlcnJvckNvbXBvbmVudFN0YWNrOiBudWxsXG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVSZW5kZXJUYXNrKFxuICAgICAgcmVxdWVzdCxcbiAgICAgIHRoZW5hYmxlU3RhdGUsXG4gICAgICBub2RlLFxuICAgICAgY2hpbGRJbmRleCxcbiAgICAgIGJsb2NrZWRCb3VuZGFyeSxcbiAgICAgIGJsb2NrZWRTZWdtZW50LFxuICAgICAgaG9pc3RhYmxlU3RhdGUsXG4gICAgICBhYm9ydFNldCxcbiAgICAgIGtleVBhdGgsXG4gICAgICBmb3JtYXRDb250ZXh0LFxuICAgICAgY29udGV4dCxcbiAgICAgIHRyZWVDb250ZXh0LFxuICAgICAgY29tcG9uZW50U3RhY2ssXG4gICAgICBpc0ZhbGxiYWNrXG4gICAgKSB7XG4gICAgICByZXF1ZXN0LmFsbFBlbmRpbmdUYXNrcysrO1xuICAgICAgbnVsbCA9PT0gYmxvY2tlZEJvdW5kYXJ5XG4gICAgICAgID8gcmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzKytcbiAgICAgICAgOiBibG9ja2VkQm91bmRhcnkucGVuZGluZ1Rhc2tzKys7XG4gICAgICB2YXIgdGFzayA9IHtcbiAgICAgICAgcmVwbGF5OiBudWxsLFxuICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICBjaGlsZEluZGV4OiBjaGlsZEluZGV4LFxuICAgICAgICBwaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHBpbmdUYXNrKHJlcXVlc3QsIHRhc2spO1xuICAgICAgICB9LFxuICAgICAgICBibG9ja2VkQm91bmRhcnk6IGJsb2NrZWRCb3VuZGFyeSxcbiAgICAgICAgYmxvY2tlZFNlZ21lbnQ6IGJsb2NrZWRTZWdtZW50LFxuICAgICAgICBob2lzdGFibGVTdGF0ZTogaG9pc3RhYmxlU3RhdGUsXG4gICAgICAgIGFib3J0U2V0OiBhYm9ydFNldCxcbiAgICAgICAga2V5UGF0aDoga2V5UGF0aCxcbiAgICAgICAgZm9ybWF0Q29udGV4dDogZm9ybWF0Q29udGV4dCxcbiAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgdHJlZUNvbnRleHQ6IHRyZWVDb250ZXh0LFxuICAgICAgICBjb21wb25lbnRTdGFjazogY29tcG9uZW50U3RhY2ssXG4gICAgICAgIHRoZW5hYmxlU3RhdGU6IHRoZW5hYmxlU3RhdGUsXG4gICAgICAgIGlzRmFsbGJhY2s6IGlzRmFsbGJhY2tcbiAgICAgIH07XG4gICAgICBhYm9ydFNldC5hZGQodGFzayk7XG4gICAgICByZXR1cm4gdGFzaztcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlUmVwbGF5VGFzayhcbiAgICAgIHJlcXVlc3QsXG4gICAgICB0aGVuYWJsZVN0YXRlLFxuICAgICAgcmVwbGF5LFxuICAgICAgbm9kZSxcbiAgICAgIGNoaWxkSW5kZXgsXG4gICAgICBibG9ja2VkQm91bmRhcnksXG4gICAgICBob2lzdGFibGVTdGF0ZSxcbiAgICAgIGFib3J0U2V0LFxuICAgICAga2V5UGF0aCxcbiAgICAgIGZvcm1hdENvbnRleHQsXG4gICAgICBjb250ZXh0LFxuICAgICAgdHJlZUNvbnRleHQsXG4gICAgICBjb21wb25lbnRTdGFjayxcbiAgICAgIGlzRmFsbGJhY2tcbiAgICApIHtcbiAgICAgIHJlcXVlc3QuYWxsUGVuZGluZ1Rhc2tzKys7XG4gICAgICBudWxsID09PSBibG9ja2VkQm91bmRhcnlcbiAgICAgICAgPyByZXF1ZXN0LnBlbmRpbmdSb290VGFza3MrK1xuICAgICAgICA6IGJsb2NrZWRCb3VuZGFyeS5wZW5kaW5nVGFza3MrKztcbiAgICAgIHJlcGxheS5wZW5kaW5nVGFza3MrKztcbiAgICAgIHZhciB0YXNrID0ge1xuICAgICAgICByZXBsYXk6IHJlcGxheSxcbiAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgY2hpbGRJbmRleDogY2hpbGRJbmRleCxcbiAgICAgICAgcGluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBwaW5nVGFzayhyZXF1ZXN0LCB0YXNrKTtcbiAgICAgICAgfSxcbiAgICAgICAgYmxvY2tlZEJvdW5kYXJ5OiBibG9ja2VkQm91bmRhcnksXG4gICAgICAgIGJsb2NrZWRTZWdtZW50OiBudWxsLFxuICAgICAgICBob2lzdGFibGVTdGF0ZTogaG9pc3RhYmxlU3RhdGUsXG4gICAgICAgIGFib3J0U2V0OiBhYm9ydFNldCxcbiAgICAgICAga2V5UGF0aDoga2V5UGF0aCxcbiAgICAgICAgZm9ybWF0Q29udGV4dDogZm9ybWF0Q29udGV4dCxcbiAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgdHJlZUNvbnRleHQ6IHRyZWVDb250ZXh0LFxuICAgICAgICBjb21wb25lbnRTdGFjazogY29tcG9uZW50U3RhY2ssXG4gICAgICAgIHRoZW5hYmxlU3RhdGU6IHRoZW5hYmxlU3RhdGUsXG4gICAgICAgIGlzRmFsbGJhY2s6IGlzRmFsbGJhY2tcbiAgICAgIH07XG4gICAgICBhYm9ydFNldC5hZGQodGFzayk7XG4gICAgICByZXR1cm4gdGFzaztcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlUGVuZGluZ1NlZ21lbnQoXG4gICAgICByZXF1ZXN0LFxuICAgICAgaW5kZXgsXG4gICAgICBib3VuZGFyeSxcbiAgICAgIHBhcmVudEZvcm1hdENvbnRleHQsXG4gICAgICBsYXN0UHVzaGVkVGV4dCxcbiAgICAgIHRleHRFbWJlZGRlZFxuICAgICkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdHVzOiBQRU5ESU5HLFxuICAgICAgICBpZDogLTEsXG4gICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgcGFyZW50Rmx1c2hlZDogITEsXG4gICAgICAgIGNodW5rczogW10sXG4gICAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgICAgcGFyZW50Rm9ybWF0Q29udGV4dDogcGFyZW50Rm9ybWF0Q29udGV4dCxcbiAgICAgICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgICAgICBsYXN0UHVzaGVkVGV4dDogbGFzdFB1c2hlZFRleHQsXG4gICAgICAgIHRleHRFbWJlZGRlZDogdGV4dEVtYmVkZGVkXG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDdXJyZW50U3RhY2tJbkRFVigpIHtcbiAgICAgIHJldHVybiBudWxsID09PSBjdXJyZW50VGFza0luREVWIHx8XG4gICAgICAgIG51bGwgPT09IGN1cnJlbnRUYXNrSW5ERVYuY29tcG9uZW50U3RhY2tcbiAgICAgICAgPyBcIlwiXG4gICAgICAgIDogZ2V0U3RhY2tCeUNvbXBvbmVudFN0YWNrTm9kZShjdXJyZW50VGFza0luREVWLmNvbXBvbmVudFN0YWNrKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaFNlcnZlckNvbXBvbmVudFN0YWNrKHRhc2ssIGRlYnVnSW5mbykge1xuICAgICAgaWYgKG51bGwgIT0gZGVidWdJbmZvKVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlYnVnSW5mby5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBjb21wb25lbnRJbmZvID0gZGVidWdJbmZvW2ldO1xuICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBjb21wb25lbnRJbmZvLm5hbWUgJiZcbiAgICAgICAgICAgICh0YXNrLmNvbXBvbmVudFN0YWNrID0ge1xuICAgICAgICAgICAgICBwYXJlbnQ6IHRhc2suY29tcG9uZW50U3RhY2ssXG4gICAgICAgICAgICAgIHR5cGU6IGNvbXBvbmVudEluZm8sXG4gICAgICAgICAgICAgIG93bmVyOiBjb21wb25lbnRJbmZvLm93bmVyLFxuICAgICAgICAgICAgICBzdGFjazogbnVsbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaENvbXBvbmVudFN0YWNrKHRhc2spIHtcbiAgICAgIHZhciBub2RlID0gdGFzay5ub2RlO1xuICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBub2RlICYmIG51bGwgIT09IG5vZGUpXG4gICAgICAgIHN3aXRjaCAobm9kZS4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgICAgdmFyIHR5cGUgPSBub2RlLnR5cGUsXG4gICAgICAgICAgICAgIG93bmVyID0gbm9kZS5fb3duZXI7XG4gICAgICAgICAgICBwdXNoU2VydmVyQ29tcG9uZW50U3RhY2sodGFzaywgbm9kZS5fZGVidWdJbmZvKTtcbiAgICAgICAgICAgIHRhc2suY29tcG9uZW50U3RhY2sgPSB7XG4gICAgICAgICAgICAgIHBhcmVudDogdGFzay5jb21wb25lbnRTdGFjayxcbiAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgb3duZXI6IG93bmVyLFxuICAgICAgICAgICAgICBzdGFjazogbnVsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgcHVzaFNlcnZlckNvbXBvbmVudFN0YWNrKHRhc2ssIG5vZGUuX2RlYnVnSW5mbyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2Ygbm9kZS50aGVuICYmXG4gICAgICAgICAgICAgIHB1c2hTZXJ2ZXJDb21wb25lbnRTdGFjayh0YXNrLCBub2RlLl9kZWJ1Z0luZm8pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFRocm93bkluZm8obm9kZSkge1xuICAgICAgdmFyIGVycm9ySW5mbyA9IHt9O1xuICAgICAgbm9kZSAmJlxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyb3JJbmZvLCBcImNvbXBvbmVudFN0YWNrXCIsIHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN0YWNrID0gZ2V0U3RhY2tCeUNvbXBvbmVudFN0YWNrTm9kZShub2RlKTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlcnJvckluZm8sIFwiY29tcG9uZW50U3RhY2tcIiwge1xuICAgICAgICAgICAgICB2YWx1ZTogc3RhY2tcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHN0YWNrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICByZXR1cm4gZXJyb3JJbmZvO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbmNvZGVFcnJvckZvckJvdW5kYXJ5KFxuICAgICAgYm91bmRhcnksXG4gICAgICBkaWdlc3QsXG4gICAgICBlcnJvcixcbiAgICAgIHRocm93bkluZm8sXG4gICAgICB3YXNBYm9ydGVkXG4gICAgKSB7XG4gICAgICBib3VuZGFyeS5lcnJvckRpZ2VzdCA9IGRpZ2VzdDtcbiAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3JcbiAgICAgICAgPyAoKGRpZ2VzdCA9IFN0cmluZyhlcnJvci5tZXNzYWdlKSksIChlcnJvciA9IFN0cmluZyhlcnJvci5zdGFjaykpKVxuICAgICAgICA6ICgoZGlnZXN0ID1cbiAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBlcnJvciAmJiBudWxsICE9PSBlcnJvclxuICAgICAgICAgICAgICA/IGRlc2NyaWJlT2JqZWN0Rm9yRXJyb3JNZXNzYWdlKGVycm9yKVxuICAgICAgICAgICAgICA6IFN0cmluZyhlcnJvcikpLFxuICAgICAgICAgIChlcnJvciA9IG51bGwpKTtcbiAgICAgIHdhc0Fib3J0ZWQgPSB3YXNBYm9ydGVkXG4gICAgICAgID8gXCJTd2l0Y2hlZCB0byBjbGllbnQgcmVuZGVyaW5nIGJlY2F1c2UgdGhlIHNlcnZlciByZW5kZXJpbmcgYWJvcnRlZCBkdWUgdG86XFxuXFxuXCJcbiAgICAgICAgOiBcIlN3aXRjaGVkIHRvIGNsaWVudCByZW5kZXJpbmcgYmVjYXVzZSB0aGUgc2VydmVyIHJlbmRlcmluZyBlcnJvcmVkOlxcblxcblwiO1xuICAgICAgYm91bmRhcnkuZXJyb3JNZXNzYWdlID0gd2FzQWJvcnRlZCArIGRpZ2VzdDtcbiAgICAgIGJvdW5kYXJ5LmVycm9yU3RhY2sgPSBudWxsICE9PSBlcnJvciA/IHdhc0Fib3J0ZWQgKyBlcnJvciA6IG51bGw7XG4gICAgICBib3VuZGFyeS5lcnJvckNvbXBvbmVudFN0YWNrID0gdGhyb3duSW5mby5jb21wb25lbnRTdGFjaztcbiAgICB9XG4gICAgZnVuY3Rpb24gbG9nUmVjb3ZlcmFibGVFcnJvcihyZXF1ZXN0LCBlcnJvciwgZXJyb3JJbmZvKSB7XG4gICAgICByZXF1ZXN0ID0gcmVxdWVzdC5vbkVycm9yO1xuICAgICAgZXJyb3IgPSByZXF1ZXN0KGVycm9yLCBlcnJvckluZm8pO1xuICAgICAgaWYgKG51bGwgIT0gZXJyb3IgJiYgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIGVycm9yKVxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICdvbkVycm9yIHJldHVybmVkIHNvbWV0aGluZyB3aXRoIGEgdHlwZSBvdGhlciB0aGFuIFwic3RyaW5nXCIuIG9uRXJyb3Igc2hvdWxkIHJldHVybiBhIHN0cmluZyBhbmQgbWF5IHJldHVybiBudWxsIG9yIHVuZGVmaW5lZCBidXQgbXVzdCBub3QgcmV0dXJuIGFueXRoaW5nIGVsc2UuIEl0IHJlY2VpdmVkIHNvbWV0aGluZyBvZiB0eXBlIFwiJXNcIiBpbnN0ZWFkJyxcbiAgICAgICAgICB0eXBlb2YgZXJyb3JcbiAgICAgICAgKTtcbiAgICAgIGVsc2UgcmV0dXJuIGVycm9yO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmYXRhbEVycm9yKHJlcXVlc3QsIGVycm9yKSB7XG4gICAgICB2YXIgb25TaGVsbEVycm9yID0gcmVxdWVzdC5vblNoZWxsRXJyb3IsXG4gICAgICAgIG9uRmF0YWxFcnJvciA9IHJlcXVlc3Qub25GYXRhbEVycm9yO1xuICAgICAgb25TaGVsbEVycm9yKGVycm9yKTtcbiAgICAgIG9uRmF0YWxFcnJvcihlcnJvcik7XG4gICAgICBudWxsICE9PSByZXF1ZXN0LmRlc3RpbmF0aW9uXG4gICAgICAgID8gKChyZXF1ZXN0LnN0YXR1cyA9IENMT1NFRCksIHJlcXVlc3QuZGVzdGluYXRpb24uZGVzdHJveShlcnJvcikpXG4gICAgICAgIDogKChyZXF1ZXN0LnN0YXR1cyA9IDEzKSwgKHJlcXVlc3QuZmF0YWxFcnJvciA9IGVycm9yKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbmRlcldpdGhIb29rcyhcbiAgICAgIHJlcXVlc3QsXG4gICAgICB0YXNrLFxuICAgICAga2V5UGF0aCxcbiAgICAgIENvbXBvbmVudCxcbiAgICAgIHByb3BzLFxuICAgICAgc2Vjb25kQXJnXG4gICAgKSB7XG4gICAgICB2YXIgcHJldlRoZW5hYmxlU3RhdGUgPSB0YXNrLnRoZW5hYmxlU3RhdGU7XG4gICAgICB0YXNrLnRoZW5hYmxlU3RhdGUgPSBudWxsO1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50ID0ge307XG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdUYXNrID0gdGFzaztcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ1JlcXVlc3QgPSByZXF1ZXN0O1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nS2V5UGF0aCA9IGtleVBhdGg7XG4gICAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSAhMTtcbiAgICAgIGFjdGlvblN0YXRlQ291bnRlciA9IGxvY2FsSWRDb3VudGVyID0gMDtcbiAgICAgIGFjdGlvblN0YXRlTWF0Y2hpbmdJbmRleCA9IC0xO1xuICAgICAgdGhlbmFibGVJbmRleENvdW50ZXIgPSAwO1xuICAgICAgdGhlbmFibGVTdGF0ZSA9IHByZXZUaGVuYWJsZVN0YXRlO1xuICAgICAgZm9yIChcbiAgICAgICAgcmVxdWVzdCA9IGNhbGxDb21wb25lbnRJbkRFVihDb21wb25lbnQsIHByb3BzLCBzZWNvbmRBcmcpO1xuICAgICAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlO1xuXG4gICAgICApXG4gICAgICAgIChkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gITEpLFxuICAgICAgICAgIChhY3Rpb25TdGF0ZUNvdW50ZXIgPSBsb2NhbElkQ291bnRlciA9IDApLFxuICAgICAgICAgIChhY3Rpb25TdGF0ZU1hdGNoaW5nSW5kZXggPSAtMSksXG4gICAgICAgICAgKHRoZW5hYmxlSW5kZXhDb3VudGVyID0gMCksXG4gICAgICAgICAgKG51bWJlck9mUmVSZW5kZXJzICs9IDEpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsKSxcbiAgICAgICAgICAocmVxdWVzdCA9IENvbXBvbmVudChwcm9wcywgc2Vjb25kQXJnKSk7XG4gICAgICByZXNldEhvb2tzU3RhdGUoKTtcbiAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5pc2hGdW5jdGlvbkNvbXBvbmVudChcbiAgICAgIHJlcXVlc3QsXG4gICAgICB0YXNrLFxuICAgICAga2V5UGF0aCxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgaGFzSWQsXG4gICAgICBhY3Rpb25TdGF0ZUNvdW50LFxuICAgICAgYWN0aW9uU3RhdGVNYXRjaGluZ0luZGV4XG4gICAgKSB7XG4gICAgICB2YXIgZGlkRW1pdEFjdGlvblN0YXRlTWFya2VycyA9ICExO1xuICAgICAgaWYgKDAgIT09IGFjdGlvblN0YXRlQ291bnQgJiYgbnVsbCAhPT0gcmVxdWVzdC5mb3JtU3RhdGUpIHtcbiAgICAgICAgdmFyIHNlZ21lbnQgPSB0YXNrLmJsb2NrZWRTZWdtZW50O1xuICAgICAgICBpZiAobnVsbCAhPT0gc2VnbWVudCkge1xuICAgICAgICAgIGRpZEVtaXRBY3Rpb25TdGF0ZU1hcmtlcnMgPSAhMDtcbiAgICAgICAgICBzZWdtZW50ID0gc2VnbWVudC5jaHVua3M7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhY3Rpb25TdGF0ZUNvdW50OyBpKyspXG4gICAgICAgICAgICBpID09PSBhY3Rpb25TdGF0ZU1hdGNoaW5nSW5kZXhcbiAgICAgICAgICAgICAgPyBzZWdtZW50LnB1c2goXCJcXHgzYyEtLUYhLS1cXHgzZVwiKVxuICAgICAgICAgICAgICA6IHNlZ21lbnQucHVzaChcIlxceDNjIS0tRi0tXFx4M2VcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFjdGlvblN0YXRlQ291bnQgPSB0YXNrLmtleVBhdGg7XG4gICAgICB0YXNrLmtleVBhdGggPSBrZXlQYXRoO1xuICAgICAgaGFzSWRcbiAgICAgICAgPyAoKGtleVBhdGggPSB0YXNrLnRyZWVDb250ZXh0KSxcbiAgICAgICAgICAodGFzay50cmVlQ29udGV4dCA9IHB1c2hUcmVlQ29udGV4dChrZXlQYXRoLCAxLCAwKSksXG4gICAgICAgICAgcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBjaGlsZHJlbiwgLTEpLFxuICAgICAgICAgICh0YXNrLnRyZWVDb250ZXh0ID0ga2V5UGF0aCkpXG4gICAgICAgIDogZGlkRW1pdEFjdGlvblN0YXRlTWFya2Vyc1xuICAgICAgICAgID8gcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBjaGlsZHJlbiwgLTEpXG4gICAgICAgICAgOiByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgY2hpbGRyZW4sIC0xKTtcbiAgICAgIHRhc2sua2V5UGF0aCA9IGFjdGlvblN0YXRlQ291bnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbmRlckVsZW1lbnQocmVxdWVzdCwgdGFzaywga2V5UGF0aCwgdHlwZSwgcHJvcHMsIHJlZikge1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIGlmICh0eXBlLnByb3RvdHlwZSAmJiB0eXBlLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KSB7XG4gICAgICAgICAgdmFyIG5ld1Byb3BzID0gcHJvcHM7XG4gICAgICAgICAgaWYgKFwicmVmXCIgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgIG5ld1Byb3BzID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBwcm9wcylcbiAgICAgICAgICAgICAgXCJyZWZcIiAhPT0gcHJvcE5hbWUgJiYgKG5ld1Byb3BzW3Byb3BOYW1lXSA9IHByb3BzW3Byb3BOYW1lXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcbiAgICAgICAgICBpZiAoZGVmYXVsdFByb3BzKSB7XG4gICAgICAgICAgICBuZXdQcm9wcyA9PT0gcHJvcHMgJiYgKG5ld1Byb3BzID0gYXNzaWduKHt9LCBuZXdQcm9wcywgcHJvcHMpKTtcbiAgICAgICAgICAgIGZvciAodmFyIF9wcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpXG4gICAgICAgICAgICAgIHZvaWQgMCA9PT0gbmV3UHJvcHNbX3Byb3BOYW1lXSAmJlxuICAgICAgICAgICAgICAgIChuZXdQcm9wc1tfcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW19wcm9wTmFtZV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcmVzb2x2ZWRQcm9wcyA9IG5ld1Byb3BzO1xuICAgICAgICAgIHZhciBjb250ZXh0ID0gZW1wdHlDb250ZXh0T2JqZWN0LFxuICAgICAgICAgICAgY29udGV4dFR5cGUgPSB0eXBlLmNvbnRleHRUeXBlO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIFwiY29udGV4dFR5cGVcIiBpbiB0eXBlICYmXG4gICAgICAgICAgICBudWxsICE9PSBjb250ZXh0VHlwZSAmJlxuICAgICAgICAgICAgKHZvaWQgMCA9PT0gY29udGV4dFR5cGUgfHxcbiAgICAgICAgICAgICAgY29udGV4dFR5cGUuJCR0eXBlb2YgIT09IFJFQUNUX0NPTlRFWFRfVFlQRSkgJiZcbiAgICAgICAgICAgICFkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUuaGFzKHR5cGUpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUuYWRkKHR5cGUpO1xuICAgICAgICAgICAgdmFyIGFkZGVuZHVtID1cbiAgICAgICAgICAgICAgdm9pZCAwID09PSBjb250ZXh0VHlwZVxuICAgICAgICAgICAgICAgID8gXCIgSG93ZXZlciwgaXQgaXMgc2V0IHRvIHVuZGVmaW5lZC4gVGhpcyBjYW4gYmUgY2F1c2VkIGJ5IGEgdHlwbyBvciBieSBtaXhpbmcgdXAgbmFtZWQgYW5kIGRlZmF1bHQgaW1wb3J0cy4gVGhpcyBjYW4gYWxzbyBoYXBwZW4gZHVlIHRvIGEgY2lyY3VsYXIgZGVwZW5kZW5jeSwgc28gdHJ5IG1vdmluZyB0aGUgY3JlYXRlQ29udGV4dCgpIGNhbGwgdG8gYSBzZXBhcmF0ZSBmaWxlLlwiXG4gICAgICAgICAgICAgICAgOiBcIm9iamVjdFwiICE9PSB0eXBlb2YgY29udGV4dFR5cGVcbiAgICAgICAgICAgICAgICAgID8gXCIgSG93ZXZlciwgaXQgaXMgc2V0IHRvIGEgXCIgKyB0eXBlb2YgY29udGV4dFR5cGUgKyBcIi5cIlxuICAgICAgICAgICAgICAgICAgOiBjb250ZXh0VHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OU1VNRVJfVFlQRVxuICAgICAgICAgICAgICAgICAgICA/IFwiIERpZCB5b3UgYWNjaWRlbnRhbGx5IHBhc3MgdGhlIENvbnRleHQuQ29uc3VtZXIgaW5zdGVhZD9cIlxuICAgICAgICAgICAgICAgICAgICA6IFwiIEhvd2V2ZXIsIGl0IGlzIHNldCB0byBhbiBvYmplY3Qgd2l0aCBrZXlzIHtcIiArXG4gICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoY29udGV4dFR5cGUpLmpvaW4oXCIsIFwiKSArXG4gICAgICAgICAgICAgICAgICAgICAgXCJ9LlwiO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlcyBkZWZpbmVzIGFuIGludmFsaWQgY29udGV4dFR5cGUuIGNvbnRleHRUeXBlIHNob3VsZCBwb2ludCB0byB0aGUgQ29udGV4dCBvYmplY3QgcmV0dXJuZWQgYnkgUmVhY3QuY3JlYXRlQ29udGV4dCgpLiVzXCIsXG4gICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCBcIkNvbXBvbmVudFwiLFxuICAgICAgICAgICAgICBhZGRlbmR1bVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGNvbnRleHRUeXBlICYmXG4gICAgICAgICAgICBudWxsICE9PSBjb250ZXh0VHlwZSAmJlxuICAgICAgICAgICAgKGNvbnRleHQgPSBjb250ZXh0VHlwZS5fY3VycmVudFZhbHVlMik7XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gbmV3IHR5cGUocmVzb2x2ZWRQcm9wcywgY29udGV4dCk7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgJiZcbiAgICAgICAgICAgIChudWxsID09PSBpbnN0YW5jZS5zdGF0ZSB8fCB2b2lkIDAgPT09IGluc3RhbmNlLnN0YXRlKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgXCJDb21wb25lbnRcIjtcbiAgICAgICAgICAgIGRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZS5oYXMoY29tcG9uZW50TmFtZSkgfHxcbiAgICAgICAgICAgICAgKGRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZS5hZGQoY29tcG9uZW50TmFtZSksXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJgJXNgIHVzZXMgYGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc2AgYnV0IGl0cyBpbml0aWFsIHN0YXRlIGlzICVzLiBUaGlzIGlzIG5vdCByZWNvbW1lbmRlZC4gSW5zdGVhZCwgZGVmaW5lIHRoZSBpbml0aWFsIHN0YXRlIGJ5IGFzc2lnbmluZyBhbiBvYmplY3QgdG8gYHRoaXMuc3RhdGVgIGluIHRoZSBjb25zdHJ1Y3RvciBvZiBgJXNgLiBUaGlzIGVuc3VyZXMgdGhhdCBgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzYCBhcmd1bWVudHMgaGF2ZSBhIGNvbnNpc3RlbnQgc2hhcGUuXCIsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50TmFtZSxcbiAgICAgICAgICAgICAgICBudWxsID09PSBpbnN0YW5jZS5zdGF0ZSA/IFwibnVsbFwiIDogXCJ1bmRlZmluZWRcIixcbiAgICAgICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAgICAgICAgICAgICkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyB8fFxuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGVcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciBmb3VuZFdpbGxNb3VudE5hbWUgPSBudWxsLFxuICAgICAgICAgICAgICBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lID0gbnVsbCxcbiAgICAgICAgICAgICAgZm91bmRXaWxsVXBkYXRlTmFtZSA9IG51bGw7XG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgJiZcbiAgICAgICAgICAgICEwICE9PSBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ1xuICAgICAgICAgICAgICA/IChmb3VuZFdpbGxNb3VudE5hbWUgPSBcImNvbXBvbmVudFdpbGxNb3VudFwiKVxuICAgICAgICAgICAgICA6IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgJiZcbiAgICAgICAgICAgICAgICAoZm91bmRXaWxsTW91bnROYW1lID0gXCJVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50XCIpO1xuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAmJlxuICAgICAgICAgICAgITAgIT09XG4gICAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ1xuICAgICAgICAgICAgICA/IChmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lID0gXCJjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzXCIpXG4gICAgICAgICAgICAgIDogXCJmdW5jdGlvblwiID09PVxuICAgICAgICAgICAgICAgICAgdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzICYmXG4gICAgICAgICAgICAgICAgKGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgPVxuICAgICAgICAgICAgICAgICAgXCJVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1wiKTtcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUgJiZcbiAgICAgICAgICAgICEwICE9PSBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdcbiAgICAgICAgICAgICAgPyAoZm91bmRXaWxsVXBkYXRlTmFtZSA9IFwiY29tcG9uZW50V2lsbFVwZGF0ZVwiKVxuICAgICAgICAgICAgICA6IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlICYmXG4gICAgICAgICAgICAgICAgKGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSBcIlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlXCIpO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBudWxsICE9PSBmb3VuZFdpbGxNb3VudE5hbWUgfHxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSB8fFxuICAgICAgICAgICAgICBudWxsICE9PSBmb3VuZFdpbGxVcGRhdGVOYW1lXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgdmFyIF9jb21wb25lbnROYW1lID1cbiAgICAgICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCBcIkNvbXBvbmVudFwiLFxuICAgICAgICAgICAgICAgIG5ld0FwaU5hbWUgPVxuICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNcbiAgICAgICAgICAgICAgICAgICAgPyBcImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcygpXCJcbiAgICAgICAgICAgICAgICAgICAgOiBcImdldFNuYXBzaG90QmVmb3JlVXBkYXRlKClcIjtcbiAgICAgICAgICAgICAgZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZS5oYXMoX2NvbXBvbmVudE5hbWUpIHx8XG4gICAgICAgICAgICAgICAgKGRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUuYWRkKFxuICAgICAgICAgICAgICAgICAgX2NvbXBvbmVudE5hbWVcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlVuc2FmZSBsZWdhY3kgbGlmZWN5Y2xlcyB3aWxsIG5vdCBiZSBjYWxsZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgbmV3IGNvbXBvbmVudCBBUElzLlxcblxcbiVzIHVzZXMgJXMgYnV0IGFsc28gY29udGFpbnMgdGhlIGZvbGxvd2luZyBsZWdhY3kgbGlmZWN5Y2xlczolcyVzJXNcXG5cXG5UaGUgYWJvdmUgbGlmZWN5Y2xlcyBzaG91bGQgYmUgcmVtb3ZlZC4gTGVhcm4gbW9yZSBhYm91dCB0aGlzIHdhcm5pbmcgaGVyZTpcXG5odHRwczovL3JlYWN0LmRldi9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlc1wiLFxuICAgICAgICAgICAgICAgICAgX2NvbXBvbmVudE5hbWUsXG4gICAgICAgICAgICAgICAgICBuZXdBcGlOYW1lLFxuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gZm91bmRXaWxsTW91bnROYW1lXG4gICAgICAgICAgICAgICAgICAgID8gXCJcXG4gIFwiICsgZm91bmRXaWxsTW91bnROYW1lXG4gICAgICAgICAgICAgICAgICAgIDogXCJcIixcbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWVcbiAgICAgICAgICAgICAgICAgICAgPyBcIlxcbiAgXCIgKyBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lXG4gICAgICAgICAgICAgICAgICAgIDogXCJcIixcbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IGZvdW5kV2lsbFVwZGF0ZU5hbWVcbiAgICAgICAgICAgICAgICAgICAgPyBcIlxcbiAgXCIgKyBmb3VuZFdpbGxVcGRhdGVOYW1lXG4gICAgICAgICAgICAgICAgICAgIDogXCJcIlxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCBcIkNvbXBvbmVudFwiO1xuICAgICAgICAgIGluc3RhbmNlLnJlbmRlciB8fFxuICAgICAgICAgICAgKHR5cGUucHJvdG90eXBlICYmIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUucHJvdG90eXBlLnJlbmRlclxuICAgICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIk5vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgJXMgaW5zdGFuY2U6IGRpZCB5b3UgYWNjaWRlbnRhbGx5IHJldHVybiBhbiBvYmplY3QgZnJvbSB0aGUgY29uc3RydWN0b3I/XCIsXG4gICAgICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIk5vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgJXMgaW5zdGFuY2U6IHlvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gZGVmaW5lIGByZW5kZXJgLlwiLFxuICAgICAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICFpbnN0YW5jZS5nZXRJbml0aWFsU3RhdGUgfHxcbiAgICAgICAgICAgIGluc3RhbmNlLmdldEluaXRpYWxTdGF0ZS5pc1JlYWN0Q2xhc3NBcHByb3ZlZCB8fFxuICAgICAgICAgICAgaW5zdGFuY2Uuc3RhdGUgfHxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiZ2V0SW5pdGlhbFN0YXRlIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuIFRoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gRGlkIHlvdSBtZWFuIHRvIGRlZmluZSBhIHN0YXRlIHByb3BlcnR5IGluc3RlYWQ/XCIsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgaW5zdGFuY2UuZ2V0RGVmYXVsdFByb3BzICYmXG4gICAgICAgICAgICAhaW5zdGFuY2UuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcImdldERlZmF1bHRQcm9wcyB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiBUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSB0byBkZWZpbmUgZGVmYXVsdFByb3BzIGluc3RlYWQuXCIsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgaW5zdGFuY2UuY29udGV4dFR5cGUgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiY29udGV4dFR5cGUgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSB0byBkZWZpbmUgY29udGV4dFR5cGUgaW5zdGVhZC5cIixcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB0eXBlLmNoaWxkQ29udGV4dFR5cGVzICYmXG4gICAgICAgICAgICAhZGlkV2FybkFib3V0Q2hpbGRDb250ZXh0VHlwZXMuaGFzKHR5cGUpICYmXG4gICAgICAgICAgICAoZGlkV2FybkFib3V0Q2hpbGRDb250ZXh0VHlwZXMuYWRkKHR5cGUpLFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlcyB1c2VzIHRoZSBsZWdhY3kgY2hpbGRDb250ZXh0VHlwZXMgQVBJIHdoaWNoIHdhcyByZW1vdmVkIGluIFJlYWN0IDE5LiBVc2UgUmVhY3QuY3JlYXRlQ29udGV4dCgpIGluc3RlYWQuIChodHRwczovL3JlYWN0LmRldi9saW5rL2xlZ2FjeS1jb250ZXh0KVwiLFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApKTtcbiAgICAgICAgICB0eXBlLmNvbnRleHRUeXBlcyAmJlxuICAgICAgICAgICAgIWRpZFdhcm5BYm91dENvbnRleHRUeXBlcyQxLmhhcyh0eXBlKSAmJlxuICAgICAgICAgICAgKGRpZFdhcm5BYm91dENvbnRleHRUeXBlcyQxLmFkZCh0eXBlKSxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiJXMgdXNlcyB0aGUgbGVnYWN5IGNvbnRleHRUeXBlcyBBUEkgd2hpY2ggd2FzIHJlbW92ZWQgaW4gUmVhY3QgMTkuIFVzZSBSZWFjdC5jcmVhdGVDb250ZXh0KCkgd2l0aCBzdGF0aWMgY29udGV4dFR5cGUgaW5zdGVhZC4gKGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvbGVnYWN5LWNvbnRleHQpXCIsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICkpO1xuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFNob3VsZFVwZGF0ZSAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlcyBoYXMgYSBtZXRob2QgY2FsbGVkIGNvbXBvbmVudFNob3VsZFVwZGF0ZSgpLiBEaWQgeW91IG1lYW4gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk/IFRoZSBuYW1lIGlzIHBocmFzZWQgYXMgYSBxdWVzdGlvbiBiZWNhdXNlIHRoZSBmdW5jdGlvbiBpcyBleHBlY3RlZCB0byByZXR1cm4gYSB2YWx1ZS5cIixcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB0eXBlLnByb3RvdHlwZSAmJlxuICAgICAgICAgICAgdHlwZS5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgJiZcbiAgICAgICAgICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBzaG91bGRDb21wb25lbnRVcGRhdGUoKS4gc2hvdWxkQ29tcG9uZW50VXBkYXRlIHNob3VsZCBub3QgYmUgdXNlZCB3aGVuIGV4dGVuZGluZyBSZWFjdC5QdXJlQ29tcG9uZW50LiBQbGVhc2UgZXh0ZW5kIFJlYWN0LkNvbXBvbmVudCBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgaXMgdXNlZC5cIixcbiAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8IFwiQSBwdXJlIGNvbXBvbmVudFwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVubW91bnQgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBjb21wb25lbnREaWRVbm1vdW50KCkuIEJ1dCB0aGVyZSBpcyBubyBzdWNoIGxpZmVjeWNsZSBtZXRob2QuIERpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsVW5tb3VudCgpP1wiLFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFJlY2VpdmVQcm9wcyAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlcyBoYXMgYSBtZXRob2QgY2FsbGVkIGNvbXBvbmVudERpZFJlY2VpdmVQcm9wcygpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiBJZiB5b3UgbWVhbnQgdG8gdXBkYXRlIHRoZSBzdGF0ZSBpbiByZXNwb25zZSB0byBjaGFuZ2luZyBwcm9wcywgdXNlIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKS4gSWYgeW91IG1lYW50IHRvIGZldGNoIGRhdGEgb3IgcnVuIHNpZGUtZWZmZWN0cyBvciBtdXRhdGlvbnMgYWZ0ZXIgUmVhY3QgaGFzIHVwZGF0ZWQgdGhlIFVJLCB1c2UgY29tcG9uZW50RGlkVXBkYXRlKCkuXCIsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlcyBoYXMgYSBtZXRob2QgY2FsbGVkIGNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT9cIixcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlcyBoYXMgYSBtZXRob2QgY2FsbGVkIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpP1wiLFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHZhciBoYXNNdXRhdGVkUHJvcHMgPSBpbnN0YW5jZS5wcm9wcyAhPT0gcmVzb2x2ZWRQcm9wcztcbiAgICAgICAgICB2b2lkIDAgIT09IGluc3RhbmNlLnByb3BzICYmXG4gICAgICAgICAgICBoYXNNdXRhdGVkUHJvcHMgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiV2hlbiBjYWxsaW5nIHN1cGVyKCkgaW4gYCVzYCwgbWFrZSBzdXJlIHRvIHBhc3MgdXAgdGhlIHNhbWUgcHJvcHMgdGhhdCB5b3VyIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yIHdhcyBwYXNzZWQuXCIsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgaW5zdGFuY2UuZGVmYXVsdFByb3BzICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlNldHRpbmcgZGVmYXVsdFByb3BzIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzIGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCwgZGVmaW5lIGRlZmF1bHRQcm9wcyBhcyBhIHN0YXRpYyBwcm9wZXJ0eSBvbiAlcy5cIixcbiAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSB8fFxuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlIHx8XG4gICAgICAgICAgICBkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUuaGFzKHR5cGUpIHx8XG4gICAgICAgICAgICAoZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlLmFkZCh0eXBlKSxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiJXM6IGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgc2hvdWxkIGJlIHVzZWQgd2l0aCBjb21wb25lbnREaWRVcGRhdGUoKS4gVGhpcyBjb21wb25lbnQgZGVmaW5lcyBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIG9ubHkuXCIsXG4gICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKVxuICAgICAgICAgICAgKSk7XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzOiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoKSBpcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIG1ldGhvZCBhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWNsYXJlIGl0IGFzIGEgc3RhdGljIG1ldGhvZC5cIixcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiJXM6IGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcigpIGlzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kIGFuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlY2xhcmUgaXQgYXMgYSBzdGF0aWMgbWV0aG9kLlwiLFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiJXM6IGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgaXMgZGVmaW5lZCBhcyBhIHN0YXRpYyBtZXRob2QgYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCwgZGVjbGFyZSBpdCBhcyBhbiBpbnN0YW5jZSBtZXRob2QuXCIsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgdmFyIHN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG4gICAgICAgICAgc3RhdGUgJiZcbiAgICAgICAgICAgIChcIm9iamVjdFwiICE9PSB0eXBlb2Ygc3RhdGUgfHwgaXNBcnJheUltcGwoc3RhdGUpKSAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIiVzLnN0YXRlOiBtdXN0IGJlIHNldCB0byBhbiBvYmplY3Qgb3IgbnVsbFwiLCBuYW1lKTtcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQgJiZcbiAgICAgICAgICAgIFwib2JqZWN0XCIgIT09IHR5cGVvZiB0eXBlLmNoaWxkQ29udGV4dFR5cGVzICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzLmdldENoaWxkQ29udGV4dCgpOiBjaGlsZENvbnRleHRUeXBlcyBtdXN0IGJlIGRlZmluZWQgaW4gb3JkZXIgdG8gdXNlIGdldENoaWxkQ29udGV4dCgpLlwiLFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHZhciBpbml0aWFsU3RhdGUgPSB2b2lkIDAgIT09IGluc3RhbmNlLnN0YXRlID8gaW5zdGFuY2Uuc3RhdGUgOiBudWxsO1xuICAgICAgICAgIGluc3RhbmNlLnVwZGF0ZXIgPSBjbGFzc0NvbXBvbmVudFVwZGF0ZXI7XG4gICAgICAgICAgaW5zdGFuY2UucHJvcHMgPSByZXNvbHZlZFByb3BzO1xuICAgICAgICAgIGluc3RhbmNlLnN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICAgICAgICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0geyBxdWV1ZTogW10sIHJlcGxhY2U6ICExIH07XG4gICAgICAgICAgaW5zdGFuY2UuX3JlYWN0SW50ZXJuYWxzID0gaW50ZXJuYWxJbnN0YW5jZTtcbiAgICAgICAgICB2YXIgY29udGV4dFR5cGUkanNjb21wJDAgPSB0eXBlLmNvbnRleHRUeXBlO1xuICAgICAgICAgIGluc3RhbmNlLmNvbnRleHQgPVxuICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGNvbnRleHRUeXBlJGpzY29tcCQwICYmXG4gICAgICAgICAgICBudWxsICE9PSBjb250ZXh0VHlwZSRqc2NvbXAkMFxuICAgICAgICAgICAgICA/IGNvbnRleHRUeXBlJGpzY29tcCQwLl9jdXJyZW50VmFsdWUyXG4gICAgICAgICAgICAgIDogZW1wdHlDb250ZXh0T2JqZWN0O1xuICAgICAgICAgIGlmIChpbnN0YW5jZS5zdGF0ZSA9PT0gcmVzb2x2ZWRQcm9wcykge1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUkanNjb21wJDAgPVxuICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgXCJDb21wb25lbnRcIjtcbiAgICAgICAgICAgIGRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlLmhhcyhcbiAgICAgICAgICAgICAgY29tcG9uZW50TmFtZSRqc2NvbXAkMFxuICAgICAgICAgICAgKSB8fFxuICAgICAgICAgICAgICAoZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUuYWRkKFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudE5hbWUkanNjb21wJDBcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIiVzOiBJdCBpcyBub3QgcmVjb21tZW5kZWQgdG8gYXNzaWduIHByb3BzIGRpcmVjdGx5IHRvIHN0YXRlIGJlY2F1c2UgdXBkYXRlcyB0byBwcm9wcyB3b24ndCBiZSByZWZsZWN0ZWQgaW4gc3RhdGUuIEluIG1vc3QgY2FzZXMsIGl0IGlzIGJldHRlciB0byB1c2UgcHJvcHMgZGlyZWN0bHkuXCIsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50TmFtZSRqc2NvbXAkMFxuICAgICAgICAgICAgICApKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IHR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzO1xuICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMpIHtcbiAgICAgICAgICAgIHZhciBwYXJ0aWFsU3RhdGUgPSBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoXG4gICAgICAgICAgICAgIHJlc29sdmVkUHJvcHMsXG4gICAgICAgICAgICAgIGluaXRpYWxTdGF0ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IHBhcnRpYWxTdGF0ZSkge1xuICAgICAgICAgICAgICB2YXIgY29tcG9uZW50TmFtZSRqc2NvbXAkMSA9XG4gICAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8IFwiQ29tcG9uZW50XCI7XG4gICAgICAgICAgICAgIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZS5oYXMoY29tcG9uZW50TmFtZSRqc2NvbXAkMSkgfHxcbiAgICAgICAgICAgICAgICAoZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlLmFkZChjb21wb25lbnROYW1lJGpzY29tcCQxKSxcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCIlcy5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoKTogQSB2YWxpZCBzdGF0ZSBvYmplY3QgKG9yIG51bGwpIG11c3QgYmUgcmV0dXJuZWQuIFlvdSBoYXZlIHJldHVybmVkIHVuZGVmaW5lZC5cIixcbiAgICAgICAgICAgICAgICAgIGNvbXBvbmVudE5hbWUkanNjb21wJDFcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPVxuICAgICAgICAgICAgICBudWxsID09PSBwYXJ0aWFsU3RhdGUgfHwgdm9pZCAwID09PSBwYXJ0aWFsU3RhdGVcbiAgICAgICAgICAgICAgICA/IGluaXRpYWxTdGF0ZVxuICAgICAgICAgICAgICAgIDogYXNzaWduKHt9LCBpbml0aWFsU3RhdGUsIHBhcnRpYWxTdGF0ZSk7XG4gICAgICAgICAgICBpbnN0YW5jZS5zdGF0ZSA9IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgdHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgJiZcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlICYmXG4gICAgICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCB8fFxuICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgb2xkU3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTtcbiAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQpIHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICEwICE9PSBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ1xuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB2YXIgY29tcG9uZW50TmFtZSRqc2NvbXAkMiA9XG4gICAgICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgXCJVbmtub3duXCI7XG4gICAgICAgICAgICAgICAgZGlkV2FybkFib3V0RGVwcmVjYXRlZFdpbGxNb3VudFtjb21wb25lbnROYW1lJGpzY29tcCQyXSB8fFxuICAgICAgICAgICAgICAgICAgKGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAgICAgXCJjb21wb25lbnRXaWxsTW91bnQgaGFzIGJlZW4gcmVuYW1lZCwgYW5kIGlzIG5vdCByZWNvbW1lbmRlZCBmb3IgdXNlLiBTZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuKiBNb3ZlIGNvZGUgZnJvbSBjb21wb25lbnRXaWxsTW91bnQgdG8gY29tcG9uZW50RGlkTW91bnQgKHByZWZlcnJlZCBpbiBtb3N0IGNhc2VzKSBvciB0aGUgY29uc3RydWN0b3IuXFxuXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzXCIsXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudE5hbWUkanNjb21wJDJcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAoZGlkV2FybkFib3V0RGVwcmVjYXRlZFdpbGxNb3VudFtjb21wb25lbnROYW1lJGpzY29tcCQyXSA9XG4gICAgICAgICAgICAgICAgICAgICEwKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ICYmXG4gICAgICAgICAgICAgIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgICAgICAgICAgIG9sZFN0YXRlICE9PSBpbnN0YW5jZS5zdGF0ZSAmJlxuICAgICAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIiVzLmNvbXBvbmVudFdpbGxNb3VudCgpOiBBc3NpZ25pbmcgZGlyZWN0bHkgdG8gdGhpcy5zdGF0ZSBpcyBkZXByZWNhdGVkIChleGNlcHQgaW5zaWRlIGEgY29tcG9uZW50J3MgY29uc3RydWN0b3IpLiBVc2Ugc2V0U3RhdGUgaW5zdGVhZC5cIixcbiAgICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgXCJDb21wb25lbnRcIlxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBjbGFzc0NvbXBvbmVudFVwZGF0ZXIuZW5xdWV1ZVJlcGxhY2VTdGF0ZShcbiAgICAgICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5zdGF0ZSxcbiAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBudWxsICE9PSBpbnRlcm5hbEluc3RhbmNlLnF1ZXVlICYmXG4gICAgICAgICAgICAgIDAgPCBpbnRlcm5hbEluc3RhbmNlLnF1ZXVlLmxlbmd0aFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHZhciBvbGRRdWV1ZSA9IGludGVybmFsSW5zdGFuY2UucXVldWUsXG4gICAgICAgICAgICAgICAgb2xkUmVwbGFjZSA9IGludGVybmFsSW5zdGFuY2UucmVwbGFjZTtcbiAgICAgICAgICAgICAgaW50ZXJuYWxJbnN0YW5jZS5xdWV1ZSA9IG51bGw7XG4gICAgICAgICAgICAgIGludGVybmFsSW5zdGFuY2UucmVwbGFjZSA9ICExO1xuICAgICAgICAgICAgICBpZiAob2xkUmVwbGFjZSAmJiAxID09PSBvbGRRdWV1ZS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgaW5zdGFuY2Uuc3RhdGUgPSBvbGRRdWV1ZVswXTtcbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICAgIHZhciBuZXh0U3RhdGUgPSBvbGRSZXBsYWNlID8gb2xkUXVldWVbMF0gOiBpbnN0YW5jZS5zdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgZG9udE11dGF0ZSA9ICEwLFxuICAgICAgICAgICAgICAgICAgICBpID0gb2xkUmVwbGFjZSA/IDEgOiAwO1xuICAgICAgICAgICAgICAgICAgaSA8IG9sZFF1ZXVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgIGkrK1xuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgdmFyIHBhcnRpYWwgPSBvbGRRdWV1ZVtpXSxcbiAgICAgICAgICAgICAgICAgICAgcGFydGlhbFN0YXRlJGpzY29tcCQwID1cbiAgICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBwYXJ0aWFsXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHBhcnRpYWwuY2FsbChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0U3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBwYXJ0aWFsO1xuICAgICAgICAgICAgICAgICAgbnVsbCAhPSBwYXJ0aWFsU3RhdGUkanNjb21wJDAgJiZcbiAgICAgICAgICAgICAgICAgICAgKGRvbnRNdXRhdGVcbiAgICAgICAgICAgICAgICAgICAgICA/ICgoZG9udE11dGF0ZSA9ICExKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIChuZXh0U3RhdGUgPSBhc3NpZ24oXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0U3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWxTdGF0ZSRqc2NvbXAkMFxuICAgICAgICAgICAgICAgICAgICAgICAgKSkpXG4gICAgICAgICAgICAgICAgICAgICAgOiBhc3NpZ24obmV4dFN0YXRlLCBwYXJ0aWFsU3RhdGUkanNjb21wJDApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5zdGFuY2Uuc3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpbnRlcm5hbEluc3RhbmNlLnF1ZXVlID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG5leHRDaGlsZHJlbiA9IGNhbGxSZW5kZXJJbkRFVihpbnN0YW5jZSk7XG4gICAgICAgICAgaWYgKDEyID09PSByZXF1ZXN0LnN0YXR1cykgdGhyb3cgbnVsbDtcbiAgICAgICAgICBpbnN0YW5jZS5wcm9wcyAhPT0gcmVzb2x2ZWRQcm9wcyAmJlxuICAgICAgICAgICAgKGRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMgfHxcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIkl0IGxvb2tzIGxpa2UgJXMgaXMgcmVhc3NpZ25pbmcgaXRzIG93biBgdGhpcy5wcm9wc2Agd2hpbGUgcmVuZGVyaW5nLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQgYW5kIGNhbiBsZWFkIHRvIGNvbmZ1c2luZyBidWdzLlwiLFxuICAgICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCBcImEgY29tcG9uZW50XCJcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIChkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzID0gITApKTtcbiAgICAgICAgICB2YXIgcHJldktleVBhdGggPSB0YXNrLmtleVBhdGg7XG4gICAgICAgICAgdGFzay5rZXlQYXRoID0ga2V5UGF0aDtcbiAgICAgICAgICByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgbmV4dENoaWxkcmVuLCAtMSk7XG4gICAgICAgICAgdGFzay5rZXlQYXRoID0gcHJldktleVBhdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHR5cGUucHJvdG90eXBlICYmIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUucHJvdG90eXBlLnJlbmRlcikge1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUkanNjb21wJDMgPVxuICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgXCJVbmtub3duXCI7XG4gICAgICAgICAgICBkaWRXYXJuQWJvdXRCYWRDbGFzc1tjb21wb25lbnROYW1lJGpzY29tcCQzXSB8fFxuICAgICAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIlRoZSA8JXMgLz4gY29tcG9uZW50IGFwcGVhcnMgdG8gaGF2ZSBhIHJlbmRlciBtZXRob2QsIGJ1dCBkb2Vzbid0IGV4dGVuZCBSZWFjdC5Db21wb25lbnQuIFRoaXMgaXMgbGlrZWx5IHRvIGNhdXNlIGVycm9ycy4gQ2hhbmdlICVzIHRvIGV4dGVuZCBSZWFjdC5Db21wb25lbnQgaW5zdGVhZC5cIixcbiAgICAgICAgICAgICAgICBjb21wb25lbnROYW1lJGpzY29tcCQzLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudE5hbWUkanNjb21wJDNcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgKGRpZFdhcm5BYm91dEJhZENsYXNzW2NvbXBvbmVudE5hbWUkanNjb21wJDNdID0gITApKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHZhbHVlID0gcmVuZGVyV2l0aEhvb2tzKFxuICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgIHRhc2ssXG4gICAgICAgICAgICBrZXlQYXRoLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgdm9pZCAwXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoMTIgPT09IHJlcXVlc3Quc3RhdHVzKSB0aHJvdyBudWxsO1xuICAgICAgICAgIHZhciBoYXNJZCA9IDAgIT09IGxvY2FsSWRDb3VudGVyLFxuICAgICAgICAgICAgYWN0aW9uU3RhdGVDb3VudCA9IGFjdGlvblN0YXRlQ291bnRlcixcbiAgICAgICAgICAgIGFjdGlvblN0YXRlTWF0Y2hpbmdJbmRleCRqc2NvbXAkMCA9IGFjdGlvblN0YXRlTWF0Y2hpbmdJbmRleDtcbiAgICAgICAgICBpZiAodHlwZS5jb250ZXh0VHlwZXMpIHtcbiAgICAgICAgICAgIHZhciBfY29tcG9uZW50TmFtZSRqc2NvbXAkMCA9XG4gICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCBcIlVua25vd25cIjtcbiAgICAgICAgICAgIGRpZFdhcm5BYm91dENvbnRleHRUeXBlc1tfY29tcG9uZW50TmFtZSRqc2NvbXAkMF0gfHxcbiAgICAgICAgICAgICAgKChkaWRXYXJuQWJvdXRDb250ZXh0VHlwZXNbX2NvbXBvbmVudE5hbWUkanNjb21wJDBdID0gITApLFxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiJXMgdXNlcyB0aGUgbGVnYWN5IGNvbnRleHRUeXBlcyBBUEkgd2hpY2ggd2FzIHJlbW92ZWQgaW4gUmVhY3QgMTkuIFVzZSBSZWFjdC5jcmVhdGVDb250ZXh0KCkgd2l0aCBSZWFjdC51c2VDb250ZXh0KCkgaW5zdGVhZC4gKGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvbGVnYWN5LWNvbnRleHQpXCIsXG4gICAgICAgICAgICAgICAgX2NvbXBvbmVudE5hbWUkanNjb21wJDBcbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHR5cGUgJiZcbiAgICAgICAgICAgIHR5cGUuY2hpbGRDb250ZXh0VHlwZXMgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiY2hpbGRDb250ZXh0VHlwZXMgY2Fubm90IGJlIGRlZmluZWQgb24gYSBmdW5jdGlvbiBjb21wb25lbnQuXFxuICAlcy5jaGlsZENvbnRleHRUeXBlcyA9IC4uLlwiLFxuICAgICAgICAgICAgICB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBcIkNvbXBvbmVudFwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcykge1xuICAgICAgICAgICAgdmFyIF9jb21wb25lbnROYW1lMiA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCBcIlVua25vd25cIjtcbiAgICAgICAgICAgIGRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnRbX2NvbXBvbmVudE5hbWUyXSB8fFxuICAgICAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIiVzOiBGdW5jdGlvbiBjb21wb25lbnRzIGRvIG5vdCBzdXBwb3J0IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy5cIixcbiAgICAgICAgICAgICAgICBfY29tcG9uZW50TmFtZTJcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgKGRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnRbX2NvbXBvbmVudE5hbWUyXSA9XG4gICAgICAgICAgICAgICAgITApKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUuY29udGV4dFR5cGUgJiZcbiAgICAgICAgICAgIG51bGwgIT09IHR5cGUuY29udGV4dFR5cGVcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciBfY29tcG9uZW50TmFtZTMgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgXCJVbmtub3duXCI7XG4gICAgICAgICAgICBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnRbX2NvbXBvbmVudE5hbWUzXSB8fFxuICAgICAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIiVzOiBGdW5jdGlvbiBjb21wb25lbnRzIGRvIG5vdCBzdXBwb3J0IGNvbnRleHRUeXBlLlwiLFxuICAgICAgICAgICAgICAgIF9jb21wb25lbnROYW1lM1xuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAoZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lM10gPVxuICAgICAgICAgICAgICAgICEwKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZpbmlzaEZ1bmN0aW9uQ29tcG9uZW50KFxuICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgIHRhc2ssXG4gICAgICAgICAgICBrZXlQYXRoLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBoYXNJZCxcbiAgICAgICAgICAgIGFjdGlvblN0YXRlQ291bnQsXG4gICAgICAgICAgICBhY3Rpb25TdGF0ZU1hdGNoaW5nSW5kZXgkanNjb21wJDBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICBlbHNlIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZSkge1xuICAgICAgICB2YXIgc2VnbWVudCA9IHRhc2suYmxvY2tlZFNlZ21lbnQ7XG4gICAgICAgIGlmIChudWxsID09PSBzZWdtZW50KSB7XG4gICAgICAgICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICAgICAgICBwcmV2Q29udGV4dCA9IHRhc2suZm9ybWF0Q29udGV4dCxcbiAgICAgICAgICAgIHByZXZLZXlQYXRoJGpzY29tcCQwID0gdGFzay5rZXlQYXRoO1xuICAgICAgICAgIHRhc2suZm9ybWF0Q29udGV4dCA9IGdldENoaWxkRm9ybWF0Q29udGV4dChwcmV2Q29udGV4dCwgdHlwZSwgcHJvcHMpO1xuICAgICAgICAgIHRhc2sua2V5UGF0aCA9IGtleVBhdGg7XG4gICAgICAgICAgcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBjaGlsZHJlbiwgLTEpO1xuICAgICAgICAgIHRhc2suZm9ybWF0Q29udGV4dCA9IHByZXZDb250ZXh0O1xuICAgICAgICAgIHRhc2sua2V5UGF0aCA9IHByZXZLZXlQYXRoJGpzY29tcCQwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfY2hpbGRyZW4gPSBwdXNoU3RhcnRJbnN0YW5jZShcbiAgICAgICAgICAgIHNlZ21lbnQuY2h1bmtzLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgcmVxdWVzdC5yZXN1bWFibGVTdGF0ZSxcbiAgICAgICAgICAgIHJlcXVlc3QucmVuZGVyU3RhdGUsXG4gICAgICAgICAgICB0YXNrLmhvaXN0YWJsZVN0YXRlLFxuICAgICAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0LFxuICAgICAgICAgICAgc2VnbWVudC5sYXN0UHVzaGVkVGV4dCxcbiAgICAgICAgICAgIHRhc2suaXNGYWxsYmFja1xuICAgICAgICAgICk7XG4gICAgICAgICAgc2VnbWVudC5sYXN0UHVzaGVkVGV4dCA9ICExO1xuICAgICAgICAgIHZhciBfcHJldkNvbnRleHQgPSB0YXNrLmZvcm1hdENvbnRleHQsXG4gICAgICAgICAgICBfcHJldktleVBhdGgyID0gdGFzay5rZXlQYXRoO1xuICAgICAgICAgIHRhc2suZm9ybWF0Q29udGV4dCA9IGdldENoaWxkRm9ybWF0Q29udGV4dChfcHJldkNvbnRleHQsIHR5cGUsIHByb3BzKTtcbiAgICAgICAgICB0YXNrLmtleVBhdGggPSBrZXlQYXRoO1xuICAgICAgICAgIHJlbmRlck5vZGUocmVxdWVzdCwgdGFzaywgX2NoaWxkcmVuLCAtMSk7XG4gICAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0ID0gX3ByZXZDb250ZXh0O1xuICAgICAgICAgIHRhc2sua2V5UGF0aCA9IF9wcmV2S2V5UGF0aDI7XG4gICAgICAgICAgYToge1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHNlZ21lbnQuY2h1bmtzLFxuICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZSA9IHJlcXVlc3QucmVzdW1hYmxlU3RhdGU7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcInRpdGxlXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgICAgICAgICBjYXNlIFwic2NyaXB0XCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJhcmVhXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJiYXNlXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJiclwiOlxuICAgICAgICAgICAgICBjYXNlIFwiY29sXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbWJlZFwiOlxuICAgICAgICAgICAgICBjYXNlIFwiaHJcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImltZ1wiOlxuICAgICAgICAgICAgICBjYXNlIFwiaW5wdXRcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImtleWdlblwiOlxuICAgICAgICAgICAgICBjYXNlIFwibGlua1wiOlxuICAgICAgICAgICAgICBjYXNlIFwibWV0YVwiOlxuICAgICAgICAgICAgICBjYXNlIFwicGFyYW1cIjpcbiAgICAgICAgICAgICAgY2FzZSBcInNvdXJjZVwiOlxuICAgICAgICAgICAgICBjYXNlIFwidHJhY2tcIjpcbiAgICAgICAgICAgICAgY2FzZSBcIndiclwiOlxuICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIGNhc2UgXCJib2R5XCI6XG4gICAgICAgICAgICAgICAgaWYgKF9wcmV2Q29udGV4dC5pbnNlcnRpb25Nb2RlIDw9IEhUTUxfSFRNTF9NT0RFKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZS5oYXNCb2R5ID0gITA7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcImh0bWxcIjpcbiAgICAgICAgICAgICAgICBpZiAoX3ByZXZDb250ZXh0Lmluc2VydGlvbk1vZGUgPT09IFJPT1RfSFRNTF9NT0RFKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZS5oYXNIdG1sID0gITA7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhcmdldC5wdXNoKGVuZENodW5rRm9yVGFnKHR5cGUpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VnbWVudC5sYXN0UHVzaGVkVGV4dCA9ICExO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICAgICAgdmFyIHByZXZLZXlQYXRoJGpzY29tcCQxID0gdGFzay5rZXlQYXRoO1xuICAgICAgICAgICAgdGFzay5rZXlQYXRoID0ga2V5UGF0aDtcbiAgICAgICAgICAgIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBwcm9wcy5jaGlsZHJlbiwgLTEpO1xuICAgICAgICAgICAgdGFzay5rZXlQYXRoID0gcHJldktleVBhdGgkanNjb21wJDE7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgY2FzZSBSRUFDVF9PRkZTQ1JFRU5fVFlQRTpcbiAgICAgICAgICAgIGlmIChcImhpZGRlblwiICE9PSBwcm9wcy5tb2RlKSB7XG4gICAgICAgICAgICAgIHZhciBwcmV2S2V5UGF0aCRqc2NvbXAkMiA9IHRhc2sua2V5UGF0aDtcbiAgICAgICAgICAgICAgdGFzay5rZXlQYXRoID0ga2V5UGF0aDtcbiAgICAgICAgICAgICAgcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIHByb3BzLmNoaWxkcmVuLCAtMSk7XG4gICAgICAgICAgICAgIHRhc2sua2V5UGF0aCA9IHByZXZLZXlQYXRoJGpzY29tcCQyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgICAgdmFyIF9wcmV2S2V5UGF0aDMgPSB0YXNrLmtleVBhdGg7XG4gICAgICAgICAgICB0YXNrLmtleVBhdGggPSBrZXlQYXRoO1xuICAgICAgICAgICAgcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIHByb3BzLmNoaWxkcmVuLCAtMSk7XG4gICAgICAgICAgICB0YXNrLmtleVBhdGggPSBfcHJldktleVBhdGgzO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfU0NPUEVfVFlQRTpcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICBcIlJlYWN0RE9NU2VydmVyIGRvZXMgbm90IHlldCBzdXBwb3J0IHNjb3BlIGNvbXBvbmVudHMuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgICAgYTogaWYgKG51bGwgIT09IHRhc2sucmVwbGF5KSB7XG4gICAgICAgICAgICAgIHZhciBfcHJldktleVBhdGggPSB0YXNrLmtleVBhdGg7XG4gICAgICAgICAgICAgIHRhc2sua2V5UGF0aCA9IGtleVBhdGg7XG4gICAgICAgICAgICAgIHZhciBfY29udGVudCA9IHByb3BzLmNoaWxkcmVuO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlbmRlck5vZGUocmVxdWVzdCwgdGFzaywgX2NvbnRlbnQsIC0xKTtcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0YXNrLmtleVBhdGggPSBfcHJldktleVBhdGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBwcmV2S2V5UGF0aCRqc2NvbXAkMyA9IHRhc2sua2V5UGF0aCxcbiAgICAgICAgICAgICAgICBwYXJlbnRCb3VuZGFyeSA9IHRhc2suYmxvY2tlZEJvdW5kYXJ5LFxuICAgICAgICAgICAgICAgIHBhcmVudEhvaXN0YWJsZVN0YXRlID0gdGFzay5ob2lzdGFibGVTdGF0ZSxcbiAgICAgICAgICAgICAgICBwYXJlbnRTZWdtZW50ID0gdGFzay5ibG9ja2VkU2VnbWVudCxcbiAgICAgICAgICAgICAgICBmYWxsYmFjayA9IHByb3BzLmZhbGxiYWNrLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgICAgICAgICAgICBmYWxsYmFja0Fib3J0U2V0ID0gbmV3IFNldCgpLFxuICAgICAgICAgICAgICAgIG5ld0JvdW5kYXJ5ID0gY3JlYXRlU3VzcGVuc2VCb3VuZGFyeShyZXF1ZXN0LCBmYWxsYmFja0Fib3J0U2V0KTtcbiAgICAgICAgICAgICAgbnVsbCAhPT0gcmVxdWVzdC50cmFja2VkUG9zdHBvbmVzICYmXG4gICAgICAgICAgICAgICAgKG5ld0JvdW5kYXJ5LnRyYWNrZWRDb250ZW50S2V5UGF0aCA9IGtleVBhdGgpO1xuICAgICAgICAgICAgICB2YXIgYm91bmRhcnlTZWdtZW50ID0gY3JlYXRlUGVuZGluZ1NlZ21lbnQoXG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICBwYXJlbnRTZWdtZW50LmNodW5rcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgbmV3Qm91bmRhcnksXG4gICAgICAgICAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0LFxuICAgICAgICAgICAgICAgICExLFxuICAgICAgICAgICAgICAgICExXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHBhcmVudFNlZ21lbnQuY2hpbGRyZW4ucHVzaChib3VuZGFyeVNlZ21lbnQpO1xuICAgICAgICAgICAgICBwYXJlbnRTZWdtZW50Lmxhc3RQdXNoZWRUZXh0ID0gITE7XG4gICAgICAgICAgICAgIHZhciBjb250ZW50Um9vdFNlZ21lbnQgPSBjcmVhdGVQZW5kaW5nU2VnbWVudChcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQsXG4gICAgICAgICAgICAgICAgITEsXG4gICAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgY29udGVudFJvb3RTZWdtZW50LnBhcmVudEZsdXNoZWQgPSAhMDtcbiAgICAgICAgICAgICAgaWYgKG51bGwgIT09IHJlcXVlc3QudHJhY2tlZFBvc3Rwb25lcykge1xuICAgICAgICAgICAgICAgIHZhciBmYWxsYmFja0tleVBhdGggPSBbXG4gICAgICAgICAgICAgICAgICAgIGtleVBhdGhbMF0sXG4gICAgICAgICAgICAgICAgICAgIFwiU3VzcGVuc2UgRmFsbGJhY2tcIixcbiAgICAgICAgICAgICAgICAgICAga2V5UGF0aFsyXVxuICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgIGZhbGxiYWNrUmVwbGF5Tm9kZSA9IFtcbiAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2tLZXlQYXRoWzFdLFxuICAgICAgICAgICAgICAgICAgICBmYWxsYmFja0tleVBhdGhbMl0sXG4gICAgICAgICAgICAgICAgICAgIFtdLFxuICAgICAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIHJlcXVlc3QudHJhY2tlZFBvc3Rwb25lcy53b3JraW5nTWFwLnNldChcbiAgICAgICAgICAgICAgICAgIGZhbGxiYWNrS2V5UGF0aCxcbiAgICAgICAgICAgICAgICAgIGZhbGxiYWNrUmVwbGF5Tm9kZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgbmV3Qm91bmRhcnkudHJhY2tlZEZhbGxiYWNrTm9kZSA9IGZhbGxiYWNrUmVwbGF5Tm9kZTtcbiAgICAgICAgICAgICAgICB0YXNrLmJsb2NrZWRTZWdtZW50ID0gYm91bmRhcnlTZWdtZW50O1xuICAgICAgICAgICAgICAgIHRhc2sua2V5UGF0aCA9IGZhbGxiYWNrS2V5UGF0aDtcbiAgICAgICAgICAgICAgICBib3VuZGFyeVNlZ21lbnQuc3RhdHVzID0gNjtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBmYWxsYmFjaywgLTEpLFxuICAgICAgICAgICAgICAgICAgICBwdXNoU2VnbWVudEZpbmFsZShcbiAgICAgICAgICAgICAgICAgICAgICBib3VuZGFyeVNlZ21lbnQuY2h1bmtzLFxuICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QucmVuZGVyU3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgYm91bmRhcnlTZWdtZW50Lmxhc3RQdXNoZWRUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgIGJvdW5kYXJ5U2VnbWVudC50ZXh0RW1iZWRkZWRcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgKGJvdW5kYXJ5U2VnbWVudC5zdGF0dXMgPSBDT01QTEVURUQpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHRocm93blZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyAoXG4gICAgICAgICAgICAgICAgICAgICgoYm91bmRhcnlTZWdtZW50LnN0YXR1cyA9IDEyID09PSByZXF1ZXN0LnN0YXR1cyA/IDMgOiA0KSxcbiAgICAgICAgICAgICAgICAgICAgdGhyb3duVmFsdWUpXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAodGFzay5ibG9ja2VkU2VnbWVudCA9IHBhcmVudFNlZ21lbnQpLFxuICAgICAgICAgICAgICAgICAgICAodGFzay5rZXlQYXRoID0gcHJldktleVBhdGgkanNjb21wJDMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgc3VzcGVuZGVkUHJpbWFyeVRhc2sgPSBjcmVhdGVSZW5kZXJUYXNrKFxuICAgICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgICAgICAgICAgLTEsXG4gICAgICAgICAgICAgICAgICBuZXdCb3VuZGFyeSxcbiAgICAgICAgICAgICAgICAgIGNvbnRlbnRSb290U2VnbWVudCxcbiAgICAgICAgICAgICAgICAgIG5ld0JvdW5kYXJ5LmNvbnRlbnRTdGF0ZSxcbiAgICAgICAgICAgICAgICAgIHRhc2suYWJvcnRTZXQsXG4gICAgICAgICAgICAgICAgICBrZXlQYXRoLFxuICAgICAgICAgICAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0LFxuICAgICAgICAgICAgICAgICAgdGFzay5jb250ZXh0LFxuICAgICAgICAgICAgICAgICAgdGFzay50cmVlQ29udGV4dCxcbiAgICAgICAgICAgICAgICAgIHRhc2suY29tcG9uZW50U3RhY2ssXG4gICAgICAgICAgICAgICAgICB0YXNrLmlzRmFsbGJhY2tcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHB1c2hDb21wb25lbnRTdGFjayhzdXNwZW5kZWRQcmltYXJ5VGFzayk7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5waW5nZWRUYXNrcy5wdXNoKHN1c3BlbmRlZFByaW1hcnlUYXNrKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXNrLmJsb2NrZWRCb3VuZGFyeSA9IG5ld0JvdW5kYXJ5O1xuICAgICAgICAgICAgICAgIHRhc2suaG9pc3RhYmxlU3RhdGUgPSBuZXdCb3VuZGFyeS5jb250ZW50U3RhdGU7XG4gICAgICAgICAgICAgICAgdGFzay5ibG9ja2VkU2VnbWVudCA9IGNvbnRlbnRSb290U2VnbWVudDtcbiAgICAgICAgICAgICAgICB0YXNrLmtleVBhdGggPSBrZXlQYXRoO1xuICAgICAgICAgICAgICAgIGNvbnRlbnRSb290U2VnbWVudC5zdGF0dXMgPSA2O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIChyZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIGNvbnRlbnQsIC0xKSxcbiAgICAgICAgICAgICAgICAgICAgcHVzaFNlZ21lbnRGaW5hbGUoXG4gICAgICAgICAgICAgICAgICAgICAgY29udGVudFJvb3RTZWdtZW50LmNodW5rcyxcbiAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnJlbmRlclN0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRSb290U2VnbWVudC5sYXN0UHVzaGVkVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICBjb250ZW50Um9vdFNlZ21lbnQudGV4dEVtYmVkZGVkXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIChjb250ZW50Um9vdFNlZ21lbnQuc3RhdHVzID0gQ09NUExFVEVEKSxcbiAgICAgICAgICAgICAgICAgICAgcXVldWVDb21wbGV0ZWRTZWdtZW50KG5ld0JvdW5kYXJ5LCBjb250ZW50Um9vdFNlZ21lbnQpLFxuICAgICAgICAgICAgICAgICAgICAwID09PSBuZXdCb3VuZGFyeS5wZW5kaW5nVGFza3MgJiZcbiAgICAgICAgICAgICAgICAgICAgICBuZXdCb3VuZGFyeS5zdGF0dXMgPT09IFBFTkRJTkcpXG4gICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3Qm91bmRhcnkuc3RhdHVzID0gQ09NUExFVEVEO1xuICAgICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHRocm93blZhbHVlJDIpIHtcbiAgICAgICAgICAgICAgICAgIG5ld0JvdW5kYXJ5LnN0YXR1cyA9IENMSUVOVF9SRU5ERVJFRDtcbiAgICAgICAgICAgICAgICAgIGlmICgxMiA9PT0gcmVxdWVzdC5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudFJvb3RTZWdtZW50LnN0YXR1cyA9IDM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IHJlcXVlc3QuZmF0YWxFcnJvcjtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICAoY29udGVudFJvb3RTZWdtZW50LnN0YXR1cyA9IDQpLCAoZXJyb3IgPSB0aHJvd25WYWx1ZSQyKTtcbiAgICAgICAgICAgICAgICAgIHZhciB0aHJvd25JbmZvID0gZ2V0VGhyb3duSW5mbyh0YXNrLmNvbXBvbmVudFN0YWNrKTtcbiAgICAgICAgICAgICAgICAgIHZhciBlcnJvckRpZ2VzdCA9IGxvZ1JlY292ZXJhYmxlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgICAgICB0aHJvd25JbmZvXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgZW5jb2RlRXJyb3JGb3JCb3VuZGFyeShcbiAgICAgICAgICAgICAgICAgICAgbmV3Qm91bmRhcnksXG4gICAgICAgICAgICAgICAgICAgIGVycm9yRGlnZXN0LFxuICAgICAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgdGhyb3duSW5mbyxcbiAgICAgICAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICB1bnRyYWNrQm91bmRhcnkocmVxdWVzdCwgbmV3Qm91bmRhcnkpO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAodGFzay5ibG9ja2VkQm91bmRhcnkgPSBwYXJlbnRCb3VuZGFyeSksXG4gICAgICAgICAgICAgICAgICAgICh0YXNrLmhvaXN0YWJsZVN0YXRlID0gcGFyZW50SG9pc3RhYmxlU3RhdGUpLFxuICAgICAgICAgICAgICAgICAgICAodGFzay5ibG9ja2VkU2VnbWVudCA9IHBhcmVudFNlZ21lbnQpLFxuICAgICAgICAgICAgICAgICAgICAodGFzay5rZXlQYXRoID0gcHJldktleVBhdGgkanNjb21wJDMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgc3VzcGVuZGVkRmFsbGJhY2tUYXNrID0gY3JlYXRlUmVuZGVyVGFzayhcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgZmFsbGJhY2ssXG4gICAgICAgICAgICAgICAgICAtMSxcbiAgICAgICAgICAgICAgICAgIHBhcmVudEJvdW5kYXJ5LFxuICAgICAgICAgICAgICAgICAgYm91bmRhcnlTZWdtZW50LFxuICAgICAgICAgICAgICAgICAgbmV3Qm91bmRhcnkuZmFsbGJhY2tTdGF0ZSxcbiAgICAgICAgICAgICAgICAgIGZhbGxiYWNrQWJvcnRTZXQsXG4gICAgICAgICAgICAgICAgICBba2V5UGF0aFswXSwgXCJTdXNwZW5zZSBGYWxsYmFja1wiLCBrZXlQYXRoWzJdXSxcbiAgICAgICAgICAgICAgICAgIHRhc2suZm9ybWF0Q29udGV4dCxcbiAgICAgICAgICAgICAgICAgIHRhc2suY29udGV4dCxcbiAgICAgICAgICAgICAgICAgIHRhc2sudHJlZUNvbnRleHQsXG4gICAgICAgICAgICAgICAgICB0YXNrLmNvbXBvbmVudFN0YWNrLFxuICAgICAgICAgICAgICAgICAgITBcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHB1c2hDb21wb25lbnRTdGFjayhzdXNwZW5kZWRGYWxsYmFja1Rhc2spO1xuICAgICAgICAgICAgICAgIHJlcXVlc3QucGluZ2VkVGFza3MucHVzaChzdXNwZW5kZWRGYWxsYmFja1Rhc2spO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlICYmIG51bGwgIT09IHR5cGUpXG4gICAgICAgICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICAgIGlmIChcInJlZlwiIGluIHByb3BzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb3BzV2l0aG91dFJlZiA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wcylcbiAgICAgICAgICAgICAgICAgIFwicmVmXCIgIT09IGtleSAmJiAocHJvcHNXaXRob3V0UmVmW2tleV0gPSBwcm9wc1trZXldKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHByb3BzV2l0aG91dFJlZiA9IHByb3BzO1xuICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4kanNjb21wJDAgPSByZW5kZXJXaXRoSG9va3MoXG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICB0YXNrLFxuICAgICAgICAgICAgICAgIGtleVBhdGgsXG4gICAgICAgICAgICAgICAgdHlwZS5yZW5kZXIsXG4gICAgICAgICAgICAgICAgcHJvcHNXaXRob3V0UmVmLFxuICAgICAgICAgICAgICAgIHJlZlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBmaW5pc2hGdW5jdGlvbkNvbXBvbmVudChcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIHRhc2ssXG4gICAgICAgICAgICAgICAga2V5UGF0aCxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbiRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAwICE9PSBsb2NhbElkQ291bnRlcixcbiAgICAgICAgICAgICAgICBhY3Rpb25TdGF0ZUNvdW50ZXIsXG4gICAgICAgICAgICAgICAgYWN0aW9uU3RhdGVNYXRjaGluZ0luZGV4XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgICByZW5kZXJFbGVtZW50KHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIHR5cGUudHlwZSwgcHJvcHMsIHJlZik7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgICB2YXIgdmFsdWUkanNjb21wJDAgPSBwcm9wcy52YWx1ZSxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbiRqc2NvbXAkMSA9IHByb3BzLmNoaWxkcmVuO1xuICAgICAgICAgICAgICB2YXIgcHJldlNuYXBzaG90ID0gdGFzay5jb250ZXh0O1xuICAgICAgICAgICAgICB2YXIgcHJldktleVBhdGgkanNjb21wJDQgPSB0YXNrLmtleVBhdGg7XG4gICAgICAgICAgICAgIHZhciBwcmV2VmFsdWUgPSB0eXBlLl9jdXJyZW50VmFsdWUyO1xuICAgICAgICAgICAgICB0eXBlLl9jdXJyZW50VmFsdWUyID0gdmFsdWUkanNjb21wJDA7XG4gICAgICAgICAgICAgIHZvaWQgMCAhPT0gdHlwZS5fY3VycmVudFJlbmRlcmVyMiAmJlxuICAgICAgICAgICAgICAgIG51bGwgIT09IHR5cGUuX2N1cnJlbnRSZW5kZXJlcjIgJiZcbiAgICAgICAgICAgICAgICB0eXBlLl9jdXJyZW50UmVuZGVyZXIyICE9PSByZW5kZXJlclNpZ2lsICYmXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiRGV0ZWN0ZWQgbXVsdGlwbGUgcmVuZGVyZXJzIGNvbmN1cnJlbnRseSByZW5kZXJpbmcgdGhlIHNhbWUgY29udGV4dCBwcm92aWRlci4gVGhpcyBpcyBjdXJyZW50bHkgdW5zdXBwb3J0ZWQuXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB0eXBlLl9jdXJyZW50UmVuZGVyZXIyID0gcmVuZGVyZXJTaWdpbDtcbiAgICAgICAgICAgICAgdmFyIHByZXZOb2RlID0gY3VycmVudEFjdGl2ZVNuYXBzaG90LFxuICAgICAgICAgICAgICAgIG5ld05vZGUgPSB7XG4gICAgICAgICAgICAgICAgICBwYXJlbnQ6IHByZXZOb2RlLFxuICAgICAgICAgICAgICAgICAgZGVwdGg6IG51bGwgPT09IHByZXZOb2RlID8gMCA6IHByZXZOb2RlLmRlcHRoICsgMSxcbiAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHR5cGUsXG4gICAgICAgICAgICAgICAgICBwYXJlbnRWYWx1ZTogcHJldlZhbHVlLFxuICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlJGpzY29tcCQwXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgY3VycmVudEFjdGl2ZVNuYXBzaG90ID0gbmV3Tm9kZTtcbiAgICAgICAgICAgICAgdGFzay5jb250ZXh0ID0gbmV3Tm9kZTtcbiAgICAgICAgICAgICAgdGFzay5rZXlQYXRoID0ga2V5UGF0aDtcbiAgICAgICAgICAgICAgcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIGNoaWxkcmVuJGpzY29tcCQxLCAtMSk7XG4gICAgICAgICAgICAgIHZhciBwcmV2U25hcHNob3QkanNjb21wJDAgPSBjdXJyZW50QWN0aXZlU25hcHNob3Q7XG4gICAgICAgICAgICAgIGlmIChudWxsID09PSBwcmV2U25hcHNob3QkanNjb21wJDApXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlRyaWVkIHRvIHBvcCBhIENvbnRleHQgYXQgdGhlIHJvb3Qgb2YgdGhlIGFwcC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHByZXZTbmFwc2hvdCRqc2NvbXAkMC5jb250ZXh0ICE9PSB0eXBlICYmXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiVGhlIHBhcmVudCBjb250ZXh0IGlzIG5vdCB0aGUgZXhwZWN0ZWQgY29udGV4dC4gVGhpcyBpcyBwcm9iYWJseSBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHByZXZTbmFwc2hvdCRqc2NvbXAkMC5jb250ZXh0Ll9jdXJyZW50VmFsdWUyID1cbiAgICAgICAgICAgICAgICBwcmV2U25hcHNob3QkanNjb21wJDAucGFyZW50VmFsdWU7XG4gICAgICAgICAgICAgIHZvaWQgMCAhPT0gdHlwZS5fY3VycmVudFJlbmRlcmVyMiAmJlxuICAgICAgICAgICAgICAgIG51bGwgIT09IHR5cGUuX2N1cnJlbnRSZW5kZXJlcjIgJiZcbiAgICAgICAgICAgICAgICB0eXBlLl9jdXJyZW50UmVuZGVyZXIyICE9PSByZW5kZXJlclNpZ2lsICYmXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiRGV0ZWN0ZWQgbXVsdGlwbGUgcmVuZGVyZXJzIGNvbmN1cnJlbnRseSByZW5kZXJpbmcgdGhlIHNhbWUgY29udGV4dCBwcm92aWRlci4gVGhpcyBpcyBjdXJyZW50bHkgdW5zdXBwb3J0ZWQuXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB0eXBlLl9jdXJyZW50UmVuZGVyZXIyID0gcmVuZGVyZXJTaWdpbDtcbiAgICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMCA9IChjdXJyZW50QWN0aXZlU25hcHNob3QgPVxuICAgICAgICAgICAgICAgIHByZXZTbmFwc2hvdCRqc2NvbXAkMC5wYXJlbnQpO1xuICAgICAgICAgICAgICB0YXNrLmNvbnRleHQgPSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDA7XG4gICAgICAgICAgICAgIHRhc2sua2V5UGF0aCA9IHByZXZLZXlQYXRoJGpzY29tcCQ0O1xuICAgICAgICAgICAgICBwcmV2U25hcHNob3QgIT09IHRhc2suY29udGV4dCAmJlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlBvcHBpbmcgdGhlIGNvbnRleHQgcHJvdmlkZXIgZGlkIG5vdCByZXR1cm4gYmFjayB0byB0aGUgb3JpZ2luYWwgc25hcHNob3QuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIFJFQUNUX0NPTlNVTUVSX1RZUEU6XG4gICAgICAgICAgICAgIHZhciBjb250ZXh0JGpzY29tcCQwID0gdHlwZS5fY29udGV4dCxcbiAgICAgICAgICAgICAgICByZW5kZXIgPSBwcm9wcy5jaGlsZHJlbjtcbiAgICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgcmVuZGVyICYmXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiQSBjb250ZXh0IGNvbnN1bWVyIHdhcyByZW5kZXJlZCB3aXRoIG11bHRpcGxlIGNoaWxkcmVuLCBvciBhIGNoaWxkIHRoYXQgaXNuJ3QgYSBmdW5jdGlvbi4gQSBjb250ZXh0IGNvbnN1bWVyIGV4cGVjdHMgYSBzaW5nbGUgY2hpbGQgdGhhdCBpcyBhIGZ1bmN0aW9uLiBJZiB5b3UgZGlkIHBhc3MgYSBmdW5jdGlvbiwgbWFrZSBzdXJlIHRoZXJlIGlzIG5vIHRyYWlsaW5nIG9yIGxlYWRpbmcgd2hpdGVzcGFjZSBhcm91bmQgaXQuXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB2YXIgbmV3Q2hpbGRyZW4gPSByZW5kZXIoY29udGV4dCRqc2NvbXAkMC5fY3VycmVudFZhbHVlMiksXG4gICAgICAgICAgICAgICAgcHJldktleVBhdGgkanNjb21wJDUgPSB0YXNrLmtleVBhdGg7XG4gICAgICAgICAgICAgIHRhc2sua2V5UGF0aCA9IGtleVBhdGg7XG4gICAgICAgICAgICAgIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBuZXdDaGlsZHJlbiwgLTEpO1xuICAgICAgICAgICAgICB0YXNrLmtleVBhdGggPSBwcmV2S2V5UGF0aCRqc2NvbXAkNTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgIHZhciBDb21wb25lbnQgPSBjYWxsTGF6eUluaXRJbkRFVih0eXBlKTtcbiAgICAgICAgICAgICAgaWYgKDEyID09PSByZXF1ZXN0LnN0YXR1cykgdGhyb3cgbnVsbDtcbiAgICAgICAgICAgICAgcmVuZGVyRWxlbWVudChyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCBDb21wb25lbnQsIHByb3BzLCByZWYpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB2YXIgaW5mbyA9IFwiXCI7XG4gICAgICAgIGlmIChcbiAgICAgICAgICB2b2lkIDAgPT09IHR5cGUgfHxcbiAgICAgICAgICAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUgJiZcbiAgICAgICAgICAgIG51bGwgIT09IHR5cGUgJiZcbiAgICAgICAgICAgIDAgPT09IE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aClcbiAgICAgICAgKVxuICAgICAgICAgIGluZm8gKz1cbiAgICAgICAgICAgIFwiIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlIGl0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJFbGVtZW50IHR5cGUgaXMgaW52YWxpZDogZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciBidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlIGNvbXBvbmVudHMpIGJ1dCBnb3Q6IFwiICtcbiAgICAgICAgICAgICgobnVsbCA9PSB0eXBlID8gdHlwZSA6IHR5cGVvZiB0eXBlKSArIFwiLlwiICsgaW5mbylcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzdW1lTm9kZShyZXF1ZXN0LCB0YXNrLCBzZWdtZW50SWQsIG5vZGUsIGNoaWxkSW5kZXgpIHtcbiAgICAgIHZhciBwcmV2UmVwbGF5ID0gdGFzay5yZXBsYXksXG4gICAgICAgIGJsb2NrZWRCb3VuZGFyeSA9IHRhc2suYmxvY2tlZEJvdW5kYXJ5LFxuICAgICAgICByZXN1bWVkU2VnbWVudCA9IGNyZWF0ZVBlbmRpbmdTZWdtZW50KFxuICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgMCxcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHRhc2suZm9ybWF0Q29udGV4dCxcbiAgICAgICAgICAhMSxcbiAgICAgICAgICAhMVxuICAgICAgICApO1xuICAgICAgcmVzdW1lZFNlZ21lbnQuaWQgPSBzZWdtZW50SWQ7XG4gICAgICByZXN1bWVkU2VnbWVudC5wYXJlbnRGbHVzaGVkID0gITA7XG4gICAgICB0cnkge1xuICAgICAgICAodGFzay5yZXBsYXkgPSBudWxsKSxcbiAgICAgICAgICAodGFzay5ibG9ja2VkU2VnbWVudCA9IHJlc3VtZWRTZWdtZW50KSxcbiAgICAgICAgICByZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIG5vZGUsIGNoaWxkSW5kZXgpLFxuICAgICAgICAgIChyZXN1bWVkU2VnbWVudC5zdGF0dXMgPSBDT01QTEVURUQpLFxuICAgICAgICAgIG51bGwgPT09IGJsb2NrZWRCb3VuZGFyeVxuICAgICAgICAgICAgPyAocmVxdWVzdC5jb21wbGV0ZWRSb290U2VnbWVudCA9IHJlc3VtZWRTZWdtZW50KVxuICAgICAgICAgICAgOiAocXVldWVDb21wbGV0ZWRTZWdtZW50KGJsb2NrZWRCb3VuZGFyeSwgcmVzdW1lZFNlZ21lbnQpLFxuICAgICAgICAgICAgICBibG9ja2VkQm91bmRhcnkucGFyZW50Rmx1c2hlZCAmJlxuICAgICAgICAgICAgICAgIHJlcXVlc3QucGFydGlhbEJvdW5kYXJpZXMucHVzaChibG9ja2VkQm91bmRhcnkpKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICh0YXNrLnJlcGxheSA9IHByZXZSZXBsYXkpLCAodGFzay5ibG9ja2VkU2VnbWVudCA9IG51bGwpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgbm9kZSwgY2hpbGRJbmRleCkge1xuICAgICAgbnVsbCAhPT0gdGFzay5yZXBsYXkgJiYgXCJudW1iZXJcIiA9PT0gdHlwZW9mIHRhc2sucmVwbGF5LnNsb3RzXG4gICAgICAgID8gcmVzdW1lTm9kZShyZXF1ZXN0LCB0YXNrLCB0YXNrLnJlcGxheS5zbG90cywgbm9kZSwgY2hpbGRJbmRleClcbiAgICAgICAgOiAoKHRhc2subm9kZSA9IG5vZGUpLFxuICAgICAgICAgICh0YXNrLmNoaWxkSW5kZXggPSBjaGlsZEluZGV4KSxcbiAgICAgICAgICAobm9kZSA9IHRhc2suY29tcG9uZW50U3RhY2spLFxuICAgICAgICAgIHB1c2hDb21wb25lbnRTdGFjayh0YXNrKSxcbiAgICAgICAgICByZXRyeU5vZGUocmVxdWVzdCwgdGFzayksXG4gICAgICAgICAgKHRhc2suY29tcG9uZW50U3RhY2sgPSBub2RlKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJldHJ5Tm9kZShyZXF1ZXN0LCB0YXNrKSB7XG4gICAgICB2YXIgbm9kZSA9IHRhc2subm9kZSxcbiAgICAgICAgY2hpbGRJbmRleCA9IHRhc2suY2hpbGRJbmRleDtcbiAgICAgIGlmIChudWxsICE9PSBub2RlKSB7XG4gICAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2Ygbm9kZSkge1xuICAgICAgICAgIHN3aXRjaCAobm9kZS4kJHR5cGVvZikge1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgICAgIHZhciB0eXBlID0gbm9kZS50eXBlLFxuICAgICAgICAgICAgICAgIGtleSA9IG5vZGUua2V5LFxuICAgICAgICAgICAgICAgIHByb3BzID0gbm9kZS5wcm9wcztcbiAgICAgICAgICAgICAgbm9kZSA9IHByb3BzLnJlZjtcbiAgICAgICAgICAgICAgdmFyIHJlZiA9IHZvaWQgMCAhPT0gbm9kZSA/IG5vZGUgOiBudWxsLFxuICAgICAgICAgICAgICAgIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSksXG4gICAgICAgICAgICAgICAga2V5T3JJbmRleCA9XG4gICAgICAgICAgICAgICAgICBudWxsID09IGtleSA/ICgtMSA9PT0gY2hpbGRJbmRleCA/IDAgOiBjaGlsZEluZGV4KSA6IGtleSxcbiAgICAgICAgICAgICAgICBrZXlQYXRoID0gW3Rhc2sua2V5UGF0aCwgbmFtZSwga2V5T3JJbmRleF07XG4gICAgICAgICAgICAgIGlmIChudWxsICE9PSB0YXNrLnJlcGxheSkge1xuICAgICAgICAgICAgICAgIHZhciByZXBsYXkgPSB0YXNrLnJlcGxheTtcbiAgICAgICAgICAgICAgICBjaGlsZEluZGV4ID0gcmVwbGF5Lm5vZGVzO1xuICAgICAgICAgICAgICAgIGZvciAobm9kZSA9IDA7IG5vZGUgPCBjaGlsZEluZGV4Lmxlbmd0aDsgbm9kZSsrKVxuICAgICAgICAgICAgICAgICAgaWYgKCgoa2V5ID0gY2hpbGRJbmRleFtub2RlXSksIGtleU9ySW5kZXggPT09IGtleVsxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKDQgPT09IGtleS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAobnVsbCAhPT0gbmFtZSAmJiBuYW1lICE9PSBrZXlbMF0pXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJFeHBlY3RlZCB0aGUgcmVzdW1lIHRvIHJlbmRlciA8XCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleVswXSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCI+IGluIHRoaXMgc2xvdCBidXQgaW5zdGVhZCBpdCByZW5kZXJlZCA8XCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiPi4gVGhlIHRyZWUgZG9lc24ndCBtYXRjaCBzbyBSZWFjdCB3aWxsIGZhbGxiYWNrIHRvIGNsaWVudCByZW5kZXJpbmcuXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkTm9kZXMgPSBrZXlbMl07XG4gICAgICAgICAgICAgICAgICAgICAga2V5ID0ga2V5WzNdO1xuICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSB0YXNrLm5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgdGFzay5yZXBsYXkgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlczogY2hpbGROb2RlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsb3RzOiBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nVGFza3M6IDFcbiAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJFbGVtZW50KHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIHR5cGUsIHByb3BzLCByZWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAxID09PSB0YXNrLnJlcGxheS5wZW5kaW5nVGFza3MgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgMCA8IHRhc2sucmVwbGF5Lm5vZGVzLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkNvdWxkbid0IGZpbmQgYWxsIHJlc3VtYWJsZSBzbG90cyBieSBrZXkvaW5kZXggZHVyaW5nIHJlcGxheWluZy4gVGhlIHRyZWUgZG9lc24ndCBtYXRjaCBzbyBSZWFjdCB3aWxsIGZhbGxiYWNrIHRvIGNsaWVudCByZW5kZXJpbmcuXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2sucmVwbGF5LnBlbmRpbmdUYXNrcy0tO1xuICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHggJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0geCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAoeCA9PT0gU3VzcGVuc2VFeGNlcHRpb24gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB4LnRoZW4pXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAodGFzay5ub2RlID09PSBuYW1lICYmICh0YXNrLnJlcGxheSA9IHJlcGxheSksIHgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrLnJlcGxheS5wZW5kaW5nVGFza3MtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzID0gZ2V0VGhyb3duSW5mbyh0YXNrLmNvbXBvbmVudFN0YWNrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yZWRSZXBsYXkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRhc2suYmxvY2tlZEJvdW5kYXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAga2V5XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB0YXNrLnJlcGxheSA9IHJlcGxheTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSAhPT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcIkV4cGVjdGVkIHRoZSByZXN1bWUgdG8gcmVuZGVyIDxTdXNwZW5zZT4gaW4gdGhpcyBzbG90IGJ1dCBpbnN0ZWFkIGl0IHJlbmRlcmVkIDxcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCBcIlVua25vd25cIikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiPi4gVGhlIHRyZWUgZG9lc24ndCBtYXRjaCBzbyBSZWFjdCB3aWxsIGZhbGxiYWNrIHRvIGNsaWVudCByZW5kZXJpbmcuXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgYToge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZiA9IGtleVs1XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxheSA9IGtleVsyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBrZXlbM107XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlPckluZGV4ID0gbnVsbCA9PT0ga2V5WzRdID8gW10gOiBrZXlbNF1bMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBudWxsID09PSBrZXlbNF0gPyBudWxsIDoga2V5WzRdWzNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZLZXlQYXRoID0gdGFzay5rZXlQYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1JlcGxheVNldCA9IHRhc2sucmVwbGF5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRCb3VuZGFyeSA9IHRhc2suYmxvY2tlZEJvdW5kYXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRIb2lzdGFibGVTdGF0ZSA9IHRhc2suaG9pc3RhYmxlU3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBwcm9wcy5jaGlsZHJlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzID0gcHJvcHMuZmFsbGJhY2s7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmFsbGJhY2tBYm9ydFNldCA9IG5ldyBTZXQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdW1lZEJvdW5kYXJ5ID0gY3JlYXRlU3VzcGVuc2VCb3VuZGFyeShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrQWJvcnRTZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VtZWRCb3VuZGFyeS5wYXJlbnRGbHVzaGVkID0gITA7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bWVkQm91bmRhcnkucm9vdFNlZ21lbnRJRCA9IHJlZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2suYmxvY2tlZEJvdW5kYXJ5ID0gcmVzdW1lZEJvdW5kYXJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFzay5ob2lzdGFibGVTdGF0ZSA9IHJlc3VtZWRCb3VuZGFyeS5jb250ZW50U3RhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrLmtleVBhdGggPSBrZXlQYXRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFzay5yZXBsYXkgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzOiByZXBsYXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNsb3RzOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nVGFza3M6IDFcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIGNvbnRlbnQsIC0xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEgPT09IHRhc2sucmVwbGF5LnBlbmRpbmdUYXNrcyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAgPCB0YXNrLnJlcGxheS5ub2Rlcy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJDb3VsZG4ndCBmaW5kIGFsbCByZXN1bWFibGUgc2xvdHMgYnkga2V5L2luZGV4IGR1cmluZyByZXBsYXlpbmcuIFRoZSB0cmVlIGRvZXNuJ3QgbWF0Y2ggc28gUmVhY3Qgd2lsbCBmYWxsYmFjayB0byBjbGllbnQgcmVuZGVyaW5nLlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGFzay5yZXBsYXkucGVuZGluZ1Rhc2tzLS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAwID09PSByZXN1bWVkQm91bmRhcnkucGVuZGluZ1Rhc2tzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdW1lZEJvdW5kYXJ5LnN0YXR1cyA9PT0gUEVORElOR1xuICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bWVkQm91bmRhcnkuc3RhdHVzID0gQ09NUExFVEVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuY29tcGxldGVkQm91bmRhcmllcy5wdXNoKHJlc3VtZWRCb3VuZGFyeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKHJlc3VtZWRCb3VuZGFyeS5zdGF0dXMgPSBDTElFTlRfUkVOREVSRUQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjaGlsZE5vZGVzID0gZ2V0VGhyb3duSW5mbyh0YXNrLmNvbXBvbmVudFN0YWNrKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGUgPSBsb2dSZWNvdmVyYWJsZUVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGROb2Rlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZUVycm9yRm9yQm91bmRhcnkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bWVkQm91bmRhcnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhc2sucmVwbGF5LnBlbmRpbmdUYXNrcy0tLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bWVkQm91bmRhcnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKHRhc2suYmxvY2tlZEJvdW5kYXJ5ID0gcGFyZW50Qm91bmRhcnkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0YXNrLmhvaXN0YWJsZVN0YXRlID0gcGFyZW50SG9pc3RhYmxlU3RhdGUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0YXNrLnJlcGxheSA9IHByZXZpb3VzUmVwbGF5U2V0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAodGFzay5rZXlQYXRoID0gcHJldktleVBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlcyA9IGNyZWF0ZVJlcGxheVRhc2soXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHsgbm9kZXM6IGtleU9ySW5kZXgsIHNsb3RzOiBrZXksIHBlbmRpbmdUYXNrczogMCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLTEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudEJvdW5kYXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bWVkQm91bmRhcnkuZmFsbGJhY2tTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2tBYm9ydFNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgW2tleVBhdGhbMF0sIFwiU3VzcGVuc2UgRmFsbGJhY2tcIiwga2V5UGF0aFsyXV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRhc2suZm9ybWF0Q29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGFzay5jb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0YXNrLnRyZWVDb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0YXNrLmNvbXBvbmVudFN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAhMFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1c2hDb21wb25lbnRTdGFjayhjaGlsZE5vZGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QucGluZ2VkVGFza3MucHVzaChjaGlsZE5vZGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2hpbGRJbmRleC5zcGxpY2Uobm9kZSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgcmVuZGVyRWxlbWVudChyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCB0eXBlLCBwcm9wcywgcmVmKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJQb3J0YWxzIGFyZSBub3QgY3VycmVudGx5IHN1cHBvcnRlZCBieSB0aGUgc2VydmVyIHJlbmRlcmVyLiBSZW5kZXIgdGhlbSBjb25kaXRpb25hbGx5IHNvIHRoYXQgdGhleSBvbmx5IGFwcGVhciBvbiB0aGUgY2xpZW50IHJlbmRlci5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgIG5vZGUgPSBjYWxsTGF6eUluaXRJbkRFVihub2RlKTtcbiAgICAgICAgICAgICAgaWYgKDEyID09PSByZXF1ZXN0LnN0YXR1cykgdGhyb3cgbnVsbDtcbiAgICAgICAgICAgICAgcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIG5vZGUsIGNoaWxkSW5kZXgpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0FycmF5SW1wbChub2RlKSkge1xuICAgICAgICAgICAgcmVuZGVyQ2hpbGRyZW5BcnJheShyZXF1ZXN0LCB0YXNrLCBub2RlLCBjaGlsZEluZGV4KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbnVsbCA9PT0gbm9kZSB8fCBcIm9iamVjdFwiICE9PSB0eXBlb2Ygbm9kZVxuICAgICAgICAgICAgPyAocHJvcHMgPSBudWxsKVxuICAgICAgICAgICAgOiAoKGNoaWxkTm9kZXMgPVxuICAgICAgICAgICAgICAgIChNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbm9kZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdKSB8fFxuICAgICAgICAgICAgICAgIG5vZGVbXCJAQGl0ZXJhdG9yXCJdKSxcbiAgICAgICAgICAgICAgKHByb3BzID0gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY2hpbGROb2RlcyA/IGNoaWxkTm9kZXMgOiBudWxsKSk7XG4gICAgICAgICAgaWYgKHByb3BzICYmIChjaGlsZE5vZGVzID0gcHJvcHMuY2FsbChub2RlKSkpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGVzID09PSBub2RlKSB7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAtMSAhPT0gY2hpbGRJbmRleCB8fFxuICAgICAgICAgICAgICAgIG51bGwgPT09IHRhc2suY29tcG9uZW50U3RhY2sgfHxcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiB0YXNrLmNvbXBvbmVudFN0YWNrLnR5cGUgfHxcbiAgICAgICAgICAgICAgICBcIltvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dXCIgIT09XG4gICAgICAgICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodGFzay5jb21wb25lbnRTdGFjay50eXBlKSB8fFxuICAgICAgICAgICAgICAgIFwiW29iamVjdCBHZW5lcmF0b3JdXCIgIT09XG4gICAgICAgICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoY2hpbGROb2RlcylcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIGRpZFdhcm5BYm91dEdlbmVyYXRvcnMgfHxcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiVXNpbmcgSXRlcmF0b3JzIGFzIGNoaWxkcmVuIGlzIHVuc3VwcG9ydGVkIGFuZCB3aWxsIGxpa2VseSB5aWVsZCB1bmV4cGVjdGVkIHJlc3VsdHMgYmVjYXVzZSBlbnVtZXJhdGluZyBhIGdlbmVyYXRvciBtdXRhdGVzIGl0LiBZb3UgbWF5IGNvbnZlcnQgaXQgdG8gYW4gYXJyYXkgd2l0aCBgQXJyYXkuZnJvbSgpYCBvciB0aGUgYFsuLi5zcHJlYWRdYCBvcGVyYXRvciBiZWZvcmUgcmVuZGVyaW5nLiBZb3UgY2FuIGFsc28gdXNlIGFuIEl0ZXJhYmxlIHRoYXQgY2FuIGl0ZXJhdGUgbXVsdGlwbGUgdGltZXMgb3ZlciB0aGUgc2FtZSBpdGVtcy5cIlxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgIChkaWRXYXJuQWJvdXRHZW5lcmF0b3JzID0gITApO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgIG5vZGUuZW50cmllcyAhPT0gcHJvcHMgfHxcbiAgICAgICAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzIHx8XG4gICAgICAgICAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlVzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgbm90IHN1cHBvcnRlZC4gVXNlIGFuIGFycmF5IG9mIGtleWVkIFJlYWN0RWxlbWVudHMgaW5zdGVhZC5cIlxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKGRpZFdhcm5BYm91dE1hcHMgPSAhMCkpO1xuICAgICAgICAgICAgbm9kZSA9IGNoaWxkTm9kZXMubmV4dCgpO1xuICAgICAgICAgICAgaWYgKCFub2RlLmRvbmUpIHtcbiAgICAgICAgICAgICAgcHJvcHMgPSBbXTtcbiAgICAgICAgICAgICAgZG8gcHJvcHMucHVzaChub2RlLnZhbHVlKSwgKG5vZGUgPSBjaGlsZE5vZGVzLm5leHQoKSk7XG4gICAgICAgICAgICAgIHdoaWxlICghbm9kZS5kb25lKTtcbiAgICAgICAgICAgICAgcmVuZGVyQ2hpbGRyZW5BcnJheShyZXF1ZXN0LCB0YXNrLCBwcm9wcywgY2hpbGRJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBub2RlLnRoZW4pXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAodGFzay50aGVuYWJsZVN0YXRlID0gbnVsbCksXG4gICAgICAgICAgICAgIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIHRhc2ssXG4gICAgICAgICAgICAgICAgdW53cmFwVGhlbmFibGUobm9kZSksXG4gICAgICAgICAgICAgICAgY2hpbGRJbmRleFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGlmIChub2RlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUpXG4gICAgICAgICAgICByZXR1cm4gcmVuZGVyTm9kZURlc3RydWN0aXZlKFxuICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICB0YXNrLFxuICAgICAgICAgICAgICBub2RlLl9jdXJyZW50VmFsdWUyLFxuICAgICAgICAgICAgICBjaGlsZEluZGV4XG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNoaWxkSW5kZXggPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobm9kZSk7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIk9iamVjdHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkIChmb3VuZDogXCIgK1xuICAgICAgICAgICAgICAoXCJbb2JqZWN0IE9iamVjdF1cIiA9PT0gY2hpbGRJbmRleFxuICAgICAgICAgICAgICAgID8gXCJvYmplY3Qgd2l0aCBrZXlzIHtcIiArIE9iamVjdC5rZXlzKG5vZGUpLmpvaW4oXCIsIFwiKSArIFwifVwiXG4gICAgICAgICAgICAgICAgOiBjaGlsZEluZGV4KSArXG4gICAgICAgICAgICAgIFwiKS4gSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4sIHVzZSBhbiBhcnJheSBpbnN0ZWFkLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygbm9kZVxuICAgICAgICAgID8gKChjaGlsZEluZGV4ID0gdGFzay5ibG9ja2VkU2VnbWVudCksXG4gICAgICAgICAgICBudWxsICE9PSBjaGlsZEluZGV4ICYmXG4gICAgICAgICAgICAgIChjaGlsZEluZGV4Lmxhc3RQdXNoZWRUZXh0ID0gcHVzaFRleHRJbnN0YW5jZShcbiAgICAgICAgICAgICAgICBjaGlsZEluZGV4LmNodW5rcyxcbiAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgIHJlcXVlc3QucmVuZGVyU3RhdGUsXG4gICAgICAgICAgICAgICAgY2hpbGRJbmRleC5sYXN0UHVzaGVkVGV4dFxuICAgICAgICAgICAgICApKSlcbiAgICAgICAgICA6IFwibnVtYmVyXCIgPT09IHR5cGVvZiBub2RlIHx8IFwiYmlnaW50XCIgPT09IHR5cGVvZiBub2RlXG4gICAgICAgICAgICA/ICgoY2hpbGRJbmRleCA9IHRhc2suYmxvY2tlZFNlZ21lbnQpLFxuICAgICAgICAgICAgICBudWxsICE9PSBjaGlsZEluZGV4ICYmXG4gICAgICAgICAgICAgICAgKGNoaWxkSW5kZXgubGFzdFB1c2hlZFRleHQgPSBwdXNoVGV4dEluc3RhbmNlKFxuICAgICAgICAgICAgICAgICAgY2hpbGRJbmRleC5jaHVua3MsXG4gICAgICAgICAgICAgICAgICBcIlwiICsgbm9kZSxcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3QucmVuZGVyU3RhdGUsXG4gICAgICAgICAgICAgICAgICBjaGlsZEluZGV4Lmxhc3RQdXNoZWRUZXh0XG4gICAgICAgICAgICAgICAgKSkpXG4gICAgICAgICAgICA6IChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBub2RlICYmXG4gICAgICAgICAgICAgICAgKChjaGlsZEluZGV4ID0gbm9kZS5kaXNwbGF5TmFtZSB8fCBub2RlLm5hbWUgfHwgXCJDb21wb25lbnRcIiksXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiRnVuY3Rpb25zIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZC4gVGhpcyBtYXkgaGFwcGVuIGlmIHlvdSByZXR1cm4gJXMgaW5zdGVhZCBvZiA8JXMgLz4gZnJvbSByZW5kZXIuIE9yIG1heWJlIHlvdSBtZWFudCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gcmF0aGVyIHRoYW4gcmV0dXJuIGl0LlwiLFxuICAgICAgICAgICAgICAgICAgY2hpbGRJbmRleCxcbiAgICAgICAgICAgICAgICAgIGNoaWxkSW5kZXhcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgXCJzeW1ib2xcIiA9PT0gdHlwZW9mIG5vZGUgJiZcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJTeW1ib2xzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZC5cXG4gICVzXCIsXG4gICAgICAgICAgICAgICAgICBTdHJpbmcobm9kZSlcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVuZGVyQ2hpbGRyZW5BcnJheShyZXF1ZXN0JGpzY29tcCQwLCB0YXNrLCBjaGlsZHJlbiwgY2hpbGRJbmRleCkge1xuICAgICAgdmFyIHByZXZLZXlQYXRoID0gdGFzay5rZXlQYXRoLFxuICAgICAgICBwcmV2aW91c0NvbXBvbmVudFN0YWNrID0gdGFzay5jb21wb25lbnRTdGFjaztcbiAgICAgIHB1c2hTZXJ2ZXJDb21wb25lbnRTdGFjayh0YXNrLCB0YXNrLm5vZGUuX2RlYnVnSW5mbyk7XG4gICAgICBpZiAoXG4gICAgICAgIC0xICE9PSBjaGlsZEluZGV4ICYmXG4gICAgICAgICgodGFzay5rZXlQYXRoID0gW3Rhc2sua2V5UGF0aCwgXCJGcmFnbWVudFwiLCBjaGlsZEluZGV4XSksXG4gICAgICAgIG51bGwgIT09IHRhc2sucmVwbGF5KVxuICAgICAgKSB7XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgdmFyIHJlcGxheSA9IHRhc2sucmVwbGF5LCByZXBsYXlOb2RlcyA9IHJlcGxheS5ub2RlcywgaiA9IDA7XG4gICAgICAgICAgaiA8IHJlcGxheU5vZGVzLmxlbmd0aDtcbiAgICAgICAgICBqKytcbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSByZXBsYXlOb2Rlc1tqXTtcbiAgICAgICAgICBpZiAobm9kZVsxXSA9PT0gY2hpbGRJbmRleCkge1xuICAgICAgICAgICAgY2hpbGRJbmRleCA9IG5vZGVbMl07XG4gICAgICAgICAgICBub2RlID0gbm9kZVszXTtcbiAgICAgICAgICAgIHRhc2sucmVwbGF5ID0geyBub2RlczogY2hpbGRJbmRleCwgc2xvdHM6IG5vZGUsIHBlbmRpbmdUYXNrczogMSB9O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmVuZGVyQ2hpbGRyZW5BcnJheShyZXF1ZXN0JGpzY29tcCQwLCB0YXNrLCBjaGlsZHJlbiwgLTEpO1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgMSA9PT0gdGFzay5yZXBsYXkucGVuZGluZ1Rhc2tzICYmXG4gICAgICAgICAgICAgICAgMCA8IHRhc2sucmVwbGF5Lm5vZGVzLmxlbmd0aFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIkNvdWxkbid0IGZpbmQgYWxsIHJlc3VtYWJsZSBzbG90cyBieSBrZXkvaW5kZXggZHVyaW5nIHJlcGxheWluZy4gVGhlIHRyZWUgZG9lc24ndCBtYXRjaCBzbyBSZWFjdCB3aWxsIGZhbGxiYWNrIHRvIGNsaWVudCByZW5kZXJpbmcuXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB0YXNrLnJlcGxheS5wZW5kaW5nVGFza3MtLTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiB4ICYmXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0geCAmJlxuICAgICAgICAgICAgICAgICh4ID09PSBTdXNwZW5zZUV4Y2VwdGlvbiB8fCBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB4LnRoZW4pXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICB0aHJvdyB4O1xuICAgICAgICAgICAgICB0YXNrLnJlcGxheS5wZW5kaW5nVGFza3MtLTtcbiAgICAgICAgICAgICAgY2hpbGRyZW4gPSBnZXRUaHJvd25JbmZvKHRhc2suY29tcG9uZW50U3RhY2spO1xuICAgICAgICAgICAgICBlcnJvcmVkUmVwbGF5KFxuICAgICAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgdGFzay5ibG9ja2VkQm91bmRhcnksXG4gICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgICAgICAgICBjaGlsZEluZGV4LFxuICAgICAgICAgICAgICAgIG5vZGVcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhc2sucmVwbGF5ID0gcmVwbGF5O1xuICAgICAgICAgICAgcmVwbGF5Tm9kZXMuc3BsaWNlKGosIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRhc2sua2V5UGF0aCA9IHByZXZLZXlQYXRoO1xuICAgICAgICB0YXNrLmNvbXBvbmVudFN0YWNrID0gcHJldmlvdXNDb21wb25lbnRTdGFjaztcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVwbGF5ID0gdGFzay50cmVlQ29udGV4dDtcbiAgICAgIHJlcGxheU5vZGVzID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgaWYgKFxuICAgICAgICBudWxsICE9PSB0YXNrLnJlcGxheSAmJlxuICAgICAgICAoKGogPSB0YXNrLnJlcGxheS5zbG90cyksIG51bGwgIT09IGogJiYgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGopXG4gICAgICApIHtcbiAgICAgICAgZm9yIChjaGlsZEluZGV4ID0gMDsgY2hpbGRJbmRleCA8IHJlcGxheU5vZGVzOyBjaGlsZEluZGV4KyspIHtcbiAgICAgICAgICBub2RlID0gY2hpbGRyZW5bY2hpbGRJbmRleF07XG4gICAgICAgICAgdGFzay50cmVlQ29udGV4dCA9IHB1c2hUcmVlQ29udGV4dChyZXBsYXksIHJlcGxheU5vZGVzLCBjaGlsZEluZGV4KTtcbiAgICAgICAgICB2YXIgcmVzdW1lU2VnbWVudElEID0galtjaGlsZEluZGV4XTtcbiAgICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgcmVzdW1lU2VnbWVudElEXG4gICAgICAgICAgICA/IChyZXN1bWVOb2RlKFxuICAgICAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgdGFzayxcbiAgICAgICAgICAgICAgICByZXN1bWVTZWdtZW50SUQsXG4gICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICBjaGlsZEluZGV4XG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIGRlbGV0ZSBqW2NoaWxkSW5kZXhdKVxuICAgICAgICAgICAgOiByZW5kZXJOb2RlKHJlcXVlc3QkanNjb21wJDAsIHRhc2ssIG5vZGUsIGNoaWxkSW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHRhc2sudHJlZUNvbnRleHQgPSByZXBsYXk7XG4gICAgICAgIHRhc2sua2V5UGF0aCA9IHByZXZLZXlQYXRoO1xuICAgICAgICB0YXNrLmNvbXBvbmVudFN0YWNrID0gcHJldmlvdXNDb21wb25lbnRTdGFjaztcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yIChqID0gMDsgaiA8IHJlcGxheU5vZGVzOyBqKyspIHtcbiAgICAgICAgY2hpbGRJbmRleCA9IGNoaWxkcmVuW2pdO1xuICAgICAgICB2YXIgcmVxdWVzdCA9IHJlcXVlc3QkanNjb21wJDA7XG4gICAgICAgIG5vZGUgPSB0YXNrO1xuICAgICAgICByZXN1bWVTZWdtZW50SUQgPSBjaGlsZEluZGV4O1xuICAgICAgICBpZiAoXG4gICAgICAgICAgbnVsbCAhPT0gcmVzdW1lU2VnbWVudElEICYmXG4gICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHJlc3VtZVNlZ21lbnRJRCAmJlxuICAgICAgICAgIChyZXN1bWVTZWdtZW50SUQuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSB8fFxuICAgICAgICAgICAgcmVzdW1lU2VnbWVudElELiQkdHlwZW9mID09PSBSRUFDVF9QT1JUQUxfVFlQRSkgJiZcbiAgICAgICAgICByZXN1bWVTZWdtZW50SUQuX3N0b3JlICYmXG4gICAgICAgICAgKCghcmVzdW1lU2VnbWVudElELl9zdG9yZS52YWxpZGF0ZWQgJiYgbnVsbCA9PSByZXN1bWVTZWdtZW50SUQua2V5KSB8fFxuICAgICAgICAgICAgMiA9PT0gcmVzdW1lU2VnbWVudElELl9zdG9yZS52YWxpZGF0ZWQpXG4gICAgICAgICkge1xuICAgICAgICAgIGlmIChcIm9iamVjdFwiICE9PSB0eXBlb2YgcmVzdW1lU2VnbWVudElELl9zdG9yZSlcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICBcIlJlYWN0IENvbXBvbmVudCBpbiB3YXJuRm9yTWlzc2luZ0tleSBzaG91bGQgaGF2ZSBhIF9zdG9yZS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICByZXN1bWVTZWdtZW50SUQuX3N0b3JlLnZhbGlkYXRlZCA9IDE7XG4gICAgICAgICAgdmFyIGRpZFdhcm5Gb3JLZXkgPSByZXF1ZXN0LmRpZFdhcm5Gb3JLZXk7XG4gICAgICAgICAgbnVsbCA9PSBkaWRXYXJuRm9yS2V5ICYmXG4gICAgICAgICAgICAoZGlkV2FybkZvcktleSA9IHJlcXVlc3QuZGlkV2FybkZvcktleSA9IG5ldyBXZWFrU2V0KCkpO1xuICAgICAgICAgIHJlcXVlc3QgPSBub2RlLmNvbXBvbmVudFN0YWNrO1xuICAgICAgICAgIGlmIChudWxsICE9PSByZXF1ZXN0ICYmICFkaWRXYXJuRm9yS2V5LmhhcyhyZXF1ZXN0KSkge1xuICAgICAgICAgICAgZGlkV2FybkZvcktleS5hZGQocmVxdWVzdCk7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShyZXN1bWVTZWdtZW50SUQudHlwZSk7XG4gICAgICAgICAgICBkaWRXYXJuRm9yS2V5ID0gcmVzdW1lU2VnbWVudElELl9vd25lcjtcbiAgICAgICAgICAgIHZhciBwYXJlbnRPd25lciA9IHJlcXVlc3Qub3duZXI7XG4gICAgICAgICAgICByZXF1ZXN0ID0gXCJcIjtcbiAgICAgICAgICAgIGlmIChwYXJlbnRPd25lciAmJiBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgcGFyZW50T3duZXIudHlwZSkge1xuICAgICAgICAgICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShwYXJlbnRPd25lci50eXBlKTtcbiAgICAgICAgICAgICAgbmFtZSAmJlxuICAgICAgICAgICAgICAgIChyZXF1ZXN0ID0gXCJcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgXCIgKyBuYW1lICsgXCJgLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcXVlc3QgfHxcbiAgICAgICAgICAgICAgKGNvbXBvbmVudE5hbWUgJiZcbiAgICAgICAgICAgICAgICAocmVxdWVzdCA9XG4gICAgICAgICAgICAgICAgICBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICtcbiAgICAgICAgICAgICAgICAgIGNvbXBvbmVudE5hbWUgK1xuICAgICAgICAgICAgICAgICAgXCI+LlwiKSk7XG4gICAgICAgICAgICBjb21wb25lbnROYW1lID0gXCJcIjtcbiAgICAgICAgICAgIG51bGwgIT0gZGlkV2FybkZvcktleSAmJlxuICAgICAgICAgICAgICBwYXJlbnRPd25lciAhPT0gZGlkV2FybkZvcktleSAmJlxuICAgICAgICAgICAgICAoKHBhcmVudE93bmVyID0gbnVsbCksXG4gICAgICAgICAgICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBkaWRXYXJuRm9yS2V5LnR5cGVcbiAgICAgICAgICAgICAgICA/IChwYXJlbnRPd25lciA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShkaWRXYXJuRm9yS2V5LnR5cGUpKVxuICAgICAgICAgICAgICAgIDogXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGRpZFdhcm5Gb3JLZXkubmFtZSAmJlxuICAgICAgICAgICAgICAgICAgKHBhcmVudE93bmVyID0gZGlkV2FybkZvcktleS5uYW1lKSxcbiAgICAgICAgICAgICAgcGFyZW50T3duZXIgJiZcbiAgICAgICAgICAgICAgICAoY29tcG9uZW50TmFtZSA9XG4gICAgICAgICAgICAgICAgICBcIiBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSBcIiArIHBhcmVudE93bmVyICsgXCIuXCIpKTtcbiAgICAgICAgICAgIGRpZFdhcm5Gb3JLZXkgPSBub2RlLmNvbXBvbmVudFN0YWNrO1xuICAgICAgICAgICAgbm9kZS5jb21wb25lbnRTdGFjayA9IHtcbiAgICAgICAgICAgICAgcGFyZW50OiBub2RlLmNvbXBvbmVudFN0YWNrLFxuICAgICAgICAgICAgICB0eXBlOiByZXN1bWVTZWdtZW50SUQudHlwZSxcbiAgICAgICAgICAgICAgb3duZXI6IHJlc3VtZVNlZ21lbnRJRC5fb3duZXIsXG4gICAgICAgICAgICAgIHN0YWNrOiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgJ0VhY2ggY2hpbGQgaW4gYSBsaXN0IHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4lcyVzIFNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL3dhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLFxuICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbm9kZS5jb21wb25lbnRTdGFjayA9IGRpZFdhcm5Gb3JLZXk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRhc2sudHJlZUNvbnRleHQgPSBwdXNoVHJlZUNvbnRleHQocmVwbGF5LCByZXBsYXlOb2Rlcywgaik7XG4gICAgICAgIHJlbmRlck5vZGUocmVxdWVzdCRqc2NvbXAkMCwgdGFzaywgY2hpbGRJbmRleCwgaik7XG4gICAgICB9XG4gICAgICB0YXNrLnRyZWVDb250ZXh0ID0gcmVwbGF5O1xuICAgICAgdGFzay5rZXlQYXRoID0gcHJldktleVBhdGg7XG4gICAgICB0YXNrLmNvbXBvbmVudFN0YWNrID0gcHJldmlvdXNDb21wb25lbnRTdGFjaztcbiAgICB9XG4gICAgZnVuY3Rpb24gdW50cmFja0JvdW5kYXJ5KHJlcXVlc3QsIGJvdW5kYXJ5KSB7XG4gICAgICByZXF1ZXN0ID0gcmVxdWVzdC50cmFja2VkUG9zdHBvbmVzO1xuICAgICAgbnVsbCAhPT0gcmVxdWVzdCAmJlxuICAgICAgICAoKGJvdW5kYXJ5ID0gYm91bmRhcnkudHJhY2tlZENvbnRlbnRLZXlQYXRoKSxcbiAgICAgICAgbnVsbCAhPT0gYm91bmRhcnkgJiZcbiAgICAgICAgICAoKGJvdW5kYXJ5ID0gcmVxdWVzdC53b3JraW5nTWFwLmdldChib3VuZGFyeSkpLFxuICAgICAgICAgIHZvaWQgMCAhPT0gYm91bmRhcnkgJiZcbiAgICAgICAgICAgICgoYm91bmRhcnkubGVuZ3RoID0gNCksIChib3VuZGFyeVsyXSA9IFtdKSwgKGJvdW5kYXJ5WzNdID0gbnVsbCkpKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNwYXduTmV3U3VzcGVuZGVkUmVwbGF5VGFzayhyZXF1ZXN0LCB0YXNrLCB0aGVuYWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm4gY3JlYXRlUmVwbGF5VGFzayhcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgdGhlbmFibGVTdGF0ZSxcbiAgICAgICAgdGFzay5yZXBsYXksXG4gICAgICAgIHRhc2subm9kZSxcbiAgICAgICAgdGFzay5jaGlsZEluZGV4LFxuICAgICAgICB0YXNrLmJsb2NrZWRCb3VuZGFyeSxcbiAgICAgICAgdGFzay5ob2lzdGFibGVTdGF0ZSxcbiAgICAgICAgdGFzay5hYm9ydFNldCxcbiAgICAgICAgdGFzay5rZXlQYXRoLFxuICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQsXG4gICAgICAgIHRhc2suY29udGV4dCxcbiAgICAgICAgdGFzay50cmVlQ29udGV4dCxcbiAgICAgICAgdGFzay5jb21wb25lbnRTdGFjayxcbiAgICAgICAgdGFzay5pc0ZhbGxiYWNrXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzcGF3bk5ld1N1c3BlbmRlZFJlbmRlclRhc2socmVxdWVzdCwgdGFzaywgdGhlbmFibGVTdGF0ZSkge1xuICAgICAgdmFyIHNlZ21lbnQgPSB0YXNrLmJsb2NrZWRTZWdtZW50LFxuICAgICAgICBuZXdTZWdtZW50ID0gY3JlYXRlUGVuZGluZ1NlZ21lbnQoXG4gICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICBzZWdtZW50LmNodW5rcy5sZW5ndGgsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQsXG4gICAgICAgICAgc2VnbWVudC5sYXN0UHVzaGVkVGV4dCxcbiAgICAgICAgICAhMFxuICAgICAgICApO1xuICAgICAgc2VnbWVudC5jaGlsZHJlbi5wdXNoKG5ld1NlZ21lbnQpO1xuICAgICAgc2VnbWVudC5sYXN0UHVzaGVkVGV4dCA9ICExO1xuICAgICAgcmV0dXJuIGNyZWF0ZVJlbmRlclRhc2soXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIHRoZW5hYmxlU3RhdGUsXG4gICAgICAgIHRhc2subm9kZSxcbiAgICAgICAgdGFzay5jaGlsZEluZGV4LFxuICAgICAgICB0YXNrLmJsb2NrZWRCb3VuZGFyeSxcbiAgICAgICAgbmV3U2VnbWVudCxcbiAgICAgICAgdGFzay5ob2lzdGFibGVTdGF0ZSxcbiAgICAgICAgdGFzay5hYm9ydFNldCxcbiAgICAgICAgdGFzay5rZXlQYXRoLFxuICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQsXG4gICAgICAgIHRhc2suY29udGV4dCxcbiAgICAgICAgdGFzay50cmVlQ29udGV4dCxcbiAgICAgICAgdGFzay5jb21wb25lbnRTdGFjayxcbiAgICAgICAgdGFzay5pc0ZhbGxiYWNrXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIG5vZGUsIGNoaWxkSW5kZXgpIHtcbiAgICAgIHZhciBwcmV2aW91c0Zvcm1hdENvbnRleHQgPSB0YXNrLmZvcm1hdENvbnRleHQsXG4gICAgICAgIHByZXZpb3VzQ29udGV4dCA9IHRhc2suY29udGV4dCxcbiAgICAgICAgcHJldmlvdXNLZXlQYXRoID0gdGFzay5rZXlQYXRoLFxuICAgICAgICBwcmV2aW91c1RyZWVDb250ZXh0ID0gdGFzay50cmVlQ29udGV4dCxcbiAgICAgICAgcHJldmlvdXNDb21wb25lbnRTdGFjayA9IHRhc2suY29tcG9uZW50U3RhY2ssXG4gICAgICAgIHNlZ21lbnQgPSB0YXNrLmJsb2NrZWRTZWdtZW50O1xuICAgICAgaWYgKG51bGwgPT09IHNlZ21lbnQpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBub2RlLCBjaGlsZEluZGV4KTtcbiAgICAgICAgfSBjYXRjaCAodGhyb3duVmFsdWUpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAocmVzZXRIb29rc1N0YXRlKCksXG4gICAgICAgICAgICAobm9kZSA9XG4gICAgICAgICAgICAgIHRocm93blZhbHVlID09PSBTdXNwZW5zZUV4Y2VwdGlvblxuICAgICAgICAgICAgICAgID8gZ2V0U3VzcGVuZGVkVGhlbmFibGUoKVxuICAgICAgICAgICAgICAgIDogdGhyb3duVmFsdWUpLFxuICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG5vZGUgJiYgbnVsbCAhPT0gbm9kZSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBub2RlLnRoZW4pIHtcbiAgICAgICAgICAgICAgY2hpbGRJbmRleCA9IGdldFRoZW5hYmxlU3RhdGVBZnRlclN1c3BlbmRpbmcoKTtcbiAgICAgICAgICAgICAgcmVxdWVzdCA9IHNwYXduTmV3U3VzcGVuZGVkUmVwbGF5VGFzayhcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIHRhc2ssXG4gICAgICAgICAgICAgICAgY2hpbGRJbmRleFxuICAgICAgICAgICAgICApLnBpbmc7XG4gICAgICAgICAgICAgIG5vZGUudGhlbihyZXF1ZXN0LCByZXF1ZXN0KTtcbiAgICAgICAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0ID0gcHJldmlvdXNGb3JtYXRDb250ZXh0O1xuICAgICAgICAgICAgICB0YXNrLmNvbnRleHQgPSBwcmV2aW91c0NvbnRleHQ7XG4gICAgICAgICAgICAgIHRhc2sua2V5UGF0aCA9IHByZXZpb3VzS2V5UGF0aDtcbiAgICAgICAgICAgICAgdGFzay50cmVlQ29udGV4dCA9IHByZXZpb3VzVHJlZUNvbnRleHQ7XG4gICAgICAgICAgICAgIHRhc2suY29tcG9uZW50U3RhY2sgPSBwcmV2aW91c0NvbXBvbmVudFN0YWNrO1xuICAgICAgICAgICAgICBzd2l0Y2hDb250ZXh0KHByZXZpb3VzQ29udGV4dCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChcIk1heGltdW0gY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIgPT09IG5vZGUubWVzc2FnZSkge1xuICAgICAgICAgICAgICBub2RlID0gZ2V0VGhlbmFibGVTdGF0ZUFmdGVyU3VzcGVuZGluZygpO1xuICAgICAgICAgICAgICBub2RlID0gc3Bhd25OZXdTdXNwZW5kZWRSZXBsYXlUYXNrKHJlcXVlc3QsIHRhc2ssIG5vZGUpO1xuICAgICAgICAgICAgICByZXF1ZXN0LnBpbmdlZFRhc2tzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgIHRhc2suZm9ybWF0Q29udGV4dCA9IHByZXZpb3VzRm9ybWF0Q29udGV4dDtcbiAgICAgICAgICAgICAgdGFzay5jb250ZXh0ID0gcHJldmlvdXNDb250ZXh0O1xuICAgICAgICAgICAgICB0YXNrLmtleVBhdGggPSBwcmV2aW91c0tleVBhdGg7XG4gICAgICAgICAgICAgIHRhc2sudHJlZUNvbnRleHQgPSBwcmV2aW91c1RyZWVDb250ZXh0O1xuICAgICAgICAgICAgICB0YXNrLmNvbXBvbmVudFN0YWNrID0gcHJldmlvdXNDb21wb25lbnRTdGFjaztcbiAgICAgICAgICAgICAgc3dpdGNoQ29udGV4dChwcmV2aW91c0NvbnRleHQpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gc2VnbWVudC5jaGlsZHJlbi5sZW5ndGgsXG4gICAgICAgICAgY2h1bmtMZW5ndGggPSBzZWdtZW50LmNodW5rcy5sZW5ndGg7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBub2RlLCBjaGlsZEluZGV4KTtcbiAgICAgICAgfSBjYXRjaCAodGhyb3duVmFsdWUkMykge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIChyZXNldEhvb2tzU3RhdGUoKSxcbiAgICAgICAgICAgIChzZWdtZW50LmNoaWxkcmVuLmxlbmd0aCA9IGNoaWxkcmVuTGVuZ3RoKSxcbiAgICAgICAgICAgIChzZWdtZW50LmNodW5rcy5sZW5ndGggPSBjaHVua0xlbmd0aCksXG4gICAgICAgICAgICAobm9kZSA9XG4gICAgICAgICAgICAgIHRocm93blZhbHVlJDMgPT09IFN1c3BlbnNlRXhjZXB0aW9uXG4gICAgICAgICAgICAgICAgPyBnZXRTdXNwZW5kZWRUaGVuYWJsZSgpXG4gICAgICAgICAgICAgICAgOiB0aHJvd25WYWx1ZSQzKSxcbiAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBub2RlICYmIG51bGwgIT09IG5vZGUpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2Ygbm9kZS50aGVuKSB7XG4gICAgICAgICAgICAgIGNoaWxkSW5kZXggPSBnZXRUaGVuYWJsZVN0YXRlQWZ0ZXJTdXNwZW5kaW5nKCk7XG4gICAgICAgICAgICAgIHJlcXVlc3QgPSBzcGF3bk5ld1N1c3BlbmRlZFJlbmRlclRhc2soXG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICB0YXNrLFxuICAgICAgICAgICAgICAgIGNoaWxkSW5kZXhcbiAgICAgICAgICAgICAgKS5waW5nO1xuICAgICAgICAgICAgICBub2RlLnRoZW4ocmVxdWVzdCwgcmVxdWVzdCk7XG4gICAgICAgICAgICAgIHRhc2suZm9ybWF0Q29udGV4dCA9IHByZXZpb3VzRm9ybWF0Q29udGV4dDtcbiAgICAgICAgICAgICAgdGFzay5jb250ZXh0ID0gcHJldmlvdXNDb250ZXh0O1xuICAgICAgICAgICAgICB0YXNrLmtleVBhdGggPSBwcmV2aW91c0tleVBhdGg7XG4gICAgICAgICAgICAgIHRhc2sudHJlZUNvbnRleHQgPSBwcmV2aW91c1RyZWVDb250ZXh0O1xuICAgICAgICAgICAgICB0YXNrLmNvbXBvbmVudFN0YWNrID0gcHJldmlvdXNDb21wb25lbnRTdGFjaztcbiAgICAgICAgICAgICAgc3dpdGNoQ29udGV4dChwcmV2aW91c0NvbnRleHQpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXCJNYXhpbXVtIGNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiID09PSBub2RlLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgbm9kZSA9IGdldFRoZW5hYmxlU3RhdGVBZnRlclN1c3BlbmRpbmcoKTtcbiAgICAgICAgICAgICAgbm9kZSA9IHNwYXduTmV3U3VzcGVuZGVkUmVuZGVyVGFzayhyZXF1ZXN0LCB0YXNrLCBub2RlKTtcbiAgICAgICAgICAgICAgcmVxdWVzdC5waW5nZWRUYXNrcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQgPSBwcmV2aW91c0Zvcm1hdENvbnRleHQ7XG4gICAgICAgICAgICAgIHRhc2suY29udGV4dCA9IHByZXZpb3VzQ29udGV4dDtcbiAgICAgICAgICAgICAgdGFzay5rZXlQYXRoID0gcHJldmlvdXNLZXlQYXRoO1xuICAgICAgICAgICAgICB0YXNrLnRyZWVDb250ZXh0ID0gcHJldmlvdXNUcmVlQ29udGV4dDtcbiAgICAgICAgICAgICAgdGFzay5jb21wb25lbnRTdGFjayA9IHByZXZpb3VzQ29tcG9uZW50U3RhY2s7XG4gICAgICAgICAgICAgIHN3aXRjaENvbnRleHQocHJldmlvdXNDb250ZXh0KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGFzay5mb3JtYXRDb250ZXh0ID0gcHJldmlvdXNGb3JtYXRDb250ZXh0O1xuICAgICAgdGFzay5jb250ZXh0ID0gcHJldmlvdXNDb250ZXh0O1xuICAgICAgdGFzay5rZXlQYXRoID0gcHJldmlvdXNLZXlQYXRoO1xuICAgICAgdGFzay50cmVlQ29udGV4dCA9IHByZXZpb3VzVHJlZUNvbnRleHQ7XG4gICAgICBzd2l0Y2hDb250ZXh0KHByZXZpb3VzQ29udGV4dCk7XG4gICAgICB0aHJvdyBub2RlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlcnJvcmVkUmVwbGF5KFxuICAgICAgcmVxdWVzdCxcbiAgICAgIGJvdW5kYXJ5LFxuICAgICAgZXJyb3IsXG4gICAgICBlcnJvckluZm8sXG4gICAgICByZXBsYXlOb2RlcyxcbiAgICAgIHJlc3VtZVNsb3RzXG4gICAgKSB7XG4gICAgICB2YXIgZXJyb3JEaWdlc3QgPSBsb2dSZWNvdmVyYWJsZUVycm9yKHJlcXVlc3QsIGVycm9yLCBlcnJvckluZm8pO1xuICAgICAgYWJvcnRSZW1haW5pbmdSZXBsYXlOb2RlcyhcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgYm91bmRhcnksXG4gICAgICAgIHJlcGxheU5vZGVzLFxuICAgICAgICByZXN1bWVTbG90cyxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIGVycm9yRGlnZXN0LFxuICAgICAgICBlcnJvckluZm8sXG4gICAgICAgICExXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhYm9ydFRhc2tTb2Z0KHRhc2spIHtcbiAgICAgIHZhciBib3VuZGFyeSA9IHRhc2suYmxvY2tlZEJvdW5kYXJ5O1xuICAgICAgdGFzayA9IHRhc2suYmxvY2tlZFNlZ21lbnQ7XG4gICAgICBudWxsICE9PSB0YXNrICYmICgodGFzay5zdGF0dXMgPSAzKSwgZmluaXNoZWRUYXNrKHRoaXMsIGJvdW5kYXJ5LCB0YXNrKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFib3J0UmVtYWluaW5nUmVwbGF5Tm9kZXMoXG4gICAgICByZXF1ZXN0JGpzY29tcCQwLFxuICAgICAgYm91bmRhcnksXG4gICAgICBub2RlcyxcbiAgICAgIHNsb3RzLFxuICAgICAgZXJyb3IkanNjb21wJDAsXG4gICAgICBlcnJvckRpZ2VzdCRqc2NvbXAkMCxcbiAgICAgIGVycm9ySW5mbyRqc2NvbXAkMCxcbiAgICAgIGFib3J0ZWRcbiAgICApIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgaWYgKDQgPT09IG5vZGUubGVuZ3RoKVxuICAgICAgICAgIGFib3J0UmVtYWluaW5nUmVwbGF5Tm9kZXMoXG4gICAgICAgICAgICByZXF1ZXN0JGpzY29tcCQwLFxuICAgICAgICAgICAgYm91bmRhcnksXG4gICAgICAgICAgICBub2RlWzJdLFxuICAgICAgICAgICAgbm9kZVszXSxcbiAgICAgICAgICAgIGVycm9yJGpzY29tcCQwLFxuICAgICAgICAgICAgZXJyb3JEaWdlc3QkanNjb21wJDAsXG4gICAgICAgICAgICBlcnJvckluZm8kanNjb21wJDAsXG4gICAgICAgICAgICBhYm9ydGVkXG4gICAgICAgICAgKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIHJlcXVlc3QgPSByZXF1ZXN0JGpzY29tcCQwO1xuICAgICAgICAgIG5vZGUgPSBub2RlWzVdO1xuICAgICAgICAgIHZhciBlcnJvciA9IGVycm9yJGpzY29tcCQwLFxuICAgICAgICAgICAgZXJyb3JEaWdlc3QgPSBlcnJvckRpZ2VzdCRqc2NvbXAkMCxcbiAgICAgICAgICAgIGVycm9ySW5mbyA9IGVycm9ySW5mbyRqc2NvbXAkMCxcbiAgICAgICAgICAgIHdhc0Fib3J0ZWQgPSBhYm9ydGVkLFxuICAgICAgICAgICAgcmVzdW1lZEJvdW5kYXJ5ID0gY3JlYXRlU3VzcGVuc2VCb3VuZGFyeShyZXF1ZXN0LCBuZXcgU2V0KCkpO1xuICAgICAgICAgIHJlc3VtZWRCb3VuZGFyeS5wYXJlbnRGbHVzaGVkID0gITA7XG4gICAgICAgICAgcmVzdW1lZEJvdW5kYXJ5LnJvb3RTZWdtZW50SUQgPSBub2RlO1xuICAgICAgICAgIHJlc3VtZWRCb3VuZGFyeS5zdGF0dXMgPSBDTElFTlRfUkVOREVSRUQ7XG4gICAgICAgICAgZW5jb2RlRXJyb3JGb3JCb3VuZGFyeShcbiAgICAgICAgICAgIHJlc3VtZWRCb3VuZGFyeSxcbiAgICAgICAgICAgIGVycm9yRGlnZXN0LFxuICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICBlcnJvckluZm8sXG4gICAgICAgICAgICB3YXNBYm9ydGVkXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXN1bWVkQm91bmRhcnkucGFyZW50Rmx1c2hlZCAmJlxuICAgICAgICAgICAgcmVxdWVzdC5jbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMucHVzaChyZXN1bWVkQm91bmRhcnkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBub2Rlcy5sZW5ndGggPSAwO1xuICAgICAgaWYgKG51bGwgIT09IHNsb3RzKSB7XG4gICAgICAgIGlmIChudWxsID09PSBib3VuZGFyeSlcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiV2Ugc2hvdWxkIG5vdCBoYXZlIGFueSByZXN1bWFibGUgbm9kZXMgaW4gdGhlIHNoZWxsLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgYm91bmRhcnkuc3RhdHVzICE9PSBDTElFTlRfUkVOREVSRUQgJiZcbiAgICAgICAgICAoKGJvdW5kYXJ5LnN0YXR1cyA9IENMSUVOVF9SRU5ERVJFRCksXG4gICAgICAgICAgZW5jb2RlRXJyb3JGb3JCb3VuZGFyeShcbiAgICAgICAgICAgIGJvdW5kYXJ5LFxuICAgICAgICAgICAgZXJyb3JEaWdlc3QkanNjb21wJDAsXG4gICAgICAgICAgICBlcnJvciRqc2NvbXAkMCxcbiAgICAgICAgICAgIGVycm9ySW5mbyRqc2NvbXAkMCxcbiAgICAgICAgICAgIGFib3J0ZWRcbiAgICAgICAgICApLFxuICAgICAgICAgIGJvdW5kYXJ5LnBhcmVudEZsdXNoZWQgJiZcbiAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDAuY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzLnB1c2goYm91bmRhcnkpKTtcbiAgICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBzbG90cylcbiAgICAgICAgICBmb3IgKHZhciBpbmRleCBpbiBzbG90cykgZGVsZXRlIHNsb3RzW2luZGV4XTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYWJvcnRUYXNrKHRhc2ssIHJlcXVlc3QsIGVycm9yKSB7XG4gICAgICB2YXIgYm91bmRhcnkgPSB0YXNrLmJsb2NrZWRCb3VuZGFyeSxcbiAgICAgICAgc2VnbWVudCA9IHRhc2suYmxvY2tlZFNlZ21lbnQ7XG4gICAgICBpZiAobnVsbCAhPT0gc2VnbWVudCkge1xuICAgICAgICBpZiAoNiA9PT0gc2VnbWVudC5zdGF0dXMpIHJldHVybjtcbiAgICAgICAgc2VnbWVudC5zdGF0dXMgPSAzO1xuICAgICAgfVxuICAgICAgc2VnbWVudCA9IGdldFRocm93bkluZm8odGFzay5jb21wb25lbnRTdGFjayk7XG4gICAgICBpZiAobnVsbCA9PT0gYm91bmRhcnkpIHtcbiAgICAgICAgaWYgKDEzICE9PSByZXF1ZXN0LnN0YXR1cyAmJiByZXF1ZXN0LnN0YXR1cyAhPT0gQ0xPU0VEKSB7XG4gICAgICAgICAgYm91bmRhcnkgPSB0YXNrLnJlcGxheTtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gYm91bmRhcnkpIHtcbiAgICAgICAgICAgIGxvZ1JlY292ZXJhYmxlRXJyb3IocmVxdWVzdCwgZXJyb3IsIHNlZ21lbnQpO1xuICAgICAgICAgICAgZmF0YWxFcnJvcihyZXF1ZXN0LCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGJvdW5kYXJ5LnBlbmRpbmdUYXNrcy0tO1xuICAgICAgICAgIDAgPT09IGJvdW5kYXJ5LnBlbmRpbmdUYXNrcyAmJlxuICAgICAgICAgICAgMCA8IGJvdW5kYXJ5Lm5vZGVzLmxlbmd0aCAmJlxuICAgICAgICAgICAgKCh0YXNrID0gbG9nUmVjb3ZlcmFibGVFcnJvcihyZXF1ZXN0LCBlcnJvciwgc2VnbWVudCkpLFxuICAgICAgICAgICAgYWJvcnRSZW1haW5pbmdSZXBsYXlOb2RlcyhcbiAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgYm91bmRhcnkubm9kZXMsXG4gICAgICAgICAgICAgIGJvdW5kYXJ5LnNsb3RzLFxuICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgdGFzayxcbiAgICAgICAgICAgICAgc2VnbWVudCxcbiAgICAgICAgICAgICAgITBcbiAgICAgICAgICAgICkpO1xuICAgICAgICAgIHJlcXVlc3QucGVuZGluZ1Jvb3RUYXNrcy0tO1xuICAgICAgICAgIDAgPT09IHJlcXVlc3QucGVuZGluZ1Jvb3RUYXNrcyAmJiBjb21wbGV0ZVNoZWxsKHJlcXVlc3QpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2VcbiAgICAgICAgYm91bmRhcnkucGVuZGluZ1Rhc2tzLS0sXG4gICAgICAgICAgYm91bmRhcnkuc3RhdHVzICE9PSBDTElFTlRfUkVOREVSRUQgJiZcbiAgICAgICAgICAgICgoYm91bmRhcnkuc3RhdHVzID0gQ0xJRU5UX1JFTkRFUkVEKSxcbiAgICAgICAgICAgICh0YXNrID0gbG9nUmVjb3ZlcmFibGVFcnJvcihyZXF1ZXN0LCBlcnJvciwgc2VnbWVudCkpLFxuICAgICAgICAgICAgKGJvdW5kYXJ5LnN0YXR1cyA9IENMSUVOVF9SRU5ERVJFRCksXG4gICAgICAgICAgICBlbmNvZGVFcnJvckZvckJvdW5kYXJ5KGJvdW5kYXJ5LCB0YXNrLCBlcnJvciwgc2VnbWVudCwgITApLFxuICAgICAgICAgICAgdW50cmFja0JvdW5kYXJ5KHJlcXVlc3QsIGJvdW5kYXJ5KSxcbiAgICAgICAgICAgIGJvdW5kYXJ5LnBhcmVudEZsdXNoZWQgJiZcbiAgICAgICAgICAgICAgcmVxdWVzdC5jbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMucHVzaChib3VuZGFyeSkpLFxuICAgICAgICAgIGJvdW5kYXJ5LmZhbGxiYWNrQWJvcnRhYmxlVGFza3MuZm9yRWFjaChmdW5jdGlvbiAoZmFsbGJhY2tUYXNrKSB7XG4gICAgICAgICAgICByZXR1cm4gYWJvcnRUYXNrKGZhbGxiYWNrVGFzaywgcmVxdWVzdCwgZXJyb3IpO1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIGJvdW5kYXJ5LmZhbGxiYWNrQWJvcnRhYmxlVGFza3MuY2xlYXIoKTtcbiAgICAgIHJlcXVlc3QuYWxsUGVuZGluZ1Rhc2tzLS07XG4gICAgICAwID09PSByZXF1ZXN0LmFsbFBlbmRpbmdUYXNrcyAmJiBjb21wbGV0ZUFsbChyZXF1ZXN0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2FmZWx5RW1pdEVhcmx5UHJlbG9hZHMocmVxdWVzdCwgc2hlbGxDb21wbGV0ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHJlbmRlclN0YXRlID0gcmVxdWVzdC5yZW5kZXJTdGF0ZSxcbiAgICAgICAgICBvbkhlYWRlcnMgPSByZW5kZXJTdGF0ZS5vbkhlYWRlcnM7XG4gICAgICAgIGlmIChvbkhlYWRlcnMpIHtcbiAgICAgICAgICB2YXIgaGVhZGVycyA9IHJlbmRlclN0YXRlLmhlYWRlcnM7XG4gICAgICAgICAgaWYgKGhlYWRlcnMpIHtcbiAgICAgICAgICAgIHJlbmRlclN0YXRlLmhlYWRlcnMgPSBudWxsO1xuICAgICAgICAgICAgdmFyIGxpbmtIZWFkZXIgPSBoZWFkZXJzLnByZWNvbm5lY3RzO1xuICAgICAgICAgICAgaGVhZGVycy5mb250UHJlbG9hZHMgJiZcbiAgICAgICAgICAgICAgKGxpbmtIZWFkZXIgJiYgKGxpbmtIZWFkZXIgKz0gXCIsIFwiKSxcbiAgICAgICAgICAgICAgKGxpbmtIZWFkZXIgKz0gaGVhZGVycy5mb250UHJlbG9hZHMpKTtcbiAgICAgICAgICAgIGhlYWRlcnMuaGlnaEltYWdlUHJlbG9hZHMgJiZcbiAgICAgICAgICAgICAgKGxpbmtIZWFkZXIgJiYgKGxpbmtIZWFkZXIgKz0gXCIsIFwiKSxcbiAgICAgICAgICAgICAgKGxpbmtIZWFkZXIgKz0gaGVhZGVycy5oaWdoSW1hZ2VQcmVsb2FkcykpO1xuICAgICAgICAgICAgaWYgKCFzaGVsbENvbXBsZXRlKSB7XG4gICAgICAgICAgICAgIHZhciBxdWV1ZUl0ZXIgPSByZW5kZXJTdGF0ZS5zdHlsZXMudmFsdWVzKCksXG4gICAgICAgICAgICAgICAgcXVldWVTdGVwID0gcXVldWVJdGVyLm5leHQoKTtcbiAgICAgICAgICAgICAgYjogZm9yIChcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgMCA8IGhlYWRlcnMucmVtYWluaW5nQ2FwYWNpdHkgJiYgIXF1ZXVlU3RlcC5kb25lO1xuICAgICAgICAgICAgICAgIHF1ZXVlU3RlcCA9IHF1ZXVlSXRlci5uZXh0KClcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgICB2YXIgc2hlZXRJdGVyID0gcXVldWVTdGVwLnZhbHVlLnNoZWV0cy52YWx1ZXMoKSxcbiAgICAgICAgICAgICAgICAgICAgc2hlZXRTdGVwID0gc2hlZXRJdGVyLm5leHQoKTtcbiAgICAgICAgICAgICAgICAgIDAgPCBoZWFkZXJzLnJlbWFpbmluZ0NhcGFjaXR5ICYmICFzaGVldFN0ZXAuZG9uZTtcbiAgICAgICAgICAgICAgICAgIHNoZWV0U3RlcCA9IHNoZWV0SXRlci5uZXh0KClcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIHZhciBzaGVldCA9IHNoZWV0U3RlcC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMgPSBzaGVldC5wcm9wcyxcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gcHJvcHMuaHJlZixcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMkanNjb21wJDAgPSBzaGVldC5wcm9wcztcbiAgICAgICAgICAgICAgICAgIHZhciBoZWFkZXIgPSBnZXRQcmVsb2FkQXNIZWFkZXIoXG4gICAgICAgICAgICAgICAgICAgIHByb3BzJGpzY29tcCQwLmhyZWYsXG4gICAgICAgICAgICAgICAgICAgIFwic3R5bGVcIixcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgIGNyb3NzT3JpZ2luOiBwcm9wcyRqc2NvbXAkMC5jcm9zc09yaWdpbixcbiAgICAgICAgICAgICAgICAgICAgICBpbnRlZ3JpdHk6IHByb3BzJGpzY29tcCQwLmludGVncml0eSxcbiAgICAgICAgICAgICAgICAgICAgICBub25jZTogcHJvcHMkanNjb21wJDAubm9uY2UsXG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogcHJvcHMkanNjb21wJDAudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICBmZXRjaFByaW9yaXR5OiBwcm9wcyRqc2NvbXAkMC5mZXRjaFByaW9yaXR5LFxuICAgICAgICAgICAgICAgICAgICAgIHJlZmVycmVyUG9saWN5OiBwcm9wcyRqc2NvbXAkMC5yZWZlcnJlclBvbGljeSxcbiAgICAgICAgICAgICAgICAgICAgICBtZWRpYTogcHJvcHMkanNjb21wJDAubWVkaWFcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGlmICgwIDw9IChoZWFkZXJzLnJlbWFpbmluZ0NhcGFjaXR5IC09IGhlYWRlci5sZW5ndGggKyAyKSlcbiAgICAgICAgICAgICAgICAgICAgKHJlbmRlclN0YXRlLnJlc2V0cy5zdHlsZVtrZXldID0gUFJFTE9BRF9OT19DUkVEUyksXG4gICAgICAgICAgICAgICAgICAgICAgbGlua0hlYWRlciAmJiAobGlua0hlYWRlciArPSBcIiwgXCIpLFxuICAgICAgICAgICAgICAgICAgICAgIChsaW5rSGVhZGVyICs9IGhlYWRlciksXG4gICAgICAgICAgICAgICAgICAgICAgKHJlbmRlclN0YXRlLnJlc2V0cy5zdHlsZVtrZXldID1cbiAgICAgICAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBwcm9wcy5jcm9zc09yaWdpbiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHByb3BzLmludGVncml0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICA/IFtwcm9wcy5jcm9zc09yaWdpbiwgcHJvcHMuaW50ZWdyaXR5XVxuICAgICAgICAgICAgICAgICAgICAgICAgICA6IFBSRUxPQURfTk9fQ1JFRFMpO1xuICAgICAgICAgICAgICAgICAgZWxzZSBicmVhayBiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbmtIZWFkZXIgPyBvbkhlYWRlcnMoeyBMaW5rOiBsaW5rSGVhZGVyIH0pIDogb25IZWFkZXJzKHt9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ1JlY292ZXJhYmxlRXJyb3IocmVxdWVzdCwgZXJyb3IsIHt9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcGxldGVTaGVsbChyZXF1ZXN0KSB7XG4gICAgICBudWxsID09PSByZXF1ZXN0LnRyYWNrZWRQb3N0cG9uZXMgJiYgc2FmZWx5RW1pdEVhcmx5UHJlbG9hZHMocmVxdWVzdCwgITApO1xuICAgICAgcmVxdWVzdC5vblNoZWxsRXJyb3IgPSBub29wO1xuICAgICAgcmVxdWVzdCA9IHJlcXVlc3Qub25TaGVsbFJlYWR5O1xuICAgICAgcmVxdWVzdCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wbGV0ZUFsbChyZXF1ZXN0KSB7XG4gICAgICBzYWZlbHlFbWl0RWFybHlQcmVsb2FkcyhcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgbnVsbCA9PT0gcmVxdWVzdC50cmFja2VkUG9zdHBvbmVzXG4gICAgICAgICAgPyAhMFxuICAgICAgICAgIDogbnVsbCA9PT0gcmVxdWVzdC5jb21wbGV0ZWRSb290U2VnbWVudCB8fFxuICAgICAgICAgICAgICByZXF1ZXN0LmNvbXBsZXRlZFJvb3RTZWdtZW50LnN0YXR1cyAhPT0gUE9TVFBPTkVEXG4gICAgICApO1xuICAgICAgcmVxdWVzdCA9IHJlcXVlc3Qub25BbGxSZWFkeTtcbiAgICAgIHJlcXVlc3QoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcXVldWVDb21wbGV0ZWRTZWdtZW50KGJvdW5kYXJ5LCBzZWdtZW50KSB7XG4gICAgICBpZiAoXG4gICAgICAgIDAgPT09IHNlZ21lbnQuY2h1bmtzLmxlbmd0aCAmJlxuICAgICAgICAxID09PSBzZWdtZW50LmNoaWxkcmVuLmxlbmd0aCAmJlxuICAgICAgICBudWxsID09PSBzZWdtZW50LmNoaWxkcmVuWzBdLmJvdW5kYXJ5ICYmXG4gICAgICAgIC0xID09PSBzZWdtZW50LmNoaWxkcmVuWzBdLmlkXG4gICAgICApIHtcbiAgICAgICAgdmFyIGNoaWxkU2VnbWVudCA9IHNlZ21lbnQuY2hpbGRyZW5bMF07XG4gICAgICAgIGNoaWxkU2VnbWVudC5pZCA9IHNlZ21lbnQuaWQ7XG4gICAgICAgIGNoaWxkU2VnbWVudC5wYXJlbnRGbHVzaGVkID0gITA7XG4gICAgICAgIGNoaWxkU2VnbWVudC5zdGF0dXMgPT09IENPTVBMRVRFRCAmJlxuICAgICAgICAgIHF1ZXVlQ29tcGxldGVkU2VnbWVudChib3VuZGFyeSwgY2hpbGRTZWdtZW50KTtcbiAgICAgIH0gZWxzZSBib3VuZGFyeS5jb21wbGV0ZWRTZWdtZW50cy5wdXNoKHNlZ21lbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5pc2hlZFRhc2socmVxdWVzdCwgYm91bmRhcnksIHNlZ21lbnQpIHtcbiAgICAgIGlmIChudWxsID09PSBib3VuZGFyeSkge1xuICAgICAgICBpZiAobnVsbCAhPT0gc2VnbWVudCAmJiBzZWdtZW50LnBhcmVudEZsdXNoZWQpIHtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gcmVxdWVzdC5jb21wbGV0ZWRSb290U2VnbWVudClcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICBcIlRoZXJlIGNhbiBvbmx5IGJlIG9uZSByb290IHNlZ21lbnQuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgcmVxdWVzdC5jb21wbGV0ZWRSb290U2VnbWVudCA9IHNlZ21lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzLS07XG4gICAgICAgIDAgPT09IHJlcXVlc3QucGVuZGluZ1Jvb3RUYXNrcyAmJiBjb21wbGV0ZVNoZWxsKHJlcXVlc3QpO1xuICAgICAgfSBlbHNlXG4gICAgICAgIGJvdW5kYXJ5LnBlbmRpbmdUYXNrcy0tLFxuICAgICAgICAgIGJvdW5kYXJ5LnN0YXR1cyAhPT0gQ0xJRU5UX1JFTkRFUkVEICYmXG4gICAgICAgICAgICAoMCA9PT0gYm91bmRhcnkucGVuZGluZ1Rhc2tzXG4gICAgICAgICAgICAgID8gKGJvdW5kYXJ5LnN0YXR1cyA9PT0gUEVORElORyAmJiAoYm91bmRhcnkuc3RhdHVzID0gQ09NUExFVEVEKSxcbiAgICAgICAgICAgICAgICBudWxsICE9PSBzZWdtZW50ICYmXG4gICAgICAgICAgICAgICAgICBzZWdtZW50LnBhcmVudEZsdXNoZWQgJiZcbiAgICAgICAgICAgICAgICAgIHNlZ21lbnQuc3RhdHVzID09PSBDT01QTEVURUQgJiZcbiAgICAgICAgICAgICAgICAgIHF1ZXVlQ29tcGxldGVkU2VnbWVudChib3VuZGFyeSwgc2VnbWVudCksXG4gICAgICAgICAgICAgICAgYm91bmRhcnkucGFyZW50Rmx1c2hlZCAmJlxuICAgICAgICAgICAgICAgICAgcmVxdWVzdC5jb21wbGV0ZWRCb3VuZGFyaWVzLnB1c2goYm91bmRhcnkpLFxuICAgICAgICAgICAgICAgIGJvdW5kYXJ5LnN0YXR1cyA9PT0gQ09NUExFVEVEICYmXG4gICAgICAgICAgICAgICAgICAoYm91bmRhcnkuZmFsbGJhY2tBYm9ydGFibGVUYXNrcy5mb3JFYWNoKFxuICAgICAgICAgICAgICAgICAgICBhYm9ydFRhc2tTb2Z0LFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0XG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgYm91bmRhcnkuZmFsbGJhY2tBYm9ydGFibGVUYXNrcy5jbGVhcigpKSlcbiAgICAgICAgICAgICAgOiBudWxsICE9PSBzZWdtZW50ICYmXG4gICAgICAgICAgICAgICAgc2VnbWVudC5wYXJlbnRGbHVzaGVkICYmXG4gICAgICAgICAgICAgICAgc2VnbWVudC5zdGF0dXMgPT09IENPTVBMRVRFRCAmJlxuICAgICAgICAgICAgICAgIChxdWV1ZUNvbXBsZXRlZFNlZ21lbnQoYm91bmRhcnksIHNlZ21lbnQpLFxuICAgICAgICAgICAgICAgIDEgPT09IGJvdW5kYXJ5LmNvbXBsZXRlZFNlZ21lbnRzLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgYm91bmRhcnkucGFyZW50Rmx1c2hlZCAmJlxuICAgICAgICAgICAgICAgICAgcmVxdWVzdC5wYXJ0aWFsQm91bmRhcmllcy5wdXNoKGJvdW5kYXJ5KSkpO1xuICAgICAgcmVxdWVzdC5hbGxQZW5kaW5nVGFza3MtLTtcbiAgICAgIDAgPT09IHJlcXVlc3QuYWxsUGVuZGluZ1Rhc2tzICYmIGNvbXBsZXRlQWxsKHJlcXVlc3QpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwZXJmb3JtV29yayhyZXF1ZXN0JGpzY29tcCQxKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHJlcXVlc3QkanNjb21wJDEuc3RhdHVzICE9PSBDTE9TRUQgJiZcbiAgICAgICAgMTMgIT09IHJlcXVlc3QkanNjb21wJDEuc3RhdHVzXG4gICAgICApIHtcbiAgICAgICAgdmFyIHByZXZDb250ZXh0ID0gY3VycmVudEFjdGl2ZVNuYXBzaG90LFxuICAgICAgICAgIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEhvb2tzRGlzcGF0Y2hlcjtcbiAgICAgICAgdmFyIHByZXZBc3luY0Rpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5BO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5BID0gRGVmYXVsdEFzeW5jRGlzcGF0Y2hlcjtcbiAgICAgICAgdmFyIHByZXZSZXF1ZXN0ID0gY3VycmVudFJlcXVlc3Q7XG4gICAgICAgIGN1cnJlbnRSZXF1ZXN0ID0gcmVxdWVzdCRqc2NvbXAkMTtcbiAgICAgICAgdmFyIHByZXZHZXRDdXJyZW50U3RhY2tJbXBsID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuZ2V0Q3VycmVudFN0YWNrO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2sgPSBnZXRDdXJyZW50U3RhY2tJbkRFVjtcbiAgICAgICAgdmFyIHByZXZSZXN1bWFibGVTdGF0ZSA9IGN1cnJlbnRSZXN1bWFibGVTdGF0ZTtcbiAgICAgICAgY3VycmVudFJlc3VtYWJsZVN0YXRlID0gcmVxdWVzdCRqc2NvbXAkMS5yZXN1bWFibGVTdGF0ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgcGluZ2VkVGFza3MgPSByZXF1ZXN0JGpzY29tcCQxLnBpbmdlZFRhc2tzLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGluZ2VkVGFza3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gcmVxdWVzdCRqc2NvbXAkMSxcbiAgICAgICAgICAgICAgdGFzayA9IHBpbmdlZFRhc2tzW2ldLFxuICAgICAgICAgICAgICBzZWdtZW50ID0gdGFzay5ibG9ja2VkU2VnbWVudDtcbiAgICAgICAgICAgIGlmIChudWxsID09PSBzZWdtZW50KSB7XG4gICAgICAgICAgICAgIHZhciBwcmV2VGFza0luREVWID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDAgPSByZXF1ZXN0O1xuICAgICAgICAgICAgICByZXF1ZXN0ID0gdGFzaztcbiAgICAgICAgICAgICAgaWYgKDAgIT09IHJlcXVlc3QucmVwbGF5LnBlbmRpbmdUYXNrcykge1xuICAgICAgICAgICAgICAgIHN3aXRjaENvbnRleHQocmVxdWVzdC5jb250ZXh0KTtcbiAgICAgICAgICAgICAgICBwcmV2VGFza0luREVWID0gY3VycmVudFRhc2tJbkRFVjtcbiAgICAgICAgICAgICAgICBjdXJyZW50VGFza0luREVWID0gcmVxdWVzdDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIHJlcXVlc3QucmVwbGF5LnNsb3RzXG4gICAgICAgICAgICAgICAgICAgID8gcmVzdW1lTm9kZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5yZXBsYXkuc2xvdHMsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0Lm5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmNoaWxkSW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIDogcmV0cnlOb2RlKHJlcXVlc3QkanNjb21wJDAsIHJlcXVlc3QpO1xuICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAxID09PSByZXF1ZXN0LnJlcGxheS5wZW5kaW5nVGFza3MgJiZcbiAgICAgICAgICAgICAgICAgICAgMCA8IHJlcXVlc3QucmVwbGF5Lm5vZGVzLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICBcIkNvdWxkbid0IGZpbmQgYWxsIHJlc3VtYWJsZSBzbG90cyBieSBrZXkvaW5kZXggZHVyaW5nIHJlcGxheWluZy4gVGhlIHRyZWUgZG9lc24ndCBtYXRjaCBzbyBSZWFjdCB3aWxsIGZhbGxiYWNrIHRvIGNsaWVudCByZW5kZXJpbmcuXCJcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3QucmVwbGF5LnBlbmRpbmdUYXNrcy0tO1xuICAgICAgICAgICAgICAgICAgcmVxdWVzdC5hYm9ydFNldC5kZWxldGUocmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFRhc2socmVxdWVzdCRqc2NvbXAkMCwgcmVxdWVzdC5ibG9ja2VkQm91bmRhcnksIG51bGwpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHRocm93blZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICByZXNldEhvb2tzU3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgIHZhciB4ID1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3duVmFsdWUgPT09IFN1c3BlbnNlRXhjZXB0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgPyBnZXRTdXNwZW5kZWRUaGVuYWJsZSgpXG4gICAgICAgICAgICAgICAgICAgICAgOiB0aHJvd25WYWx1ZTtcbiAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHggJiZcbiAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0geCAmJlxuICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB4LnRoZW5cbiAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGluZyA9IHJlcXVlc3QucGluZztcbiAgICAgICAgICAgICAgICAgICAgeC50aGVuKHBpbmcsIHBpbmcpO1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnRoZW5hYmxlU3RhdGUgPSBnZXRUaGVuYWJsZVN0YXRlQWZ0ZXJTdXNwZW5kaW5nKCk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnJlcGxheS5wZW5kaW5nVGFza3MtLTtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5hYm9ydFNldC5kZWxldGUocmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvckluZm8gPSBnZXRUaHJvd25JbmZvKHJlcXVlc3QuY29tcG9uZW50U3RhY2spO1xuICAgICAgICAgICAgICAgICAgICBlcnJvcmVkUmVwbGF5KFxuICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5ibG9ja2VkQm91bmRhcnksXG4gICAgICAgICAgICAgICAgICAgICAgMTIgPT09IHJlcXVlc3QkanNjb21wJDAuc3RhdHVzXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHJlcXVlc3QkanNjb21wJDAuZmF0YWxFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgOiB4LFxuICAgICAgICAgICAgICAgICAgICAgIGVycm9ySW5mbyxcbiAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnJlcGxheS5ub2RlcyxcbiAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnJlcGxheS5zbG90c1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0JGpzY29tcCQwLnBlbmRpbmdSb290VGFza3MtLTtcbiAgICAgICAgICAgICAgICAgICAgMCA9PT0gcmVxdWVzdCRqc2NvbXAkMC5wZW5kaW5nUm9vdFRhc2tzICYmXG4gICAgICAgICAgICAgICAgICAgICAgY29tcGxldGVTaGVsbChyZXF1ZXN0JGpzY29tcCQwKTtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCRqc2NvbXAkMC5hbGxQZW5kaW5nVGFza3MtLTtcbiAgICAgICAgICAgICAgICAgICAgMCA9PT0gcmVxdWVzdCRqc2NvbXAkMC5hbGxQZW5kaW5nVGFza3MgJiZcbiAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZUFsbChyZXF1ZXN0JGpzY29tcCQwKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgY3VycmVudFRhc2tJbkRFViA9IHByZXZUYXNrSW5ERVY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXF1ZXN0JGpzY29tcCQwID0gcHJldlRhc2tJbkRFViA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgdmFyIHRhc2skanNjb21wJDAgPSB0YXNrLFxuICAgICAgICAgICAgICAgIHNlZ21lbnQkanNjb21wJDAgPSBzZWdtZW50O1xuICAgICAgICAgICAgICBpZiAoc2VnbWVudCRqc2NvbXAkMC5zdGF0dXMgPT09IFBFTkRJTkcpIHtcbiAgICAgICAgICAgICAgICBzZWdtZW50JGpzY29tcCQwLnN0YXR1cyA9IDY7XG4gICAgICAgICAgICAgICAgc3dpdGNoQ29udGV4dCh0YXNrJGpzY29tcCQwLmNvbnRleHQpO1xuICAgICAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDAgPSBjdXJyZW50VGFza0luREVWO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRUYXNrSW5ERVYgPSB0YXNrJGpzY29tcCQwO1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZHJlbkxlbmd0aCA9IHNlZ21lbnQkanNjb21wJDAuY2hpbGRyZW4ubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgY2h1bmtMZW5ndGggPSBzZWdtZW50JGpzY29tcCQwLmNodW5rcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHJldHJ5Tm9kZShyZXF1ZXN0LCB0YXNrJGpzY29tcCQwKSxcbiAgICAgICAgICAgICAgICAgICAgcHVzaFNlZ21lbnRGaW5hbGUoXG4gICAgICAgICAgICAgICAgICAgICAgc2VnbWVudCRqc2NvbXAkMC5jaHVua3MsXG4gICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5yZW5kZXJTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50JGpzY29tcCQwLmxhc3RQdXNoZWRUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnQkanNjb21wJDAudGV4dEVtYmVkZGVkXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIHRhc2skanNjb21wJDAuYWJvcnRTZXQuZGVsZXRlKHRhc2skanNjb21wJDApLFxuICAgICAgICAgICAgICAgICAgICAoc2VnbWVudCRqc2NvbXAkMC5zdGF0dXMgPSBDT01QTEVURUQpLFxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFRhc2soXG4gICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgICB0YXNrJGpzY29tcCQwLmJsb2NrZWRCb3VuZGFyeSxcbiAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50JGpzY29tcCQwXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAodGhyb3duVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIHJlc2V0SG9va3NTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgc2VnbWVudCRqc2NvbXAkMC5jaGlsZHJlbi5sZW5ndGggPSBjaGlsZHJlbkxlbmd0aDtcbiAgICAgICAgICAgICAgICAgIHNlZ21lbnQkanNjb21wJDAuY2h1bmtzLmxlbmd0aCA9IGNodW5rTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgdmFyIHgkanNjb21wJDAgPVxuICAgICAgICAgICAgICAgICAgICB0aHJvd25WYWx1ZSA9PT0gU3VzcGVuc2VFeGNlcHRpb25cbiAgICAgICAgICAgICAgICAgICAgICA/IGdldFN1c3BlbmRlZFRoZW5hYmxlKClcbiAgICAgICAgICAgICAgICAgICAgICA6IDEyID09PSByZXF1ZXN0LnN0YXR1c1xuICAgICAgICAgICAgICAgICAgICAgICAgPyByZXF1ZXN0LmZhdGFsRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdGhyb3duVmFsdWU7XG4gICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiB4JGpzY29tcCQwICYmXG4gICAgICAgICAgICAgICAgICAgIG51bGwgIT09IHgkanNjb21wJDAgJiZcbiAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgeCRqc2NvbXAkMC50aGVuXG4gICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudCRqc2NvbXAkMC5zdGF0dXMgPSBQRU5ESU5HO1xuICAgICAgICAgICAgICAgICAgICB0YXNrJGpzY29tcCQwLnRoZW5hYmxlU3RhdGUgPVxuICAgICAgICAgICAgICAgICAgICAgIGdldFRoZW5hYmxlU3RhdGVBZnRlclN1c3BlbmRpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBpbmckanNjb21wJDAgPSB0YXNrJGpzY29tcCQwLnBpbmc7XG4gICAgICAgICAgICAgICAgICAgIHgkanNjb21wJDAudGhlbihwaW5nJGpzY29tcCQwLCBwaW5nJGpzY29tcCQwKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvckluZm8kanNjb21wJDAgPSBnZXRUaHJvd25JbmZvKFxuICAgICAgICAgICAgICAgICAgICAgIHRhc2skanNjb21wJDAuY29tcG9uZW50U3RhY2tcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgdGFzayRqc2NvbXAkMC5hYm9ydFNldC5kZWxldGUodGFzayRqc2NvbXAkMCk7XG4gICAgICAgICAgICAgICAgICAgIHNlZ21lbnQkanNjb21wJDAuc3RhdHVzID0gNDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvdW5kYXJ5ID0gdGFzayRqc2NvbXAkMC5ibG9ja2VkQm91bmRhcnk7XG4gICAgICAgICAgICAgICAgICAgIHByZXZUYXNrSW5ERVYgPSBsb2dSZWNvdmVyYWJsZUVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgeCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICBlcnJvckluZm8kanNjb21wJDBcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgbnVsbCA9PT0gYm91bmRhcnlcbiAgICAgICAgICAgICAgICAgICAgICA/IGZhdGFsRXJyb3IocmVxdWVzdCwgeCRqc2NvbXAkMClcbiAgICAgICAgICAgICAgICAgICAgICA6IChib3VuZGFyeS5wZW5kaW5nVGFza3MtLSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kYXJ5LnN0YXR1cyAhPT0gQ0xJRU5UX1JFTkRFUkVEICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICgoYm91bmRhcnkuc3RhdHVzID0gQ0xJRU5UX1JFTkRFUkVEKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlRXJyb3JGb3JCb3VuZGFyeShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3VuZGFyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2VGFza0luREVWLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JJbmZvJGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICExXG4gICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHVudHJhY2tCb3VuZGFyeShyZXF1ZXN0LCBib3VuZGFyeSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kYXJ5LnBhcmVudEZsdXNoZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmNsaWVudFJlbmRlcmVkQm91bmRhcmllcy5wdXNoKGJvdW5kYXJ5KSkpO1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmFsbFBlbmRpbmdUYXNrcy0tO1xuICAgICAgICAgICAgICAgICAgICAwID09PSByZXF1ZXN0LmFsbFBlbmRpbmdUYXNrcyAmJiBjb21wbGV0ZUFsbChyZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgY3VycmVudFRhc2tJbkRFViA9IHJlcXVlc3QkanNjb21wJDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHBpbmdlZFRhc2tzLnNwbGljZSgwLCBpKTtcbiAgICAgICAgICBudWxsICE9PSByZXF1ZXN0JGpzY29tcCQxLmRlc3RpbmF0aW9uICYmXG4gICAgICAgICAgICBmbHVzaENvbXBsZXRlZFF1ZXVlcyhcbiAgICAgICAgICAgICAgcmVxdWVzdCRqc2NvbXAkMSxcbiAgICAgICAgICAgICAgcmVxdWVzdCRqc2NvbXAkMS5kZXN0aW5hdGlvblxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBsb2dSZWNvdmVyYWJsZUVycm9yKHJlcXVlc3QkanNjb21wJDEsIGVycm9yLCB7fSksXG4gICAgICAgICAgICBmYXRhbEVycm9yKHJlcXVlc3QkanNjb21wJDEsIGVycm9yKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAoY3VycmVudFJlc3VtYWJsZVN0YXRlID0gcHJldlJlc3VtYWJsZVN0YXRlKSxcbiAgICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXIpLFxuICAgICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLkEgPSBwcmV2QXN5bmNEaXNwYXRjaGVyKSxcbiAgICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2sgPSBwcmV2R2V0Q3VycmVudFN0YWNrSW1wbCksXG4gICAgICAgICAgICBwcmV2RGlzcGF0Y2hlciA9PT0gSG9va3NEaXNwYXRjaGVyICYmIHN3aXRjaENvbnRleHQocHJldkNvbnRleHQpLFxuICAgICAgICAgICAgKGN1cnJlbnRSZXF1ZXN0ID0gcHJldlJlcXVlc3QpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsdXNoU3VidHJlZShyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgc2VnbWVudCwgaG9pc3RhYmxlU3RhdGUpIHtcbiAgICAgIHNlZ21lbnQucGFyZW50Rmx1c2hlZCA9ICEwO1xuICAgICAgc3dpdGNoIChzZWdtZW50LnN0YXR1cykge1xuICAgICAgICBjYXNlIFBFTkRJTkc6XG4gICAgICAgICAgc2VnbWVudC5pZCA9IHJlcXVlc3QubmV4dFNlZ21lbnRJZCsrO1xuICAgICAgICBjYXNlIFBPU1RQT05FRDpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGhvaXN0YWJsZVN0YXRlID0gc2VnbWVudC5pZCksXG4gICAgICAgICAgICAoc2VnbWVudC5sYXN0UHVzaGVkVGV4dCA9ICExKSxcbiAgICAgICAgICAgIChzZWdtZW50LnRleHRFbWJlZGRlZCA9ICExKSxcbiAgICAgICAgICAgIChyZXF1ZXN0ID0gcmVxdWVzdC5yZW5kZXJTdGF0ZSksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHBsYWNlaG9sZGVyMSksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHJlcXVlc3QucGxhY2Vob2xkZXJQcmVmaXgpLFxuICAgICAgICAgICAgKHJlcXVlc3QgPSBob2lzdGFibGVTdGF0ZS50b1N0cmluZygxNikpLFxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChyZXF1ZXN0KSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2gocGxhY2Vob2xkZXIyKVxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgQ09NUExFVEVEOlxuICAgICAgICAgIHNlZ21lbnQuc3RhdHVzID0gRkxVU0hFRDtcbiAgICAgICAgICB2YXIgciA9ICEwLFxuICAgICAgICAgICAgY2h1bmtzID0gc2VnbWVudC5jaHVua3MsXG4gICAgICAgICAgICBjaHVua0lkeCA9IDA7XG4gICAgICAgICAgc2VnbWVudCA9IHNlZ21lbnQuY2hpbGRyZW47XG4gICAgICAgICAgZm9yICh2YXIgY2hpbGRJZHggPSAwOyBjaGlsZElkeCA8IHNlZ21lbnQubGVuZ3RoOyBjaGlsZElkeCsrKSB7XG4gICAgICAgICAgICBmb3IgKHIgPSBzZWdtZW50W2NoaWxkSWR4XTsgY2h1bmtJZHggPCByLmluZGV4OyBjaHVua0lkeCsrKVxuICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKGNodW5rc1tjaHVua0lkeF0pO1xuICAgICAgICAgICAgciA9IGZsdXNoU2VnbWVudChyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgciwgaG9pc3RhYmxlU3RhdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKDsgY2h1bmtJZHggPCBjaHVua3MubGVuZ3RoIC0gMTsgY2h1bmtJZHgrKylcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goY2h1bmtzW2NodW5rSWR4XSk7XG4gICAgICAgICAgY2h1bmtJZHggPCBjaHVua3MubGVuZ3RoICYmIChyID0gZGVzdGluYXRpb24ucHVzaChjaHVua3NbY2h1bmtJZHhdKSk7XG4gICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIkFib3J0ZWQsIGVycm9yZWQgb3IgYWxyZWFkeSBmbHVzaGVkIGJvdW5kYXJpZXMgc2hvdWxkIG5vdCBiZSBmbHVzaGVkIGFnYWluLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZmx1c2hTZWdtZW50KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBzZWdtZW50LCBob2lzdGFibGVTdGF0ZSkge1xuICAgICAgdmFyIGJvdW5kYXJ5ID0gc2VnbWVudC5ib3VuZGFyeTtcbiAgICAgIGlmIChudWxsID09PSBib3VuZGFyeSlcbiAgICAgICAgcmV0dXJuIGZsdXNoU3VidHJlZShyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgc2VnbWVudCwgaG9pc3RhYmxlU3RhdGUpO1xuICAgICAgYm91bmRhcnkucGFyZW50Rmx1c2hlZCA9ICEwO1xuICAgICAgaWYgKGJvdW5kYXJ5LnN0YXR1cyA9PT0gQ0xJRU5UX1JFTkRFUkVEKSB7XG4gICAgICAgIGlmICghcmVxdWVzdC5yZW5kZXJTdGF0ZS5nZW5lcmF0ZVN0YXRpY01hcmt1cCkge1xuICAgICAgICAgIHZhciBlcnJvckRpZ2VzdCA9IGJvdW5kYXJ5LmVycm9yRGlnZXN0LFxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gYm91bmRhcnkuZXJyb3JNZXNzYWdlLFxuICAgICAgICAgICAgZXJyb3JTdGFjayA9IGJvdW5kYXJ5LmVycm9yU3RhY2s7XG4gICAgICAgICAgYm91bmRhcnkgPSBib3VuZGFyeS5lcnJvckNvbXBvbmVudFN0YWNrO1xuICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goc3RhcnRDbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnkpO1xuICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxKTtcbiAgICAgICAgICBlcnJvckRpZ2VzdCAmJlxuICAgICAgICAgICAgKGRlc3RpbmF0aW9uLnB1c2goY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxQSksXG4gICAgICAgICAgICAoZXJyb3JEaWdlc3QgPSBlc2NhcGVUZXh0Rm9yQnJvd3NlcihlcnJvckRpZ2VzdCkpLFxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChlcnJvckRpZ2VzdCksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKFxuICAgICAgICAgICAgICBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvckF0dHJJbnRlcnN0aXRpYWxcbiAgICAgICAgICAgICkpO1xuICAgICAgICAgIGVycm9yTWVzc2FnZSAmJlxuICAgICAgICAgICAgKGRlc3RpbmF0aW9uLnB1c2goY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxQiksXG4gICAgICAgICAgICAoZXJyb3JNZXNzYWdlID0gZXNjYXBlVGV4dEZvckJyb3dzZXIoZXJyb3JNZXNzYWdlKSksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKGVycm9yTWVzc2FnZSksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKFxuICAgICAgICAgICAgICBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvckF0dHJJbnRlcnN0aXRpYWxcbiAgICAgICAgICAgICkpO1xuICAgICAgICAgIGVycm9yU3RhY2sgJiZcbiAgICAgICAgICAgIChkZXN0aW5hdGlvbi5wdXNoKGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMUMpLFxuICAgICAgICAgICAgKGVycm9yU3RhY2sgPSBlc2NhcGVUZXh0Rm9yQnJvd3NlcihlcnJvclN0YWNrKSksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKGVycm9yU3RhY2spLFxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChcbiAgICAgICAgICAgICAgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3JBdHRySW50ZXJzdGl0aWFsXG4gICAgICAgICAgICApKTtcbiAgICAgICAgICBib3VuZGFyeSAmJlxuICAgICAgICAgICAgKGRlc3RpbmF0aW9uLnB1c2goY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxRCksXG4gICAgICAgICAgICAoZXJyb3JTdGFjayA9IGVzY2FwZVRleHRGb3JCcm93c2VyKGJvdW5kYXJ5KSksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKGVycm9yU3RhY2spLFxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChcbiAgICAgICAgICAgICAgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3JBdHRySW50ZXJzdGl0aWFsXG4gICAgICAgICAgICApKTtcbiAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMik7XG4gICAgICAgIH1cbiAgICAgICAgZmx1c2hTdWJ0cmVlKHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBzZWdtZW50LCBob2lzdGFibGVTdGF0ZSk7XG4gICAgICAgIHJlcXVlc3QgPSByZXF1ZXN0LnJlbmRlclN0YXRlLmdlbmVyYXRlU3RhdGljTWFya3VwXG4gICAgICAgICAgPyAhMFxuICAgICAgICAgIDogZGVzdGluYXRpb24ucHVzaChlbmRTdXNwZW5zZUJvdW5kYXJ5KTtcbiAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgICB9XG4gICAgICBpZiAoYm91bmRhcnkuc3RhdHVzICE9PSBDT01QTEVURUQpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgYm91bmRhcnkuc3RhdHVzID09PSBQRU5ESU5HICYmXG4gICAgICAgICAgICAoYm91bmRhcnkucm9vdFNlZ21lbnRJRCA9IHJlcXVlc3QubmV4dFNlZ21lbnRJZCsrKSxcbiAgICAgICAgICAwIDwgYm91bmRhcnkuY29tcGxldGVkU2VnbWVudHMubGVuZ3RoICYmXG4gICAgICAgICAgICByZXF1ZXN0LnBhcnRpYWxCb3VuZGFyaWVzLnB1c2goYm91bmRhcnkpLFxuICAgICAgICAgIHdyaXRlU3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeShcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICAgICAgcmVxdWVzdC5yZW5kZXJTdGF0ZSxcbiAgICAgICAgICAgIGJvdW5kYXJ5LnJvb3RTZWdtZW50SURcbiAgICAgICAgICApLFxuICAgICAgICAgIGhvaXN0YWJsZVN0YXRlICYmXG4gICAgICAgICAgICAoKGVycm9yU3RhY2sgPSBib3VuZGFyeS5mYWxsYmFja1N0YXRlKSxcbiAgICAgICAgICAgIGVycm9yU3RhY2suc3R5bGVzLmZvckVhY2goXG4gICAgICAgICAgICAgIGhvaXN0U3R5bGVRdWV1ZURlcGVuZGVuY3ksXG4gICAgICAgICAgICAgIGhvaXN0YWJsZVN0YXRlXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgZXJyb3JTdGFjay5zdHlsZXNoZWV0cy5mb3JFYWNoKFxuICAgICAgICAgICAgICBob2lzdFN0eWxlc2hlZXREZXBlbmRlbmN5LFxuICAgICAgICAgICAgICBob2lzdGFibGVTdGF0ZVxuICAgICAgICAgICAgKSksXG4gICAgICAgICAgZmx1c2hTdWJ0cmVlKHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBzZWdtZW50LCBob2lzdGFibGVTdGF0ZSksXG4gICAgICAgICAgZGVzdGluYXRpb24ucHVzaChlbmRTdXNwZW5zZUJvdW5kYXJ5KVxuICAgICAgICApO1xuICAgICAgaWYgKGJvdW5kYXJ5LmJ5dGVTaXplID4gcmVxdWVzdC5wcm9ncmVzc2l2ZUNodW5rU2l6ZSlcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAoYm91bmRhcnkucm9vdFNlZ21lbnRJRCA9IHJlcXVlc3QubmV4dFNlZ21lbnRJZCsrKSxcbiAgICAgICAgICByZXF1ZXN0LmNvbXBsZXRlZEJvdW5kYXJpZXMucHVzaChib3VuZGFyeSksXG4gICAgICAgICAgd3JpdGVTdGFydFBlbmRpbmdTdXNwZW5zZUJvdW5kYXJ5KFxuICAgICAgICAgICAgZGVzdGluYXRpb24sXG4gICAgICAgICAgICByZXF1ZXN0LnJlbmRlclN0YXRlLFxuICAgICAgICAgICAgYm91bmRhcnkucm9vdFNlZ21lbnRJRFxuICAgICAgICAgICksXG4gICAgICAgICAgZmx1c2hTdWJ0cmVlKHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBzZWdtZW50LCBob2lzdGFibGVTdGF0ZSksXG4gICAgICAgICAgZGVzdGluYXRpb24ucHVzaChlbmRTdXNwZW5zZUJvdW5kYXJ5KVxuICAgICAgICApO1xuICAgICAgaG9pc3RhYmxlU3RhdGUgJiZcbiAgICAgICAgKChzZWdtZW50ID0gYm91bmRhcnkuY29udGVudFN0YXRlKSxcbiAgICAgICAgc2VnbWVudC5zdHlsZXMuZm9yRWFjaChob2lzdFN0eWxlUXVldWVEZXBlbmRlbmN5LCBob2lzdGFibGVTdGF0ZSksXG4gICAgICAgIHNlZ21lbnQuc3R5bGVzaGVldHMuZm9yRWFjaChob2lzdFN0eWxlc2hlZXREZXBlbmRlbmN5LCBob2lzdGFibGVTdGF0ZSkpO1xuICAgICAgcmVxdWVzdC5yZW5kZXJTdGF0ZS5nZW5lcmF0ZVN0YXRpY01hcmt1cCB8fFxuICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHN0YXJ0Q29tcGxldGVkU3VzcGVuc2VCb3VuZGFyeSk7XG4gICAgICBzZWdtZW50ID0gYm91bmRhcnkuY29tcGxldGVkU2VnbWVudHM7XG4gICAgICBpZiAoMSAhPT0gc2VnbWVudC5sZW5ndGgpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiQSBwcmV2aW91c2x5IHVudmlzaXRlZCBib3VuZGFyeSBtdXN0IGhhdmUgZXhhY3RseSBvbmUgcm9vdCBzZWdtZW50LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICk7XG4gICAgICBmbHVzaFNlZ21lbnQocmVxdWVzdCwgZGVzdGluYXRpb24sIHNlZ21lbnRbMF0sIGhvaXN0YWJsZVN0YXRlKTtcbiAgICAgIHJlcXVlc3QgPSByZXF1ZXN0LnJlbmRlclN0YXRlLmdlbmVyYXRlU3RhdGljTWFya3VwXG4gICAgICAgID8gITBcbiAgICAgICAgOiBkZXN0aW5hdGlvbi5wdXNoKGVuZFN1c3BlbnNlQm91bmRhcnkpO1xuICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsdXNoU2VnbWVudENvbnRhaW5lcihcbiAgICAgIHJlcXVlc3QsXG4gICAgICBkZXN0aW5hdGlvbixcbiAgICAgIHNlZ21lbnQsXG4gICAgICBob2lzdGFibGVTdGF0ZVxuICAgICkge1xuICAgICAgd3JpdGVTdGFydFNlZ21lbnQoXG4gICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICByZXF1ZXN0LnJlbmRlclN0YXRlLFxuICAgICAgICBzZWdtZW50LnBhcmVudEZvcm1hdENvbnRleHQsXG4gICAgICAgIHNlZ21lbnQuaWRcbiAgICAgICk7XG4gICAgICBmbHVzaFNlZ21lbnQocmVxdWVzdCwgZGVzdGluYXRpb24sIHNlZ21lbnQsIGhvaXN0YWJsZVN0YXRlKTtcbiAgICAgIHJldHVybiB3cml0ZUVuZFNlZ21lbnQoZGVzdGluYXRpb24sIHNlZ21lbnQucGFyZW50Rm9ybWF0Q29udGV4dCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsdXNoQ29tcGxldGVkQm91bmRhcnkocmVxdWVzdCwgZGVzdGluYXRpb24sIGJvdW5kYXJ5KSB7XG4gICAgICBmb3IgKFxuICAgICAgICB2YXIgY29tcGxldGVkU2VnbWVudHMgPSBib3VuZGFyeS5jb21wbGV0ZWRTZWdtZW50cywgaSA9IDA7XG4gICAgICAgIGkgPCBjb21wbGV0ZWRTZWdtZW50cy5sZW5ndGg7XG4gICAgICAgIGkrK1xuICAgICAgKVxuICAgICAgICBmbHVzaFBhcnRpYWxseUNvbXBsZXRlZFNlZ21lbnQoXG4gICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgICAgICBib3VuZGFyeSxcbiAgICAgICAgICBjb21wbGV0ZWRTZWdtZW50c1tpXVxuICAgICAgICApO1xuICAgICAgY29tcGxldGVkU2VnbWVudHMubGVuZ3RoID0gMDtcbiAgICAgIHdyaXRlSG9pc3RhYmxlc0ZvckJvdW5kYXJ5KFxuICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgICAgYm91bmRhcnkuY29udGVudFN0YXRlLFxuICAgICAgICByZXF1ZXN0LnJlbmRlclN0YXRlXG4gICAgICApO1xuICAgICAgY29tcGxldGVkU2VnbWVudHMgPSByZXF1ZXN0LnJlc3VtYWJsZVN0YXRlO1xuICAgICAgcmVxdWVzdCA9IHJlcXVlc3QucmVuZGVyU3RhdGU7XG4gICAgICBpID0gYm91bmRhcnkucm9vdFNlZ21lbnRJRDtcbiAgICAgIGJvdW5kYXJ5ID0gYm91bmRhcnkuY29udGVudFN0YXRlO1xuICAgICAgdmFyIHJlcXVpcmVzU3R5bGVJbnNlcnRpb24gPSByZXF1ZXN0LnN0eWxlc1RvSG9pc3Q7XG4gICAgICByZXF1ZXN0LnN0eWxlc1RvSG9pc3QgPSAhMTtcbiAgICAgIGRlc3RpbmF0aW9uLnB1c2gocmVxdWVzdC5zdGFydElubGluZVNjcmlwdCk7XG4gICAgICByZXF1aXJlc1N0eWxlSW5zZXJ0aW9uXG4gICAgICAgID8gKGNvbXBsZXRlZFNlZ21lbnRzLmluc3RydWN0aW9ucyAmIFNlbnRDb21wbGV0ZUJvdW5kYXJ5RnVuY3Rpb24pID09PVxuICAgICAgICAgIE5vdGhpbmdTZW50XG4gICAgICAgICAgPyAoKGNvbXBsZXRlZFNlZ21lbnRzLmluc3RydWN0aW9ucyA9XG4gICAgICAgICAgICAgIGNvbXBsZXRlZFNlZ21lbnRzLmluc3RydWN0aW9ucyB8XG4gICAgICAgICAgICAgIFNlbnRTdHlsZUluc2VydGlvbkZ1bmN0aW9uIHxcbiAgICAgICAgICAgICAgU2VudENvbXBsZXRlQm91bmRhcnlGdW5jdGlvbiksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKGNvbXBsZXRlQm91bmRhcnlXaXRoU3R5bGVzU2NyaXB0MUZ1bGxCb3RoKSlcbiAgICAgICAgICA6IChjb21wbGV0ZWRTZWdtZW50cy5pbnN0cnVjdGlvbnMgJiBTZW50U3R5bGVJbnNlcnRpb25GdW5jdGlvbikgPT09XG4gICAgICAgICAgICAgIE5vdGhpbmdTZW50XG4gICAgICAgICAgICA/ICgoY29tcGxldGVkU2VnbWVudHMuaW5zdHJ1Y3Rpb25zIHw9IFNlbnRTdHlsZUluc2VydGlvbkZ1bmN0aW9uKSxcbiAgICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChjb21wbGV0ZUJvdW5kYXJ5V2l0aFN0eWxlc1NjcmlwdDFGdWxsUGFydGlhbCkpXG4gICAgICAgICAgICA6IGRlc3RpbmF0aW9uLnB1c2goY29tcGxldGVCb3VuZGFyeVdpdGhTdHlsZXNTY3JpcHQxUGFydGlhbClcbiAgICAgICAgOiAoY29tcGxldGVkU2VnbWVudHMuaW5zdHJ1Y3Rpb25zICYgU2VudENvbXBsZXRlQm91bmRhcnlGdW5jdGlvbikgPT09XG4gICAgICAgICAgICBOb3RoaW5nU2VudFxuICAgICAgICAgID8gKChjb21wbGV0ZWRTZWdtZW50cy5pbnN0cnVjdGlvbnMgfD0gU2VudENvbXBsZXRlQm91bmRhcnlGdW5jdGlvbiksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKGNvbXBsZXRlQm91bmRhcnlTY3JpcHQxRnVsbCkpXG4gICAgICAgICAgOiBkZXN0aW5hdGlvbi5wdXNoKGNvbXBsZXRlQm91bmRhcnlTY3JpcHQxUGFydGlhbCk7XG4gICAgICBjb21wbGV0ZWRTZWdtZW50cyA9IGkudG9TdHJpbmcoMTYpO1xuICAgICAgZGVzdGluYXRpb24ucHVzaChyZXF1ZXN0LmJvdW5kYXJ5UHJlZml4KTtcbiAgICAgIGRlc3RpbmF0aW9uLnB1c2goY29tcGxldGVkU2VnbWVudHMpO1xuICAgICAgZGVzdGluYXRpb24ucHVzaChjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0Mik7XG4gICAgICBkZXN0aW5hdGlvbi5wdXNoKHJlcXVlc3Quc2VnbWVudFByZWZpeCk7XG4gICAgICBkZXN0aW5hdGlvbi5wdXNoKGNvbXBsZXRlZFNlZ21lbnRzKTtcbiAgICAgIHJlcXVpcmVzU3R5bGVJbnNlcnRpb25cbiAgICAgICAgPyAoZGVzdGluYXRpb24ucHVzaChjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0M2EpLFxuICAgICAgICAgIHdyaXRlU3R5bGVSZXNvdXJjZURlcGVuZGVuY2llc0luSlMoZGVzdGluYXRpb24sIGJvdW5kYXJ5KSlcbiAgICAgICAgOiBkZXN0aW5hdGlvbi5wdXNoKGNvbXBsZXRlQm91bmRhcnlTY3JpcHQzYik7XG4gICAgICBib3VuZGFyeSA9IGRlc3RpbmF0aW9uLnB1c2goY29tcGxldGVCb3VuZGFyeVNjcmlwdEVuZCk7XG4gICAgICByZXR1cm4gd3JpdGVCb290c3RyYXAoZGVzdGluYXRpb24sIHJlcXVlc3QpICYmIGJvdW5kYXJ5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBmbHVzaFBhcnRpYWxseUNvbXBsZXRlZFNlZ21lbnQoXG4gICAgICByZXF1ZXN0LFxuICAgICAgZGVzdGluYXRpb24sXG4gICAgICBib3VuZGFyeSxcbiAgICAgIHNlZ21lbnRcbiAgICApIHtcbiAgICAgIGlmIChzZWdtZW50LnN0YXR1cyA9PT0gRkxVU0hFRCkgcmV0dXJuICEwO1xuICAgICAgdmFyIGhvaXN0YWJsZVN0YXRlID0gYm91bmRhcnkuY29udGVudFN0YXRlLFxuICAgICAgICBzZWdtZW50SUQgPSBzZWdtZW50LmlkO1xuICAgICAgaWYgKC0xID09PSBzZWdtZW50SUQpIHtcbiAgICAgICAgaWYgKC0xID09PSAoc2VnbWVudC5pZCA9IGJvdW5kYXJ5LnJvb3RTZWdtZW50SUQpKVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJBIHJvb3Qgc2VnbWVudCBJRCBtdXN0IGhhdmUgYmVlbiBhc3NpZ25lZCBieSBub3cuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICApO1xuICAgICAgICByZXR1cm4gZmx1c2hTZWdtZW50Q29udGFpbmVyKFxuICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgZGVzdGluYXRpb24sXG4gICAgICAgICAgc2VnbWVudCxcbiAgICAgICAgICBob2lzdGFibGVTdGF0ZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHNlZ21lbnRJRCA9PT0gYm91bmRhcnkucm9vdFNlZ21lbnRJRClcbiAgICAgICAgcmV0dXJuIGZsdXNoU2VnbWVudENvbnRhaW5lcihcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICAgIHNlZ21lbnQsXG4gICAgICAgICAgaG9pc3RhYmxlU3RhdGVcbiAgICAgICAgKTtcbiAgICAgIGZsdXNoU2VnbWVudENvbnRhaW5lcihyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgc2VnbWVudCwgaG9pc3RhYmxlU3RhdGUpO1xuICAgICAgYm91bmRhcnkgPSByZXF1ZXN0LnJlc3VtYWJsZVN0YXRlO1xuICAgICAgcmVxdWVzdCA9IHJlcXVlc3QucmVuZGVyU3RhdGU7XG4gICAgICBkZXN0aW5hdGlvbi5wdXNoKHJlcXVlc3Quc3RhcnRJbmxpbmVTY3JpcHQpO1xuICAgICAgKGJvdW5kYXJ5Lmluc3RydWN0aW9ucyAmIFNlbnRDb21wbGV0ZVNlZ21lbnRGdW5jdGlvbikgPT09IE5vdGhpbmdTZW50XG4gICAgICAgID8gKChib3VuZGFyeS5pbnN0cnVjdGlvbnMgfD0gU2VudENvbXBsZXRlU2VnbWVudEZ1bmN0aW9uKSxcbiAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKGNvbXBsZXRlU2VnbWVudFNjcmlwdDFGdWxsKSlcbiAgICAgICAgOiBkZXN0aW5hdGlvbi5wdXNoKGNvbXBsZXRlU2VnbWVudFNjcmlwdDFQYXJ0aWFsKTtcbiAgICAgIGRlc3RpbmF0aW9uLnB1c2gocmVxdWVzdC5zZWdtZW50UHJlZml4KTtcbiAgICAgIHNlZ21lbnRJRCA9IHNlZ21lbnRJRC50b1N0cmluZygxNik7XG4gICAgICBkZXN0aW5hdGlvbi5wdXNoKHNlZ21lbnRJRCk7XG4gICAgICBkZXN0aW5hdGlvbi5wdXNoKGNvbXBsZXRlU2VnbWVudFNjcmlwdDIpO1xuICAgICAgZGVzdGluYXRpb24ucHVzaChyZXF1ZXN0LnBsYWNlaG9sZGVyUHJlZml4KTtcbiAgICAgIGRlc3RpbmF0aW9uLnB1c2goc2VnbWVudElEKTtcbiAgICAgIGRlc3RpbmF0aW9uID0gZGVzdGluYXRpb24ucHVzaChjb21wbGV0ZVNlZ21lbnRTY3JpcHRFbmQpO1xuICAgICAgcmV0dXJuIGRlc3RpbmF0aW9uO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmbHVzaENvbXBsZXRlZFF1ZXVlcyhyZXF1ZXN0LCBkZXN0aW5hdGlvbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCEoMCA8IHJlcXVlc3QucGVuZGluZ1Jvb3RUYXNrcykpIHtcbiAgICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGNvbXBsZXRlZFJvb3RTZWdtZW50ID0gcmVxdWVzdC5jb21wbGV0ZWRSb290U2VnbWVudDtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gY29tcGxldGVkUm9vdFNlZ21lbnQpIHtcbiAgICAgICAgICAgIGlmIChjb21wbGV0ZWRSb290U2VnbWVudC5zdGF0dXMgPT09IFBPU1RQT05FRCkgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIHJlbmRlclN0YXRlID0gcmVxdWVzdC5yZW5kZXJTdGF0ZSxcbiAgICAgICAgICAgICAgaHRtbENodW5rcyA9IHJlbmRlclN0YXRlLmh0bWxDaHVua3MsXG4gICAgICAgICAgICAgIGhlYWRDaHVua3MgPSByZW5kZXJTdGF0ZS5oZWFkQ2h1bmtzLFxuICAgICAgICAgICAgICBpJGpzY29tcCQwO1xuICAgICAgICAgICAgaWYgKGh0bWxDaHVua3MpIHtcbiAgICAgICAgICAgICAgZm9yIChpJGpzY29tcCQwID0gMDsgaSRqc2NvbXAkMCA8IGh0bWxDaHVua3MubGVuZ3RoOyBpJGpzY29tcCQwKyspXG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChodG1sQ2h1bmtzW2kkanNjb21wJDBdKTtcbiAgICAgICAgICAgICAgaWYgKGhlYWRDaHVua3MpXG4gICAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICAgIGkkanNjb21wJDAgPSAwO1xuICAgICAgICAgICAgICAgICAgaSRqc2NvbXAkMCA8IGhlYWRDaHVua3MubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgaSRqc2NvbXAkMCsrXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChoZWFkQ2h1bmtzW2kkanNjb21wJDBdKTtcbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGNodW5rID0gc3RhcnRDaHVua0ZvclRhZyhcImhlYWRcIik7XG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChjaHVuayk7XG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChoZWFkQ2h1bmtzKVxuICAgICAgICAgICAgICBmb3IgKGkkanNjb21wJDAgPSAwOyBpJGpzY29tcCQwIDwgaGVhZENodW5rcy5sZW5ndGg7IGkkanNjb21wJDArKylcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKGhlYWRDaHVua3NbaSRqc2NvbXAkMF0pO1xuICAgICAgICAgICAgdmFyIGNoYXJzZXRDaHVua3MgPSByZW5kZXJTdGF0ZS5jaGFyc2V0Q2h1bmtzO1xuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgaSRqc2NvbXAkMCA9IDA7XG4gICAgICAgICAgICAgIGkkanNjb21wJDAgPCBjaGFyc2V0Q2h1bmtzLmxlbmd0aDtcbiAgICAgICAgICAgICAgaSRqc2NvbXAkMCsrXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goY2hhcnNldENodW5rc1tpJGpzY29tcCQwXSk7XG4gICAgICAgICAgICBjaGFyc2V0Q2h1bmtzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5wcmVjb25uZWN0cy5mb3JFYWNoKGZsdXNoUmVzb3VyY2UsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgIHJlbmRlclN0YXRlLnByZWNvbm5lY3RzLmNsZWFyKCk7XG4gICAgICAgICAgICB2YXIgdmlld3BvcnRDaHVua3MgPSByZW5kZXJTdGF0ZS52aWV3cG9ydENodW5rcztcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIGkkanNjb21wJDAgPSAwO1xuICAgICAgICAgICAgICBpJGpzY29tcCQwIDwgdmlld3BvcnRDaHVua3MubGVuZ3RoO1xuICAgICAgICAgICAgICBpJGpzY29tcCQwKytcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaCh2aWV3cG9ydENodW5rc1tpJGpzY29tcCQwXSk7XG4gICAgICAgICAgICB2aWV3cG9ydENodW5rcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgcmVuZGVyU3RhdGUuZm9udFByZWxvYWRzLmZvckVhY2goZmx1c2hSZXNvdXJjZSwgZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgcmVuZGVyU3RhdGUuZm9udFByZWxvYWRzLmNsZWFyKCk7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5oaWdoSW1hZ2VQcmVsb2Fkcy5mb3JFYWNoKGZsdXNoUmVzb3VyY2UsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgIHJlbmRlclN0YXRlLmhpZ2hJbWFnZVByZWxvYWRzLmNsZWFyKCk7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5zdHlsZXMuZm9yRWFjaChmbHVzaFN0eWxlc0luUHJlYW1ibGUsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgIHZhciBpbXBvcnRNYXBDaHVua3MgPSByZW5kZXJTdGF0ZS5pbXBvcnRNYXBDaHVua3M7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICBpJGpzY29tcCQwID0gMDtcbiAgICAgICAgICAgICAgaSRqc2NvbXAkMCA8IGltcG9ydE1hcENodW5rcy5sZW5ndGg7XG4gICAgICAgICAgICAgIGkkanNjb21wJDArK1xuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKGltcG9ydE1hcENodW5rc1tpJGpzY29tcCQwXSk7XG4gICAgICAgICAgICBpbXBvcnRNYXBDaHVua3MubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHJlbmRlclN0YXRlLmJvb3RzdHJhcFNjcmlwdHMuZm9yRWFjaChmbHVzaFJlc291cmNlLCBkZXN0aW5hdGlvbik7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5zY3JpcHRzLmZvckVhY2goZmx1c2hSZXNvdXJjZSwgZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgcmVuZGVyU3RhdGUuc2NyaXB0cy5jbGVhcigpO1xuICAgICAgICAgICAgcmVuZGVyU3RhdGUuYnVsa1ByZWxvYWRzLmZvckVhY2goZmx1c2hSZXNvdXJjZSwgZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgcmVuZGVyU3RhdGUuYnVsa1ByZWxvYWRzLmNsZWFyKCk7XG4gICAgICAgICAgICB2YXIgaG9pc3RhYmxlQ2h1bmtzID0gcmVuZGVyU3RhdGUuaG9pc3RhYmxlQ2h1bmtzO1xuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgaSRqc2NvbXAkMCA9IDA7XG4gICAgICAgICAgICAgIGkkanNjb21wJDAgPCBob2lzdGFibGVDaHVua3MubGVuZ3RoO1xuICAgICAgICAgICAgICBpJGpzY29tcCQwKytcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChob2lzdGFibGVDaHVua3NbaSRqc2NvbXAkMF0pO1xuICAgICAgICAgICAgaG9pc3RhYmxlQ2h1bmtzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICBpZiAoaHRtbENodW5rcyAmJiBudWxsID09PSBoZWFkQ2h1bmtzKSB7XG4gICAgICAgICAgICAgIHZhciBjaHVuayRqc2NvbXAkMCA9IGVuZENodW5rRm9yVGFnKFwiaGVhZFwiKTtcbiAgICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChjaHVuayRqc2NvbXAkMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmbHVzaFNlZ21lbnQocmVxdWVzdCwgZGVzdGluYXRpb24sIGNvbXBsZXRlZFJvb3RTZWdtZW50LCBudWxsKTtcbiAgICAgICAgICAgIHJlcXVlc3QuY29tcGxldGVkUm9vdFNlZ21lbnQgPSBudWxsO1xuICAgICAgICAgICAgd3JpdGVCb290c3RyYXAoZGVzdGluYXRpb24sIHJlcXVlc3QucmVuZGVyU3RhdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcmVuZGVyU3RhdGUkanNjb21wJDAgPSByZXF1ZXN0LnJlbmRlclN0YXRlO1xuICAgICAgICAgIGNvbXBsZXRlZFJvb3RTZWdtZW50ID0gMDtcbiAgICAgICAgICB2YXIgdmlld3BvcnRDaHVua3MkanNjb21wJDAgPSByZW5kZXJTdGF0ZSRqc2NvbXAkMC52aWV3cG9ydENodW5rcztcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgY29tcGxldGVkUm9vdFNlZ21lbnQgPSAwO1xuICAgICAgICAgICAgY29tcGxldGVkUm9vdFNlZ21lbnQgPCB2aWV3cG9ydENodW5rcyRqc2NvbXAkMC5sZW5ndGg7XG4gICAgICAgICAgICBjb21wbGV0ZWRSb290U2VnbWVudCsrXG4gICAgICAgICAgKVxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaCh2aWV3cG9ydENodW5rcyRqc2NvbXAkMFtjb21wbGV0ZWRSb290U2VnbWVudF0pO1xuICAgICAgICAgIHZpZXdwb3J0Q2h1bmtzJGpzY29tcCQwLmxlbmd0aCA9IDA7XG4gICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDAucHJlY29ubmVjdHMuZm9yRWFjaChmbHVzaFJlc291cmNlLCBkZXN0aW5hdGlvbik7XG4gICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDAucHJlY29ubmVjdHMuY2xlYXIoKTtcbiAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMC5mb250UHJlbG9hZHMuZm9yRWFjaChmbHVzaFJlc291cmNlLCBkZXN0aW5hdGlvbik7XG4gICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDAuZm9udFByZWxvYWRzLmNsZWFyKCk7XG4gICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDAuaGlnaEltYWdlUHJlbG9hZHMuZm9yRWFjaChcbiAgICAgICAgICAgIGZsdXNoUmVzb3VyY2UsXG4gICAgICAgICAgICBkZXN0aW5hdGlvblxuICAgICAgICAgICk7XG4gICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDAuaGlnaEltYWdlUHJlbG9hZHMuY2xlYXIoKTtcbiAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMC5zdHlsZXMuZm9yRWFjaChwcmVsb2FkTGF0ZVN0eWxlcywgZGVzdGluYXRpb24pO1xuICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQwLnNjcmlwdHMuZm9yRWFjaChmbHVzaFJlc291cmNlLCBkZXN0aW5hdGlvbik7XG4gICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDAuc2NyaXB0cy5jbGVhcigpO1xuICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQwLmJ1bGtQcmVsb2Fkcy5mb3JFYWNoKGZsdXNoUmVzb3VyY2UsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMC5idWxrUHJlbG9hZHMuY2xlYXIoKTtcbiAgICAgICAgICB2YXIgaG9pc3RhYmxlQ2h1bmtzJGpzY29tcCQwID0gcmVuZGVyU3RhdGUkanNjb21wJDAuaG9pc3RhYmxlQ2h1bmtzO1xuICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICBjb21wbGV0ZWRSb290U2VnbWVudCA9IDA7XG4gICAgICAgICAgICBjb21wbGV0ZWRSb290U2VnbWVudCA8IGhvaXN0YWJsZUNodW5rcyRqc2NvbXAkMC5sZW5ndGg7XG4gICAgICAgICAgICBjb21wbGV0ZWRSb290U2VnbWVudCsrXG4gICAgICAgICAgKVxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChob2lzdGFibGVDaHVua3MkanNjb21wJDBbY29tcGxldGVkUm9vdFNlZ21lbnRdKTtcbiAgICAgICAgICBob2lzdGFibGVDaHVua3MkanNjb21wJDAubGVuZ3RoID0gMDtcbiAgICAgICAgICB2YXIgY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzID0gcmVxdWVzdC5jbGllbnRSZW5kZXJlZEJvdW5kYXJpZXM7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNsaWVudFJlbmRlcmVkQm91bmRhcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGJvdW5kYXJ5ID0gY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzW2ldO1xuICAgICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDAgPSBkZXN0aW5hdGlvbjtcbiAgICAgICAgICAgIHZhciByZXN1bWFibGVTdGF0ZSA9IHJlcXVlc3QucmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQxID0gcmVxdWVzdC5yZW5kZXJTdGF0ZSxcbiAgICAgICAgICAgICAgaWQgPSBib3VuZGFyeS5yb290U2VnbWVudElELFxuICAgICAgICAgICAgICBlcnJvckRpZ2VzdCA9IGJvdW5kYXJ5LmVycm9yRGlnZXN0LFxuICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBib3VuZGFyeS5lcnJvck1lc3NhZ2UsXG4gICAgICAgICAgICAgIGVycm9yU3RhY2sgPSBib3VuZGFyeS5lcnJvclN0YWNrLFxuICAgICAgICAgICAgICBlcnJvckNvbXBvbmVudFN0YWNrID0gYm91bmRhcnkuZXJyb3JDb21wb25lbnRTdGFjaztcbiAgICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQwLnB1c2gocmVuZGVyU3RhdGUkanNjb21wJDEuc3RhcnRJbmxpbmVTY3JpcHQpO1xuICAgICAgICAgICAgKHJlc3VtYWJsZVN0YXRlLmluc3RydWN0aW9ucyAmIFNlbnRDbGllbnRSZW5kZXJGdW5jdGlvbikgPT09XG4gICAgICAgICAgICBOb3RoaW5nU2VudFxuICAgICAgICAgICAgICA/ICgocmVzdW1hYmxlU3RhdGUuaW5zdHJ1Y3Rpb25zIHw9IFNlbnRDbGllbnRSZW5kZXJGdW5jdGlvbiksXG4gICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDAucHVzaChjbGllbnRSZW5kZXJTY3JpcHQxRnVsbCkpXG4gICAgICAgICAgICAgIDogcmVuZGVyU3RhdGUkanNjb21wJDAucHVzaChjbGllbnRSZW5kZXJTY3JpcHQxUGFydGlhbCk7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMC5wdXNoKHJlbmRlclN0YXRlJGpzY29tcCQxLmJvdW5kYXJ5UHJlZml4KTtcbiAgICAgICAgICAgIHZhciBjaHVuayRqc2NvbXAkMSA9IGlkLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQwLnB1c2goY2h1bmskanNjb21wJDEpO1xuICAgICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDAucHVzaChjbGllbnRSZW5kZXJTY3JpcHQxQSk7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIGVycm9yRGlnZXN0IHx8XG4gICAgICAgICAgICAgIGVycm9yTWVzc2FnZSB8fFxuICAgICAgICAgICAgICBlcnJvclN0YWNrIHx8XG4gICAgICAgICAgICAgIGVycm9yQ29tcG9uZW50U3RhY2tcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMC5wdXNoKGNsaWVudFJlbmRlckVycm9yU2NyaXB0QXJnSW50ZXJzdGl0aWFsKTtcbiAgICAgICAgICAgICAgdmFyIGNodW5rJGpzY29tcCQyID0gZXNjYXBlSlNTdHJpbmdzRm9ySW5zdHJ1Y3Rpb25TY3JpcHRzKFxuICAgICAgICAgICAgICAgIGVycm9yRGlnZXN0IHx8IFwiXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDAucHVzaChjaHVuayRqc2NvbXAkMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJyb3JNZXNzYWdlIHx8IGVycm9yU3RhY2sgfHwgZXJyb3JDb21wb25lbnRTdGFjaykge1xuICAgICAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMC5wdXNoKGNsaWVudFJlbmRlckVycm9yU2NyaXB0QXJnSW50ZXJzdGl0aWFsKTtcbiAgICAgICAgICAgICAgdmFyIGNodW5rJGpzY29tcCQzID0gZXNjYXBlSlNTdHJpbmdzRm9ySW5zdHJ1Y3Rpb25TY3JpcHRzKFxuICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSB8fCBcIlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQwLnB1c2goY2h1bmskanNjb21wJDMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVycm9yU3RhY2sgfHwgZXJyb3JDb21wb25lbnRTdGFjaykge1xuICAgICAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMC5wdXNoKGNsaWVudFJlbmRlckVycm9yU2NyaXB0QXJnSW50ZXJzdGl0aWFsKTtcbiAgICAgICAgICAgICAgdmFyIGNodW5rJGpzY29tcCQ0ID0gZXNjYXBlSlNTdHJpbmdzRm9ySW5zdHJ1Y3Rpb25TY3JpcHRzKFxuICAgICAgICAgICAgICAgIGVycm9yU3RhY2sgfHwgXCJcIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMC5wdXNoKGNodW5rJGpzY29tcCQ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlcnJvckNvbXBvbmVudFN0YWNrKSB7XG4gICAgICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQwLnB1c2goY2xpZW50UmVuZGVyRXJyb3JTY3JpcHRBcmdJbnRlcnN0aXRpYWwpO1xuICAgICAgICAgICAgICB2YXIgY2h1bmskanNjb21wJDUgPVxuICAgICAgICAgICAgICAgIGVzY2FwZUpTU3RyaW5nc0Zvckluc3RydWN0aW9uU2NyaXB0cyhlcnJvckNvbXBvbmVudFN0YWNrKTtcbiAgICAgICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDAucHVzaChjaHVuayRqc2NvbXAkNSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gcmVuZGVyU3RhdGUkanNjb21wJDAucHVzaChcbiAgICAgICAgICAgICAgY2xpZW50UmVuZGVyU2NyaXB0RW5kXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKCFKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQpIHtcbiAgICAgICAgICAgICAgcmVxdWVzdC5kZXN0aW5hdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzLnNwbGljZSgwLCBpKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMuc3BsaWNlKDAsIGkpO1xuICAgICAgICAgIHZhciBjb21wbGV0ZWRCb3VuZGFyaWVzID0gcmVxdWVzdC5jb21wbGV0ZWRCb3VuZGFyaWVzO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb21wbGV0ZWRCb3VuZGFyaWVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAhZmx1c2hDb21wbGV0ZWRCb3VuZGFyeShcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICAgICAgICAgIGNvbXBsZXRlZEJvdW5kYXJpZXNbaV1cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHJlcXVlc3QuZGVzdGluYXRpb24gPSBudWxsO1xuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgIGNvbXBsZXRlZEJvdW5kYXJpZXMuc3BsaWNlKDAsIGkpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY29tcGxldGVkQm91bmRhcmllcy5zcGxpY2UoMCwgaSk7XG4gICAgICAgICAgdmFyIHBhcnRpYWxCb3VuZGFyaWVzID0gcmVxdWVzdC5wYXJ0aWFsQm91bmRhcmllcztcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFydGlhbEJvdW5kYXJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgICAgY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzID0gcmVxdWVzdDtcbiAgICAgICAgICAgICAgYm91bmRhcnkgPSBkZXN0aW5hdGlvbjtcbiAgICAgICAgICAgICAgdmFyIGJvdW5kYXJ5JGpzY29tcCQwID0gcGFydGlhbEJvdW5kYXJpZXNbaV0sXG4gICAgICAgICAgICAgICAgY29tcGxldGVkU2VnbWVudHMgPSBib3VuZGFyeSRqc2NvbXAkMC5jb21wbGV0ZWRTZWdtZW50cztcbiAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAwO1xuICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA8IGNvbXBsZXRlZFNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQrK1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgIWZsdXNoUGFydGlhbGx5Q29tcGxldGVkU2VnbWVudChcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzLFxuICAgICAgICAgICAgICAgICAgICBib3VuZGFyeSxcbiAgICAgICAgICAgICAgICAgICAgYm91bmRhcnkkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlZFNlZ21lbnRzW0pTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdF1cbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCsrO1xuICAgICAgICAgICAgICAgICAgY29tcGxldGVkU2VnbWVudHMuc3BsaWNlKDAsIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCk7XG4gICAgICAgICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwID0gITE7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29tcGxldGVkU2VnbWVudHMuc3BsaWNlKDAsIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCk7XG4gICAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMCA9IHdyaXRlSG9pc3RhYmxlc0ZvckJvdW5kYXJ5KFxuICAgICAgICAgICAgICAgIGJvdW5kYXJ5LFxuICAgICAgICAgICAgICAgIGJvdW5kYXJ5JGpzY29tcCQwLmNvbnRlbnRTdGF0ZSxcbiAgICAgICAgICAgICAgICBjbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMucmVuZGVyU3RhdGVcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwKSB7XG4gICAgICAgICAgICAgIHJlcXVlc3QuZGVzdGluYXRpb24gPSBudWxsO1xuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgIHBhcnRpYWxCb3VuZGFyaWVzLnNwbGljZSgwLCBpKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJ0aWFsQm91bmRhcmllcy5zcGxpY2UoMCwgaSk7XG4gICAgICAgICAgdmFyIGxhcmdlQm91bmRhcmllcyA9IHJlcXVlc3QuY29tcGxldGVkQm91bmRhcmllcztcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGFyZ2VCb3VuZGFyaWVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAhZmx1c2hDb21wbGV0ZWRCb3VuZGFyeShyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgbGFyZ2VCb3VuZGFyaWVzW2ldKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHJlcXVlc3QuZGVzdGluYXRpb24gPSBudWxsO1xuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgIGxhcmdlQm91bmRhcmllcy5zcGxpY2UoMCwgaSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBsYXJnZUJvdW5kYXJpZXMuc3BsaWNlKDAsIGkpO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICAwID09PSByZXF1ZXN0LmFsbFBlbmRpbmdUYXNrcyAmJlxuICAgICAgICAgIDAgPT09IHJlcXVlc3QucGluZ2VkVGFza3MubGVuZ3RoICYmXG4gICAgICAgICAgMCA9PT0gcmVxdWVzdC5jbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMubGVuZ3RoICYmXG4gICAgICAgICAgMCA9PT0gcmVxdWVzdC5jb21wbGV0ZWRCb3VuZGFyaWVzLmxlbmd0aCAmJlxuICAgICAgICAgICgocmVxdWVzdC5mbHVzaFNjaGVkdWxlZCA9ICExKSxcbiAgICAgICAgICAoaSA9IHJlcXVlc3QucmVzdW1hYmxlU3RhdGUpLFxuICAgICAgICAgIGkuaGFzQm9keSAmJlxuICAgICAgICAgICAgKChwYXJ0aWFsQm91bmRhcmllcyA9IGVuZENodW5rRm9yVGFnKFwiYm9keVwiKSksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHBhcnRpYWxCb3VuZGFyaWVzKSksXG4gICAgICAgICAgaS5oYXNIdG1sICYmICgoaSA9IGVuZENodW5rRm9yVGFnKFwiaHRtbFwiKSksIGRlc3RpbmF0aW9uLnB1c2goaSkpLFxuICAgICAgICAgIDAgIT09IHJlcXVlc3QuYWJvcnRhYmxlVGFza3Muc2l6ZSAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJUaGVyZSB3YXMgc3RpbGwgYWJvcnRhYmxlIHRhc2sgYXQgdGhlIHJvb3Qgd2hlbiB3ZSBjbG9zZWQuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgKHJlcXVlc3Quc3RhdHVzID0gQ0xPU0VEKSxcbiAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKG51bGwpLFxuICAgICAgICAgIChyZXF1ZXN0LmRlc3RpbmF0aW9uID0gbnVsbCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzdGFydFdvcmsocmVxdWVzdCkge1xuICAgICAgcmVxdWVzdC5mbHVzaFNjaGVkdWxlZCA9IG51bGwgIT09IHJlcXVlc3QuZGVzdGluYXRpb247XG4gICAgICBwZXJmb3JtV29yayhyZXF1ZXN0KTtcbiAgICAgIDEwID09PSByZXF1ZXN0LnN0YXR1cyAmJiAocmVxdWVzdC5zdGF0dXMgPSAxMSk7XG4gICAgICBudWxsID09PSByZXF1ZXN0LnRyYWNrZWRQb3N0cG9uZXMgJiZcbiAgICAgICAgc2FmZWx5RW1pdEVhcmx5UHJlbG9hZHMocmVxdWVzdCwgMCA9PT0gcmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5xdWV1ZUZsdXNoKHJlcXVlc3QpIHtcbiAgICAgIGlmIChcbiAgICAgICAgITEgPT09IHJlcXVlc3QuZmx1c2hTY2hlZHVsZWQgJiZcbiAgICAgICAgMCA9PT0gcmVxdWVzdC5waW5nZWRUYXNrcy5sZW5ndGggJiZcbiAgICAgICAgbnVsbCAhPT0gcmVxdWVzdC5kZXN0aW5hdGlvblxuICAgICAgKSB7XG4gICAgICAgIHJlcXVlc3QuZmx1c2hTY2hlZHVsZWQgPSAhMDtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gcmVxdWVzdC5kZXN0aW5hdGlvbjtcbiAgICAgICAgZGVzdGluYXRpb25cbiAgICAgICAgICA/IGZsdXNoQ29tcGxldGVkUXVldWVzKHJlcXVlc3QsIGRlc3RpbmF0aW9uKVxuICAgICAgICAgIDogKHJlcXVlc3QuZmx1c2hTY2hlZHVsZWQgPSAhMSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0YXJ0Rmxvd2luZyhyZXF1ZXN0LCBkZXN0aW5hdGlvbikge1xuICAgICAgaWYgKDEzID09PSByZXF1ZXN0LnN0YXR1cylcbiAgICAgICAgKHJlcXVlc3Quc3RhdHVzID0gQ0xPU0VEKSwgZGVzdGluYXRpb24uZGVzdHJveShyZXF1ZXN0LmZhdGFsRXJyb3IpO1xuICAgICAgZWxzZSBpZiAocmVxdWVzdC5zdGF0dXMgIT09IENMT1NFRCAmJiBudWxsID09PSByZXF1ZXN0LmRlc3RpbmF0aW9uKSB7XG4gICAgICAgIHJlcXVlc3QuZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmbHVzaENvbXBsZXRlZFF1ZXVlcyhyZXF1ZXN0LCBkZXN0aW5hdGlvbik7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgbG9nUmVjb3ZlcmFibGVFcnJvcihyZXF1ZXN0LCBlcnJvciwge30pLCBmYXRhbEVycm9yKHJlcXVlc3QsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBhYm9ydChyZXF1ZXN0LCByZWFzb24pIHtcbiAgICAgIGlmICgxMSA9PT0gcmVxdWVzdC5zdGF0dXMgfHwgMTAgPT09IHJlcXVlc3Quc3RhdHVzKSByZXF1ZXN0LnN0YXR1cyA9IDEyO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGFib3J0YWJsZVRhc2tzID0gcmVxdWVzdC5hYm9ydGFibGVUYXNrcztcbiAgICAgICAgaWYgKDAgPCBhYm9ydGFibGVUYXNrcy5zaXplKSB7XG4gICAgICAgICAgdmFyIGVycm9yID1cbiAgICAgICAgICAgIHZvaWQgMCA9PT0gcmVhc29uXG4gICAgICAgICAgICAgID8gRXJyb3IoXCJUaGUgcmVuZGVyIHdhcyBhYm9ydGVkIGJ5IHRoZSBzZXJ2ZXIgd2l0aG91dCBhIHJlYXNvbi5cIilcbiAgICAgICAgICAgICAgOiBcIm9iamVjdFwiID09PSB0eXBlb2YgcmVhc29uICYmXG4gICAgICAgICAgICAgICAgICBudWxsICE9PSByZWFzb24gJiZcbiAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJlYXNvbi50aGVuXG4gICAgICAgICAgICAgICAgPyBFcnJvcihcIlRoZSByZW5kZXIgd2FzIGFib3J0ZWQgYnkgdGhlIHNlcnZlciB3aXRoIGEgcHJvbWlzZS5cIilcbiAgICAgICAgICAgICAgICA6IHJlYXNvbjtcbiAgICAgICAgICByZXF1ZXN0LmZhdGFsRXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICBhYm9ydGFibGVUYXNrcy5mb3JFYWNoKGZ1bmN0aW9uICh0YXNrKSB7XG4gICAgICAgICAgICByZXR1cm4gYWJvcnRUYXNrKHRhc2ssIHJlcXVlc3QsIGVycm9yKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBhYm9ydGFibGVUYXNrcy5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIG51bGwgIT09IHJlcXVlc3QuZGVzdGluYXRpb24gJiZcbiAgICAgICAgICBmbHVzaENvbXBsZXRlZFF1ZXVlcyhyZXF1ZXN0LCByZXF1ZXN0LmRlc3RpbmF0aW9uKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yJDQpIHtcbiAgICAgICAgbG9nUmVjb3ZlcmFibGVFcnJvcihyZXF1ZXN0LCBlcnJvciQ0LCB7fSksIGZhdGFsRXJyb3IocmVxdWVzdCwgZXJyb3IkNCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uRXJyb3IoKSB7fVxuICAgIGZ1bmN0aW9uIHJlbmRlclRvU3RyaW5nSW1wbChcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIGdlbmVyYXRlU3RhdGljTWFya3VwLFxuICAgICAgYWJvcnRSZWFzb25cbiAgICApIHtcbiAgICAgIHZhciBkaWRGYXRhbCA9ICExLFxuICAgICAgICBmYXRhbEVycm9yID0gbnVsbCxcbiAgICAgICAgcmVzdWx0ID0gXCJcIixcbiAgICAgICAgcmVhZHlUb1N0cmVhbSA9ICExO1xuICAgICAgb3B0aW9ucyA9IGNyZWF0ZVJlc3VtYWJsZVN0YXRlKFxuICAgICAgICBvcHRpb25zID8gb3B0aW9ucy5pZGVudGlmaWVyUHJlZml4IDogdm9pZCAwXG4gICAgICApO1xuICAgICAgY2hpbGRyZW4gPSBjcmVhdGVSZXF1ZXN0KFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgY3JlYXRlUmVuZGVyU3RhdGUob3B0aW9ucywgZ2VuZXJhdGVTdGF0aWNNYXJrdXApLFxuICAgICAgICBjcmVhdGVGb3JtYXRDb250ZXh0KFJPT1RfSFRNTF9NT0RFLCBudWxsLCAwKSxcbiAgICAgICAgSW5maW5pdHksXG4gICAgICAgIG9uRXJyb3IsXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJlYWR5VG9TdHJlYW0gPSAhMDtcbiAgICAgICAgfSxcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIHZvaWQgMFxuICAgICAgKTtcbiAgICAgIHN0YXJ0V29yayhjaGlsZHJlbik7XG4gICAgICBhYm9ydChjaGlsZHJlbiwgYWJvcnRSZWFzb24pO1xuICAgICAgc3RhcnRGbG93aW5nKGNoaWxkcmVuLCB7XG4gICAgICAgIHB1c2g6IGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICAgIG51bGwgIT09IGNodW5rICYmIChyZXN1bHQgKz0gY2h1bmspO1xuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgfSxcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgZGlkRmF0YWwgPSAhMDtcbiAgICAgICAgICBmYXRhbEVycm9yID0gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKGRpZEZhdGFsICYmIGZhdGFsRXJyb3IgIT09IGFib3J0UmVhc29uKSB0aHJvdyBmYXRhbEVycm9yO1xuICAgICAgaWYgKCFyZWFkeVRvU3RyZWFtKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIkEgY29tcG9uZW50IHN1c3BlbmRlZCB3aGlsZSByZXNwb25kaW5nIHRvIHN5bmNocm9ub3VzIGlucHV0LiBUaGlzIHdpbGwgY2F1c2UgdGhlIFVJIHRvIGJlIHJlcGxhY2VkIHdpdGggYSBsb2FkaW5nIGluZGljYXRvci4gVG8gZml4LCB1cGRhdGVzIHRoYXQgc3VzcGVuZCBzaG91bGQgYmUgd3JhcHBlZCB3aXRoIHN0YXJ0VHJhbnNpdGlvbi5cIlxuICAgICAgICApO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdmFyIFJlYWN0ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdFwiKSxcbiAgICAgIFJlYWN0RE9NID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdC1kb21cIiksXG4gICAgICBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QudHJhbnNpdGlvbmFsLmVsZW1lbnRcIiksXG4gICAgICBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wb3J0YWxcIiksXG4gICAgICBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpLFxuICAgICAgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKSxcbiAgICAgIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvZmlsZXJcIiksXG4gICAgICBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnByb3ZpZGVyXCIpLFxuICAgICAgUkVBQ1RfQ09OU1VNRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb25zdW1lclwiKSxcbiAgICAgIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpLFxuICAgICAgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKSxcbiAgICAgIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIiksXG4gICAgICBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VfbGlzdFwiKSxcbiAgICAgIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpLFxuICAgICAgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIiksXG4gICAgICBSRUFDVF9TQ09QRV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnNjb3BlXCIpLFxuICAgICAgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZGVidWdfdHJhY2VfbW9kZVwiKSxcbiAgICAgIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0Lm9mZnNjcmVlblwiKSxcbiAgICAgIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5sZWdhY3lfaGlkZGVuXCIpLFxuICAgICAgUkVBQ1RfTUVNT19DQUNIRV9TRU5USU5FTCA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vX2NhY2hlX3NlbnRpbmVsXCIpLFxuICAgICAgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yLFxuICAgICAgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5LFxuICAgICAganN4UHJvcHNQYXJlbnRzID0gbmV3IFdlYWtNYXAoKSxcbiAgICAgIGpzeENoaWxkcmVuUGFyZW50cyA9IG5ldyBXZWFrTWFwKCksXG4gICAgICBDTElFTlRfUkVGRVJFTkNFX1RBRyA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpLFxuICAgICAgYXNzaWduID0gT2JqZWN0LmFzc2lnbixcbiAgICAgIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgIFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYID0gUmVnRXhwKFxuICAgICAgICBcIl5bOkEtWl9hLXpcXFxcdTAwQzAtXFxcXHUwMEQ2XFxcXHUwMEQ4LVxcXFx1MDBGNlxcXFx1MDBGOC1cXFxcdTAyRkZcXFxcdTAzNzAtXFxcXHUwMzdEXFxcXHUwMzdGLVxcXFx1MUZGRlxcXFx1MjAwQy1cXFxcdTIwMERcXFxcdTIwNzAtXFxcXHUyMThGXFxcXHUyQzAwLVxcXFx1MkZFRlxcXFx1MzAwMS1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZGRF1bOkEtWl9hLXpcXFxcdTAwQzAtXFxcXHUwMEQ2XFxcXHUwMEQ4LVxcXFx1MDBGNlxcXFx1MDBGOC1cXFxcdTAyRkZcXFxcdTAzNzAtXFxcXHUwMzdEXFxcXHUwMzdGLVxcXFx1MUZGRlxcXFx1MjAwQy1cXFxcdTIwMERcXFxcdTIwNzAtXFxcXHUyMThGXFxcXHUyQzAwLVxcXFx1MkZFRlxcXFx1MzAwMS1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZGRFxcXFwtLjAtOVxcXFx1MDBCN1xcXFx1MDMwMC1cXFxcdTAzNkZcXFxcdTIwM0YtXFxcXHUyMDQwXSokXCJcbiAgICAgICksXG4gICAgICBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlID0ge30sXG4gICAgICB2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGUgPSB7fSxcbiAgICAgIHVuaXRsZXNzTnVtYmVycyA9IG5ldyBTZXQoXG4gICAgICAgIFwiYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQgYXNwZWN0UmF0aW8gYm9yZGVySW1hZ2VPdXRzZXQgYm9yZGVySW1hZ2VTbGljZSBib3JkZXJJbWFnZVdpZHRoIGJveEZsZXggYm94RmxleEdyb3VwIGJveE9yZGluYWxHcm91cCBjb2x1bW5Db3VudCBjb2x1bW5zIGZsZXggZmxleEdyb3cgZmxleFBvc2l0aXZlIGZsZXhTaHJpbmsgZmxleE5lZ2F0aXZlIGZsZXhPcmRlciBncmlkQXJlYSBncmlkUm93IGdyaWRSb3dFbmQgZ3JpZFJvd1NwYW4gZ3JpZFJvd1N0YXJ0IGdyaWRDb2x1bW4gZ3JpZENvbHVtbkVuZCBncmlkQ29sdW1uU3BhbiBncmlkQ29sdW1uU3RhcnQgZm9udFdlaWdodCBsaW5lQ2xhbXAgbGluZUhlaWdodCBvcGFjaXR5IG9yZGVyIG9ycGhhbnMgc2NhbGUgdGFiU2l6ZSB3aWRvd3MgekluZGV4IHpvb20gZmlsbE9wYWNpdHkgZmxvb2RPcGFjaXR5IHN0b3BPcGFjaXR5IHN0cm9rZURhc2hhcnJheSBzdHJva2VEYXNob2Zmc2V0IHN0cm9rZU1pdGVybGltaXQgc3Ryb2tlT3BhY2l0eSBzdHJva2VXaWR0aCBNb3pBbmltYXRpb25JdGVyYXRpb25Db3VudCBNb3pCb3hGbGV4IE1vekJveEZsZXhHcm91cCBNb3pMaW5lQ2xhbXAgbXNBbmltYXRpb25JdGVyYXRpb25Db3VudCBtc0ZsZXggbXNab29tIG1zRmxleEdyb3cgbXNGbGV4TmVnYXRpdmUgbXNGbGV4T3JkZXIgbXNGbGV4UG9zaXRpdmUgbXNGbGV4U2hyaW5rIG1zR3JpZENvbHVtbiBtc0dyaWRDb2x1bW5TcGFuIG1zR3JpZFJvdyBtc0dyaWRSb3dTcGFuIFdlYmtpdEFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50IFdlYmtpdEJveEZsZXggV2ViS2l0Qm94RmxleEdyb3VwIFdlYmtpdEJveE9yZGluYWxHcm91cCBXZWJraXRDb2x1bW5Db3VudCBXZWJraXRDb2x1bW5zIFdlYmtpdEZsZXggV2Via2l0RmxleEdyb3cgV2Via2l0RmxleFBvc2l0aXZlIFdlYmtpdEZsZXhTaHJpbmsgV2Via2l0TGluZUNsYW1wXCIuc3BsaXQoXG4gICAgICAgICAgXCIgXCJcbiAgICAgICAgKVxuICAgICAgKSxcbiAgICAgIGFsaWFzZXMgPSBuZXcgTWFwKFtcbiAgICAgICAgW1wiYWNjZXB0Q2hhcnNldFwiLCBcImFjY2VwdC1jaGFyc2V0XCJdLFxuICAgICAgICBbXCJodG1sRm9yXCIsIFwiZm9yXCJdLFxuICAgICAgICBbXCJodHRwRXF1aXZcIiwgXCJodHRwLWVxdWl2XCJdLFxuICAgICAgICBbXCJjcm9zc09yaWdpblwiLCBcImNyb3Nzb3JpZ2luXCJdLFxuICAgICAgICBbXCJhY2NlbnRIZWlnaHRcIiwgXCJhY2NlbnQtaGVpZ2h0XCJdLFxuICAgICAgICBbXCJhbGlnbm1lbnRCYXNlbGluZVwiLCBcImFsaWdubWVudC1iYXNlbGluZVwiXSxcbiAgICAgICAgW1wiYXJhYmljRm9ybVwiLCBcImFyYWJpYy1mb3JtXCJdLFxuICAgICAgICBbXCJiYXNlbGluZVNoaWZ0XCIsIFwiYmFzZWxpbmUtc2hpZnRcIl0sXG4gICAgICAgIFtcImNhcEhlaWdodFwiLCBcImNhcC1oZWlnaHRcIl0sXG4gICAgICAgIFtcImNsaXBQYXRoXCIsIFwiY2xpcC1wYXRoXCJdLFxuICAgICAgICBbXCJjbGlwUnVsZVwiLCBcImNsaXAtcnVsZVwiXSxcbiAgICAgICAgW1wiY29sb3JJbnRlcnBvbGF0aW9uXCIsIFwiY29sb3ItaW50ZXJwb2xhdGlvblwiXSxcbiAgICAgICAgW1wiY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVyc1wiLCBcImNvbG9yLWludGVycG9sYXRpb24tZmlsdGVyc1wiXSxcbiAgICAgICAgW1wiY29sb3JQcm9maWxlXCIsIFwiY29sb3ItcHJvZmlsZVwiXSxcbiAgICAgICAgW1wiY29sb3JSZW5kZXJpbmdcIiwgXCJjb2xvci1yZW5kZXJpbmdcIl0sXG4gICAgICAgIFtcImRvbWluYW50QmFzZWxpbmVcIiwgXCJkb21pbmFudC1iYXNlbGluZVwiXSxcbiAgICAgICAgW1wiZW5hYmxlQmFja2dyb3VuZFwiLCBcImVuYWJsZS1iYWNrZ3JvdW5kXCJdLFxuICAgICAgICBbXCJmaWxsT3BhY2l0eVwiLCBcImZpbGwtb3BhY2l0eVwiXSxcbiAgICAgICAgW1wiZmlsbFJ1bGVcIiwgXCJmaWxsLXJ1bGVcIl0sXG4gICAgICAgIFtcImZsb29kQ29sb3JcIiwgXCJmbG9vZC1jb2xvclwiXSxcbiAgICAgICAgW1wiZmxvb2RPcGFjaXR5XCIsIFwiZmxvb2Qtb3BhY2l0eVwiXSxcbiAgICAgICAgW1wiZm9udEZhbWlseVwiLCBcImZvbnQtZmFtaWx5XCJdLFxuICAgICAgICBbXCJmb250U2l6ZVwiLCBcImZvbnQtc2l6ZVwiXSxcbiAgICAgICAgW1wiZm9udFNpemVBZGp1c3RcIiwgXCJmb250LXNpemUtYWRqdXN0XCJdLFxuICAgICAgICBbXCJmb250U3RyZXRjaFwiLCBcImZvbnQtc3RyZXRjaFwiXSxcbiAgICAgICAgW1wiZm9udFN0eWxlXCIsIFwiZm9udC1zdHlsZVwiXSxcbiAgICAgICAgW1wiZm9udFZhcmlhbnRcIiwgXCJmb250LXZhcmlhbnRcIl0sXG4gICAgICAgIFtcImZvbnRXZWlnaHRcIiwgXCJmb250LXdlaWdodFwiXSxcbiAgICAgICAgW1wiZ2x5cGhOYW1lXCIsIFwiZ2x5cGgtbmFtZVwiXSxcbiAgICAgICAgW1wiZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWxcIiwgXCJnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsXCJdLFxuICAgICAgICBbXCJnbHlwaE9yaWVudGF0aW9uVmVydGljYWxcIiwgXCJnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbFwiXSxcbiAgICAgICAgW1wiaG9yaXpBZHZYXCIsIFwiaG9yaXotYWR2LXhcIl0sXG4gICAgICAgIFtcImhvcml6T3JpZ2luWFwiLCBcImhvcml6LW9yaWdpbi14XCJdLFxuICAgICAgICBbXCJpbWFnZVJlbmRlcmluZ1wiLCBcImltYWdlLXJlbmRlcmluZ1wiXSxcbiAgICAgICAgW1wibGV0dGVyU3BhY2luZ1wiLCBcImxldHRlci1zcGFjaW5nXCJdLFxuICAgICAgICBbXCJsaWdodGluZ0NvbG9yXCIsIFwibGlnaHRpbmctY29sb3JcIl0sXG4gICAgICAgIFtcIm1hcmtlckVuZFwiLCBcIm1hcmtlci1lbmRcIl0sXG4gICAgICAgIFtcIm1hcmtlck1pZFwiLCBcIm1hcmtlci1taWRcIl0sXG4gICAgICAgIFtcIm1hcmtlclN0YXJ0XCIsIFwibWFya2VyLXN0YXJ0XCJdLFxuICAgICAgICBbXCJvdmVybGluZVBvc2l0aW9uXCIsIFwib3ZlcmxpbmUtcG9zaXRpb25cIl0sXG4gICAgICAgIFtcIm92ZXJsaW5lVGhpY2tuZXNzXCIsIFwib3ZlcmxpbmUtdGhpY2tuZXNzXCJdLFxuICAgICAgICBbXCJwYWludE9yZGVyXCIsIFwicGFpbnQtb3JkZXJcIl0sXG4gICAgICAgIFtcInBhbm9zZS0xXCIsIFwicGFub3NlLTFcIl0sXG4gICAgICAgIFtcInBvaW50ZXJFdmVudHNcIiwgXCJwb2ludGVyLWV2ZW50c1wiXSxcbiAgICAgICAgW1wicmVuZGVyaW5nSW50ZW50XCIsIFwicmVuZGVyaW5nLWludGVudFwiXSxcbiAgICAgICAgW1wic2hhcGVSZW5kZXJpbmdcIiwgXCJzaGFwZS1yZW5kZXJpbmdcIl0sXG4gICAgICAgIFtcInN0b3BDb2xvclwiLCBcInN0b3AtY29sb3JcIl0sXG4gICAgICAgIFtcInN0b3BPcGFjaXR5XCIsIFwic3RvcC1vcGFjaXR5XCJdLFxuICAgICAgICBbXCJzdHJpa2V0aHJvdWdoUG9zaXRpb25cIiwgXCJzdHJpa2V0aHJvdWdoLXBvc2l0aW9uXCJdLFxuICAgICAgICBbXCJzdHJpa2V0aHJvdWdoVGhpY2tuZXNzXCIsIFwic3RyaWtldGhyb3VnaC10aGlja25lc3NcIl0sXG4gICAgICAgIFtcInN0cm9rZURhc2hhcnJheVwiLCBcInN0cm9rZS1kYXNoYXJyYXlcIl0sXG4gICAgICAgIFtcInN0cm9rZURhc2hvZmZzZXRcIiwgXCJzdHJva2UtZGFzaG9mZnNldFwiXSxcbiAgICAgICAgW1wic3Ryb2tlTGluZWNhcFwiLCBcInN0cm9rZS1saW5lY2FwXCJdLFxuICAgICAgICBbXCJzdHJva2VMaW5lam9pblwiLCBcInN0cm9rZS1saW5lam9pblwiXSxcbiAgICAgICAgW1wic3Ryb2tlTWl0ZXJsaW1pdFwiLCBcInN0cm9rZS1taXRlcmxpbWl0XCJdLFxuICAgICAgICBbXCJzdHJva2VPcGFjaXR5XCIsIFwic3Ryb2tlLW9wYWNpdHlcIl0sXG4gICAgICAgIFtcInN0cm9rZVdpZHRoXCIsIFwic3Ryb2tlLXdpZHRoXCJdLFxuICAgICAgICBbXCJ0ZXh0QW5jaG9yXCIsIFwidGV4dC1hbmNob3JcIl0sXG4gICAgICAgIFtcInRleHREZWNvcmF0aW9uXCIsIFwidGV4dC1kZWNvcmF0aW9uXCJdLFxuICAgICAgICBbXCJ0ZXh0UmVuZGVyaW5nXCIsIFwidGV4dC1yZW5kZXJpbmdcIl0sXG4gICAgICAgIFtcInRyYW5zZm9ybU9yaWdpblwiLCBcInRyYW5zZm9ybS1vcmlnaW5cIl0sXG4gICAgICAgIFtcInVuZGVybGluZVBvc2l0aW9uXCIsIFwidW5kZXJsaW5lLXBvc2l0aW9uXCJdLFxuICAgICAgICBbXCJ1bmRlcmxpbmVUaGlja25lc3NcIiwgXCJ1bmRlcmxpbmUtdGhpY2tuZXNzXCJdLFxuICAgICAgICBbXCJ1bmljb2RlQmlkaVwiLCBcInVuaWNvZGUtYmlkaVwiXSxcbiAgICAgICAgW1widW5pY29kZVJhbmdlXCIsIFwidW5pY29kZS1yYW5nZVwiXSxcbiAgICAgICAgW1widW5pdHNQZXJFbVwiLCBcInVuaXRzLXBlci1lbVwiXSxcbiAgICAgICAgW1widkFscGhhYmV0aWNcIiwgXCJ2LWFscGhhYmV0aWNcIl0sXG4gICAgICAgIFtcInZIYW5naW5nXCIsIFwidi1oYW5naW5nXCJdLFxuICAgICAgICBbXCJ2SWRlb2dyYXBoaWNcIiwgXCJ2LWlkZW9ncmFwaGljXCJdLFxuICAgICAgICBbXCJ2TWF0aGVtYXRpY2FsXCIsIFwidi1tYXRoZW1hdGljYWxcIl0sXG4gICAgICAgIFtcInZlY3RvckVmZmVjdFwiLCBcInZlY3Rvci1lZmZlY3RcIl0sXG4gICAgICAgIFtcInZlcnRBZHZZXCIsIFwidmVydC1hZHYteVwiXSxcbiAgICAgICAgW1widmVydE9yaWdpblhcIiwgXCJ2ZXJ0LW9yaWdpbi14XCJdLFxuICAgICAgICBbXCJ2ZXJ0T3JpZ2luWVwiLCBcInZlcnQtb3JpZ2luLXlcIl0sXG4gICAgICAgIFtcIndvcmRTcGFjaW5nXCIsIFwid29yZC1zcGFjaW5nXCJdLFxuICAgICAgICBbXCJ3cml0aW5nTW9kZVwiLCBcIndyaXRpbmctbW9kZVwiXSxcbiAgICAgICAgW1wieG1sbnNYbGlua1wiLCBcInhtbG5zOnhsaW5rXCJdLFxuICAgICAgICBbXCJ4SGVpZ2h0XCIsIFwieC1oZWlnaHRcIl1cbiAgICAgIF0pLFxuICAgICAgaGFzUmVhZE9ubHlWYWx1ZSA9IHtcbiAgICAgICAgYnV0dG9uOiAhMCxcbiAgICAgICAgY2hlY2tib3g6ICEwLFxuICAgICAgICBpbWFnZTogITAsXG4gICAgICAgIGhpZGRlbjogITAsXG4gICAgICAgIHJhZGlvOiAhMCxcbiAgICAgICAgcmVzZXQ6ICEwLFxuICAgICAgICBzdWJtaXQ6ICEwXG4gICAgICB9LFxuICAgICAgYXJpYVByb3BlcnRpZXMgPSB7XG4gICAgICAgIFwiYXJpYS1jdXJyZW50XCI6IDAsXG4gICAgICAgIFwiYXJpYS1kZXNjcmlwdGlvblwiOiAwLFxuICAgICAgICBcImFyaWEtZGV0YWlsc1wiOiAwLFxuICAgICAgICBcImFyaWEtZGlzYWJsZWRcIjogMCxcbiAgICAgICAgXCJhcmlhLWhpZGRlblwiOiAwLFxuICAgICAgICBcImFyaWEtaW52YWxpZFwiOiAwLFxuICAgICAgICBcImFyaWEta2V5c2hvcnRjdXRzXCI6IDAsXG4gICAgICAgIFwiYXJpYS1sYWJlbFwiOiAwLFxuICAgICAgICBcImFyaWEtcm9sZWRlc2NyaXB0aW9uXCI6IDAsXG4gICAgICAgIFwiYXJpYS1hdXRvY29tcGxldGVcIjogMCxcbiAgICAgICAgXCJhcmlhLWNoZWNrZWRcIjogMCxcbiAgICAgICAgXCJhcmlhLWV4cGFuZGVkXCI6IDAsXG4gICAgICAgIFwiYXJpYS1oYXNwb3B1cFwiOiAwLFxuICAgICAgICBcImFyaWEtbGV2ZWxcIjogMCxcbiAgICAgICAgXCJhcmlhLW1vZGFsXCI6IDAsXG4gICAgICAgIFwiYXJpYS1tdWx0aWxpbmVcIjogMCxcbiAgICAgICAgXCJhcmlhLW11bHRpc2VsZWN0YWJsZVwiOiAwLFxuICAgICAgICBcImFyaWEtb3JpZW50YXRpb25cIjogMCxcbiAgICAgICAgXCJhcmlhLXBsYWNlaG9sZGVyXCI6IDAsXG4gICAgICAgIFwiYXJpYS1wcmVzc2VkXCI6IDAsXG4gICAgICAgIFwiYXJpYS1yZWFkb25seVwiOiAwLFxuICAgICAgICBcImFyaWEtcmVxdWlyZWRcIjogMCxcbiAgICAgICAgXCJhcmlhLXNlbGVjdGVkXCI6IDAsXG4gICAgICAgIFwiYXJpYS1zb3J0XCI6IDAsXG4gICAgICAgIFwiYXJpYS12YWx1ZW1heFwiOiAwLFxuICAgICAgICBcImFyaWEtdmFsdWVtaW5cIjogMCxcbiAgICAgICAgXCJhcmlhLXZhbHVlbm93XCI6IDAsXG4gICAgICAgIFwiYXJpYS12YWx1ZXRleHRcIjogMCxcbiAgICAgICAgXCJhcmlhLWF0b21pY1wiOiAwLFxuICAgICAgICBcImFyaWEtYnVzeVwiOiAwLFxuICAgICAgICBcImFyaWEtbGl2ZVwiOiAwLFxuICAgICAgICBcImFyaWEtcmVsZXZhbnRcIjogMCxcbiAgICAgICAgXCJhcmlhLWRyb3BlZmZlY3RcIjogMCxcbiAgICAgICAgXCJhcmlhLWdyYWJiZWRcIjogMCxcbiAgICAgICAgXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIjogMCxcbiAgICAgICAgXCJhcmlhLWNvbGNvdW50XCI6IDAsXG4gICAgICAgIFwiYXJpYS1jb2xpbmRleFwiOiAwLFxuICAgICAgICBcImFyaWEtY29sc3BhblwiOiAwLFxuICAgICAgICBcImFyaWEtY29udHJvbHNcIjogMCxcbiAgICAgICAgXCJhcmlhLWRlc2NyaWJlZGJ5XCI6IDAsXG4gICAgICAgIFwiYXJpYS1lcnJvcm1lc3NhZ2VcIjogMCxcbiAgICAgICAgXCJhcmlhLWZsb3d0b1wiOiAwLFxuICAgICAgICBcImFyaWEtbGFiZWxsZWRieVwiOiAwLFxuICAgICAgICBcImFyaWEtb3duc1wiOiAwLFxuICAgICAgICBcImFyaWEtcG9zaW5zZXRcIjogMCxcbiAgICAgICAgXCJhcmlhLXJvd2NvdW50XCI6IDAsXG4gICAgICAgIFwiYXJpYS1yb3dpbmRleFwiOiAwLFxuICAgICAgICBcImFyaWEtcm93c3BhblwiOiAwLFxuICAgICAgICBcImFyaWEtc2V0c2l6ZVwiOiAwXG4gICAgICB9LFxuICAgICAgd2FybmVkUHJvcGVydGllcyQxID0ge30sXG4gICAgICByQVJJQSQxID0gUmVnRXhwKFxuICAgICAgICBcIl4oYXJpYSktWzpBLVpfYS16XFxcXHUwMEMwLVxcXFx1MDBENlxcXFx1MDBEOC1cXFxcdTAwRjZcXFxcdTAwRjgtXFxcXHUwMkZGXFxcXHUwMzcwLVxcXFx1MDM3RFxcXFx1MDM3Ri1cXFxcdTFGRkZcXFxcdTIwMEMtXFxcXHUyMDBEXFxcXHUyMDcwLVxcXFx1MjE4RlxcXFx1MkMwMC1cXFxcdTJGRUZcXFxcdTMwMDEtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRkRcXFxcLS4wLTlcXFxcdTAwQjdcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUyMDNGLVxcXFx1MjA0MF0qJFwiXG4gICAgICApLFxuICAgICAgckFSSUFDYW1lbCQxID0gUmVnRXhwKFxuICAgICAgICBcIl4oYXJpYSlbQS1aXVs6QS1aX2EtelxcXFx1MDBDMC1cXFxcdTAwRDZcXFxcdTAwRDgtXFxcXHUwMEY2XFxcXHUwMEY4LVxcXFx1MDJGRlxcXFx1MDM3MC1cXFxcdTAzN0RcXFxcdTAzN0YtXFxcXHUxRkZGXFxcXHUyMDBDLVxcXFx1MjAwRFxcXFx1MjA3MC1cXFxcdTIxOEZcXFxcdTJDMDAtXFxcXHUyRkVGXFxcXHUzMDAxLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkZEXFxcXC0uMC05XFxcXHUwMEI3XFxcXHUwMzAwLVxcXFx1MDM2RlxcXFx1MjAzRi1cXFxcdTIwNDBdKiRcIlxuICAgICAgKSxcbiAgICAgIGRpZFdhcm5WYWx1ZU51bGwgPSAhMSxcbiAgICAgIHBvc3NpYmxlU3RhbmRhcmROYW1lcyA9IHtcbiAgICAgICAgYWNjZXB0OiBcImFjY2VwdFwiLFxuICAgICAgICBhY2NlcHRjaGFyc2V0OiBcImFjY2VwdENoYXJzZXRcIixcbiAgICAgICAgXCJhY2NlcHQtY2hhcnNldFwiOiBcImFjY2VwdENoYXJzZXRcIixcbiAgICAgICAgYWNjZXNza2V5OiBcImFjY2Vzc0tleVwiLFxuICAgICAgICBhY3Rpb246IFwiYWN0aW9uXCIsXG4gICAgICAgIGFsbG93ZnVsbHNjcmVlbjogXCJhbGxvd0Z1bGxTY3JlZW5cIixcbiAgICAgICAgYWx0OiBcImFsdFwiLFxuICAgICAgICBhczogXCJhc1wiLFxuICAgICAgICBhc3luYzogXCJhc3luY1wiLFxuICAgICAgICBhdXRvY2FwaXRhbGl6ZTogXCJhdXRvQ2FwaXRhbGl6ZVwiLFxuICAgICAgICBhdXRvY29tcGxldGU6IFwiYXV0b0NvbXBsZXRlXCIsXG4gICAgICAgIGF1dG9jb3JyZWN0OiBcImF1dG9Db3JyZWN0XCIsXG4gICAgICAgIGF1dG9mb2N1czogXCJhdXRvRm9jdXNcIixcbiAgICAgICAgYXV0b3BsYXk6IFwiYXV0b1BsYXlcIixcbiAgICAgICAgYXV0b3NhdmU6IFwiYXV0b1NhdmVcIixcbiAgICAgICAgY2FwdHVyZTogXCJjYXB0dXJlXCIsXG4gICAgICAgIGNlbGxwYWRkaW5nOiBcImNlbGxQYWRkaW5nXCIsXG4gICAgICAgIGNlbGxzcGFjaW5nOiBcImNlbGxTcGFjaW5nXCIsXG4gICAgICAgIGNoYWxsZW5nZTogXCJjaGFsbGVuZ2VcIixcbiAgICAgICAgY2hhcnNldDogXCJjaGFyU2V0XCIsXG4gICAgICAgIGNoZWNrZWQ6IFwiY2hlY2tlZFwiLFxuICAgICAgICBjaGlsZHJlbjogXCJjaGlsZHJlblwiLFxuICAgICAgICBjaXRlOiBcImNpdGVcIixcbiAgICAgICAgY2xhc3M6IFwiY2xhc3NOYW1lXCIsXG4gICAgICAgIGNsYXNzaWQ6IFwiY2xhc3NJRFwiLFxuICAgICAgICBjbGFzc25hbWU6IFwiY2xhc3NOYW1lXCIsXG4gICAgICAgIGNvbHM6IFwiY29sc1wiLFxuICAgICAgICBjb2xzcGFuOiBcImNvbFNwYW5cIixcbiAgICAgICAgY29udGVudDogXCJjb250ZW50XCIsXG4gICAgICAgIGNvbnRlbnRlZGl0YWJsZTogXCJjb250ZW50RWRpdGFibGVcIixcbiAgICAgICAgY29udGV4dG1lbnU6IFwiY29udGV4dE1lbnVcIixcbiAgICAgICAgY29udHJvbHM6IFwiY29udHJvbHNcIixcbiAgICAgICAgY29udHJvbHNsaXN0OiBcImNvbnRyb2xzTGlzdFwiLFxuICAgICAgICBjb29yZHM6IFwiY29vcmRzXCIsXG4gICAgICAgIGNyb3Nzb3JpZ2luOiBcImNyb3NzT3JpZ2luXCIsXG4gICAgICAgIGRhbmdlcm91c2x5c2V0aW5uZXJodG1sOiBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCIsXG4gICAgICAgIGRhdGE6IFwiZGF0YVwiLFxuICAgICAgICBkYXRldGltZTogXCJkYXRlVGltZVwiLFxuICAgICAgICBkZWZhdWx0OiBcImRlZmF1bHRcIixcbiAgICAgICAgZGVmYXVsdGNoZWNrZWQ6IFwiZGVmYXVsdENoZWNrZWRcIixcbiAgICAgICAgZGVmYXVsdHZhbHVlOiBcImRlZmF1bHRWYWx1ZVwiLFxuICAgICAgICBkZWZlcjogXCJkZWZlclwiLFxuICAgICAgICBkaXI6IFwiZGlyXCIsXG4gICAgICAgIGRpc2FibGVkOiBcImRpc2FibGVkXCIsXG4gICAgICAgIGRpc2FibGVwaWN0dXJlaW5waWN0dXJlOiBcImRpc2FibGVQaWN0dXJlSW5QaWN0dXJlXCIsXG4gICAgICAgIGRpc2FibGVyZW1vdGVwbGF5YmFjazogXCJkaXNhYmxlUmVtb3RlUGxheWJhY2tcIixcbiAgICAgICAgZG93bmxvYWQ6IFwiZG93bmxvYWRcIixcbiAgICAgICAgZHJhZ2dhYmxlOiBcImRyYWdnYWJsZVwiLFxuICAgICAgICBlbmN0eXBlOiBcImVuY1R5cGVcIixcbiAgICAgICAgZW50ZXJrZXloaW50OiBcImVudGVyS2V5SGludFwiLFxuICAgICAgICBmZXRjaHByaW9yaXR5OiBcImZldGNoUHJpb3JpdHlcIixcbiAgICAgICAgZm9yOiBcImh0bWxGb3JcIixcbiAgICAgICAgZm9ybTogXCJmb3JtXCIsXG4gICAgICAgIGZvcm1tZXRob2Q6IFwiZm9ybU1ldGhvZFwiLFxuICAgICAgICBmb3JtYWN0aW9uOiBcImZvcm1BY3Rpb25cIixcbiAgICAgICAgZm9ybWVuY3R5cGU6IFwiZm9ybUVuY1R5cGVcIixcbiAgICAgICAgZm9ybW5vdmFsaWRhdGU6IFwiZm9ybU5vVmFsaWRhdGVcIixcbiAgICAgICAgZm9ybXRhcmdldDogXCJmb3JtVGFyZ2V0XCIsXG4gICAgICAgIGZyYW1lYm9yZGVyOiBcImZyYW1lQm9yZGVyXCIsXG4gICAgICAgIGhlYWRlcnM6IFwiaGVhZGVyc1wiLFxuICAgICAgICBoZWlnaHQ6IFwiaGVpZ2h0XCIsXG4gICAgICAgIGhpZGRlbjogXCJoaWRkZW5cIixcbiAgICAgICAgaGlnaDogXCJoaWdoXCIsXG4gICAgICAgIGhyZWY6IFwiaHJlZlwiLFxuICAgICAgICBocmVmbGFuZzogXCJocmVmTGFuZ1wiLFxuICAgICAgICBodG1sZm9yOiBcImh0bWxGb3JcIixcbiAgICAgICAgaHR0cGVxdWl2OiBcImh0dHBFcXVpdlwiLFxuICAgICAgICBcImh0dHAtZXF1aXZcIjogXCJodHRwRXF1aXZcIixcbiAgICAgICAgaWNvbjogXCJpY29uXCIsXG4gICAgICAgIGlkOiBcImlkXCIsXG4gICAgICAgIGltYWdlc2l6ZXM6IFwiaW1hZ2VTaXplc1wiLFxuICAgICAgICBpbWFnZXNyY3NldDogXCJpbWFnZVNyY1NldFwiLFxuICAgICAgICBpbmVydDogXCJpbmVydFwiLFxuICAgICAgICBpbm5lcmh0bWw6IFwiaW5uZXJIVE1MXCIsXG4gICAgICAgIGlucHV0bW9kZTogXCJpbnB1dE1vZGVcIixcbiAgICAgICAgaW50ZWdyaXR5OiBcImludGVncml0eVwiLFxuICAgICAgICBpczogXCJpc1wiLFxuICAgICAgICBpdGVtaWQ6IFwiaXRlbUlEXCIsXG4gICAgICAgIGl0ZW1wcm9wOiBcIml0ZW1Qcm9wXCIsXG4gICAgICAgIGl0ZW1yZWY6IFwiaXRlbVJlZlwiLFxuICAgICAgICBpdGVtc2NvcGU6IFwiaXRlbVNjb3BlXCIsXG4gICAgICAgIGl0ZW10eXBlOiBcIml0ZW1UeXBlXCIsXG4gICAgICAgIGtleXBhcmFtczogXCJrZXlQYXJhbXNcIixcbiAgICAgICAga2V5dHlwZTogXCJrZXlUeXBlXCIsXG4gICAgICAgIGtpbmQ6IFwia2luZFwiLFxuICAgICAgICBsYWJlbDogXCJsYWJlbFwiLFxuICAgICAgICBsYW5nOiBcImxhbmdcIixcbiAgICAgICAgbGlzdDogXCJsaXN0XCIsXG4gICAgICAgIGxvb3A6IFwibG9vcFwiLFxuICAgICAgICBsb3c6IFwibG93XCIsXG4gICAgICAgIG1hbmlmZXN0OiBcIm1hbmlmZXN0XCIsXG4gICAgICAgIG1hcmdpbndpZHRoOiBcIm1hcmdpbldpZHRoXCIsXG4gICAgICAgIG1hcmdpbmhlaWdodDogXCJtYXJnaW5IZWlnaHRcIixcbiAgICAgICAgbWF4OiBcIm1heFwiLFxuICAgICAgICBtYXhsZW5ndGg6IFwibWF4TGVuZ3RoXCIsXG4gICAgICAgIG1lZGlhOiBcIm1lZGlhXCIsXG4gICAgICAgIG1lZGlhZ3JvdXA6IFwibWVkaWFHcm91cFwiLFxuICAgICAgICBtZXRob2Q6IFwibWV0aG9kXCIsXG4gICAgICAgIG1pbjogXCJtaW5cIixcbiAgICAgICAgbWlubGVuZ3RoOiBcIm1pbkxlbmd0aFwiLFxuICAgICAgICBtdWx0aXBsZTogXCJtdWx0aXBsZVwiLFxuICAgICAgICBtdXRlZDogXCJtdXRlZFwiLFxuICAgICAgICBuYW1lOiBcIm5hbWVcIixcbiAgICAgICAgbm9tb2R1bGU6IFwibm9Nb2R1bGVcIixcbiAgICAgICAgbm9uY2U6IFwibm9uY2VcIixcbiAgICAgICAgbm92YWxpZGF0ZTogXCJub1ZhbGlkYXRlXCIsXG4gICAgICAgIG9wZW46IFwib3BlblwiLFxuICAgICAgICBvcHRpbXVtOiBcIm9wdGltdW1cIixcbiAgICAgICAgcGF0dGVybjogXCJwYXR0ZXJuXCIsXG4gICAgICAgIHBsYWNlaG9sZGVyOiBcInBsYWNlaG9sZGVyXCIsXG4gICAgICAgIHBsYXlzaW5saW5lOiBcInBsYXlzSW5saW5lXCIsXG4gICAgICAgIHBvc3RlcjogXCJwb3N0ZXJcIixcbiAgICAgICAgcHJlbG9hZDogXCJwcmVsb2FkXCIsXG4gICAgICAgIHByb2ZpbGU6IFwicHJvZmlsZVwiLFxuICAgICAgICByYWRpb2dyb3VwOiBcInJhZGlvR3JvdXBcIixcbiAgICAgICAgcmVhZG9ubHk6IFwicmVhZE9ubHlcIixcbiAgICAgICAgcmVmZXJyZXJwb2xpY3k6IFwicmVmZXJyZXJQb2xpY3lcIixcbiAgICAgICAgcmVsOiBcInJlbFwiLFxuICAgICAgICByZXF1aXJlZDogXCJyZXF1aXJlZFwiLFxuICAgICAgICByZXZlcnNlZDogXCJyZXZlcnNlZFwiLFxuICAgICAgICByb2xlOiBcInJvbGVcIixcbiAgICAgICAgcm93czogXCJyb3dzXCIsXG4gICAgICAgIHJvd3NwYW46IFwicm93U3BhblwiLFxuICAgICAgICBzYW5kYm94OiBcInNhbmRib3hcIixcbiAgICAgICAgc2NvcGU6IFwic2NvcGVcIixcbiAgICAgICAgc2NvcGVkOiBcInNjb3BlZFwiLFxuICAgICAgICBzY3JvbGxpbmc6IFwic2Nyb2xsaW5nXCIsXG4gICAgICAgIHNlYW1sZXNzOiBcInNlYW1sZXNzXCIsXG4gICAgICAgIHNlbGVjdGVkOiBcInNlbGVjdGVkXCIsXG4gICAgICAgIHNoYXBlOiBcInNoYXBlXCIsXG4gICAgICAgIHNpemU6IFwic2l6ZVwiLFxuICAgICAgICBzaXplczogXCJzaXplc1wiLFxuICAgICAgICBzcGFuOiBcInNwYW5cIixcbiAgICAgICAgc3BlbGxjaGVjazogXCJzcGVsbENoZWNrXCIsXG4gICAgICAgIHNyYzogXCJzcmNcIixcbiAgICAgICAgc3JjZG9jOiBcInNyY0RvY1wiLFxuICAgICAgICBzcmNsYW5nOiBcInNyY0xhbmdcIixcbiAgICAgICAgc3Jjc2V0OiBcInNyY1NldFwiLFxuICAgICAgICBzdGFydDogXCJzdGFydFwiLFxuICAgICAgICBzdGVwOiBcInN0ZXBcIixcbiAgICAgICAgc3R5bGU6IFwic3R5bGVcIixcbiAgICAgICAgc3VtbWFyeTogXCJzdW1tYXJ5XCIsXG4gICAgICAgIHRhYmluZGV4OiBcInRhYkluZGV4XCIsXG4gICAgICAgIHRhcmdldDogXCJ0YXJnZXRcIixcbiAgICAgICAgdGl0bGU6IFwidGl0bGVcIixcbiAgICAgICAgdHlwZTogXCJ0eXBlXCIsXG4gICAgICAgIHVzZW1hcDogXCJ1c2VNYXBcIixcbiAgICAgICAgdmFsdWU6IFwidmFsdWVcIixcbiAgICAgICAgd2lkdGg6IFwid2lkdGhcIixcbiAgICAgICAgd21vZGU6IFwid21vZGVcIixcbiAgICAgICAgd3JhcDogXCJ3cmFwXCIsXG4gICAgICAgIGFib3V0OiBcImFib3V0XCIsXG4gICAgICAgIGFjY2VudGhlaWdodDogXCJhY2NlbnRIZWlnaHRcIixcbiAgICAgICAgXCJhY2NlbnQtaGVpZ2h0XCI6IFwiYWNjZW50SGVpZ2h0XCIsXG4gICAgICAgIGFjY3VtdWxhdGU6IFwiYWNjdW11bGF0ZVwiLFxuICAgICAgICBhZGRpdGl2ZTogXCJhZGRpdGl2ZVwiLFxuICAgICAgICBhbGlnbm1lbnRiYXNlbGluZTogXCJhbGlnbm1lbnRCYXNlbGluZVwiLFxuICAgICAgICBcImFsaWdubWVudC1iYXNlbGluZVwiOiBcImFsaWdubWVudEJhc2VsaW5lXCIsXG4gICAgICAgIGFsbG93cmVvcmRlcjogXCJhbGxvd1Jlb3JkZXJcIixcbiAgICAgICAgYWxwaGFiZXRpYzogXCJhbHBoYWJldGljXCIsXG4gICAgICAgIGFtcGxpdHVkZTogXCJhbXBsaXR1ZGVcIixcbiAgICAgICAgYXJhYmljZm9ybTogXCJhcmFiaWNGb3JtXCIsXG4gICAgICAgIFwiYXJhYmljLWZvcm1cIjogXCJhcmFiaWNGb3JtXCIsXG4gICAgICAgIGFzY2VudDogXCJhc2NlbnRcIixcbiAgICAgICAgYXR0cmlidXRlbmFtZTogXCJhdHRyaWJ1dGVOYW1lXCIsXG4gICAgICAgIGF0dHJpYnV0ZXR5cGU6IFwiYXR0cmlidXRlVHlwZVwiLFxuICAgICAgICBhdXRvcmV2ZXJzZTogXCJhdXRvUmV2ZXJzZVwiLFxuICAgICAgICBhemltdXRoOiBcImF6aW11dGhcIixcbiAgICAgICAgYmFzZWZyZXF1ZW5jeTogXCJiYXNlRnJlcXVlbmN5XCIsXG4gICAgICAgIGJhc2VsaW5lc2hpZnQ6IFwiYmFzZWxpbmVTaGlmdFwiLFxuICAgICAgICBcImJhc2VsaW5lLXNoaWZ0XCI6IFwiYmFzZWxpbmVTaGlmdFwiLFxuICAgICAgICBiYXNlcHJvZmlsZTogXCJiYXNlUHJvZmlsZVwiLFxuICAgICAgICBiYm94OiBcImJib3hcIixcbiAgICAgICAgYmVnaW46IFwiYmVnaW5cIixcbiAgICAgICAgYmlhczogXCJiaWFzXCIsXG4gICAgICAgIGJ5OiBcImJ5XCIsXG4gICAgICAgIGNhbGNtb2RlOiBcImNhbGNNb2RlXCIsXG4gICAgICAgIGNhcGhlaWdodDogXCJjYXBIZWlnaHRcIixcbiAgICAgICAgXCJjYXAtaGVpZ2h0XCI6IFwiY2FwSGVpZ2h0XCIsXG4gICAgICAgIGNsaXA6IFwiY2xpcFwiLFxuICAgICAgICBjbGlwcGF0aDogXCJjbGlwUGF0aFwiLFxuICAgICAgICBcImNsaXAtcGF0aFwiOiBcImNsaXBQYXRoXCIsXG4gICAgICAgIGNsaXBwYXRodW5pdHM6IFwiY2xpcFBhdGhVbml0c1wiLFxuICAgICAgICBjbGlwcnVsZTogXCJjbGlwUnVsZVwiLFxuICAgICAgICBcImNsaXAtcnVsZVwiOiBcImNsaXBSdWxlXCIsXG4gICAgICAgIGNvbG9yOiBcImNvbG9yXCIsXG4gICAgICAgIGNvbG9yaW50ZXJwb2xhdGlvbjogXCJjb2xvckludGVycG9sYXRpb25cIixcbiAgICAgICAgXCJjb2xvci1pbnRlcnBvbGF0aW9uXCI6IFwiY29sb3JJbnRlcnBvbGF0aW9uXCIsXG4gICAgICAgIGNvbG9yaW50ZXJwb2xhdGlvbmZpbHRlcnM6IFwiY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVyc1wiLFxuICAgICAgICBcImNvbG9yLWludGVycG9sYXRpb24tZmlsdGVyc1wiOiBcImNvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnNcIixcbiAgICAgICAgY29sb3Jwcm9maWxlOiBcImNvbG9yUHJvZmlsZVwiLFxuICAgICAgICBcImNvbG9yLXByb2ZpbGVcIjogXCJjb2xvclByb2ZpbGVcIixcbiAgICAgICAgY29sb3JyZW5kZXJpbmc6IFwiY29sb3JSZW5kZXJpbmdcIixcbiAgICAgICAgXCJjb2xvci1yZW5kZXJpbmdcIjogXCJjb2xvclJlbmRlcmluZ1wiLFxuICAgICAgICBjb250ZW50c2NyaXB0dHlwZTogXCJjb250ZW50U2NyaXB0VHlwZVwiLFxuICAgICAgICBjb250ZW50c3R5bGV0eXBlOiBcImNvbnRlbnRTdHlsZVR5cGVcIixcbiAgICAgICAgY3Vyc29yOiBcImN1cnNvclwiLFxuICAgICAgICBjeDogXCJjeFwiLFxuICAgICAgICBjeTogXCJjeVwiLFxuICAgICAgICBkOiBcImRcIixcbiAgICAgICAgZGF0YXR5cGU6IFwiZGF0YXR5cGVcIixcbiAgICAgICAgZGVjZWxlcmF0ZTogXCJkZWNlbGVyYXRlXCIsXG4gICAgICAgIGRlc2NlbnQ6IFwiZGVzY2VudFwiLFxuICAgICAgICBkaWZmdXNlY29uc3RhbnQ6IFwiZGlmZnVzZUNvbnN0YW50XCIsXG4gICAgICAgIGRpcmVjdGlvbjogXCJkaXJlY3Rpb25cIixcbiAgICAgICAgZGlzcGxheTogXCJkaXNwbGF5XCIsXG4gICAgICAgIGRpdmlzb3I6IFwiZGl2aXNvclwiLFxuICAgICAgICBkb21pbmFudGJhc2VsaW5lOiBcImRvbWluYW50QmFzZWxpbmVcIixcbiAgICAgICAgXCJkb21pbmFudC1iYXNlbGluZVwiOiBcImRvbWluYW50QmFzZWxpbmVcIixcbiAgICAgICAgZHVyOiBcImR1clwiLFxuICAgICAgICBkeDogXCJkeFwiLFxuICAgICAgICBkeTogXCJkeVwiLFxuICAgICAgICBlZGdlbW9kZTogXCJlZGdlTW9kZVwiLFxuICAgICAgICBlbGV2YXRpb246IFwiZWxldmF0aW9uXCIsXG4gICAgICAgIGVuYWJsZWJhY2tncm91bmQ6IFwiZW5hYmxlQmFja2dyb3VuZFwiLFxuICAgICAgICBcImVuYWJsZS1iYWNrZ3JvdW5kXCI6IFwiZW5hYmxlQmFja2dyb3VuZFwiLFxuICAgICAgICBlbmQ6IFwiZW5kXCIsXG4gICAgICAgIGV4cG9uZW50OiBcImV4cG9uZW50XCIsXG4gICAgICAgIGV4dGVybmFscmVzb3VyY2VzcmVxdWlyZWQ6IFwiZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZFwiLFxuICAgICAgICBmaWxsOiBcImZpbGxcIixcbiAgICAgICAgZmlsbG9wYWNpdHk6IFwiZmlsbE9wYWNpdHlcIixcbiAgICAgICAgXCJmaWxsLW9wYWNpdHlcIjogXCJmaWxsT3BhY2l0eVwiLFxuICAgICAgICBmaWxscnVsZTogXCJmaWxsUnVsZVwiLFxuICAgICAgICBcImZpbGwtcnVsZVwiOiBcImZpbGxSdWxlXCIsXG4gICAgICAgIGZpbHRlcjogXCJmaWx0ZXJcIixcbiAgICAgICAgZmlsdGVycmVzOiBcImZpbHRlclJlc1wiLFxuICAgICAgICBmaWx0ZXJ1bml0czogXCJmaWx0ZXJVbml0c1wiLFxuICAgICAgICBmbG9vZG9wYWNpdHk6IFwiZmxvb2RPcGFjaXR5XCIsXG4gICAgICAgIFwiZmxvb2Qtb3BhY2l0eVwiOiBcImZsb29kT3BhY2l0eVwiLFxuICAgICAgICBmbG9vZGNvbG9yOiBcImZsb29kQ29sb3JcIixcbiAgICAgICAgXCJmbG9vZC1jb2xvclwiOiBcImZsb29kQ29sb3JcIixcbiAgICAgICAgZm9jdXNhYmxlOiBcImZvY3VzYWJsZVwiLFxuICAgICAgICBmb250ZmFtaWx5OiBcImZvbnRGYW1pbHlcIixcbiAgICAgICAgXCJmb250LWZhbWlseVwiOiBcImZvbnRGYW1pbHlcIixcbiAgICAgICAgZm9udHNpemU6IFwiZm9udFNpemVcIixcbiAgICAgICAgXCJmb250LXNpemVcIjogXCJmb250U2l6ZVwiLFxuICAgICAgICBmb250c2l6ZWFkanVzdDogXCJmb250U2l6ZUFkanVzdFwiLFxuICAgICAgICBcImZvbnQtc2l6ZS1hZGp1c3RcIjogXCJmb250U2l6ZUFkanVzdFwiLFxuICAgICAgICBmb250c3RyZXRjaDogXCJmb250U3RyZXRjaFwiLFxuICAgICAgICBcImZvbnQtc3RyZXRjaFwiOiBcImZvbnRTdHJldGNoXCIsXG4gICAgICAgIGZvbnRzdHlsZTogXCJmb250U3R5bGVcIixcbiAgICAgICAgXCJmb250LXN0eWxlXCI6IFwiZm9udFN0eWxlXCIsXG4gICAgICAgIGZvbnR2YXJpYW50OiBcImZvbnRWYXJpYW50XCIsXG4gICAgICAgIFwiZm9udC12YXJpYW50XCI6IFwiZm9udFZhcmlhbnRcIixcbiAgICAgICAgZm9udHdlaWdodDogXCJmb250V2VpZ2h0XCIsXG4gICAgICAgIFwiZm9udC13ZWlnaHRcIjogXCJmb250V2VpZ2h0XCIsXG4gICAgICAgIGZvcm1hdDogXCJmb3JtYXRcIixcbiAgICAgICAgZnJvbTogXCJmcm9tXCIsXG4gICAgICAgIGZ4OiBcImZ4XCIsXG4gICAgICAgIGZ5OiBcImZ5XCIsXG4gICAgICAgIGcxOiBcImcxXCIsXG4gICAgICAgIGcyOiBcImcyXCIsXG4gICAgICAgIGdseXBobmFtZTogXCJnbHlwaE5hbWVcIixcbiAgICAgICAgXCJnbHlwaC1uYW1lXCI6IFwiZ2x5cGhOYW1lXCIsXG4gICAgICAgIGdseXBob3JpZW50YXRpb25ob3Jpem9udGFsOiBcImdseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsXCIsXG4gICAgICAgIFwiZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbFwiOiBcImdseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsXCIsXG4gICAgICAgIGdseXBob3JpZW50YXRpb252ZXJ0aWNhbDogXCJnbHlwaE9yaWVudGF0aW9uVmVydGljYWxcIixcbiAgICAgICAgXCJnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbFwiOiBcImdseXBoT3JpZW50YXRpb25WZXJ0aWNhbFwiLFxuICAgICAgICBnbHlwaHJlZjogXCJnbHlwaFJlZlwiLFxuICAgICAgICBncmFkaWVudHRyYW5zZm9ybTogXCJncmFkaWVudFRyYW5zZm9ybVwiLFxuICAgICAgICBncmFkaWVudHVuaXRzOiBcImdyYWRpZW50VW5pdHNcIixcbiAgICAgICAgaGFuZ2luZzogXCJoYW5naW5nXCIsXG4gICAgICAgIGhvcml6YWR2eDogXCJob3JpekFkdlhcIixcbiAgICAgICAgXCJob3Jpei1hZHYteFwiOiBcImhvcml6QWR2WFwiLFxuICAgICAgICBob3Jpem9yaWdpbng6IFwiaG9yaXpPcmlnaW5YXCIsXG4gICAgICAgIFwiaG9yaXotb3JpZ2luLXhcIjogXCJob3Jpek9yaWdpblhcIixcbiAgICAgICAgaWRlb2dyYXBoaWM6IFwiaWRlb2dyYXBoaWNcIixcbiAgICAgICAgaW1hZ2VyZW5kZXJpbmc6IFwiaW1hZ2VSZW5kZXJpbmdcIixcbiAgICAgICAgXCJpbWFnZS1yZW5kZXJpbmdcIjogXCJpbWFnZVJlbmRlcmluZ1wiLFxuICAgICAgICBpbjI6IFwiaW4yXCIsXG4gICAgICAgIGluOiBcImluXCIsXG4gICAgICAgIGlubGlzdDogXCJpbmxpc3RcIixcbiAgICAgICAgaW50ZXJjZXB0OiBcImludGVyY2VwdFwiLFxuICAgICAgICBrMTogXCJrMVwiLFxuICAgICAgICBrMjogXCJrMlwiLFxuICAgICAgICBrMzogXCJrM1wiLFxuICAgICAgICBrNDogXCJrNFwiLFxuICAgICAgICBrOiBcImtcIixcbiAgICAgICAga2VybmVsbWF0cml4OiBcImtlcm5lbE1hdHJpeFwiLFxuICAgICAgICBrZXJuZWx1bml0bGVuZ3RoOiBcImtlcm5lbFVuaXRMZW5ndGhcIixcbiAgICAgICAga2VybmluZzogXCJrZXJuaW5nXCIsXG4gICAgICAgIGtleXBvaW50czogXCJrZXlQb2ludHNcIixcbiAgICAgICAga2V5c3BsaW5lczogXCJrZXlTcGxpbmVzXCIsXG4gICAgICAgIGtleXRpbWVzOiBcImtleVRpbWVzXCIsXG4gICAgICAgIGxlbmd0aGFkanVzdDogXCJsZW5ndGhBZGp1c3RcIixcbiAgICAgICAgbGV0dGVyc3BhY2luZzogXCJsZXR0ZXJTcGFjaW5nXCIsXG4gICAgICAgIFwibGV0dGVyLXNwYWNpbmdcIjogXCJsZXR0ZXJTcGFjaW5nXCIsXG4gICAgICAgIGxpZ2h0aW5nY29sb3I6IFwibGlnaHRpbmdDb2xvclwiLFxuICAgICAgICBcImxpZ2h0aW5nLWNvbG9yXCI6IFwibGlnaHRpbmdDb2xvclwiLFxuICAgICAgICBsaW1pdGluZ2NvbmVhbmdsZTogXCJsaW1pdGluZ0NvbmVBbmdsZVwiLFxuICAgICAgICBsb2NhbDogXCJsb2NhbFwiLFxuICAgICAgICBtYXJrZXJlbmQ6IFwibWFya2VyRW5kXCIsXG4gICAgICAgIFwibWFya2VyLWVuZFwiOiBcIm1hcmtlckVuZFwiLFxuICAgICAgICBtYXJrZXJoZWlnaHQ6IFwibWFya2VySGVpZ2h0XCIsXG4gICAgICAgIG1hcmtlcm1pZDogXCJtYXJrZXJNaWRcIixcbiAgICAgICAgXCJtYXJrZXItbWlkXCI6IFwibWFya2VyTWlkXCIsXG4gICAgICAgIG1hcmtlcnN0YXJ0OiBcIm1hcmtlclN0YXJ0XCIsXG4gICAgICAgIFwibWFya2VyLXN0YXJ0XCI6IFwibWFya2VyU3RhcnRcIixcbiAgICAgICAgbWFya2VydW5pdHM6IFwibWFya2VyVW5pdHNcIixcbiAgICAgICAgbWFya2Vyd2lkdGg6IFwibWFya2VyV2lkdGhcIixcbiAgICAgICAgbWFzazogXCJtYXNrXCIsXG4gICAgICAgIG1hc2tjb250ZW50dW5pdHM6IFwibWFza0NvbnRlbnRVbml0c1wiLFxuICAgICAgICBtYXNrdW5pdHM6IFwibWFza1VuaXRzXCIsXG4gICAgICAgIG1hdGhlbWF0aWNhbDogXCJtYXRoZW1hdGljYWxcIixcbiAgICAgICAgbW9kZTogXCJtb2RlXCIsXG4gICAgICAgIG51bW9jdGF2ZXM6IFwibnVtT2N0YXZlc1wiLFxuICAgICAgICBvZmZzZXQ6IFwib2Zmc2V0XCIsXG4gICAgICAgIG9wYWNpdHk6IFwib3BhY2l0eVwiLFxuICAgICAgICBvcGVyYXRvcjogXCJvcGVyYXRvclwiLFxuICAgICAgICBvcmRlcjogXCJvcmRlclwiLFxuICAgICAgICBvcmllbnQ6IFwib3JpZW50XCIsXG4gICAgICAgIG9yaWVudGF0aW9uOiBcIm9yaWVudGF0aW9uXCIsXG4gICAgICAgIG9yaWdpbjogXCJvcmlnaW5cIixcbiAgICAgICAgb3ZlcmZsb3c6IFwib3ZlcmZsb3dcIixcbiAgICAgICAgb3ZlcmxpbmVwb3NpdGlvbjogXCJvdmVybGluZVBvc2l0aW9uXCIsXG4gICAgICAgIFwib3ZlcmxpbmUtcG9zaXRpb25cIjogXCJvdmVybGluZVBvc2l0aW9uXCIsXG4gICAgICAgIG92ZXJsaW5ldGhpY2tuZXNzOiBcIm92ZXJsaW5lVGhpY2tuZXNzXCIsXG4gICAgICAgIFwib3ZlcmxpbmUtdGhpY2tuZXNzXCI6IFwib3ZlcmxpbmVUaGlja25lc3NcIixcbiAgICAgICAgcGFpbnRvcmRlcjogXCJwYWludE9yZGVyXCIsXG4gICAgICAgIFwicGFpbnQtb3JkZXJcIjogXCJwYWludE9yZGVyXCIsXG4gICAgICAgIHBhbm9zZTE6IFwicGFub3NlMVwiLFxuICAgICAgICBcInBhbm9zZS0xXCI6IFwicGFub3NlMVwiLFxuICAgICAgICBwYXRobGVuZ3RoOiBcInBhdGhMZW5ndGhcIixcbiAgICAgICAgcGF0dGVybmNvbnRlbnR1bml0czogXCJwYXR0ZXJuQ29udGVudFVuaXRzXCIsXG4gICAgICAgIHBhdHRlcm50cmFuc2Zvcm06IFwicGF0dGVyblRyYW5zZm9ybVwiLFxuICAgICAgICBwYXR0ZXJudW5pdHM6IFwicGF0dGVyblVuaXRzXCIsXG4gICAgICAgIHBvaW50ZXJldmVudHM6IFwicG9pbnRlckV2ZW50c1wiLFxuICAgICAgICBcInBvaW50ZXItZXZlbnRzXCI6IFwicG9pbnRlckV2ZW50c1wiLFxuICAgICAgICBwb2ludHM6IFwicG9pbnRzXCIsXG4gICAgICAgIHBvaW50c2F0eDogXCJwb2ludHNBdFhcIixcbiAgICAgICAgcG9pbnRzYXR5OiBcInBvaW50c0F0WVwiLFxuICAgICAgICBwb2ludHNhdHo6IFwicG9pbnRzQXRaXCIsXG4gICAgICAgIHBvcG92ZXI6IFwicG9wb3ZlclwiLFxuICAgICAgICBwb3BvdmVydGFyZ2V0OiBcInBvcG92ZXJUYXJnZXRcIixcbiAgICAgICAgcG9wb3ZlcnRhcmdldGFjdGlvbjogXCJwb3BvdmVyVGFyZ2V0QWN0aW9uXCIsXG4gICAgICAgIHByZWZpeDogXCJwcmVmaXhcIixcbiAgICAgICAgcHJlc2VydmVhbHBoYTogXCJwcmVzZXJ2ZUFscGhhXCIsXG4gICAgICAgIHByZXNlcnZlYXNwZWN0cmF0aW86IFwicHJlc2VydmVBc3BlY3RSYXRpb1wiLFxuICAgICAgICBwcmltaXRpdmV1bml0czogXCJwcmltaXRpdmVVbml0c1wiLFxuICAgICAgICBwcm9wZXJ0eTogXCJwcm9wZXJ0eVwiLFxuICAgICAgICByOiBcInJcIixcbiAgICAgICAgcmFkaXVzOiBcInJhZGl1c1wiLFxuICAgICAgICByZWZ4OiBcInJlZlhcIixcbiAgICAgICAgcmVmeTogXCJyZWZZXCIsXG4gICAgICAgIHJlbmRlcmluZ2ludGVudDogXCJyZW5kZXJpbmdJbnRlbnRcIixcbiAgICAgICAgXCJyZW5kZXJpbmctaW50ZW50XCI6IFwicmVuZGVyaW5nSW50ZW50XCIsXG4gICAgICAgIHJlcGVhdGNvdW50OiBcInJlcGVhdENvdW50XCIsXG4gICAgICAgIHJlcGVhdGR1cjogXCJyZXBlYXREdXJcIixcbiAgICAgICAgcmVxdWlyZWRleHRlbnNpb25zOiBcInJlcXVpcmVkRXh0ZW5zaW9uc1wiLFxuICAgICAgICByZXF1aXJlZGZlYXR1cmVzOiBcInJlcXVpcmVkRmVhdHVyZXNcIixcbiAgICAgICAgcmVzb3VyY2U6IFwicmVzb3VyY2VcIixcbiAgICAgICAgcmVzdGFydDogXCJyZXN0YXJ0XCIsXG4gICAgICAgIHJlc3VsdDogXCJyZXN1bHRcIixcbiAgICAgICAgcmVzdWx0czogXCJyZXN1bHRzXCIsXG4gICAgICAgIHJvdGF0ZTogXCJyb3RhdGVcIixcbiAgICAgICAgcng6IFwicnhcIixcbiAgICAgICAgcnk6IFwicnlcIixcbiAgICAgICAgc2NhbGU6IFwic2NhbGVcIixcbiAgICAgICAgc2VjdXJpdHk6IFwic2VjdXJpdHlcIixcbiAgICAgICAgc2VlZDogXCJzZWVkXCIsXG4gICAgICAgIHNoYXBlcmVuZGVyaW5nOiBcInNoYXBlUmVuZGVyaW5nXCIsXG4gICAgICAgIFwic2hhcGUtcmVuZGVyaW5nXCI6IFwic2hhcGVSZW5kZXJpbmdcIixcbiAgICAgICAgc2xvcGU6IFwic2xvcGVcIixcbiAgICAgICAgc3BhY2luZzogXCJzcGFjaW5nXCIsXG4gICAgICAgIHNwZWN1bGFyY29uc3RhbnQ6IFwic3BlY3VsYXJDb25zdGFudFwiLFxuICAgICAgICBzcGVjdWxhcmV4cG9uZW50OiBcInNwZWN1bGFyRXhwb25lbnRcIixcbiAgICAgICAgc3BlZWQ6IFwic3BlZWRcIixcbiAgICAgICAgc3ByZWFkbWV0aG9kOiBcInNwcmVhZE1ldGhvZFwiLFxuICAgICAgICBzdGFydG9mZnNldDogXCJzdGFydE9mZnNldFwiLFxuICAgICAgICBzdGRkZXZpYXRpb246IFwic3RkRGV2aWF0aW9uXCIsXG4gICAgICAgIHN0ZW1oOiBcInN0ZW1oXCIsXG4gICAgICAgIHN0ZW12OiBcInN0ZW12XCIsXG4gICAgICAgIHN0aXRjaHRpbGVzOiBcInN0aXRjaFRpbGVzXCIsXG4gICAgICAgIHN0b3Bjb2xvcjogXCJzdG9wQ29sb3JcIixcbiAgICAgICAgXCJzdG9wLWNvbG9yXCI6IFwic3RvcENvbG9yXCIsXG4gICAgICAgIHN0b3BvcGFjaXR5OiBcInN0b3BPcGFjaXR5XCIsXG4gICAgICAgIFwic3RvcC1vcGFjaXR5XCI6IFwic3RvcE9wYWNpdHlcIixcbiAgICAgICAgc3RyaWtldGhyb3VnaHBvc2l0aW9uOiBcInN0cmlrZXRocm91Z2hQb3NpdGlvblwiLFxuICAgICAgICBcInN0cmlrZXRocm91Z2gtcG9zaXRpb25cIjogXCJzdHJpa2V0aHJvdWdoUG9zaXRpb25cIixcbiAgICAgICAgc3RyaWtldGhyb3VnaHRoaWNrbmVzczogXCJzdHJpa2V0aHJvdWdoVGhpY2tuZXNzXCIsXG4gICAgICAgIFwic3RyaWtldGhyb3VnaC10aGlja25lc3NcIjogXCJzdHJpa2V0aHJvdWdoVGhpY2tuZXNzXCIsXG4gICAgICAgIHN0cmluZzogXCJzdHJpbmdcIixcbiAgICAgICAgc3Ryb2tlOiBcInN0cm9rZVwiLFxuICAgICAgICBzdHJva2VkYXNoYXJyYXk6IFwic3Ryb2tlRGFzaGFycmF5XCIsXG4gICAgICAgIFwic3Ryb2tlLWRhc2hhcnJheVwiOiBcInN0cm9rZURhc2hhcnJheVwiLFxuICAgICAgICBzdHJva2VkYXNob2Zmc2V0OiBcInN0cm9rZURhc2hvZmZzZXRcIixcbiAgICAgICAgXCJzdHJva2UtZGFzaG9mZnNldFwiOiBcInN0cm9rZURhc2hvZmZzZXRcIixcbiAgICAgICAgc3Ryb2tlbGluZWNhcDogXCJzdHJva2VMaW5lY2FwXCIsXG4gICAgICAgIFwic3Ryb2tlLWxpbmVjYXBcIjogXCJzdHJva2VMaW5lY2FwXCIsXG4gICAgICAgIHN0cm9rZWxpbmVqb2luOiBcInN0cm9rZUxpbmVqb2luXCIsXG4gICAgICAgIFwic3Ryb2tlLWxpbmVqb2luXCI6IFwic3Ryb2tlTGluZWpvaW5cIixcbiAgICAgICAgc3Ryb2tlbWl0ZXJsaW1pdDogXCJzdHJva2VNaXRlcmxpbWl0XCIsXG4gICAgICAgIFwic3Ryb2tlLW1pdGVybGltaXRcIjogXCJzdHJva2VNaXRlcmxpbWl0XCIsXG4gICAgICAgIHN0cm9rZXdpZHRoOiBcInN0cm9rZVdpZHRoXCIsXG4gICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IFwic3Ryb2tlV2lkdGhcIixcbiAgICAgICAgc3Ryb2tlb3BhY2l0eTogXCJzdHJva2VPcGFjaXR5XCIsXG4gICAgICAgIFwic3Ryb2tlLW9wYWNpdHlcIjogXCJzdHJva2VPcGFjaXR5XCIsXG4gICAgICAgIHN1cHByZXNzY29udGVudGVkaXRhYmxld2FybmluZzogXCJzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmdcIixcbiAgICAgICAgc3VwcHJlc3NoeWRyYXRpb253YXJuaW5nOiBcInN1cHByZXNzSHlkcmF0aW9uV2FybmluZ1wiLFxuICAgICAgICBzdXJmYWNlc2NhbGU6IFwic3VyZmFjZVNjYWxlXCIsXG4gICAgICAgIHN5c3RlbWxhbmd1YWdlOiBcInN5c3RlbUxhbmd1YWdlXCIsXG4gICAgICAgIHRhYmxldmFsdWVzOiBcInRhYmxlVmFsdWVzXCIsXG4gICAgICAgIHRhcmdldHg6IFwidGFyZ2V0WFwiLFxuICAgICAgICB0YXJnZXR5OiBcInRhcmdldFlcIixcbiAgICAgICAgdGV4dGFuY2hvcjogXCJ0ZXh0QW5jaG9yXCIsXG4gICAgICAgIFwidGV4dC1hbmNob3JcIjogXCJ0ZXh0QW5jaG9yXCIsXG4gICAgICAgIHRleHRkZWNvcmF0aW9uOiBcInRleHREZWNvcmF0aW9uXCIsXG4gICAgICAgIFwidGV4dC1kZWNvcmF0aW9uXCI6IFwidGV4dERlY29yYXRpb25cIixcbiAgICAgICAgdGV4dGxlbmd0aDogXCJ0ZXh0TGVuZ3RoXCIsXG4gICAgICAgIHRleHRyZW5kZXJpbmc6IFwidGV4dFJlbmRlcmluZ1wiLFxuICAgICAgICBcInRleHQtcmVuZGVyaW5nXCI6IFwidGV4dFJlbmRlcmluZ1wiLFxuICAgICAgICB0bzogXCJ0b1wiLFxuICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNmb3JtXCIsXG4gICAgICAgIHRyYW5zZm9ybW9yaWdpbjogXCJ0cmFuc2Zvcm1PcmlnaW5cIixcbiAgICAgICAgXCJ0cmFuc2Zvcm0tb3JpZ2luXCI6IFwidHJhbnNmb3JtT3JpZ2luXCIsXG4gICAgICAgIHR5cGVvZjogXCJ0eXBlb2ZcIixcbiAgICAgICAgdTE6IFwidTFcIixcbiAgICAgICAgdTI6IFwidTJcIixcbiAgICAgICAgdW5kZXJsaW5lcG9zaXRpb246IFwidW5kZXJsaW5lUG9zaXRpb25cIixcbiAgICAgICAgXCJ1bmRlcmxpbmUtcG9zaXRpb25cIjogXCJ1bmRlcmxpbmVQb3NpdGlvblwiLFxuICAgICAgICB1bmRlcmxpbmV0aGlja25lc3M6IFwidW5kZXJsaW5lVGhpY2tuZXNzXCIsXG4gICAgICAgIFwidW5kZXJsaW5lLXRoaWNrbmVzc1wiOiBcInVuZGVybGluZVRoaWNrbmVzc1wiLFxuICAgICAgICB1bmljb2RlOiBcInVuaWNvZGVcIixcbiAgICAgICAgdW5pY29kZWJpZGk6IFwidW5pY29kZUJpZGlcIixcbiAgICAgICAgXCJ1bmljb2RlLWJpZGlcIjogXCJ1bmljb2RlQmlkaVwiLFxuICAgICAgICB1bmljb2RlcmFuZ2U6IFwidW5pY29kZVJhbmdlXCIsXG4gICAgICAgIFwidW5pY29kZS1yYW5nZVwiOiBcInVuaWNvZGVSYW5nZVwiLFxuICAgICAgICB1bml0c3BlcmVtOiBcInVuaXRzUGVyRW1cIixcbiAgICAgICAgXCJ1bml0cy1wZXItZW1cIjogXCJ1bml0c1BlckVtXCIsXG4gICAgICAgIHVuc2VsZWN0YWJsZTogXCJ1bnNlbGVjdGFibGVcIixcbiAgICAgICAgdmFscGhhYmV0aWM6IFwidkFscGhhYmV0aWNcIixcbiAgICAgICAgXCJ2LWFscGhhYmV0aWNcIjogXCJ2QWxwaGFiZXRpY1wiLFxuICAgICAgICB2YWx1ZXM6IFwidmFsdWVzXCIsXG4gICAgICAgIHZlY3RvcmVmZmVjdDogXCJ2ZWN0b3JFZmZlY3RcIixcbiAgICAgICAgXCJ2ZWN0b3ItZWZmZWN0XCI6IFwidmVjdG9yRWZmZWN0XCIsXG4gICAgICAgIHZlcnNpb246IFwidmVyc2lvblwiLFxuICAgICAgICB2ZXJ0YWR2eTogXCJ2ZXJ0QWR2WVwiLFxuICAgICAgICBcInZlcnQtYWR2LXlcIjogXCJ2ZXJ0QWR2WVwiLFxuICAgICAgICB2ZXJ0b3JpZ2lueDogXCJ2ZXJ0T3JpZ2luWFwiLFxuICAgICAgICBcInZlcnQtb3JpZ2luLXhcIjogXCJ2ZXJ0T3JpZ2luWFwiLFxuICAgICAgICB2ZXJ0b3JpZ2lueTogXCJ2ZXJ0T3JpZ2luWVwiLFxuICAgICAgICBcInZlcnQtb3JpZ2luLXlcIjogXCJ2ZXJ0T3JpZ2luWVwiLFxuICAgICAgICB2aGFuZ2luZzogXCJ2SGFuZ2luZ1wiLFxuICAgICAgICBcInYtaGFuZ2luZ1wiOiBcInZIYW5naW5nXCIsXG4gICAgICAgIHZpZGVvZ3JhcGhpYzogXCJ2SWRlb2dyYXBoaWNcIixcbiAgICAgICAgXCJ2LWlkZW9ncmFwaGljXCI6IFwidklkZW9ncmFwaGljXCIsXG4gICAgICAgIHZpZXdib3g6IFwidmlld0JveFwiLFxuICAgICAgICB2aWV3dGFyZ2V0OiBcInZpZXdUYXJnZXRcIixcbiAgICAgICAgdmlzaWJpbGl0eTogXCJ2aXNpYmlsaXR5XCIsXG4gICAgICAgIHZtYXRoZW1hdGljYWw6IFwidk1hdGhlbWF0aWNhbFwiLFxuICAgICAgICBcInYtbWF0aGVtYXRpY2FsXCI6IFwidk1hdGhlbWF0aWNhbFwiLFxuICAgICAgICB2b2NhYjogXCJ2b2NhYlwiLFxuICAgICAgICB3aWR0aHM6IFwid2lkdGhzXCIsXG4gICAgICAgIHdvcmRzcGFjaW5nOiBcIndvcmRTcGFjaW5nXCIsXG4gICAgICAgIFwid29yZC1zcGFjaW5nXCI6IFwid29yZFNwYWNpbmdcIixcbiAgICAgICAgd3JpdGluZ21vZGU6IFwid3JpdGluZ01vZGVcIixcbiAgICAgICAgXCJ3cml0aW5nLW1vZGVcIjogXCJ3cml0aW5nTW9kZVwiLFxuICAgICAgICB4MTogXCJ4MVwiLFxuICAgICAgICB4MjogXCJ4MlwiLFxuICAgICAgICB4OiBcInhcIixcbiAgICAgICAgeGNoYW5uZWxzZWxlY3RvcjogXCJ4Q2hhbm5lbFNlbGVjdG9yXCIsXG4gICAgICAgIHhoZWlnaHQ6IFwieEhlaWdodFwiLFxuICAgICAgICBcIngtaGVpZ2h0XCI6IFwieEhlaWdodFwiLFxuICAgICAgICB4bGlua2FjdHVhdGU6IFwieGxpbmtBY3R1YXRlXCIsXG4gICAgICAgIFwieGxpbms6YWN0dWF0ZVwiOiBcInhsaW5rQWN0dWF0ZVwiLFxuICAgICAgICB4bGlua2FyY3JvbGU6IFwieGxpbmtBcmNyb2xlXCIsXG4gICAgICAgIFwieGxpbms6YXJjcm9sZVwiOiBcInhsaW5rQXJjcm9sZVwiLFxuICAgICAgICB4bGlua2hyZWY6IFwieGxpbmtIcmVmXCIsXG4gICAgICAgIFwieGxpbms6aHJlZlwiOiBcInhsaW5rSHJlZlwiLFxuICAgICAgICB4bGlua3JvbGU6IFwieGxpbmtSb2xlXCIsXG4gICAgICAgIFwieGxpbms6cm9sZVwiOiBcInhsaW5rUm9sZVwiLFxuICAgICAgICB4bGlua3Nob3c6IFwieGxpbmtTaG93XCIsXG4gICAgICAgIFwieGxpbms6c2hvd1wiOiBcInhsaW5rU2hvd1wiLFxuICAgICAgICB4bGlua3RpdGxlOiBcInhsaW5rVGl0bGVcIixcbiAgICAgICAgXCJ4bGluazp0aXRsZVwiOiBcInhsaW5rVGl0bGVcIixcbiAgICAgICAgeGxpbmt0eXBlOiBcInhsaW5rVHlwZVwiLFxuICAgICAgICBcInhsaW5rOnR5cGVcIjogXCJ4bGlua1R5cGVcIixcbiAgICAgICAgeG1sYmFzZTogXCJ4bWxCYXNlXCIsXG4gICAgICAgIFwieG1sOmJhc2VcIjogXCJ4bWxCYXNlXCIsXG4gICAgICAgIHhtbGxhbmc6IFwieG1sTGFuZ1wiLFxuICAgICAgICBcInhtbDpsYW5nXCI6IFwieG1sTGFuZ1wiLFxuICAgICAgICB4bWxuczogXCJ4bWxuc1wiLFxuICAgICAgICBcInhtbDpzcGFjZVwiOiBcInhtbFNwYWNlXCIsXG4gICAgICAgIHhtbG5zeGxpbms6IFwieG1sbnNYbGlua1wiLFxuICAgICAgICBcInhtbG5zOnhsaW5rXCI6IFwieG1sbnNYbGlua1wiLFxuICAgICAgICB4bWxzcGFjZTogXCJ4bWxTcGFjZVwiLFxuICAgICAgICB5MTogXCJ5MVwiLFxuICAgICAgICB5MjogXCJ5MlwiLFxuICAgICAgICB5OiBcInlcIixcbiAgICAgICAgeWNoYW5uZWxzZWxlY3RvcjogXCJ5Q2hhbm5lbFNlbGVjdG9yXCIsXG4gICAgICAgIHo6IFwielwiLFxuICAgICAgICB6b29tYW5kcGFuOiBcInpvb21BbmRQYW5cIlxuICAgICAgfSxcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMgPSB7fSxcbiAgICAgIEVWRU5UX05BTUVfUkVHRVggPSAvXm9uLi8sXG4gICAgICBJTlZBTElEX0VWRU5UX05BTUVfUkVHRVggPSAvXm9uW15BLVpdLyxcbiAgICAgIHJBUklBID0gUmVnRXhwKFxuICAgICAgICBcIl4oYXJpYSktWzpBLVpfYS16XFxcXHUwMEMwLVxcXFx1MDBENlxcXFx1MDBEOC1cXFxcdTAwRjZcXFxcdTAwRjgtXFxcXHUwMkZGXFxcXHUwMzcwLVxcXFx1MDM3RFxcXFx1MDM3Ri1cXFxcdTFGRkZcXFxcdTIwMEMtXFxcXHUyMDBEXFxcXHUyMDcwLVxcXFx1MjE4RlxcXFx1MkMwMC1cXFxcdTJGRUZcXFxcdTMwMDEtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRkRcXFxcLS4wLTlcXFxcdTAwQjdcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUyMDNGLVxcXFx1MjA0MF0qJFwiXG4gICAgICApLFxuICAgICAgckFSSUFDYW1lbCA9IFJlZ0V4cChcbiAgICAgICAgXCJeKGFyaWEpW0EtWl1bOkEtWl9hLXpcXFxcdTAwQzAtXFxcXHUwMEQ2XFxcXHUwMEQ4LVxcXFx1MDBGNlxcXFx1MDBGOC1cXFxcdTAyRkZcXFxcdTAzNzAtXFxcXHUwMzdEXFxcXHUwMzdGLVxcXFx1MUZGRlxcXFx1MjAwQy1cXFxcdTIwMERcXFxcdTIwNzAtXFxcXHUyMThGXFxcXHUyQzAwLVxcXFx1MkZFRlxcXFx1MzAwMS1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZGRFxcXFwtLjAtOVxcXFx1MDBCN1xcXFx1MDMwMC1cXFxcdTAzNkZcXFxcdTIwM0YtXFxcXHUyMDQwXSokXCJcbiAgICAgICksXG4gICAgICBiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4gPSAvXig/OndlYmtpdHxtb3p8bylbQS1aXS8sXG4gICAgICBtc1BhdHRlcm4kMSA9IC9eLW1zLS8sXG4gICAgICBoeXBoZW5QYXR0ZXJuID0gLy0oLikvZyxcbiAgICAgIGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiA9IC87XFxzKiQvLFxuICAgICAgd2FybmVkU3R5bGVOYW1lcyA9IHt9LFxuICAgICAgd2FybmVkU3R5bGVWYWx1ZXMgPSB7fSxcbiAgICAgIHdhcm5lZEZvck5hTlZhbHVlID0gITEsXG4gICAgICB3YXJuZWRGb3JJbmZpbml0eVZhbHVlID0gITEsXG4gICAgICBtYXRjaEh0bWxSZWdFeHAgPSAvW1wiJyY8Pl0vLFxuICAgICAgdXBwZXJjYXNlUGF0dGVybiA9IC8oW0EtWl0pL2csXG4gICAgICBtc1BhdHRlcm4gPSAvXm1zLS8sXG4gICAgICBpc0phdmFTY3JpcHRQcm90b2NvbCA9XG4gICAgICAgIC9eW1xcdTAwMDAtXFx1MDAxRiBdKmpbXFxyXFxuXFx0XSphW1xcclxcblxcdF0qdltcXHJcXG5cXHRdKmFbXFxyXFxuXFx0XSpzW1xcclxcblxcdF0qY1tcXHJcXG5cXHRdKnJbXFxyXFxuXFx0XSppW1xcclxcblxcdF0qcFtcXHJcXG5cXHRdKnRbXFxyXFxuXFx0XSo6L2ksXG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscyA9XG4gICAgICAgIFJlYWN0Ll9fQ0xJRU5UX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERSxcbiAgICAgIFJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzID1cbiAgICAgICAgUmVhY3RET00uX19ET01fSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFLFxuICAgICAgTm90UGVuZGluZyA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBwZW5kaW5nOiAhMSxcbiAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgbWV0aG9kOiBudWxsLFxuICAgICAgICBhY3Rpb246IG51bGxcbiAgICAgIH0pLFxuICAgICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RET01TaGFyZWRJbnRlcm5hbHMuZDtcbiAgICBSZWFjdERPTVNoYXJlZEludGVybmFscy5kID0ge1xuICAgICAgZjogcHJldmlvdXNEaXNwYXRjaGVyLmYsXG4gICAgICByOiBwcmV2aW91c0Rpc3BhdGNoZXIucixcbiAgICAgIEQ6IGZ1bmN0aW9uIChocmVmKSB7XG4gICAgICAgIHZhciByZXF1ZXN0ID0gY3VycmVudFJlcXVlc3QgPyBjdXJyZW50UmVxdWVzdCA6IG51bGw7XG4gICAgICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICAgICAgdmFyIHJlc3VtYWJsZVN0YXRlID0gcmVxdWVzdC5yZXN1bWFibGVTdGF0ZSxcbiAgICAgICAgICAgIHJlbmRlclN0YXRlID0gcmVxdWVzdC5yZW5kZXJTdGF0ZTtcbiAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGhyZWYgJiYgaHJlZikge1xuICAgICAgICAgICAgaWYgKCFyZXN1bWFibGVTdGF0ZS5kbnNSZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoaHJlZikpIHtcbiAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUuZG5zUmVzb3VyY2VzW2hyZWZdID0gRVhJU1RTO1xuICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZSA9IHJlbmRlclN0YXRlLmhlYWRlcnM7XG4gICAgICAgICAgICAgIHZhciBoZWFkZXIsIEpTQ29tcGlsZXJfdGVtcDtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIChKU0NvbXBpbGVyX3RlbXAgPVxuICAgICAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUgJiYgMCA8IHJlc3VtYWJsZVN0YXRlLnJlbWFpbmluZ0NhcGFjaXR5KVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgSlNDb21waWxlcl90ZW1wID1cbiAgICAgICAgICAgICAgICAgICgoaGVhZGVyID1cbiAgICAgICAgICAgICAgICAgICAgXCI8XCIgK1xuICAgICAgICAgICAgICAgICAgICBlc2NhcGVIcmVmRm9yTGlua0hlYWRlclVSTENvbnRleHQoaHJlZikgK1xuICAgICAgICAgICAgICAgICAgICBcIj47IHJlbD1kbnMtcHJlZmV0Y2hcIiksXG4gICAgICAgICAgICAgICAgICAwIDw9IChyZXN1bWFibGVTdGF0ZS5yZW1haW5pbmdDYXBhY2l0eSAtPSBoZWFkZXIubGVuZ3RoICsgMikpO1xuICAgICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXBcbiAgICAgICAgICAgICAgICA/ICgocmVuZGVyU3RhdGUucmVzZXRzLmRuc1tocmVmXSA9IEVYSVNUUyksXG4gICAgICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZS5wcmVjb25uZWN0cyAmJlxuICAgICAgICAgICAgICAgICAgICAocmVzdW1hYmxlU3RhdGUucHJlY29ubmVjdHMgKz0gXCIsIFwiKSxcbiAgICAgICAgICAgICAgICAgIChyZXN1bWFibGVTdGF0ZS5wcmVjb25uZWN0cyArPSBoZWFkZXIpKVxuICAgICAgICAgICAgICAgIDogKChoZWFkZXIgPSBbXSksXG4gICAgICAgICAgICAgICAgICBwdXNoTGlua0ltcGwoaGVhZGVyLCB7IGhyZWY6IGhyZWYsIHJlbDogXCJkbnMtcHJlZmV0Y2hcIiB9KSxcbiAgICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLnByZWNvbm5lY3RzLmFkZChoZWFkZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVucXVldWVGbHVzaChyZXF1ZXN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBwcmV2aW91c0Rpc3BhdGNoZXIuRChocmVmKTtcbiAgICAgIH0sXG4gICAgICBDOiBmdW5jdGlvbiAoaHJlZiwgY3Jvc3NPcmlnaW4pIHtcbiAgICAgICAgdmFyIHJlcXVlc3QgPSBjdXJyZW50UmVxdWVzdCA/IGN1cnJlbnRSZXF1ZXN0IDogbnVsbDtcbiAgICAgICAgaWYgKHJlcXVlc3QpIHtcbiAgICAgICAgICB2YXIgcmVzdW1hYmxlU3RhdGUgPSByZXF1ZXN0LnJlc3VtYWJsZVN0YXRlLFxuICAgICAgICAgICAgcmVuZGVyU3RhdGUgPSByZXF1ZXN0LnJlbmRlclN0YXRlO1xuICAgICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgaHJlZiAmJiBocmVmKSB7XG4gICAgICAgICAgICB2YXIgYnVja2V0ID1cbiAgICAgICAgICAgICAgXCJ1c2UtY3JlZGVudGlhbHNcIiA9PT0gY3Jvc3NPcmlnaW5cbiAgICAgICAgICAgICAgICA/IFwiY3JlZGVudGlhbHNcIlxuICAgICAgICAgICAgICAgIDogXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGNyb3NzT3JpZ2luXG4gICAgICAgICAgICAgICAgICA/IFwiYW5vbnltb3VzXCJcbiAgICAgICAgICAgICAgICAgIDogXCJkZWZhdWx0XCI7XG4gICAgICAgICAgICBpZiAoIXJlc3VtYWJsZVN0YXRlLmNvbm5lY3RSZXNvdXJjZXNbYnVja2V0XS5oYXNPd25Qcm9wZXJ0eShocmVmKSkge1xuICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZS5jb25uZWN0UmVzb3VyY2VzW2J1Y2tldF1baHJlZl0gPSBFWElTVFM7XG4gICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlID0gcmVuZGVyU3RhdGUuaGVhZGVycztcbiAgICAgICAgICAgICAgdmFyIGhlYWRlciwgSlNDb21waWxlcl90ZW1wO1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKEpTQ29tcGlsZXJfdGVtcCA9XG4gICAgICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZSAmJiAwIDwgcmVzdW1hYmxlU3RhdGUucmVtYWluaW5nQ2FwYWNpdHkpXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCA9XG4gICAgICAgICAgICAgICAgICBcIjxcIiArXG4gICAgICAgICAgICAgICAgICBlc2NhcGVIcmVmRm9yTGlua0hlYWRlclVSTENvbnRleHQoaHJlZikgK1xuICAgICAgICAgICAgICAgICAgXCI+OyByZWw9cHJlY29ubmVjdFwiO1xuICAgICAgICAgICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgY3Jvc3NPcmlnaW4pIHtcbiAgICAgICAgICAgICAgICAgIHZhciBlc2NhcGVkQ3Jvc3NPcmlnaW4gPVxuICAgICAgICAgICAgICAgICAgICBlc2NhcGVTdHJpbmdGb3JMaW5rSGVhZGVyUXVvdGVkUGFyYW1WYWx1ZUNvbnRleHQoXG4gICAgICAgICAgICAgICAgICAgICAgY3Jvc3NPcmlnaW4sXG4gICAgICAgICAgICAgICAgICAgICAgXCJjcm9zc09yaWdpblwiXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAgKz1cbiAgICAgICAgICAgICAgICAgICAgJzsgY3Jvc3NvcmlnaW49XCInICsgZXNjYXBlZENyb3NzT3JpZ2luICsgJ1wiJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgSlNDb21waWxlcl90ZW1wID1cbiAgICAgICAgICAgICAgICAgICgoaGVhZGVyID0gSlNDb21waWxlcl90ZW1wKSxcbiAgICAgICAgICAgICAgICAgIDAgPD0gKHJlc3VtYWJsZVN0YXRlLnJlbWFpbmluZ0NhcGFjaXR5IC09IGhlYWRlci5sZW5ndGggKyAyKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgSlNDb21waWxlcl90ZW1wXG4gICAgICAgICAgICAgICAgPyAoKHJlbmRlclN0YXRlLnJlc2V0cy5jb25uZWN0W2J1Y2tldF1baHJlZl0gPSBFWElTVFMpLFxuICAgICAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUucHJlY29ubmVjdHMgJiZcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VtYWJsZVN0YXRlLnByZWNvbm5lY3RzICs9IFwiLCBcIiksXG4gICAgICAgICAgICAgICAgICAocmVzdW1hYmxlU3RhdGUucHJlY29ubmVjdHMgKz0gaGVhZGVyKSlcbiAgICAgICAgICAgICAgICA6ICgoYnVja2V0ID0gW10pLFxuICAgICAgICAgICAgICAgICAgcHVzaExpbmtJbXBsKGJ1Y2tldCwge1xuICAgICAgICAgICAgICAgICAgICByZWw6IFwicHJlY29ubmVjdFwiLFxuICAgICAgICAgICAgICAgICAgICBocmVmOiBocmVmLFxuICAgICAgICAgICAgICAgICAgICBjcm9zc09yaWdpbjogY3Jvc3NPcmlnaW5cbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUucHJlY29ubmVjdHMuYWRkKGJ1Y2tldCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW5xdWV1ZUZsdXNoKHJlcXVlc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHByZXZpb3VzRGlzcGF0Y2hlci5DKGhyZWYsIGNyb3NzT3JpZ2luKTtcbiAgICAgIH0sXG4gICAgICBMOiBmdW5jdGlvbiAoaHJlZiwgYXMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJlcXVlc3QgPSBjdXJyZW50UmVxdWVzdCA/IGN1cnJlbnRSZXF1ZXN0IDogbnVsbDtcbiAgICAgICAgaWYgKHJlcXVlc3QpIHtcbiAgICAgICAgICB2YXIgcmVzdW1hYmxlU3RhdGUgPSByZXF1ZXN0LnJlc3VtYWJsZVN0YXRlLFxuICAgICAgICAgICAgcmVuZGVyU3RhdGUgPSByZXF1ZXN0LnJlbmRlclN0YXRlO1xuICAgICAgICAgIGlmIChhcyAmJiBocmVmKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGFzKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJpbWFnZVwiOlxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgaW1hZ2VTcmNTZXQgPSBvcHRpb25zLmltYWdlU3JjU2V0O1xuICAgICAgICAgICAgICAgICAgdmFyIGltYWdlU2l6ZXMgPSBvcHRpb25zLmltYWdlU2l6ZXM7XG4gICAgICAgICAgICAgICAgICB2YXIgZmV0Y2hQcmlvcml0eSA9IG9wdGlvbnMuZmV0Y2hQcmlvcml0eTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGltYWdlU3JjU2V0XG4gICAgICAgICAgICAgICAgICA/IGltYWdlU3JjU2V0ICsgXCJcXG5cIiArIChpbWFnZVNpemVzIHx8IFwiXCIpXG4gICAgICAgICAgICAgICAgICA6IGhyZWY7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VtYWJsZVN0YXRlLmltYWdlUmVzb3VyY2VzLmhhc093blByb3BlcnR5KGtleSkpIHJldHVybjtcbiAgICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZS5pbWFnZVJlc291cmNlc1trZXldID0gUFJFTE9BRF9OT19DUkVEUztcbiAgICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZSA9IHJlbmRlclN0YXRlLmhlYWRlcnM7XG4gICAgICAgICAgICAgICAgdmFyIGhlYWRlcjtcbiAgICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZSAmJlxuICAgICAgICAgICAgICAgIDAgPCByZXN1bWFibGVTdGF0ZS5yZW1haW5pbmdDYXBhY2l0eSAmJlxuICAgICAgICAgICAgICAgIFwiaGlnaFwiID09PSBmZXRjaFByaW9yaXR5ICYmXG4gICAgICAgICAgICAgICAgKChoZWFkZXIgPSBnZXRQcmVsb2FkQXNIZWFkZXIoaHJlZiwgYXMsIG9wdGlvbnMpKSxcbiAgICAgICAgICAgICAgICAwIDw9IChyZXN1bWFibGVTdGF0ZS5yZW1haW5pbmdDYXBhY2l0eSAtPSBoZWFkZXIubGVuZ3RoICsgMikpXG4gICAgICAgICAgICAgICAgICA/ICgocmVuZGVyU3RhdGUucmVzZXRzLmltYWdlW2tleV0gPSBQUkVMT0FEX05PX0NSRURTKSxcbiAgICAgICAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUuaGlnaEltYWdlUHJlbG9hZHMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAocmVzdW1hYmxlU3RhdGUuaGlnaEltYWdlUHJlbG9hZHMgKz0gXCIsIFwiKSxcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VtYWJsZVN0YXRlLmhpZ2hJbWFnZVByZWxvYWRzICs9IGhlYWRlcikpXG4gICAgICAgICAgICAgICAgICA6ICgocmVzdW1hYmxlU3RhdGUgPSBbXSksXG4gICAgICAgICAgICAgICAgICAgIHB1c2hMaW5rSW1wbChcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICBhc3NpZ24oXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlbDogXCJwcmVsb2FkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY6IGltYWdlU3JjU2V0ID8gdm9pZCAwIDogaHJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXM6IGFzXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgXCJoaWdoXCIgPT09IGZldGNoUHJpb3JpdHlcbiAgICAgICAgICAgICAgICAgICAgICA/IHJlbmRlclN0YXRlLmhpZ2hJbWFnZVByZWxvYWRzLmFkZChyZXN1bWFibGVTdGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgICA6IChyZW5kZXJTdGF0ZS5idWxrUHJlbG9hZHMuYWRkKHJlc3VtYWJsZVN0YXRlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLnByZWxvYWRzLmltYWdlcy5zZXQoa2V5LCByZXN1bWFibGVTdGF0ZSkpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcInN0eWxlXCI6XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzLmhhc093blByb3BlcnR5KGhyZWYpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgaW1hZ2VTcmNTZXQgPSBbXTtcbiAgICAgICAgICAgICAgICBwdXNoTGlua0ltcGwoXG4gICAgICAgICAgICAgICAgICBpbWFnZVNyY1NldCxcbiAgICAgICAgICAgICAgICAgIGFzc2lnbih7IHJlbDogXCJwcmVsb2FkXCIsIGhyZWY6IGhyZWYsIGFzOiBhcyB9LCBvcHRpb25zKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUuc3R5bGVSZXNvdXJjZXNbaHJlZl0gPVxuICAgICAgICAgICAgICAgICAgIW9wdGlvbnMgfHxcbiAgICAgICAgICAgICAgICAgIChcInN0cmluZ1wiICE9PSB0eXBlb2Ygb3B0aW9ucy5jcm9zc09yaWdpbiAmJlxuICAgICAgICAgICAgICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2Ygb3B0aW9ucy5pbnRlZ3JpdHkpXG4gICAgICAgICAgICAgICAgICAgID8gUFJFTE9BRF9OT19DUkVEU1xuICAgICAgICAgICAgICAgICAgICA6IFtvcHRpb25zLmNyb3NzT3JpZ2luLCBvcHRpb25zLmludGVncml0eV07XG4gICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUucHJlbG9hZHMuc3R5bGVzaGVldHMuc2V0KGhyZWYsIGltYWdlU3JjU2V0KTtcbiAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5idWxrUHJlbG9hZHMuYWRkKGltYWdlU3JjU2V0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcInNjcmlwdFwiOlxuICAgICAgICAgICAgICAgIGlmIChyZXN1bWFibGVTdGF0ZS5zY3JpcHRSZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoaHJlZikpIHJldHVybjtcbiAgICAgICAgICAgICAgICBpbWFnZVNyY1NldCA9IFtdO1xuICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLnByZWxvYWRzLnNjcmlwdHMuc2V0KGhyZWYsIGltYWdlU3JjU2V0KTtcbiAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5idWxrUHJlbG9hZHMuYWRkKGltYWdlU3JjU2V0KTtcbiAgICAgICAgICAgICAgICBwdXNoTGlua0ltcGwoXG4gICAgICAgICAgICAgICAgICBpbWFnZVNyY1NldCxcbiAgICAgICAgICAgICAgICAgIGFzc2lnbih7IHJlbDogXCJwcmVsb2FkXCIsIGhyZWY6IGhyZWYsIGFzOiBhcyB9LCBvcHRpb25zKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUuc2NyaXB0UmVzb3VyY2VzW2hyZWZdID1cbiAgICAgICAgICAgICAgICAgICFvcHRpb25zIHx8XG4gICAgICAgICAgICAgICAgICAoXCJzdHJpbmdcIiAhPT0gdHlwZW9mIG9wdGlvbnMuY3Jvc3NPcmlnaW4gJiZcbiAgICAgICAgICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIG9wdGlvbnMuaW50ZWdyaXR5KVxuICAgICAgICAgICAgICAgICAgICA/IFBSRUxPQURfTk9fQ1JFRFNcbiAgICAgICAgICAgICAgICAgICAgOiBbb3B0aW9ucy5jcm9zc09yaWdpbiwgb3B0aW9ucy5pbnRlZ3JpdHldO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmIChyZXN1bWFibGVTdGF0ZS51bmtub3duUmVzb3VyY2VzLmhhc093blByb3BlcnR5KGFzKSkge1xuICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAoKGltYWdlU3JjU2V0ID0gcmVzdW1hYmxlU3RhdGUudW5rbm93blJlc291cmNlc1thc10pLFxuICAgICAgICAgICAgICAgICAgICBpbWFnZVNyY1NldC5oYXNPd25Qcm9wZXJ0eShocmVmKSlcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgKGltYWdlU3JjU2V0ID0ge30pLFxuICAgICAgICAgICAgICAgICAgICAocmVzdW1hYmxlU3RhdGUudW5rbm93blJlc291cmNlc1thc10gPSBpbWFnZVNyY1NldCk7XG4gICAgICAgICAgICAgICAgaW1hZ2VTcmNTZXRbaHJlZl0gPSBQUkVMT0FEX05PX0NSRURTO1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgIChyZXN1bWFibGVTdGF0ZSA9IHJlbmRlclN0YXRlLmhlYWRlcnMpICYmXG4gICAgICAgICAgICAgICAgICAwIDwgcmVzdW1hYmxlU3RhdGUucmVtYWluaW5nQ2FwYWNpdHkgJiZcbiAgICAgICAgICAgICAgICAgIFwiZm9udFwiID09PSBhcyAmJlxuICAgICAgICAgICAgICAgICAgKChrZXkgPSBnZXRQcmVsb2FkQXNIZWFkZXIoaHJlZiwgYXMsIG9wdGlvbnMpKSxcbiAgICAgICAgICAgICAgICAgIDAgPD0gKHJlc3VtYWJsZVN0YXRlLnJlbWFpbmluZ0NhcGFjaXR5IC09IGtleS5sZW5ndGggKyAyKSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAocmVuZGVyU3RhdGUucmVzZXRzLmZvbnRbaHJlZl0gPSBQUkVMT0FEX05PX0NSRURTKSxcbiAgICAgICAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUuZm9udFByZWxvYWRzICYmXG4gICAgICAgICAgICAgICAgICAgICAgKHJlc3VtYWJsZVN0YXRlLmZvbnRQcmVsb2FkcyArPSBcIiwgXCIpLFxuICAgICAgICAgICAgICAgICAgICAocmVzdW1hYmxlU3RhdGUuZm9udFByZWxvYWRzICs9IGtleSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgc3dpdGNoIChcbiAgICAgICAgICAgICAgICAgICAgKChyZXN1bWFibGVTdGF0ZSA9IFtdKSxcbiAgICAgICAgICAgICAgICAgICAgKGhyZWYgPSBhc3NpZ24oXG4gICAgICAgICAgICAgICAgICAgICAgeyByZWw6IFwicHJlbG9hZFwiLCBocmVmOiBocmVmLCBhczogYXMgfSxcbiAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgICAgICBwdXNoTGlua0ltcGwocmVzdW1hYmxlU3RhdGUsIGhyZWYpLFxuICAgICAgICAgICAgICAgICAgICBhcylcbiAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZm9udFwiOlxuICAgICAgICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLmZvbnRQcmVsb2Fkcy5hZGQocmVzdW1hYmxlU3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLmJ1bGtQcmVsb2Fkcy5hZGQocmVzdW1hYmxlU3RhdGUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW5xdWV1ZUZsdXNoKHJlcXVlc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHByZXZpb3VzRGlzcGF0Y2hlci5MKGhyZWYsIGFzLCBvcHRpb25zKTtcbiAgICAgIH0sXG4gICAgICBtOiBmdW5jdGlvbiAoaHJlZiwgb3B0aW9ucykge1xuICAgICAgICB2YXIgcmVxdWVzdCA9IGN1cnJlbnRSZXF1ZXN0ID8gY3VycmVudFJlcXVlc3QgOiBudWxsO1xuICAgICAgICBpZiAocmVxdWVzdCkge1xuICAgICAgICAgIHZhciByZXN1bWFibGVTdGF0ZSA9IHJlcXVlc3QucmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICByZW5kZXJTdGF0ZSA9IHJlcXVlc3QucmVuZGVyU3RhdGU7XG4gICAgICAgICAgaWYgKGhyZWYpIHtcbiAgICAgICAgICAgIHZhciBhcyA9XG4gICAgICAgICAgICAgIG9wdGlvbnMgJiYgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMuYXMgPyBvcHRpb25zLmFzIDogXCJzY3JpcHRcIjtcbiAgICAgICAgICAgIHN3aXRjaCAoYXMpIHtcbiAgICAgICAgICAgICAgY2FzZSBcInNjcmlwdFwiOlxuICAgICAgICAgICAgICAgIGlmIChyZXN1bWFibGVTdGF0ZS5tb2R1bGVTY3JpcHRSZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoaHJlZikpXG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgYXMgPSBbXTtcbiAgICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZS5tb2R1bGVTY3JpcHRSZXNvdXJjZXNbaHJlZl0gPVxuICAgICAgICAgICAgICAgICAgIW9wdGlvbnMgfHxcbiAgICAgICAgICAgICAgICAgIChcInN0cmluZ1wiICE9PSB0eXBlb2Ygb3B0aW9ucy5jcm9zc09yaWdpbiAmJlxuICAgICAgICAgICAgICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2Ygb3B0aW9ucy5pbnRlZ3JpdHkpXG4gICAgICAgICAgICAgICAgICAgID8gUFJFTE9BRF9OT19DUkVEU1xuICAgICAgICAgICAgICAgICAgICA6IFtvcHRpb25zLmNyb3NzT3JpZ2luLCBvcHRpb25zLmludGVncml0eV07XG4gICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUucHJlbG9hZHMubW9kdWxlU2NyaXB0cy5zZXQoaHJlZiwgYXMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmIChyZXN1bWFibGVTdGF0ZS5tb2R1bGVVbmtub3duUmVzb3VyY2VzLmhhc093blByb3BlcnR5KGFzKSkge1xuICAgICAgICAgICAgICAgICAgdmFyIHJlc291cmNlcyA9IHJlc3VtYWJsZVN0YXRlLnVua25vd25SZXNvdXJjZXNbYXNdO1xuICAgICAgICAgICAgICAgICAgaWYgKHJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShocmVmKSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgKHJlc291cmNlcyA9IHt9KSxcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VtYWJsZVN0YXRlLm1vZHVsZVVua25vd25SZXNvdXJjZXNbYXNdID0gcmVzb3VyY2VzKTtcbiAgICAgICAgICAgICAgICBhcyA9IFtdO1xuICAgICAgICAgICAgICAgIHJlc291cmNlc1tocmVmXSA9IFBSRUxPQURfTk9fQ1JFRFM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwdXNoTGlua0ltcGwoXG4gICAgICAgICAgICAgIGFzLFxuICAgICAgICAgICAgICBhc3NpZ24oeyByZWw6IFwibW9kdWxlcHJlbG9hZFwiLCBocmVmOiBocmVmIH0sIG9wdGlvbnMpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmVuZGVyU3RhdGUuYnVsa1ByZWxvYWRzLmFkZChhcyk7XG4gICAgICAgICAgICBlbnF1ZXVlRmx1c2gocmVxdWVzdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgcHJldmlvdXNEaXNwYXRjaGVyLm0oaHJlZiwgb3B0aW9ucyk7XG4gICAgICB9LFxuICAgICAgWDogZnVuY3Rpb24gKHNyYywgb3B0aW9ucykge1xuICAgICAgICB2YXIgcmVxdWVzdCA9IGN1cnJlbnRSZXF1ZXN0ID8gY3VycmVudFJlcXVlc3QgOiBudWxsO1xuICAgICAgICBpZiAocmVxdWVzdCkge1xuICAgICAgICAgIHZhciByZXN1bWFibGVTdGF0ZSA9IHJlcXVlc3QucmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICByZW5kZXJTdGF0ZSA9IHJlcXVlc3QucmVuZGVyU3RhdGU7XG4gICAgICAgICAgaWYgKHNyYykge1xuICAgICAgICAgICAgdmFyIHJlc291cmNlU3RhdGUgPSByZXN1bWFibGVTdGF0ZS5zY3JpcHRSZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoXG4gICAgICAgICAgICAgIHNyY1xuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA/IHJlc3VtYWJsZVN0YXRlLnNjcmlwdFJlc291cmNlc1tzcmNdXG4gICAgICAgICAgICAgIDogdm9pZCAwO1xuICAgICAgICAgICAgcmVzb3VyY2VTdGF0ZSAhPT0gRVhJU1RTICYmXG4gICAgICAgICAgICAgICgocmVzdW1hYmxlU3RhdGUuc2NyaXB0UmVzb3VyY2VzW3NyY10gPSBFWElTVFMpLFxuICAgICAgICAgICAgICAob3B0aW9ucyA9IGFzc2lnbih7IHNyYzogc3JjLCBhc3luYzogITAgfSwgb3B0aW9ucykpLFxuICAgICAgICAgICAgICByZXNvdXJjZVN0YXRlICYmXG4gICAgICAgICAgICAgICAgKDIgPT09IHJlc291cmNlU3RhdGUubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICBhZG9wdFByZWxvYWRDcmVkZW50aWFscyhvcHRpb25zLCByZXNvdXJjZVN0YXRlKSxcbiAgICAgICAgICAgICAgICAoc3JjID0gcmVuZGVyU3RhdGUucHJlbG9hZHMuc2NyaXB0cy5nZXQoc3JjKSkpICYmXG4gICAgICAgICAgICAgICAgKHNyYy5sZW5ndGggPSAwKSxcbiAgICAgICAgICAgICAgKHNyYyA9IFtdKSxcbiAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuc2NyaXB0cy5hZGQoc3JjKSxcbiAgICAgICAgICAgICAgcHVzaFNjcmlwdEltcGwoc3JjLCBvcHRpb25zKSxcbiAgICAgICAgICAgICAgZW5xdWV1ZUZsdXNoKHJlcXVlc3QpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBwcmV2aW91c0Rpc3BhdGNoZXIuWChzcmMsIG9wdGlvbnMpO1xuICAgICAgfSxcbiAgICAgIFM6IGZ1bmN0aW9uIChocmVmLCBwcmVjZWRlbmNlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciByZXF1ZXN0ID0gY3VycmVudFJlcXVlc3QgPyBjdXJyZW50UmVxdWVzdCA6IG51bGw7XG4gICAgICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICAgICAgdmFyIHJlc3VtYWJsZVN0YXRlID0gcmVxdWVzdC5yZXN1bWFibGVTdGF0ZSxcbiAgICAgICAgICAgIHJlbmRlclN0YXRlID0gcmVxdWVzdC5yZW5kZXJTdGF0ZTtcbiAgICAgICAgICBpZiAoaHJlZikge1xuICAgICAgICAgICAgcHJlY2VkZW5jZSA9IHByZWNlZGVuY2UgfHwgXCJkZWZhdWx0XCI7XG4gICAgICAgICAgICB2YXIgc3R5bGVRdWV1ZSA9IHJlbmRlclN0YXRlLnN0eWxlcy5nZXQocHJlY2VkZW5jZSksXG4gICAgICAgICAgICAgIHJlc291cmNlU3RhdGUgPSByZXN1bWFibGVTdGF0ZS5zdHlsZVJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShocmVmKVxuICAgICAgICAgICAgICAgID8gcmVzdW1hYmxlU3RhdGUuc3R5bGVSZXNvdXJjZXNbaHJlZl1cbiAgICAgICAgICAgICAgICA6IHZvaWQgMDtcbiAgICAgICAgICAgIHJlc291cmNlU3RhdGUgIT09IEVYSVNUUyAmJlxuICAgICAgICAgICAgICAoKHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzW2hyZWZdID0gRVhJU1RTKSxcbiAgICAgICAgICAgICAgc3R5bGVRdWV1ZSB8fFxuICAgICAgICAgICAgICAgICgoc3R5bGVRdWV1ZSA9IHtcbiAgICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IGVzY2FwZVRleHRGb3JCcm93c2VyKHByZWNlZGVuY2UpLFxuICAgICAgICAgICAgICAgICAgcnVsZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgaHJlZnM6IFtdLFxuICAgICAgICAgICAgICAgICAgc2hlZXRzOiBuZXcgTWFwKClcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5zdHlsZXMuc2V0KHByZWNlZGVuY2UsIHN0eWxlUXVldWUpKSxcbiAgICAgICAgICAgICAgKHByZWNlZGVuY2UgPSB7XG4gICAgICAgICAgICAgICAgc3RhdGU6IFBFTkRJTkckMSxcbiAgICAgICAgICAgICAgICBwcm9wczogYXNzaWduKFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByZWw6IFwic3R5bGVzaGVldFwiLFxuICAgICAgICAgICAgICAgICAgICBocmVmOiBocmVmLFxuICAgICAgICAgICAgICAgICAgICBcImRhdGEtcHJlY2VkZW5jZVwiOiBwcmVjZWRlbmNlXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIHJlc291cmNlU3RhdGUgJiZcbiAgICAgICAgICAgICAgICAoMiA9PT0gcmVzb3VyY2VTdGF0ZS5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgIGFkb3B0UHJlbG9hZENyZWRlbnRpYWxzKHByZWNlZGVuY2UucHJvcHMsIHJlc291cmNlU3RhdGUpLFxuICAgICAgICAgICAgICAgIChyZW5kZXJTdGF0ZSA9IHJlbmRlclN0YXRlLnByZWxvYWRzLnN0eWxlc2hlZXRzLmdldChocmVmKSkgJiZcbiAgICAgICAgICAgICAgICAwIDwgcmVuZGVyU3RhdGUubGVuZ3RoXG4gICAgICAgICAgICAgICAgICA/IChyZW5kZXJTdGF0ZS5sZW5ndGggPSAwKVxuICAgICAgICAgICAgICAgICAgOiAocHJlY2VkZW5jZS5zdGF0ZSA9IFBSRUxPQURFRCkpLFxuICAgICAgICAgICAgICBzdHlsZVF1ZXVlLnNoZWV0cy5zZXQoaHJlZiwgcHJlY2VkZW5jZSksXG4gICAgICAgICAgICAgIGVucXVldWVGbHVzaChyZXF1ZXN0KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgcHJldmlvdXNEaXNwYXRjaGVyLlMoaHJlZiwgcHJlY2VkZW5jZSwgb3B0aW9ucyk7XG4gICAgICB9LFxuICAgICAgTTogZnVuY3Rpb24gKHNyYywgb3B0aW9ucykge1xuICAgICAgICB2YXIgcmVxdWVzdCA9IGN1cnJlbnRSZXF1ZXN0ID8gY3VycmVudFJlcXVlc3QgOiBudWxsO1xuICAgICAgICBpZiAocmVxdWVzdCkge1xuICAgICAgICAgIHZhciByZXN1bWFibGVTdGF0ZSA9IHJlcXVlc3QucmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICByZW5kZXJTdGF0ZSA9IHJlcXVlc3QucmVuZGVyU3RhdGU7XG4gICAgICAgICAgaWYgKHNyYykge1xuICAgICAgICAgICAgdmFyIHJlc291cmNlU3RhdGUgPVxuICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZS5tb2R1bGVTY3JpcHRSZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoc3JjKVxuICAgICAgICAgICAgICAgID8gcmVzdW1hYmxlU3RhdGUubW9kdWxlU2NyaXB0UmVzb3VyY2VzW3NyY11cbiAgICAgICAgICAgICAgICA6IHZvaWQgMDtcbiAgICAgICAgICAgIHJlc291cmNlU3RhdGUgIT09IEVYSVNUUyAmJlxuICAgICAgICAgICAgICAoKHJlc3VtYWJsZVN0YXRlLm1vZHVsZVNjcmlwdFJlc291cmNlc1tzcmNdID0gRVhJU1RTKSxcbiAgICAgICAgICAgICAgKG9wdGlvbnMgPSBhc3NpZ24oXG4gICAgICAgICAgICAgICAgeyBzcmM6IHNyYywgdHlwZTogXCJtb2R1bGVcIiwgYXN5bmM6ICEwIH0sXG4gICAgICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgcmVzb3VyY2VTdGF0ZSAmJlxuICAgICAgICAgICAgICAgICgyID09PSByZXNvdXJjZVN0YXRlLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgYWRvcHRQcmVsb2FkQ3JlZGVudGlhbHMob3B0aW9ucywgcmVzb3VyY2VTdGF0ZSksXG4gICAgICAgICAgICAgICAgKHNyYyA9IHJlbmRlclN0YXRlLnByZWxvYWRzLm1vZHVsZVNjcmlwdHMuZ2V0KHNyYykpKSAmJlxuICAgICAgICAgICAgICAgIChzcmMubGVuZ3RoID0gMCksXG4gICAgICAgICAgICAgIChzcmMgPSBbXSksXG4gICAgICAgICAgICAgIHJlbmRlclN0YXRlLnNjcmlwdHMuYWRkKHNyYyksXG4gICAgICAgICAgICAgIHB1c2hTY3JpcHRJbXBsKHNyYywgb3B0aW9ucyksXG4gICAgICAgICAgICAgIGVucXVldWVGbHVzaChyZXF1ZXN0KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgcHJldmlvdXNEaXNwYXRjaGVyLk0oc3JjLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBOb3RoaW5nU2VudCA9IDAsXG4gICAgICBTZW50Q29tcGxldGVTZWdtZW50RnVuY3Rpb24gPSAxLFxuICAgICAgU2VudENvbXBsZXRlQm91bmRhcnlGdW5jdGlvbiA9IDIsXG4gICAgICBTZW50Q2xpZW50UmVuZGVyRnVuY3Rpb24gPSA0LFxuICAgICAgU2VudFN0eWxlSW5zZXJ0aW9uRnVuY3Rpb24gPSA4LFxuICAgICAgRVhJU1RTID0gbnVsbCxcbiAgICAgIFBSRUxPQURfTk9fQ1JFRFMgPSBbXTtcbiAgICBPYmplY3QuZnJlZXplKFBSRUxPQURfTk9fQ1JFRFMpO1xuICAgIHZhciBzY3JpcHRSZWdleCA9IC8oPFxcL3w8KShzKShjcmlwdCkvZ2k7XG4gICAgdmFyIGRpZFdhcm5Gb3JOZXdCb29sZWFuUHJvcHNXaXRoRW1wdHlWYWx1ZSA9IHt9O1xuICAgIHZhciBST09UX0hUTUxfTU9ERSA9IDAsXG4gICAgICBIVE1MX0hUTUxfTU9ERSA9IDEsXG4gICAgICBIVE1MX01PREUgPSAyLFxuICAgICAgU1ZHX01PREUgPSAzLFxuICAgICAgTUFUSE1MX01PREUgPSA0LFxuICAgICAgSFRNTF9UQUJMRV9NT0RFID0gNSxcbiAgICAgIEhUTUxfVEFCTEVfQk9EWV9NT0RFID0gNixcbiAgICAgIEhUTUxfVEFCTEVfUk9XX01PREUgPSA3LFxuICAgICAgSFRNTF9DT0xHUk9VUF9NT0RFID0gOCxcbiAgICAgIHN0eWxlTmFtZUNhY2hlID0gbmV3IE1hcCgpLFxuICAgICAgc3R5bGVBdHRyaWJ1dGVTdGFydCA9ICcgc3R5bGU9XCInLFxuICAgICAgc3R5bGVBc3NpZ24gPSBcIjpcIixcbiAgICAgIHN0eWxlU2VwYXJhdG9yID0gXCI7XCIsXG4gICAgICBhdHRyaWJ1dGVTZXBhcmF0b3IgPSBcIiBcIixcbiAgICAgIGF0dHJpYnV0ZUFzc2lnbiA9ICc9XCInLFxuICAgICAgYXR0cmlidXRlRW5kID0gJ1wiJyxcbiAgICAgIGF0dHJpYnV0ZUVtcHR5U3RyaW5nID0gJz1cIlwiJyxcbiAgICAgIGFjdGlvbkphdmFTY3JpcHRVUkwgPSBlc2NhcGVUZXh0Rm9yQnJvd3NlcihcbiAgICAgICAgXCJqYXZhc2NyaXB0OnRocm93IG5ldyBFcnJvcignUmVhY3QgZm9ybSB1bmV4cGVjdGVkbHkgc3VibWl0dGVkLicpXCJcbiAgICAgICksXG4gICAgICBlbmRPZlN0YXJ0VGFnID0gXCI+XCIsXG4gICAgICBlbmRPZlN0YXJ0VGFnU2VsZkNsb3NpbmcgPSBcIi8+XCIsXG4gICAgICBkaWRXYXJuRGVmYXVsdElucHV0VmFsdWUgPSAhMSxcbiAgICAgIGRpZFdhcm5EZWZhdWx0Q2hlY2tlZCA9ICExLFxuICAgICAgZGlkV2FybkRlZmF1bHRTZWxlY3RWYWx1ZSA9ICExLFxuICAgICAgZGlkV2FybkRlZmF1bHRUZXh0YXJlYVZhbHVlID0gITEsXG4gICAgICBkaWRXYXJuSW52YWxpZE9wdGlvbkNoaWxkcmVuID0gITEsXG4gICAgICBkaWRXYXJuSW52YWxpZE9wdGlvbklubmVySFRNTCA9ICExLFxuICAgICAgZGlkV2FyblNlbGVjdGVkU2V0T25PcHRpb24gPSAhMSxcbiAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uVHlwZSA9ICExLFxuICAgICAgZGlkV2FybkZvcm1BY3Rpb25OYW1lID0gITEsXG4gICAgICBkaWRXYXJuRm9ybUFjdGlvblRhcmdldCA9ICExLFxuICAgICAgZGlkV2FybkZvcm1BY3Rpb25NZXRob2QgPSAhMSxcbiAgICAgIGZvcm1SZXBsYXlpbmdSdW50aW1lU2NyaXB0ID1cbiAgICAgICAgJ2FkZEV2ZW50TGlzdGVuZXIoXCJzdWJtaXRcIixmdW5jdGlvbihhKXtpZighYS5kZWZhdWx0UHJldmVudGVkKXt2YXIgYz1hLnRhcmdldCxkPWEuc3VibWl0dGVyLGU9Yy5hY3Rpb24sYj1kO2lmKGQpe3ZhciBmPWQuZ2V0QXR0cmlidXRlKFwiZm9ybUFjdGlvblwiKTtudWxsIT1mJiYoZT1mLGI9bnVsbCl9XCJqYXZhc2NyaXB0OnRocm93IG5ldyBFcnJvcihcXCdSZWFjdCBmb3JtIHVuZXhwZWN0ZWRseSBzdWJtaXR0ZWQuXFwnKVwiPT09ZSYmKGEucHJldmVudERlZmF1bHQoKSxiPyhhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKSxhLm5hbWU9Yi5uYW1lLGEudmFsdWU9Yi52YWx1ZSxiLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGEsYiksYj1uZXcgRm9ybURhdGEoYyksYS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGEpKTpiPW5ldyBGb3JtRGF0YShjKSxhPWMub3duZXJEb2N1bWVudHx8YywoYS4kJHJlYWN0Rm9ybVJlcGxheT1hLiQkcmVhY3RGb3JtUmVwbGF5fHxbXSkucHVzaChjLGQsYikpfX0pOycsXG4gICAgICBzdHlsZVJlZ2V4ID0gLyg8XFwvfDwpKHMpKHR5bGUpL2dpLFxuICAgICAgbGVhZGluZ05ld2xpbmUgPSBcIlxcblwiLFxuICAgICAgVkFMSURfVEFHX1JFR0VYID0gL15bYS16QS1aXVthLXpBLVo6X1xcLlxcLVxcZF0qJC8sXG4gICAgICB2YWxpZGF0ZWRUYWdDYWNoZSA9IG5ldyBNYXAoKSxcbiAgICAgIGVuZFRhZ0NhY2hlID0gbmV3IE1hcCgpLFxuICAgICAgcGxhY2Vob2xkZXIxID0gJzx0ZW1wbGF0ZSBpZD1cIicsXG4gICAgICBwbGFjZWhvbGRlcjIgPSAnXCI+PC90ZW1wbGF0ZT4nLFxuICAgICAgc3RhcnRDb21wbGV0ZWRTdXNwZW5zZUJvdW5kYXJ5ID0gXCJcXHgzYyEtLSQtLVxceDNlXCIsXG4gICAgICBzdGFydFBlbmRpbmdTdXNwZW5zZUJvdW5kYXJ5MSA9ICdcXHgzYyEtLSQ/LS1cXHgzZTx0ZW1wbGF0ZSBpZD1cIicsXG4gICAgICBzdGFydFBlbmRpbmdTdXNwZW5zZUJvdW5kYXJ5MiA9ICdcIj48L3RlbXBsYXRlPicsXG4gICAgICBzdGFydENsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeSA9IFwiXFx4M2MhLS0kIS0tXFx4M2VcIixcbiAgICAgIGVuZFN1c3BlbnNlQm91bmRhcnkgPSBcIlxceDNjIS0tLyQtLVxceDNlXCIsXG4gICAgICBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjEgPSBcIjx0ZW1wbGF0ZVwiLFxuICAgICAgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3JBdHRySW50ZXJzdGl0aWFsID0gJ1wiJyxcbiAgICAgIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMUEgPSAnIGRhdGEtZGdzdD1cIicsXG4gICAgICBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjFCID0gJyBkYXRhLW1zZz1cIicsXG4gICAgICBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjFDID0gJyBkYXRhLXN0Y2s9XCInLFxuICAgICAgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxRCA9ICcgZGF0YS1jc3Rjaz1cIicsXG4gICAgICBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjIgPSBcIj48L3RlbXBsYXRlPlwiLFxuICAgICAgc3RhcnRTZWdtZW50SFRNTCA9ICc8ZGl2IGhpZGRlbiBpZD1cIicsXG4gICAgICBzdGFydFNlZ21lbnRIVE1MMiA9ICdcIj4nLFxuICAgICAgZW5kU2VnbWVudEhUTUwgPSBcIjwvZGl2PlwiLFxuICAgICAgc3RhcnRTZWdtZW50U1ZHID0gJzxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgc3R5bGU9XCJkaXNwbGF5Om5vbmVcIiBpZD1cIicsXG4gICAgICBzdGFydFNlZ21lbnRTVkcyID0gJ1wiPicsXG4gICAgICBlbmRTZWdtZW50U1ZHID0gXCI8L3N2Zz5cIixcbiAgICAgIHN0YXJ0U2VnbWVudE1hdGhNTCA9ICc8bWF0aCBhcmlhLWhpZGRlbj1cInRydWVcIiBzdHlsZT1cImRpc3BsYXk6bm9uZVwiIGlkPVwiJyxcbiAgICAgIHN0YXJ0U2VnbWVudE1hdGhNTDIgPSAnXCI+JyxcbiAgICAgIGVuZFNlZ21lbnRNYXRoTUwgPSBcIjwvbWF0aD5cIixcbiAgICAgIHN0YXJ0U2VnbWVudFRhYmxlID0gJzx0YWJsZSBoaWRkZW4gaWQ9XCInLFxuICAgICAgc3RhcnRTZWdtZW50VGFibGUyID0gJ1wiPicsXG4gICAgICBlbmRTZWdtZW50VGFibGUgPSBcIjwvdGFibGU+XCIsXG4gICAgICBzdGFydFNlZ21lbnRUYWJsZUJvZHkgPSAnPHRhYmxlIGhpZGRlbj48dGJvZHkgaWQ9XCInLFxuICAgICAgc3RhcnRTZWdtZW50VGFibGVCb2R5MiA9ICdcIj4nLFxuICAgICAgZW5kU2VnbWVudFRhYmxlQm9keSA9IFwiPC90Ym9keT48L3RhYmxlPlwiLFxuICAgICAgc3RhcnRTZWdtZW50VGFibGVSb3cgPSAnPHRhYmxlIGhpZGRlbj48dHIgaWQ9XCInLFxuICAgICAgc3RhcnRTZWdtZW50VGFibGVSb3cyID0gJ1wiPicsXG4gICAgICBlbmRTZWdtZW50VGFibGVSb3cgPSBcIjwvdHI+PC90YWJsZT5cIixcbiAgICAgIHN0YXJ0U2VnbWVudENvbEdyb3VwID0gJzx0YWJsZSBoaWRkZW4+PGNvbGdyb3VwIGlkPVwiJyxcbiAgICAgIHN0YXJ0U2VnbWVudENvbEdyb3VwMiA9ICdcIj4nLFxuICAgICAgZW5kU2VnbWVudENvbEdyb3VwID0gXCI8L2NvbGdyb3VwPjwvdGFibGU+XCIsXG4gICAgICBjb21wbGV0ZVNlZ21lbnRTY3JpcHQxRnVsbCA9XG4gICAgICAgICckUlM9ZnVuY3Rpb24oYSxiKXthPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGEpO2I9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYik7Zm9yKGEucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChhKTthLmZpcnN0Q2hpbGQ7KWIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYS5maXJzdENoaWxkLGIpO2IucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChiKX07JFJTKFwiJyxcbiAgICAgIGNvbXBsZXRlU2VnbWVudFNjcmlwdDFQYXJ0aWFsID0gJyRSUyhcIicsXG4gICAgICBjb21wbGV0ZVNlZ21lbnRTY3JpcHQyID0gJ1wiLFwiJyxcbiAgICAgIGNvbXBsZXRlU2VnbWVudFNjcmlwdEVuZCA9ICdcIilcXHgzYy9zY3JpcHQ+JyxcbiAgICAgIGNvbXBsZXRlQm91bmRhcnlTY3JpcHQxRnVsbCA9XG4gICAgICAgICckUkM9ZnVuY3Rpb24oYixjLGUpe2M9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYyk7Yy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGMpO3ZhciBhPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGIpO2lmKGEpe2I9YS5wcmV2aW91c1NpYmxpbmc7aWYoZSliLmRhdGE9XCIkIVwiLGEuc2V0QXR0cmlidXRlKFwiZGF0YS1kZ3N0XCIsZSk7ZWxzZXtlPWIucGFyZW50Tm9kZTthPWIubmV4dFNpYmxpbmc7dmFyIGY9MDtkb3tpZihhJiY4PT09YS5ub2RlVHlwZSl7dmFyIGQ9YS5kYXRhO2lmKFwiLyRcIj09PWQpaWYoMD09PWYpYnJlYWs7ZWxzZSBmLS07ZWxzZVwiJFwiIT09ZCYmXCIkP1wiIT09ZCYmXCIkIVwiIT09ZHx8ZisrfWQ9YS5uZXh0U2libGluZztlLnJlbW92ZUNoaWxkKGEpO2E9ZH13aGlsZShhKTtmb3IoO2MuZmlyc3RDaGlsZDspZS5pbnNlcnRCZWZvcmUoYy5maXJzdENoaWxkLGEpO2IuZGF0YT1cIiRcIn1iLl9yZWFjdFJldHJ5JiZiLl9yZWFjdFJldHJ5KCl9fTskUkMoXCInLFxuICAgICAgY29tcGxldGVCb3VuZGFyeVNjcmlwdDFQYXJ0aWFsID0gJyRSQyhcIicsXG4gICAgICBjb21wbGV0ZUJvdW5kYXJ5V2l0aFN0eWxlc1NjcmlwdDFGdWxsQm90aCA9XG4gICAgICAgICckUkM9ZnVuY3Rpb24oYixjLGUpe2M9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYyk7Yy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGMpO3ZhciBhPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGIpO2lmKGEpe2I9YS5wcmV2aW91c1NpYmxpbmc7aWYoZSliLmRhdGE9XCIkIVwiLGEuc2V0QXR0cmlidXRlKFwiZGF0YS1kZ3N0XCIsZSk7ZWxzZXtlPWIucGFyZW50Tm9kZTthPWIubmV4dFNpYmxpbmc7dmFyIGY9MDtkb3tpZihhJiY4PT09YS5ub2RlVHlwZSl7dmFyIGQ9YS5kYXRhO2lmKFwiLyRcIj09PWQpaWYoMD09PWYpYnJlYWs7ZWxzZSBmLS07ZWxzZVwiJFwiIT09ZCYmXCIkP1wiIT09ZCYmXCIkIVwiIT09ZHx8ZisrfWQ9YS5uZXh0U2libGluZztlLnJlbW92ZUNoaWxkKGEpO2E9ZH13aGlsZShhKTtmb3IoO2MuZmlyc3RDaGlsZDspZS5pbnNlcnRCZWZvcmUoYy5maXJzdENoaWxkLGEpO2IuZGF0YT1cIiRcIn1iLl9yZWFjdFJldHJ5JiZiLl9yZWFjdFJldHJ5KCl9fTskUk09bmV3IE1hcDtcXG4kUlI9ZnVuY3Rpb24odCx1LHkpe2Z1bmN0aW9uIHYobil7dGhpcy5fcD1udWxsO24oKX1mb3IodmFyIHc9JFJDLHA9JFJNLHE9bmV3IE1hcCxyPWRvY3VtZW50LGcsYixoPXIucXVlcnlTZWxlY3RvckFsbChcImxpbmtbZGF0YS1wcmVjZWRlbmNlXSxzdHlsZVtkYXRhLXByZWNlZGVuY2VdXCIpLHg9W10saz0wO2I9aFtrKytdOylcIm5vdCBhbGxcIj09PWIuZ2V0QXR0cmlidXRlKFwibWVkaWFcIik/eC5wdXNoKGIpOihcIkxJTktcIj09PWIudGFnTmFtZSYmcC5zZXQoYi5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpLGIpLHEuc2V0KGIuZGF0YXNldC5wcmVjZWRlbmNlLGc9YikpO2I9MDtoPVtdO3ZhciBsLGE7Zm9yKGs9ITA7Oyl7aWYoayl7dmFyIGU9eVtiKytdO2lmKCFlKXtrPSExO2I9MDtjb250aW51ZX12YXIgYz0hMSxtPTA7dmFyIGQ9ZVttKytdO2lmKGE9cC5nZXQoZCkpe3ZhciBmPWEuX3A7Yz0hMH1lbHNle2E9ci5jcmVhdGVFbGVtZW50KFwibGlua1wiKTthLmhyZWY9XFxuZDthLnJlbD1cInN0eWxlc2hlZXRcIjtmb3IoYS5kYXRhc2V0LnByZWNlZGVuY2U9bD1lW20rK107Zj1lW20rK107KWEuc2V0QXR0cmlidXRlKGYsZVttKytdKTtmPWEuX3A9bmV3IFByb21pc2UoZnVuY3Rpb24obix6KXthLm9ubG9hZD12LmJpbmQoYSxuKTthLm9uZXJyb3I9di5iaW5kKGEseil9KTtwLnNldChkLGEpfWQ9YS5nZXRBdHRyaWJ1dGUoXCJtZWRpYVwiKTshZnx8ZCYmIW1hdGNoTWVkaWEoZCkubWF0Y2hlc3x8aC5wdXNoKGYpO2lmKGMpY29udGludWV9ZWxzZXthPXhbYisrXTtpZighYSlicmVhaztsPWEuZ2V0QXR0cmlidXRlKFwiZGF0YS1wcmVjZWRlbmNlXCIpO2EucmVtb3ZlQXR0cmlidXRlKFwibWVkaWFcIil9Yz1xLmdldChsKXx8ZztjPT09ZyYmKGc9YSk7cS5zZXQobCxhKTtjP2MucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYSxjLm5leHRTaWJsaW5nKTooYz1yLmhlYWQsYy5pbnNlcnRCZWZvcmUoYSxjLmZpcnN0Q2hpbGQpKX1Qcm9taXNlLmFsbChoKS50aGVuKHcuYmluZChudWxsLFxcbnQsdSxcIlwiKSx3LmJpbmQobnVsbCx0LHUsXCJSZXNvdXJjZSBmYWlsZWQgdG8gbG9hZFwiKSl9OyRSUihcIicsXG4gICAgICBjb21wbGV0ZUJvdW5kYXJ5V2l0aFN0eWxlc1NjcmlwdDFGdWxsUGFydGlhbCA9XG4gICAgICAgICckUk09bmV3IE1hcDtcXG4kUlI9ZnVuY3Rpb24odCx1LHkpe2Z1bmN0aW9uIHYobil7dGhpcy5fcD1udWxsO24oKX1mb3IodmFyIHc9JFJDLHA9JFJNLHE9bmV3IE1hcCxyPWRvY3VtZW50LGcsYixoPXIucXVlcnlTZWxlY3RvckFsbChcImxpbmtbZGF0YS1wcmVjZWRlbmNlXSxzdHlsZVtkYXRhLXByZWNlZGVuY2VdXCIpLHg9W10saz0wO2I9aFtrKytdOylcIm5vdCBhbGxcIj09PWIuZ2V0QXR0cmlidXRlKFwibWVkaWFcIik/eC5wdXNoKGIpOihcIkxJTktcIj09PWIudGFnTmFtZSYmcC5zZXQoYi5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpLGIpLHEuc2V0KGIuZGF0YXNldC5wcmVjZWRlbmNlLGc9YikpO2I9MDtoPVtdO3ZhciBsLGE7Zm9yKGs9ITA7Oyl7aWYoayl7dmFyIGU9eVtiKytdO2lmKCFlKXtrPSExO2I9MDtjb250aW51ZX12YXIgYz0hMSxtPTA7dmFyIGQ9ZVttKytdO2lmKGE9cC5nZXQoZCkpe3ZhciBmPWEuX3A7Yz0hMH1lbHNle2E9ci5jcmVhdGVFbGVtZW50KFwibGlua1wiKTthLmhyZWY9XFxuZDthLnJlbD1cInN0eWxlc2hlZXRcIjtmb3IoYS5kYXRhc2V0LnByZWNlZGVuY2U9bD1lW20rK107Zj1lW20rK107KWEuc2V0QXR0cmlidXRlKGYsZVttKytdKTtmPWEuX3A9bmV3IFByb21pc2UoZnVuY3Rpb24obix6KXthLm9ubG9hZD12LmJpbmQoYSxuKTthLm9uZXJyb3I9di5iaW5kKGEseil9KTtwLnNldChkLGEpfWQ9YS5nZXRBdHRyaWJ1dGUoXCJtZWRpYVwiKTshZnx8ZCYmIW1hdGNoTWVkaWEoZCkubWF0Y2hlc3x8aC5wdXNoKGYpO2lmKGMpY29udGludWV9ZWxzZXthPXhbYisrXTtpZighYSlicmVhaztsPWEuZ2V0QXR0cmlidXRlKFwiZGF0YS1wcmVjZWRlbmNlXCIpO2EucmVtb3ZlQXR0cmlidXRlKFwibWVkaWFcIil9Yz1xLmdldChsKXx8ZztjPT09ZyYmKGc9YSk7cS5zZXQobCxhKTtjP2MucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYSxjLm5leHRTaWJsaW5nKTooYz1yLmhlYWQsYy5pbnNlcnRCZWZvcmUoYSxjLmZpcnN0Q2hpbGQpKX1Qcm9taXNlLmFsbChoKS50aGVuKHcuYmluZChudWxsLFxcbnQsdSxcIlwiKSx3LmJpbmQobnVsbCx0LHUsXCJSZXNvdXJjZSBmYWlsZWQgdG8gbG9hZFwiKSl9OyRSUihcIicsXG4gICAgICBjb21wbGV0ZUJvdW5kYXJ5V2l0aFN0eWxlc1NjcmlwdDFQYXJ0aWFsID0gJyRSUihcIicsXG4gICAgICBjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0MiA9ICdcIixcIicsXG4gICAgICBjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0M2EgPSAnXCIsJyxcbiAgICAgIGNvbXBsZXRlQm91bmRhcnlTY3JpcHQzYiA9ICdcIicsXG4gICAgICBjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0RW5kID0gXCIpXFx4M2Mvc2NyaXB0PlwiLFxuICAgICAgY2xpZW50UmVuZGVyU2NyaXB0MUZ1bGwgPVxuICAgICAgICAnJFJYPWZ1bmN0aW9uKGIsYyxkLGUsZil7dmFyIGE9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYik7YSYmKGI9YS5wcmV2aW91c1NpYmxpbmcsYi5kYXRhPVwiJCFcIixhPWEuZGF0YXNldCxjJiYoYS5kZ3N0PWMpLGQmJihhLm1zZz1kKSxlJiYoYS5zdGNrPWUpLGYmJihhLmNzdGNrPWYpLGIuX3JlYWN0UmV0cnkmJmIuX3JlYWN0UmV0cnkoKSl9OzskUlgoXCInLFxuICAgICAgY2xpZW50UmVuZGVyU2NyaXB0MVBhcnRpYWwgPSAnJFJYKFwiJyxcbiAgICAgIGNsaWVudFJlbmRlclNjcmlwdDFBID0gJ1wiJyxcbiAgICAgIGNsaWVudFJlbmRlckVycm9yU2NyaXB0QXJnSW50ZXJzdGl0aWFsID0gXCIsXCIsXG4gICAgICBjbGllbnRSZW5kZXJTY3JpcHRFbmQgPSBcIilcXHgzYy9zY3JpcHQ+XCIsXG4gICAgICByZWdleEZvckpTU3RyaW5nc0luSW5zdHJ1Y3Rpb25TY3JpcHRzID0gL1s8XFx1MjAyOFxcdTIwMjldL2csXG4gICAgICByZWdleEZvckpTU3RyaW5nc0luU2NyaXB0cyA9IC9bJj48XFx1MjAyOFxcdTIwMjldL2csXG4gICAgICBsYXRlU3R5bGVUYWdSZXNvdXJjZU9wZW4xID0gJzxzdHlsZSBtZWRpYT1cIm5vdCBhbGxcIiBkYXRhLXByZWNlZGVuY2U9XCInLFxuICAgICAgbGF0ZVN0eWxlVGFnUmVzb3VyY2VPcGVuMiA9ICdcIiBkYXRhLWhyZWY9XCInLFxuICAgICAgbGF0ZVN0eWxlVGFnUmVzb3VyY2VPcGVuMyA9ICdcIj4nLFxuICAgICAgbGF0ZVN0eWxlVGFnVGVtcGxhdGVDbG9zZSA9IFwiPC9zdHlsZT5cIixcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0JvdW5kYXJ5SGFzU3R5bGVzVG9Ib2lzdCA9ICExLFxuICAgICAgZGVzdGluYXRpb25IYXNDYXBhY2l0eSA9ICEwLFxuICAgICAgc3R5bGVzaGVldEZsdXNoaW5nUXVldWUgPSBbXSxcbiAgICAgIHN0eWxlVGFnUmVzb3VyY2VPcGVuMSA9ICc8c3R5bGUgZGF0YS1wcmVjZWRlbmNlPVwiJyxcbiAgICAgIHN0eWxlVGFnUmVzb3VyY2VPcGVuMiA9ICdcIiBkYXRhLWhyZWY9XCInLFxuICAgICAgc3BhY2VTZXBhcmF0b3IgPSBcIiBcIixcbiAgICAgIHN0eWxlVGFnUmVzb3VyY2VPcGVuMyA9ICdcIj4nLFxuICAgICAgc3R5bGVUYWdSZXNvdXJjZUNsb3NlID0gXCI8L3N0eWxlPlwiLFxuICAgICAgYXJyYXlGaXJzdE9wZW5CcmFja2V0ID0gXCJbXCIsXG4gICAgICBhcnJheVN1YnNlcXVlbnRPcGVuQnJhY2tldCA9IFwiLFtcIixcbiAgICAgIGFycmF5SW50ZXJzdGl0aWFsID0gXCIsXCIsXG4gICAgICBhcnJheUNsb3NlQnJhY2tldCA9IFwiXVwiLFxuICAgICAgUEVORElORyQxID0gMCxcbiAgICAgIFBSRUxPQURFRCA9IDEsXG4gICAgICBQUkVBTUJMRSA9IDIsXG4gICAgICBMQVRFID0gMyxcbiAgICAgIHJlZ2V4Rm9ySHJlZkluTGlua0hlYWRlclVSTENvbnRleHQgPSAvWzw+XFxyXFxuXS9nLFxuICAgICAgcmVnZXhGb3JMaW5rSGVhZGVyUXVvdGVkUGFyYW1WYWx1ZUNvbnRleHQgPSAvW1wiJzssXFxyXFxuXS9nLFxuICAgICAgZG9jdHlwZUNodW5rID0gXCJcIixcbiAgICAgIGJpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCxcbiAgICAgIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UgPSBTeW1ib2wuZm9yKFwicmVhY3QuY2xpZW50LnJlZmVyZW5jZVwiKSxcbiAgICAgIGVtcHR5Q29udGV4dE9iamVjdCA9IHt9O1xuICAgIE9iamVjdC5mcmVlemUoZW1wdHlDb250ZXh0T2JqZWN0KTtcbiAgICB2YXIgcmVuZGVyZXJTaWdpbCA9IHt9O1xuICAgIHZhciBjdXJyZW50QWN0aXZlU25hcHNob3QgPSBudWxsLFxuICAgICAgZGlkV2FybkFib3V0Tm9vcFVwZGF0ZUZvckNvbXBvbmVudCA9IHt9LFxuICAgICAgZGlkV2FybkFib3V0RGVwcmVjYXRlZFdpbGxNb3VudCA9IHt9O1xuICAgIHZhciBkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZSA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZSA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZSA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2FybkFib3V0Q29udGV4dFR5cGVzJDEgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5BYm91dENoaWxkQ29udGV4dFR5cGVzID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5PbkludmFsaWRDYWxsYmFjayA9IG5ldyBTZXQoKTtcbiAgICB2YXIgY2xhc3NDb21wb25lbnRVcGRhdGVyID0ge1xuICAgICAgICBpc01vdW50ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIH0sXG4gICAgICAgIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKGluc3QsIHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIGludGVybmFscyA9IGluc3QuX3JlYWN0SW50ZXJuYWxzO1xuICAgICAgICAgIG51bGwgPT09IGludGVybmFscy5xdWV1ZVxuICAgICAgICAgICAgPyB3YXJuTm9vcChpbnN0LCBcInNldFN0YXRlXCIpXG4gICAgICAgICAgICA6IChpbnRlcm5hbHMucXVldWUucHVzaChwYXlsb2FkKSxcbiAgICAgICAgICAgICAgdm9pZCAwICE9PSBjYWxsYmFjayAmJlxuICAgICAgICAgICAgICAgIG51bGwgIT09IGNhbGxiYWNrICYmXG4gICAgICAgICAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChpbnN0LCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgICAgICAgIGluc3QgPSBpbnN0Ll9yZWFjdEludGVybmFscztcbiAgICAgICAgICBpbnN0LnJlcGxhY2UgPSAhMDtcbiAgICAgICAgICBpbnN0LnF1ZXVlID0gW3BheWxvYWRdO1xuICAgICAgICAgIHZvaWQgMCAhPT0gY2FsbGJhY2sgJiZcbiAgICAgICAgICAgIG51bGwgIT09IGNhbGxiYWNrICYmXG4gICAgICAgICAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2spO1xuICAgICAgICB9LFxuICAgICAgICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChpbnN0LCBjYWxsYmFjaykge1xuICAgICAgICAgIG51bGwgPT09IGluc3QuX3JlYWN0SW50ZXJuYWxzLnF1ZXVlXG4gICAgICAgICAgICA/IHdhcm5Ob29wKGluc3QsIFwiZm9yY2VVcGRhdGVcIilcbiAgICAgICAgICAgIDogdm9pZCAwICE9PSBjYWxsYmFjayAmJlxuICAgICAgICAgICAgICBudWxsICE9PSBjYWxsYmFjayAmJlxuICAgICAgICAgICAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZW1wdHlUcmVlQ29udGV4dCA9IHsgaWQ6IDEsIG92ZXJmbG93OiBcIlwiIH0sXG4gICAgICBjbHozMiA9IE1hdGguY2x6MzIgPyBNYXRoLmNsejMyIDogY2x6MzJGYWxsYmFjayxcbiAgICAgIGxvZyA9IE1hdGgubG9nLFxuICAgICAgTE4yID0gTWF0aC5MTjIsXG4gICAgICBTdXNwZW5zZUV4Y2VwdGlvbiA9IEVycm9yKFxuICAgICAgICBcIlN1c3BlbnNlIEV4Y2VwdGlvbjogVGhpcyBpcyBub3QgYSByZWFsIGVycm9yISBJdCdzIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbCBvZiBgdXNlYCB0byBpbnRlcnJ1cHQgdGhlIGN1cnJlbnQgcmVuZGVyLiBZb3UgbXVzdCBlaXRoZXIgcmV0aHJvdyBpdCBpbW1lZGlhdGVseSwgb3IgbW92ZSB0aGUgYHVzZWAgY2FsbCBvdXRzaWRlIG9mIHRoZSBgdHJ5L2NhdGNoYCBibG9jay4gQ2FwdHVyaW5nIHdpdGhvdXQgcmV0aHJvd2luZyB3aWxsIGxlYWQgdG8gdW5leHBlY3RlZCBiZWhhdmlvci5cXG5cXG5UbyBoYW5kbGUgYXN5bmMgZXJyb3JzLCB3cmFwIHlvdXIgY29tcG9uZW50IGluIGFuIGVycm9yIGJvdW5kYXJ5LCBvciBjYWxsIHRoZSBwcm9taXNlJ3MgYC5jYXRjaGAgbWV0aG9kIGFuZCBwYXNzIHRoZSByZXN1bHQgdG8gYHVzZWAuXCJcbiAgICAgICksXG4gICAgICBzdXNwZW5kZWRUaGVuYWJsZSA9IG51bGwsXG4gICAgICBvYmplY3RJcyA9IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIE9iamVjdC5pcyA/IE9iamVjdC5pcyA6IGlzLFxuICAgICAgY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50ID0gbnVsbCxcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ1Rhc2sgPSBudWxsLFxuICAgICAgY3VycmVudGx5UmVuZGVyaW5nUmVxdWVzdCA9IG51bGwsXG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdLZXlQYXRoID0gbnVsbCxcbiAgICAgIGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbCxcbiAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGwsXG4gICAgICBpc1JlUmVuZGVyID0gITEsXG4gICAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gITEsXG4gICAgICBsb2NhbElkQ291bnRlciA9IDAsXG4gICAgICBhY3Rpb25TdGF0ZUNvdW50ZXIgPSAwLFxuICAgICAgYWN0aW9uU3RhdGVNYXRjaGluZ0luZGV4ID0gLTEsXG4gICAgICB0aGVuYWJsZUluZGV4Q291bnRlciA9IDAsXG4gICAgICB0aGVuYWJsZVN0YXRlID0gbnVsbCxcbiAgICAgIHJlbmRlclBoYXNlVXBkYXRlcyA9IG51bGwsXG4gICAgICBudW1iZXJPZlJlUmVuZGVycyA9IDAsXG4gICAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSAhMSxcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2LFxuICAgICAgSG9va3NEaXNwYXRjaGVyID0ge1xuICAgICAgICByZWFkQ29udGV4dDogcmVhZENvbnRleHQsXG4gICAgICAgIHVzZTogZnVuY3Rpb24gKHVzYWJsZSkge1xuICAgICAgICAgIGlmIChudWxsICE9PSB1c2FibGUgJiYgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHVzYWJsZSkge1xuICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHVzYWJsZS50aGVuKVxuICAgICAgICAgICAgICByZXR1cm4gdW53cmFwVGhlbmFibGUodXNhYmxlKTtcbiAgICAgICAgICAgIGlmICh1c2FibGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSlcbiAgICAgICAgICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KHVzYWJsZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJBbiB1bnN1cHBvcnRlZCB0eXBlIHdhcyBwYXNzZWQgdG8gdXNlKCk6IFwiICsgU3RyaW5nKHVzYWJsZSlcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDb250ZXh0XCI7XG4gICAgICAgICAgcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICAgICAgICAgIHJldHVybiBjb250ZXh0Ll9jdXJyZW50VmFsdWUyO1xuICAgICAgICB9LFxuICAgICAgICB1c2VNZW1vOiB1c2VNZW1vLFxuICAgICAgICB1c2VSZWR1Y2VyOiB1c2VSZWR1Y2VyLFxuICAgICAgICB1c2VSZWY6IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPSByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3NIb29rID0gY3JlYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICAgICAgdmFyIHByZXZpb3VzUmVmID0gd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgcmV0dXJuIG51bGwgPT09IHByZXZpb3VzUmVmXG4gICAgICAgICAgICA/ICgoaW5pdGlhbFZhbHVlID0geyBjdXJyZW50OiBpbml0aWFsVmFsdWUgfSksXG4gICAgICAgICAgICAgIE9iamVjdC5zZWFsKGluaXRpYWxWYWx1ZSksXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSA9IGluaXRpYWxWYWx1ZSkpXG4gICAgICAgICAgICA6IHByZXZpb3VzUmVmO1xuICAgICAgICB9LFxuICAgICAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VTdGF0ZVwiO1xuICAgICAgICAgIHJldHVybiB1c2VSZWR1Y2VyKGJhc2ljU3RhdGVSZWR1Y2VyLCBpbml0aWFsU3RhdGUpO1xuICAgICAgICB9LFxuICAgICAgICB1c2VJbnNlcnRpb25FZmZlY3Q6IG5vb3AkMSxcbiAgICAgICAgdXNlTGF5b3V0RWZmZWN0OiBub29wJDEsXG4gICAgICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgICAgICByZXR1cm4gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2s7XG4gICAgICAgICAgfSwgZGVwcyk7XG4gICAgICAgIH0sXG4gICAgICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IG5vb3AkMSxcbiAgICAgICAgdXNlRWZmZWN0OiBub29wJDEsXG4gICAgICAgIHVzZURlYnVnVmFsdWU6IG5vb3AkMSxcbiAgICAgICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgICByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gICAgICAgICAgcmV0dXJuIHZvaWQgMCAhPT0gaW5pdGlhbFZhbHVlID8gaW5pdGlhbFZhbHVlIDogdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gICAgICAgICAgcmV0dXJuIFshMSwgdW5zdXBwb3J0ZWRTdGFydFRyYW5zaXRpb25dO1xuICAgICAgICB9LFxuICAgICAgICB1c2VJZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciB0cmVlSWQgPSBjdXJyZW50bHlSZW5kZXJpbmdUYXNrLnRyZWVDb250ZXh0O1xuICAgICAgICAgIHZhciBvdmVyZmxvdyA9IHRyZWVJZC5vdmVyZmxvdztcbiAgICAgICAgICB0cmVlSWQgPSB0cmVlSWQuaWQ7XG4gICAgICAgICAgdHJlZUlkID1cbiAgICAgICAgICAgICh0cmVlSWQgJiB+KDEgPDwgKDMyIC0gY2x6MzIodHJlZUlkKSAtIDEpKSkudG9TdHJpbmcoMzIpICsgb3ZlcmZsb3c7XG4gICAgICAgICAgdmFyIHJlc3VtYWJsZVN0YXRlID0gY3VycmVudFJlc3VtYWJsZVN0YXRlO1xuICAgICAgICAgIGlmIChudWxsID09PSByZXN1bWFibGVTdGF0ZSlcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICBcIkludmFsaWQgaG9vayBjYWxsLiBIb29rcyBjYW4gb25seSBiZSBjYWxsZWQgaW5zaWRlIG9mIHRoZSBib2R5IG9mIGEgZnVuY3Rpb24gY29tcG9uZW50LlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIG92ZXJmbG93ID0gbG9jYWxJZENvdW50ZXIrKztcbiAgICAgICAgICB0cmVlSWQgPSBcIjpcIiArIHJlc3VtYWJsZVN0YXRlLmlkUHJlZml4ICsgXCJSXCIgKyB0cmVlSWQ7XG4gICAgICAgICAgMCA8IG92ZXJmbG93ICYmICh0cmVlSWQgKz0gXCJIXCIgKyBvdmVyZmxvdy50b1N0cmluZygzMikpO1xuICAgICAgICAgIHJldHVybiB0cmVlSWQgKyBcIjpcIjtcbiAgICAgICAgfSxcbiAgICAgICAgdXNlU3luY0V4dGVybmFsU3RvcmU6IGZ1bmN0aW9uIChcbiAgICAgICAgICBzdWJzY3JpYmUsXG4gICAgICAgICAgZ2V0U25hcHNob3QsXG4gICAgICAgICAgZ2V0U2VydmVyU25hcHNob3RcbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKHZvaWQgMCA9PT0gZ2V0U2VydmVyU25hcHNob3QpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgXCJNaXNzaW5nIGdldFNlcnZlclNuYXBzaG90LCB3aGljaCBpcyByZXF1aXJlZCBmb3Igc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQuIFdpbGwgcmV2ZXJ0IHRvIGNsaWVudCByZW5kZXJpbmcuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIGdldFNlcnZlclNuYXBzaG90KCk7XG4gICAgICAgIH0sXG4gICAgICAgIHVzZUNhY2hlUmVmcmVzaDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB1bnN1cHBvcnRlZFJlZnJlc2g7XG4gICAgICAgIH0sXG4gICAgICAgIHVzZU1lbW9DYWNoZTogZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgICAgICBmb3IgKHZhciBkYXRhID0gQXJyYXkoc2l6ZSksIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKVxuICAgICAgICAgICAgZGF0YVtpXSA9IFJFQUNUX01FTU9fQ0FDSEVfU0VOVElORUw7XG4gICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0sXG4gICAgICAgIHVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICAgICAgICAgIHJldHVybiBOb3RQZW5kaW5nO1xuICAgICAgICB9LFxuICAgICAgICB1c2VPcHRpbWlzdGljOiBmdW5jdGlvbiAocGFzc3Rocm91Z2gpIHtcbiAgICAgICAgICByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gICAgICAgICAgcmV0dXJuIFtwYXNzdGhyb3VnaCwgdW5zdXBwb3J0ZWRTZXRPcHRpbWlzdGljU3RhdGVdO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIEhvb2tzRGlzcGF0Y2hlci51c2VGb3JtU3RhdGUgPSB1c2VBY3Rpb25TdGF0ZTtcbiAgICBIb29rc0Rpc3BhdGNoZXIudXNlQWN0aW9uU3RhdGUgPSB1c2VBY3Rpb25TdGF0ZTtcbiAgICB2YXIgY3VycmVudFJlc3VtYWJsZVN0YXRlID0gbnVsbCxcbiAgICAgIGN1cnJlbnRUYXNrSW5ERVYgPSBudWxsLFxuICAgICAgRGVmYXVsdEFzeW5jRGlzcGF0Y2hlciA9IHtcbiAgICAgICAgZ2V0Q2FjaGVGb3JUeXBlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWQuXCIpO1xuICAgICAgICB9LFxuICAgICAgICBnZXRPd25lcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBudWxsID09PSBjdXJyZW50VGFza0luREVWXG4gICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgIDogY3VycmVudFRhc2tJbkRFVi5jb21wb25lbnRTdGFjaztcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRpc2FibGVkRGVwdGggPSAwLFxuICAgICAgcHJldkxvZyxcbiAgICAgIHByZXZJbmZvLFxuICAgICAgcHJldldhcm4sXG4gICAgICBwcmV2RXJyb3IsXG4gICAgICBwcmV2R3JvdXAsXG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQsXG4gICAgICBwcmV2R3JvdXBFbmQ7XG4gICAgZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gITA7XG4gICAgdmFyIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIHJlZW50cnkgPSAhMTtcbiAgICB2YXIgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyAoXG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBXZWFrTWFwID8gV2Vha01hcCA6IE1hcFxuICAgICkoKTtcbiAgICB2YXIgY2FsbENvbXBvbmVudCA9IHtcbiAgICAgICAgXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIjogZnVuY3Rpb24gKENvbXBvbmVudCwgcHJvcHMsIHNlY29uZEFyZykge1xuICAgICAgICAgIHJldHVybiBDb21wb25lbnQocHJvcHMsIHNlY29uZEFyZyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjYWxsQ29tcG9uZW50SW5ERVYgPVxuICAgICAgICBjYWxsQ29tcG9uZW50W1wicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCJdLmJpbmQoY2FsbENvbXBvbmVudCksXG4gICAgICBjYWxsUmVuZGVyID0ge1xuICAgICAgICBcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiOiBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICAgICAgICByZXR1cm4gaW5zdGFuY2UucmVuZGVyKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjYWxsUmVuZGVySW5ERVYgPSBjYWxsUmVuZGVyW1wicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCJdLmJpbmQoY2FsbFJlbmRlciksXG4gICAgICBjYWxsTGF6eUluaXQgPSB7XG4gICAgICAgIFwicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCI6IGZ1bmN0aW9uIChsYXp5KSB7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Ll9pbml0O1xuICAgICAgICAgIHJldHVybiBpbml0KGxhenkuX3BheWxvYWQpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2FsbExhenlJbml0SW5ERVYgPVxuICAgICAgICBjYWxsTGF6eUluaXRbXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIl0uYmluZChjYWxsTGF6eUluaXQpLFxuICAgICAgQ0xJRU5UX1JFTkRFUkVEID0gNCxcbiAgICAgIFBFTkRJTkcgPSAwLFxuICAgICAgQ09NUExFVEVEID0gMSxcbiAgICAgIEZMVVNIRUQgPSAyLFxuICAgICAgUE9TVFBPTkVEID0gNSxcbiAgICAgIENMT1NFRCA9IDE0LFxuICAgICAgY3VycmVudFJlcXVlc3QgPSBudWxsLFxuICAgICAgZGlkV2FybkFib3V0QmFkQ2xhc3MgPSB7fSxcbiAgICAgIGRpZFdhcm5BYm91dENvbnRleHRUeXBlcyA9IHt9LFxuICAgICAgZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50ID0ge30sXG4gICAgICBkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50ID0ge30sXG4gICAgICBkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzID0gITEsXG4gICAgICBkaWRXYXJuQWJvdXRHZW5lcmF0b3JzID0gITEsXG4gICAgICBkaWRXYXJuQWJvdXRNYXBzID0gITE7XG4gICAgZXhwb3J0cy5yZW5kZXJUb1N0YXRpY01hcmt1cCA9IGZ1bmN0aW9uIChjaGlsZHJlbiwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHJlbmRlclRvU3RyaW5nSW1wbChcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgICEwLFxuICAgICAgICAnVGhlIHNlcnZlciB1c2VkIFwicmVuZGVyVG9TdGF0aWNNYXJrdXBcIiB3aGljaCBkb2VzIG5vdCBzdXBwb3J0IFN1c3BlbnNlLiBJZiB5b3UgaW50ZW5kZWQgdG8gaGF2ZSB0aGUgc2VydmVyIHdhaXQgZm9yIHRoZSBzdXNwZW5kZWQgY29tcG9uZW50IHBsZWFzZSBzd2l0Y2ggdG8gXCJyZW5kZXJUb1JlYWRhYmxlU3RyZWFtXCIgd2hpY2ggc3VwcG9ydHMgU3VzcGVuc2Ugb24gdGhlIHNlcnZlcidcbiAgICAgICk7XG4gICAgfTtcbiAgICBleHBvcnRzLnJlbmRlclRvU3RyaW5nID0gZnVuY3Rpb24gKGNoaWxkcmVuLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gcmVuZGVyVG9TdHJpbmdJbXBsKFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgITEsXG4gICAgICAgICdUaGUgc2VydmVyIHVzZWQgXCJyZW5kZXJUb1N0cmluZ1wiIHdoaWNoIGRvZXMgbm90IHN1cHBvcnQgU3VzcGVuc2UuIElmIHlvdSBpbnRlbmRlZCBmb3IgdGhpcyBTdXNwZW5zZSBib3VuZGFyeSB0byByZW5kZXIgdGhlIGZhbGxiYWNrIGNvbnRlbnQgb24gdGhlIHNlcnZlciBjb25zaWRlciB0aHJvd2luZyBhbiBFcnJvciBzb21ld2hlcmUgd2l0aGluIHRoZSBTdXNwZW5zZSBib3VuZGFyeS4gSWYgeW91IGludGVuZGVkIHRvIGhhdmUgdGhlIHNlcnZlciB3YWl0IGZvciB0aGUgc3VzcGVuZGVkIGNvbXBvbmVudCBwbGVhc2Ugc3dpdGNoIHRvIFwicmVuZGVyVG9SZWFkYWJsZVN0cmVhbVwiIHdoaWNoIHN1cHBvcnRzIFN1c3BlbnNlIG9uIHRoZSBzZXJ2ZXInXG4gICAgICApO1xuICAgIH07XG4gICAgZXhwb3J0cy52ZXJzaW9uID0gXCIxOS4wLjAtcmMtNjVlMDZjYjctMjAyNDEyMThcIjtcbiAgfSkoKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/cjs/react-dom-server-legacy.browser.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/cjs/react-dom-server.browser.development.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react-dom/cjs/react-dom-server.browser.development.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-dom-server.browser.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/*\n\n\n JS Implementation of MurmurHash3 (r136) (as of May 20, 2011)\n\n Copyright (c) 2011 Gary Court\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n SOFTWARE.\n*/\n\n true &&\n  (function () {\n    function styleReplacer(match, prefix, s, suffix) {\n      return \"\" + prefix + (\"s\" === s ? \"\\\\73 \" : \"\\\\53 \") + suffix;\n    }\n    function scriptReplacer(match, prefix, s, suffix) {\n      return \"\" + prefix + (\"s\" === s ? \"\\\\u0073\" : \"\\\\u0053\") + suffix;\n    }\n    function objectName(object) {\n      return Object.prototype.toString\n        .call(object)\n        .replace(/^\\[object (.*)\\]$/, function (m, p0) {\n          return p0;\n        });\n    }\n    function describeKeyForErrorMessage(key) {\n      var encodedKey = JSON.stringify(key);\n      return '\"' + key + '\"' === encodedKey ? key : encodedKey;\n    }\n    function describeValueForErrorMessage(value) {\n      switch (typeof value) {\n        case \"string\":\n          return JSON.stringify(\n            10 >= value.length ? value : value.slice(0, 10) + \"...\"\n          );\n        case \"object\":\n          if (isArrayImpl(value)) return \"[...]\";\n          if (null !== value && value.$$typeof === CLIENT_REFERENCE_TAG)\n            return \"client\";\n          value = objectName(value);\n          return \"Object\" === value ? \"{...}\" : value;\n        case \"function\":\n          return value.$$typeof === CLIENT_REFERENCE_TAG\n            ? \"client\"\n            : (value = value.displayName || value.name)\n              ? \"function \" + value\n              : \"function\";\n        default:\n          return String(value);\n      }\n    }\n    function describeElementType(type) {\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n      }\n      if (\"object\" === typeof type)\n        switch (type.$$typeof) {\n          case REACT_FORWARD_REF_TYPE:\n            return describeElementType(type.render);\n          case REACT_MEMO_TYPE:\n            return describeElementType(type.type);\n          case REACT_LAZY_TYPE:\n            var payload = type._payload;\n            type = type._init;\n            try {\n              return describeElementType(type(payload));\n            } catch (x) {}\n        }\n      return \"\";\n    }\n    function describeObjectForErrorMessage(objectOrArray, expandedName) {\n      var objKind = objectName(objectOrArray);\n      if (\"Object\" !== objKind && \"Array\" !== objKind) return objKind;\n      var start = -1,\n        length = 0;\n      if (isArrayImpl(objectOrArray))\n        if (jsxChildrenParents.has(objectOrArray)) {\n          var type = jsxChildrenParents.get(objectOrArray);\n          objKind = \"<\" + describeElementType(type) + \">\";\n          for (var i = 0; i < objectOrArray.length; i++) {\n            var value = objectOrArray[i];\n            value =\n              \"string\" === typeof value\n                ? value\n                : \"object\" === typeof value && null !== value\n                  ? \"{\" + describeObjectForErrorMessage(value) + \"}\"\n                  : \"{\" + describeValueForErrorMessage(value) + \"}\";\n            \"\" + i === expandedName\n              ? ((start = objKind.length),\n                (length = value.length),\n                (objKind += value))\n              : (objKind =\n                  15 > value.length && 40 > objKind.length + value.length\n                    ? objKind + value\n                    : objKind + \"{...}\");\n          }\n          objKind += \"</\" + describeElementType(type) + \">\";\n        } else {\n          objKind = \"[\";\n          for (type = 0; type < objectOrArray.length; type++)\n            0 < type && (objKind += \", \"),\n              (i = objectOrArray[type]),\n              (i =\n                \"object\" === typeof i && null !== i\n                  ? describeObjectForErrorMessage(i)\n                  : describeValueForErrorMessage(i)),\n              \"\" + type === expandedName\n                ? ((start = objKind.length),\n                  (length = i.length),\n                  (objKind += i))\n                : (objKind =\n                    10 > i.length && 40 > objKind.length + i.length\n                      ? objKind + i\n                      : objKind + \"...\");\n          objKind += \"]\";\n        }\n      else if (objectOrArray.$$typeof === REACT_ELEMENT_TYPE)\n        objKind = \"<\" + describeElementType(objectOrArray.type) + \"/>\";\n      else {\n        if (objectOrArray.$$typeof === CLIENT_REFERENCE_TAG) return \"client\";\n        if (jsxPropsParents.has(objectOrArray)) {\n          objKind = jsxPropsParents.get(objectOrArray);\n          objKind = \"<\" + (describeElementType(objKind) || \"...\");\n          type = Object.keys(objectOrArray);\n          for (i = 0; i < type.length; i++) {\n            objKind += \" \";\n            value = type[i];\n            objKind += describeKeyForErrorMessage(value) + \"=\";\n            var _value2 = objectOrArray[value];\n            var _substr2 =\n              value === expandedName &&\n              \"object\" === typeof _value2 &&\n              null !== _value2\n                ? describeObjectForErrorMessage(_value2)\n                : describeValueForErrorMessage(_value2);\n            \"string\" !== typeof _value2 && (_substr2 = \"{\" + _substr2 + \"}\");\n            value === expandedName\n              ? ((start = objKind.length),\n                (length = _substr2.length),\n                (objKind += _substr2))\n              : (objKind =\n                  10 > _substr2.length && 40 > objKind.length + _substr2.length\n                    ? objKind + _substr2\n                    : objKind + \"...\");\n          }\n          objKind += \">\";\n        } else {\n          objKind = \"{\";\n          type = Object.keys(objectOrArray);\n          for (i = 0; i < type.length; i++)\n            0 < i && (objKind += \", \"),\n              (value = type[i]),\n              (objKind += describeKeyForErrorMessage(value) + \": \"),\n              (_value2 = objectOrArray[value]),\n              (_value2 =\n                \"object\" === typeof _value2 && null !== _value2\n                  ? describeObjectForErrorMessage(_value2)\n                  : describeValueForErrorMessage(_value2)),\n              value === expandedName\n                ? ((start = objKind.length),\n                  (length = _value2.length),\n                  (objKind += _value2))\n                : (objKind =\n                    10 > _value2.length && 40 > objKind.length + _value2.length\n                      ? objKind + _value2\n                      : objKind + \"...\");\n          objKind += \"}\";\n        }\n      }\n      return void 0 === expandedName\n        ? objKind\n        : -1 < start && 0 < length\n          ? ((objectOrArray = \" \".repeat(start) + \"^\".repeat(length)),\n            \"\\n  \" + objKind + \"\\n  \" + objectOrArray)\n          : \"\\n  \" + objKind;\n    }\n    function murmurhash3_32_gc(key, seed) {\n      var remainder = key.length & 3;\n      var bytes = key.length - remainder;\n      var h1 = seed;\n      for (seed = 0; seed < bytes; ) {\n        var k1 =\n          (key.charCodeAt(seed) & 255) |\n          ((key.charCodeAt(++seed) & 255) << 8) |\n          ((key.charCodeAt(++seed) & 255) << 16) |\n          ((key.charCodeAt(++seed) & 255) << 24);\n        ++seed;\n        k1 =\n          (3432918353 * (k1 & 65535) +\n            (((3432918353 * (k1 >>> 16)) & 65535) << 16)) &\n          4294967295;\n        k1 = (k1 << 15) | (k1 >>> 17);\n        k1 =\n          (461845907 * (k1 & 65535) +\n            (((461845907 * (k1 >>> 16)) & 65535) << 16)) &\n          4294967295;\n        h1 ^= k1;\n        h1 = (h1 << 13) | (h1 >>> 19);\n        h1 =\n          (5 * (h1 & 65535) + (((5 * (h1 >>> 16)) & 65535) << 16)) & 4294967295;\n        h1 = (h1 & 65535) + 27492 + ((((h1 >>> 16) + 58964) & 65535) << 16);\n      }\n      k1 = 0;\n      switch (remainder) {\n        case 3:\n          k1 ^= (key.charCodeAt(seed + 2) & 255) << 16;\n        case 2:\n          k1 ^= (key.charCodeAt(seed + 1) & 255) << 8;\n        case 1:\n          (k1 ^= key.charCodeAt(seed) & 255),\n            (k1 =\n              (3432918353 * (k1 & 65535) +\n                (((3432918353 * (k1 >>> 16)) & 65535) << 16)) &\n              4294967295),\n            (k1 = (k1 << 15) | (k1 >>> 17)),\n            (h1 ^=\n              (461845907 * (k1 & 65535) +\n                (((461845907 * (k1 >>> 16)) & 65535) << 16)) &\n              4294967295);\n      }\n      h1 ^= key.length;\n      h1 ^= h1 >>> 16;\n      h1 =\n        (2246822507 * (h1 & 65535) +\n          (((2246822507 * (h1 >>> 16)) & 65535) << 16)) &\n        4294967295;\n      h1 ^= h1 >>> 13;\n      h1 =\n        (3266489909 * (h1 & 65535) +\n          (((3266489909 * (h1 >>> 16)) & 65535) << 16)) &\n        4294967295;\n      return (h1 ^ (h1 >>> 16)) >>> 0;\n    }\n    function scheduleWork(callback) {\n      taskQueue.push(callback);\n      channel.port2.postMessage(null);\n    }\n    function handleErrorInNextTick(error) {\n      setTimeout(function () {\n        throw error;\n      });\n    }\n    function writeChunk(destination, chunk) {\n      if (0 !== chunk.byteLength)\n        if (2048 < chunk.byteLength)\n          0 < writtenBytes &&\n            (destination.enqueue(\n              new Uint8Array(currentView.buffer, 0, writtenBytes)\n            ),\n            (currentView = new Uint8Array(2048)),\n            (writtenBytes = 0)),\n            destination.enqueue(chunk);\n        else {\n          var allowableBytes = currentView.length - writtenBytes;\n          allowableBytes < chunk.byteLength &&\n            (0 === allowableBytes\n              ? destination.enqueue(currentView)\n              : (currentView.set(\n                  chunk.subarray(0, allowableBytes),\n                  writtenBytes\n                ),\n                destination.enqueue(currentView),\n                (chunk = chunk.subarray(allowableBytes))),\n            (currentView = new Uint8Array(2048)),\n            (writtenBytes = 0));\n          currentView.set(chunk, writtenBytes);\n          writtenBytes += chunk.byteLength;\n        }\n    }\n    function writeChunkAndReturn(destination, chunk) {\n      writeChunk(destination, chunk);\n      return !0;\n    }\n    function completeWriting(destination) {\n      currentView &&\n        0 < writtenBytes &&\n        (destination.enqueue(\n          new Uint8Array(currentView.buffer, 0, writtenBytes)\n        ),\n        (currentView = null),\n        (writtenBytes = 0));\n    }\n    function stringToChunk(content) {\n      return textEncoder.encode(content);\n    }\n    function stringToPrecomputedChunk(content) {\n      content = textEncoder.encode(content);\n      2048 < content.byteLength &&\n        console.error(\n          \"precomputed chunks must be smaller than the view size configured for this host. This is a bug in React.\"\n        );\n      return content;\n    }\n    function closeWithError(destination, error) {\n      \"function\" === typeof destination.error\n        ? destination.error(error)\n        : destination.close();\n    }\n    function typeName(value) {\n      return (\n        (\"function\" === typeof Symbol &&\n          Symbol.toStringTag &&\n          value[Symbol.toStringTag]) ||\n        value.constructor.name ||\n        \"Object\"\n      );\n    }\n    function willCoercionThrow(value) {\n      try {\n        return testStringCoercion(value), !1;\n      } catch (e) {\n        return !0;\n      }\n    }\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function checkAttributeStringCoercion(value, attributeName) {\n      if (willCoercionThrow(value))\n        return (\n          console.error(\n            \"The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before using it here.\",\n            attributeName,\n            typeName(value)\n          ),\n          testStringCoercion(value)\n        );\n    }\n    function checkCSSPropertyStringCoercion(value, propName) {\n      if (willCoercionThrow(value))\n        return (\n          console.error(\n            \"The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before using it here.\",\n            propName,\n            typeName(value)\n          ),\n          testStringCoercion(value)\n        );\n    }\n    function checkHtmlStringCoercion(value) {\n      if (willCoercionThrow(value))\n        return (\n          console.error(\n            \"The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before using it here.\",\n            typeName(value)\n          ),\n          testStringCoercion(value)\n        );\n    }\n    function isAttributeNameSafe(attributeName) {\n      if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))\n        return !0;\n      if (hasOwnProperty.call(illegalAttributeNameCache, attributeName))\n        return !1;\n      if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))\n        return (validatedAttributeNameCache[attributeName] = !0);\n      illegalAttributeNameCache[attributeName] = !0;\n      console.error(\"Invalid attribute name: `%s`\", attributeName);\n      return !1;\n    }\n    function checkControlledValueProps(tagName, props) {\n      hasReadOnlyValue[props.type] ||\n        props.onChange ||\n        props.onInput ||\n        props.readOnly ||\n        props.disabled ||\n        null == props.value ||\n        (\"select\" === tagName\n          ? console.error(\n              \"You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set `onChange`.\"\n            )\n          : console.error(\n              \"You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.\"\n            ));\n      props.onChange ||\n        props.readOnly ||\n        props.disabled ||\n        null == props.checked ||\n        console.error(\n          \"You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.\"\n        );\n    }\n    function validateProperty$1(tagName, name) {\n      if (\n        hasOwnProperty.call(warnedProperties$1, name) &&\n        warnedProperties$1[name]\n      )\n        return !0;\n      if (rARIACamel$1.test(name)) {\n        tagName = \"aria-\" + name.slice(4).toLowerCase();\n        tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;\n        if (null == tagName)\n          return (\n            console.error(\n              \"Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.\",\n              name\n            ),\n            (warnedProperties$1[name] = !0)\n          );\n        if (name !== tagName)\n          return (\n            console.error(\n              \"Invalid ARIA attribute `%s`. Did you mean `%s`?\",\n              name,\n              tagName\n            ),\n            (warnedProperties$1[name] = !0)\n          );\n      }\n      if (rARIA$1.test(name)) {\n        tagName = name.toLowerCase();\n        tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;\n        if (null == tagName) return (warnedProperties$1[name] = !0), !1;\n        name !== tagName &&\n          (console.error(\n            \"Unknown ARIA attribute `%s`. Did you mean `%s`?\",\n            name,\n            tagName\n          ),\n          (warnedProperties$1[name] = !0));\n      }\n      return !0;\n    }\n    function validateProperties$2(type, props) {\n      var invalidProps = [],\n        key;\n      for (key in props)\n        validateProperty$1(type, key) || invalidProps.push(key);\n      props = invalidProps\n        .map(function (prop) {\n          return \"`\" + prop + \"`\";\n        })\n        .join(\", \");\n      1 === invalidProps.length\n        ? console.error(\n            \"Invalid aria prop %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props\",\n            props,\n            type\n          )\n        : 1 < invalidProps.length &&\n          console.error(\n            \"Invalid aria props %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props\",\n            props,\n            type\n          );\n    }\n    function validateProperty(tagName, name, value, eventRegistry) {\n      if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name])\n        return !0;\n      var lowerCasedName = name.toLowerCase();\n      if (\"onfocusin\" === lowerCasedName || \"onfocusout\" === lowerCasedName)\n        return (\n          console.error(\n            \"React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.\"\n          ),\n          (warnedProperties[name] = !0)\n        );\n      if (\n        \"function\" === typeof value &&\n        ((\"form\" === tagName && \"action\" === name) ||\n          (\"input\" === tagName && \"formAction\" === name) ||\n          (\"button\" === tagName && \"formAction\" === name))\n      )\n        return !0;\n      if (null != eventRegistry) {\n        tagName = eventRegistry.possibleRegistrationNames;\n        if (eventRegistry.registrationNameDependencies.hasOwnProperty(name))\n          return !0;\n        eventRegistry = tagName.hasOwnProperty(lowerCasedName)\n          ? tagName[lowerCasedName]\n          : null;\n        if (null != eventRegistry)\n          return (\n            console.error(\n              \"Invalid event handler property `%s`. Did you mean `%s`?\",\n              name,\n              eventRegistry\n            ),\n            (warnedProperties[name] = !0)\n          );\n        if (EVENT_NAME_REGEX.test(name))\n          return (\n            console.error(\n              \"Unknown event handler property `%s`. It will be ignored.\",\n              name\n            ),\n            (warnedProperties[name] = !0)\n          );\n      } else if (EVENT_NAME_REGEX.test(name))\n        return (\n          INVALID_EVENT_NAME_REGEX.test(name) &&\n            console.error(\n              \"Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.\",\n              name\n            ),\n          (warnedProperties[name] = !0)\n        );\n      if (rARIA.test(name) || rARIACamel.test(name)) return !0;\n      if (\"innerhtml\" === lowerCasedName)\n        return (\n          console.error(\n            \"Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.\"\n          ),\n          (warnedProperties[name] = !0)\n        );\n      if (\"aria\" === lowerCasedName)\n        return (\n          console.error(\n            \"The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.\"\n          ),\n          (warnedProperties[name] = !0)\n        );\n      if (\n        \"is\" === lowerCasedName &&\n        null !== value &&\n        void 0 !== value &&\n        \"string\" !== typeof value\n      )\n        return (\n          console.error(\n            \"Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.\",\n            typeof value\n          ),\n          (warnedProperties[name] = !0)\n        );\n      if (\"number\" === typeof value && isNaN(value))\n        return (\n          console.error(\n            \"Received NaN for the `%s` attribute. If this is expected, cast the value to a string.\",\n            name\n          ),\n          (warnedProperties[name] = !0)\n        );\n      if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {\n        if (\n          ((lowerCasedName = possibleStandardNames[lowerCasedName]),\n          lowerCasedName !== name)\n        )\n          return (\n            console.error(\n              \"Invalid DOM property `%s`. Did you mean `%s`?\",\n              name,\n              lowerCasedName\n            ),\n            (warnedProperties[name] = !0)\n          );\n      } else if (name !== lowerCasedName)\n        return (\n          console.error(\n            \"React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.\",\n            name,\n            lowerCasedName\n          ),\n          (warnedProperties[name] = !0)\n        );\n      switch (name) {\n        case \"dangerouslySetInnerHTML\":\n        case \"children\":\n        case \"style\":\n        case \"suppressContentEditableWarning\":\n        case \"suppressHydrationWarning\":\n        case \"defaultValue\":\n        case \"defaultChecked\":\n        case \"innerHTML\":\n        case \"ref\":\n          return !0;\n        case \"innerText\":\n        case \"textContent\":\n          return !0;\n      }\n      switch (typeof value) {\n        case \"boolean\":\n          switch (name) {\n            case \"autoFocus\":\n            case \"checked\":\n            case \"multiple\":\n            case \"muted\":\n            case \"selected\":\n            case \"contentEditable\":\n            case \"spellCheck\":\n            case \"draggable\":\n            case \"value\":\n            case \"autoReverse\":\n            case \"externalResourcesRequired\":\n            case \"focusable\":\n            case \"preserveAlpha\":\n            case \"allowFullScreen\":\n            case \"async\":\n            case \"autoPlay\":\n            case \"controls\":\n            case \"default\":\n            case \"defer\":\n            case \"disabled\":\n            case \"disablePictureInPicture\":\n            case \"disableRemotePlayback\":\n            case \"formNoValidate\":\n            case \"hidden\":\n            case \"loop\":\n            case \"noModule\":\n            case \"noValidate\":\n            case \"open\":\n            case \"playsInline\":\n            case \"readOnly\":\n            case \"required\":\n            case \"reversed\":\n            case \"scoped\":\n            case \"seamless\":\n            case \"itemScope\":\n            case \"capture\":\n            case \"download\":\n            case \"inert\":\n              return !0;\n            default:\n              lowerCasedName = name.toLowerCase().slice(0, 5);\n              if (\"data-\" === lowerCasedName || \"aria-\" === lowerCasedName)\n                return !0;\n              value\n                ? console.error(\n                    'Received `%s` for a non-boolean attribute `%s`.\\n\\nIf you want to write it to the DOM, pass a string instead: %s=\"%s\" or %s={value.toString()}.',\n                    value,\n                    name,\n                    name,\n                    value,\n                    name\n                  )\n                : console.error(\n                    'Received `%s` for a non-boolean attribute `%s`.\\n\\nIf you want to write it to the DOM, pass a string instead: %s=\"%s\" or %s={value.toString()}.\\n\\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.',\n                    value,\n                    name,\n                    name,\n                    value,\n                    name,\n                    name,\n                    name\n                  );\n              return (warnedProperties[name] = !0);\n          }\n        case \"function\":\n        case \"symbol\":\n          return (warnedProperties[name] = !0), !1;\n        case \"string\":\n          if (\"false\" === value || \"true\" === value) {\n            switch (name) {\n              case \"checked\":\n              case \"selected\":\n              case \"multiple\":\n              case \"muted\":\n              case \"allowFullScreen\":\n              case \"async\":\n              case \"autoPlay\":\n              case \"controls\":\n              case \"default\":\n              case \"defer\":\n              case \"disabled\":\n              case \"disablePictureInPicture\":\n              case \"disableRemotePlayback\":\n              case \"formNoValidate\":\n              case \"hidden\":\n              case \"loop\":\n              case \"noModule\":\n              case \"noValidate\":\n              case \"open\":\n              case \"playsInline\":\n              case \"readOnly\":\n              case \"required\":\n              case \"reversed\":\n              case \"scoped\":\n              case \"seamless\":\n              case \"itemScope\":\n              case \"inert\":\n                break;\n              default:\n                return !0;\n            }\n            console.error(\n              \"Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?\",\n              value,\n              name,\n              \"false\" === value\n                ? \"The browser will interpret it as a truthy value.\"\n                : 'Although this works, it will not work as expected if you pass the string \"false\".',\n              name,\n              value\n            );\n            warnedProperties[name] = !0;\n          }\n      }\n      return !0;\n    }\n    function warnUnknownProperties(type, props, eventRegistry) {\n      var unknownProps = [],\n        key;\n      for (key in props)\n        validateProperty(type, key, props[key], eventRegistry) ||\n          unknownProps.push(key);\n      props = unknownProps\n        .map(function (prop) {\n          return \"`\" + prop + \"`\";\n        })\n        .join(\", \");\n      1 === unknownProps.length\n        ? console.error(\n            \"Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://react.dev/link/attribute-behavior \",\n            props,\n            type\n          )\n        : 1 < unknownProps.length &&\n          console.error(\n            \"Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://react.dev/link/attribute-behavior \",\n            props,\n            type\n          );\n    }\n    function camelize(string) {\n      return string.replace(hyphenPattern, function (_, character) {\n        return character.toUpperCase();\n      });\n    }\n    function escapeTextForBrowser(text) {\n      if (\n        \"boolean\" === typeof text ||\n        \"number\" === typeof text ||\n        \"bigint\" === typeof text\n      )\n        return \"\" + text;\n      checkHtmlStringCoercion(text);\n      text = \"\" + text;\n      var match = matchHtmlRegExp.exec(text);\n      if (match) {\n        var html = \"\",\n          index,\n          lastIndex = 0;\n        for (index = match.index; index < text.length; index++) {\n          switch (text.charCodeAt(index)) {\n            case 34:\n              match = \"&quot;\";\n              break;\n            case 38:\n              match = \"&amp;\";\n              break;\n            case 39:\n              match = \"&#x27;\";\n              break;\n            case 60:\n              match = \"&lt;\";\n              break;\n            case 62:\n              match = \"&gt;\";\n              break;\n            default:\n              continue;\n          }\n          lastIndex !== index && (html += text.slice(lastIndex, index));\n          lastIndex = index + 1;\n          html += match;\n        }\n        text = lastIndex !== index ? html + text.slice(lastIndex, index) : html;\n      }\n      return text;\n    }\n    function sanitizeURL(url) {\n      return isJavaScriptProtocol.test(\"\" + url)\n        ? \"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')\"\n        : url;\n    }\n    function escapeEntireInlineScriptContent(scriptText) {\n      checkHtmlStringCoercion(scriptText);\n      return (\"\" + scriptText).replace(scriptRegex, scriptReplacer);\n    }\n    function createRenderState(\n      resumableState,\n      nonce,\n      externalRuntimeConfig,\n      importMap,\n      onHeaders,\n      maxHeadersLength\n    ) {\n      var inlineScriptWithNonce =\n          void 0 === nonce\n            ? startInlineScript\n            : stringToPrecomputedChunk(\n                '<script nonce=\"' + escapeTextForBrowser(nonce) + '\">'\n              ),\n        idPrefix = resumableState.idPrefix;\n      externalRuntimeConfig = [];\n      var bootstrapScriptContent = resumableState.bootstrapScriptContent,\n        bootstrapScripts = resumableState.bootstrapScripts,\n        bootstrapModules = resumableState.bootstrapModules;\n      void 0 !== bootstrapScriptContent &&\n        externalRuntimeConfig.push(\n          inlineScriptWithNonce,\n          stringToChunk(\n            escapeEntireInlineScriptContent(bootstrapScriptContent)\n          ),\n          endInlineScript\n        );\n      bootstrapScriptContent = [];\n      void 0 !== importMap &&\n        (bootstrapScriptContent.push(importMapScriptStart),\n        bootstrapScriptContent.push(\n          stringToChunk(\n            escapeEntireInlineScriptContent(JSON.stringify(importMap))\n          )\n        ),\n        bootstrapScriptContent.push(importMapScriptEnd));\n      onHeaders &&\n        \"number\" === typeof maxHeadersLength &&\n        0 >= maxHeadersLength &&\n        console.error(\n          \"React expected a positive non-zero `maxHeadersLength` option but found %s instead. When using the `onHeaders` option you may supply an optional `maxHeadersLength` option as well however, when setting this value to zero or less no headers will be captured.\",\n          0 === maxHeadersLength ? \"zero\" : maxHeadersLength\n        );\n      importMap = onHeaders\n        ? {\n            preconnects: \"\",\n            fontPreloads: \"\",\n            highImagePreloads: \"\",\n            remainingCapacity:\n              2 +\n              (\"number\" === typeof maxHeadersLength ? maxHeadersLength : 2e3)\n          }\n        : null;\n      onHeaders = {\n        placeholderPrefix: stringToPrecomputedChunk(idPrefix + \"P:\"),\n        segmentPrefix: stringToPrecomputedChunk(idPrefix + \"S:\"),\n        boundaryPrefix: stringToPrecomputedChunk(idPrefix + \"B:\"),\n        startInlineScript: inlineScriptWithNonce,\n        htmlChunks: null,\n        headChunks: null,\n        externalRuntimeScript: null,\n        bootstrapChunks: externalRuntimeConfig,\n        importMapChunks: bootstrapScriptContent,\n        onHeaders: onHeaders,\n        headers: importMap,\n        resets: {\n          font: {},\n          dns: {},\n          connect: { default: {}, anonymous: {}, credentials: {} },\n          image: {},\n          style: {}\n        },\n        charsetChunks: [],\n        viewportChunks: [],\n        hoistableChunks: [],\n        preconnects: new Set(),\n        fontPreloads: new Set(),\n        highImagePreloads: new Set(),\n        styles: new Map(),\n        bootstrapScripts: new Set(),\n        scripts: new Set(),\n        bulkPreloads: new Set(),\n        preloads: {\n          images: new Map(),\n          stylesheets: new Map(),\n          scripts: new Map(),\n          moduleScripts: new Map()\n        },\n        nonce: nonce,\n        hoistableState: null,\n        stylesToHoist: !1\n      };\n      if (void 0 !== bootstrapScripts)\n        for (importMap = 0; importMap < bootstrapScripts.length; importMap++) {\n          maxHeadersLength = bootstrapScripts[importMap];\n          bootstrapScriptContent = idPrefix = void 0;\n          var props = {\n            rel: \"preload\",\n            as: \"script\",\n            fetchPriority: \"low\",\n            nonce: nonce\n          };\n          \"string\" === typeof maxHeadersLength\n            ? (props.href = inlineScriptWithNonce = maxHeadersLength)\n            : ((props.href = inlineScriptWithNonce = maxHeadersLength.src),\n              (props.integrity = bootstrapScriptContent =\n                \"string\" === typeof maxHeadersLength.integrity\n                  ? maxHeadersLength.integrity\n                  : void 0),\n              (props.crossOrigin = idPrefix =\n                \"string\" === typeof maxHeadersLength ||\n                null == maxHeadersLength.crossOrigin\n                  ? void 0\n                  : \"use-credentials\" === maxHeadersLength.crossOrigin\n                    ? \"use-credentials\"\n                    : \"\"));\n          preloadBootstrapScriptOrModule(\n            resumableState,\n            onHeaders,\n            inlineScriptWithNonce,\n            props\n          );\n          externalRuntimeConfig.push(\n            startScriptSrc,\n            stringToChunk(escapeTextForBrowser(inlineScriptWithNonce))\n          );\n          nonce &&\n            externalRuntimeConfig.push(\n              scriptNonce,\n              stringToChunk(escapeTextForBrowser(nonce))\n            );\n          \"string\" === typeof bootstrapScriptContent &&\n            externalRuntimeConfig.push(\n              scriptIntegirty,\n              stringToChunk(escapeTextForBrowser(bootstrapScriptContent))\n            );\n          \"string\" === typeof idPrefix &&\n            externalRuntimeConfig.push(\n              scriptCrossOrigin,\n              stringToChunk(escapeTextForBrowser(idPrefix))\n            );\n          externalRuntimeConfig.push(endAsyncScript);\n        }\n      if (void 0 !== bootstrapModules)\n        for (\n          bootstrapScripts = 0;\n          bootstrapScripts < bootstrapModules.length;\n          bootstrapScripts++\n        )\n          (importMap = bootstrapModules[bootstrapScripts]),\n            (idPrefix = inlineScriptWithNonce = void 0),\n            (bootstrapScriptContent = {\n              rel: \"modulepreload\",\n              fetchPriority: \"low\",\n              nonce: nonce\n            }),\n            \"string\" === typeof importMap\n              ? (bootstrapScriptContent.href = maxHeadersLength = importMap)\n              : ((bootstrapScriptContent.href = maxHeadersLength =\n                  importMap.src),\n                (bootstrapScriptContent.integrity = idPrefix =\n                  \"string\" === typeof importMap.integrity\n                    ? importMap.integrity\n                    : void 0),\n                (bootstrapScriptContent.crossOrigin = inlineScriptWithNonce =\n                  \"string\" === typeof importMap || null == importMap.crossOrigin\n                    ? void 0\n                    : \"use-credentials\" === importMap.crossOrigin\n                      ? \"use-credentials\"\n                      : \"\")),\n            preloadBootstrapScriptOrModule(\n              resumableState,\n              onHeaders,\n              maxHeadersLength,\n              bootstrapScriptContent\n            ),\n            externalRuntimeConfig.push(\n              startModuleSrc,\n              stringToChunk(escapeTextForBrowser(maxHeadersLength))\n            ),\n            nonce &&\n              externalRuntimeConfig.push(\n                scriptNonce,\n                stringToChunk(escapeTextForBrowser(nonce))\n              ),\n            \"string\" === typeof idPrefix &&\n              externalRuntimeConfig.push(\n                scriptIntegirty,\n                stringToChunk(escapeTextForBrowser(idPrefix))\n              ),\n            \"string\" === typeof inlineScriptWithNonce &&\n              externalRuntimeConfig.push(\n                scriptCrossOrigin,\n                stringToChunk(escapeTextForBrowser(inlineScriptWithNonce))\n              ),\n            externalRuntimeConfig.push(endAsyncScript);\n      return onHeaders;\n    }\n    function createResumableState(\n      identifierPrefix,\n      externalRuntimeConfig,\n      bootstrapScriptContent,\n      bootstrapScripts,\n      bootstrapModules\n    ) {\n      return {\n        idPrefix: void 0 === identifierPrefix ? \"\" : identifierPrefix,\n        nextFormID: 0,\n        streamingFormat: 0,\n        bootstrapScriptContent: bootstrapScriptContent,\n        bootstrapScripts: bootstrapScripts,\n        bootstrapModules: bootstrapModules,\n        instructions: NothingSent,\n        hasBody: !1,\n        hasHtml: !1,\n        unknownResources: {},\n        dnsResources: {},\n        connectResources: { default: {}, anonymous: {}, credentials: {} },\n        imageResources: {},\n        styleResources: {},\n        scriptResources: {},\n        moduleUnknownResources: {},\n        moduleScriptResources: {}\n      };\n    }\n    function createFormatContext(insertionMode, selectedValue, tagScope) {\n      return {\n        insertionMode: insertionMode,\n        selectedValue: selectedValue,\n        tagScope: tagScope\n      };\n    }\n    function createRootFormatContext(namespaceURI) {\n      return createFormatContext(\n        \"http://www.w3.org/2000/svg\" === namespaceURI\n          ? SVG_MODE\n          : \"http://www.w3.org/1998/Math/MathML\" === namespaceURI\n            ? MATHML_MODE\n            : ROOT_HTML_MODE,\n        null,\n        0\n      );\n    }\n    function getChildFormatContext(parentContext, type, props) {\n      switch (type) {\n        case \"noscript\":\n          return createFormatContext(\n            HTML_MODE,\n            null,\n            parentContext.tagScope | 1\n          );\n        case \"select\":\n          return createFormatContext(\n            HTML_MODE,\n            null != props.value ? props.value : props.defaultValue,\n            parentContext.tagScope\n          );\n        case \"svg\":\n          return createFormatContext(SVG_MODE, null, parentContext.tagScope);\n        case \"picture\":\n          return createFormatContext(\n            HTML_MODE,\n            null,\n            parentContext.tagScope | 2\n          );\n        case \"math\":\n          return createFormatContext(MATHML_MODE, null, parentContext.tagScope);\n        case \"foreignObject\":\n          return createFormatContext(HTML_MODE, null, parentContext.tagScope);\n        case \"table\":\n          return createFormatContext(\n            HTML_TABLE_MODE,\n            null,\n            parentContext.tagScope\n          );\n        case \"thead\":\n        case \"tbody\":\n        case \"tfoot\":\n          return createFormatContext(\n            HTML_TABLE_BODY_MODE,\n            null,\n            parentContext.tagScope\n          );\n        case \"colgroup\":\n          return createFormatContext(\n            HTML_COLGROUP_MODE,\n            null,\n            parentContext.tagScope\n          );\n        case \"tr\":\n          return createFormatContext(\n            HTML_TABLE_ROW_MODE,\n            null,\n            parentContext.tagScope\n          );\n      }\n      return parentContext.insertionMode >= HTML_TABLE_MODE\n        ? createFormatContext(HTML_MODE, null, parentContext.tagScope)\n        : parentContext.insertionMode === ROOT_HTML_MODE\n          ? \"html\" === type\n            ? createFormatContext(HTML_HTML_MODE, null, parentContext.tagScope)\n            : createFormatContext(HTML_MODE, null, parentContext.tagScope)\n          : parentContext.insertionMode === HTML_HTML_MODE\n            ? createFormatContext(HTML_MODE, null, parentContext.tagScope)\n            : parentContext;\n    }\n    function pushTextInstance(target, text, renderState, textEmbedded) {\n      if (\"\" === text) return textEmbedded;\n      textEmbedded && target.push(textSeparator);\n      target.push(stringToChunk(escapeTextForBrowser(text)));\n      return !0;\n    }\n    function pushStyleAttribute(target, style) {\n      if (\"object\" !== typeof style)\n        throw Error(\n          \"The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.\"\n        );\n      var isFirst = !0,\n        styleName;\n      for (styleName in style)\n        if (hasOwnProperty.call(style, styleName)) {\n          var styleValue = style[styleName];\n          if (\n            null != styleValue &&\n            \"boolean\" !== typeof styleValue &&\n            \"\" !== styleValue\n          ) {\n            if (0 === styleName.indexOf(\"--\")) {\n              var nameChunk = stringToChunk(escapeTextForBrowser(styleName));\n              checkCSSPropertyStringCoercion(styleValue, styleName);\n              styleValue = stringToChunk(\n                escapeTextForBrowser((\"\" + styleValue).trim())\n              );\n            } else {\n              nameChunk = styleName;\n              var value = styleValue;\n              if (-1 < nameChunk.indexOf(\"-\")) {\n                var name = nameChunk;\n                (warnedStyleNames.hasOwnProperty(name) &&\n                  warnedStyleNames[name]) ||\n                  ((warnedStyleNames[name] = !0),\n                  console.error(\n                    \"Unsupported style property %s. Did you mean %s?\",\n                    name,\n                    camelize(name.replace(msPattern$1, \"ms-\"))\n                  ));\n              } else if (badVendoredStyleNamePattern.test(nameChunk))\n                (name = nameChunk),\n                  (warnedStyleNames.hasOwnProperty(name) &&\n                    warnedStyleNames[name]) ||\n                    ((warnedStyleNames[name] = !0),\n                    console.error(\n                      \"Unsupported vendor-prefixed style property %s. Did you mean %s?\",\n                      name,\n                      name.charAt(0).toUpperCase() + name.slice(1)\n                    ));\n              else if (badStyleValueWithSemicolonPattern.test(value)) {\n                name = nameChunk;\n                var value$jscomp$0 = value;\n                (warnedStyleValues.hasOwnProperty(value$jscomp$0) &&\n                  warnedStyleValues[value$jscomp$0]) ||\n                  ((warnedStyleValues[value$jscomp$0] = !0),\n                  console.error(\n                    'Style property values shouldn\\'t contain a semicolon. Try \"%s: %s\" instead.',\n                    name,\n                    value$jscomp$0.replace(\n                      badStyleValueWithSemicolonPattern,\n                      \"\"\n                    )\n                  ));\n              }\n              \"number\" === typeof value &&\n                (isNaN(value)\n                  ? warnedForNaNValue ||\n                    ((warnedForNaNValue = !0),\n                    console.error(\n                      \"`NaN` is an invalid value for the `%s` css style property.\",\n                      nameChunk\n                    ))\n                  : isFinite(value) ||\n                    warnedForInfinityValue ||\n                    ((warnedForInfinityValue = !0),\n                    console.error(\n                      \"`Infinity` is an invalid value for the `%s` css style property.\",\n                      nameChunk\n                    )));\n              nameChunk = styleName;\n              value = styleNameCache.get(nameChunk);\n              void 0 !== value\n                ? (nameChunk = value)\n                : ((value = stringToPrecomputedChunk(\n                    escapeTextForBrowser(\n                      nameChunk\n                        .replace(uppercasePattern, \"-$1\")\n                        .toLowerCase()\n                        .replace(msPattern, \"-ms-\")\n                    )\n                  )),\n                  styleNameCache.set(nameChunk, value),\n                  (nameChunk = value));\n              \"number\" === typeof styleValue\n                ? (styleValue =\n                    0 === styleValue || unitlessNumbers.has(styleName)\n                      ? stringToChunk(\"\" + styleValue)\n                      : stringToChunk(styleValue + \"px\"))\n                : (checkCSSPropertyStringCoercion(styleValue, styleName),\n                  (styleValue = stringToChunk(\n                    escapeTextForBrowser((\"\" + styleValue).trim())\n                  )));\n            }\n            isFirst\n              ? ((isFirst = !1),\n                target.push(\n                  styleAttributeStart,\n                  nameChunk,\n                  styleAssign,\n                  styleValue\n                ))\n              : target.push(styleSeparator, nameChunk, styleAssign, styleValue);\n          }\n        }\n      isFirst || target.push(attributeEnd);\n    }\n    function pushBooleanAttribute(target, name, value) {\n      value &&\n        \"function\" !== typeof value &&\n        \"symbol\" !== typeof value &&\n        target.push(\n          attributeSeparator,\n          stringToChunk(name),\n          attributeEmptyString\n        );\n    }\n    function pushStringAttribute(target, name, value) {\n      \"function\" !== typeof value &&\n        \"symbol\" !== typeof value &&\n        \"boolean\" !== typeof value &&\n        target.push(\n          attributeSeparator,\n          stringToChunk(name),\n          attributeAssign,\n          stringToChunk(escapeTextForBrowser(value)),\n          attributeEnd\n        );\n    }\n    function pushAdditionalFormField(value, key) {\n      this.push(startHiddenInputChunk);\n      validateAdditionalFormField(value);\n      pushStringAttribute(this, \"name\", key);\n      pushStringAttribute(this, \"value\", value);\n      this.push(endOfStartTagSelfClosing);\n    }\n    function validateAdditionalFormField(value) {\n      if (\"string\" !== typeof value)\n        throw Error(\n          \"File/Blob fields are not yet supported in progressive forms. Will fallback to client hydration.\"\n        );\n    }\n    function getCustomFormFields(resumableState, formAction) {\n      if (\"function\" === typeof formAction.$$FORM_ACTION) {\n        var id = resumableState.nextFormID++;\n        resumableState = resumableState.idPrefix + id;\n        try {\n          var customFields = formAction.$$FORM_ACTION(resumableState);\n          if (customFields) {\n            var formData = customFields.data;\n            null != formData && formData.forEach(validateAdditionalFormField);\n          }\n          return customFields;\n        } catch (x) {\n          if (\n            \"object\" === typeof x &&\n            null !== x &&\n            \"function\" === typeof x.then\n          )\n            throw x;\n          console.error(\n            \"Failed to serialize an action for progressive enhancement:\\n%s\",\n            x\n          );\n        }\n      }\n      return null;\n    }\n    function pushFormActionAttribute(\n      target,\n      resumableState,\n      renderState,\n      formAction,\n      formEncType,\n      formMethod,\n      formTarget,\n      name\n    ) {\n      var formData = null;\n      if (\"function\" === typeof formAction) {\n        null === name ||\n          didWarnFormActionName ||\n          ((didWarnFormActionName = !0),\n          console.error(\n            'Cannot specify a \"name\" prop for a button that specifies a function as a formAction. React needs it to encode which action should be invoked. It will get overridden.'\n          ));\n        (null === formEncType && null === formMethod) ||\n          didWarnFormActionMethod ||\n          ((didWarnFormActionMethod = !0),\n          console.error(\n            \"Cannot specify a formEncType or formMethod for a button that specifies a function as a formAction. React provides those automatically. They will get overridden.\"\n          ));\n        null === formTarget ||\n          didWarnFormActionTarget ||\n          ((didWarnFormActionTarget = !0),\n          console.error(\n            \"Cannot specify a formTarget for a button that specifies a function as a formAction. The function will always be executed in the same window.\"\n          ));\n        var customFields = getCustomFormFields(resumableState, formAction);\n        null !== customFields\n          ? ((name = customFields.name),\n            (formAction = customFields.action || \"\"),\n            (formEncType = customFields.encType),\n            (formMethod = customFields.method),\n            (formTarget = customFields.target),\n            (formData = customFields.data))\n          : (target.push(\n              attributeSeparator,\n              stringToChunk(\"formAction\"),\n              attributeAssign,\n              actionJavaScriptURL,\n              attributeEnd\n            ),\n            (formTarget = formMethod = formEncType = formAction = name = null),\n            injectFormReplayingRuntime(resumableState, renderState));\n      }\n      null != name && pushAttribute(target, \"name\", name);\n      null != formAction && pushAttribute(target, \"formAction\", formAction);\n      null != formEncType && pushAttribute(target, \"formEncType\", formEncType);\n      null != formMethod && pushAttribute(target, \"formMethod\", formMethod);\n      null != formTarget && pushAttribute(target, \"formTarget\", formTarget);\n      return formData;\n    }\n    function pushAttribute(target, name, value) {\n      switch (name) {\n        case \"className\":\n          pushStringAttribute(target, \"class\", value);\n          break;\n        case \"tabIndex\":\n          pushStringAttribute(target, \"tabindex\", value);\n          break;\n        case \"dir\":\n        case \"role\":\n        case \"viewBox\":\n        case \"width\":\n        case \"height\":\n          pushStringAttribute(target, name, value);\n          break;\n        case \"style\":\n          pushStyleAttribute(target, value);\n          break;\n        case \"src\":\n        case \"href\":\n          if (\"\" === value) {\n            \"src\" === name\n              ? console.error(\n                  'An empty string (\"\") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',\n                  name,\n                  name\n                )\n              : console.error(\n                  'An empty string (\"\") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',\n                  name,\n                  name\n                );\n            break;\n          }\n        case \"action\":\n        case \"formAction\":\n          if (\n            null == value ||\n            \"function\" === typeof value ||\n            \"symbol\" === typeof value ||\n            \"boolean\" === typeof value\n          )\n            break;\n          checkAttributeStringCoercion(value, name);\n          value = sanitizeURL(\"\" + value);\n          target.push(\n            attributeSeparator,\n            stringToChunk(name),\n            attributeAssign,\n            stringToChunk(escapeTextForBrowser(value)),\n            attributeEnd\n          );\n          break;\n        case \"defaultValue\":\n        case \"defaultChecked\":\n        case \"innerHTML\":\n        case \"suppressContentEditableWarning\":\n        case \"suppressHydrationWarning\":\n        case \"ref\":\n          break;\n        case \"autoFocus\":\n        case \"multiple\":\n        case \"muted\":\n          pushBooleanAttribute(target, name.toLowerCase(), value);\n          break;\n        case \"xlinkHref\":\n          if (\n            \"function\" === typeof value ||\n            \"symbol\" === typeof value ||\n            \"boolean\" === typeof value\n          )\n            break;\n          checkAttributeStringCoercion(value, name);\n          value = sanitizeURL(\"\" + value);\n          target.push(\n            attributeSeparator,\n            stringToChunk(\"xlink:href\"),\n            attributeAssign,\n            stringToChunk(escapeTextForBrowser(value)),\n            attributeEnd\n          );\n          break;\n        case \"contentEditable\":\n        case \"spellCheck\":\n        case \"draggable\":\n        case \"value\":\n        case \"autoReverse\":\n        case \"externalResourcesRequired\":\n        case \"focusable\":\n        case \"preserveAlpha\":\n          \"function\" !== typeof value &&\n            \"symbol\" !== typeof value &&\n            target.push(\n              attributeSeparator,\n              stringToChunk(name),\n              attributeAssign,\n              stringToChunk(escapeTextForBrowser(value)),\n              attributeEnd\n            );\n          break;\n        case \"inert\":\n          \"\" !== value ||\n            didWarnForNewBooleanPropsWithEmptyValue[name] ||\n            ((didWarnForNewBooleanPropsWithEmptyValue[name] = !0),\n            console.error(\n              \"Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.\",\n              name\n            ));\n        case \"allowFullScreen\":\n        case \"async\":\n        case \"autoPlay\":\n        case \"controls\":\n        case \"default\":\n        case \"defer\":\n        case \"disabled\":\n        case \"disablePictureInPicture\":\n        case \"disableRemotePlayback\":\n        case \"formNoValidate\":\n        case \"hidden\":\n        case \"loop\":\n        case \"noModule\":\n        case \"noValidate\":\n        case \"open\":\n        case \"playsInline\":\n        case \"readOnly\":\n        case \"required\":\n        case \"reversed\":\n        case \"scoped\":\n        case \"seamless\":\n        case \"itemScope\":\n          value &&\n            \"function\" !== typeof value &&\n            \"symbol\" !== typeof value &&\n            target.push(\n              attributeSeparator,\n              stringToChunk(name),\n              attributeEmptyString\n            );\n          break;\n        case \"capture\":\n        case \"download\":\n          !0 === value\n            ? target.push(\n                attributeSeparator,\n                stringToChunk(name),\n                attributeEmptyString\n              )\n            : !1 !== value &&\n              \"function\" !== typeof value &&\n              \"symbol\" !== typeof value &&\n              target.push(\n                attributeSeparator,\n                stringToChunk(name),\n                attributeAssign,\n                stringToChunk(escapeTextForBrowser(value)),\n                attributeEnd\n              );\n          break;\n        case \"cols\":\n        case \"rows\":\n        case \"size\":\n        case \"span\":\n          \"function\" !== typeof value &&\n            \"symbol\" !== typeof value &&\n            !isNaN(value) &&\n            1 <= value &&\n            target.push(\n              attributeSeparator,\n              stringToChunk(name),\n              attributeAssign,\n              stringToChunk(escapeTextForBrowser(value)),\n              attributeEnd\n            );\n          break;\n        case \"rowSpan\":\n        case \"start\":\n          \"function\" === typeof value ||\n            \"symbol\" === typeof value ||\n            isNaN(value) ||\n            target.push(\n              attributeSeparator,\n              stringToChunk(name),\n              attributeAssign,\n              stringToChunk(escapeTextForBrowser(value)),\n              attributeEnd\n            );\n          break;\n        case \"xlinkActuate\":\n          pushStringAttribute(target, \"xlink:actuate\", value);\n          break;\n        case \"xlinkArcrole\":\n          pushStringAttribute(target, \"xlink:arcrole\", value);\n          break;\n        case \"xlinkRole\":\n          pushStringAttribute(target, \"xlink:role\", value);\n          break;\n        case \"xlinkShow\":\n          pushStringAttribute(target, \"xlink:show\", value);\n          break;\n        case \"xlinkTitle\":\n          pushStringAttribute(target, \"xlink:title\", value);\n          break;\n        case \"xlinkType\":\n          pushStringAttribute(target, \"xlink:type\", value);\n          break;\n        case \"xmlBase\":\n          pushStringAttribute(target, \"xml:base\", value);\n          break;\n        case \"xmlLang\":\n          pushStringAttribute(target, \"xml:lang\", value);\n          break;\n        case \"xmlSpace\":\n          pushStringAttribute(target, \"xml:space\", value);\n          break;\n        default:\n          if (\n            !(2 < name.length) ||\n            (\"o\" !== name[0] && \"O\" !== name[0]) ||\n            (\"n\" !== name[1] && \"N\" !== name[1])\n          )\n            if (\n              ((name = aliases.get(name) || name), isAttributeNameSafe(name))\n            ) {\n              switch (typeof value) {\n                case \"function\":\n                case \"symbol\":\n                  return;\n                case \"boolean\":\n                  var prefix = name.toLowerCase().slice(0, 5);\n                  if (\"data-\" !== prefix && \"aria-\" !== prefix) return;\n              }\n              target.push(\n                attributeSeparator,\n                stringToChunk(name),\n                attributeAssign,\n                stringToChunk(escapeTextForBrowser(value)),\n                attributeEnd\n              );\n            }\n      }\n    }\n    function pushInnerHTML(target, innerHTML, children) {\n      if (null != innerHTML) {\n        if (null != children)\n          throw Error(\n            \"Can only set one of `children` or `props.dangerouslySetInnerHTML`.\"\n          );\n        if (\"object\" !== typeof innerHTML || !(\"__html\" in innerHTML))\n          throw Error(\n            \"`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information.\"\n          );\n        innerHTML = innerHTML.__html;\n        null !== innerHTML &&\n          void 0 !== innerHTML &&\n          (checkHtmlStringCoercion(innerHTML),\n          target.push(stringToChunk(\"\" + innerHTML)));\n      }\n    }\n    function checkSelectProp(props, propName) {\n      var value = props[propName];\n      null != value &&\n        ((value = isArrayImpl(value)),\n        props.multiple && !value\n          ? console.error(\n              \"The `%s` prop supplied to <select> must be an array if `multiple` is true.\",\n              propName\n            )\n          : !props.multiple &&\n            value &&\n            console.error(\n              \"The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.\",\n              propName\n            ));\n    }\n    function flattenOptionChildren(children) {\n      var content = \"\";\n      React.Children.forEach(children, function (child) {\n        null != child &&\n          ((content += child),\n          didWarnInvalidOptionChildren ||\n            \"string\" === typeof child ||\n            \"number\" === typeof child ||\n            \"bigint\" === typeof child ||\n            ((didWarnInvalidOptionChildren = !0),\n            console.error(\n              \"Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.\"\n            )));\n      });\n      return content;\n    }\n    function injectFormReplayingRuntime(resumableState, renderState) {\n      (resumableState.instructions & 16) === NothingSent &&\n        ((resumableState.instructions |= 16),\n        renderState.bootstrapChunks.unshift(\n          renderState.startInlineScript,\n          formReplayingRuntimeScript,\n          endInlineScript\n        ));\n    }\n    function pushLinkImpl(target, props) {\n      target.push(startChunkForTag(\"link\"));\n      for (var propKey in props)\n        if (hasOwnProperty.call(props, propKey)) {\n          var propValue = props[propKey];\n          if (null != propValue)\n            switch (propKey) {\n              case \"children\":\n              case \"dangerouslySetInnerHTML\":\n                throw Error(\n                  \"link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.\"\n                );\n              default:\n                pushAttribute(target, propKey, propValue);\n            }\n        }\n      target.push(endOfStartTagSelfClosing);\n      return null;\n    }\n    function escapeStyleTextContent(styleText) {\n      checkHtmlStringCoercion(styleText);\n      return (\"\" + styleText).replace(styleRegex, styleReplacer);\n    }\n    function pushSelfClosing(target, props, tag) {\n      target.push(startChunkForTag(tag));\n      for (var propKey in props)\n        if (hasOwnProperty.call(props, propKey)) {\n          var propValue = props[propKey];\n          if (null != propValue)\n            switch (propKey) {\n              case \"children\":\n              case \"dangerouslySetInnerHTML\":\n                throw Error(\n                  tag +\n                    \" is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.\"\n                );\n              default:\n                pushAttribute(target, propKey, propValue);\n            }\n        }\n      target.push(endOfStartTagSelfClosing);\n      return null;\n    }\n    function pushTitleImpl(target, props) {\n      target.push(startChunkForTag(\"title\"));\n      var children = null,\n        innerHTML = null,\n        propKey;\n      for (propKey in props)\n        if (hasOwnProperty.call(props, propKey)) {\n          var propValue = props[propKey];\n          if (null != propValue)\n            switch (propKey) {\n              case \"children\":\n                children = propValue;\n                break;\n              case \"dangerouslySetInnerHTML\":\n                innerHTML = propValue;\n                break;\n              default:\n                pushAttribute(target, propKey, propValue);\n            }\n        }\n      target.push(endOfStartTag);\n      props = Array.isArray(children)\n        ? 2 > children.length\n          ? children[0]\n          : null\n        : children;\n      \"function\" !== typeof props &&\n        \"symbol\" !== typeof props &&\n        null !== props &&\n        void 0 !== props &&\n        target.push(stringToChunk(escapeTextForBrowser(\"\" + props)));\n      pushInnerHTML(target, innerHTML, children);\n      target.push(endChunkForTag(\"title\"));\n      return null;\n    }\n    function pushScriptImpl(target, props) {\n      target.push(startChunkForTag(\"script\"));\n      var children = null,\n        innerHTML = null,\n        propKey;\n      for (propKey in props)\n        if (hasOwnProperty.call(props, propKey)) {\n          var propValue = props[propKey];\n          if (null != propValue)\n            switch (propKey) {\n              case \"children\":\n                children = propValue;\n                break;\n              case \"dangerouslySetInnerHTML\":\n                innerHTML = propValue;\n                break;\n              default:\n                pushAttribute(target, propKey, propValue);\n            }\n        }\n      target.push(endOfStartTag);\n      null != children &&\n        \"string\" !== typeof children &&\n        ((props =\n          \"number\" === typeof children\n            ? \"a number for children\"\n            : Array.isArray(children)\n              ? \"an array for children\"\n              : \"something unexpected for children\"),\n        console.error(\n          \"A script element was rendered with %s. If script element has children it must be a single string. Consider using dangerouslySetInnerHTML or passing a plain string as children.\",\n          props\n        ));\n      pushInnerHTML(target, innerHTML, children);\n      \"string\" === typeof children &&\n        target.push(stringToChunk(escapeEntireInlineScriptContent(children)));\n      target.push(endChunkForTag(\"script\"));\n      return null;\n    }\n    function pushStartGenericElement(target, props, tag) {\n      target.push(startChunkForTag(tag));\n      var innerHTML = (tag = null),\n        propKey;\n      for (propKey in props)\n        if (hasOwnProperty.call(props, propKey)) {\n          var propValue = props[propKey];\n          if (null != propValue)\n            switch (propKey) {\n              case \"children\":\n                tag = propValue;\n                break;\n              case \"dangerouslySetInnerHTML\":\n                innerHTML = propValue;\n                break;\n              default:\n                pushAttribute(target, propKey, propValue);\n            }\n        }\n      target.push(endOfStartTag);\n      pushInnerHTML(target, innerHTML, tag);\n      return \"string\" === typeof tag\n        ? (target.push(stringToChunk(escapeTextForBrowser(tag))), null)\n        : tag;\n    }\n    function startChunkForTag(tag) {\n      var tagStartChunk = validatedTagCache.get(tag);\n      if (void 0 === tagStartChunk) {\n        if (!VALID_TAG_REGEX.test(tag)) throw Error(\"Invalid tag: \" + tag);\n        tagStartChunk = stringToPrecomputedChunk(\"<\" + tag);\n        validatedTagCache.set(tag, tagStartChunk);\n      }\n      return tagStartChunk;\n    }\n    function pushStartInstance(\n      target$jscomp$0,\n      type,\n      props,\n      resumableState,\n      renderState,\n      hoistableState,\n      formatContext,\n      textEmbedded,\n      isFallback\n    ) {\n      validateProperties$2(type, props);\n      (\"input\" !== type && \"textarea\" !== type && \"select\" !== type) ||\n        null == props ||\n        null !== props.value ||\n        didWarnValueNull ||\n        ((didWarnValueNull = !0),\n        \"select\" === type && props.multiple\n          ? console.error(\n              \"`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.\",\n              type\n            )\n          : console.error(\n              \"`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.\",\n              type\n            ));\n      b: if (-1 === type.indexOf(\"-\")) var JSCompiler_inline_result = !1;\n      else\n        switch (type) {\n          case \"annotation-xml\":\n          case \"color-profile\":\n          case \"font-face\":\n          case \"font-face-src\":\n          case \"font-face-uri\":\n          case \"font-face-format\":\n          case \"font-face-name\":\n          case \"missing-glyph\":\n            JSCompiler_inline_result = !1;\n            break b;\n          default:\n            JSCompiler_inline_result = !0;\n        }\n      JSCompiler_inline_result ||\n        \"string\" === typeof props.is ||\n        warnUnknownProperties(type, props, null);\n      !props.suppressContentEditableWarning &&\n        props.contentEditable &&\n        null != props.children &&\n        console.error(\n          \"A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.\"\n        );\n      formatContext.insertionMode !== SVG_MODE &&\n        formatContext.insertionMode !== MATHML_MODE &&\n        -1 === type.indexOf(\"-\") &&\n        type.toLowerCase() !== type &&\n        console.error(\n          \"<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.\",\n          type\n        );\n      switch (type) {\n        case \"div\":\n        case \"span\":\n        case \"svg\":\n        case \"path\":\n          break;\n        case \"a\":\n          target$jscomp$0.push(startChunkForTag(\"a\"));\n          var children = null,\n            innerHTML = null,\n            propKey;\n          for (propKey in props)\n            if (hasOwnProperty.call(props, propKey)) {\n              var propValue = props[propKey];\n              if (null != propValue)\n                switch (propKey) {\n                  case \"children\":\n                    children = propValue;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML = propValue;\n                    break;\n                  case \"href\":\n                    \"\" === propValue\n                      ? pushStringAttribute(target$jscomp$0, \"href\", \"\")\n                      : pushAttribute(target$jscomp$0, propKey, propValue);\n                    break;\n                  default:\n                    pushAttribute(target$jscomp$0, propKey, propValue);\n                }\n            }\n          target$jscomp$0.push(endOfStartTag);\n          pushInnerHTML(target$jscomp$0, innerHTML, children);\n          if (\"string\" === typeof children) {\n            target$jscomp$0.push(stringToChunk(escapeTextForBrowser(children)));\n            var JSCompiler_inline_result$jscomp$0 = null;\n          } else JSCompiler_inline_result$jscomp$0 = children;\n          return JSCompiler_inline_result$jscomp$0;\n        case \"g\":\n        case \"p\":\n        case \"li\":\n          break;\n        case \"select\":\n          checkControlledValueProps(\"select\", props);\n          checkSelectProp(props, \"value\");\n          checkSelectProp(props, \"defaultValue\");\n          void 0 === props.value ||\n            void 0 === props.defaultValue ||\n            didWarnDefaultSelectValue ||\n            (console.error(\n              \"Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://react.dev/link/controlled-components\"\n            ),\n            (didWarnDefaultSelectValue = !0));\n          target$jscomp$0.push(startChunkForTag(\"select\"));\n          var children$jscomp$0 = null,\n            innerHTML$jscomp$0 = null,\n            propKey$jscomp$0;\n          for (propKey$jscomp$0 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$0)) {\n              var propValue$jscomp$0 = props[propKey$jscomp$0];\n              if (null != propValue$jscomp$0)\n                switch (propKey$jscomp$0) {\n                  case \"children\":\n                    children$jscomp$0 = propValue$jscomp$0;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML$jscomp$0 = propValue$jscomp$0;\n                    break;\n                  case \"defaultValue\":\n                  case \"value\":\n                    break;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$0,\n                      propValue$jscomp$0\n                    );\n                }\n            }\n          target$jscomp$0.push(endOfStartTag);\n          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$0, children$jscomp$0);\n          return children$jscomp$0;\n        case \"option\":\n          var selectedValue = formatContext.selectedValue;\n          target$jscomp$0.push(startChunkForTag(\"option\"));\n          var children$jscomp$1 = null,\n            value = null,\n            selected = null,\n            innerHTML$jscomp$1 = null,\n            propKey$jscomp$1;\n          for (propKey$jscomp$1 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$1)) {\n              var propValue$jscomp$1 = props[propKey$jscomp$1];\n              if (null != propValue$jscomp$1)\n                switch (propKey$jscomp$1) {\n                  case \"children\":\n                    children$jscomp$1 = propValue$jscomp$1;\n                    break;\n                  case \"selected\":\n                    selected = propValue$jscomp$1;\n                    didWarnSelectedSetOnOption ||\n                      (console.error(\n                        \"Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.\"\n                      ),\n                      (didWarnSelectedSetOnOption = !0));\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML$jscomp$1 = propValue$jscomp$1;\n                    break;\n                  case \"value\":\n                    value = propValue$jscomp$1;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$1,\n                      propValue$jscomp$1\n                    );\n                }\n            }\n          if (null != selectedValue) {\n            if (null !== value) {\n              checkAttributeStringCoercion(value, \"value\");\n              var stringValue = \"\" + value;\n            } else\n              null === innerHTML$jscomp$1 ||\n                didWarnInvalidOptionInnerHTML ||\n                ((didWarnInvalidOptionInnerHTML = !0),\n                console.error(\n                  \"Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.\"\n                )),\n                (stringValue = flattenOptionChildren(children$jscomp$1));\n            if (isArrayImpl(selectedValue))\n              for (var i = 0; i < selectedValue.length; i++) {\n                if (\n                  (checkAttributeStringCoercion(selectedValue[i], \"value\"),\n                  \"\" + selectedValue[i] === stringValue)\n                ) {\n                  target$jscomp$0.push(selectedMarkerAttribute);\n                  break;\n                }\n              }\n            else\n              checkAttributeStringCoercion(selectedValue, \"select.value\"),\n                \"\" + selectedValue === stringValue &&\n                  target$jscomp$0.push(selectedMarkerAttribute);\n          } else selected && target$jscomp$0.push(selectedMarkerAttribute);\n          target$jscomp$0.push(endOfStartTag);\n          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$1, children$jscomp$1);\n          return children$jscomp$1;\n        case \"textarea\":\n          checkControlledValueProps(\"textarea\", props);\n          void 0 === props.value ||\n            void 0 === props.defaultValue ||\n            didWarnDefaultTextareaValue ||\n            (console.error(\n              \"Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://react.dev/link/controlled-components\"\n            ),\n            (didWarnDefaultTextareaValue = !0));\n          target$jscomp$0.push(startChunkForTag(\"textarea\"));\n          var value$jscomp$0 = null,\n            defaultValue = null,\n            children$jscomp$2 = null,\n            propKey$jscomp$2;\n          for (propKey$jscomp$2 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$2)) {\n              var propValue$jscomp$2 = props[propKey$jscomp$2];\n              if (null != propValue$jscomp$2)\n                switch (propKey$jscomp$2) {\n                  case \"children\":\n                    children$jscomp$2 = propValue$jscomp$2;\n                    break;\n                  case \"value\":\n                    value$jscomp$0 = propValue$jscomp$2;\n                    break;\n                  case \"defaultValue\":\n                    defaultValue = propValue$jscomp$2;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    throw Error(\n                      \"`dangerouslySetInnerHTML` does not make sense on <textarea>.\"\n                    );\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$2,\n                      propValue$jscomp$2\n                    );\n                }\n            }\n          null === value$jscomp$0 &&\n            null !== defaultValue &&\n            (value$jscomp$0 = defaultValue);\n          target$jscomp$0.push(endOfStartTag);\n          if (null != children$jscomp$2) {\n            console.error(\n              \"Use the `defaultValue` or `value` props instead of setting children on <textarea>.\"\n            );\n            if (null != value$jscomp$0)\n              throw Error(\n                \"If you supply `defaultValue` on a <textarea>, do not pass children.\"\n              );\n            if (isArrayImpl(children$jscomp$2)) {\n              if (1 < children$jscomp$2.length)\n                throw Error(\"<textarea> can only have at most one child.\");\n              checkHtmlStringCoercion(children$jscomp$2[0]);\n              value$jscomp$0 = \"\" + children$jscomp$2[0];\n            }\n            checkHtmlStringCoercion(children$jscomp$2);\n            value$jscomp$0 = \"\" + children$jscomp$2;\n          }\n          \"string\" === typeof value$jscomp$0 &&\n            \"\\n\" === value$jscomp$0[0] &&\n            target$jscomp$0.push(leadingNewline);\n          null !== value$jscomp$0 &&\n            (checkAttributeStringCoercion(value$jscomp$0, \"value\"),\n            target$jscomp$0.push(\n              stringToChunk(escapeTextForBrowser(\"\" + value$jscomp$0))\n            ));\n          return null;\n        case \"input\":\n          checkControlledValueProps(\"input\", props);\n          target$jscomp$0.push(startChunkForTag(\"input\"));\n          var name = null,\n            formAction = null,\n            formEncType = null,\n            formMethod = null,\n            formTarget = null,\n            value$jscomp$1 = null,\n            defaultValue$jscomp$0 = null,\n            checked = null,\n            defaultChecked = null,\n            propKey$jscomp$3;\n          for (propKey$jscomp$3 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$3)) {\n              var propValue$jscomp$3 = props[propKey$jscomp$3];\n              if (null != propValue$jscomp$3)\n                switch (propKey$jscomp$3) {\n                  case \"children\":\n                  case \"dangerouslySetInnerHTML\":\n                    throw Error(\n                      \"input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.\"\n                    );\n                  case \"name\":\n                    name = propValue$jscomp$3;\n                    break;\n                  case \"formAction\":\n                    formAction = propValue$jscomp$3;\n                    break;\n                  case \"formEncType\":\n                    formEncType = propValue$jscomp$3;\n                    break;\n                  case \"formMethod\":\n                    formMethod = propValue$jscomp$3;\n                    break;\n                  case \"formTarget\":\n                    formTarget = propValue$jscomp$3;\n                    break;\n                  case \"defaultChecked\":\n                    defaultChecked = propValue$jscomp$3;\n                    break;\n                  case \"defaultValue\":\n                    defaultValue$jscomp$0 = propValue$jscomp$3;\n                    break;\n                  case \"checked\":\n                    checked = propValue$jscomp$3;\n                    break;\n                  case \"value\":\n                    value$jscomp$1 = propValue$jscomp$3;\n                    break;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$3,\n                      propValue$jscomp$3\n                    );\n                }\n            }\n          null === formAction ||\n            \"image\" === props.type ||\n            \"submit\" === props.type ||\n            didWarnFormActionType ||\n            ((didWarnFormActionType = !0),\n            console.error(\n              'An input can only specify a formAction along with type=\"submit\" or type=\"image\".'\n            ));\n          var formData = pushFormActionAttribute(\n            target$jscomp$0,\n            resumableState,\n            renderState,\n            formAction,\n            formEncType,\n            formMethod,\n            formTarget,\n            name\n          );\n          null === checked ||\n            null === defaultChecked ||\n            didWarnDefaultChecked ||\n            (console.error(\n              \"%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components\",\n              \"A component\",\n              props.type\n            ),\n            (didWarnDefaultChecked = !0));\n          null === value$jscomp$1 ||\n            null === defaultValue$jscomp$0 ||\n            didWarnDefaultInputValue ||\n            (console.error(\n              \"%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components\",\n              \"A component\",\n              props.type\n            ),\n            (didWarnDefaultInputValue = !0));\n          null !== checked\n            ? pushBooleanAttribute(target$jscomp$0, \"checked\", checked)\n            : null !== defaultChecked &&\n              pushBooleanAttribute(target$jscomp$0, \"checked\", defaultChecked);\n          null !== value$jscomp$1\n            ? pushAttribute(target$jscomp$0, \"value\", value$jscomp$1)\n            : null !== defaultValue$jscomp$0 &&\n              pushAttribute(target$jscomp$0, \"value\", defaultValue$jscomp$0);\n          target$jscomp$0.push(endOfStartTagSelfClosing);\n          null != formData &&\n            formData.forEach(pushAdditionalFormField, target$jscomp$0);\n          return null;\n        case \"button\":\n          target$jscomp$0.push(startChunkForTag(\"button\"));\n          var children$jscomp$3 = null,\n            innerHTML$jscomp$2 = null,\n            name$jscomp$0 = null,\n            formAction$jscomp$0 = null,\n            formEncType$jscomp$0 = null,\n            formMethod$jscomp$0 = null,\n            formTarget$jscomp$0 = null,\n            propKey$jscomp$4;\n          for (propKey$jscomp$4 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$4)) {\n              var propValue$jscomp$4 = props[propKey$jscomp$4];\n              if (null != propValue$jscomp$4)\n                switch (propKey$jscomp$4) {\n                  case \"children\":\n                    children$jscomp$3 = propValue$jscomp$4;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML$jscomp$2 = propValue$jscomp$4;\n                    break;\n                  case \"name\":\n                    name$jscomp$0 = propValue$jscomp$4;\n                    break;\n                  case \"formAction\":\n                    formAction$jscomp$0 = propValue$jscomp$4;\n                    break;\n                  case \"formEncType\":\n                    formEncType$jscomp$0 = propValue$jscomp$4;\n                    break;\n                  case \"formMethod\":\n                    formMethod$jscomp$0 = propValue$jscomp$4;\n                    break;\n                  case \"formTarget\":\n                    formTarget$jscomp$0 = propValue$jscomp$4;\n                    break;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$4,\n                      propValue$jscomp$4\n                    );\n                }\n            }\n          null === formAction$jscomp$0 ||\n            null == props.type ||\n            \"submit\" === props.type ||\n            didWarnFormActionType ||\n            ((didWarnFormActionType = !0),\n            console.error(\n              'A button can only specify a formAction along with type=\"submit\" or no type.'\n            ));\n          var formData$jscomp$0 = pushFormActionAttribute(\n            target$jscomp$0,\n            resumableState,\n            renderState,\n            formAction$jscomp$0,\n            formEncType$jscomp$0,\n            formMethod$jscomp$0,\n            formTarget$jscomp$0,\n            name$jscomp$0\n          );\n          target$jscomp$0.push(endOfStartTag);\n          null != formData$jscomp$0 &&\n            formData$jscomp$0.forEach(pushAdditionalFormField, target$jscomp$0);\n          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$2, children$jscomp$3);\n          if (\"string\" === typeof children$jscomp$3) {\n            target$jscomp$0.push(\n              stringToChunk(escapeTextForBrowser(children$jscomp$3))\n            );\n            var JSCompiler_inline_result$jscomp$1 = null;\n          } else JSCompiler_inline_result$jscomp$1 = children$jscomp$3;\n          return JSCompiler_inline_result$jscomp$1;\n        case \"form\":\n          target$jscomp$0.push(startChunkForTag(\"form\"));\n          var children$jscomp$4 = null,\n            innerHTML$jscomp$3 = null,\n            formAction$jscomp$1 = null,\n            formEncType$jscomp$1 = null,\n            formMethod$jscomp$1 = null,\n            formTarget$jscomp$1 = null,\n            propKey$jscomp$5;\n          for (propKey$jscomp$5 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$5)) {\n              var propValue$jscomp$5 = props[propKey$jscomp$5];\n              if (null != propValue$jscomp$5)\n                switch (propKey$jscomp$5) {\n                  case \"children\":\n                    children$jscomp$4 = propValue$jscomp$5;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML$jscomp$3 = propValue$jscomp$5;\n                    break;\n                  case \"action\":\n                    formAction$jscomp$1 = propValue$jscomp$5;\n                    break;\n                  case \"encType\":\n                    formEncType$jscomp$1 = propValue$jscomp$5;\n                    break;\n                  case \"method\":\n                    formMethod$jscomp$1 = propValue$jscomp$5;\n                    break;\n                  case \"target\":\n                    formTarget$jscomp$1 = propValue$jscomp$5;\n                    break;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$5,\n                      propValue$jscomp$5\n                    );\n                }\n            }\n          var formData$jscomp$1 = null,\n            formActionName = null;\n          if (\"function\" === typeof formAction$jscomp$1) {\n            (null === formEncType$jscomp$1 && null === formMethod$jscomp$1) ||\n              didWarnFormActionMethod ||\n              ((didWarnFormActionMethod = !0),\n              console.error(\n                \"Cannot specify a encType or method for a form that specifies a function as the action. React provides those automatically. They will get overridden.\"\n              ));\n            null === formTarget$jscomp$1 ||\n              didWarnFormActionTarget ||\n              ((didWarnFormActionTarget = !0),\n              console.error(\n                \"Cannot specify a target for a form that specifies a function as the action. The function will always be executed in the same window.\"\n              ));\n            var customFields = getCustomFormFields(\n              resumableState,\n              formAction$jscomp$1\n            );\n            null !== customFields\n              ? ((formAction$jscomp$1 = customFields.action || \"\"),\n                (formEncType$jscomp$1 = customFields.encType),\n                (formMethod$jscomp$1 = customFields.method),\n                (formTarget$jscomp$1 = customFields.target),\n                (formData$jscomp$1 = customFields.data),\n                (formActionName = customFields.name))\n              : (target$jscomp$0.push(\n                  attributeSeparator,\n                  stringToChunk(\"action\"),\n                  attributeAssign,\n                  actionJavaScriptURL,\n                  attributeEnd\n                ),\n                (formTarget$jscomp$1 =\n                  formMethod$jscomp$1 =\n                  formEncType$jscomp$1 =\n                  formAction$jscomp$1 =\n                    null),\n                injectFormReplayingRuntime(resumableState, renderState));\n          }\n          null != formAction$jscomp$1 &&\n            pushAttribute(target$jscomp$0, \"action\", formAction$jscomp$1);\n          null != formEncType$jscomp$1 &&\n            pushAttribute(target$jscomp$0, \"encType\", formEncType$jscomp$1);\n          null != formMethod$jscomp$1 &&\n            pushAttribute(target$jscomp$0, \"method\", formMethod$jscomp$1);\n          null != formTarget$jscomp$1 &&\n            pushAttribute(target$jscomp$0, \"target\", formTarget$jscomp$1);\n          target$jscomp$0.push(endOfStartTag);\n          null !== formActionName &&\n            (target$jscomp$0.push(startHiddenInputChunk),\n            pushStringAttribute(target$jscomp$0, \"name\", formActionName),\n            target$jscomp$0.push(endOfStartTagSelfClosing),\n            null != formData$jscomp$1 &&\n              formData$jscomp$1.forEach(\n                pushAdditionalFormField,\n                target$jscomp$0\n              ));\n          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$3, children$jscomp$4);\n          if (\"string\" === typeof children$jscomp$4) {\n            target$jscomp$0.push(\n              stringToChunk(escapeTextForBrowser(children$jscomp$4))\n            );\n            var JSCompiler_inline_result$jscomp$2 = null;\n          } else JSCompiler_inline_result$jscomp$2 = children$jscomp$4;\n          return JSCompiler_inline_result$jscomp$2;\n        case \"menuitem\":\n          target$jscomp$0.push(startChunkForTag(\"menuitem\"));\n          for (var propKey$jscomp$6 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$6)) {\n              var propValue$jscomp$6 = props[propKey$jscomp$6];\n              if (null != propValue$jscomp$6)\n                switch (propKey$jscomp$6) {\n                  case \"children\":\n                  case \"dangerouslySetInnerHTML\":\n                    throw Error(\n                      \"menuitems cannot have `children` nor `dangerouslySetInnerHTML`.\"\n                    );\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$6,\n                      propValue$jscomp$6\n                    );\n                }\n            }\n          target$jscomp$0.push(endOfStartTag);\n          return null;\n        case \"object\":\n          target$jscomp$0.push(startChunkForTag(\"object\"));\n          var children$jscomp$5 = null,\n            innerHTML$jscomp$4 = null,\n            propKey$jscomp$7;\n          for (propKey$jscomp$7 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$7)) {\n              var propValue$jscomp$7 = props[propKey$jscomp$7];\n              if (null != propValue$jscomp$7)\n                switch (propKey$jscomp$7) {\n                  case \"children\":\n                    children$jscomp$5 = propValue$jscomp$7;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML$jscomp$4 = propValue$jscomp$7;\n                    break;\n                  case \"data\":\n                    checkAttributeStringCoercion(propValue$jscomp$7, \"data\");\n                    var sanitizedValue = sanitizeURL(\"\" + propValue$jscomp$7);\n                    if (\"\" === sanitizedValue) {\n                      console.error(\n                        'An empty string (\"\") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',\n                        propKey$jscomp$7,\n                        propKey$jscomp$7\n                      );\n                      break;\n                    }\n                    target$jscomp$0.push(\n                      attributeSeparator,\n                      stringToChunk(\"data\"),\n                      attributeAssign,\n                      stringToChunk(escapeTextForBrowser(sanitizedValue)),\n                      attributeEnd\n                    );\n                    break;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$7,\n                      propValue$jscomp$7\n                    );\n                }\n            }\n          target$jscomp$0.push(endOfStartTag);\n          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$4, children$jscomp$5);\n          if (\"string\" === typeof children$jscomp$5) {\n            target$jscomp$0.push(\n              stringToChunk(escapeTextForBrowser(children$jscomp$5))\n            );\n            var JSCompiler_inline_result$jscomp$3 = null;\n          } else JSCompiler_inline_result$jscomp$3 = children$jscomp$5;\n          return JSCompiler_inline_result$jscomp$3;\n        case \"title\":\n          var insertionMode = formatContext.insertionMode,\n            noscriptTagInScope = !!(formatContext.tagScope & 1);\n          if (hasOwnProperty.call(props, \"children\")) {\n            var children$jscomp$6 = props.children,\n              child = Array.isArray(children$jscomp$6)\n                ? 2 > children$jscomp$6.length\n                  ? children$jscomp$6[0]\n                  : null\n                : children$jscomp$6;\n            Array.isArray(children$jscomp$6) && 1 < children$jscomp$6.length\n              ? console.error(\n                  \"React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an Array with length %s instead. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert `children` of <title> tags to a single string value which is why Arrays of length greater than 1 are not supported. When using JSX it can be commong to combine text nodes and value nodes. For example: <title>hello {nameOfUser}</title>. While not immediately apparent, `children` in this case is an Array with length 2. If your `children` prop is using this form try rewriting it using a template string: <title>{`hello ${nameOfUser}`}</title>.\",\n                  children$jscomp$6.length\n                )\n              : \"function\" === typeof child || \"symbol\" === typeof child\n                ? console.error(\n                    \"React expect children of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found %s instead. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value.\",\n                    \"function\" === typeof child ? \"a Function\" : \"a Sybmol\"\n                  )\n                : child &&\n                  child.toString === {}.toString &&\n                  (null != child.$$typeof\n                    ? console.error(\n                        \"React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an object that appears to be a React element which never implements a suitable `toString` method. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value which is why rendering React elements is not supported. If the `children` of <title> is a React Component try moving the <title> tag into that component. If the `children` of <title> is some HTML markup change it to be Text only to be valid HTML.\"\n                      )\n                    : console.error(\n                        \"React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an object that does not implement a suitable `toString` method. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value. Using the default `toString` method available on every object is almost certainly an error. Consider whether the `children` of this <title> is an object in error and change it to a string or number value if so. Otherwise implement a `toString` method that React can use to produce a valid <title>.\"\n                      ));\n          }\n          if (\n            insertionMode === SVG_MODE ||\n            noscriptTagInScope ||\n            null != props.itemProp\n          )\n            var JSCompiler_inline_result$jscomp$4 = pushTitleImpl(\n              target$jscomp$0,\n              props\n            );\n          else\n            isFallback\n              ? (JSCompiler_inline_result$jscomp$4 = null)\n              : (pushTitleImpl(renderState.hoistableChunks, props),\n                (JSCompiler_inline_result$jscomp$4 = void 0));\n          return JSCompiler_inline_result$jscomp$4;\n        case \"link\":\n          var rel = props.rel,\n            href = props.href,\n            precedence = props.precedence;\n          if (\n            formatContext.insertionMode === SVG_MODE ||\n            formatContext.tagScope & 1 ||\n            null != props.itemProp ||\n            \"string\" !== typeof rel ||\n            \"string\" !== typeof href ||\n            \"\" === href\n          ) {\n            \"stylesheet\" === rel &&\n              \"string\" === typeof props.precedence &&\n              ((\"string\" === typeof href && href) ||\n                console.error(\n                  'React encountered a `<link rel=\"stylesheet\" .../>` with a `precedence` prop and expected the `href` prop to be a non-empty string but ecountered %s instead. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop ensure there is a non-empty string `href` prop as well, otherwise remove the `precedence` prop.',\n                  null === href\n                    ? \"`null`\"\n                    : void 0 === href\n                      ? \"`undefined`\"\n                      : \"\" === href\n                        ? \"an empty string\"\n                        : 'something with type \"' + typeof href + '\"'\n                ));\n            pushLinkImpl(target$jscomp$0, props);\n            var JSCompiler_inline_result$jscomp$5 = null;\n          } else if (\"stylesheet\" === props.rel)\n            if (\n              \"string\" !== typeof precedence ||\n              null != props.disabled ||\n              props.onLoad ||\n              props.onError\n            ) {\n              if (\"string\" === typeof precedence)\n                if (null != props.disabled)\n                  console.error(\n                    'React encountered a `<link rel=\"stylesheet\" .../>` with a `precedence` prop and a `disabled` prop. The presence of the `disabled` prop indicates an intent to manage the stylesheet active state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the `disabled` prop, otherwise remove the `precedence` prop.'\n                  );\n                else if (props.onLoad || props.onError) {\n                  var propDescription =\n                    props.onLoad && props.onError\n                      ? \"`onLoad` and `onError` props\"\n                      : props.onLoad\n                        ? \"`onLoad` prop\"\n                        : \"`onError` prop\";\n                  console.error(\n                    'React encountered a `<link rel=\"stylesheet\" .../>` with a `precedence` prop and %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.',\n                    propDescription,\n                    propDescription\n                  );\n                }\n              JSCompiler_inline_result$jscomp$5 = pushLinkImpl(\n                target$jscomp$0,\n                props\n              );\n            } else {\n              var styleQueue = renderState.styles.get(precedence),\n                resourceState = resumableState.styleResources.hasOwnProperty(\n                  href\n                )\n                  ? resumableState.styleResources[href]\n                  : void 0;\n              if (resourceState !== EXISTS) {\n                resumableState.styleResources[href] = EXISTS;\n                styleQueue ||\n                  ((styleQueue = {\n                    precedence: stringToChunk(escapeTextForBrowser(precedence)),\n                    rules: [],\n                    hrefs: [],\n                    sheets: new Map()\n                  }),\n                  renderState.styles.set(precedence, styleQueue));\n                var resource = {\n                  state: PENDING$1,\n                  props: assign({}, props, {\n                    \"data-precedence\": props.precedence,\n                    precedence: null\n                  })\n                };\n                if (resourceState) {\n                  2 === resourceState.length &&\n                    adoptPreloadCredentials(resource.props, resourceState);\n                  var preloadResource =\n                    renderState.preloads.stylesheets.get(href);\n                  preloadResource && 0 < preloadResource.length\n                    ? (preloadResource.length = 0)\n                    : (resource.state = PRELOADED);\n                }\n                styleQueue.sheets.set(href, resource);\n                hoistableState && hoistableState.stylesheets.add(resource);\n              } else if (styleQueue) {\n                var _resource = styleQueue.sheets.get(href);\n                _resource &&\n                  hoistableState &&\n                  hoistableState.stylesheets.add(_resource);\n              }\n              textEmbedded && target$jscomp$0.push(textSeparator);\n              JSCompiler_inline_result$jscomp$5 = null;\n            }\n          else\n            props.onLoad || props.onError\n              ? (JSCompiler_inline_result$jscomp$5 = pushLinkImpl(\n                  target$jscomp$0,\n                  props\n                ))\n              : (textEmbedded && target$jscomp$0.push(textSeparator),\n                (JSCompiler_inline_result$jscomp$5 = isFallback\n                  ? null\n                  : pushLinkImpl(renderState.hoistableChunks, props)));\n          return JSCompiler_inline_result$jscomp$5;\n        case \"script\":\n          var asyncProp = props.async;\n          if (\n            \"string\" !== typeof props.src ||\n            !props.src ||\n            !asyncProp ||\n            \"function\" === typeof asyncProp ||\n            \"symbol\" === typeof asyncProp ||\n            props.onLoad ||\n            props.onError ||\n            formatContext.insertionMode === SVG_MODE ||\n            formatContext.tagScope & 1 ||\n            null != props.itemProp\n          )\n            var JSCompiler_inline_result$jscomp$6 = pushScriptImpl(\n              target$jscomp$0,\n              props\n            );\n          else {\n            var key = props.src;\n            if (\"module\" === props.type) {\n              var resources = resumableState.moduleScriptResources;\n              var preloads = renderState.preloads.moduleScripts;\n            } else\n              (resources = resumableState.scriptResources),\n                (preloads = renderState.preloads.scripts);\n            var resourceState$jscomp$0 = resources.hasOwnProperty(key)\n              ? resources[key]\n              : void 0;\n            if (resourceState$jscomp$0 !== EXISTS) {\n              resources[key] = EXISTS;\n              var scriptProps = props;\n              if (resourceState$jscomp$0) {\n                2 === resourceState$jscomp$0.length &&\n                  ((scriptProps = assign({}, props)),\n                  adoptPreloadCredentials(scriptProps, resourceState$jscomp$0));\n                var preloadResource$jscomp$0 = preloads.get(key);\n                preloadResource$jscomp$0 &&\n                  (preloadResource$jscomp$0.length = 0);\n              }\n              var resource$jscomp$0 = [];\n              renderState.scripts.add(resource$jscomp$0);\n              pushScriptImpl(resource$jscomp$0, scriptProps);\n            }\n            textEmbedded && target$jscomp$0.push(textSeparator);\n            JSCompiler_inline_result$jscomp$6 = null;\n          }\n          return JSCompiler_inline_result$jscomp$6;\n        case \"style\":\n          var insertionMode$jscomp$0 = formatContext.insertionMode,\n            noscriptTagInScope$jscomp$0 = !!(formatContext.tagScope & 1);\n          if (hasOwnProperty.call(props, \"children\")) {\n            var children$jscomp$7 = props.children,\n              child$jscomp$0 = Array.isArray(children$jscomp$7)\n                ? 2 > children$jscomp$7.length\n                  ? children$jscomp$7[0]\n                  : null\n                : children$jscomp$7;\n            (\"function\" === typeof child$jscomp$0 ||\n              \"symbol\" === typeof child$jscomp$0 ||\n              Array.isArray(child$jscomp$0)) &&\n              console.error(\n                \"React expect children of <style> tags to be a string, number, or object with a `toString` method but found %s instead. In browsers style Elements can only have `Text` Nodes as children.\",\n                \"function\" === typeof child$jscomp$0\n                  ? \"a Function\"\n                  : \"symbol\" === typeof child$jscomp$0\n                    ? \"a Sybmol\"\n                    : \"an Array\"\n              );\n          }\n          var precedence$jscomp$0 = props.precedence,\n            href$jscomp$0 = props.href;\n          if (\n            insertionMode$jscomp$0 === SVG_MODE ||\n            noscriptTagInScope$jscomp$0 ||\n            null != props.itemProp ||\n            \"string\" !== typeof precedence$jscomp$0 ||\n            \"string\" !== typeof href$jscomp$0 ||\n            \"\" === href$jscomp$0\n          ) {\n            target$jscomp$0.push(startChunkForTag(\"style\"));\n            var children$jscomp$8 = null,\n              innerHTML$jscomp$5 = null,\n              propKey$jscomp$8;\n            for (propKey$jscomp$8 in props)\n              if (hasOwnProperty.call(props, propKey$jscomp$8)) {\n                var propValue$jscomp$8 = props[propKey$jscomp$8];\n                if (null != propValue$jscomp$8)\n                  switch (propKey$jscomp$8) {\n                    case \"children\":\n                      children$jscomp$8 = propValue$jscomp$8;\n                      break;\n                    case \"dangerouslySetInnerHTML\":\n                      innerHTML$jscomp$5 = propValue$jscomp$8;\n                      break;\n                    default:\n                      pushAttribute(\n                        target$jscomp$0,\n                        propKey$jscomp$8,\n                        propValue$jscomp$8\n                      );\n                  }\n              }\n            target$jscomp$0.push(endOfStartTag);\n            var child$jscomp$1 = Array.isArray(children$jscomp$8)\n              ? 2 > children$jscomp$8.length\n                ? children$jscomp$8[0]\n                : null\n              : children$jscomp$8;\n            \"function\" !== typeof child$jscomp$1 &&\n              \"symbol\" !== typeof child$jscomp$1 &&\n              null !== child$jscomp$1 &&\n              void 0 !== child$jscomp$1 &&\n              target$jscomp$0.push(\n                stringToChunk(escapeStyleTextContent(child$jscomp$1))\n              );\n            pushInnerHTML(\n              target$jscomp$0,\n              innerHTML$jscomp$5,\n              children$jscomp$8\n            );\n            target$jscomp$0.push(endChunkForTag(\"style\"));\n            var JSCompiler_inline_result$jscomp$7 = null;\n          } else {\n            href$jscomp$0.includes(\" \") &&\n              console.error(\n                'React expected the `href` prop for a <style> tag opting into hoisting semantics using the `precedence` prop to not have any spaces but ecountered spaces instead. using spaces in this prop will cause hydration of this style to fail on the client. The href for the <style> where this ocurred is \"%s\".',\n                href$jscomp$0\n              );\n            var styleQueue$jscomp$0 =\n                renderState.styles.get(precedence$jscomp$0),\n              resourceState$jscomp$1 =\n                resumableState.styleResources.hasOwnProperty(href$jscomp$0)\n                  ? resumableState.styleResources[href$jscomp$0]\n                  : void 0;\n            if (resourceState$jscomp$1 !== EXISTS) {\n              resumableState.styleResources[href$jscomp$0] = EXISTS;\n              resourceState$jscomp$1 &&\n                console.error(\n                  'React encountered a hoistable style tag for the same href as a preload: \"%s\". When using a style tag to inline styles you should not also preload it as a stylsheet.',\n                  href$jscomp$0\n                );\n              styleQueue$jscomp$0\n                ? styleQueue$jscomp$0.hrefs.push(\n                    stringToChunk(escapeTextForBrowser(href$jscomp$0))\n                  )\n                : ((styleQueue$jscomp$0 = {\n                    precedence: stringToChunk(\n                      escapeTextForBrowser(precedence$jscomp$0)\n                    ),\n                    rules: [],\n                    hrefs: [stringToChunk(escapeTextForBrowser(href$jscomp$0))],\n                    sheets: new Map()\n                  }),\n                  renderState.styles.set(\n                    precedence$jscomp$0,\n                    styleQueue$jscomp$0\n                  ));\n              var target = styleQueue$jscomp$0.rules,\n                children$jscomp$9 = null,\n                innerHTML$jscomp$6 = null,\n                propKey$jscomp$9;\n              for (propKey$jscomp$9 in props)\n                if (hasOwnProperty.call(props, propKey$jscomp$9)) {\n                  var propValue$jscomp$9 = props[propKey$jscomp$9];\n                  if (null != propValue$jscomp$9)\n                    switch (propKey$jscomp$9) {\n                      case \"children\":\n                        children$jscomp$9 = propValue$jscomp$9;\n                        break;\n                      case \"dangerouslySetInnerHTML\":\n                        innerHTML$jscomp$6 = propValue$jscomp$9;\n                    }\n                }\n              var child$jscomp$2 = Array.isArray(children$jscomp$9)\n                ? 2 > children$jscomp$9.length\n                  ? children$jscomp$9[0]\n                  : null\n                : children$jscomp$9;\n              \"function\" !== typeof child$jscomp$2 &&\n                \"symbol\" !== typeof child$jscomp$2 &&\n                null !== child$jscomp$2 &&\n                void 0 !== child$jscomp$2 &&\n                target.push(\n                  stringToChunk(escapeStyleTextContent(child$jscomp$2))\n                );\n              pushInnerHTML(target, innerHTML$jscomp$6, children$jscomp$9);\n            }\n            styleQueue$jscomp$0 &&\n              hoistableState &&\n              hoistableState.styles.add(styleQueue$jscomp$0);\n            textEmbedded && target$jscomp$0.push(textSeparator);\n            JSCompiler_inline_result$jscomp$7 = void 0;\n          }\n          return JSCompiler_inline_result$jscomp$7;\n        case \"meta\":\n          if (\n            formatContext.insertionMode === SVG_MODE ||\n            formatContext.tagScope & 1 ||\n            null != props.itemProp\n          )\n            var JSCompiler_inline_result$jscomp$8 = pushSelfClosing(\n              target$jscomp$0,\n              props,\n              \"meta\"\n            );\n          else\n            textEmbedded && target$jscomp$0.push(textSeparator),\n              (JSCompiler_inline_result$jscomp$8 = isFallback\n                ? null\n                : \"string\" === typeof props.charSet\n                  ? pushSelfClosing(renderState.charsetChunks, props, \"meta\")\n                  : \"viewport\" === props.name\n                    ? pushSelfClosing(renderState.viewportChunks, props, \"meta\")\n                    : pushSelfClosing(\n                        renderState.hoistableChunks,\n                        props,\n                        \"meta\"\n                      ));\n          return JSCompiler_inline_result$jscomp$8;\n        case \"listing\":\n        case \"pre\":\n          target$jscomp$0.push(startChunkForTag(type));\n          var children$jscomp$10 = null,\n            innerHTML$jscomp$7 = null,\n            propKey$jscomp$10;\n          for (propKey$jscomp$10 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$10)) {\n              var propValue$jscomp$10 = props[propKey$jscomp$10];\n              if (null != propValue$jscomp$10)\n                switch (propKey$jscomp$10) {\n                  case \"children\":\n                    children$jscomp$10 = propValue$jscomp$10;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML$jscomp$7 = propValue$jscomp$10;\n                    break;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$10,\n                      propValue$jscomp$10\n                    );\n                }\n            }\n          target$jscomp$0.push(endOfStartTag);\n          if (null != innerHTML$jscomp$7) {\n            if (null != children$jscomp$10)\n              throw Error(\n                \"Can only set one of `children` or `props.dangerouslySetInnerHTML`.\"\n              );\n            if (\n              \"object\" !== typeof innerHTML$jscomp$7 ||\n              !(\"__html\" in innerHTML$jscomp$7)\n            )\n              throw Error(\n                \"`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information.\"\n              );\n            var html = innerHTML$jscomp$7.__html;\n            null !== html &&\n              void 0 !== html &&\n              (\"string\" === typeof html && 0 < html.length && \"\\n\" === html[0]\n                ? target$jscomp$0.push(leadingNewline, stringToChunk(html))\n                : (checkHtmlStringCoercion(html),\n                  target$jscomp$0.push(stringToChunk(\"\" + html))));\n          }\n          \"string\" === typeof children$jscomp$10 &&\n            \"\\n\" === children$jscomp$10[0] &&\n            target$jscomp$0.push(leadingNewline);\n          return children$jscomp$10;\n        case \"img\":\n          var src = props.src,\n            srcSet = props.srcSet;\n          if (\n            !(\n              \"lazy\" === props.loading ||\n              (!src && !srcSet) ||\n              (\"string\" !== typeof src && null != src) ||\n              (\"string\" !== typeof srcSet && null != srcSet)\n            ) &&\n            \"low\" !== props.fetchPriority &&\n            !1 === !!(formatContext.tagScope & 3) &&\n            (\"string\" !== typeof src ||\n              \":\" !== src[4] ||\n              (\"d\" !== src[0] && \"D\" !== src[0]) ||\n              (\"a\" !== src[1] && \"A\" !== src[1]) ||\n              (\"t\" !== src[2] && \"T\" !== src[2]) ||\n              (\"a\" !== src[3] && \"A\" !== src[3])) &&\n            (\"string\" !== typeof srcSet ||\n              \":\" !== srcSet[4] ||\n              (\"d\" !== srcSet[0] && \"D\" !== srcSet[0]) ||\n              (\"a\" !== srcSet[1] && \"A\" !== srcSet[1]) ||\n              (\"t\" !== srcSet[2] && \"T\" !== srcSet[2]) ||\n              (\"a\" !== srcSet[3] && \"A\" !== srcSet[3]))\n          ) {\n            var sizes = \"string\" === typeof props.sizes ? props.sizes : void 0,\n              key$jscomp$0 = srcSet ? srcSet + \"\\n\" + (sizes || \"\") : src,\n              promotablePreloads = renderState.preloads.images,\n              resource$jscomp$1 = promotablePreloads.get(key$jscomp$0);\n            if (resource$jscomp$1) {\n              if (\n                \"high\" === props.fetchPriority ||\n                10 > renderState.highImagePreloads.size\n              )\n                promotablePreloads.delete(key$jscomp$0),\n                  renderState.highImagePreloads.add(resource$jscomp$1);\n            } else if (\n              !resumableState.imageResources.hasOwnProperty(key$jscomp$0)\n            ) {\n              resumableState.imageResources[key$jscomp$0] = PRELOAD_NO_CREDS;\n              var input = props.crossOrigin;\n              var crossOrigin =\n                \"string\" === typeof input\n                  ? \"use-credentials\" === input\n                    ? input\n                    : \"\"\n                  : void 0;\n              var headers = renderState.headers,\n                header;\n              headers &&\n              0 < headers.remainingCapacity &&\n              (\"high\" === props.fetchPriority ||\n                500 > headers.highImagePreloads.length) &&\n              ((header = getPreloadAsHeader(src, \"image\", {\n                imageSrcSet: props.srcSet,\n                imageSizes: props.sizes,\n                crossOrigin: crossOrigin,\n                integrity: props.integrity,\n                nonce: props.nonce,\n                type: props.type,\n                fetchPriority: props.fetchPriority,\n                referrerPolicy: props.refererPolicy\n              })),\n              0 <= (headers.remainingCapacity -= header.length + 2))\n                ? ((renderState.resets.image[key$jscomp$0] = PRELOAD_NO_CREDS),\n                  headers.highImagePreloads &&\n                    (headers.highImagePreloads += \", \"),\n                  (headers.highImagePreloads += header))\n                : ((resource$jscomp$1 = []),\n                  pushLinkImpl(resource$jscomp$1, {\n                    rel: \"preload\",\n                    as: \"image\",\n                    href: srcSet ? void 0 : src,\n                    imageSrcSet: srcSet,\n                    imageSizes: sizes,\n                    crossOrigin: crossOrigin,\n                    integrity: props.integrity,\n                    type: props.type,\n                    fetchPriority: props.fetchPriority,\n                    referrerPolicy: props.referrerPolicy\n                  }),\n                  \"high\" === props.fetchPriority ||\n                  10 > renderState.highImagePreloads.size\n                    ? renderState.highImagePreloads.add(resource$jscomp$1)\n                    : (renderState.bulkPreloads.add(resource$jscomp$1),\n                      promotablePreloads.set(key$jscomp$0, resource$jscomp$1)));\n            }\n          }\n          return pushSelfClosing(target$jscomp$0, props, \"img\");\n        case \"base\":\n        case \"area\":\n        case \"br\":\n        case \"col\":\n        case \"embed\":\n        case \"hr\":\n        case \"keygen\":\n        case \"param\":\n        case \"source\":\n        case \"track\":\n        case \"wbr\":\n          return pushSelfClosing(target$jscomp$0, props, type);\n        case \"annotation-xml\":\n        case \"color-profile\":\n        case \"font-face\":\n        case \"font-face-src\":\n        case \"font-face-uri\":\n        case \"font-face-format\":\n        case \"font-face-name\":\n        case \"missing-glyph\":\n          break;\n        case \"head\":\n          if (\n            formatContext.insertionMode < HTML_MODE &&\n            null === renderState.headChunks\n          ) {\n            renderState.headChunks = [];\n            var JSCompiler_inline_result$jscomp$9 = pushStartGenericElement(\n              renderState.headChunks,\n              props,\n              \"head\"\n            );\n          } else\n            JSCompiler_inline_result$jscomp$9 = pushStartGenericElement(\n              target$jscomp$0,\n              props,\n              \"head\"\n            );\n          return JSCompiler_inline_result$jscomp$9;\n        case \"html\":\n          if (\n            formatContext.insertionMode === ROOT_HTML_MODE &&\n            null === renderState.htmlChunks\n          ) {\n            renderState.htmlChunks = [doctypeChunk];\n            var JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(\n              renderState.htmlChunks,\n              props,\n              \"html\"\n            );\n          } else\n            JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(\n              target$jscomp$0,\n              props,\n              \"html\"\n            );\n          return JSCompiler_inline_result$jscomp$10;\n        default:\n          if (-1 !== type.indexOf(\"-\")) {\n            target$jscomp$0.push(startChunkForTag(type));\n            var children$jscomp$11 = null,\n              innerHTML$jscomp$8 = null,\n              propKey$jscomp$11;\n            for (propKey$jscomp$11 in props)\n              if (hasOwnProperty.call(props, propKey$jscomp$11)) {\n                var propValue$jscomp$11 = props[propKey$jscomp$11];\n                if (null != propValue$jscomp$11) {\n                  var attributeName = propKey$jscomp$11;\n                  switch (propKey$jscomp$11) {\n                    case \"children\":\n                      children$jscomp$11 = propValue$jscomp$11;\n                      break;\n                    case \"dangerouslySetInnerHTML\":\n                      innerHTML$jscomp$8 = propValue$jscomp$11;\n                      break;\n                    case \"style\":\n                      pushStyleAttribute(target$jscomp$0, propValue$jscomp$11);\n                      break;\n                    case \"suppressContentEditableWarning\":\n                    case \"suppressHydrationWarning\":\n                    case \"ref\":\n                      break;\n                    case \"className\":\n                      attributeName = \"class\";\n                    default:\n                      if (\n                        isAttributeNameSafe(propKey$jscomp$11) &&\n                        \"function\" !== typeof propValue$jscomp$11 &&\n                        \"symbol\" !== typeof propValue$jscomp$11 &&\n                        !1 !== propValue$jscomp$11\n                      ) {\n                        if (!0 === propValue$jscomp$11)\n                          propValue$jscomp$11 = \"\";\n                        else if (\"object\" === typeof propValue$jscomp$11)\n                          continue;\n                        target$jscomp$0.push(\n                          attributeSeparator,\n                          stringToChunk(attributeName),\n                          attributeAssign,\n                          stringToChunk(\n                            escapeTextForBrowser(propValue$jscomp$11)\n                          ),\n                          attributeEnd\n                        );\n                      }\n                  }\n                }\n              }\n            target$jscomp$0.push(endOfStartTag);\n            pushInnerHTML(\n              target$jscomp$0,\n              innerHTML$jscomp$8,\n              children$jscomp$11\n            );\n            return children$jscomp$11;\n          }\n      }\n      return pushStartGenericElement(target$jscomp$0, props, type);\n    }\n    function endChunkForTag(tag) {\n      var chunk = endTagCache.get(tag);\n      void 0 === chunk &&\n        ((chunk = stringToPrecomputedChunk(\"</\" + tag + \">\")),\n        endTagCache.set(tag, chunk));\n      return chunk;\n    }\n    function writeBootstrap(destination, renderState) {\n      renderState = renderState.bootstrapChunks;\n      for (var i = 0; i < renderState.length - 1; i++)\n        writeChunk(destination, renderState[i]);\n      return i < renderState.length\n        ? ((i = renderState[i]),\n          (renderState.length = 0),\n          writeChunkAndReturn(destination, i))\n        : !0;\n    }\n    function writeStartPendingSuspenseBoundary(destination, renderState, id) {\n      writeChunk(destination, startPendingSuspenseBoundary1);\n      if (null === id)\n        throw Error(\n          \"An ID must have been assigned before we can complete the boundary.\"\n        );\n      writeChunk(destination, renderState.boundaryPrefix);\n      writeChunk(destination, stringToChunk(id.toString(16)));\n      return writeChunkAndReturn(destination, startPendingSuspenseBoundary2);\n    }\n    function writeStartSegment(destination, renderState, formatContext, id) {\n      switch (formatContext.insertionMode) {\n        case ROOT_HTML_MODE:\n        case HTML_HTML_MODE:\n        case HTML_MODE:\n          return (\n            writeChunk(destination, startSegmentHTML),\n            writeChunk(destination, renderState.segmentPrefix),\n            writeChunk(destination, stringToChunk(id.toString(16))),\n            writeChunkAndReturn(destination, startSegmentHTML2)\n          );\n        case SVG_MODE:\n          return (\n            writeChunk(destination, startSegmentSVG),\n            writeChunk(destination, renderState.segmentPrefix),\n            writeChunk(destination, stringToChunk(id.toString(16))),\n            writeChunkAndReturn(destination, startSegmentSVG2)\n          );\n        case MATHML_MODE:\n          return (\n            writeChunk(destination, startSegmentMathML),\n            writeChunk(destination, renderState.segmentPrefix),\n            writeChunk(destination, stringToChunk(id.toString(16))),\n            writeChunkAndReturn(destination, startSegmentMathML2)\n          );\n        case HTML_TABLE_MODE:\n          return (\n            writeChunk(destination, startSegmentTable),\n            writeChunk(destination, renderState.segmentPrefix),\n            writeChunk(destination, stringToChunk(id.toString(16))),\n            writeChunkAndReturn(destination, startSegmentTable2)\n          );\n        case HTML_TABLE_BODY_MODE:\n          return (\n            writeChunk(destination, startSegmentTableBody),\n            writeChunk(destination, renderState.segmentPrefix),\n            writeChunk(destination, stringToChunk(id.toString(16))),\n            writeChunkAndReturn(destination, startSegmentTableBody2)\n          );\n        case HTML_TABLE_ROW_MODE:\n          return (\n            writeChunk(destination, startSegmentTableRow),\n            writeChunk(destination, renderState.segmentPrefix),\n            writeChunk(destination, stringToChunk(id.toString(16))),\n            writeChunkAndReturn(destination, startSegmentTableRow2)\n          );\n        case HTML_COLGROUP_MODE:\n          return (\n            writeChunk(destination, startSegmentColGroup),\n            writeChunk(destination, renderState.segmentPrefix),\n            writeChunk(destination, stringToChunk(id.toString(16))),\n            writeChunkAndReturn(destination, startSegmentColGroup2)\n          );\n        default:\n          throw Error(\"Unknown insertion mode. This is a bug in React.\");\n      }\n    }\n    function writeEndSegment(destination, formatContext) {\n      switch (formatContext.insertionMode) {\n        case ROOT_HTML_MODE:\n        case HTML_HTML_MODE:\n        case HTML_MODE:\n          return writeChunkAndReturn(destination, endSegmentHTML);\n        case SVG_MODE:\n          return writeChunkAndReturn(destination, endSegmentSVG);\n        case MATHML_MODE:\n          return writeChunkAndReturn(destination, endSegmentMathML);\n        case HTML_TABLE_MODE:\n          return writeChunkAndReturn(destination, endSegmentTable);\n        case HTML_TABLE_BODY_MODE:\n          return writeChunkAndReturn(destination, endSegmentTableBody);\n        case HTML_TABLE_ROW_MODE:\n          return writeChunkAndReturn(destination, endSegmentTableRow);\n        case HTML_COLGROUP_MODE:\n          return writeChunkAndReturn(destination, endSegmentColGroup);\n        default:\n          throw Error(\"Unknown insertion mode. This is a bug in React.\");\n      }\n    }\n    function escapeJSStringsForInstructionScripts(input) {\n      return JSON.stringify(input).replace(\n        regexForJSStringsInInstructionScripts,\n        function (match) {\n          switch (match) {\n            case \"<\":\n              return \"\\\\u003c\";\n            case \"\\u2028\":\n              return \"\\\\u2028\";\n            case \"\\u2029\":\n              return \"\\\\u2029\";\n            default:\n              throw Error(\n                \"escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\"\n              );\n          }\n        }\n      );\n    }\n    function escapeJSObjectForInstructionScripts(input) {\n      return JSON.stringify(input).replace(\n        regexForJSStringsInScripts,\n        function (match) {\n          switch (match) {\n            case \"&\":\n              return \"\\\\u0026\";\n            case \">\":\n              return \"\\\\u003e\";\n            case \"<\":\n              return \"\\\\u003c\";\n            case \"\\u2028\":\n              return \"\\\\u2028\";\n            case \"\\u2029\":\n              return \"\\\\u2029\";\n            default:\n              throw Error(\n                \"escapeJSObjectForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\"\n              );\n          }\n        }\n      );\n    }\n    function flushStyleTagsLateForBoundary(styleQueue) {\n      var rules = styleQueue.rules,\n        hrefs = styleQueue.hrefs;\n      0 < rules.length &&\n        0 === hrefs.length &&\n        console.error(\n          \"React expected to have at least one href for an a hoistable style but found none. This is a bug in React.\"\n        );\n      var i = 0;\n      if (hrefs.length) {\n        writeChunk(this, lateStyleTagResourceOpen1);\n        writeChunk(this, styleQueue.precedence);\n        for (\n          writeChunk(this, lateStyleTagResourceOpen2);\n          i < hrefs.length - 1;\n          i++\n        )\n          writeChunk(this, hrefs[i]), writeChunk(this, spaceSeparator);\n        writeChunk(this, hrefs[i]);\n        writeChunk(this, lateStyleTagResourceOpen3);\n        for (i = 0; i < rules.length; i++) writeChunk(this, rules[i]);\n        destinationHasCapacity = writeChunkAndReturn(\n          this,\n          lateStyleTagTemplateClose\n        );\n        currentlyRenderingBoundaryHasStylesToHoist = !0;\n        rules.length = 0;\n        hrefs.length = 0;\n      }\n    }\n    function hasStylesToHoist(stylesheet) {\n      return stylesheet.state !== PREAMBLE\n        ? (currentlyRenderingBoundaryHasStylesToHoist = !0)\n        : !1;\n    }\n    function writeHoistablesForBoundary(\n      destination,\n      hoistableState,\n      renderState\n    ) {\n      currentlyRenderingBoundaryHasStylesToHoist = !1;\n      destinationHasCapacity = !0;\n      hoistableState.styles.forEach(flushStyleTagsLateForBoundary, destination);\n      hoistableState.stylesheets.forEach(hasStylesToHoist);\n      currentlyRenderingBoundaryHasStylesToHoist &&\n        (renderState.stylesToHoist = !0);\n      return destinationHasCapacity;\n    }\n    function flushResource(resource) {\n      for (var i = 0; i < resource.length; i++) writeChunk(this, resource[i]);\n      resource.length = 0;\n    }\n    function flushStyleInPreamble(stylesheet) {\n      pushLinkImpl(stylesheetFlushingQueue, stylesheet.props);\n      for (var i = 0; i < stylesheetFlushingQueue.length; i++)\n        writeChunk(this, stylesheetFlushingQueue[i]);\n      stylesheetFlushingQueue.length = 0;\n      stylesheet.state = PREAMBLE;\n    }\n    function flushStylesInPreamble(styleQueue) {\n      var hasStylesheets = 0 < styleQueue.sheets.size;\n      styleQueue.sheets.forEach(flushStyleInPreamble, this);\n      styleQueue.sheets.clear();\n      var rules = styleQueue.rules,\n        hrefs = styleQueue.hrefs;\n      if (!hasStylesheets || hrefs.length) {\n        writeChunk(this, styleTagResourceOpen1);\n        writeChunk(this, styleQueue.precedence);\n        styleQueue = 0;\n        if (hrefs.length) {\n          for (\n            writeChunk(this, styleTagResourceOpen2);\n            styleQueue < hrefs.length - 1;\n            styleQueue++\n          )\n            writeChunk(this, hrefs[styleQueue]),\n              writeChunk(this, spaceSeparator);\n          writeChunk(this, hrefs[styleQueue]);\n        }\n        writeChunk(this, styleTagResourceOpen3);\n        for (styleQueue = 0; styleQueue < rules.length; styleQueue++)\n          writeChunk(this, rules[styleQueue]);\n        writeChunk(this, styleTagResourceClose);\n        rules.length = 0;\n        hrefs.length = 0;\n      }\n    }\n    function preloadLateStyle(stylesheet) {\n      if (stylesheet.state === PENDING$1) {\n        stylesheet.state = PRELOADED;\n        var props = stylesheet.props;\n        pushLinkImpl(stylesheetFlushingQueue, {\n          rel: \"preload\",\n          as: \"style\",\n          href: stylesheet.props.href,\n          crossOrigin: props.crossOrigin,\n          fetchPriority: props.fetchPriority,\n          integrity: props.integrity,\n          media: props.media,\n          hrefLang: props.hrefLang,\n          referrerPolicy: props.referrerPolicy\n        });\n        for (\n          stylesheet = 0;\n          stylesheet < stylesheetFlushingQueue.length;\n          stylesheet++\n        )\n          writeChunk(this, stylesheetFlushingQueue[stylesheet]);\n        stylesheetFlushingQueue.length = 0;\n      }\n    }\n    function preloadLateStyles(styleQueue) {\n      styleQueue.sheets.forEach(preloadLateStyle, this);\n      styleQueue.sheets.clear();\n    }\n    function writeStyleResourceDependenciesInJS(destination, hoistableState) {\n      writeChunk(destination, arrayFirstOpenBracket);\n      var nextArrayOpenBrackChunk = arrayFirstOpenBracket;\n      hoistableState.stylesheets.forEach(function (resource) {\n        if (resource.state !== PREAMBLE)\n          if (resource.state === LATE)\n            writeChunk(destination, nextArrayOpenBrackChunk),\n              (resource = resource.props.href),\n              checkAttributeStringCoercion(resource, \"href\"),\n              writeChunk(\n                destination,\n                stringToChunk(\n                  escapeJSObjectForInstructionScripts(\"\" + resource)\n                )\n              ),\n              writeChunk(destination, arrayCloseBracket),\n              (nextArrayOpenBrackChunk = arraySubsequentOpenBracket);\n          else {\n            writeChunk(destination, nextArrayOpenBrackChunk);\n            var precedence = resource.props[\"data-precedence\"],\n              props = resource.props,\n              coercedHref = sanitizeURL(\"\" + resource.props.href);\n            writeChunk(\n              destination,\n              stringToChunk(escapeJSObjectForInstructionScripts(coercedHref))\n            );\n            checkAttributeStringCoercion(precedence, \"precedence\");\n            precedence = \"\" + precedence;\n            writeChunk(destination, arrayInterstitial);\n            writeChunk(\n              destination,\n              stringToChunk(escapeJSObjectForInstructionScripts(precedence))\n            );\n            for (var propKey in props)\n              if (\n                hasOwnProperty.call(props, propKey) &&\n                ((precedence = props[propKey]), null != precedence)\n              )\n                switch (propKey) {\n                  case \"href\":\n                  case \"rel\":\n                  case \"precedence\":\n                  case \"data-precedence\":\n                    break;\n                  case \"children\":\n                  case \"dangerouslySetInnerHTML\":\n                    throw Error(\n                      \"link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.\"\n                    );\n                  default:\n                    writeStyleResourceAttributeInJS(\n                      destination,\n                      propKey,\n                      precedence\n                    );\n                }\n            writeChunk(destination, arrayCloseBracket);\n            nextArrayOpenBrackChunk = arraySubsequentOpenBracket;\n            resource.state = LATE;\n          }\n      });\n      writeChunk(destination, arrayCloseBracket);\n    }\n    function writeStyleResourceAttributeInJS(destination, name, value) {\n      var attributeName = name.toLowerCase();\n      switch (typeof value) {\n        case \"function\":\n        case \"symbol\":\n          return;\n      }\n      switch (name) {\n        case \"innerHTML\":\n        case \"dangerouslySetInnerHTML\":\n        case \"suppressContentEditableWarning\":\n        case \"suppressHydrationWarning\":\n        case \"style\":\n        case \"ref\":\n          return;\n        case \"className\":\n          attributeName = \"class\";\n          checkAttributeStringCoercion(value, attributeName);\n          name = \"\" + value;\n          break;\n        case \"hidden\":\n          if (!1 === value) return;\n          name = \"\";\n          break;\n        case \"src\":\n        case \"href\":\n          value = sanitizeURL(value);\n          checkAttributeStringCoercion(value, attributeName);\n          name = \"\" + value;\n          break;\n        default:\n          if (\n            (2 < name.length &&\n              (\"o\" === name[0] || \"O\" === name[0]) &&\n              (\"n\" === name[1] || \"N\" === name[1])) ||\n            !isAttributeNameSafe(name)\n          )\n            return;\n          checkAttributeStringCoercion(value, attributeName);\n          name = \"\" + value;\n      }\n      writeChunk(destination, arrayInterstitial);\n      writeChunk(\n        destination,\n        stringToChunk(escapeJSObjectForInstructionScripts(attributeName))\n      );\n      writeChunk(destination, arrayInterstitial);\n      writeChunk(\n        destination,\n        stringToChunk(escapeJSObjectForInstructionScripts(name))\n      );\n    }\n    function createHoistableState() {\n      return { styles: new Set(), stylesheets: new Set() };\n    }\n    function preloadBootstrapScriptOrModule(\n      resumableState,\n      renderState,\n      href,\n      props\n    ) {\n      (resumableState.scriptResources.hasOwnProperty(href) ||\n        resumableState.moduleScriptResources.hasOwnProperty(href)) &&\n        console.error(\n          'Internal React Error: React expected bootstrap script or module with src \"%s\" to not have been preloaded already. please file an issue',\n          href\n        );\n      resumableState.scriptResources[href] = EXISTS;\n      resumableState.moduleScriptResources[href] = EXISTS;\n      resumableState = [];\n      pushLinkImpl(resumableState, props);\n      renderState.bootstrapScripts.add(resumableState);\n    }\n    function adoptPreloadCredentials(target, preloadState) {\n      null == target.crossOrigin && (target.crossOrigin = preloadState[0]);\n      null == target.integrity && (target.integrity = preloadState[1]);\n    }\n    function getPreloadAsHeader(href, as, params) {\n      href = escapeHrefForLinkHeaderURLContext(href);\n      as = escapeStringForLinkHeaderQuotedParamValueContext(as, \"as\");\n      as = \"<\" + href + '>; rel=preload; as=\"' + as + '\"';\n      for (var paramName in params)\n        hasOwnProperty.call(params, paramName) &&\n          ((href = params[paramName]),\n          \"string\" === typeof href &&\n            (as +=\n              \"; \" +\n              paramName.toLowerCase() +\n              '=\"' +\n              escapeStringForLinkHeaderQuotedParamValueContext(\n                href,\n                paramName\n              ) +\n              '\"'));\n      return as;\n    }\n    function escapeHrefForLinkHeaderURLContext(hrefInput) {\n      checkAttributeStringCoercion(hrefInput, \"href\");\n      return (\"\" + hrefInput).replace(\n        regexForHrefInLinkHeaderURLContext,\n        escapeHrefForLinkHeaderURLContextReplacer\n      );\n    }\n    function escapeHrefForLinkHeaderURLContextReplacer(match) {\n      switch (match) {\n        case \"<\":\n          return \"%3C\";\n        case \">\":\n          return \"%3E\";\n        case \"\\n\":\n          return \"%0A\";\n        case \"\\r\":\n          return \"%0D\";\n        default:\n          throw Error(\n            \"escapeLinkHrefForHeaderContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\"\n          );\n      }\n    }\n    function escapeStringForLinkHeaderQuotedParamValueContext(value, name) {\n      willCoercionThrow(value) &&\n        (console.error(\n          \"The provided `%s` option is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          name,\n          typeName(value)\n        ),\n        testStringCoercion(value));\n      return (\"\" + value).replace(\n        regexForLinkHeaderQuotedParamValueContext,\n        escapeStringForLinkHeaderQuotedParamValueContextReplacer\n      );\n    }\n    function escapeStringForLinkHeaderQuotedParamValueContextReplacer(match) {\n      switch (match) {\n        case '\"':\n          return \"%22\";\n        case \"'\":\n          return \"%27\";\n        case \";\":\n          return \"%3B\";\n        case \",\":\n          return \"%2C\";\n        case \"\\n\":\n          return \"%0A\";\n        case \"\\r\":\n          return \"%0D\";\n        default:\n          throw Error(\n            \"escapeStringForLinkHeaderQuotedParamValueContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\"\n          );\n      }\n    }\n    function hoistStyleQueueDependency(styleQueue) {\n      this.styles.add(styleQueue);\n    }\n    function hoistStylesheetDependency(stylesheet) {\n      this.stylesheets.add(stylesheet);\n    }\n    function getComponentNameFromType(type) {\n      if (null == type) return null;\n      if (\"function\" === typeof type)\n        return type.$$typeof === REACT_CLIENT_REFERENCE\n          ? null\n          : type.displayName || type.name || null;\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n        case REACT_PORTAL_TYPE:\n          return \"Portal\";\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n      }\n      if (\"object\" === typeof type)\n        switch (\n          (\"number\" === typeof type.tag &&\n            console.error(\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n            ),\n          type.$$typeof)\n        ) {\n          case REACT_CONTEXT_TYPE:\n            return (type.displayName || \"Context\") + \".Provider\";\n          case REACT_CONSUMER_TYPE:\n            return (type._context.displayName || \"Context\") + \".Consumer\";\n          case REACT_FORWARD_REF_TYPE:\n            var innerType = type.render;\n            type = type.displayName;\n            type ||\n              ((type = innerType.displayName || innerType.name || \"\"),\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n            return type;\n          case REACT_MEMO_TYPE:\n            return (\n              (innerType = type.displayName || null),\n              null !== innerType\n                ? innerType\n                : getComponentNameFromType(type.type) || \"Memo\"\n            );\n          case REACT_LAZY_TYPE:\n            innerType = type._payload;\n            type = type._init;\n            try {\n              return getComponentNameFromType(type(innerType));\n            } catch (x) {}\n        }\n      return null;\n    }\n    function popToNearestCommonAncestor(prev, next) {\n      if (prev !== next) {\n        prev.context._currentValue = prev.parentValue;\n        prev = prev.parent;\n        var parentNext = next.parent;\n        if (null === prev) {\n          if (null !== parentNext)\n            throw Error(\n              \"The stacks must reach the root at the same time. This is a bug in React.\"\n            );\n        } else {\n          if (null === parentNext)\n            throw Error(\n              \"The stacks must reach the root at the same time. This is a bug in React.\"\n            );\n          popToNearestCommonAncestor(prev, parentNext);\n        }\n        next.context._currentValue = next.value;\n      }\n    }\n    function popAllPrevious(prev) {\n      prev.context._currentValue = prev.parentValue;\n      prev = prev.parent;\n      null !== prev && popAllPrevious(prev);\n    }\n    function pushAllNext(next) {\n      var parentNext = next.parent;\n      null !== parentNext && pushAllNext(parentNext);\n      next.context._currentValue = next.value;\n    }\n    function popPreviousToCommonLevel(prev, next) {\n      prev.context._currentValue = prev.parentValue;\n      prev = prev.parent;\n      if (null === prev)\n        throw Error(\n          \"The depth must equal at least at zero before reaching the root. This is a bug in React.\"\n        );\n      prev.depth === next.depth\n        ? popToNearestCommonAncestor(prev, next)\n        : popPreviousToCommonLevel(prev, next);\n    }\n    function popNextToCommonLevel(prev, next) {\n      var parentNext = next.parent;\n      if (null === parentNext)\n        throw Error(\n          \"The depth must equal at least at zero before reaching the root. This is a bug in React.\"\n        );\n      prev.depth === parentNext.depth\n        ? popToNearestCommonAncestor(prev, parentNext)\n        : popNextToCommonLevel(prev, parentNext);\n      next.context._currentValue = next.value;\n    }\n    function switchContext(newSnapshot) {\n      var prev = currentActiveSnapshot;\n      prev !== newSnapshot &&\n        (null === prev\n          ? pushAllNext(newSnapshot)\n          : null === newSnapshot\n            ? popAllPrevious(prev)\n            : prev.depth === newSnapshot.depth\n              ? popToNearestCommonAncestor(prev, newSnapshot)\n              : prev.depth > newSnapshot.depth\n                ? popPreviousToCommonLevel(prev, newSnapshot)\n                : popNextToCommonLevel(prev, newSnapshot),\n        (currentActiveSnapshot = newSnapshot));\n    }\n    function warnOnInvalidCallback(callback) {\n      if (null !== callback && \"function\" !== typeof callback) {\n        var key = String(callback);\n        didWarnOnInvalidCallback.has(key) ||\n          (didWarnOnInvalidCallback.add(key),\n          console.error(\n            \"Expected the last optional `callback` argument to be a function. Instead received: %s.\",\n            callback\n          ));\n      }\n    }\n    function warnNoop(publicInstance, callerName) {\n      publicInstance =\n        ((publicInstance = publicInstance.constructor) &&\n          getComponentNameFromType(publicInstance)) ||\n        \"ReactClass\";\n      var warningKey = publicInstance + \".\" + callerName;\n      didWarnAboutNoopUpdateForComponent[warningKey] ||\n        (console.error(\n          \"Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.\\n\\nPlease check the code for the %s component.\",\n          callerName,\n          publicInstance\n        ),\n        (didWarnAboutNoopUpdateForComponent[warningKey] = !0));\n    }\n    function pushTreeContext(baseContext, totalChildren, index) {\n      var baseIdWithLeadingBit = baseContext.id;\n      baseContext = baseContext.overflow;\n      var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;\n      baseIdWithLeadingBit &= ~(1 << baseLength);\n      index += 1;\n      var length = 32 - clz32(totalChildren) + baseLength;\n      if (30 < length) {\n        var numberOfOverflowBits = baseLength - (baseLength % 5);\n        length = (\n          baseIdWithLeadingBit &\n          ((1 << numberOfOverflowBits) - 1)\n        ).toString(32);\n        baseIdWithLeadingBit >>= numberOfOverflowBits;\n        baseLength -= numberOfOverflowBits;\n        return {\n          id:\n            (1 << (32 - clz32(totalChildren) + baseLength)) |\n            (index << baseLength) |\n            baseIdWithLeadingBit,\n          overflow: length + baseContext\n        };\n      }\n      return {\n        id: (1 << length) | (index << baseLength) | baseIdWithLeadingBit,\n        overflow: baseContext\n      };\n    }\n    function clz32Fallback(x) {\n      x >>>= 0;\n      return 0 === x ? 32 : (31 - ((log(x) / LN2) | 0)) | 0;\n    }\n    function noop$2() {}\n    function trackUsedThenable(thenableState, thenable, index) {\n      index = thenableState[index];\n      void 0 === index\n        ? thenableState.push(thenable)\n        : index !== thenable &&\n          (thenable.then(noop$2, noop$2), (thenable = index));\n      switch (thenable.status) {\n        case \"fulfilled\":\n          return thenable.value;\n        case \"rejected\":\n          throw thenable.reason;\n        default:\n          \"string\" === typeof thenable.status\n            ? thenable.then(noop$2, noop$2)\n            : ((thenableState = thenable),\n              (thenableState.status = \"pending\"),\n              thenableState.then(\n                function (fulfilledValue) {\n                  if (\"pending\" === thenable.status) {\n                    var fulfilledThenable = thenable;\n                    fulfilledThenable.status = \"fulfilled\";\n                    fulfilledThenable.value = fulfilledValue;\n                  }\n                },\n                function (error) {\n                  if (\"pending\" === thenable.status) {\n                    var rejectedThenable = thenable;\n                    rejectedThenable.status = \"rejected\";\n                    rejectedThenable.reason = error;\n                  }\n                }\n              ));\n          switch (thenable.status) {\n            case \"fulfilled\":\n              return thenable.value;\n            case \"rejected\":\n              throw thenable.reason;\n          }\n          suspendedThenable = thenable;\n          throw SuspenseException;\n      }\n    }\n    function getSuspendedThenable() {\n      if (null === suspendedThenable)\n        throw Error(\n          \"Expected a suspended thenable. This is a bug in React. Please file an issue.\"\n        );\n      var thenable = suspendedThenable;\n      suspendedThenable = null;\n      return thenable;\n    }\n    function is(x, y) {\n      return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);\n    }\n    function resolveCurrentlyRenderingComponent() {\n      if (null === currentlyRenderingComponent)\n        throw Error(\n          \"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\\n1. You might have mismatching versions of React and the renderer (such as React DOM)\\n2. You might be breaking the Rules of Hooks\\n3. You might have more than one copy of React in the same app\\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.\"\n        );\n      isInHookUserCodeInDev &&\n        console.error(\n          \"Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks\"\n        );\n      return currentlyRenderingComponent;\n    }\n    function createHook() {\n      if (0 < numberOfReRenders)\n        throw Error(\"Rendered more hooks than during the previous render\");\n      return { memoizedState: null, queue: null, next: null };\n    }\n    function createWorkInProgressHook() {\n      null === workInProgressHook\n        ? null === firstWorkInProgressHook\n          ? ((isReRender = !1),\n            (firstWorkInProgressHook = workInProgressHook = createHook()))\n          : ((isReRender = !0), (workInProgressHook = firstWorkInProgressHook))\n        : null === workInProgressHook.next\n          ? ((isReRender = !1),\n            (workInProgressHook = workInProgressHook.next = createHook()))\n          : ((isReRender = !0), (workInProgressHook = workInProgressHook.next));\n      return workInProgressHook;\n    }\n    function getThenableStateAfterSuspending() {\n      var state = thenableState;\n      thenableState = null;\n      return state;\n    }\n    function resetHooksState() {\n      isInHookUserCodeInDev = !1;\n      currentlyRenderingKeyPath =\n        currentlyRenderingRequest =\n        currentlyRenderingTask =\n        currentlyRenderingComponent =\n          null;\n      didScheduleRenderPhaseUpdate = !1;\n      firstWorkInProgressHook = null;\n      numberOfReRenders = 0;\n      workInProgressHook = renderPhaseUpdates = null;\n    }\n    function readContext(context) {\n      isInHookUserCodeInDev &&\n        console.error(\n          \"Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().\"\n        );\n      return context._currentValue;\n    }\n    function basicStateReducer(state, action) {\n      return \"function\" === typeof action ? action(state) : action;\n    }\n    function useReducer(reducer, initialArg, init) {\n      reducer !== basicStateReducer && (currentHookNameInDev = \"useReducer\");\n      currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n      workInProgressHook = createWorkInProgressHook();\n      if (isReRender) {\n        init = workInProgressHook.queue;\n        initialArg = init.dispatch;\n        if (null !== renderPhaseUpdates) {\n          var firstRenderPhaseUpdate = renderPhaseUpdates.get(init);\n          if (void 0 !== firstRenderPhaseUpdate) {\n            renderPhaseUpdates.delete(init);\n            init = workInProgressHook.memoizedState;\n            do {\n              var action = firstRenderPhaseUpdate.action;\n              isInHookUserCodeInDev = !0;\n              init = reducer(init, action);\n              isInHookUserCodeInDev = !1;\n              firstRenderPhaseUpdate = firstRenderPhaseUpdate.next;\n            } while (null !== firstRenderPhaseUpdate);\n            workInProgressHook.memoizedState = init;\n            return [init, initialArg];\n          }\n        }\n        return [workInProgressHook.memoizedState, initialArg];\n      }\n      isInHookUserCodeInDev = !0;\n      reducer =\n        reducer === basicStateReducer\n          ? \"function\" === typeof initialArg\n            ? initialArg()\n            : initialArg\n          : void 0 !== init\n            ? init(initialArg)\n            : initialArg;\n      isInHookUserCodeInDev = !1;\n      workInProgressHook.memoizedState = reducer;\n      reducer = workInProgressHook.queue = { last: null, dispatch: null };\n      reducer = reducer.dispatch = dispatchAction.bind(\n        null,\n        currentlyRenderingComponent,\n        reducer\n      );\n      return [workInProgressHook.memoizedState, reducer];\n    }\n    function useMemo(nextCreate, deps) {\n      currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n      workInProgressHook = createWorkInProgressHook();\n      deps = void 0 === deps ? null : deps;\n      if (null !== workInProgressHook) {\n        var prevState = workInProgressHook.memoizedState;\n        if (null !== prevState && null !== deps) {\n          a: {\n            var JSCompiler_inline_result = prevState[1];\n            if (null === JSCompiler_inline_result)\n              console.error(\n                \"%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.\",\n                currentHookNameInDev\n              ),\n                (JSCompiler_inline_result = !1);\n            else {\n              deps.length !== JSCompiler_inline_result.length &&\n                console.error(\n                  \"The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\\n\\nPrevious: %s\\nIncoming: %s\",\n                  currentHookNameInDev,\n                  \"[\" + deps.join(\", \") + \"]\",\n                  \"[\" + JSCompiler_inline_result.join(\", \") + \"]\"\n                );\n              for (\n                var i = 0;\n                i < JSCompiler_inline_result.length && i < deps.length;\n                i++\n              )\n                if (!objectIs(deps[i], JSCompiler_inline_result[i])) {\n                  JSCompiler_inline_result = !1;\n                  break a;\n                }\n              JSCompiler_inline_result = !0;\n            }\n          }\n          if (JSCompiler_inline_result) return prevState[0];\n        }\n      }\n      isInHookUserCodeInDev = !0;\n      nextCreate = nextCreate();\n      isInHookUserCodeInDev = !1;\n      workInProgressHook.memoizedState = [nextCreate, deps];\n      return nextCreate;\n    }\n    function dispatchAction(componentIdentity, queue, action) {\n      if (25 <= numberOfReRenders)\n        throw Error(\n          \"Too many re-renders. React limits the number of renders to prevent an infinite loop.\"\n        );\n      if (componentIdentity === currentlyRenderingComponent)\n        if (\n          ((didScheduleRenderPhaseUpdate = !0),\n          (componentIdentity = { action: action, next: null }),\n          null === renderPhaseUpdates && (renderPhaseUpdates = new Map()),\n          (action = renderPhaseUpdates.get(queue)),\n          void 0 === action)\n        )\n          renderPhaseUpdates.set(queue, componentIdentity);\n        else {\n          for (queue = action; null !== queue.next; ) queue = queue.next;\n          queue.next = componentIdentity;\n        }\n    }\n    function unsupportedStartTransition() {\n      throw Error(\"startTransition cannot be called during server rendering.\");\n    }\n    function unsupportedSetOptimisticState() {\n      throw Error(\"Cannot update optimistic state while rendering.\");\n    }\n    function useActionState(action, initialState, permalink) {\n      resolveCurrentlyRenderingComponent();\n      var actionStateHookIndex = actionStateCounter++,\n        request = currentlyRenderingRequest;\n      if (\"function\" === typeof action.$$FORM_ACTION) {\n        var nextPostbackStateKey = null,\n          componentKeyPath = currentlyRenderingKeyPath;\n        request = request.formState;\n        var isSignatureEqual = action.$$IS_SIGNATURE_EQUAL;\n        if (null !== request && \"function\" === typeof isSignatureEqual) {\n          var postbackKey = request[1];\n          isSignatureEqual.call(action, request[2], request[3]) &&\n            ((nextPostbackStateKey =\n              void 0 !== permalink\n                ? \"p\" + permalink\n                : \"k\" +\n                  murmurhash3_32_gc(\n                    JSON.stringify([\n                      componentKeyPath,\n                      null,\n                      actionStateHookIndex\n                    ]),\n                    0\n                  )),\n            postbackKey === nextPostbackStateKey &&\n              ((actionStateMatchingIndex = actionStateHookIndex),\n              (initialState = request[0])));\n        }\n        var boundAction = action.bind(null, initialState);\n        action = function (payload) {\n          boundAction(payload);\n        };\n        \"function\" === typeof boundAction.$$FORM_ACTION &&\n          (action.$$FORM_ACTION = function (prefix) {\n            prefix = boundAction.$$FORM_ACTION(prefix);\n            void 0 !== permalink &&\n              (checkAttributeStringCoercion(permalink, \"target\"),\n              (permalink += \"\"),\n              (prefix.action = permalink));\n            var formData = prefix.data;\n            formData &&\n              (null === nextPostbackStateKey &&\n                (nextPostbackStateKey =\n                  void 0 !== permalink\n                    ? \"p\" + permalink\n                    : \"k\" +\n                      murmurhash3_32_gc(\n                        JSON.stringify([\n                          componentKeyPath,\n                          null,\n                          actionStateHookIndex\n                        ]),\n                        0\n                      )),\n              formData.append(\"$ACTION_KEY\", nextPostbackStateKey));\n            return prefix;\n          });\n        return [initialState, action, !1];\n      }\n      var _boundAction = action.bind(null, initialState);\n      return [\n        initialState,\n        function (payload) {\n          _boundAction(payload);\n        },\n        !1\n      ];\n    }\n    function unwrapThenable(thenable) {\n      var index = thenableIndexCounter;\n      thenableIndexCounter += 1;\n      null === thenableState && (thenableState = []);\n      return trackUsedThenable(thenableState, thenable, index);\n    }\n    function unsupportedRefresh() {\n      throw Error(\"Cache cannot be refreshed during server rendering.\");\n    }\n    function noop$1() {}\n    function disabledLog() {}\n    function disableLogs() {\n      if (0 === disabledDepth) {\n        prevLog = console.log;\n        prevInfo = console.info;\n        prevWarn = console.warn;\n        prevError = console.error;\n        prevGroup = console.group;\n        prevGroupCollapsed = console.groupCollapsed;\n        prevGroupEnd = console.groupEnd;\n        var props = {\n          configurable: !0,\n          enumerable: !0,\n          value: disabledLog,\n          writable: !0\n        };\n        Object.defineProperties(console, {\n          info: props,\n          log: props,\n          warn: props,\n          error: props,\n          group: props,\n          groupCollapsed: props,\n          groupEnd: props\n        });\n      }\n      disabledDepth++;\n    }\n    function reenableLogs() {\n      disabledDepth--;\n      if (0 === disabledDepth) {\n        var props = { configurable: !0, enumerable: !0, writable: !0 };\n        Object.defineProperties(console, {\n          log: assign({}, props, { value: prevLog }),\n          info: assign({}, props, { value: prevInfo }),\n          warn: assign({}, props, { value: prevWarn }),\n          error: assign({}, props, { value: prevError }),\n          group: assign({}, props, { value: prevGroup }),\n          groupCollapsed: assign({}, props, { value: prevGroupCollapsed }),\n          groupEnd: assign({}, props, { value: prevGroupEnd })\n        });\n      }\n      0 > disabledDepth &&\n        console.error(\n          \"disabledDepth fell below zero. This is a bug in React. Please file an issue.\"\n        );\n    }\n    function describeBuiltInComponentFrame(name) {\n      if (void 0 === prefix)\n        try {\n          throw Error();\n        } catch (x) {\n          var match = x.stack.trim().match(/\\n( *(at )?)/);\n          prefix = (match && match[1]) || \"\";\n          suffix =\n            -1 < x.stack.indexOf(\"\\n    at\")\n              ? \" (<anonymous>)\"\n              : -1 < x.stack.indexOf(\"@\")\n                ? \"@unknown:0:0\"\n                : \"\";\n        }\n      return \"\\n\" + prefix + name + suffix;\n    }\n    function describeNativeComponentFrame(fn, construct) {\n      if (!fn || reentry) return \"\";\n      var frame = componentFrameCache.get(fn);\n      if (void 0 !== frame) return frame;\n      reentry = !0;\n      frame = Error.prepareStackTrace;\n      Error.prepareStackTrace = void 0;\n      var previousDispatcher = null;\n      previousDispatcher = ReactSharedInternals.H;\n      ReactSharedInternals.H = null;\n      disableLogs();\n      try {\n        var RunInRootFrame = {\n          DetermineComponentFrameRoot: function () {\n            try {\n              if (construct) {\n                var Fake = function () {\n                  throw Error();\n                };\n                Object.defineProperty(Fake.prototype, \"props\", {\n                  set: function () {\n                    throw Error();\n                  }\n                });\n                if (\"object\" === typeof Reflect && Reflect.construct) {\n                  try {\n                    Reflect.construct(Fake, []);\n                  } catch (x) {\n                    var control = x;\n                  }\n                  Reflect.construct(fn, [], Fake);\n                } else {\n                  try {\n                    Fake.call();\n                  } catch (x$0) {\n                    control = x$0;\n                  }\n                  fn.call(Fake.prototype);\n                }\n              } else {\n                try {\n                  throw Error();\n                } catch (x$1) {\n                  control = x$1;\n                }\n                (Fake = fn()) &&\n                  \"function\" === typeof Fake.catch &&\n                  Fake.catch(function () {});\n              }\n            } catch (sample) {\n              if (sample && control && \"string\" === typeof sample.stack)\n                return [sample.stack, control.stack];\n            }\n            return [null, null];\n          }\n        };\n        RunInRootFrame.DetermineComponentFrameRoot.displayName =\n          \"DetermineComponentFrameRoot\";\n        var namePropDescriptor = Object.getOwnPropertyDescriptor(\n          RunInRootFrame.DetermineComponentFrameRoot,\n          \"name\"\n        );\n        namePropDescriptor &&\n          namePropDescriptor.configurable &&\n          Object.defineProperty(\n            RunInRootFrame.DetermineComponentFrameRoot,\n            \"name\",\n            { value: \"DetermineComponentFrameRoot\" }\n          );\n        var _RunInRootFrame$Deter =\n            RunInRootFrame.DetermineComponentFrameRoot(),\n          sampleStack = _RunInRootFrame$Deter[0],\n          controlStack = _RunInRootFrame$Deter[1];\n        if (sampleStack && controlStack) {\n          var sampleLines = sampleStack.split(\"\\n\"),\n            controlLines = controlStack.split(\"\\n\");\n          for (\n            _RunInRootFrame$Deter = namePropDescriptor = 0;\n            namePropDescriptor < sampleLines.length &&\n            !sampleLines[namePropDescriptor].includes(\n              \"DetermineComponentFrameRoot\"\n            );\n\n          )\n            namePropDescriptor++;\n          for (\n            ;\n            _RunInRootFrame$Deter < controlLines.length &&\n            !controlLines[_RunInRootFrame$Deter].includes(\n              \"DetermineComponentFrameRoot\"\n            );\n\n          )\n            _RunInRootFrame$Deter++;\n          if (\n            namePropDescriptor === sampleLines.length ||\n            _RunInRootFrame$Deter === controlLines.length\n          )\n            for (\n              namePropDescriptor = sampleLines.length - 1,\n                _RunInRootFrame$Deter = controlLines.length - 1;\n              1 <= namePropDescriptor &&\n              0 <= _RunInRootFrame$Deter &&\n              sampleLines[namePropDescriptor] !==\n                controlLines[_RunInRootFrame$Deter];\n\n            )\n              _RunInRootFrame$Deter--;\n          for (\n            ;\n            1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter;\n            namePropDescriptor--, _RunInRootFrame$Deter--\n          )\n            if (\n              sampleLines[namePropDescriptor] !==\n              controlLines[_RunInRootFrame$Deter]\n            ) {\n              if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {\n                do\n                  if (\n                    (namePropDescriptor--,\n                    _RunInRootFrame$Deter--,\n                    0 > _RunInRootFrame$Deter ||\n                      sampleLines[namePropDescriptor] !==\n                        controlLines[_RunInRootFrame$Deter])\n                  ) {\n                    var _frame =\n                      \"\\n\" +\n                      sampleLines[namePropDescriptor].replace(\n                        \" at new \",\n                        \" at \"\n                      );\n                    fn.displayName &&\n                      _frame.includes(\"<anonymous>\") &&\n                      (_frame = _frame.replace(\"<anonymous>\", fn.displayName));\n                    \"function\" === typeof fn &&\n                      componentFrameCache.set(fn, _frame);\n                    return _frame;\n                  }\n                while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);\n              }\n              break;\n            }\n        }\n      } finally {\n        (reentry = !1),\n          (ReactSharedInternals.H = previousDispatcher),\n          reenableLogs(),\n          (Error.prepareStackTrace = frame);\n      }\n      sampleLines = (sampleLines = fn ? fn.displayName || fn.name : \"\")\n        ? describeBuiltInComponentFrame(sampleLines)\n        : \"\";\n      \"function\" === typeof fn && componentFrameCache.set(fn, sampleLines);\n      return sampleLines;\n    }\n    function describeComponentStackByType(type) {\n      if (\"string\" === typeof type) return describeBuiltInComponentFrame(type);\n      if (\"function\" === typeof type)\n        return type.prototype && type.prototype.isReactComponent\n          ? ((type = describeNativeComponentFrame(type, !0)), type)\n          : describeNativeComponentFrame(type, !1);\n      if (\"object\" === typeof type && null !== type) {\n        switch (type.$$typeof) {\n          case REACT_FORWARD_REF_TYPE:\n            return describeNativeComponentFrame(type.render, !1);\n          case REACT_MEMO_TYPE:\n            return describeNativeComponentFrame(type.type, !1);\n          case REACT_LAZY_TYPE:\n            var lazyComponent = type,\n              payload = lazyComponent._payload;\n            lazyComponent = lazyComponent._init;\n            try {\n              type = lazyComponent(payload);\n            } catch (x) {\n              return describeBuiltInComponentFrame(\"Lazy\");\n            }\n            return describeComponentStackByType(type);\n        }\n        if (\"string\" === typeof type.name)\n          return (\n            (payload = type.env),\n            describeBuiltInComponentFrame(\n              type.name + (payload ? \" [\" + payload + \"]\" : \"\")\n            )\n          );\n      }\n      switch (type) {\n        case REACT_SUSPENSE_LIST_TYPE:\n          return describeBuiltInComponentFrame(\"SuspenseList\");\n        case REACT_SUSPENSE_TYPE:\n          return describeBuiltInComponentFrame(\"Suspense\");\n      }\n      return \"\";\n    }\n    function getStackByComponentStackNode(componentStack) {\n      try {\n        var info = \"\";\n        do\n          (info += describeComponentStackByType(componentStack.type)),\n            (componentStack = componentStack.parent);\n        while (componentStack);\n        return info;\n      } catch (x) {\n        return \"\\nError generating stack: \" + x.message + \"\\n\" + x.stack;\n      }\n    }\n    function defaultErrorHandler(error) {\n      if (\n        \"object\" === typeof error &&\n        null !== error &&\n        \"string\" === typeof error.environmentName\n      ) {\n        var JSCompiler_inline_result = error.environmentName;\n        error = [error].slice(0);\n        \"string\" === typeof error[0]\n          ? error.splice(\n              0,\n              1,\n              \"%c%s%c \" + error[0],\n              \"background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px\",\n              \" \" + JSCompiler_inline_result + \" \",\n              \"\"\n            )\n          : error.splice(\n              0,\n              0,\n              \"%c%s%c \",\n              \"background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px\",\n              \" \" + JSCompiler_inline_result + \" \",\n              \"\"\n            );\n        error.unshift(console);\n        JSCompiler_inline_result = bind.apply(console.error, error);\n        JSCompiler_inline_result();\n      } else console.error(error);\n      return null;\n    }\n    function noop() {}\n    function RequestInstance(\n      resumableState,\n      renderState,\n      rootFormatContext,\n      progressiveChunkSize,\n      onError,\n      onAllReady,\n      onShellReady,\n      onShellError,\n      onFatalError,\n      onPostpone,\n      formState\n    ) {\n      var abortSet = new Set();\n      this.destination = null;\n      this.flushScheduled = !1;\n      this.resumableState = resumableState;\n      this.renderState = renderState;\n      this.rootFormatContext = rootFormatContext;\n      this.progressiveChunkSize =\n        void 0 === progressiveChunkSize ? 12800 : progressiveChunkSize;\n      this.status = 10;\n      this.fatalError = null;\n      this.pendingRootTasks = this.allPendingTasks = this.nextSegmentId = 0;\n      this.completedRootSegment = null;\n      this.abortableTasks = abortSet;\n      this.pingedTasks = [];\n      this.clientRenderedBoundaries = [];\n      this.completedBoundaries = [];\n      this.partialBoundaries = [];\n      this.trackedPostpones = null;\n      this.onError = void 0 === onError ? defaultErrorHandler : onError;\n      this.onPostpone = void 0 === onPostpone ? noop : onPostpone;\n      this.onAllReady = void 0 === onAllReady ? noop : onAllReady;\n      this.onShellReady = void 0 === onShellReady ? noop : onShellReady;\n      this.onShellError = void 0 === onShellError ? noop : onShellError;\n      this.onFatalError = void 0 === onFatalError ? noop : onFatalError;\n      this.formState = void 0 === formState ? null : formState;\n      this.didWarnForKey = null;\n    }\n    function createRequest(\n      children,\n      resumableState,\n      renderState,\n      rootFormatContext,\n      progressiveChunkSize,\n      onError,\n      onAllReady,\n      onShellReady,\n      onShellError,\n      onFatalError,\n      onPostpone,\n      formState\n    ) {\n      resumableState = new RequestInstance(\n        resumableState,\n        renderState,\n        rootFormatContext,\n        progressiveChunkSize,\n        onError,\n        onAllReady,\n        onShellReady,\n        onShellError,\n        onFatalError,\n        onPostpone,\n        formState\n      );\n      renderState = createPendingSegment(\n        resumableState,\n        0,\n        null,\n        rootFormatContext,\n        !1,\n        !1\n      );\n      renderState.parentFlushed = !0;\n      children = createRenderTask(\n        resumableState,\n        null,\n        children,\n        -1,\n        null,\n        renderState,\n        null,\n        resumableState.abortableTasks,\n        null,\n        rootFormatContext,\n        null,\n        emptyTreeContext,\n        null,\n        !1\n      );\n      pushComponentStack(children);\n      resumableState.pingedTasks.push(children);\n      return resumableState;\n    }\n    function createPrerenderRequest(\n      children,\n      resumableState,\n      renderState,\n      rootFormatContext,\n      progressiveChunkSize,\n      onError,\n      onAllReady,\n      onShellReady,\n      onShellError,\n      onFatalError,\n      onPostpone\n    ) {\n      children = createRequest(\n        children,\n        resumableState,\n        renderState,\n        rootFormatContext,\n        progressiveChunkSize,\n        onError,\n        onAllReady,\n        onShellReady,\n        onShellError,\n        onFatalError,\n        onPostpone,\n        void 0\n      );\n      children.trackedPostpones = {\n        workingMap: new Map(),\n        rootNodes: [],\n        rootSlots: null\n      };\n      return children;\n    }\n    function pingTask(request, task) {\n      request.pingedTasks.push(task);\n      1 === request.pingedTasks.length &&\n        ((request.flushScheduled = null !== request.destination),\n        null !== request.trackedPostpones || 10 === request.status\n          ? scheduleMicrotask(function () {\n              return performWork(request);\n            })\n          : scheduleWork(function () {\n              return performWork(request);\n            }));\n    }\n    function createSuspenseBoundary(request, fallbackAbortableTasks) {\n      return {\n        status: PENDING,\n        rootSegmentID: -1,\n        parentFlushed: !1,\n        pendingTasks: 0,\n        completedSegments: [],\n        byteSize: 0,\n        fallbackAbortableTasks: fallbackAbortableTasks,\n        errorDigest: null,\n        contentState: createHoistableState(),\n        fallbackState: createHoistableState(),\n        trackedContentKeyPath: null,\n        trackedFallbackNode: null,\n        errorMessage: null,\n        errorStack: null,\n        errorComponentStack: null\n      };\n    }\n    function createRenderTask(\n      request,\n      thenableState,\n      node,\n      childIndex,\n      blockedBoundary,\n      blockedSegment,\n      hoistableState,\n      abortSet,\n      keyPath,\n      formatContext,\n      context,\n      treeContext,\n      componentStack,\n      isFallback\n    ) {\n      request.allPendingTasks++;\n      null === blockedBoundary\n        ? request.pendingRootTasks++\n        : blockedBoundary.pendingTasks++;\n      var task = {\n        replay: null,\n        node: node,\n        childIndex: childIndex,\n        ping: function () {\n          return pingTask(request, task);\n        },\n        blockedBoundary: blockedBoundary,\n        blockedSegment: blockedSegment,\n        hoistableState: hoistableState,\n        abortSet: abortSet,\n        keyPath: keyPath,\n        formatContext: formatContext,\n        context: context,\n        treeContext: treeContext,\n        componentStack: componentStack,\n        thenableState: thenableState,\n        isFallback: isFallback\n      };\n      abortSet.add(task);\n      return task;\n    }\n    function createReplayTask(\n      request,\n      thenableState,\n      replay,\n      node,\n      childIndex,\n      blockedBoundary,\n      hoistableState,\n      abortSet,\n      keyPath,\n      formatContext,\n      context,\n      treeContext,\n      componentStack,\n      isFallback\n    ) {\n      request.allPendingTasks++;\n      null === blockedBoundary\n        ? request.pendingRootTasks++\n        : blockedBoundary.pendingTasks++;\n      replay.pendingTasks++;\n      var task = {\n        replay: replay,\n        node: node,\n        childIndex: childIndex,\n        ping: function () {\n          return pingTask(request, task);\n        },\n        blockedBoundary: blockedBoundary,\n        blockedSegment: null,\n        hoistableState: hoistableState,\n        abortSet: abortSet,\n        keyPath: keyPath,\n        formatContext: formatContext,\n        context: context,\n        treeContext: treeContext,\n        componentStack: componentStack,\n        thenableState: thenableState,\n        isFallback: isFallback\n      };\n      abortSet.add(task);\n      return task;\n    }\n    function createPendingSegment(\n      request,\n      index,\n      boundary,\n      parentFormatContext,\n      lastPushedText,\n      textEmbedded\n    ) {\n      return {\n        status: PENDING,\n        id: -1,\n        index: index,\n        parentFlushed: !1,\n        chunks: [],\n        children: [],\n        parentFormatContext: parentFormatContext,\n        boundary: boundary,\n        lastPushedText: lastPushedText,\n        textEmbedded: textEmbedded\n      };\n    }\n    function getCurrentStackInDEV() {\n      return null === currentTaskInDEV ||\n        null === currentTaskInDEV.componentStack\n        ? \"\"\n        : getStackByComponentStackNode(currentTaskInDEV.componentStack);\n    }\n    function pushServerComponentStack(task, debugInfo) {\n      if (null != debugInfo)\n        for (var i = 0; i < debugInfo.length; i++) {\n          var componentInfo = debugInfo[i];\n          \"string\" === typeof componentInfo.name &&\n            (task.componentStack = {\n              parent: task.componentStack,\n              type: componentInfo,\n              owner: componentInfo.owner,\n              stack: null\n            });\n        }\n    }\n    function pushComponentStack(task) {\n      var node = task.node;\n      if (\"object\" === typeof node && null !== node)\n        switch (node.$$typeof) {\n          case REACT_ELEMENT_TYPE:\n            var type = node.type,\n              owner = node._owner;\n            pushServerComponentStack(task, node._debugInfo);\n            task.componentStack = {\n              parent: task.componentStack,\n              type: type,\n              owner: owner,\n              stack: null\n            };\n            break;\n          case REACT_LAZY_TYPE:\n            pushServerComponentStack(task, node._debugInfo);\n            break;\n          default:\n            \"function\" === typeof node.then &&\n              pushServerComponentStack(task, node._debugInfo);\n        }\n    }\n    function getThrownInfo(node) {\n      var errorInfo = {};\n      node &&\n        Object.defineProperty(errorInfo, \"componentStack\", {\n          configurable: !0,\n          enumerable: !0,\n          get: function () {\n            var stack = getStackByComponentStackNode(node);\n            Object.defineProperty(errorInfo, \"componentStack\", {\n              value: stack\n            });\n            return stack;\n          }\n        });\n      return errorInfo;\n    }\n    function encodeErrorForBoundary(\n      boundary,\n      digest,\n      error,\n      thrownInfo,\n      wasAborted\n    ) {\n      boundary.errorDigest = digest;\n      error instanceof Error\n        ? ((digest = String(error.message)), (error = String(error.stack)))\n        : ((digest =\n            \"object\" === typeof error && null !== error\n              ? describeObjectForErrorMessage(error)\n              : String(error)),\n          (error = null));\n      wasAborted = wasAborted\n        ? \"Switched to client rendering because the server rendering aborted due to:\\n\\n\"\n        : \"Switched to client rendering because the server rendering errored:\\n\\n\";\n      boundary.errorMessage = wasAborted + digest;\n      boundary.errorStack = null !== error ? wasAborted + error : null;\n      boundary.errorComponentStack = thrownInfo.componentStack;\n    }\n    function logRecoverableError(request, error, errorInfo) {\n      request = request.onError;\n      error = request(error, errorInfo);\n      if (null != error && \"string\" !== typeof error)\n        console.error(\n          'onError returned something with a type other than \"string\". onError should return a string and may return null or undefined but must not return anything else. It received something of type \"%s\" instead',\n          typeof error\n        );\n      else return error;\n    }\n    function fatalError(request, error) {\n      var onShellError = request.onShellError,\n        onFatalError = request.onFatalError;\n      onShellError(error);\n      onFatalError(error);\n      null !== request.destination\n        ? ((request.status = CLOSED),\n          closeWithError(request.destination, error))\n        : ((request.status = 13), (request.fatalError = error));\n    }\n    function renderWithHooks(\n      request,\n      task,\n      keyPath,\n      Component,\n      props,\n      secondArg\n    ) {\n      var prevThenableState = task.thenableState;\n      task.thenableState = null;\n      currentlyRenderingComponent = {};\n      currentlyRenderingTask = task;\n      currentlyRenderingRequest = request;\n      currentlyRenderingKeyPath = keyPath;\n      isInHookUserCodeInDev = !1;\n      actionStateCounter = localIdCounter = 0;\n      actionStateMatchingIndex = -1;\n      thenableIndexCounter = 0;\n      thenableState = prevThenableState;\n      for (\n        request = callComponentInDEV(Component, props, secondArg);\n        didScheduleRenderPhaseUpdate;\n\n      )\n        (didScheduleRenderPhaseUpdate = !1),\n          (actionStateCounter = localIdCounter = 0),\n          (actionStateMatchingIndex = -1),\n          (thenableIndexCounter = 0),\n          (numberOfReRenders += 1),\n          (workInProgressHook = null),\n          (request = Component(props, secondArg));\n      resetHooksState();\n      return request;\n    }\n    function finishFunctionComponent(\n      request,\n      task,\n      keyPath,\n      children,\n      hasId,\n      actionStateCount,\n      actionStateMatchingIndex\n    ) {\n      var didEmitActionStateMarkers = !1;\n      if (0 !== actionStateCount && null !== request.formState) {\n        var segment = task.blockedSegment;\n        if (null !== segment) {\n          didEmitActionStateMarkers = !0;\n          segment = segment.chunks;\n          for (var i = 0; i < actionStateCount; i++)\n            i === actionStateMatchingIndex\n              ? segment.push(formStateMarkerIsMatching)\n              : segment.push(formStateMarkerIsNotMatching);\n        }\n      }\n      actionStateCount = task.keyPath;\n      task.keyPath = keyPath;\n      hasId\n        ? ((keyPath = task.treeContext),\n          (task.treeContext = pushTreeContext(keyPath, 1, 0)),\n          renderNode(request, task, children, -1),\n          (task.treeContext = keyPath))\n        : didEmitActionStateMarkers\n          ? renderNode(request, task, children, -1)\n          : renderNodeDestructive(request, task, children, -1);\n      task.keyPath = actionStateCount;\n    }\n    function renderElement(request, task, keyPath, type, props, ref) {\n      if (\"function\" === typeof type)\n        if (type.prototype && type.prototype.isReactComponent) {\n          var newProps = props;\n          if (\"ref\" in props) {\n            newProps = {};\n            for (var propName in props)\n              \"ref\" !== propName && (newProps[propName] = props[propName]);\n          }\n          var defaultProps = type.defaultProps;\n          if (defaultProps) {\n            newProps === props && (newProps = assign({}, newProps, props));\n            for (var _propName in defaultProps)\n              void 0 === newProps[_propName] &&\n                (newProps[_propName] = defaultProps[_propName]);\n          }\n          var resolvedProps = newProps;\n          var context = emptyContextObject,\n            contextType = type.contextType;\n          if (\n            \"contextType\" in type &&\n            null !== contextType &&\n            (void 0 === contextType ||\n              contextType.$$typeof !== REACT_CONTEXT_TYPE) &&\n            !didWarnAboutInvalidateContextType.has(type)\n          ) {\n            didWarnAboutInvalidateContextType.add(type);\n            var addendum =\n              void 0 === contextType\n                ? \" However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.\"\n                : \"object\" !== typeof contextType\n                  ? \" However, it is set to a \" + typeof contextType + \".\"\n                  : contextType.$$typeof === REACT_CONSUMER_TYPE\n                    ? \" Did you accidentally pass the Context.Consumer instead?\"\n                    : \" However, it is set to an object with keys {\" +\n                      Object.keys(contextType).join(\", \") +\n                      \"}.\";\n            console.error(\n              \"%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s\",\n              getComponentNameFromType(type) || \"Component\",\n              addendum\n            );\n          }\n          \"object\" === typeof contextType &&\n            null !== contextType &&\n            (context = contextType._currentValue);\n          var instance = new type(resolvedProps, context);\n          if (\n            \"function\" === typeof type.getDerivedStateFromProps &&\n            (null === instance.state || void 0 === instance.state)\n          ) {\n            var componentName = getComponentNameFromType(type) || \"Component\";\n            didWarnAboutUninitializedState.has(componentName) ||\n              (didWarnAboutUninitializedState.add(componentName),\n              console.error(\n                \"`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.\",\n                componentName,\n                null === instance.state ? \"null\" : \"undefined\",\n                componentName\n              ));\n          }\n          if (\n            \"function\" === typeof type.getDerivedStateFromProps ||\n            \"function\" === typeof instance.getSnapshotBeforeUpdate\n          ) {\n            var foundWillMountName = null,\n              foundWillReceivePropsName = null,\n              foundWillUpdateName = null;\n            \"function\" === typeof instance.componentWillMount &&\n            !0 !== instance.componentWillMount.__suppressDeprecationWarning\n              ? (foundWillMountName = \"componentWillMount\")\n              : \"function\" === typeof instance.UNSAFE_componentWillMount &&\n                (foundWillMountName = \"UNSAFE_componentWillMount\");\n            \"function\" === typeof instance.componentWillReceiveProps &&\n            !0 !==\n              instance.componentWillReceiveProps.__suppressDeprecationWarning\n              ? (foundWillReceivePropsName = \"componentWillReceiveProps\")\n              : \"function\" ===\n                  typeof instance.UNSAFE_componentWillReceiveProps &&\n                (foundWillReceivePropsName =\n                  \"UNSAFE_componentWillReceiveProps\");\n            \"function\" === typeof instance.componentWillUpdate &&\n            !0 !== instance.componentWillUpdate.__suppressDeprecationWarning\n              ? (foundWillUpdateName = \"componentWillUpdate\")\n              : \"function\" === typeof instance.UNSAFE_componentWillUpdate &&\n                (foundWillUpdateName = \"UNSAFE_componentWillUpdate\");\n            if (\n              null !== foundWillMountName ||\n              null !== foundWillReceivePropsName ||\n              null !== foundWillUpdateName\n            ) {\n              var _componentName =\n                  getComponentNameFromType(type) || \"Component\",\n                newApiName =\n                  \"function\" === typeof type.getDerivedStateFromProps\n                    ? \"getDerivedStateFromProps()\"\n                    : \"getSnapshotBeforeUpdate()\";\n              didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName) ||\n                (didWarnAboutLegacyLifecyclesAndDerivedState.add(\n                  _componentName\n                ),\n                console.error(\n                  \"Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\nThe above lifecycles should be removed. Learn more about this warning here:\\nhttps://react.dev/link/unsafe-component-lifecycles\",\n                  _componentName,\n                  newApiName,\n                  null !== foundWillMountName\n                    ? \"\\n  \" + foundWillMountName\n                    : \"\",\n                  null !== foundWillReceivePropsName\n                    ? \"\\n  \" + foundWillReceivePropsName\n                    : \"\",\n                  null !== foundWillUpdateName\n                    ? \"\\n  \" + foundWillUpdateName\n                    : \"\"\n                ));\n            }\n          }\n          var name = getComponentNameFromType(type) || \"Component\";\n          instance.render ||\n            (type.prototype && \"function\" === typeof type.prototype.render\n              ? console.error(\n                  \"No `render` method found on the %s instance: did you accidentally return an object from the constructor?\",\n                  name\n                )\n              : console.error(\n                  \"No `render` method found on the %s instance: you may have forgotten to define `render`.\",\n                  name\n                ));\n          !instance.getInitialState ||\n            instance.getInitialState.isReactClassApproved ||\n            instance.state ||\n            console.error(\n              \"getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?\",\n              name\n            );\n          instance.getDefaultProps &&\n            !instance.getDefaultProps.isReactClassApproved &&\n            console.error(\n              \"getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.\",\n              name\n            );\n          instance.contextType &&\n            console.error(\n              \"contextType was defined as an instance property on %s. Use a static property to define contextType instead.\",\n              name\n            );\n          type.childContextTypes &&\n            !didWarnAboutChildContextTypes.has(type) &&\n            (didWarnAboutChildContextTypes.add(type),\n            console.error(\n              \"%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)\",\n              name\n            ));\n          type.contextTypes &&\n            !didWarnAboutContextTypes$1.has(type) &&\n            (didWarnAboutContextTypes$1.add(type),\n            console.error(\n              \"%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)\",\n              name\n            ));\n          \"function\" === typeof instance.componentShouldUpdate &&\n            console.error(\n              \"%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.\",\n              name\n            );\n          type.prototype &&\n            type.prototype.isPureReactComponent &&\n            \"undefined\" !== typeof instance.shouldComponentUpdate &&\n            console.error(\n              \"%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.\",\n              getComponentNameFromType(type) || \"A pure component\"\n            );\n          \"function\" === typeof instance.componentDidUnmount &&\n            console.error(\n              \"%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?\",\n              name\n            );\n          \"function\" === typeof instance.componentDidReceiveProps &&\n            console.error(\n              \"%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().\",\n              name\n            );\n          \"function\" === typeof instance.componentWillRecieveProps &&\n            console.error(\n              \"%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?\",\n              name\n            );\n          \"function\" === typeof instance.UNSAFE_componentWillRecieveProps &&\n            console.error(\n              \"%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?\",\n              name\n            );\n          var hasMutatedProps = instance.props !== resolvedProps;\n          void 0 !== instance.props &&\n            hasMutatedProps &&\n            console.error(\n              \"When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.\",\n              name\n            );\n          instance.defaultProps &&\n            console.error(\n              \"Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.\",\n              name,\n              name\n            );\n          \"function\" !== typeof instance.getSnapshotBeforeUpdate ||\n            \"function\" === typeof instance.componentDidUpdate ||\n            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(type) ||\n            (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(type),\n            console.error(\n              \"%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.\",\n              getComponentNameFromType(type)\n            ));\n          \"function\" === typeof instance.getDerivedStateFromProps &&\n            console.error(\n              \"%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.\",\n              name\n            );\n          \"function\" === typeof instance.getDerivedStateFromError &&\n            console.error(\n              \"%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.\",\n              name\n            );\n          \"function\" === typeof type.getSnapshotBeforeUpdate &&\n            console.error(\n              \"%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.\",\n              name\n            );\n          var state = instance.state;\n          state &&\n            (\"object\" !== typeof state || isArrayImpl(state)) &&\n            console.error(\"%s.state: must be set to an object or null\", name);\n          \"function\" === typeof instance.getChildContext &&\n            \"object\" !== typeof type.childContextTypes &&\n            console.error(\n              \"%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().\",\n              name\n            );\n          var initialState = void 0 !== instance.state ? instance.state : null;\n          instance.updater = classComponentUpdater;\n          instance.props = resolvedProps;\n          instance.state = initialState;\n          var internalInstance = { queue: [], replace: !1 };\n          instance._reactInternals = internalInstance;\n          var contextType$jscomp$0 = type.contextType;\n          instance.context =\n            \"object\" === typeof contextType$jscomp$0 &&\n            null !== contextType$jscomp$0\n              ? contextType$jscomp$0._currentValue\n              : emptyContextObject;\n          if (instance.state === resolvedProps) {\n            var componentName$jscomp$0 =\n              getComponentNameFromType(type) || \"Component\";\n            didWarnAboutDirectlyAssigningPropsToState.has(\n              componentName$jscomp$0\n            ) ||\n              (didWarnAboutDirectlyAssigningPropsToState.add(\n                componentName$jscomp$0\n              ),\n              console.error(\n                \"%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.\",\n                componentName$jscomp$0\n              ));\n          }\n          var getDerivedStateFromProps = type.getDerivedStateFromProps;\n          if (\"function\" === typeof getDerivedStateFromProps) {\n            var partialState = getDerivedStateFromProps(\n              resolvedProps,\n              initialState\n            );\n            if (void 0 === partialState) {\n              var componentName$jscomp$1 =\n                getComponentNameFromType(type) || \"Component\";\n              didWarnAboutUndefinedDerivedState.has(componentName$jscomp$1) ||\n                (didWarnAboutUndefinedDerivedState.add(componentName$jscomp$1),\n                console.error(\n                  \"%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.\",\n                  componentName$jscomp$1\n                ));\n            }\n            var JSCompiler_inline_result =\n              null === partialState || void 0 === partialState\n                ? initialState\n                : assign({}, initialState, partialState);\n            instance.state = JSCompiler_inline_result;\n          }\n          if (\n            \"function\" !== typeof type.getDerivedStateFromProps &&\n            \"function\" !== typeof instance.getSnapshotBeforeUpdate &&\n            (\"function\" === typeof instance.UNSAFE_componentWillMount ||\n              \"function\" === typeof instance.componentWillMount)\n          ) {\n            var oldState = instance.state;\n            if (\"function\" === typeof instance.componentWillMount) {\n              if (\n                !0 !== instance.componentWillMount.__suppressDeprecationWarning\n              ) {\n                var componentName$jscomp$2 =\n                  getComponentNameFromType(type) || \"Unknown\";\n                didWarnAboutDeprecatedWillMount[componentName$jscomp$2] ||\n                  (console.warn(\n                    \"componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.\\n\\nPlease update the following components: %s\",\n                    componentName$jscomp$2\n                  ),\n                  (didWarnAboutDeprecatedWillMount[componentName$jscomp$2] =\n                    !0));\n              }\n              instance.componentWillMount();\n            }\n            \"function\" === typeof instance.UNSAFE_componentWillMount &&\n              instance.UNSAFE_componentWillMount();\n            oldState !== instance.state &&\n              (console.error(\n                \"%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.\",\n                getComponentNameFromType(type) || \"Component\"\n              ),\n              classComponentUpdater.enqueueReplaceState(\n                instance,\n                instance.state,\n                null\n              ));\n            if (\n              null !== internalInstance.queue &&\n              0 < internalInstance.queue.length\n            ) {\n              var oldQueue = internalInstance.queue,\n                oldReplace = internalInstance.replace;\n              internalInstance.queue = null;\n              internalInstance.replace = !1;\n              if (oldReplace && 1 === oldQueue.length)\n                instance.state = oldQueue[0];\n              else {\n                for (\n                  var nextState = oldReplace ? oldQueue[0] : instance.state,\n                    dontMutate = !0,\n                    i = oldReplace ? 1 : 0;\n                  i < oldQueue.length;\n                  i++\n                ) {\n                  var partial = oldQueue[i],\n                    partialState$jscomp$0 =\n                      \"function\" === typeof partial\n                        ? partial.call(\n                            instance,\n                            nextState,\n                            resolvedProps,\n                            void 0\n                          )\n                        : partial;\n                  null != partialState$jscomp$0 &&\n                    (dontMutate\n                      ? ((dontMutate = !1),\n                        (nextState = assign(\n                          {},\n                          nextState,\n                          partialState$jscomp$0\n                        )))\n                      : assign(nextState, partialState$jscomp$0));\n                }\n                instance.state = nextState;\n              }\n            } else internalInstance.queue = null;\n          }\n          var nextChildren = callRenderInDEV(instance);\n          if (12 === request.status) throw null;\n          instance.props !== resolvedProps &&\n            (didWarnAboutReassigningProps ||\n              console.error(\n                \"It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.\",\n                getComponentNameFromType(type) || \"a component\"\n              ),\n            (didWarnAboutReassigningProps = !0));\n          var prevKeyPath = task.keyPath;\n          task.keyPath = keyPath;\n          renderNodeDestructive(request, task, nextChildren, -1);\n          task.keyPath = prevKeyPath;\n        } else {\n          if (type.prototype && \"function\" === typeof type.prototype.render) {\n            var componentName$jscomp$3 =\n              getComponentNameFromType(type) || \"Unknown\";\n            didWarnAboutBadClass[componentName$jscomp$3] ||\n              (console.error(\n                \"The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.\",\n                componentName$jscomp$3,\n                componentName$jscomp$3\n              ),\n              (didWarnAboutBadClass[componentName$jscomp$3] = !0));\n          }\n          var value = renderWithHooks(\n            request,\n            task,\n            keyPath,\n            type,\n            props,\n            void 0\n          );\n          if (12 === request.status) throw null;\n          var hasId = 0 !== localIdCounter,\n            actionStateCount = actionStateCounter,\n            actionStateMatchingIndex$jscomp$0 = actionStateMatchingIndex;\n          if (type.contextTypes) {\n            var _componentName$jscomp$0 =\n              getComponentNameFromType(type) || \"Unknown\";\n            didWarnAboutContextTypes[_componentName$jscomp$0] ||\n              ((didWarnAboutContextTypes[_componentName$jscomp$0] = !0),\n              console.error(\n                \"%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)\",\n                _componentName$jscomp$0\n              ));\n          }\n          type &&\n            type.childContextTypes &&\n            console.error(\n              \"childContextTypes cannot be defined on a function component.\\n  %s.childContextTypes = ...\",\n              type.displayName || type.name || \"Component\"\n            );\n          if (\"function\" === typeof type.getDerivedStateFromProps) {\n            var _componentName2 = getComponentNameFromType(type) || \"Unknown\";\n            didWarnAboutGetDerivedStateOnFunctionComponent[_componentName2] ||\n              (console.error(\n                \"%s: Function components do not support getDerivedStateFromProps.\",\n                _componentName2\n              ),\n              (didWarnAboutGetDerivedStateOnFunctionComponent[_componentName2] =\n                !0));\n          }\n          if (\n            \"object\" === typeof type.contextType &&\n            null !== type.contextType\n          ) {\n            var _componentName3 = getComponentNameFromType(type) || \"Unknown\";\n            didWarnAboutContextTypeOnFunctionComponent[_componentName3] ||\n              (console.error(\n                \"%s: Function components do not support contextType.\",\n                _componentName3\n              ),\n              (didWarnAboutContextTypeOnFunctionComponent[_componentName3] =\n                !0));\n          }\n          finishFunctionComponent(\n            request,\n            task,\n            keyPath,\n            value,\n            hasId,\n            actionStateCount,\n            actionStateMatchingIndex$jscomp$0\n          );\n        }\n      else if (\"string\" === typeof type) {\n        var segment = task.blockedSegment;\n        if (null === segment) {\n          var children = props.children,\n            prevContext = task.formatContext,\n            prevKeyPath$jscomp$0 = task.keyPath;\n          task.formatContext = getChildFormatContext(prevContext, type, props);\n          task.keyPath = keyPath;\n          renderNode(request, task, children, -1);\n          task.formatContext = prevContext;\n          task.keyPath = prevKeyPath$jscomp$0;\n        } else {\n          var _children = pushStartInstance(\n            segment.chunks,\n            type,\n            props,\n            request.resumableState,\n            request.renderState,\n            task.hoistableState,\n            task.formatContext,\n            segment.lastPushedText,\n            task.isFallback\n          );\n          segment.lastPushedText = !1;\n          var _prevContext = task.formatContext,\n            _prevKeyPath2 = task.keyPath;\n          task.formatContext = getChildFormatContext(_prevContext, type, props);\n          task.keyPath = keyPath;\n          renderNode(request, task, _children, -1);\n          task.formatContext = _prevContext;\n          task.keyPath = _prevKeyPath2;\n          a: {\n            var target = segment.chunks,\n              resumableState = request.resumableState;\n            switch (type) {\n              case \"title\":\n              case \"style\":\n              case \"script\":\n              case \"area\":\n              case \"base\":\n              case \"br\":\n              case \"col\":\n              case \"embed\":\n              case \"hr\":\n              case \"img\":\n              case \"input\":\n              case \"keygen\":\n              case \"link\":\n              case \"meta\":\n              case \"param\":\n              case \"source\":\n              case \"track\":\n              case \"wbr\":\n                break a;\n              case \"body\":\n                if (_prevContext.insertionMode <= HTML_HTML_MODE) {\n                  resumableState.hasBody = !0;\n                  break a;\n                }\n                break;\n              case \"html\":\n                if (_prevContext.insertionMode === ROOT_HTML_MODE) {\n                  resumableState.hasHtml = !0;\n                  break a;\n                }\n            }\n            target.push(endChunkForTag(type));\n          }\n          segment.lastPushedText = !1;\n        }\n      } else {\n        switch (type) {\n          case REACT_LEGACY_HIDDEN_TYPE:\n          case REACT_DEBUG_TRACING_MODE_TYPE:\n          case REACT_STRICT_MODE_TYPE:\n          case REACT_PROFILER_TYPE:\n          case REACT_FRAGMENT_TYPE:\n            var prevKeyPath$jscomp$1 = task.keyPath;\n            task.keyPath = keyPath;\n            renderNodeDestructive(request, task, props.children, -1);\n            task.keyPath = prevKeyPath$jscomp$1;\n            return;\n          case REACT_OFFSCREEN_TYPE:\n            if (\"hidden\" !== props.mode) {\n              var prevKeyPath$jscomp$2 = task.keyPath;\n              task.keyPath = keyPath;\n              renderNodeDestructive(request, task, props.children, -1);\n              task.keyPath = prevKeyPath$jscomp$2;\n            }\n            return;\n          case REACT_SUSPENSE_LIST_TYPE:\n            var _prevKeyPath3 = task.keyPath;\n            task.keyPath = keyPath;\n            renderNodeDestructive(request, task, props.children, -1);\n            task.keyPath = _prevKeyPath3;\n            return;\n          case REACT_SCOPE_TYPE:\n            throw Error(\n              \"ReactDOMServer does not yet support scope components.\"\n            );\n          case REACT_SUSPENSE_TYPE:\n            a: if (null !== task.replay) {\n              var _prevKeyPath = task.keyPath;\n              task.keyPath = keyPath;\n              var _content = props.children;\n              try {\n                renderNode(request, task, _content, -1);\n              } finally {\n                task.keyPath = _prevKeyPath;\n              }\n            } else {\n              var prevKeyPath$jscomp$3 = task.keyPath,\n                parentBoundary = task.blockedBoundary,\n                parentHoistableState = task.hoistableState,\n                parentSegment = task.blockedSegment,\n                fallback = props.fallback,\n                content = props.children,\n                fallbackAbortSet = new Set(),\n                newBoundary = createSuspenseBoundary(request, fallbackAbortSet);\n              null !== request.trackedPostpones &&\n                (newBoundary.trackedContentKeyPath = keyPath);\n              var boundarySegment = createPendingSegment(\n                request,\n                parentSegment.chunks.length,\n                newBoundary,\n                task.formatContext,\n                !1,\n                !1\n              );\n              parentSegment.children.push(boundarySegment);\n              parentSegment.lastPushedText = !1;\n              var contentRootSegment = createPendingSegment(\n                request,\n                0,\n                null,\n                task.formatContext,\n                !1,\n                !1\n              );\n              contentRootSegment.parentFlushed = !0;\n              if (null !== request.trackedPostpones) {\n                var fallbackKeyPath = [\n                    keyPath[0],\n                    \"Suspense Fallback\",\n                    keyPath[2]\n                  ],\n                  fallbackReplayNode = [\n                    fallbackKeyPath[1],\n                    fallbackKeyPath[2],\n                    [],\n                    null\n                  ];\n                request.trackedPostpones.workingMap.set(\n                  fallbackKeyPath,\n                  fallbackReplayNode\n                );\n                newBoundary.trackedFallbackNode = fallbackReplayNode;\n                task.blockedSegment = boundarySegment;\n                task.keyPath = fallbackKeyPath;\n                boundarySegment.status = 6;\n                try {\n                  renderNode(request, task, fallback, -1),\n                    boundarySegment.lastPushedText &&\n                      boundarySegment.textEmbedded &&\n                      boundarySegment.chunks.push(textSeparator),\n                    (boundarySegment.status = COMPLETED);\n                } catch (thrownValue) {\n                  throw (\n                    ((boundarySegment.status = 12 === request.status ? 3 : 4),\n                    thrownValue)\n                  );\n                } finally {\n                  (task.blockedSegment = parentSegment),\n                    (task.keyPath = prevKeyPath$jscomp$3);\n                }\n                var suspendedPrimaryTask = createRenderTask(\n                  request,\n                  null,\n                  content,\n                  -1,\n                  newBoundary,\n                  contentRootSegment,\n                  newBoundary.contentState,\n                  task.abortSet,\n                  keyPath,\n                  task.formatContext,\n                  task.context,\n                  task.treeContext,\n                  task.componentStack,\n                  task.isFallback\n                );\n                pushComponentStack(suspendedPrimaryTask);\n                request.pingedTasks.push(suspendedPrimaryTask);\n              } else {\n                task.blockedBoundary = newBoundary;\n                task.hoistableState = newBoundary.contentState;\n                task.blockedSegment = contentRootSegment;\n                task.keyPath = keyPath;\n                contentRootSegment.status = 6;\n                try {\n                  if (\n                    (renderNode(request, task, content, -1),\n                    contentRootSegment.lastPushedText &&\n                      contentRootSegment.textEmbedded &&\n                      contentRootSegment.chunks.push(textSeparator),\n                    (contentRootSegment.status = COMPLETED),\n                    queueCompletedSegment(newBoundary, contentRootSegment),\n                    0 === newBoundary.pendingTasks &&\n                      newBoundary.status === PENDING)\n                  ) {\n                    newBoundary.status = COMPLETED;\n                    break a;\n                  }\n                } catch (thrownValue$2) {\n                  newBoundary.status = CLIENT_RENDERED;\n                  if (12 === request.status) {\n                    contentRootSegment.status = 3;\n                    var error = request.fatalError;\n                  } else\n                    (contentRootSegment.status = 4), (error = thrownValue$2);\n                  var thrownInfo = getThrownInfo(task.componentStack);\n                  var errorDigest = logRecoverableError(\n                    request,\n                    error,\n                    thrownInfo\n                  );\n                  encodeErrorForBoundary(\n                    newBoundary,\n                    errorDigest,\n                    error,\n                    thrownInfo,\n                    !1\n                  );\n                  untrackBoundary(request, newBoundary);\n                } finally {\n                  (task.blockedBoundary = parentBoundary),\n                    (task.hoistableState = parentHoistableState),\n                    (task.blockedSegment = parentSegment),\n                    (task.keyPath = prevKeyPath$jscomp$3);\n                }\n                var suspendedFallbackTask = createRenderTask(\n                  request,\n                  null,\n                  fallback,\n                  -1,\n                  parentBoundary,\n                  boundarySegment,\n                  newBoundary.fallbackState,\n                  fallbackAbortSet,\n                  [keyPath[0], \"Suspense Fallback\", keyPath[2]],\n                  task.formatContext,\n                  task.context,\n                  task.treeContext,\n                  task.componentStack,\n                  !0\n                );\n                pushComponentStack(suspendedFallbackTask);\n                request.pingedTasks.push(suspendedFallbackTask);\n              }\n            }\n            return;\n        }\n        if (\"object\" === typeof type && null !== type)\n          switch (type.$$typeof) {\n            case REACT_FORWARD_REF_TYPE:\n              if (\"ref\" in props) {\n                var propsWithoutRef = {};\n                for (var key in props)\n                  \"ref\" !== key && (propsWithoutRef[key] = props[key]);\n              } else propsWithoutRef = props;\n              var children$jscomp$0 = renderWithHooks(\n                request,\n                task,\n                keyPath,\n                type.render,\n                propsWithoutRef,\n                ref\n              );\n              finishFunctionComponent(\n                request,\n                task,\n                keyPath,\n                children$jscomp$0,\n                0 !== localIdCounter,\n                actionStateCounter,\n                actionStateMatchingIndex\n              );\n              return;\n            case REACT_MEMO_TYPE:\n              renderElement(request, task, keyPath, type.type, props, ref);\n              return;\n            case REACT_PROVIDER_TYPE:\n            case REACT_CONTEXT_TYPE:\n              var value$jscomp$0 = props.value,\n                children$jscomp$1 = props.children;\n              var prevSnapshot = task.context;\n              var prevKeyPath$jscomp$4 = task.keyPath;\n              var prevValue = type._currentValue;\n              type._currentValue = value$jscomp$0;\n              void 0 !== type._currentRenderer &&\n                null !== type._currentRenderer &&\n                type._currentRenderer !== rendererSigil &&\n                console.error(\n                  \"Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.\"\n                );\n              type._currentRenderer = rendererSigil;\n              var prevNode = currentActiveSnapshot,\n                newNode = {\n                  parent: prevNode,\n                  depth: null === prevNode ? 0 : prevNode.depth + 1,\n                  context: type,\n                  parentValue: prevValue,\n                  value: value$jscomp$0\n                };\n              currentActiveSnapshot = newNode;\n              task.context = newNode;\n              task.keyPath = keyPath;\n              renderNodeDestructive(request, task, children$jscomp$1, -1);\n              var prevSnapshot$jscomp$0 = currentActiveSnapshot;\n              if (null === prevSnapshot$jscomp$0)\n                throw Error(\n                  \"Tried to pop a Context at the root of the app. This is a bug in React.\"\n                );\n              prevSnapshot$jscomp$0.context !== type &&\n                console.error(\n                  \"The parent context is not the expected context. This is probably a bug in React.\"\n                );\n              prevSnapshot$jscomp$0.context._currentValue =\n                prevSnapshot$jscomp$0.parentValue;\n              void 0 !== type._currentRenderer &&\n                null !== type._currentRenderer &&\n                type._currentRenderer !== rendererSigil &&\n                console.error(\n                  \"Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.\"\n                );\n              type._currentRenderer = rendererSigil;\n              var JSCompiler_inline_result$jscomp$0 = (currentActiveSnapshot =\n                prevSnapshot$jscomp$0.parent);\n              task.context = JSCompiler_inline_result$jscomp$0;\n              task.keyPath = prevKeyPath$jscomp$4;\n              prevSnapshot !== task.context &&\n                console.error(\n                  \"Popping the context provider did not return back to the original snapshot. This is a bug in React.\"\n                );\n              return;\n            case REACT_CONSUMER_TYPE:\n              var context$jscomp$0 = type._context,\n                render = props.children;\n              \"function\" !== typeof render &&\n                console.error(\n                  \"A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.\"\n                );\n              var newChildren = render(context$jscomp$0._currentValue),\n                prevKeyPath$jscomp$5 = task.keyPath;\n              task.keyPath = keyPath;\n              renderNodeDestructive(request, task, newChildren, -1);\n              task.keyPath = prevKeyPath$jscomp$5;\n              return;\n            case REACT_LAZY_TYPE:\n              var Component = callLazyInitInDEV(type);\n              if (12 === request.status) throw null;\n              renderElement(request, task, keyPath, Component, props, ref);\n              return;\n          }\n        var info = \"\";\n        if (\n          void 0 === type ||\n          (\"object\" === typeof type &&\n            null !== type &&\n            0 === Object.keys(type).length)\n        )\n          info +=\n            \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\";\n        throw Error(\n          \"Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: \" +\n            ((null == type ? type : typeof type) + \".\" + info)\n        );\n      }\n    }\n    function resumeNode(request, task, segmentId, node, childIndex) {\n      var prevReplay = task.replay,\n        blockedBoundary = task.blockedBoundary,\n        resumedSegment = createPendingSegment(\n          request,\n          0,\n          null,\n          task.formatContext,\n          !1,\n          !1\n        );\n      resumedSegment.id = segmentId;\n      resumedSegment.parentFlushed = !0;\n      try {\n        (task.replay = null),\n          (task.blockedSegment = resumedSegment),\n          renderNode(request, task, node, childIndex),\n          (resumedSegment.status = COMPLETED),\n          null === blockedBoundary\n            ? (request.completedRootSegment = resumedSegment)\n            : (queueCompletedSegment(blockedBoundary, resumedSegment),\n              blockedBoundary.parentFlushed &&\n                request.partialBoundaries.push(blockedBoundary));\n      } finally {\n        (task.replay = prevReplay), (task.blockedSegment = null);\n      }\n    }\n    function renderNodeDestructive(request, task, node, childIndex) {\n      null !== task.replay && \"number\" === typeof task.replay.slots\n        ? resumeNode(request, task, task.replay.slots, node, childIndex)\n        : ((task.node = node),\n          (task.childIndex = childIndex),\n          (node = task.componentStack),\n          pushComponentStack(task),\n          retryNode(request, task),\n          (task.componentStack = node));\n    }\n    function retryNode(request, task) {\n      var node = task.node,\n        childIndex = task.childIndex;\n      if (null !== node) {\n        if (\"object\" === typeof node) {\n          switch (node.$$typeof) {\n            case REACT_ELEMENT_TYPE:\n              var type = node.type,\n                key = node.key,\n                props = node.props;\n              node = props.ref;\n              var ref = void 0 !== node ? node : null,\n                name = getComponentNameFromType(type),\n                keyOrIndex =\n                  null == key ? (-1 === childIndex ? 0 : childIndex) : key,\n                keyPath = [task.keyPath, name, keyOrIndex];\n              if (null !== task.replay) {\n                var replay = task.replay;\n                childIndex = replay.nodes;\n                for (node = 0; node < childIndex.length; node++)\n                  if (((key = childIndex[node]), keyOrIndex === key[1])) {\n                    if (4 === key.length) {\n                      if (null !== name && name !== key[0])\n                        throw Error(\n                          \"Expected the resume to render <\" +\n                            key[0] +\n                            \"> in this slot but instead it rendered <\" +\n                            name +\n                            \">. The tree doesn't match so React will fallback to client rendering.\"\n                        );\n                      var childNodes = key[2];\n                      key = key[3];\n                      name = task.node;\n                      task.replay = {\n                        nodes: childNodes,\n                        slots: key,\n                        pendingTasks: 1\n                      };\n                      try {\n                        renderElement(request, task, keyPath, type, props, ref);\n                        if (\n                          1 === task.replay.pendingTasks &&\n                          0 < task.replay.nodes.length\n                        )\n                          throw Error(\n                            \"Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.\"\n                          );\n                        task.replay.pendingTasks--;\n                      } catch (x) {\n                        if (\n                          \"object\" === typeof x &&\n                          null !== x &&\n                          (x === SuspenseException ||\n                            \"function\" === typeof x.then)\n                        )\n                          throw (\n                            (task.node === name && (task.replay = replay), x)\n                          );\n                        task.replay.pendingTasks--;\n                        props = getThrownInfo(task.componentStack);\n                        erroredReplay(\n                          request,\n                          task.blockedBoundary,\n                          x,\n                          props,\n                          childNodes,\n                          key\n                        );\n                      }\n                      task.replay = replay;\n                    } else {\n                      if (type !== REACT_SUSPENSE_TYPE)\n                        throw Error(\n                          \"Expected the resume to render <Suspense> in this slot but instead it rendered <\" +\n                            (getComponentNameFromType(type) || \"Unknown\") +\n                            \">. The tree doesn't match so React will fallback to client rendering.\"\n                        );\n                      a: {\n                        type = void 0;\n                        ref = key[5];\n                        replay = key[2];\n                        name = key[3];\n                        keyOrIndex = null === key[4] ? [] : key[4][2];\n                        key = null === key[4] ? null : key[4][3];\n                        var prevKeyPath = task.keyPath,\n                          previousReplaySet = task.replay,\n                          parentBoundary = task.blockedBoundary,\n                          parentHoistableState = task.hoistableState,\n                          content = props.children;\n                        props = props.fallback;\n                        var fallbackAbortSet = new Set(),\n                          resumedBoundary = createSuspenseBoundary(\n                            request,\n                            fallbackAbortSet\n                          );\n                        resumedBoundary.parentFlushed = !0;\n                        resumedBoundary.rootSegmentID = ref;\n                        task.blockedBoundary = resumedBoundary;\n                        task.hoistableState = resumedBoundary.contentState;\n                        task.keyPath = keyPath;\n                        task.replay = {\n                          nodes: replay,\n                          slots: name,\n                          pendingTasks: 1\n                        };\n                        try {\n                          renderNode(request, task, content, -1);\n                          if (\n                            1 === task.replay.pendingTasks &&\n                            0 < task.replay.nodes.length\n                          )\n                            throw Error(\n                              \"Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.\"\n                            );\n                          task.replay.pendingTasks--;\n                          if (\n                            0 === resumedBoundary.pendingTasks &&\n                            resumedBoundary.status === PENDING\n                          ) {\n                            resumedBoundary.status = COMPLETED;\n                            request.completedBoundaries.push(resumedBoundary);\n                            break a;\n                          }\n                        } catch (error) {\n                          (resumedBoundary.status = CLIENT_RENDERED),\n                            (childNodes = getThrownInfo(task.componentStack)),\n                            (type = logRecoverableError(\n                              request,\n                              error,\n                              childNodes\n                            )),\n                            encodeErrorForBoundary(\n                              resumedBoundary,\n                              type,\n                              error,\n                              childNodes,\n                              !1\n                            ),\n                            task.replay.pendingTasks--,\n                            request.clientRenderedBoundaries.push(\n                              resumedBoundary\n                            );\n                        } finally {\n                          (task.blockedBoundary = parentBoundary),\n                            (task.hoistableState = parentHoistableState),\n                            (task.replay = previousReplaySet),\n                            (task.keyPath = prevKeyPath);\n                        }\n                        childNodes = createReplayTask(\n                          request,\n                          null,\n                          { nodes: keyOrIndex, slots: key, pendingTasks: 0 },\n                          props,\n                          -1,\n                          parentBoundary,\n                          resumedBoundary.fallbackState,\n                          fallbackAbortSet,\n                          [keyPath[0], \"Suspense Fallback\", keyPath[2]],\n                          task.formatContext,\n                          task.context,\n                          task.treeContext,\n                          task.componentStack,\n                          !0\n                        );\n                        pushComponentStack(childNodes);\n                        request.pingedTasks.push(childNodes);\n                      }\n                    }\n                    childIndex.splice(node, 1);\n                    break;\n                  }\n              } else renderElement(request, task, keyPath, type, props, ref);\n              return;\n            case REACT_PORTAL_TYPE:\n              throw Error(\n                \"Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.\"\n              );\n            case REACT_LAZY_TYPE:\n              node = callLazyInitInDEV(node);\n              if (12 === request.status) throw null;\n              renderNodeDestructive(request, task, node, childIndex);\n              return;\n          }\n          if (isArrayImpl(node)) {\n            renderChildrenArray(request, task, node, childIndex);\n            return;\n          }\n          null === node || \"object\" !== typeof node\n            ? (props = null)\n            : ((childNodes =\n                (MAYBE_ITERATOR_SYMBOL && node[MAYBE_ITERATOR_SYMBOL]) ||\n                node[\"@@iterator\"]),\n              (props = \"function\" === typeof childNodes ? childNodes : null));\n          if (props && (childNodes = props.call(node))) {\n            if (childNodes === node) {\n              if (\n                -1 !== childIndex ||\n                null === task.componentStack ||\n                \"function\" !== typeof task.componentStack.type ||\n                \"[object GeneratorFunction]\" !==\n                  Object.prototype.toString.call(task.componentStack.type) ||\n                \"[object Generator]\" !==\n                  Object.prototype.toString.call(childNodes)\n              )\n                didWarnAboutGenerators ||\n                  console.error(\n                    \"Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items.\"\n                  ),\n                  (didWarnAboutGenerators = !0);\n            } else\n              node.entries !== props ||\n                didWarnAboutMaps ||\n                (console.error(\n                  \"Using Maps as children is not supported. Use an array of keyed ReactElements instead.\"\n                ),\n                (didWarnAboutMaps = !0));\n            node = childNodes.next();\n            if (!node.done) {\n              props = [];\n              do props.push(node.value), (node = childNodes.next());\n              while (!node.done);\n              renderChildrenArray(request, task, props, childIndex);\n            }\n            return;\n          }\n          if (\"function\" === typeof node.then)\n            return (\n              (task.thenableState = null),\n              renderNodeDestructive(\n                request,\n                task,\n                unwrapThenable(node),\n                childIndex\n              )\n            );\n          if (node.$$typeof === REACT_CONTEXT_TYPE)\n            return renderNodeDestructive(\n              request,\n              task,\n              node._currentValue,\n              childIndex\n            );\n          childIndex = Object.prototype.toString.call(node);\n          throw Error(\n            \"Objects are not valid as a React child (found: \" +\n              (\"[object Object]\" === childIndex\n                ? \"object with keys {\" + Object.keys(node).join(\", \") + \"}\"\n                : childIndex) +\n              \"). If you meant to render a collection of children, use an array instead.\"\n          );\n        }\n        \"string\" === typeof node\n          ? ((childIndex = task.blockedSegment),\n            null !== childIndex &&\n              (childIndex.lastPushedText = pushTextInstance(\n                childIndex.chunks,\n                node,\n                request.renderState,\n                childIndex.lastPushedText\n              )))\n          : \"number\" === typeof node || \"bigint\" === typeof node\n            ? ((childIndex = task.blockedSegment),\n              null !== childIndex &&\n                (childIndex.lastPushedText = pushTextInstance(\n                  childIndex.chunks,\n                  \"\" + node,\n                  request.renderState,\n                  childIndex.lastPushedText\n                )))\n            : (\"function\" === typeof node &&\n                ((childIndex = node.displayName || node.name || \"Component\"),\n                console.error(\n                  \"Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\",\n                  childIndex,\n                  childIndex\n                )),\n              \"symbol\" === typeof node &&\n                console.error(\n                  \"Symbols are not valid as a React child.\\n  %s\",\n                  String(node)\n                ));\n      }\n    }\n    function renderChildrenArray(request$jscomp$0, task, children, childIndex) {\n      var prevKeyPath = task.keyPath,\n        previousComponentStack = task.componentStack;\n      pushServerComponentStack(task, task.node._debugInfo);\n      if (\n        -1 !== childIndex &&\n        ((task.keyPath = [task.keyPath, \"Fragment\", childIndex]),\n        null !== task.replay)\n      ) {\n        for (\n          var replay = task.replay, replayNodes = replay.nodes, j = 0;\n          j < replayNodes.length;\n          j++\n        ) {\n          var node = replayNodes[j];\n          if (node[1] === childIndex) {\n            childIndex = node[2];\n            node = node[3];\n            task.replay = { nodes: childIndex, slots: node, pendingTasks: 1 };\n            try {\n              renderChildrenArray(request$jscomp$0, task, children, -1);\n              if (\n                1 === task.replay.pendingTasks &&\n                0 < task.replay.nodes.length\n              )\n                throw Error(\n                  \"Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.\"\n                );\n              task.replay.pendingTasks--;\n            } catch (x) {\n              if (\n                \"object\" === typeof x &&\n                null !== x &&\n                (x === SuspenseException || \"function\" === typeof x.then)\n              )\n                throw x;\n              task.replay.pendingTasks--;\n              children = getThrownInfo(task.componentStack);\n              erroredReplay(\n                request$jscomp$0,\n                task.blockedBoundary,\n                x,\n                children,\n                childIndex,\n                node\n              );\n            }\n            task.replay = replay;\n            replayNodes.splice(j, 1);\n            break;\n          }\n        }\n        task.keyPath = prevKeyPath;\n        task.componentStack = previousComponentStack;\n        return;\n      }\n      replay = task.treeContext;\n      replayNodes = children.length;\n      if (\n        null !== task.replay &&\n        ((j = task.replay.slots), null !== j && \"object\" === typeof j)\n      ) {\n        for (childIndex = 0; childIndex < replayNodes; childIndex++) {\n          node = children[childIndex];\n          task.treeContext = pushTreeContext(replay, replayNodes, childIndex);\n          var resumeSegmentID = j[childIndex];\n          \"number\" === typeof resumeSegmentID\n            ? (resumeNode(\n                request$jscomp$0,\n                task,\n                resumeSegmentID,\n                node,\n                childIndex\n              ),\n              delete j[childIndex])\n            : renderNode(request$jscomp$0, task, node, childIndex);\n        }\n        task.treeContext = replay;\n        task.keyPath = prevKeyPath;\n        task.componentStack = previousComponentStack;\n        return;\n      }\n      for (j = 0; j < replayNodes; j++) {\n        childIndex = children[j];\n        var request = request$jscomp$0;\n        node = task;\n        resumeSegmentID = childIndex;\n        if (\n          null !== resumeSegmentID &&\n          \"object\" === typeof resumeSegmentID &&\n          (resumeSegmentID.$$typeof === REACT_ELEMENT_TYPE ||\n            resumeSegmentID.$$typeof === REACT_PORTAL_TYPE) &&\n          resumeSegmentID._store &&\n          ((!resumeSegmentID._store.validated && null == resumeSegmentID.key) ||\n            2 === resumeSegmentID._store.validated)\n        ) {\n          if (\"object\" !== typeof resumeSegmentID._store)\n            throw Error(\n              \"React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.\"\n            );\n          resumeSegmentID._store.validated = 1;\n          var didWarnForKey = request.didWarnForKey;\n          null == didWarnForKey &&\n            (didWarnForKey = request.didWarnForKey = new WeakSet());\n          request = node.componentStack;\n          if (null !== request && !didWarnForKey.has(request)) {\n            didWarnForKey.add(request);\n            var componentName = getComponentNameFromType(resumeSegmentID.type);\n            didWarnForKey = resumeSegmentID._owner;\n            var parentOwner = request.owner;\n            request = \"\";\n            if (parentOwner && \"undefined\" !== typeof parentOwner.type) {\n              var name = getComponentNameFromType(parentOwner.type);\n              name &&\n                (request = \"\\n\\nCheck the render method of `\" + name + \"`.\");\n            }\n            request ||\n              (componentName &&\n                (request =\n                  \"\\n\\nCheck the top-level render call using <\" +\n                  componentName +\n                  \">.\"));\n            componentName = \"\";\n            null != didWarnForKey &&\n              parentOwner !== didWarnForKey &&\n              ((parentOwner = null),\n              \"undefined\" !== typeof didWarnForKey.type\n                ? (parentOwner = getComponentNameFromType(didWarnForKey.type))\n                : \"string\" === typeof didWarnForKey.name &&\n                  (parentOwner = didWarnForKey.name),\n              parentOwner &&\n                (componentName =\n                  \" It was passed a child from \" + parentOwner + \".\"));\n            didWarnForKey = node.componentStack;\n            node.componentStack = {\n              parent: node.componentStack,\n              type: resumeSegmentID.type,\n              owner: resumeSegmentID._owner,\n              stack: null\n            };\n            console.error(\n              'Each child in a list should have a unique \"key\" prop.%s%s See https://react.dev/link/warning-keys for more information.',\n              request,\n              componentName\n            );\n            node.componentStack = didWarnForKey;\n          }\n        }\n        task.treeContext = pushTreeContext(replay, replayNodes, j);\n        renderNode(request$jscomp$0, task, childIndex, j);\n      }\n      task.treeContext = replay;\n      task.keyPath = prevKeyPath;\n      task.componentStack = previousComponentStack;\n    }\n    function untrackBoundary(request, boundary) {\n      request = request.trackedPostpones;\n      null !== request &&\n        ((boundary = boundary.trackedContentKeyPath),\n        null !== boundary &&\n          ((boundary = request.workingMap.get(boundary)),\n          void 0 !== boundary &&\n            ((boundary.length = 4), (boundary[2] = []), (boundary[3] = null))));\n    }\n    function spawnNewSuspendedReplayTask(request, task, thenableState) {\n      return createReplayTask(\n        request,\n        thenableState,\n        task.replay,\n        task.node,\n        task.childIndex,\n        task.blockedBoundary,\n        task.hoistableState,\n        task.abortSet,\n        task.keyPath,\n        task.formatContext,\n        task.context,\n        task.treeContext,\n        task.componentStack,\n        task.isFallback\n      );\n    }\n    function spawnNewSuspendedRenderTask(request, task, thenableState) {\n      var segment = task.blockedSegment,\n        newSegment = createPendingSegment(\n          request,\n          segment.chunks.length,\n          null,\n          task.formatContext,\n          segment.lastPushedText,\n          !0\n        );\n      segment.children.push(newSegment);\n      segment.lastPushedText = !1;\n      return createRenderTask(\n        request,\n        thenableState,\n        task.node,\n        task.childIndex,\n        task.blockedBoundary,\n        newSegment,\n        task.hoistableState,\n        task.abortSet,\n        task.keyPath,\n        task.formatContext,\n        task.context,\n        task.treeContext,\n        task.componentStack,\n        task.isFallback\n      );\n    }\n    function renderNode(request, task, node, childIndex) {\n      var previousFormatContext = task.formatContext,\n        previousContext = task.context,\n        previousKeyPath = task.keyPath,\n        previousTreeContext = task.treeContext,\n        previousComponentStack = task.componentStack,\n        segment = task.blockedSegment;\n      if (null === segment)\n        try {\n          return renderNodeDestructive(request, task, node, childIndex);\n        } catch (thrownValue) {\n          if (\n            (resetHooksState(),\n            (node =\n              thrownValue === SuspenseException\n                ? getSuspendedThenable()\n                : thrownValue),\n            \"object\" === typeof node && null !== node)\n          ) {\n            if (\"function\" === typeof node.then) {\n              childIndex = getThenableStateAfterSuspending();\n              request = spawnNewSuspendedReplayTask(\n                request,\n                task,\n                childIndex\n              ).ping;\n              node.then(request, request);\n              task.formatContext = previousFormatContext;\n              task.context = previousContext;\n              task.keyPath = previousKeyPath;\n              task.treeContext = previousTreeContext;\n              task.componentStack = previousComponentStack;\n              switchContext(previousContext);\n              return;\n            }\n            if (\"Maximum call stack size exceeded\" === node.message) {\n              node = getThenableStateAfterSuspending();\n              node = spawnNewSuspendedReplayTask(request, task, node);\n              request.pingedTasks.push(node);\n              task.formatContext = previousFormatContext;\n              task.context = previousContext;\n              task.keyPath = previousKeyPath;\n              task.treeContext = previousTreeContext;\n              task.componentStack = previousComponentStack;\n              switchContext(previousContext);\n              return;\n            }\n          }\n        }\n      else {\n        var childrenLength = segment.children.length,\n          chunkLength = segment.chunks.length;\n        try {\n          return renderNodeDestructive(request, task, node, childIndex);\n        } catch (thrownValue$3) {\n          if (\n            (resetHooksState(),\n            (segment.children.length = childrenLength),\n            (segment.chunks.length = chunkLength),\n            (node =\n              thrownValue$3 === SuspenseException\n                ? getSuspendedThenable()\n                : thrownValue$3),\n            \"object\" === typeof node && null !== node)\n          ) {\n            if (\"function\" === typeof node.then) {\n              childIndex = getThenableStateAfterSuspending();\n              request = spawnNewSuspendedRenderTask(\n                request,\n                task,\n                childIndex\n              ).ping;\n              node.then(request, request);\n              task.formatContext = previousFormatContext;\n              task.context = previousContext;\n              task.keyPath = previousKeyPath;\n              task.treeContext = previousTreeContext;\n              task.componentStack = previousComponentStack;\n              switchContext(previousContext);\n              return;\n            }\n            if (\"Maximum call stack size exceeded\" === node.message) {\n              node = getThenableStateAfterSuspending();\n              node = spawnNewSuspendedRenderTask(request, task, node);\n              request.pingedTasks.push(node);\n              task.formatContext = previousFormatContext;\n              task.context = previousContext;\n              task.keyPath = previousKeyPath;\n              task.treeContext = previousTreeContext;\n              task.componentStack = previousComponentStack;\n              switchContext(previousContext);\n              return;\n            }\n          }\n        }\n      }\n      task.formatContext = previousFormatContext;\n      task.context = previousContext;\n      task.keyPath = previousKeyPath;\n      task.treeContext = previousTreeContext;\n      switchContext(previousContext);\n      throw node;\n    }\n    function erroredReplay(\n      request,\n      boundary,\n      error,\n      errorInfo,\n      replayNodes,\n      resumeSlots\n    ) {\n      var errorDigest = logRecoverableError(request, error, errorInfo);\n      abortRemainingReplayNodes(\n        request,\n        boundary,\n        replayNodes,\n        resumeSlots,\n        error,\n        errorDigest,\n        errorInfo,\n        !1\n      );\n    }\n    function abortTaskSoft(task) {\n      var boundary = task.blockedBoundary;\n      task = task.blockedSegment;\n      null !== task && ((task.status = 3), finishedTask(this, boundary, task));\n    }\n    function abortRemainingReplayNodes(\n      request$jscomp$0,\n      boundary,\n      nodes,\n      slots,\n      error$jscomp$0,\n      errorDigest$jscomp$0,\n      errorInfo$jscomp$0,\n      aborted\n    ) {\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        if (4 === node.length)\n          abortRemainingReplayNodes(\n            request$jscomp$0,\n            boundary,\n            node[2],\n            node[3],\n            error$jscomp$0,\n            errorDigest$jscomp$0,\n            errorInfo$jscomp$0,\n            aborted\n          );\n        else {\n          var request = request$jscomp$0;\n          node = node[5];\n          var error = error$jscomp$0,\n            errorDigest = errorDigest$jscomp$0,\n            errorInfo = errorInfo$jscomp$0,\n            wasAborted = aborted,\n            resumedBoundary = createSuspenseBoundary(request, new Set());\n          resumedBoundary.parentFlushed = !0;\n          resumedBoundary.rootSegmentID = node;\n          resumedBoundary.status = CLIENT_RENDERED;\n          encodeErrorForBoundary(\n            resumedBoundary,\n            errorDigest,\n            error,\n            errorInfo,\n            wasAborted\n          );\n          resumedBoundary.parentFlushed &&\n            request.clientRenderedBoundaries.push(resumedBoundary);\n        }\n      }\n      nodes.length = 0;\n      if (null !== slots) {\n        if (null === boundary)\n          throw Error(\n            \"We should not have any resumable nodes in the shell. This is a bug in React.\"\n          );\n        boundary.status !== CLIENT_RENDERED &&\n          ((boundary.status = CLIENT_RENDERED),\n          encodeErrorForBoundary(\n            boundary,\n            errorDigest$jscomp$0,\n            error$jscomp$0,\n            errorInfo$jscomp$0,\n            aborted\n          ),\n          boundary.parentFlushed &&\n            request$jscomp$0.clientRenderedBoundaries.push(boundary));\n        if (\"object\" === typeof slots)\n          for (var index in slots) delete slots[index];\n      }\n    }\n    function abortTask(task, request, error) {\n      var boundary = task.blockedBoundary,\n        segment = task.blockedSegment;\n      if (null !== segment) {\n        if (6 === segment.status) return;\n        segment.status = 3;\n      }\n      segment = getThrownInfo(task.componentStack);\n      if (null === boundary) {\n        if (13 !== request.status && request.status !== CLOSED) {\n          boundary = task.replay;\n          if (null === boundary) {\n            logRecoverableError(request, error, segment);\n            fatalError(request, error);\n            return;\n          }\n          boundary.pendingTasks--;\n          0 === boundary.pendingTasks &&\n            0 < boundary.nodes.length &&\n            ((task = logRecoverableError(request, error, segment)),\n            abortRemainingReplayNodes(\n              request,\n              null,\n              boundary.nodes,\n              boundary.slots,\n              error,\n              task,\n              segment,\n              !0\n            ));\n          request.pendingRootTasks--;\n          0 === request.pendingRootTasks && completeShell(request);\n        }\n      } else\n        boundary.pendingTasks--,\n          boundary.status !== CLIENT_RENDERED &&\n            ((boundary.status = CLIENT_RENDERED),\n            (task = logRecoverableError(request, error, segment)),\n            (boundary.status = CLIENT_RENDERED),\n            encodeErrorForBoundary(boundary, task, error, segment, !0),\n            untrackBoundary(request, boundary),\n            boundary.parentFlushed &&\n              request.clientRenderedBoundaries.push(boundary)),\n          boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {\n            return abortTask(fallbackTask, request, error);\n          }),\n          boundary.fallbackAbortableTasks.clear();\n      request.allPendingTasks--;\n      0 === request.allPendingTasks && completeAll(request);\n    }\n    function safelyEmitEarlyPreloads(request, shellComplete) {\n      try {\n        var renderState = request.renderState,\n          onHeaders = renderState.onHeaders;\n        if (onHeaders) {\n          var headers = renderState.headers;\n          if (headers) {\n            renderState.headers = null;\n            var linkHeader = headers.preconnects;\n            headers.fontPreloads &&\n              (linkHeader && (linkHeader += \", \"),\n              (linkHeader += headers.fontPreloads));\n            headers.highImagePreloads &&\n              (linkHeader && (linkHeader += \", \"),\n              (linkHeader += headers.highImagePreloads));\n            if (!shellComplete) {\n              var queueIter = renderState.styles.values(),\n                queueStep = queueIter.next();\n              b: for (\n                ;\n                0 < headers.remainingCapacity && !queueStep.done;\n                queueStep = queueIter.next()\n              )\n                for (\n                  var sheetIter = queueStep.value.sheets.values(),\n                    sheetStep = sheetIter.next();\n                  0 < headers.remainingCapacity && !sheetStep.done;\n                  sheetStep = sheetIter.next()\n                ) {\n                  var sheet = sheetStep.value,\n                    props = sheet.props,\n                    key = props.href,\n                    props$jscomp$0 = sheet.props;\n                  var header = getPreloadAsHeader(\n                    props$jscomp$0.href,\n                    \"style\",\n                    {\n                      crossOrigin: props$jscomp$0.crossOrigin,\n                      integrity: props$jscomp$0.integrity,\n                      nonce: props$jscomp$0.nonce,\n                      type: props$jscomp$0.type,\n                      fetchPriority: props$jscomp$0.fetchPriority,\n                      referrerPolicy: props$jscomp$0.referrerPolicy,\n                      media: props$jscomp$0.media\n                    }\n                  );\n                  if (0 <= (headers.remainingCapacity -= header.length + 2))\n                    (renderState.resets.style[key] = PRELOAD_NO_CREDS),\n                      linkHeader && (linkHeader += \", \"),\n                      (linkHeader += header),\n                      (renderState.resets.style[key] =\n                        \"string\" === typeof props.crossOrigin ||\n                        \"string\" === typeof props.integrity\n                          ? [props.crossOrigin, props.integrity]\n                          : PRELOAD_NO_CREDS);\n                  else break b;\n                }\n            }\n            linkHeader ? onHeaders({ Link: linkHeader }) : onHeaders({});\n          }\n        }\n      } catch (error) {\n        logRecoverableError(request, error, {});\n      }\n    }\n    function completeShell(request) {\n      null === request.trackedPostpones && safelyEmitEarlyPreloads(request, !0);\n      request.onShellError = noop;\n      request = request.onShellReady;\n      request();\n    }\n    function completeAll(request) {\n      safelyEmitEarlyPreloads(\n        request,\n        null === request.trackedPostpones\n          ? !0\n          : null === request.completedRootSegment ||\n              request.completedRootSegment.status !== POSTPONED\n      );\n      request = request.onAllReady;\n      request();\n    }\n    function queueCompletedSegment(boundary, segment) {\n      if (\n        0 === segment.chunks.length &&\n        1 === segment.children.length &&\n        null === segment.children[0].boundary &&\n        -1 === segment.children[0].id\n      ) {\n        var childSegment = segment.children[0];\n        childSegment.id = segment.id;\n        childSegment.parentFlushed = !0;\n        childSegment.status === COMPLETED &&\n          queueCompletedSegment(boundary, childSegment);\n      } else boundary.completedSegments.push(segment);\n    }\n    function finishedTask(request, boundary, segment) {\n      if (null === boundary) {\n        if (null !== segment && segment.parentFlushed) {\n          if (null !== request.completedRootSegment)\n            throw Error(\n              \"There can only be one root segment. This is a bug in React.\"\n            );\n          request.completedRootSegment = segment;\n        }\n        request.pendingRootTasks--;\n        0 === request.pendingRootTasks && completeShell(request);\n      } else\n        boundary.pendingTasks--,\n          boundary.status !== CLIENT_RENDERED &&\n            (0 === boundary.pendingTasks\n              ? (boundary.status === PENDING && (boundary.status = COMPLETED),\n                null !== segment &&\n                  segment.parentFlushed &&\n                  segment.status === COMPLETED &&\n                  queueCompletedSegment(boundary, segment),\n                boundary.parentFlushed &&\n                  request.completedBoundaries.push(boundary),\n                boundary.status === COMPLETED &&\n                  (boundary.fallbackAbortableTasks.forEach(\n                    abortTaskSoft,\n                    request\n                  ),\n                  boundary.fallbackAbortableTasks.clear()))\n              : null !== segment &&\n                segment.parentFlushed &&\n                segment.status === COMPLETED &&\n                (queueCompletedSegment(boundary, segment),\n                1 === boundary.completedSegments.length &&\n                  boundary.parentFlushed &&\n                  request.partialBoundaries.push(boundary)));\n      request.allPendingTasks--;\n      0 === request.allPendingTasks && completeAll(request);\n    }\n    function performWork(request$jscomp$1) {\n      if (\n        request$jscomp$1.status !== CLOSED &&\n        13 !== request$jscomp$1.status\n      ) {\n        var prevContext = currentActiveSnapshot,\n          prevDispatcher = ReactSharedInternals.H;\n        ReactSharedInternals.H = HooksDispatcher;\n        var prevAsyncDispatcher = ReactSharedInternals.A;\n        ReactSharedInternals.A = DefaultAsyncDispatcher;\n        var prevRequest = currentRequest;\n        currentRequest = request$jscomp$1;\n        var prevGetCurrentStackImpl = ReactSharedInternals.getCurrentStack;\n        ReactSharedInternals.getCurrentStack = getCurrentStackInDEV;\n        var prevResumableState = currentResumableState;\n        currentResumableState = request$jscomp$1.resumableState;\n        try {\n          var pingedTasks = request$jscomp$1.pingedTasks,\n            i;\n          for (i = 0; i < pingedTasks.length; i++) {\n            var request = request$jscomp$1,\n              task = pingedTasks[i],\n              segment = task.blockedSegment;\n            if (null === segment) {\n              var prevTaskInDEV = void 0,\n                request$jscomp$0 = request;\n              request = task;\n              if (0 !== request.replay.pendingTasks) {\n                switchContext(request.context);\n                prevTaskInDEV = currentTaskInDEV;\n                currentTaskInDEV = request;\n                try {\n                  \"number\" === typeof request.replay.slots\n                    ? resumeNode(\n                        request$jscomp$0,\n                        request,\n                        request.replay.slots,\n                        request.node,\n                        request.childIndex\n                      )\n                    : retryNode(request$jscomp$0, request);\n                  if (\n                    1 === request.replay.pendingTasks &&\n                    0 < request.replay.nodes.length\n                  )\n                    throw Error(\n                      \"Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.\"\n                    );\n                  request.replay.pendingTasks--;\n                  request.abortSet.delete(request);\n                  finishedTask(request$jscomp$0, request.blockedBoundary, null);\n                } catch (thrownValue) {\n                  resetHooksState();\n                  var x =\n                    thrownValue === SuspenseException\n                      ? getSuspendedThenable()\n                      : thrownValue;\n                  if (\n                    \"object\" === typeof x &&\n                    null !== x &&\n                    \"function\" === typeof x.then\n                  ) {\n                    var ping = request.ping;\n                    x.then(ping, ping);\n                    request.thenableState = getThenableStateAfterSuspending();\n                  } else {\n                    request.replay.pendingTasks--;\n                    request.abortSet.delete(request);\n                    var errorInfo = getThrownInfo(request.componentStack);\n                    erroredReplay(\n                      request$jscomp$0,\n                      request.blockedBoundary,\n                      12 === request$jscomp$0.status\n                        ? request$jscomp$0.fatalError\n                        : x,\n                      errorInfo,\n                      request.replay.nodes,\n                      request.replay.slots\n                    );\n                    request$jscomp$0.pendingRootTasks--;\n                    0 === request$jscomp$0.pendingRootTasks &&\n                      completeShell(request$jscomp$0);\n                    request$jscomp$0.allPendingTasks--;\n                    0 === request$jscomp$0.allPendingTasks &&\n                      completeAll(request$jscomp$0);\n                  }\n                } finally {\n                  currentTaskInDEV = prevTaskInDEV;\n                }\n              }\n            } else {\n              request$jscomp$0 = prevTaskInDEV = void 0;\n              var task$jscomp$0 = task,\n                segment$jscomp$0 = segment;\n              if (segment$jscomp$0.status === PENDING) {\n                segment$jscomp$0.status = 6;\n                switchContext(task$jscomp$0.context);\n                request$jscomp$0 = currentTaskInDEV;\n                currentTaskInDEV = task$jscomp$0;\n                var childrenLength = segment$jscomp$0.children.length,\n                  chunkLength = segment$jscomp$0.chunks.length;\n                try {\n                  retryNode(request, task$jscomp$0),\n                    segment$jscomp$0.lastPushedText &&\n                      segment$jscomp$0.textEmbedded &&\n                      segment$jscomp$0.chunks.push(textSeparator),\n                    task$jscomp$0.abortSet.delete(task$jscomp$0),\n                    (segment$jscomp$0.status = COMPLETED),\n                    finishedTask(\n                      request,\n                      task$jscomp$0.blockedBoundary,\n                      segment$jscomp$0\n                    );\n                } catch (thrownValue) {\n                  resetHooksState();\n                  segment$jscomp$0.children.length = childrenLength;\n                  segment$jscomp$0.chunks.length = chunkLength;\n                  var x$jscomp$0 =\n                    thrownValue === SuspenseException\n                      ? getSuspendedThenable()\n                      : 12 === request.status\n                        ? request.fatalError\n                        : thrownValue;\n                  if (\n                    \"object\" === typeof x$jscomp$0 &&\n                    null !== x$jscomp$0 &&\n                    \"function\" === typeof x$jscomp$0.then\n                  ) {\n                    segment$jscomp$0.status = PENDING;\n                    task$jscomp$0.thenableState =\n                      getThenableStateAfterSuspending();\n                    var ping$jscomp$0 = task$jscomp$0.ping;\n                    x$jscomp$0.then(ping$jscomp$0, ping$jscomp$0);\n                  } else {\n                    var errorInfo$jscomp$0 = getThrownInfo(\n                      task$jscomp$0.componentStack\n                    );\n                    task$jscomp$0.abortSet.delete(task$jscomp$0);\n                    segment$jscomp$0.status = 4;\n                    var boundary = task$jscomp$0.blockedBoundary;\n                    prevTaskInDEV = logRecoverableError(\n                      request,\n                      x$jscomp$0,\n                      errorInfo$jscomp$0\n                    );\n                    null === boundary\n                      ? fatalError(request, x$jscomp$0)\n                      : (boundary.pendingTasks--,\n                        boundary.status !== CLIENT_RENDERED &&\n                          ((boundary.status = CLIENT_RENDERED),\n                          encodeErrorForBoundary(\n                            boundary,\n                            prevTaskInDEV,\n                            x$jscomp$0,\n                            errorInfo$jscomp$0,\n                            !1\n                          ),\n                          untrackBoundary(request, boundary),\n                          boundary.parentFlushed &&\n                            request.clientRenderedBoundaries.push(boundary)));\n                    request.allPendingTasks--;\n                    0 === request.allPendingTasks && completeAll(request);\n                  }\n                } finally {\n                  currentTaskInDEV = request$jscomp$0;\n                }\n              }\n            }\n          }\n          pingedTasks.splice(0, i);\n          null !== request$jscomp$1.destination &&\n            flushCompletedQueues(\n              request$jscomp$1,\n              request$jscomp$1.destination\n            );\n        } catch (error) {\n          logRecoverableError(request$jscomp$1, error, {}),\n            fatalError(request$jscomp$1, error);\n        } finally {\n          (currentResumableState = prevResumableState),\n            (ReactSharedInternals.H = prevDispatcher),\n            (ReactSharedInternals.A = prevAsyncDispatcher),\n            (ReactSharedInternals.getCurrentStack = prevGetCurrentStackImpl),\n            prevDispatcher === HooksDispatcher && switchContext(prevContext),\n            (currentRequest = prevRequest);\n        }\n      }\n    }\n    function flushSubtree(request, destination, segment, hoistableState) {\n      segment.parentFlushed = !0;\n      switch (segment.status) {\n        case PENDING:\n          segment.id = request.nextSegmentId++;\n        case POSTPONED:\n          return (\n            (hoistableState = segment.id),\n            (segment.lastPushedText = !1),\n            (segment.textEmbedded = !1),\n            (request = request.renderState),\n            writeChunk(destination, placeholder1),\n            writeChunk(destination, request.placeholderPrefix),\n            (request = stringToChunk(hoistableState.toString(16))),\n            writeChunk(destination, request),\n            writeChunkAndReturn(destination, placeholder2)\n          );\n        case COMPLETED:\n          segment.status = FLUSHED;\n          var r = !0,\n            chunks = segment.chunks,\n            chunkIdx = 0;\n          segment = segment.children;\n          for (var childIdx = 0; childIdx < segment.length; childIdx++) {\n            for (r = segment[childIdx]; chunkIdx < r.index; chunkIdx++)\n              writeChunk(destination, chunks[chunkIdx]);\n            r = flushSegment(request, destination, r, hoistableState);\n          }\n          for (; chunkIdx < chunks.length - 1; chunkIdx++)\n            writeChunk(destination, chunks[chunkIdx]);\n          chunkIdx < chunks.length &&\n            (r = writeChunkAndReturn(destination, chunks[chunkIdx]));\n          return r;\n        default:\n          throw Error(\n            \"Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.\"\n          );\n      }\n    }\n    function flushSegment(request, destination, segment, hoistableState) {\n      var boundary = segment.boundary;\n      if (null === boundary)\n        return flushSubtree(request, destination, segment, hoistableState);\n      boundary.parentFlushed = !0;\n      if (boundary.status === CLIENT_RENDERED) {\n        var errorDigest = boundary.errorDigest,\n          errorMessage = boundary.errorMessage,\n          errorStack = boundary.errorStack;\n        boundary = boundary.errorComponentStack;\n        writeChunkAndReturn(destination, startClientRenderedSuspenseBoundary);\n        writeChunk(destination, clientRenderedSuspenseBoundaryError1);\n        errorDigest &&\n          (writeChunk(destination, clientRenderedSuspenseBoundaryError1A),\n          writeChunk(\n            destination,\n            stringToChunk(escapeTextForBrowser(errorDigest))\n          ),\n          writeChunk(\n            destination,\n            clientRenderedSuspenseBoundaryErrorAttrInterstitial\n          ));\n        errorMessage &&\n          (writeChunk(destination, clientRenderedSuspenseBoundaryError1B),\n          writeChunk(\n            destination,\n            stringToChunk(escapeTextForBrowser(errorMessage))\n          ),\n          writeChunk(\n            destination,\n            clientRenderedSuspenseBoundaryErrorAttrInterstitial\n          ));\n        errorStack &&\n          (writeChunk(destination, clientRenderedSuspenseBoundaryError1C),\n          writeChunk(\n            destination,\n            stringToChunk(escapeTextForBrowser(errorStack))\n          ),\n          writeChunk(\n            destination,\n            clientRenderedSuspenseBoundaryErrorAttrInterstitial\n          ));\n        boundary &&\n          (writeChunk(destination, clientRenderedSuspenseBoundaryError1D),\n          writeChunk(\n            destination,\n            stringToChunk(escapeTextForBrowser(boundary))\n          ),\n          writeChunk(\n            destination,\n            clientRenderedSuspenseBoundaryErrorAttrInterstitial\n          ));\n        writeChunkAndReturn(destination, clientRenderedSuspenseBoundaryError2);\n        flushSubtree(request, destination, segment, hoistableState);\n      } else if (boundary.status !== COMPLETED)\n        boundary.status === PENDING &&\n          (boundary.rootSegmentID = request.nextSegmentId++),\n          0 < boundary.completedSegments.length &&\n            request.partialBoundaries.push(boundary),\n          writeStartPendingSuspenseBoundary(\n            destination,\n            request.renderState,\n            boundary.rootSegmentID\n          ),\n          hoistableState &&\n            ((boundary = boundary.fallbackState),\n            boundary.styles.forEach(hoistStyleQueueDependency, hoistableState),\n            boundary.stylesheets.forEach(\n              hoistStylesheetDependency,\n              hoistableState\n            )),\n          flushSubtree(request, destination, segment, hoistableState);\n      else if (boundary.byteSize > request.progressiveChunkSize)\n        (boundary.rootSegmentID = request.nextSegmentId++),\n          request.completedBoundaries.push(boundary),\n          writeStartPendingSuspenseBoundary(\n            destination,\n            request.renderState,\n            boundary.rootSegmentID\n          ),\n          flushSubtree(request, destination, segment, hoistableState);\n      else {\n        hoistableState &&\n          ((segment = boundary.contentState),\n          segment.styles.forEach(hoistStyleQueueDependency, hoistableState),\n          segment.stylesheets.forEach(\n            hoistStylesheetDependency,\n            hoistableState\n          ));\n        writeChunkAndReturn(destination, startCompletedSuspenseBoundary);\n        segment = boundary.completedSegments;\n        if (1 !== segment.length)\n          throw Error(\n            \"A previously unvisited boundary must have exactly one root segment. This is a bug in React.\"\n          );\n        flushSegment(request, destination, segment[0], hoistableState);\n      }\n      return writeChunkAndReturn(destination, endSuspenseBoundary);\n    }\n    function flushSegmentContainer(\n      request,\n      destination,\n      segment,\n      hoistableState\n    ) {\n      writeStartSegment(\n        destination,\n        request.renderState,\n        segment.parentFormatContext,\n        segment.id\n      );\n      flushSegment(request, destination, segment, hoistableState);\n      return writeEndSegment(destination, segment.parentFormatContext);\n    }\n    function flushCompletedBoundary(request, destination, boundary) {\n      for (\n        var completedSegments = boundary.completedSegments, i = 0;\n        i < completedSegments.length;\n        i++\n      )\n        flushPartiallyCompletedSegment(\n          request,\n          destination,\n          boundary,\n          completedSegments[i]\n        );\n      completedSegments.length = 0;\n      writeHoistablesForBoundary(\n        destination,\n        boundary.contentState,\n        request.renderState\n      );\n      completedSegments = request.resumableState;\n      request = request.renderState;\n      i = boundary.rootSegmentID;\n      boundary = boundary.contentState;\n      var requiresStyleInsertion = request.stylesToHoist;\n      request.stylesToHoist = !1;\n      writeChunk(destination, request.startInlineScript);\n      requiresStyleInsertion\n        ? (completedSegments.instructions & SentCompleteBoundaryFunction) ===\n          NothingSent\n          ? ((completedSegments.instructions =\n              completedSegments.instructions |\n              SentStyleInsertionFunction |\n              SentCompleteBoundaryFunction),\n            writeChunk(destination, completeBoundaryWithStylesScript1FullBoth))\n          : (completedSegments.instructions & SentStyleInsertionFunction) ===\n              NothingSent\n            ? ((completedSegments.instructions |= SentStyleInsertionFunction),\n              writeChunk(\n                destination,\n                completeBoundaryWithStylesScript1FullPartial\n              ))\n            : writeChunk(destination, completeBoundaryWithStylesScript1Partial)\n        : (completedSegments.instructions & SentCompleteBoundaryFunction) ===\n            NothingSent\n          ? ((completedSegments.instructions |= SentCompleteBoundaryFunction),\n            writeChunk(destination, completeBoundaryScript1Full))\n          : writeChunk(destination, completeBoundaryScript1Partial);\n      completedSegments = stringToChunk(i.toString(16));\n      writeChunk(destination, request.boundaryPrefix);\n      writeChunk(destination, completedSegments);\n      writeChunk(destination, completeBoundaryScript2);\n      writeChunk(destination, request.segmentPrefix);\n      writeChunk(destination, completedSegments);\n      requiresStyleInsertion\n        ? (writeChunk(destination, completeBoundaryScript3a),\n          writeStyleResourceDependenciesInJS(destination, boundary))\n        : writeChunk(destination, completeBoundaryScript3b);\n      boundary = writeChunkAndReturn(destination, completeBoundaryScriptEnd);\n      return writeBootstrap(destination, request) && boundary;\n    }\n    function flushPartiallyCompletedSegment(\n      request,\n      destination,\n      boundary,\n      segment\n    ) {\n      if (segment.status === FLUSHED) return !0;\n      var hoistableState = boundary.contentState,\n        segmentID = segment.id;\n      if (-1 === segmentID) {\n        if (-1 === (segment.id = boundary.rootSegmentID))\n          throw Error(\n            \"A root segment ID must have been assigned by now. This is a bug in React.\"\n          );\n        return flushSegmentContainer(\n          request,\n          destination,\n          segment,\n          hoistableState\n        );\n      }\n      if (segmentID === boundary.rootSegmentID)\n        return flushSegmentContainer(\n          request,\n          destination,\n          segment,\n          hoistableState\n        );\n      flushSegmentContainer(request, destination, segment, hoistableState);\n      boundary = request.resumableState;\n      request = request.renderState;\n      writeChunk(destination, request.startInlineScript);\n      (boundary.instructions & SentCompleteSegmentFunction) === NothingSent\n        ? ((boundary.instructions |= SentCompleteSegmentFunction),\n          writeChunk(destination, completeSegmentScript1Full))\n        : writeChunk(destination, completeSegmentScript1Partial);\n      writeChunk(destination, request.segmentPrefix);\n      segmentID = stringToChunk(segmentID.toString(16));\n      writeChunk(destination, segmentID);\n      writeChunk(destination, completeSegmentScript2);\n      writeChunk(destination, request.placeholderPrefix);\n      writeChunk(destination, segmentID);\n      destination = writeChunkAndReturn(destination, completeSegmentScriptEnd);\n      return destination;\n    }\n    function flushCompletedQueues(request, destination) {\n      currentView = new Uint8Array(2048);\n      writtenBytes = 0;\n      try {\n        if (!(0 < request.pendingRootTasks)) {\n          var i,\n            completedRootSegment = request.completedRootSegment;\n          if (null !== completedRootSegment) {\n            if (completedRootSegment.status === POSTPONED) return;\n            var renderState = request.renderState,\n              htmlChunks = renderState.htmlChunks,\n              headChunks = renderState.headChunks,\n              i$jscomp$0;\n            if (htmlChunks) {\n              for (i$jscomp$0 = 0; i$jscomp$0 < htmlChunks.length; i$jscomp$0++)\n                writeChunk(destination, htmlChunks[i$jscomp$0]);\n              if (headChunks)\n                for (\n                  i$jscomp$0 = 0;\n                  i$jscomp$0 < headChunks.length;\n                  i$jscomp$0++\n                )\n                  writeChunk(destination, headChunks[i$jscomp$0]);\n              else\n                writeChunk(destination, startChunkForTag(\"head\")),\n                  writeChunk(destination, endOfStartTag);\n            } else if (headChunks)\n              for (i$jscomp$0 = 0; i$jscomp$0 < headChunks.length; i$jscomp$0++)\n                writeChunk(destination, headChunks[i$jscomp$0]);\n            var charsetChunks = renderState.charsetChunks;\n            for (\n              i$jscomp$0 = 0;\n              i$jscomp$0 < charsetChunks.length;\n              i$jscomp$0++\n            )\n              writeChunk(destination, charsetChunks[i$jscomp$0]);\n            charsetChunks.length = 0;\n            renderState.preconnects.forEach(flushResource, destination);\n            renderState.preconnects.clear();\n            var viewportChunks = renderState.viewportChunks;\n            for (\n              i$jscomp$0 = 0;\n              i$jscomp$0 < viewportChunks.length;\n              i$jscomp$0++\n            )\n              writeChunk(destination, viewportChunks[i$jscomp$0]);\n            viewportChunks.length = 0;\n            renderState.fontPreloads.forEach(flushResource, destination);\n            renderState.fontPreloads.clear();\n            renderState.highImagePreloads.forEach(flushResource, destination);\n            renderState.highImagePreloads.clear();\n            renderState.styles.forEach(flushStylesInPreamble, destination);\n            var importMapChunks = renderState.importMapChunks;\n            for (\n              i$jscomp$0 = 0;\n              i$jscomp$0 < importMapChunks.length;\n              i$jscomp$0++\n            )\n              writeChunk(destination, importMapChunks[i$jscomp$0]);\n            importMapChunks.length = 0;\n            renderState.bootstrapScripts.forEach(flushResource, destination);\n            renderState.scripts.forEach(flushResource, destination);\n            renderState.scripts.clear();\n            renderState.bulkPreloads.forEach(flushResource, destination);\n            renderState.bulkPreloads.clear();\n            var hoistableChunks = renderState.hoistableChunks;\n            for (\n              i$jscomp$0 = 0;\n              i$jscomp$0 < hoistableChunks.length;\n              i$jscomp$0++\n            )\n              writeChunk(destination, hoistableChunks[i$jscomp$0]);\n            hoistableChunks.length = 0;\n            htmlChunks &&\n              null === headChunks &&\n              writeChunk(destination, endChunkForTag(\"head\"));\n            flushSegment(request, destination, completedRootSegment, null);\n            request.completedRootSegment = null;\n            writeBootstrap(destination, request.renderState);\n          }\n          var renderState$jscomp$0 = request.renderState;\n          completedRootSegment = 0;\n          var viewportChunks$jscomp$0 = renderState$jscomp$0.viewportChunks;\n          for (\n            completedRootSegment = 0;\n            completedRootSegment < viewportChunks$jscomp$0.length;\n            completedRootSegment++\n          )\n            writeChunk(\n              destination,\n              viewportChunks$jscomp$0[completedRootSegment]\n            );\n          viewportChunks$jscomp$0.length = 0;\n          renderState$jscomp$0.preconnects.forEach(flushResource, destination);\n          renderState$jscomp$0.preconnects.clear();\n          renderState$jscomp$0.fontPreloads.forEach(flushResource, destination);\n          renderState$jscomp$0.fontPreloads.clear();\n          renderState$jscomp$0.highImagePreloads.forEach(\n            flushResource,\n            destination\n          );\n          renderState$jscomp$0.highImagePreloads.clear();\n          renderState$jscomp$0.styles.forEach(preloadLateStyles, destination);\n          renderState$jscomp$0.scripts.forEach(flushResource, destination);\n          renderState$jscomp$0.scripts.clear();\n          renderState$jscomp$0.bulkPreloads.forEach(flushResource, destination);\n          renderState$jscomp$0.bulkPreloads.clear();\n          var hoistableChunks$jscomp$0 = renderState$jscomp$0.hoistableChunks;\n          for (\n            completedRootSegment = 0;\n            completedRootSegment < hoistableChunks$jscomp$0.length;\n            completedRootSegment++\n          )\n            writeChunk(\n              destination,\n              hoistableChunks$jscomp$0[completedRootSegment]\n            );\n          hoistableChunks$jscomp$0.length = 0;\n          var clientRenderedBoundaries = request.clientRenderedBoundaries;\n          for (i = 0; i < clientRenderedBoundaries.length; i++) {\n            var boundary = clientRenderedBoundaries[i];\n            renderState$jscomp$0 = destination;\n            var resumableState = request.resumableState,\n              renderState$jscomp$1 = request.renderState,\n              id = boundary.rootSegmentID,\n              errorDigest = boundary.errorDigest,\n              errorMessage = boundary.errorMessage,\n              errorStack = boundary.errorStack,\n              errorComponentStack = boundary.errorComponentStack;\n            writeChunk(\n              renderState$jscomp$0,\n              renderState$jscomp$1.startInlineScript\n            );\n            (resumableState.instructions & SentClientRenderFunction) ===\n            NothingSent\n              ? ((resumableState.instructions |= SentClientRenderFunction),\n                writeChunk(renderState$jscomp$0, clientRenderScript1Full))\n              : writeChunk(renderState$jscomp$0, clientRenderScript1Partial);\n            writeChunk(\n              renderState$jscomp$0,\n              renderState$jscomp$1.boundaryPrefix\n            );\n            writeChunk(renderState$jscomp$0, stringToChunk(id.toString(16)));\n            writeChunk(renderState$jscomp$0, clientRenderScript1A);\n            if (\n              errorDigest ||\n              errorMessage ||\n              errorStack ||\n              errorComponentStack\n            )\n              writeChunk(\n                renderState$jscomp$0,\n                clientRenderErrorScriptArgInterstitial\n              ),\n                writeChunk(\n                  renderState$jscomp$0,\n                  stringToChunk(\n                    escapeJSStringsForInstructionScripts(errorDigest || \"\")\n                  )\n                );\n            if (errorMessage || errorStack || errorComponentStack)\n              writeChunk(\n                renderState$jscomp$0,\n                clientRenderErrorScriptArgInterstitial\n              ),\n                writeChunk(\n                  renderState$jscomp$0,\n                  stringToChunk(\n                    escapeJSStringsForInstructionScripts(errorMessage || \"\")\n                  )\n                );\n            if (errorStack || errorComponentStack)\n              writeChunk(\n                renderState$jscomp$0,\n                clientRenderErrorScriptArgInterstitial\n              ),\n                writeChunk(\n                  renderState$jscomp$0,\n                  stringToChunk(\n                    escapeJSStringsForInstructionScripts(errorStack || \"\")\n                  )\n                );\n            errorComponentStack &&\n              (writeChunk(\n                renderState$jscomp$0,\n                clientRenderErrorScriptArgInterstitial\n              ),\n              writeChunk(\n                renderState$jscomp$0,\n                stringToChunk(\n                  escapeJSStringsForInstructionScripts(errorComponentStack)\n                )\n              ));\n            var JSCompiler_inline_result = writeChunkAndReturn(\n              renderState$jscomp$0,\n              clientRenderScriptEnd\n            );\n            if (!JSCompiler_inline_result) {\n              request.destination = null;\n              i++;\n              clientRenderedBoundaries.splice(0, i);\n              return;\n            }\n          }\n          clientRenderedBoundaries.splice(0, i);\n          var completedBoundaries = request.completedBoundaries;\n          for (i = 0; i < completedBoundaries.length; i++)\n            if (\n              !flushCompletedBoundary(\n                request,\n                destination,\n                completedBoundaries[i]\n              )\n            ) {\n              request.destination = null;\n              i++;\n              completedBoundaries.splice(0, i);\n              return;\n            }\n          completedBoundaries.splice(0, i);\n          completeWriting(destination);\n          currentView = new Uint8Array(2048);\n          writtenBytes = 0;\n          var partialBoundaries = request.partialBoundaries;\n          for (i = 0; i < partialBoundaries.length; i++) {\n            a: {\n              clientRenderedBoundaries = request;\n              boundary = destination;\n              var boundary$jscomp$0 = partialBoundaries[i],\n                completedSegments = boundary$jscomp$0.completedSegments;\n              for (\n                JSCompiler_inline_result = 0;\n                JSCompiler_inline_result < completedSegments.length;\n                JSCompiler_inline_result++\n              )\n                if (\n                  !flushPartiallyCompletedSegment(\n                    clientRenderedBoundaries,\n                    boundary,\n                    boundary$jscomp$0,\n                    completedSegments[JSCompiler_inline_result]\n                  )\n                ) {\n                  JSCompiler_inline_result++;\n                  completedSegments.splice(0, JSCompiler_inline_result);\n                  var JSCompiler_inline_result$jscomp$0 = !1;\n                  break a;\n                }\n              completedSegments.splice(0, JSCompiler_inline_result);\n              JSCompiler_inline_result$jscomp$0 = writeHoistablesForBoundary(\n                boundary,\n                boundary$jscomp$0.contentState,\n                clientRenderedBoundaries.renderState\n              );\n            }\n            if (!JSCompiler_inline_result$jscomp$0) {\n              request.destination = null;\n              i++;\n              partialBoundaries.splice(0, i);\n              return;\n            }\n          }\n          partialBoundaries.splice(0, i);\n          var largeBoundaries = request.completedBoundaries;\n          for (i = 0; i < largeBoundaries.length; i++)\n            if (\n              !flushCompletedBoundary(request, destination, largeBoundaries[i])\n            ) {\n              request.destination = null;\n              i++;\n              largeBoundaries.splice(0, i);\n              return;\n            }\n          largeBoundaries.splice(0, i);\n        }\n      } finally {\n        0 === request.allPendingTasks &&\n        0 === request.pingedTasks.length &&\n        0 === request.clientRenderedBoundaries.length &&\n        0 === request.completedBoundaries.length\n          ? ((request.flushScheduled = !1),\n            (i = request.resumableState),\n            i.hasBody && writeChunk(destination, endChunkForTag(\"body\")),\n            i.hasHtml && writeChunk(destination, endChunkForTag(\"html\")),\n            completeWriting(destination),\n            0 !== request.abortableTasks.size &&\n              console.error(\n                \"There was still abortable task at the root when we closed. This is a bug in React.\"\n              ),\n            (request.status = CLOSED),\n            destination.close(),\n            (request.destination = null))\n          : completeWriting(destination);\n      }\n    }\n    function startWork(request) {\n      request.flushScheduled = null !== request.destination;\n      scheduleMicrotask(function () {\n        return performWork(request);\n      });\n      scheduleWork(function () {\n        10 === request.status && (request.status = 11);\n        null === request.trackedPostpones &&\n          safelyEmitEarlyPreloads(request, 0 === request.pendingRootTasks);\n      });\n    }\n    function enqueueFlush(request) {\n      !1 === request.flushScheduled &&\n        0 === request.pingedTasks.length &&\n        null !== request.destination &&\n        ((request.flushScheduled = !0),\n        scheduleWork(function () {\n          var destination = request.destination;\n          destination\n            ? flushCompletedQueues(request, destination)\n            : (request.flushScheduled = !1);\n        }));\n    }\n    function startFlowing(request, destination) {\n      if (13 === request.status)\n        (request.status = CLOSED),\n          closeWithError(destination, request.fatalError);\n      else if (request.status !== CLOSED && null === request.destination) {\n        request.destination = destination;\n        try {\n          flushCompletedQueues(request, destination);\n        } catch (error) {\n          logRecoverableError(request, error, {}), fatalError(request, error);\n        }\n      }\n    }\n    function abort(request, reason) {\n      if (11 === request.status || 10 === request.status) request.status = 12;\n      try {\n        var abortableTasks = request.abortableTasks;\n        if (0 < abortableTasks.size) {\n          var error =\n            void 0 === reason\n              ? Error(\"The render was aborted by the server without a reason.\")\n              : \"object\" === typeof reason &&\n                  null !== reason &&\n                  \"function\" === typeof reason.then\n                ? Error(\"The render was aborted by the server with a promise.\")\n                : reason;\n          request.fatalError = error;\n          abortableTasks.forEach(function (task) {\n            return abortTask(task, request, error);\n          });\n          abortableTasks.clear();\n        }\n        null !== request.destination &&\n          flushCompletedQueues(request, request.destination);\n      } catch (error$4) {\n        logRecoverableError(request, error$4, {}), fatalError(request, error$4);\n      }\n    }\n    function ensureCorrectIsomorphicReactVersion() {\n      var isomorphicReactPackageVersion = React.version;\n      if (\"19.0.0-rc-65e06cb7-20241218\" !== isomorphicReactPackageVersion)\n        throw Error(\n          'Incompatible React versions: The \"react\" and \"react-dom\" packages must have the exact same version. Instead got:\\n  - react:      ' +\n            (isomorphicReactPackageVersion +\n              \"\\n  - react-dom:  19.0.0-rc-65e06cb7-20241218\\nLearn more: https://react.dev/warnings/version-mismatch\")\n        );\n    }\n    var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"),\n      ReactDOM = __webpack_require__(/*! next/dist/compiled/react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\"),\n      REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\"),\n      REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\"),\n      REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_SCOPE_TYPE = Symbol.for(\"react.scope\"),\n      REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for(\"react.debug_trace_mode\"),\n      REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\"),\n      REACT_LEGACY_HIDDEN_TYPE = Symbol.for(\"react.legacy_hidden\"),\n      REACT_MEMO_CACHE_SENTINEL = Symbol.for(\"react.memo_cache_sentinel\"),\n      MAYBE_ITERATOR_SYMBOL = Symbol.iterator,\n      isArrayImpl = Array.isArray,\n      jsxPropsParents = new WeakMap(),\n      jsxChildrenParents = new WeakMap(),\n      CLIENT_REFERENCE_TAG = Symbol.for(\"react.client.reference\"),\n      channel = new MessageChannel(),\n      taskQueue = [];\n    channel.port1.onmessage = function () {\n      var task = taskQueue.shift();\n      task && task();\n    };\n    var LocalPromise = Promise,\n      scheduleMicrotask =\n        \"function\" === typeof queueMicrotask\n          ? queueMicrotask\n          : function (callback) {\n              LocalPromise.resolve(null)\n                .then(callback)\n                .catch(handleErrorInNextTick);\n            },\n      currentView = null,\n      writtenBytes = 0,\n      textEncoder = new TextEncoder(),\n      assign = Object.assign,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      VALID_ATTRIBUTE_NAME_REGEX = RegExp(\n        \"^[:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD][:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]*$\"\n      ),\n      illegalAttributeNameCache = {},\n      validatedAttributeNameCache = {},\n      unitlessNumbers = new Set(\n        \"animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp\".split(\n          \" \"\n        )\n      ),\n      aliases = new Map([\n        [\"acceptCharset\", \"accept-charset\"],\n        [\"htmlFor\", \"for\"],\n        [\"httpEquiv\", \"http-equiv\"],\n        [\"crossOrigin\", \"crossorigin\"],\n        [\"accentHeight\", \"accent-height\"],\n        [\"alignmentBaseline\", \"alignment-baseline\"],\n        [\"arabicForm\", \"arabic-form\"],\n        [\"baselineShift\", \"baseline-shift\"],\n        [\"capHeight\", \"cap-height\"],\n        [\"clipPath\", \"clip-path\"],\n        [\"clipRule\", \"clip-rule\"],\n        [\"colorInterpolation\", \"color-interpolation\"],\n        [\"colorInterpolationFilters\", \"color-interpolation-filters\"],\n        [\"colorProfile\", \"color-profile\"],\n        [\"colorRendering\", \"color-rendering\"],\n        [\"dominantBaseline\", \"dominant-baseline\"],\n        [\"enableBackground\", \"enable-background\"],\n        [\"fillOpacity\", \"fill-opacity\"],\n        [\"fillRule\", \"fill-rule\"],\n        [\"floodColor\", \"flood-color\"],\n        [\"floodOpacity\", \"flood-opacity\"],\n        [\"fontFamily\", \"font-family\"],\n        [\"fontSize\", \"font-size\"],\n        [\"fontSizeAdjust\", \"font-size-adjust\"],\n        [\"fontStretch\", \"font-stretch\"],\n        [\"fontStyle\", \"font-style\"],\n        [\"fontVariant\", \"font-variant\"],\n        [\"fontWeight\", \"font-weight\"],\n        [\"glyphName\", \"glyph-name\"],\n        [\"glyphOrientationHorizontal\", \"glyph-orientation-horizontal\"],\n        [\"glyphOrientationVertical\", \"glyph-orientation-vertical\"],\n        [\"horizAdvX\", \"horiz-adv-x\"],\n        [\"horizOriginX\", \"horiz-origin-x\"],\n        [\"imageRendering\", \"image-rendering\"],\n        [\"letterSpacing\", \"letter-spacing\"],\n        [\"lightingColor\", \"lighting-color\"],\n        [\"markerEnd\", \"marker-end\"],\n        [\"markerMid\", \"marker-mid\"],\n        [\"markerStart\", \"marker-start\"],\n        [\"overlinePosition\", \"overline-position\"],\n        [\"overlineThickness\", \"overline-thickness\"],\n        [\"paintOrder\", \"paint-order\"],\n        [\"panose-1\", \"panose-1\"],\n        [\"pointerEvents\", \"pointer-events\"],\n        [\"renderingIntent\", \"rendering-intent\"],\n        [\"shapeRendering\", \"shape-rendering\"],\n        [\"stopColor\", \"stop-color\"],\n        [\"stopOpacity\", \"stop-opacity\"],\n        [\"strikethroughPosition\", \"strikethrough-position\"],\n        [\"strikethroughThickness\", \"strikethrough-thickness\"],\n        [\"strokeDasharray\", \"stroke-dasharray\"],\n        [\"strokeDashoffset\", \"stroke-dashoffset\"],\n        [\"strokeLinecap\", \"stroke-linecap\"],\n        [\"strokeLinejoin\", \"stroke-linejoin\"],\n        [\"strokeMiterlimit\", \"stroke-miterlimit\"],\n        [\"strokeOpacity\", \"stroke-opacity\"],\n        [\"strokeWidth\", \"stroke-width\"],\n        [\"textAnchor\", \"text-anchor\"],\n        [\"textDecoration\", \"text-decoration\"],\n        [\"textRendering\", \"text-rendering\"],\n        [\"transformOrigin\", \"transform-origin\"],\n        [\"underlinePosition\", \"underline-position\"],\n        [\"underlineThickness\", \"underline-thickness\"],\n        [\"unicodeBidi\", \"unicode-bidi\"],\n        [\"unicodeRange\", \"unicode-range\"],\n        [\"unitsPerEm\", \"units-per-em\"],\n        [\"vAlphabetic\", \"v-alphabetic\"],\n        [\"vHanging\", \"v-hanging\"],\n        [\"vIdeographic\", \"v-ideographic\"],\n        [\"vMathematical\", \"v-mathematical\"],\n        [\"vectorEffect\", \"vector-effect\"],\n        [\"vertAdvY\", \"vert-adv-y\"],\n        [\"vertOriginX\", \"vert-origin-x\"],\n        [\"vertOriginY\", \"vert-origin-y\"],\n        [\"wordSpacing\", \"word-spacing\"],\n        [\"writingMode\", \"writing-mode\"],\n        [\"xmlnsXlink\", \"xmlns:xlink\"],\n        [\"xHeight\", \"x-height\"]\n      ]),\n      hasReadOnlyValue = {\n        button: !0,\n        checkbox: !0,\n        image: !0,\n        hidden: !0,\n        radio: !0,\n        reset: !0,\n        submit: !0\n      },\n      ariaProperties = {\n        \"aria-current\": 0,\n        \"aria-description\": 0,\n        \"aria-details\": 0,\n        \"aria-disabled\": 0,\n        \"aria-hidden\": 0,\n        \"aria-invalid\": 0,\n        \"aria-keyshortcuts\": 0,\n        \"aria-label\": 0,\n        \"aria-roledescription\": 0,\n        \"aria-autocomplete\": 0,\n        \"aria-checked\": 0,\n        \"aria-expanded\": 0,\n        \"aria-haspopup\": 0,\n        \"aria-level\": 0,\n        \"aria-modal\": 0,\n        \"aria-multiline\": 0,\n        \"aria-multiselectable\": 0,\n        \"aria-orientation\": 0,\n        \"aria-placeholder\": 0,\n        \"aria-pressed\": 0,\n        \"aria-readonly\": 0,\n        \"aria-required\": 0,\n        \"aria-selected\": 0,\n        \"aria-sort\": 0,\n        \"aria-valuemax\": 0,\n        \"aria-valuemin\": 0,\n        \"aria-valuenow\": 0,\n        \"aria-valuetext\": 0,\n        \"aria-atomic\": 0,\n        \"aria-busy\": 0,\n        \"aria-live\": 0,\n        \"aria-relevant\": 0,\n        \"aria-dropeffect\": 0,\n        \"aria-grabbed\": 0,\n        \"aria-activedescendant\": 0,\n        \"aria-colcount\": 0,\n        \"aria-colindex\": 0,\n        \"aria-colspan\": 0,\n        \"aria-controls\": 0,\n        \"aria-describedby\": 0,\n        \"aria-errormessage\": 0,\n        \"aria-flowto\": 0,\n        \"aria-labelledby\": 0,\n        \"aria-owns\": 0,\n        \"aria-posinset\": 0,\n        \"aria-rowcount\": 0,\n        \"aria-rowindex\": 0,\n        \"aria-rowspan\": 0,\n        \"aria-setsize\": 0\n      },\n      warnedProperties$1 = {},\n      rARIA$1 = RegExp(\n        \"^(aria)-[:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]*$\"\n      ),\n      rARIACamel$1 = RegExp(\n        \"^(aria)[A-Z][:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]*$\"\n      ),\n      didWarnValueNull = !1,\n      possibleStandardNames = {\n        accept: \"accept\",\n        acceptcharset: \"acceptCharset\",\n        \"accept-charset\": \"acceptCharset\",\n        accesskey: \"accessKey\",\n        action: \"action\",\n        allowfullscreen: \"allowFullScreen\",\n        alt: \"alt\",\n        as: \"as\",\n        async: \"async\",\n        autocapitalize: \"autoCapitalize\",\n        autocomplete: \"autoComplete\",\n        autocorrect: \"autoCorrect\",\n        autofocus: \"autoFocus\",\n        autoplay: \"autoPlay\",\n        autosave: \"autoSave\",\n        capture: \"capture\",\n        cellpadding: \"cellPadding\",\n        cellspacing: \"cellSpacing\",\n        challenge: \"challenge\",\n        charset: \"charSet\",\n        checked: \"checked\",\n        children: \"children\",\n        cite: \"cite\",\n        class: \"className\",\n        classid: \"classID\",\n        classname: \"className\",\n        cols: \"cols\",\n        colspan: \"colSpan\",\n        content: \"content\",\n        contenteditable: \"contentEditable\",\n        contextmenu: \"contextMenu\",\n        controls: \"controls\",\n        controlslist: \"controlsList\",\n        coords: \"coords\",\n        crossorigin: \"crossOrigin\",\n        dangerouslysetinnerhtml: \"dangerouslySetInnerHTML\",\n        data: \"data\",\n        datetime: \"dateTime\",\n        default: \"default\",\n        defaultchecked: \"defaultChecked\",\n        defaultvalue: \"defaultValue\",\n        defer: \"defer\",\n        dir: \"dir\",\n        disabled: \"disabled\",\n        disablepictureinpicture: \"disablePictureInPicture\",\n        disableremoteplayback: \"disableRemotePlayback\",\n        download: \"download\",\n        draggable: \"draggable\",\n        enctype: \"encType\",\n        enterkeyhint: \"enterKeyHint\",\n        fetchpriority: \"fetchPriority\",\n        for: \"htmlFor\",\n        form: \"form\",\n        formmethod: \"formMethod\",\n        formaction: \"formAction\",\n        formenctype: \"formEncType\",\n        formnovalidate: \"formNoValidate\",\n        formtarget: \"formTarget\",\n        frameborder: \"frameBorder\",\n        headers: \"headers\",\n        height: \"height\",\n        hidden: \"hidden\",\n        high: \"high\",\n        href: \"href\",\n        hreflang: \"hrefLang\",\n        htmlfor: \"htmlFor\",\n        httpequiv: \"httpEquiv\",\n        \"http-equiv\": \"httpEquiv\",\n        icon: \"icon\",\n        id: \"id\",\n        imagesizes: \"imageSizes\",\n        imagesrcset: \"imageSrcSet\",\n        inert: \"inert\",\n        innerhtml: \"innerHTML\",\n        inputmode: \"inputMode\",\n        integrity: \"integrity\",\n        is: \"is\",\n        itemid: \"itemID\",\n        itemprop: \"itemProp\",\n        itemref: \"itemRef\",\n        itemscope: \"itemScope\",\n        itemtype: \"itemType\",\n        keyparams: \"keyParams\",\n        keytype: \"keyType\",\n        kind: \"kind\",\n        label: \"label\",\n        lang: \"lang\",\n        list: \"list\",\n        loop: \"loop\",\n        low: \"low\",\n        manifest: \"manifest\",\n        marginwidth: \"marginWidth\",\n        marginheight: \"marginHeight\",\n        max: \"max\",\n        maxlength: \"maxLength\",\n        media: \"media\",\n        mediagroup: \"mediaGroup\",\n        method: \"method\",\n        min: \"min\",\n        minlength: \"minLength\",\n        multiple: \"multiple\",\n        muted: \"muted\",\n        name: \"name\",\n        nomodule: \"noModule\",\n        nonce: \"nonce\",\n        novalidate: \"noValidate\",\n        open: \"open\",\n        optimum: \"optimum\",\n        pattern: \"pattern\",\n        placeholder: \"placeholder\",\n        playsinline: \"playsInline\",\n        poster: \"poster\",\n        preload: \"preload\",\n        profile: \"profile\",\n        radiogroup: \"radioGroup\",\n        readonly: \"readOnly\",\n        referrerpolicy: \"referrerPolicy\",\n        rel: \"rel\",\n        required: \"required\",\n        reversed: \"reversed\",\n        role: \"role\",\n        rows: \"rows\",\n        rowspan: \"rowSpan\",\n        sandbox: \"sandbox\",\n        scope: \"scope\",\n        scoped: \"scoped\",\n        scrolling: \"scrolling\",\n        seamless: \"seamless\",\n        selected: \"selected\",\n        shape: \"shape\",\n        size: \"size\",\n        sizes: \"sizes\",\n        span: \"span\",\n        spellcheck: \"spellCheck\",\n        src: \"src\",\n        srcdoc: \"srcDoc\",\n        srclang: \"srcLang\",\n        srcset: \"srcSet\",\n        start: \"start\",\n        step: \"step\",\n        style: \"style\",\n        summary: \"summary\",\n        tabindex: \"tabIndex\",\n        target: \"target\",\n        title: \"title\",\n        type: \"type\",\n        usemap: \"useMap\",\n        value: \"value\",\n        width: \"width\",\n        wmode: \"wmode\",\n        wrap: \"wrap\",\n        about: \"about\",\n        accentheight: \"accentHeight\",\n        \"accent-height\": \"accentHeight\",\n        accumulate: \"accumulate\",\n        additive: \"additive\",\n        alignmentbaseline: \"alignmentBaseline\",\n        \"alignment-baseline\": \"alignmentBaseline\",\n        allowreorder: \"allowReorder\",\n        alphabetic: \"alphabetic\",\n        amplitude: \"amplitude\",\n        arabicform: \"arabicForm\",\n        \"arabic-form\": \"arabicForm\",\n        ascent: \"ascent\",\n        attributename: \"attributeName\",\n        attributetype: \"attributeType\",\n        autoreverse: \"autoReverse\",\n        azimuth: \"azimuth\",\n        basefrequency: \"baseFrequency\",\n        baselineshift: \"baselineShift\",\n        \"baseline-shift\": \"baselineShift\",\n        baseprofile: \"baseProfile\",\n        bbox: \"bbox\",\n        begin: \"begin\",\n        bias: \"bias\",\n        by: \"by\",\n        calcmode: \"calcMode\",\n        capheight: \"capHeight\",\n        \"cap-height\": \"capHeight\",\n        clip: \"clip\",\n        clippath: \"clipPath\",\n        \"clip-path\": \"clipPath\",\n        clippathunits: \"clipPathUnits\",\n        cliprule: \"clipRule\",\n        \"clip-rule\": \"clipRule\",\n        color: \"color\",\n        colorinterpolation: \"colorInterpolation\",\n        \"color-interpolation\": \"colorInterpolation\",\n        colorinterpolationfilters: \"colorInterpolationFilters\",\n        \"color-interpolation-filters\": \"colorInterpolationFilters\",\n        colorprofile: \"colorProfile\",\n        \"color-profile\": \"colorProfile\",\n        colorrendering: \"colorRendering\",\n        \"color-rendering\": \"colorRendering\",\n        contentscripttype: \"contentScriptType\",\n        contentstyletype: \"contentStyleType\",\n        cursor: \"cursor\",\n        cx: \"cx\",\n        cy: \"cy\",\n        d: \"d\",\n        datatype: \"datatype\",\n        decelerate: \"decelerate\",\n        descent: \"descent\",\n        diffuseconstant: \"diffuseConstant\",\n        direction: \"direction\",\n        display: \"display\",\n        divisor: \"divisor\",\n        dominantbaseline: \"dominantBaseline\",\n        \"dominant-baseline\": \"dominantBaseline\",\n        dur: \"dur\",\n        dx: \"dx\",\n        dy: \"dy\",\n        edgemode: \"edgeMode\",\n        elevation: \"elevation\",\n        enablebackground: \"enableBackground\",\n        \"enable-background\": \"enableBackground\",\n        end: \"end\",\n        exponent: \"exponent\",\n        externalresourcesrequired: \"externalResourcesRequired\",\n        fill: \"fill\",\n        fillopacity: \"fillOpacity\",\n        \"fill-opacity\": \"fillOpacity\",\n        fillrule: \"fillRule\",\n        \"fill-rule\": \"fillRule\",\n        filter: \"filter\",\n        filterres: \"filterRes\",\n        filterunits: \"filterUnits\",\n        floodopacity: \"floodOpacity\",\n        \"flood-opacity\": \"floodOpacity\",\n        floodcolor: \"floodColor\",\n        \"flood-color\": \"floodColor\",\n        focusable: \"focusable\",\n        fontfamily: \"fontFamily\",\n        \"font-family\": \"fontFamily\",\n        fontsize: \"fontSize\",\n        \"font-size\": \"fontSize\",\n        fontsizeadjust: \"fontSizeAdjust\",\n        \"font-size-adjust\": \"fontSizeAdjust\",\n        fontstretch: \"fontStretch\",\n        \"font-stretch\": \"fontStretch\",\n        fontstyle: \"fontStyle\",\n        \"font-style\": \"fontStyle\",\n        fontvariant: \"fontVariant\",\n        \"font-variant\": \"fontVariant\",\n        fontweight: \"fontWeight\",\n        \"font-weight\": \"fontWeight\",\n        format: \"format\",\n        from: \"from\",\n        fx: \"fx\",\n        fy: \"fy\",\n        g1: \"g1\",\n        g2: \"g2\",\n        glyphname: \"glyphName\",\n        \"glyph-name\": \"glyphName\",\n        glyphorientationhorizontal: \"glyphOrientationHorizontal\",\n        \"glyph-orientation-horizontal\": \"glyphOrientationHorizontal\",\n        glyphorientationvertical: \"glyphOrientationVertical\",\n        \"glyph-orientation-vertical\": \"glyphOrientationVertical\",\n        glyphref: \"glyphRef\",\n        gradienttransform: \"gradientTransform\",\n        gradientunits: \"gradientUnits\",\n        hanging: \"hanging\",\n        horizadvx: \"horizAdvX\",\n        \"horiz-adv-x\": \"horizAdvX\",\n        horizoriginx: \"horizOriginX\",\n        \"horiz-origin-x\": \"horizOriginX\",\n        ideographic: \"ideographic\",\n        imagerendering: \"imageRendering\",\n        \"image-rendering\": \"imageRendering\",\n        in2: \"in2\",\n        in: \"in\",\n        inlist: \"inlist\",\n        intercept: \"intercept\",\n        k1: \"k1\",\n        k2: \"k2\",\n        k3: \"k3\",\n        k4: \"k4\",\n        k: \"k\",\n        kernelmatrix: \"kernelMatrix\",\n        kernelunitlength: \"kernelUnitLength\",\n        kerning: \"kerning\",\n        keypoints: \"keyPoints\",\n        keysplines: \"keySplines\",\n        keytimes: \"keyTimes\",\n        lengthadjust: \"lengthAdjust\",\n        letterspacing: \"letterSpacing\",\n        \"letter-spacing\": \"letterSpacing\",\n        lightingcolor: \"lightingColor\",\n        \"lighting-color\": \"lightingColor\",\n        limitingconeangle: \"limitingConeAngle\",\n        local: \"local\",\n        markerend: \"markerEnd\",\n        \"marker-end\": \"markerEnd\",\n        markerheight: \"markerHeight\",\n        markermid: \"markerMid\",\n        \"marker-mid\": \"markerMid\",\n        markerstart: \"markerStart\",\n        \"marker-start\": \"markerStart\",\n        markerunits: \"markerUnits\",\n        markerwidth: \"markerWidth\",\n        mask: \"mask\",\n        maskcontentunits: \"maskContentUnits\",\n        maskunits: \"maskUnits\",\n        mathematical: \"mathematical\",\n        mode: \"mode\",\n        numoctaves: \"numOctaves\",\n        offset: \"offset\",\n        opacity: \"opacity\",\n        operator: \"operator\",\n        order: \"order\",\n        orient: \"orient\",\n        orientation: \"orientation\",\n        origin: \"origin\",\n        overflow: \"overflow\",\n        overlineposition: \"overlinePosition\",\n        \"overline-position\": \"overlinePosition\",\n        overlinethickness: \"overlineThickness\",\n        \"overline-thickness\": \"overlineThickness\",\n        paintorder: \"paintOrder\",\n        \"paint-order\": \"paintOrder\",\n        panose1: \"panose1\",\n        \"panose-1\": \"panose1\",\n        pathlength: \"pathLength\",\n        patterncontentunits: \"patternContentUnits\",\n        patterntransform: \"patternTransform\",\n        patternunits: \"patternUnits\",\n        pointerevents: \"pointerEvents\",\n        \"pointer-events\": \"pointerEvents\",\n        points: \"points\",\n        pointsatx: \"pointsAtX\",\n        pointsaty: \"pointsAtY\",\n        pointsatz: \"pointsAtZ\",\n        popover: \"popover\",\n        popovertarget: \"popoverTarget\",\n        popovertargetaction: \"popoverTargetAction\",\n        prefix: \"prefix\",\n        preservealpha: \"preserveAlpha\",\n        preserveaspectratio: \"preserveAspectRatio\",\n        primitiveunits: \"primitiveUnits\",\n        property: \"property\",\n        r: \"r\",\n        radius: \"radius\",\n        refx: \"refX\",\n        refy: \"refY\",\n        renderingintent: \"renderingIntent\",\n        \"rendering-intent\": \"renderingIntent\",\n        repeatcount: \"repeatCount\",\n        repeatdur: \"repeatDur\",\n        requiredextensions: \"requiredExtensions\",\n        requiredfeatures: \"requiredFeatures\",\n        resource: \"resource\",\n        restart: \"restart\",\n        result: \"result\",\n        results: \"results\",\n        rotate: \"rotate\",\n        rx: \"rx\",\n        ry: \"ry\",\n        scale: \"scale\",\n        security: \"security\",\n        seed: \"seed\",\n        shaperendering: \"shapeRendering\",\n        \"shape-rendering\": \"shapeRendering\",\n        slope: \"slope\",\n        spacing: \"spacing\",\n        specularconstant: \"specularConstant\",\n        specularexponent: \"specularExponent\",\n        speed: \"speed\",\n        spreadmethod: \"spreadMethod\",\n        startoffset: \"startOffset\",\n        stddeviation: \"stdDeviation\",\n        stemh: \"stemh\",\n        stemv: \"stemv\",\n        stitchtiles: \"stitchTiles\",\n        stopcolor: \"stopColor\",\n        \"stop-color\": \"stopColor\",\n        stopopacity: \"stopOpacity\",\n        \"stop-opacity\": \"stopOpacity\",\n        strikethroughposition: \"strikethroughPosition\",\n        \"strikethrough-position\": \"strikethroughPosition\",\n        strikethroughthickness: \"strikethroughThickness\",\n        \"strikethrough-thickness\": \"strikethroughThickness\",\n        string: \"string\",\n        stroke: \"stroke\",\n        strokedasharray: \"strokeDasharray\",\n        \"stroke-dasharray\": \"strokeDasharray\",\n        strokedashoffset: \"strokeDashoffset\",\n        \"stroke-dashoffset\": \"strokeDashoffset\",\n        strokelinecap: \"strokeLinecap\",\n        \"stroke-linecap\": \"strokeLinecap\",\n        strokelinejoin: \"strokeLinejoin\",\n        \"stroke-linejoin\": \"strokeLinejoin\",\n        strokemiterlimit: \"strokeMiterlimit\",\n        \"stroke-miterlimit\": \"strokeMiterlimit\",\n        strokewidth: \"strokeWidth\",\n        \"stroke-width\": \"strokeWidth\",\n        strokeopacity: \"strokeOpacity\",\n        \"stroke-opacity\": \"strokeOpacity\",\n        suppresscontenteditablewarning: \"suppressContentEditableWarning\",\n        suppresshydrationwarning: \"suppressHydrationWarning\",\n        surfacescale: \"surfaceScale\",\n        systemlanguage: \"systemLanguage\",\n        tablevalues: \"tableValues\",\n        targetx: \"targetX\",\n        targety: \"targetY\",\n        textanchor: \"textAnchor\",\n        \"text-anchor\": \"textAnchor\",\n        textdecoration: \"textDecoration\",\n        \"text-decoration\": \"textDecoration\",\n        textlength: \"textLength\",\n        textrendering: \"textRendering\",\n        \"text-rendering\": \"textRendering\",\n        to: \"to\",\n        transform: \"transform\",\n        transformorigin: \"transformOrigin\",\n        \"transform-origin\": \"transformOrigin\",\n        typeof: \"typeof\",\n        u1: \"u1\",\n        u2: \"u2\",\n        underlineposition: \"underlinePosition\",\n        \"underline-position\": \"underlinePosition\",\n        underlinethickness: \"underlineThickness\",\n        \"underline-thickness\": \"underlineThickness\",\n        unicode: \"unicode\",\n        unicodebidi: \"unicodeBidi\",\n        \"unicode-bidi\": \"unicodeBidi\",\n        unicoderange: \"unicodeRange\",\n        \"unicode-range\": \"unicodeRange\",\n        unitsperem: \"unitsPerEm\",\n        \"units-per-em\": \"unitsPerEm\",\n        unselectable: \"unselectable\",\n        valphabetic: \"vAlphabetic\",\n        \"v-alphabetic\": \"vAlphabetic\",\n        values: \"values\",\n        vectoreffect: \"vectorEffect\",\n        \"vector-effect\": \"vectorEffect\",\n        version: \"version\",\n        vertadvy: \"vertAdvY\",\n        \"vert-adv-y\": \"vertAdvY\",\n        vertoriginx: \"vertOriginX\",\n        \"vert-origin-x\": \"vertOriginX\",\n        vertoriginy: \"vertOriginY\",\n        \"vert-origin-y\": \"vertOriginY\",\n        vhanging: \"vHanging\",\n        \"v-hanging\": \"vHanging\",\n        videographic: \"vIdeographic\",\n        \"v-ideographic\": \"vIdeographic\",\n        viewbox: \"viewBox\",\n        viewtarget: \"viewTarget\",\n        visibility: \"visibility\",\n        vmathematical: \"vMathematical\",\n        \"v-mathematical\": \"vMathematical\",\n        vocab: \"vocab\",\n        widths: \"widths\",\n        wordspacing: \"wordSpacing\",\n        \"word-spacing\": \"wordSpacing\",\n        writingmode: \"writingMode\",\n        \"writing-mode\": \"writingMode\",\n        x1: \"x1\",\n        x2: \"x2\",\n        x: \"x\",\n        xchannelselector: \"xChannelSelector\",\n        xheight: \"xHeight\",\n        \"x-height\": \"xHeight\",\n        xlinkactuate: \"xlinkActuate\",\n        \"xlink:actuate\": \"xlinkActuate\",\n        xlinkarcrole: \"xlinkArcrole\",\n        \"xlink:arcrole\": \"xlinkArcrole\",\n        xlinkhref: \"xlinkHref\",\n        \"xlink:href\": \"xlinkHref\",\n        xlinkrole: \"xlinkRole\",\n        \"xlink:role\": \"xlinkRole\",\n        xlinkshow: \"xlinkShow\",\n        \"xlink:show\": \"xlinkShow\",\n        xlinktitle: \"xlinkTitle\",\n        \"xlink:title\": \"xlinkTitle\",\n        xlinktype: \"xlinkType\",\n        \"xlink:type\": \"xlinkType\",\n        xmlbase: \"xmlBase\",\n        \"xml:base\": \"xmlBase\",\n        xmllang: \"xmlLang\",\n        \"xml:lang\": \"xmlLang\",\n        xmlns: \"xmlns\",\n        \"xml:space\": \"xmlSpace\",\n        xmlnsxlink: \"xmlnsXlink\",\n        \"xmlns:xlink\": \"xmlnsXlink\",\n        xmlspace: \"xmlSpace\",\n        y1: \"y1\",\n        y2: \"y2\",\n        y: \"y\",\n        ychannelselector: \"yChannelSelector\",\n        z: \"z\",\n        zoomandpan: \"zoomAndPan\"\n      },\n      warnedProperties = {},\n      EVENT_NAME_REGEX = /^on./,\n      INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/,\n      rARIA = RegExp(\n        \"^(aria)-[:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]*$\"\n      ),\n      rARIACamel = RegExp(\n        \"^(aria)[A-Z][:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]*$\"\n      ),\n      badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/,\n      msPattern$1 = /^-ms-/,\n      hyphenPattern = /-(.)/g,\n      badStyleValueWithSemicolonPattern = /;\\s*$/,\n      warnedStyleNames = {},\n      warnedStyleValues = {},\n      warnedForNaNValue = !1,\n      warnedForInfinityValue = !1,\n      matchHtmlRegExp = /[\"'&<>]/,\n      uppercasePattern = /([A-Z])/g,\n      msPattern = /^ms-/,\n      isJavaScriptProtocol =\n        /^[\\u0000-\\u001F ]*j[\\r\\n\\t]*a[\\r\\n\\t]*v[\\r\\n\\t]*a[\\r\\n\\t]*s[\\r\\n\\t]*c[\\r\\n\\t]*r[\\r\\n\\t]*i[\\r\\n\\t]*p[\\r\\n\\t]*t[\\r\\n\\t]*:/i,\n      ReactSharedInternals =\n        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      ReactDOMSharedInternals =\n        ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      NotPending = Object.freeze({\n        pending: !1,\n        data: null,\n        method: null,\n        action: null\n      }),\n      previousDispatcher = ReactDOMSharedInternals.d;\n    ReactDOMSharedInternals.d = {\n      f: previousDispatcher.f,\n      r: previousDispatcher.r,\n      D: function (href) {\n        var request = currentRequest ? currentRequest : null;\n        if (request) {\n          var resumableState = request.resumableState,\n            renderState = request.renderState;\n          if (\"string\" === typeof href && href) {\n            if (!resumableState.dnsResources.hasOwnProperty(href)) {\n              resumableState.dnsResources[href] = EXISTS;\n              resumableState = renderState.headers;\n              var header, JSCompiler_temp;\n              if (\n                (JSCompiler_temp =\n                  resumableState && 0 < resumableState.remainingCapacity)\n              )\n                JSCompiler_temp =\n                  ((header =\n                    \"<\" +\n                    escapeHrefForLinkHeaderURLContext(href) +\n                    \">; rel=dns-prefetch\"),\n                  0 <= (resumableState.remainingCapacity -= header.length + 2));\n              JSCompiler_temp\n                ? ((renderState.resets.dns[href] = EXISTS),\n                  resumableState.preconnects &&\n                    (resumableState.preconnects += \", \"),\n                  (resumableState.preconnects += header))\n                : ((header = []),\n                  pushLinkImpl(header, { href: href, rel: \"dns-prefetch\" }),\n                  renderState.preconnects.add(header));\n            }\n            enqueueFlush(request);\n          }\n        } else previousDispatcher.D(href);\n      },\n      C: function (href, crossOrigin) {\n        var request = currentRequest ? currentRequest : null;\n        if (request) {\n          var resumableState = request.resumableState,\n            renderState = request.renderState;\n          if (\"string\" === typeof href && href) {\n            var bucket =\n              \"use-credentials\" === crossOrigin\n                ? \"credentials\"\n                : \"string\" === typeof crossOrigin\n                  ? \"anonymous\"\n                  : \"default\";\n            if (!resumableState.connectResources[bucket].hasOwnProperty(href)) {\n              resumableState.connectResources[bucket][href] = EXISTS;\n              resumableState = renderState.headers;\n              var header, JSCompiler_temp;\n              if (\n                (JSCompiler_temp =\n                  resumableState && 0 < resumableState.remainingCapacity)\n              ) {\n                JSCompiler_temp =\n                  \"<\" +\n                  escapeHrefForLinkHeaderURLContext(href) +\n                  \">; rel=preconnect\";\n                if (\"string\" === typeof crossOrigin) {\n                  var escapedCrossOrigin =\n                    escapeStringForLinkHeaderQuotedParamValueContext(\n                      crossOrigin,\n                      \"crossOrigin\"\n                    );\n                  JSCompiler_temp +=\n                    '; crossorigin=\"' + escapedCrossOrigin + '\"';\n                }\n                JSCompiler_temp =\n                  ((header = JSCompiler_temp),\n                  0 <= (resumableState.remainingCapacity -= header.length + 2));\n              }\n              JSCompiler_temp\n                ? ((renderState.resets.connect[bucket][href] = EXISTS),\n                  resumableState.preconnects &&\n                    (resumableState.preconnects += \", \"),\n                  (resumableState.preconnects += header))\n                : ((bucket = []),\n                  pushLinkImpl(bucket, {\n                    rel: \"preconnect\",\n                    href: href,\n                    crossOrigin: crossOrigin\n                  }),\n                  renderState.preconnects.add(bucket));\n            }\n            enqueueFlush(request);\n          }\n        } else previousDispatcher.C(href, crossOrigin);\n      },\n      L: function (href, as, options) {\n        var request = currentRequest ? currentRequest : null;\n        if (request) {\n          var resumableState = request.resumableState,\n            renderState = request.renderState;\n          if (as && href) {\n            switch (as) {\n              case \"image\":\n                if (options) {\n                  var imageSrcSet = options.imageSrcSet;\n                  var imageSizes = options.imageSizes;\n                  var fetchPriority = options.fetchPriority;\n                }\n                var key = imageSrcSet\n                  ? imageSrcSet + \"\\n\" + (imageSizes || \"\")\n                  : href;\n                if (resumableState.imageResources.hasOwnProperty(key)) return;\n                resumableState.imageResources[key] = PRELOAD_NO_CREDS;\n                resumableState = renderState.headers;\n                var header;\n                resumableState &&\n                0 < resumableState.remainingCapacity &&\n                \"high\" === fetchPriority &&\n                ((header = getPreloadAsHeader(href, as, options)),\n                0 <= (resumableState.remainingCapacity -= header.length + 2))\n                  ? ((renderState.resets.image[key] = PRELOAD_NO_CREDS),\n                    resumableState.highImagePreloads &&\n                      (resumableState.highImagePreloads += \", \"),\n                    (resumableState.highImagePreloads += header))\n                  : ((resumableState = []),\n                    pushLinkImpl(\n                      resumableState,\n                      assign(\n                        {\n                          rel: \"preload\",\n                          href: imageSrcSet ? void 0 : href,\n                          as: as\n                        },\n                        options\n                      )\n                    ),\n                    \"high\" === fetchPriority\n                      ? renderState.highImagePreloads.add(resumableState)\n                      : (renderState.bulkPreloads.add(resumableState),\n                        renderState.preloads.images.set(key, resumableState)));\n                break;\n              case \"style\":\n                if (resumableState.styleResources.hasOwnProperty(href)) return;\n                imageSrcSet = [];\n                pushLinkImpl(\n                  imageSrcSet,\n                  assign({ rel: \"preload\", href: href, as: as }, options)\n                );\n                resumableState.styleResources[href] =\n                  !options ||\n                  (\"string\" !== typeof options.crossOrigin &&\n                    \"string\" !== typeof options.integrity)\n                    ? PRELOAD_NO_CREDS\n                    : [options.crossOrigin, options.integrity];\n                renderState.preloads.stylesheets.set(href, imageSrcSet);\n                renderState.bulkPreloads.add(imageSrcSet);\n                break;\n              case \"script\":\n                if (resumableState.scriptResources.hasOwnProperty(href)) return;\n                imageSrcSet = [];\n                renderState.preloads.scripts.set(href, imageSrcSet);\n                renderState.bulkPreloads.add(imageSrcSet);\n                pushLinkImpl(\n                  imageSrcSet,\n                  assign({ rel: \"preload\", href: href, as: as }, options)\n                );\n                resumableState.scriptResources[href] =\n                  !options ||\n                  (\"string\" !== typeof options.crossOrigin &&\n                    \"string\" !== typeof options.integrity)\n                    ? PRELOAD_NO_CREDS\n                    : [options.crossOrigin, options.integrity];\n                break;\n              default:\n                if (resumableState.unknownResources.hasOwnProperty(as)) {\n                  if (\n                    ((imageSrcSet = resumableState.unknownResources[as]),\n                    imageSrcSet.hasOwnProperty(href))\n                  )\n                    return;\n                } else\n                  (imageSrcSet = {}),\n                    (resumableState.unknownResources[as] = imageSrcSet);\n                imageSrcSet[href] = PRELOAD_NO_CREDS;\n                if (\n                  (resumableState = renderState.headers) &&\n                  0 < resumableState.remainingCapacity &&\n                  \"font\" === as &&\n                  ((key = getPreloadAsHeader(href, as, options)),\n                  0 <= (resumableState.remainingCapacity -= key.length + 2))\n                )\n                  (renderState.resets.font[href] = PRELOAD_NO_CREDS),\n                    resumableState.fontPreloads &&\n                      (resumableState.fontPreloads += \", \"),\n                    (resumableState.fontPreloads += key);\n                else\n                  switch (\n                    ((resumableState = []),\n                    (href = assign(\n                      { rel: \"preload\", href: href, as: as },\n                      options\n                    )),\n                    pushLinkImpl(resumableState, href),\n                    as)\n                  ) {\n                    case \"font\":\n                      renderState.fontPreloads.add(resumableState);\n                      break;\n                    default:\n                      renderState.bulkPreloads.add(resumableState);\n                  }\n            }\n            enqueueFlush(request);\n          }\n        } else previousDispatcher.L(href, as, options);\n      },\n      m: function (href, options) {\n        var request = currentRequest ? currentRequest : null;\n        if (request) {\n          var resumableState = request.resumableState,\n            renderState = request.renderState;\n          if (href) {\n            var as =\n              options && \"string\" === typeof options.as ? options.as : \"script\";\n            switch (as) {\n              case \"script\":\n                if (resumableState.moduleScriptResources.hasOwnProperty(href))\n                  return;\n                as = [];\n                resumableState.moduleScriptResources[href] =\n                  !options ||\n                  (\"string\" !== typeof options.crossOrigin &&\n                    \"string\" !== typeof options.integrity)\n                    ? PRELOAD_NO_CREDS\n                    : [options.crossOrigin, options.integrity];\n                renderState.preloads.moduleScripts.set(href, as);\n                break;\n              default:\n                if (resumableState.moduleUnknownResources.hasOwnProperty(as)) {\n                  var resources = resumableState.unknownResources[as];\n                  if (resources.hasOwnProperty(href)) return;\n                } else\n                  (resources = {}),\n                    (resumableState.moduleUnknownResources[as] = resources);\n                as = [];\n                resources[href] = PRELOAD_NO_CREDS;\n            }\n            pushLinkImpl(\n              as,\n              assign({ rel: \"modulepreload\", href: href }, options)\n            );\n            renderState.bulkPreloads.add(as);\n            enqueueFlush(request);\n          }\n        } else previousDispatcher.m(href, options);\n      },\n      X: function (src, options) {\n        var request = currentRequest ? currentRequest : null;\n        if (request) {\n          var resumableState = request.resumableState,\n            renderState = request.renderState;\n          if (src) {\n            var resourceState = resumableState.scriptResources.hasOwnProperty(\n              src\n            )\n              ? resumableState.scriptResources[src]\n              : void 0;\n            resourceState !== EXISTS &&\n              ((resumableState.scriptResources[src] = EXISTS),\n              (options = assign({ src: src, async: !0 }, options)),\n              resourceState &&\n                (2 === resourceState.length &&\n                  adoptPreloadCredentials(options, resourceState),\n                (src = renderState.preloads.scripts.get(src))) &&\n                (src.length = 0),\n              (src = []),\n              renderState.scripts.add(src),\n              pushScriptImpl(src, options),\n              enqueueFlush(request));\n          }\n        } else previousDispatcher.X(src, options);\n      },\n      S: function (href, precedence, options) {\n        var request = currentRequest ? currentRequest : null;\n        if (request) {\n          var resumableState = request.resumableState,\n            renderState = request.renderState;\n          if (href) {\n            precedence = precedence || \"default\";\n            var styleQueue = renderState.styles.get(precedence),\n              resourceState = resumableState.styleResources.hasOwnProperty(href)\n                ? resumableState.styleResources[href]\n                : void 0;\n            resourceState !== EXISTS &&\n              ((resumableState.styleResources[href] = EXISTS),\n              styleQueue ||\n                ((styleQueue = {\n                  precedence: stringToChunk(escapeTextForBrowser(precedence)),\n                  rules: [],\n                  hrefs: [],\n                  sheets: new Map()\n                }),\n                renderState.styles.set(precedence, styleQueue)),\n              (precedence = {\n                state: PENDING$1,\n                props: assign(\n                  {\n                    rel: \"stylesheet\",\n                    href: href,\n                    \"data-precedence\": precedence\n                  },\n                  options\n                )\n              }),\n              resourceState &&\n                (2 === resourceState.length &&\n                  adoptPreloadCredentials(precedence.props, resourceState),\n                (renderState = renderState.preloads.stylesheets.get(href)) &&\n                0 < renderState.length\n                  ? (renderState.length = 0)\n                  : (precedence.state = PRELOADED)),\n              styleQueue.sheets.set(href, precedence),\n              enqueueFlush(request));\n          }\n        } else previousDispatcher.S(href, precedence, options);\n      },\n      M: function (src, options) {\n        var request = currentRequest ? currentRequest : null;\n        if (request) {\n          var resumableState = request.resumableState,\n            renderState = request.renderState;\n          if (src) {\n            var resourceState =\n              resumableState.moduleScriptResources.hasOwnProperty(src)\n                ? resumableState.moduleScriptResources[src]\n                : void 0;\n            resourceState !== EXISTS &&\n              ((resumableState.moduleScriptResources[src] = EXISTS),\n              (options = assign(\n                { src: src, type: \"module\", async: !0 },\n                options\n              )),\n              resourceState &&\n                (2 === resourceState.length &&\n                  adoptPreloadCredentials(options, resourceState),\n                (src = renderState.preloads.moduleScripts.get(src))) &&\n                (src.length = 0),\n              (src = []),\n              renderState.scripts.add(src),\n              pushScriptImpl(src, options),\n              enqueueFlush(request));\n          }\n        } else previousDispatcher.M(src, options);\n      }\n    };\n    var NothingSent = 0,\n      SentCompleteSegmentFunction = 1,\n      SentCompleteBoundaryFunction = 2,\n      SentClientRenderFunction = 4,\n      SentStyleInsertionFunction = 8,\n      EXISTS = null,\n      PRELOAD_NO_CREDS = [];\n    Object.freeze(PRELOAD_NO_CREDS);\n    stringToPrecomputedChunk('\"></template>');\n    var startInlineScript = stringToPrecomputedChunk(\"<script>\"),\n      endInlineScript = stringToPrecomputedChunk(\"\\x3c/script>\"),\n      startScriptSrc = stringToPrecomputedChunk('<script src=\"'),\n      startModuleSrc = stringToPrecomputedChunk('<script type=\"module\" src=\"'),\n      scriptNonce = stringToPrecomputedChunk('\" nonce=\"'),\n      scriptIntegirty = stringToPrecomputedChunk('\" integrity=\"'),\n      scriptCrossOrigin = stringToPrecomputedChunk('\" crossorigin=\"'),\n      endAsyncScript = stringToPrecomputedChunk('\" async=\"\">\\x3c/script>'),\n      scriptRegex = /(<\\/|<)(s)(cript)/gi,\n      importMapScriptStart = stringToPrecomputedChunk(\n        '<script type=\"importmap\">'\n      ),\n      importMapScriptEnd = stringToPrecomputedChunk(\"\\x3c/script>\");\n    var didWarnForNewBooleanPropsWithEmptyValue = {};\n    var ROOT_HTML_MODE = 0,\n      HTML_HTML_MODE = 1,\n      HTML_MODE = 2,\n      SVG_MODE = 3,\n      MATHML_MODE = 4,\n      HTML_TABLE_MODE = 5,\n      HTML_TABLE_BODY_MODE = 6,\n      HTML_TABLE_ROW_MODE = 7,\n      HTML_COLGROUP_MODE = 8,\n      textSeparator = stringToPrecomputedChunk(\"\\x3c!-- --\\x3e\"),\n      styleNameCache = new Map(),\n      styleAttributeStart = stringToPrecomputedChunk(' style=\"'),\n      styleAssign = stringToPrecomputedChunk(\":\"),\n      styleSeparator = stringToPrecomputedChunk(\";\"),\n      attributeSeparator = stringToPrecomputedChunk(\" \"),\n      attributeAssign = stringToPrecomputedChunk('=\"'),\n      attributeEnd = stringToPrecomputedChunk('\"'),\n      attributeEmptyString = stringToPrecomputedChunk('=\"\"'),\n      actionJavaScriptURL = stringToPrecomputedChunk(\n        escapeTextForBrowser(\n          \"javascript:throw new Error('React form unexpectedly submitted.')\"\n        )\n      ),\n      startHiddenInputChunk = stringToPrecomputedChunk('<input type=\"hidden\"'),\n      endOfStartTag = stringToPrecomputedChunk(\">\"),\n      endOfStartTagSelfClosing = stringToPrecomputedChunk(\"/>\"),\n      didWarnDefaultInputValue = !1,\n      didWarnDefaultChecked = !1,\n      didWarnDefaultSelectValue = !1,\n      didWarnDefaultTextareaValue = !1,\n      didWarnInvalidOptionChildren = !1,\n      didWarnInvalidOptionInnerHTML = !1,\n      didWarnSelectedSetOnOption = !1,\n      didWarnFormActionType = !1,\n      didWarnFormActionName = !1,\n      didWarnFormActionTarget = !1,\n      didWarnFormActionMethod = !1,\n      selectedMarkerAttribute = stringToPrecomputedChunk(' selected=\"\"'),\n      formReplayingRuntimeScript = stringToPrecomputedChunk(\n        'addEventListener(\"submit\",function(a){if(!a.defaultPrevented){var c=a.target,d=a.submitter,e=c.action,b=d;if(d){var f=d.getAttribute(\"formAction\");null!=f&&(e=f,b=null)}\"javascript:throw new Error(\\'React form unexpectedly submitted.\\')\"===e&&(a.preventDefault(),b?(a=document.createElement(\"input\"),a.name=b.name,a.value=b.value,b.parentNode.insertBefore(a,b),b=new FormData(c),a.parentNode.removeChild(a)):b=new FormData(c),a=c.ownerDocument||c,(a.$$reactFormReplay=a.$$reactFormReplay||[]).push(c,d,b))}});'\n      ),\n      formStateMarkerIsMatching = stringToPrecomputedChunk(\"\\x3c!--F!--\\x3e\"),\n      formStateMarkerIsNotMatching = stringToPrecomputedChunk(\"\\x3c!--F--\\x3e\"),\n      styleRegex = /(<\\/|<)(s)(tyle)/gi,\n      leadingNewline = stringToPrecomputedChunk(\"\\n\"),\n      VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\\.\\-\\d]*$/,\n      validatedTagCache = new Map(),\n      doctypeChunk = stringToPrecomputedChunk(\"<!DOCTYPE html>\"),\n      endTagCache = new Map(),\n      placeholder1 = stringToPrecomputedChunk('<template id=\"'),\n      placeholder2 = stringToPrecomputedChunk('\"></template>'),\n      startCompletedSuspenseBoundary =\n        stringToPrecomputedChunk(\"\\x3c!--$--\\x3e\"),\n      startPendingSuspenseBoundary1 = stringToPrecomputedChunk(\n        '\\x3c!--$?--\\x3e<template id=\"'\n      ),\n      startPendingSuspenseBoundary2 = stringToPrecomputedChunk('\"></template>'),\n      startClientRenderedSuspenseBoundary =\n        stringToPrecomputedChunk(\"\\x3c!--$!--\\x3e\"),\n      endSuspenseBoundary = stringToPrecomputedChunk(\"\\x3c!--/$--\\x3e\"),\n      clientRenderedSuspenseBoundaryError1 =\n        stringToPrecomputedChunk(\"<template\"),\n      clientRenderedSuspenseBoundaryErrorAttrInterstitial =\n        stringToPrecomputedChunk('\"'),\n      clientRenderedSuspenseBoundaryError1A =\n        stringToPrecomputedChunk(' data-dgst=\"'),\n      clientRenderedSuspenseBoundaryError1B =\n        stringToPrecomputedChunk(' data-msg=\"'),\n      clientRenderedSuspenseBoundaryError1C =\n        stringToPrecomputedChunk(' data-stck=\"'),\n      clientRenderedSuspenseBoundaryError1D =\n        stringToPrecomputedChunk(' data-cstck=\"'),\n      clientRenderedSuspenseBoundaryError2 =\n        stringToPrecomputedChunk(\"></template>\"),\n      startSegmentHTML = stringToPrecomputedChunk('<div hidden id=\"'),\n      startSegmentHTML2 = stringToPrecomputedChunk('\">'),\n      endSegmentHTML = stringToPrecomputedChunk(\"</div>\"),\n      startSegmentSVG = stringToPrecomputedChunk(\n        '<svg aria-hidden=\"true\" style=\"display:none\" id=\"'\n      ),\n      startSegmentSVG2 = stringToPrecomputedChunk('\">'),\n      endSegmentSVG = stringToPrecomputedChunk(\"</svg>\"),\n      startSegmentMathML = stringToPrecomputedChunk(\n        '<math aria-hidden=\"true\" style=\"display:none\" id=\"'\n      ),\n      startSegmentMathML2 = stringToPrecomputedChunk('\">'),\n      endSegmentMathML = stringToPrecomputedChunk(\"</math>\"),\n      startSegmentTable = stringToPrecomputedChunk('<table hidden id=\"'),\n      startSegmentTable2 = stringToPrecomputedChunk('\">'),\n      endSegmentTable = stringToPrecomputedChunk(\"</table>\"),\n      startSegmentTableBody = stringToPrecomputedChunk(\n        '<table hidden><tbody id=\"'\n      ),\n      startSegmentTableBody2 = stringToPrecomputedChunk('\">'),\n      endSegmentTableBody = stringToPrecomputedChunk(\"</tbody></table>\"),\n      startSegmentTableRow = stringToPrecomputedChunk('<table hidden><tr id=\"'),\n      startSegmentTableRow2 = stringToPrecomputedChunk('\">'),\n      endSegmentTableRow = stringToPrecomputedChunk(\"</tr></table>\"),\n      startSegmentColGroup = stringToPrecomputedChunk(\n        '<table hidden><colgroup id=\"'\n      ),\n      startSegmentColGroup2 = stringToPrecomputedChunk('\">'),\n      endSegmentColGroup = stringToPrecomputedChunk(\"</colgroup></table>\"),\n      completeSegmentScript1Full = stringToPrecomputedChunk(\n        '$RS=function(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS(\"'\n      ),\n      completeSegmentScript1Partial = stringToPrecomputedChunk('$RS(\"'),\n      completeSegmentScript2 = stringToPrecomputedChunk('\",\"'),\n      completeSegmentScriptEnd = stringToPrecomputedChunk('\")\\x3c/script>');\n    stringToPrecomputedChunk('<template data-rsi=\"\" data-sid=\"');\n    stringToPrecomputedChunk('\" data-pid=\"');\n    var completeBoundaryScript1Full = stringToPrecomputedChunk(\n        '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data=\"$!\",a.setAttribute(\"data-dgst\",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if(\"/$\"===d)if(0===f)break;else f--;else\"$\"!==d&&\"$?\"!==d&&\"$!\"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data=\"$\"}b._reactRetry&&b._reactRetry()}};$RC(\"'\n      ),\n      completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC(\"'),\n      completeBoundaryWithStylesScript1FullBoth = stringToPrecomputedChunk(\n        '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data=\"$!\",a.setAttribute(\"data-dgst\",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if(\"/$\"===d)if(0===f)break;else f--;else\"$\"!==d&&\"$?\"!==d&&\"$!\"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data=\"$\"}b._reactRetry&&b._reactRetry()}};$RM=new Map;\\n$RR=function(t,u,y){function v(n){this._p=null;n()}for(var w=$RC,p=$RM,q=new Map,r=document,g,b,h=r.querySelectorAll(\"link[data-precedence],style[data-precedence]\"),x=[],k=0;b=h[k++];)\"not all\"===b.getAttribute(\"media\")?x.push(b):(\"LINK\"===b.tagName&&p.set(b.getAttribute(\"href\"),b),q.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var e=y[b++];if(!e){k=!1;b=0;continue}var c=!1,m=0;var d=e[m++];if(a=p.get(d)){var f=a._p;c=!0}else{a=r.createElement(\"link\");a.href=\\nd;a.rel=\"stylesheet\";for(a.dataset.precedence=l=e[m++];f=e[m++];)a.setAttribute(f,e[m++]);f=a._p=new Promise(function(n,z){a.onload=v.bind(a,n);a.onerror=v.bind(a,z)});p.set(d,a)}d=a.getAttribute(\"media\");!f||d&&!matchMedia(d).matches||h.push(f);if(c)continue}else{a=x[b++];if(!a)break;l=a.getAttribute(\"data-precedence\");a.removeAttribute(\"media\")}c=q.get(l)||g;c===g&&(g=a);q.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=r.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(w.bind(null,\\nt,u,\"\"),w.bind(null,t,u,\"Resource failed to load\"))};$RR(\"'\n      ),\n      completeBoundaryWithStylesScript1FullPartial = stringToPrecomputedChunk(\n        '$RM=new Map;\\n$RR=function(t,u,y){function v(n){this._p=null;n()}for(var w=$RC,p=$RM,q=new Map,r=document,g,b,h=r.querySelectorAll(\"link[data-precedence],style[data-precedence]\"),x=[],k=0;b=h[k++];)\"not all\"===b.getAttribute(\"media\")?x.push(b):(\"LINK\"===b.tagName&&p.set(b.getAttribute(\"href\"),b),q.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var e=y[b++];if(!e){k=!1;b=0;continue}var c=!1,m=0;var d=e[m++];if(a=p.get(d)){var f=a._p;c=!0}else{a=r.createElement(\"link\");a.href=\\nd;a.rel=\"stylesheet\";for(a.dataset.precedence=l=e[m++];f=e[m++];)a.setAttribute(f,e[m++]);f=a._p=new Promise(function(n,z){a.onload=v.bind(a,n);a.onerror=v.bind(a,z)});p.set(d,a)}d=a.getAttribute(\"media\");!f||d&&!matchMedia(d).matches||h.push(f);if(c)continue}else{a=x[b++];if(!a)break;l=a.getAttribute(\"data-precedence\");a.removeAttribute(\"media\")}c=q.get(l)||g;c===g&&(g=a);q.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=r.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(w.bind(null,\\nt,u,\"\"),w.bind(null,t,u,\"Resource failed to load\"))};$RR(\"'\n      ),\n      completeBoundaryWithStylesScript1Partial =\n        stringToPrecomputedChunk('$RR(\"'),\n      completeBoundaryScript2 = stringToPrecomputedChunk('\",\"'),\n      completeBoundaryScript3a = stringToPrecomputedChunk('\",'),\n      completeBoundaryScript3b = stringToPrecomputedChunk('\"'),\n      completeBoundaryScriptEnd = stringToPrecomputedChunk(\")\\x3c/script>\");\n    stringToPrecomputedChunk('<template data-rci=\"\" data-bid=\"');\n    stringToPrecomputedChunk('<template data-rri=\"\" data-bid=\"');\n    stringToPrecomputedChunk('\" data-sid=\"');\n    stringToPrecomputedChunk('\" data-sty=\"');\n    var clientRenderScript1Full = stringToPrecomputedChunk(\n        '$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data=\"$!\",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};;$RX(\"'\n      ),\n      clientRenderScript1Partial = stringToPrecomputedChunk('$RX(\"'),\n      clientRenderScript1A = stringToPrecomputedChunk('\"'),\n      clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(\",\"),\n      clientRenderScriptEnd = stringToPrecomputedChunk(\")\\x3c/script>\");\n    stringToPrecomputedChunk('<template data-rxi=\"\" data-bid=\"');\n    stringToPrecomputedChunk('\" data-dgst=\"');\n    stringToPrecomputedChunk('\" data-msg=\"');\n    stringToPrecomputedChunk('\" data-stck=\"');\n    stringToPrecomputedChunk('\" data-cstck=\"');\n    var regexForJSStringsInInstructionScripts = /[<\\u2028\\u2029]/g,\n      regexForJSStringsInScripts = /[&><\\u2028\\u2029]/g,\n      lateStyleTagResourceOpen1 = stringToPrecomputedChunk(\n        '<style media=\"not all\" data-precedence=\"'\n      ),\n      lateStyleTagResourceOpen2 = stringToPrecomputedChunk('\" data-href=\"'),\n      lateStyleTagResourceOpen3 = stringToPrecomputedChunk('\">'),\n      lateStyleTagTemplateClose = stringToPrecomputedChunk(\"</style>\"),\n      currentlyRenderingBoundaryHasStylesToHoist = !1,\n      destinationHasCapacity = !0,\n      stylesheetFlushingQueue = [],\n      styleTagResourceOpen1 = stringToPrecomputedChunk(\n        '<style data-precedence=\"'\n      ),\n      styleTagResourceOpen2 = stringToPrecomputedChunk('\" data-href=\"'),\n      spaceSeparator = stringToPrecomputedChunk(\" \"),\n      styleTagResourceOpen3 = stringToPrecomputedChunk('\">'),\n      styleTagResourceClose = stringToPrecomputedChunk(\"</style>\"),\n      arrayFirstOpenBracket = stringToPrecomputedChunk(\"[\"),\n      arraySubsequentOpenBracket = stringToPrecomputedChunk(\",[\"),\n      arrayInterstitial = stringToPrecomputedChunk(\",\"),\n      arrayCloseBracket = stringToPrecomputedChunk(\"]\"),\n      PENDING$1 = 0,\n      PRELOADED = 1,\n      PREAMBLE = 2,\n      LATE = 3,\n      regexForHrefInLinkHeaderURLContext = /[<>\\r\\n]/g,\n      regexForLinkHeaderQuotedParamValueContext = /[\"';,\\r\\n]/g,\n      bind = Function.prototype.bind,\n      REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n      emptyContextObject = {};\n    Object.freeze(emptyContextObject);\n    var rendererSigil = {};\n    var currentActiveSnapshot = null,\n      didWarnAboutNoopUpdateForComponent = {},\n      didWarnAboutDeprecatedWillMount = {};\n    var didWarnAboutUninitializedState = new Set();\n    var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\n    var didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\n    var didWarnAboutDirectlyAssigningPropsToState = new Set();\n    var didWarnAboutUndefinedDerivedState = new Set();\n    var didWarnAboutContextTypes$1 = new Set();\n    var didWarnAboutChildContextTypes = new Set();\n    var didWarnAboutInvalidateContextType = new Set();\n    var didWarnOnInvalidCallback = new Set();\n    var classComponentUpdater = {\n        isMounted: function () {\n          return !1;\n        },\n        enqueueSetState: function (inst, payload, callback) {\n          var internals = inst._reactInternals;\n          null === internals.queue\n            ? warnNoop(inst, \"setState\")\n            : (internals.queue.push(payload),\n              void 0 !== callback &&\n                null !== callback &&\n                warnOnInvalidCallback(callback));\n        },\n        enqueueReplaceState: function (inst, payload, callback) {\n          inst = inst._reactInternals;\n          inst.replace = !0;\n          inst.queue = [payload];\n          void 0 !== callback &&\n            null !== callback &&\n            warnOnInvalidCallback(callback);\n        },\n        enqueueForceUpdate: function (inst, callback) {\n          null === inst._reactInternals.queue\n            ? warnNoop(inst, \"forceUpdate\")\n            : void 0 !== callback &&\n              null !== callback &&\n              warnOnInvalidCallback(callback);\n        }\n      },\n      emptyTreeContext = { id: 1, overflow: \"\" },\n      clz32 = Math.clz32 ? Math.clz32 : clz32Fallback,\n      log = Math.log,\n      LN2 = Math.LN2,\n      SuspenseException = Error(\n        \"Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\\n\\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`.\"\n      ),\n      suspendedThenable = null,\n      objectIs = \"function\" === typeof Object.is ? Object.is : is,\n      currentlyRenderingComponent = null,\n      currentlyRenderingTask = null,\n      currentlyRenderingRequest = null,\n      currentlyRenderingKeyPath = null,\n      firstWorkInProgressHook = null,\n      workInProgressHook = null,\n      isReRender = !1,\n      didScheduleRenderPhaseUpdate = !1,\n      localIdCounter = 0,\n      actionStateCounter = 0,\n      actionStateMatchingIndex = -1,\n      thenableIndexCounter = 0,\n      thenableState = null,\n      renderPhaseUpdates = null,\n      numberOfReRenders = 0,\n      isInHookUserCodeInDev = !1,\n      currentHookNameInDev,\n      HooksDispatcher = {\n        readContext: readContext,\n        use: function (usable) {\n          if (null !== usable && \"object\" === typeof usable) {\n            if (\"function\" === typeof usable.then)\n              return unwrapThenable(usable);\n            if (usable.$$typeof === REACT_CONTEXT_TYPE)\n              return readContext(usable);\n          }\n          throw Error(\n            \"An unsupported type was passed to use(): \" + String(usable)\n          );\n        },\n        useContext: function (context) {\n          currentHookNameInDev = \"useContext\";\n          resolveCurrentlyRenderingComponent();\n          return context._currentValue;\n        },\n        useMemo: useMemo,\n        useReducer: useReducer,\n        useRef: function (initialValue) {\n          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n          workInProgressHook = createWorkInProgressHook();\n          var previousRef = workInProgressHook.memoizedState;\n          return null === previousRef\n            ? ((initialValue = { current: initialValue }),\n              Object.seal(initialValue),\n              (workInProgressHook.memoizedState = initialValue))\n            : previousRef;\n        },\n        useState: function (initialState) {\n          currentHookNameInDev = \"useState\";\n          return useReducer(basicStateReducer, initialState);\n        },\n        useInsertionEffect: noop$1,\n        useLayoutEffect: noop$1,\n        useCallback: function (callback, deps) {\n          return useMemo(function () {\n            return callback;\n          }, deps);\n        },\n        useImperativeHandle: noop$1,\n        useEffect: noop$1,\n        useDebugValue: noop$1,\n        useDeferredValue: function (value, initialValue) {\n          resolveCurrentlyRenderingComponent();\n          return void 0 !== initialValue ? initialValue : value;\n        },\n        useTransition: function () {\n          resolveCurrentlyRenderingComponent();\n          return [!1, unsupportedStartTransition];\n        },\n        useId: function () {\n          var treeId = currentlyRenderingTask.treeContext;\n          var overflow = treeId.overflow;\n          treeId = treeId.id;\n          treeId =\n            (treeId & ~(1 << (32 - clz32(treeId) - 1))).toString(32) + overflow;\n          var resumableState = currentResumableState;\n          if (null === resumableState)\n            throw Error(\n              \"Invalid hook call. Hooks can only be called inside of the body of a function component.\"\n            );\n          overflow = localIdCounter++;\n          treeId = \":\" + resumableState.idPrefix + \"R\" + treeId;\n          0 < overflow && (treeId += \"H\" + overflow.toString(32));\n          return treeId + \":\";\n        },\n        useSyncExternalStore: function (\n          subscribe,\n          getSnapshot,\n          getServerSnapshot\n        ) {\n          if (void 0 === getServerSnapshot)\n            throw Error(\n              \"Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.\"\n            );\n          return getServerSnapshot();\n        },\n        useCacheRefresh: function () {\n          return unsupportedRefresh;\n        },\n        useMemoCache: function (size) {\n          for (var data = Array(size), i = 0; i < size; i++)\n            data[i] = REACT_MEMO_CACHE_SENTINEL;\n          return data;\n        },\n        useHostTransitionStatus: function () {\n          resolveCurrentlyRenderingComponent();\n          return NotPending;\n        },\n        useOptimistic: function (passthrough) {\n          resolveCurrentlyRenderingComponent();\n          return [passthrough, unsupportedSetOptimisticState];\n        }\n      };\n    HooksDispatcher.useFormState = useActionState;\n    HooksDispatcher.useActionState = useActionState;\n    var currentResumableState = null,\n      currentTaskInDEV = null,\n      DefaultAsyncDispatcher = {\n        getCacheForType: function () {\n          throw Error(\"Not implemented.\");\n        },\n        getOwner: function () {\n          return null === currentTaskInDEV\n            ? null\n            : currentTaskInDEV.componentStack;\n        }\n      },\n      disabledDepth = 0,\n      prevLog,\n      prevInfo,\n      prevWarn,\n      prevError,\n      prevGroup,\n      prevGroupCollapsed,\n      prevGroupEnd;\n    disabledLog.__reactDisabledLog = !0;\n    var prefix,\n      suffix,\n      reentry = !1;\n    var componentFrameCache = new (\n      \"function\" === typeof WeakMap ? WeakMap : Map\n    )();\n    var callComponent = {\n        \"react-stack-bottom-frame\": function (Component, props, secondArg) {\n          return Component(props, secondArg);\n        }\n      },\n      callComponentInDEV =\n        callComponent[\"react-stack-bottom-frame\"].bind(callComponent),\n      callRender = {\n        \"react-stack-bottom-frame\": function (instance) {\n          return instance.render();\n        }\n      },\n      callRenderInDEV = callRender[\"react-stack-bottom-frame\"].bind(callRender),\n      callLazyInit = {\n        \"react-stack-bottom-frame\": function (lazy) {\n          var init = lazy._init;\n          return init(lazy._payload);\n        }\n      },\n      callLazyInitInDEV =\n        callLazyInit[\"react-stack-bottom-frame\"].bind(callLazyInit),\n      CLIENT_RENDERED = 4,\n      PENDING = 0,\n      COMPLETED = 1,\n      FLUSHED = 2,\n      POSTPONED = 5,\n      CLOSED = 14,\n      currentRequest = null,\n      didWarnAboutBadClass = {},\n      didWarnAboutContextTypes = {},\n      didWarnAboutContextTypeOnFunctionComponent = {},\n      didWarnAboutGetDerivedStateOnFunctionComponent = {},\n      didWarnAboutReassigningProps = !1,\n      didWarnAboutGenerators = !1,\n      didWarnAboutMaps = !1;\n    ensureCorrectIsomorphicReactVersion();\n    ensureCorrectIsomorphicReactVersion();\n    exports.prerender = function (children, options) {\n      return new Promise(function (resolve, reject) {\n        var onHeaders = options ? options.onHeaders : void 0,\n          onHeadersImpl;\n        onHeaders &&\n          (onHeadersImpl = function (headersDescriptor) {\n            onHeaders(new Headers(headersDescriptor));\n          });\n        var resources = createResumableState(\n            options ? options.identifierPrefix : void 0,\n            options ? options.unstable_externalRuntimeSrc : void 0,\n            options ? options.bootstrapScriptContent : void 0,\n            options ? options.bootstrapScripts : void 0,\n            options ? options.bootstrapModules : void 0\n          ),\n          request = createPrerenderRequest(\n            children,\n            resources,\n            createRenderState(\n              resources,\n              void 0,\n              options ? options.unstable_externalRuntimeSrc : void 0,\n              options ? options.importMap : void 0,\n              onHeadersImpl,\n              options ? options.maxHeadersLength : void 0\n            ),\n            createRootFormatContext(options ? options.namespaceURI : void 0),\n            options ? options.progressiveChunkSize : void 0,\n            options ? options.onError : void 0,\n            function () {\n              var result = {\n                prelude: new ReadableStream(\n                  {\n                    type: \"bytes\",\n                    pull: function (controller) {\n                      startFlowing(request, controller);\n                    },\n                    cancel: function (reason) {\n                      request.destination = null;\n                      abort(request, reason);\n                    }\n                  },\n                  { highWaterMark: 0 }\n                )\n              };\n              resolve(result);\n            },\n            void 0,\n            void 0,\n            reject,\n            options ? options.onPostpone : void 0\n          );\n        if (options && options.signal) {\n          var signal = options.signal;\n          if (signal.aborted) abort(request, signal.reason);\n          else {\n            var listener = function () {\n              abort(request, signal.reason);\n              signal.removeEventListener(\"abort\", listener);\n            };\n            signal.addEventListener(\"abort\", listener);\n          }\n        }\n        startWork(request);\n      });\n    };\n    exports.renderToReadableStream = function (children, options) {\n      return new Promise(function (resolve, reject) {\n        var onFatalError,\n          onAllReady,\n          allReady = new Promise(function (res, rej) {\n            onAllReady = res;\n            onFatalError = rej;\n          }),\n          onHeaders = options ? options.onHeaders : void 0,\n          onHeadersImpl;\n        onHeaders &&\n          (onHeadersImpl = function (headersDescriptor) {\n            onHeaders(new Headers(headersDescriptor));\n          });\n        var resumableState = createResumableState(\n            options ? options.identifierPrefix : void 0,\n            options ? options.unstable_externalRuntimeSrc : void 0,\n            options ? options.bootstrapScriptContent : void 0,\n            options ? options.bootstrapScripts : void 0,\n            options ? options.bootstrapModules : void 0\n          ),\n          request = createRequest(\n            children,\n            resumableState,\n            createRenderState(\n              resumableState,\n              options ? options.nonce : void 0,\n              options ? options.unstable_externalRuntimeSrc : void 0,\n              options ? options.importMap : void 0,\n              onHeadersImpl,\n              options ? options.maxHeadersLength : void 0\n            ),\n            createRootFormatContext(options ? options.namespaceURI : void 0),\n            options ? options.progressiveChunkSize : void 0,\n            options ? options.onError : void 0,\n            onAllReady,\n            function () {\n              var stream = new ReadableStream(\n                {\n                  type: \"bytes\",\n                  pull: function (controller) {\n                    startFlowing(request, controller);\n                  },\n                  cancel: function (reason) {\n                    request.destination = null;\n                    abort(request, reason);\n                  }\n                },\n                { highWaterMark: 0 }\n              );\n              stream.allReady = allReady;\n              resolve(stream);\n            },\n            function (error) {\n              allReady.catch(function () {});\n              reject(error);\n            },\n            onFatalError,\n            options ? options.onPostpone : void 0,\n            options ? options.formState : void 0\n          );\n        if (options && options.signal) {\n          var signal = options.signal;\n          if (signal.aborted) abort(request, signal.reason);\n          else {\n            var listener = function () {\n              abort(request, signal.reason);\n              signal.removeEventListener(\"abort\", listener);\n            };\n            signal.addEventListener(\"abort\", listener);\n          }\n        }\n        startWork(request);\n      });\n    };\n    exports.version = \"19.0.0-rc-65e06cb7-20241218\";\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QtZG9tL2Nqcy9yZWFjdC1kb20tc2VydmVyLmJyb3dzZXIuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTtBQUNiLEtBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxJQUFJO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDBCQUEwQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDZDQUE2QztBQUNuRSxzQkFBc0IsNENBQTRDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLElBQUk7QUFDdEM7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLHlCQUF5Qiw2QkFBNkI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxpQkFBaUI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Ysc0JBQXNCO0FBQ3RCO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixjQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0pBQWtKLGlCQUFpQjtBQUNuSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtKQUFrSixpQkFBaUIsbURBQW1ELG1CQUFtQixXQUFXLCtCQUErQjtBQUNuUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEYsR0FBRztBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxxQkFBcUI7QUFDdkQ7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixpQkFBaUI7QUFDakIscUJBQXFCLFdBQVcsZUFBZSxtQkFBbUI7QUFDbEUsbUJBQW1CO0FBQ25CO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFDQUFxQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLHdCQUF3QjtBQUN4Qiw0QkFBNEIsV0FBVyxlQUFlLG1CQUFtQjtBQUN6RSwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLDJCQUEyQjtBQUMzQixrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0hBQWtILDhCQUE4QjtBQUNoSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxZQUFZO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDBCQUEwQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdWZBQXVmLFdBQVcsMExBQTBMLFNBQVMsV0FBVyxFQUFFO0FBQ2x0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLFlBQVk7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNEJBQTRCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFCQUFxQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvQ0FBb0M7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMkJBQTJCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixhQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsNEJBQTRCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixxQkFBcUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSx3QkFBd0IsV0FBVyxnQkFBZ0I7QUFDbkQseUJBQXlCLFdBQVcsaUJBQWlCO0FBQ3JELHlCQUF5QixXQUFXLGlCQUFpQjtBQUNyRCwwQkFBMEIsV0FBVyxrQkFBa0I7QUFDdkQsMEJBQTBCLFdBQVcsa0JBQWtCO0FBQ3ZELG1DQUFtQyxXQUFXLDJCQUEyQjtBQUN6RSw2QkFBNkIsV0FBVyxxQkFBcUI7QUFDN0QsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxnRUFBZ0UsZUFBZSxvQ0FBb0M7QUFDdEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0VBQWdFLGVBQWUsb0NBQW9DO0FBQ3RKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixzQkFBc0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDBCQUEwQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0RBQWdEO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxxQ0FBcUM7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMEJBQTBCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGtCQUFrQixnQkFBZ0I7QUFDdkU7QUFDQTtBQUNBLFFBQVE7QUFDUiw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix3QkFBd0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLHlEQUF5RDtBQUN6RDtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDJCQUEyQjtBQUM1RCx3Q0FBd0Msb0JBQW9CO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw4QkFBOEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdDQUFnQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLG1DQUFtQyxnQ0FBZ0M7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscUNBQXFDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0NBQWdDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsOEJBQThCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw0QkFBNEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxzR0FBMEI7QUFDbEQsaUJBQWlCLG1CQUFPLENBQUMsOEdBQThCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLDJCQUEyQjtBQUMzQiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsaUNBQWlDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsb0NBQW9DO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsb0NBQW9DO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQ0FBb0M7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrQ0FBa0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHFCQUFxQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxQ0FBcUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0Msd0JBQXdCLDRDQUE0QyxNQUFNLG1DQUFtQyxzQkFBc0Isa1ZBQWtWLEVBQUU7QUFDdGdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDZCQUE2Qiw2QkFBNkIsZ0NBQWdDLGFBQWEsMkNBQTJDLDZCQUE2QjtBQUMxTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw2QkFBNkIsNEJBQTRCLGlDQUFpQyxNQUFNLG9CQUFvQiwrQ0FBK0MsS0FBSyxlQUFlLGdCQUFnQixRQUFRLEdBQUcsc0JBQXNCLGFBQWEsMkJBQTJCLFNBQVMscUNBQXFDLGdCQUFnQixpQkFBaUIsSUFBSSxTQUFTLEtBQUssYUFBYSxnQ0FBZ0MsV0FBVyxpQ0FBaUM7QUFDdmU7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDZCQUE2Qiw0QkFBNEIsaUNBQWlDLE1BQU0sb0JBQW9CLCtDQUErQyxLQUFLLGVBQWUsZ0JBQWdCLFFBQVEsR0FBRyxzQkFBc0IsYUFBYSwyQkFBMkIsU0FBUyxxQ0FBcUMsZ0JBQWdCLGlCQUFpQixJQUFJLFNBQVMsS0FBSyxhQUFhLGdDQUFnQyxXQUFXLGlDQUFpQyxZQUFZLHNCQUFzQixjQUFjLGFBQWEsSUFBSSwySEFBMkgsU0FBUyxxSUFBcUksSUFBSSxLQUFLLFFBQVEsVUFBVSxFQUFFLE1BQU0sYUFBYSxPQUFPLEtBQUssSUFBSSxTQUFTLGFBQWEsYUFBYSxlQUFlLFdBQVcsS0FBSyxLQUFLLDBCQUEwQixXQUFXLG1CQUFtQixrQ0FBa0MsU0FBUywwQkFBMEIsaUNBQWlDLHFCQUFxQixzQkFBc0IsRUFBRSxXQUFXLDBCQUEwQix5Q0FBeUMsY0FBYyxLQUFLLFNBQVMsWUFBWSxvQ0FBb0MsMkJBQTJCLGNBQWMsYUFBYSxXQUFXLHVGQUF1Rix1RkFBdUY7QUFDNWdEO0FBQ0E7QUFDQSxxQkFBcUIsc0JBQXNCLGNBQWMsYUFBYSxJQUFJLDJIQUEySCxTQUFTLHFJQUFxSSxJQUFJLEtBQUssUUFBUSxVQUFVLEVBQUUsTUFBTSxhQUFhLE9BQU8sS0FBSyxJQUFJLFNBQVMsYUFBYSxhQUFhLGVBQWUsV0FBVyxLQUFLLEtBQUssMEJBQTBCLFdBQVcsbUJBQW1CLGtDQUFrQyxTQUFTLDBCQUEwQixpQ0FBaUMscUJBQXFCLHNCQUFzQixFQUFFLFdBQVcsMEJBQTBCLHlDQUF5QyxjQUFjLEtBQUssU0FBUyxZQUFZLG9DQUFvQywyQkFBMkIsY0FBYyxhQUFhLFdBQVcsdUZBQXVGLHVGQUF1RjtBQUM5aUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGlDQUFpQywwSUFBMEk7QUFDNU07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsMkJBQTJCLHFCQUFxQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx1QkFBdUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsOENBQThDLFVBQVU7QUFDeEQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsbUNBQW1DO0FBQ25DLHFEQUFxRDtBQUNyRCx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksaUJBQWlCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxJQUFJLDhCQUE4QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsSUFBSSxlQUFlO0FBQ25CLEdBQUciLCJzb3VyY2VzIjpbIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL1dvbmRlclZpdGUtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC1kb20vY2pzL3JlYWN0LWRvbS1zZXJ2ZXIuYnJvd3Nlci5kZXZlbG9wbWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1kb20tc2VydmVyLmJyb3dzZXIuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbi8qXG5cblxuIEpTIEltcGxlbWVudGF0aW9uIG9mIE11cm11ckhhc2gzIChyMTM2KSAoYXMgb2YgTWF5IDIwLCAyMDExKVxuXG4gQ29weXJpZ2h0IChjKSAyMDExIEdhcnkgQ291cnRcbiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiBTT0ZUV0FSRS5cbiovXG5cInVzZSBzdHJpY3RcIjtcblwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViAmJlxuICAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIHN0eWxlUmVwbGFjZXIobWF0Y2gsIHByZWZpeCwgcywgc3VmZml4KSB7XG4gICAgICByZXR1cm4gXCJcIiArIHByZWZpeCArIChcInNcIiA9PT0gcyA/IFwiXFxcXDczIFwiIDogXCJcXFxcNTMgXCIpICsgc3VmZml4O1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY3JpcHRSZXBsYWNlcihtYXRjaCwgcHJlZml4LCBzLCBzdWZmaXgpIHtcbiAgICAgIHJldHVybiBcIlwiICsgcHJlZml4ICsgKFwic1wiID09PSBzID8gXCJcXFxcdTAwNzNcIiA6IFwiXFxcXHUwMDUzXCIpICsgc3VmZml4O1xuICAgIH1cbiAgICBmdW5jdGlvbiBvYmplY3ROYW1lKG9iamVjdCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcbiAgICAgICAgLmNhbGwob2JqZWN0KVxuICAgICAgICAucmVwbGFjZSgvXlxcW29iamVjdCAoLiopXFxdJC8sIGZ1bmN0aW9uIChtLCBwMCkge1xuICAgICAgICAgIHJldHVybiBwMDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlS2V5Rm9yRXJyb3JNZXNzYWdlKGtleSkge1xuICAgICAgdmFyIGVuY29kZWRLZXkgPSBKU09OLnN0cmluZ2lmeShrZXkpO1xuICAgICAgcmV0dXJuICdcIicgKyBrZXkgKyAnXCInID09PSBlbmNvZGVkS2V5ID8ga2V5IDogZW5jb2RlZEtleTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVWYWx1ZUZvckVycm9yTWVzc2FnZSh2YWx1ZSkge1xuICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgIDEwID49IHZhbHVlLmxlbmd0aCA/IHZhbHVlIDogdmFsdWUuc2xpY2UoMCwgMTApICsgXCIuLi5cIlxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICBpZiAoaXNBcnJheUltcGwodmFsdWUpKSByZXR1cm4gXCJbLi4uXVwiO1xuICAgICAgICAgIGlmIChudWxsICE9PSB2YWx1ZSAmJiB2YWx1ZS4kJHR5cGVvZiA9PT0gQ0xJRU5UX1JFRkVSRU5DRV9UQUcpXG4gICAgICAgICAgICByZXR1cm4gXCJjbGllbnRcIjtcbiAgICAgICAgICB2YWx1ZSA9IG9iamVjdE5hbWUodmFsdWUpO1xuICAgICAgICAgIHJldHVybiBcIk9iamVjdFwiID09PSB2YWx1ZSA/IFwiey4uLn1cIiA6IHZhbHVlO1xuICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICByZXR1cm4gdmFsdWUuJCR0eXBlb2YgPT09IENMSUVOVF9SRUZFUkVOQ0VfVEFHXG4gICAgICAgICAgICA/IFwiY2xpZW50XCJcbiAgICAgICAgICAgIDogKHZhbHVlID0gdmFsdWUuZGlzcGxheU5hbWUgfHwgdmFsdWUubmFtZSlcbiAgICAgICAgICAgICAgPyBcImZ1bmN0aW9uIFwiICsgdmFsdWVcbiAgICAgICAgICAgICAgOiBcImZ1bmN0aW9uXCI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlRWxlbWVudFR5cGUodHlwZSkge1xuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKSByZXR1cm4gdHlwZTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VMaXN0XCI7XG4gICAgICB9XG4gICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZUVsZW1lbnRUeXBlKHR5cGUucmVuZGVyKTtcbiAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZUVsZW1lbnRUeXBlKHR5cGUudHlwZSk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICB2YXIgcGF5bG9hZCA9IHR5cGUuX3BheWxvYWQ7XG4gICAgICAgICAgICB0eXBlID0gdHlwZS5faW5pdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiBkZXNjcmliZUVsZW1lbnRUeXBlKHR5cGUocGF5bG9hZCkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlT2JqZWN0Rm9yRXJyb3JNZXNzYWdlKG9iamVjdE9yQXJyYXksIGV4cGFuZGVkTmFtZSkge1xuICAgICAgdmFyIG9iaktpbmQgPSBvYmplY3ROYW1lKG9iamVjdE9yQXJyYXkpO1xuICAgICAgaWYgKFwiT2JqZWN0XCIgIT09IG9iaktpbmQgJiYgXCJBcnJheVwiICE9PSBvYmpLaW5kKSByZXR1cm4gb2JqS2luZDtcbiAgICAgIHZhciBzdGFydCA9IC0xLFxuICAgICAgICBsZW5ndGggPSAwO1xuICAgICAgaWYgKGlzQXJyYXlJbXBsKG9iamVjdE9yQXJyYXkpKVxuICAgICAgICBpZiAoanN4Q2hpbGRyZW5QYXJlbnRzLmhhcyhvYmplY3RPckFycmF5KSkge1xuICAgICAgICAgIHZhciB0eXBlID0ganN4Q2hpbGRyZW5QYXJlbnRzLmdldChvYmplY3RPckFycmF5KTtcbiAgICAgICAgICBvYmpLaW5kID0gXCI8XCIgKyBkZXNjcmliZUVsZW1lbnRUeXBlKHR5cGUpICsgXCI+XCI7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3RPckFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBvYmplY3RPckFycmF5W2ldO1xuICAgICAgICAgICAgdmFsdWUgPVxuICAgICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgdmFsdWVcbiAgICAgICAgICAgICAgICA/IHZhbHVlXG4gICAgICAgICAgICAgICAgOiBcIm9iamVjdFwiID09PSB0eXBlb2YgdmFsdWUgJiYgbnVsbCAhPT0gdmFsdWVcbiAgICAgICAgICAgICAgICAgID8gXCJ7XCIgKyBkZXNjcmliZU9iamVjdEZvckVycm9yTWVzc2FnZSh2YWx1ZSkgKyBcIn1cIlxuICAgICAgICAgICAgICAgICAgOiBcIntcIiArIGRlc2NyaWJlVmFsdWVGb3JFcnJvck1lc3NhZ2UodmFsdWUpICsgXCJ9XCI7XG4gICAgICAgICAgICBcIlwiICsgaSA9PT0gZXhwYW5kZWROYW1lXG4gICAgICAgICAgICAgID8gKChzdGFydCA9IG9iaktpbmQubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAobGVuZ3RoID0gdmFsdWUubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAob2JqS2luZCArPSB2YWx1ZSkpXG4gICAgICAgICAgICAgIDogKG9iaktpbmQgPVxuICAgICAgICAgICAgICAgICAgMTUgPiB2YWx1ZS5sZW5ndGggJiYgNDAgPiBvYmpLaW5kLmxlbmd0aCArIHZhbHVlLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICA/IG9iaktpbmQgKyB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICA6IG9iaktpbmQgKyBcInsuLi59XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvYmpLaW5kICs9IFwiPC9cIiArIGRlc2NyaWJlRWxlbWVudFR5cGUodHlwZSkgKyBcIj5cIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvYmpLaW5kID0gXCJbXCI7XG4gICAgICAgICAgZm9yICh0eXBlID0gMDsgdHlwZSA8IG9iamVjdE9yQXJyYXkubGVuZ3RoOyB0eXBlKyspXG4gICAgICAgICAgICAwIDwgdHlwZSAmJiAob2JqS2luZCArPSBcIiwgXCIpLFxuICAgICAgICAgICAgICAoaSA9IG9iamVjdE9yQXJyYXlbdHlwZV0pLFxuICAgICAgICAgICAgICAoaSA9XG4gICAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGkgJiYgbnVsbCAhPT0gaVxuICAgICAgICAgICAgICAgICAgPyBkZXNjcmliZU9iamVjdEZvckVycm9yTWVzc2FnZShpKVxuICAgICAgICAgICAgICAgICAgOiBkZXNjcmliZVZhbHVlRm9yRXJyb3JNZXNzYWdlKGkpKSxcbiAgICAgICAgICAgICAgXCJcIiArIHR5cGUgPT09IGV4cGFuZGVkTmFtZVxuICAgICAgICAgICAgICAgID8gKChzdGFydCA9IG9iaktpbmQubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgIChsZW5ndGggPSBpLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgICAob2JqS2luZCArPSBpKSlcbiAgICAgICAgICAgICAgICA6IChvYmpLaW5kID1cbiAgICAgICAgICAgICAgICAgICAgMTAgPiBpLmxlbmd0aCAmJiA0MCA+IG9iaktpbmQubGVuZ3RoICsgaS5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICA/IG9iaktpbmQgKyBpXG4gICAgICAgICAgICAgICAgICAgICAgOiBvYmpLaW5kICsgXCIuLi5cIik7XG4gICAgICAgICAgb2JqS2luZCArPSBcIl1cIjtcbiAgICAgICAgfVxuICAgICAgZWxzZSBpZiAob2JqZWN0T3JBcnJheS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKVxuICAgICAgICBvYmpLaW5kID0gXCI8XCIgKyBkZXNjcmliZUVsZW1lbnRUeXBlKG9iamVjdE9yQXJyYXkudHlwZSkgKyBcIi8+XCI7XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKG9iamVjdE9yQXJyYXkuJCR0eXBlb2YgPT09IENMSUVOVF9SRUZFUkVOQ0VfVEFHKSByZXR1cm4gXCJjbGllbnRcIjtcbiAgICAgICAgaWYgKGpzeFByb3BzUGFyZW50cy5oYXMob2JqZWN0T3JBcnJheSkpIHtcbiAgICAgICAgICBvYmpLaW5kID0ganN4UHJvcHNQYXJlbnRzLmdldChvYmplY3RPckFycmF5KTtcbiAgICAgICAgICBvYmpLaW5kID0gXCI8XCIgKyAoZGVzY3JpYmVFbGVtZW50VHlwZShvYmpLaW5kKSB8fCBcIi4uLlwiKTtcbiAgICAgICAgICB0eXBlID0gT2JqZWN0LmtleXMob2JqZWN0T3JBcnJheSk7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IHR5cGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG9iaktpbmQgKz0gXCIgXCI7XG4gICAgICAgICAgICB2YWx1ZSA9IHR5cGVbaV07XG4gICAgICAgICAgICBvYmpLaW5kICs9IGRlc2NyaWJlS2V5Rm9yRXJyb3JNZXNzYWdlKHZhbHVlKSArIFwiPVwiO1xuICAgICAgICAgICAgdmFyIF92YWx1ZTIgPSBvYmplY3RPckFycmF5W3ZhbHVlXTtcbiAgICAgICAgICAgIHZhciBfc3Vic3RyMiA9XG4gICAgICAgICAgICAgIHZhbHVlID09PSBleHBhbmRlZE5hbWUgJiZcbiAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIF92YWx1ZTIgJiZcbiAgICAgICAgICAgICAgbnVsbCAhPT0gX3ZhbHVlMlxuICAgICAgICAgICAgICAgID8gZGVzY3JpYmVPYmplY3RGb3JFcnJvck1lc3NhZ2UoX3ZhbHVlMilcbiAgICAgICAgICAgICAgICA6IGRlc2NyaWJlVmFsdWVGb3JFcnJvck1lc3NhZ2UoX3ZhbHVlMik7XG4gICAgICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2YgX3ZhbHVlMiAmJiAoX3N1YnN0cjIgPSBcIntcIiArIF9zdWJzdHIyICsgXCJ9XCIpO1xuICAgICAgICAgICAgdmFsdWUgPT09IGV4cGFuZGVkTmFtZVxuICAgICAgICAgICAgICA/ICgoc3RhcnQgPSBvYmpLaW5kLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgKGxlbmd0aCA9IF9zdWJzdHIyLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgKG9iaktpbmQgKz0gX3N1YnN0cjIpKVxuICAgICAgICAgICAgICA6IChvYmpLaW5kID1cbiAgICAgICAgICAgICAgICAgIDEwID4gX3N1YnN0cjIubGVuZ3RoICYmIDQwID4gb2JqS2luZC5sZW5ndGggKyBfc3Vic3RyMi5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgPyBvYmpLaW5kICsgX3N1YnN0cjJcbiAgICAgICAgICAgICAgICAgICAgOiBvYmpLaW5kICsgXCIuLi5cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9iaktpbmQgKz0gXCI+XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2JqS2luZCA9IFwie1wiO1xuICAgICAgICAgIHR5cGUgPSBPYmplY3Qua2V5cyhvYmplY3RPckFycmF5KTtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdHlwZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIDAgPCBpICYmIChvYmpLaW5kICs9IFwiLCBcIiksXG4gICAgICAgICAgICAgICh2YWx1ZSA9IHR5cGVbaV0pLFxuICAgICAgICAgICAgICAob2JqS2luZCArPSBkZXNjcmliZUtleUZvckVycm9yTWVzc2FnZSh2YWx1ZSkgKyBcIjogXCIpLFxuICAgICAgICAgICAgICAoX3ZhbHVlMiA9IG9iamVjdE9yQXJyYXlbdmFsdWVdKSxcbiAgICAgICAgICAgICAgKF92YWx1ZTIgPVxuICAgICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBfdmFsdWUyICYmIG51bGwgIT09IF92YWx1ZTJcbiAgICAgICAgICAgICAgICAgID8gZGVzY3JpYmVPYmplY3RGb3JFcnJvck1lc3NhZ2UoX3ZhbHVlMilcbiAgICAgICAgICAgICAgICAgIDogZGVzY3JpYmVWYWx1ZUZvckVycm9yTWVzc2FnZShfdmFsdWUyKSksXG4gICAgICAgICAgICAgIHZhbHVlID09PSBleHBhbmRlZE5hbWVcbiAgICAgICAgICAgICAgICA/ICgoc3RhcnQgPSBvYmpLaW5kLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgICAobGVuZ3RoID0gX3ZhbHVlMi5sZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgKG9iaktpbmQgKz0gX3ZhbHVlMikpXG4gICAgICAgICAgICAgICAgOiAob2JqS2luZCA9XG4gICAgICAgICAgICAgICAgICAgIDEwID4gX3ZhbHVlMi5sZW5ndGggJiYgNDAgPiBvYmpLaW5kLmxlbmd0aCArIF92YWx1ZTIubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgPyBvYmpLaW5kICsgX3ZhbHVlMlxuICAgICAgICAgICAgICAgICAgICAgIDogb2JqS2luZCArIFwiLi4uXCIpO1xuICAgICAgICAgIG9iaktpbmQgKz0gXCJ9XCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDAgPT09IGV4cGFuZGVkTmFtZVxuICAgICAgICA/IG9iaktpbmRcbiAgICAgICAgOiAtMSA8IHN0YXJ0ICYmIDAgPCBsZW5ndGhcbiAgICAgICAgICA/ICgob2JqZWN0T3JBcnJheSA9IFwiIFwiLnJlcGVhdChzdGFydCkgKyBcIl5cIi5yZXBlYXQobGVuZ3RoKSksXG4gICAgICAgICAgICBcIlxcbiAgXCIgKyBvYmpLaW5kICsgXCJcXG4gIFwiICsgb2JqZWN0T3JBcnJheSlcbiAgICAgICAgICA6IFwiXFxuICBcIiArIG9iaktpbmQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG11cm11cmhhc2gzXzMyX2djKGtleSwgc2VlZCkge1xuICAgICAgdmFyIHJlbWFpbmRlciA9IGtleS5sZW5ndGggJiAzO1xuICAgICAgdmFyIGJ5dGVzID0ga2V5Lmxlbmd0aCAtIHJlbWFpbmRlcjtcbiAgICAgIHZhciBoMSA9IHNlZWQ7XG4gICAgICBmb3IgKHNlZWQgPSAwOyBzZWVkIDwgYnl0ZXM7ICkge1xuICAgICAgICB2YXIgazEgPVxuICAgICAgICAgIChrZXkuY2hhckNvZGVBdChzZWVkKSAmIDI1NSkgfFxuICAgICAgICAgICgoa2V5LmNoYXJDb2RlQXQoKytzZWVkKSAmIDI1NSkgPDwgOCkgfFxuICAgICAgICAgICgoa2V5LmNoYXJDb2RlQXQoKytzZWVkKSAmIDI1NSkgPDwgMTYpIHxcbiAgICAgICAgICAoKGtleS5jaGFyQ29kZUF0KCsrc2VlZCkgJiAyNTUpIDw8IDI0KTtcbiAgICAgICAgKytzZWVkO1xuICAgICAgICBrMSA9XG4gICAgICAgICAgKDM0MzI5MTgzNTMgKiAoazEgJiA2NTUzNSkgK1xuICAgICAgICAgICAgKCgoMzQzMjkxODM1MyAqIChrMSA+Pj4gMTYpKSAmIDY1NTM1KSA8PCAxNikpICZcbiAgICAgICAgICA0Mjk0OTY3Mjk1O1xuICAgICAgICBrMSA9IChrMSA8PCAxNSkgfCAoazEgPj4+IDE3KTtcbiAgICAgICAgazEgPVxuICAgICAgICAgICg0NjE4NDU5MDcgKiAoazEgJiA2NTUzNSkgK1xuICAgICAgICAgICAgKCgoNDYxODQ1OTA3ICogKGsxID4+PiAxNikpICYgNjU1MzUpIDw8IDE2KSkgJlxuICAgICAgICAgIDQyOTQ5NjcyOTU7XG4gICAgICAgIGgxIF49IGsxO1xuICAgICAgICBoMSA9IChoMSA8PCAxMykgfCAoaDEgPj4+IDE5KTtcbiAgICAgICAgaDEgPVxuICAgICAgICAgICg1ICogKGgxICYgNjU1MzUpICsgKCgoNSAqIChoMSA+Pj4gMTYpKSAmIDY1NTM1KSA8PCAxNikpICYgNDI5NDk2NzI5NTtcbiAgICAgICAgaDEgPSAoaDEgJiA2NTUzNSkgKyAyNzQ5MiArICgoKChoMSA+Pj4gMTYpICsgNTg5NjQpICYgNjU1MzUpIDw8IDE2KTtcbiAgICAgIH1cbiAgICAgIGsxID0gMDtcbiAgICAgIHN3aXRjaCAocmVtYWluZGVyKSB7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBrMSBePSAoa2V5LmNoYXJDb2RlQXQoc2VlZCArIDIpICYgMjU1KSA8PCAxNjtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGsxIF49IChrZXkuY2hhckNvZGVBdChzZWVkICsgMSkgJiAyNTUpIDw8IDg7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAoazEgXj0ga2V5LmNoYXJDb2RlQXQoc2VlZCkgJiAyNTUpLFxuICAgICAgICAgICAgKGsxID1cbiAgICAgICAgICAgICAgKDM0MzI5MTgzNTMgKiAoazEgJiA2NTUzNSkgK1xuICAgICAgICAgICAgICAgICgoKDM0MzI5MTgzNTMgKiAoazEgPj4+IDE2KSkgJiA2NTUzNSkgPDwgMTYpKSAmXG4gICAgICAgICAgICAgIDQyOTQ5NjcyOTUpLFxuICAgICAgICAgICAgKGsxID0gKGsxIDw8IDE1KSB8IChrMSA+Pj4gMTcpKSxcbiAgICAgICAgICAgIChoMSBePVxuICAgICAgICAgICAgICAoNDYxODQ1OTA3ICogKGsxICYgNjU1MzUpICtcbiAgICAgICAgICAgICAgICAoKCg0NjE4NDU5MDcgKiAoazEgPj4+IDE2KSkgJiA2NTUzNSkgPDwgMTYpKSAmXG4gICAgICAgICAgICAgIDQyOTQ5NjcyOTUpO1xuICAgICAgfVxuICAgICAgaDEgXj0ga2V5Lmxlbmd0aDtcbiAgICAgIGgxIF49IGgxID4+PiAxNjtcbiAgICAgIGgxID1cbiAgICAgICAgKDIyNDY4MjI1MDcgKiAoaDEgJiA2NTUzNSkgK1xuICAgICAgICAgICgoKDIyNDY4MjI1MDcgKiAoaDEgPj4+IDE2KSkgJiA2NTUzNSkgPDwgMTYpKSAmXG4gICAgICAgIDQyOTQ5NjcyOTU7XG4gICAgICBoMSBePSBoMSA+Pj4gMTM7XG4gICAgICBoMSA9XG4gICAgICAgICgzMjY2NDg5OTA5ICogKGgxICYgNjU1MzUpICtcbiAgICAgICAgICAoKCgzMjY2NDg5OTA5ICogKGgxID4+PiAxNikpICYgNjU1MzUpIDw8IDE2KSkgJlxuICAgICAgICA0Mjk0OTY3Mjk1O1xuICAgICAgcmV0dXJuIChoMSBeIChoMSA+Pj4gMTYpKSA+Pj4gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NoZWR1bGVXb3JrKGNhbGxiYWNrKSB7XG4gICAgICB0YXNrUXVldWUucHVzaChjYWxsYmFjayk7XG4gICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKG51bGwpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVFcnJvckluTmV4dFRpY2soZXJyb3IpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjaHVuaykge1xuICAgICAgaWYgKDAgIT09IGNodW5rLmJ5dGVMZW5ndGgpXG4gICAgICAgIGlmICgyMDQ4IDwgY2h1bmsuYnl0ZUxlbmd0aClcbiAgICAgICAgICAwIDwgd3JpdHRlbkJ5dGVzICYmXG4gICAgICAgICAgICAoZGVzdGluYXRpb24uZW5xdWV1ZShcbiAgICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoY3VycmVudFZpZXcuYnVmZmVyLCAwLCB3cml0dGVuQnl0ZXMpXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgKGN1cnJlbnRWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoMjA0OCkpLFxuICAgICAgICAgICAgKHdyaXR0ZW5CeXRlcyA9IDApKSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLmVucXVldWUoY2h1bmspO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgYWxsb3dhYmxlQnl0ZXMgPSBjdXJyZW50Vmlldy5sZW5ndGggLSB3cml0dGVuQnl0ZXM7XG4gICAgICAgICAgYWxsb3dhYmxlQnl0ZXMgPCBjaHVuay5ieXRlTGVuZ3RoICYmXG4gICAgICAgICAgICAoMCA9PT0gYWxsb3dhYmxlQnl0ZXNcbiAgICAgICAgICAgICAgPyBkZXN0aW5hdGlvbi5lbnF1ZXVlKGN1cnJlbnRWaWV3KVxuICAgICAgICAgICAgICA6IChjdXJyZW50Vmlldy5zZXQoXG4gICAgICAgICAgICAgICAgICBjaHVuay5zdWJhcnJheSgwLCBhbGxvd2FibGVCeXRlcyksXG4gICAgICAgICAgICAgICAgICB3cml0dGVuQnl0ZXNcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLmVucXVldWUoY3VycmVudFZpZXcpLFxuICAgICAgICAgICAgICAgIChjaHVuayA9IGNodW5rLnN1YmFycmF5KGFsbG93YWJsZUJ5dGVzKSkpLFxuICAgICAgICAgICAgKGN1cnJlbnRWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoMjA0OCkpLFxuICAgICAgICAgICAgKHdyaXR0ZW5CeXRlcyA9IDApKTtcbiAgICAgICAgICBjdXJyZW50Vmlldy5zZXQoY2h1bmssIHdyaXR0ZW5CeXRlcyk7XG4gICAgICAgICAgd3JpdHRlbkJ5dGVzICs9IGNodW5rLmJ5dGVMZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgY2h1bmspIHtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNodW5rKTtcbiAgICAgIHJldHVybiAhMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcGxldGVXcml0aW5nKGRlc3RpbmF0aW9uKSB7XG4gICAgICBjdXJyZW50VmlldyAmJlxuICAgICAgICAwIDwgd3JpdHRlbkJ5dGVzICYmXG4gICAgICAgIChkZXN0aW5hdGlvbi5lbnF1ZXVlKFxuICAgICAgICAgIG5ldyBVaW50OEFycmF5KGN1cnJlbnRWaWV3LmJ1ZmZlciwgMCwgd3JpdHRlbkJ5dGVzKVxuICAgICAgICApLFxuICAgICAgICAoY3VycmVudFZpZXcgPSBudWxsKSxcbiAgICAgICAgKHdyaXR0ZW5CeXRlcyA9IDApKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RyaW5nVG9DaHVuayhjb250ZW50KSB7XG4gICAgICByZXR1cm4gdGV4dEVuY29kZXIuZW5jb2RlKGNvbnRlbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoY29udGVudCkge1xuICAgICAgY29udGVudCA9IHRleHRFbmNvZGVyLmVuY29kZShjb250ZW50KTtcbiAgICAgIDIwNDggPCBjb250ZW50LmJ5dGVMZW5ndGggJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcInByZWNvbXB1dGVkIGNodW5rcyBtdXN0IGJlIHNtYWxsZXIgdGhhbiB0aGUgdmlldyBzaXplIGNvbmZpZ3VyZWQgZm9yIHRoaXMgaG9zdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICApO1xuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsb3NlV2l0aEVycm9yKGRlc3RpbmF0aW9uLCBlcnJvcikge1xuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZGVzdGluYXRpb24uZXJyb3JcbiAgICAgICAgPyBkZXN0aW5hdGlvbi5lcnJvcihlcnJvcilcbiAgICAgICAgOiBkZXN0aW5hdGlvbi5jbG9zZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFN5bWJvbCAmJlxuICAgICAgICAgIFN5bWJvbC50b1N0cmluZ1RhZyAmJlxuICAgICAgICAgIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10pIHx8XG4gICAgICAgIHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgfHxcbiAgICAgICAgXCJPYmplY3RcIlxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2lsbENvZXJjaW9uVGhyb3codmFsdWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpLCAhMTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBcIlwiICsgdmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odmFsdWUsIGF0dHJpYnV0ZU5hbWUpIHtcbiAgICAgIGlmICh3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiVGhlIHByb3ZpZGVkIGAlc2AgYXR0cmlidXRlIGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLlwiLFxuICAgICAgICAgICAgYXR0cmlidXRlTmFtZSxcbiAgICAgICAgICAgIHR5cGVOYW1lKHZhbHVlKVxuICAgICAgICAgICksXG4gICAgICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKVxuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0NTU1Byb3BlcnR5U3RyaW5nQ29lcmNpb24odmFsdWUsIHByb3BOYW1lKSB7XG4gICAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIlRoZSBwcm92aWRlZCBgJXNgIENTUyBwcm9wZXJ0eSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLiBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS5cIixcbiAgICAgICAgICAgIHByb3BOYW1lLFxuICAgICAgICAgICAgdHlwZU5hbWUodmFsdWUpXG4gICAgICAgICAgKSxcbiAgICAgICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrSHRtbFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIlRoZSBwcm92aWRlZCBIVE1MIG1hcmt1cCB1c2VzIGEgdmFsdWUgb2YgdW5zdXBwb3J0ZWQgdHlwZSAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuXCIsXG4gICAgICAgICAgICB0eXBlTmFtZSh2YWx1ZSlcbiAgICAgICAgICApLFxuICAgICAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSlcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNBdHRyaWJ1dGVOYW1lU2FmZShhdHRyaWJ1dGVOYW1lKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGUsIGF0dHJpYnV0ZU5hbWUpKVxuICAgICAgICByZXR1cm4gITA7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlLCBhdHRyaWJ1dGVOYW1lKSlcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgaWYgKFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYLnRlc3QoYXR0cmlidXRlTmFtZSkpXG4gICAgICAgIHJldHVybiAodmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gITApO1xuICAgICAgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZVthdHRyaWJ1dGVOYW1lXSA9ICEwO1xuICAgICAgY29uc29sZS5lcnJvcihcIkludmFsaWQgYXR0cmlidXRlIG5hbWU6IGAlc2BcIiwgYXR0cmlidXRlTmFtZSk7XG4gICAgICByZXR1cm4gITE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrQ29udHJvbGxlZFZhbHVlUHJvcHModGFnTmFtZSwgcHJvcHMpIHtcbiAgICAgIGhhc1JlYWRPbmx5VmFsdWVbcHJvcHMudHlwZV0gfHxcbiAgICAgICAgcHJvcHMub25DaGFuZ2UgfHxcbiAgICAgICAgcHJvcHMub25JbnB1dCB8fFxuICAgICAgICBwcm9wcy5yZWFkT25seSB8fFxuICAgICAgICBwcm9wcy5kaXNhYmxlZCB8fFxuICAgICAgICBudWxsID09IHByb3BzLnZhbHVlIHx8XG4gICAgICAgIChcInNlbGVjdFwiID09PSB0YWdOYW1lXG4gICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIllvdSBwcm92aWRlZCBhIGB2YWx1ZWAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiBgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmIHRoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRWYWx1ZWAuIE90aGVyd2lzZSwgc2V0IGBvbkNoYW5nZWAuXCJcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiWW91IHByb3ZpZGVkIGEgYHZhbHVlYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuIGBvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgdGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdFZhbHVlYC4gT3RoZXJ3aXNlLCBzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC5cIlxuICAgICAgICAgICAgKSk7XG4gICAgICBwcm9wcy5vbkNoYW5nZSB8fFxuICAgICAgICBwcm9wcy5yZWFkT25seSB8fFxuICAgICAgICBwcm9wcy5kaXNhYmxlZCB8fFxuICAgICAgICBudWxsID09IHByb3BzLmNoZWNrZWQgfHxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIllvdSBwcm92aWRlZCBhIGBjaGVja2VkYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuIGBvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgdGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdENoZWNrZWRgLiBPdGhlcndpc2UsIHNldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLlwiXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydHkkMSh0YWdOYW1lLCBuYW1lKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGhhc093blByb3BlcnR5LmNhbGwod2FybmVkUHJvcGVydGllcyQxLCBuYW1lKSAmJlxuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV1cbiAgICAgIClcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgaWYgKHJBUklBQ2FtZWwkMS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHRhZ05hbWUgPSBcImFyaWEtXCIgKyBuYW1lLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHRhZ05hbWUgPSBhcmlhUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eSh0YWdOYW1lKSA/IHRhZ05hbWUgOiBudWxsO1xuICAgICAgICBpZiAobnVsbCA9PSB0YWdOYW1lKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIkludmFsaWQgQVJJQSBhdHRyaWJ1dGUgYCVzYC4gQVJJQSBhdHRyaWJ1dGVzIGZvbGxvdyB0aGUgcGF0dGVybiBhcmlhLSogYW5kIG11c3QgYmUgbG93ZXJjYXNlLlwiLFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgKHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9ICEwKVxuICAgICAgICAgICk7XG4gICAgICAgIGlmIChuYW1lICE9PSB0YWdOYW1lKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIkludmFsaWQgQVJJQSBhdHRyaWJ1dGUgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/XCIsXG4gICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgIHRhZ05hbWVcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAod2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gITApXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChyQVJJQSQxLnRlc3QobmFtZSkpIHtcbiAgICAgICAgdGFnTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdGFnTmFtZSA9IGFyaWFQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KHRhZ05hbWUpID8gdGFnTmFtZSA6IG51bGw7XG4gICAgICAgIGlmIChudWxsID09IHRhZ05hbWUpIHJldHVybiAod2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gITApLCAhMTtcbiAgICAgICAgbmFtZSAhPT0gdGFnTmFtZSAmJlxuICAgICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJVbmtub3duIEFSSUEgYXR0cmlidXRlIGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgP1wiLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHRhZ05hbWVcbiAgICAgICAgICApLFxuICAgICAgICAgICh3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSAhMCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuICEwO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXMkMih0eXBlLCBwcm9wcykge1xuICAgICAgdmFyIGludmFsaWRQcm9wcyA9IFtdLFxuICAgICAgICBrZXk7XG4gICAgICBmb3IgKGtleSBpbiBwcm9wcylcbiAgICAgICAgdmFsaWRhdGVQcm9wZXJ0eSQxKHR5cGUsIGtleSkgfHwgaW52YWxpZFByb3BzLnB1c2goa2V5KTtcbiAgICAgIHByb3BzID0gaW52YWxpZFByb3BzXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICByZXR1cm4gXCJgXCIgKyBwcm9wICsgXCJgXCI7XG4gICAgICAgIH0pXG4gICAgICAgIC5qb2luKFwiLCBcIik7XG4gICAgICAxID09PSBpbnZhbGlkUHJvcHMubGVuZ3RoXG4gICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiSW52YWxpZCBhcmlhIHByb3AgJXMgb24gPCVzPiB0YWcuIEZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9pbnZhbGlkLWFyaWEtcHJvcHNcIixcbiAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgdHlwZVxuICAgICAgICAgIClcbiAgICAgICAgOiAxIDwgaW52YWxpZFByb3BzLmxlbmd0aCAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkludmFsaWQgYXJpYSBwcm9wcyAlcyBvbiA8JXM+IHRhZy4gRm9yIGRldGFpbHMsIHNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL2ludmFsaWQtYXJpYS1wcm9wc1wiLFxuICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICB0eXBlXG4gICAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0eSh0YWdOYW1lLCBuYW1lLCB2YWx1ZSwgZXZlbnRSZWdpc3RyeSkge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwod2FybmVkUHJvcGVydGllcywgbmFtZSkgJiYgd2FybmVkUHJvcGVydGllc1tuYW1lXSlcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKFwib25mb2N1c2luXCIgPT09IGxvd2VyQ2FzZWROYW1lIHx8IFwib25mb2N1c291dFwiID09PSBsb3dlckNhc2VkTmFtZSlcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJSZWFjdCB1c2VzIG9uRm9jdXMgYW5kIG9uQmx1ciBpbnN0ZWFkIG9mIG9uRm9jdXNJbiBhbmQgb25Gb2N1c091dC4gQWxsIFJlYWN0IGV2ZW50cyBhcmUgbm9ybWFsaXplZCB0byBidWJibGUsIHNvIG9uRm9jdXNJbiBhbmQgb25Gb2N1c091dCBhcmUgbm90IG5lZWRlZC9zdXBwb3J0ZWQgYnkgUmVhY3QuXCJcbiAgICAgICAgICApLFxuICAgICAgICAgICh3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gITApXG4gICAgICAgICk7XG4gICAgICBpZiAoXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHZhbHVlICYmXG4gICAgICAgICgoXCJmb3JtXCIgPT09IHRhZ05hbWUgJiYgXCJhY3Rpb25cIiA9PT0gbmFtZSkgfHxcbiAgICAgICAgICAoXCJpbnB1dFwiID09PSB0YWdOYW1lICYmIFwiZm9ybUFjdGlvblwiID09PSBuYW1lKSB8fFxuICAgICAgICAgIChcImJ1dHRvblwiID09PSB0YWdOYW1lICYmIFwiZm9ybUFjdGlvblwiID09PSBuYW1lKSlcbiAgICAgIClcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgaWYgKG51bGwgIT0gZXZlbnRSZWdpc3RyeSkge1xuICAgICAgICB0YWdOYW1lID0gZXZlbnRSZWdpc3RyeS5wb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzO1xuICAgICAgICBpZiAoZXZlbnRSZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLmhhc093blByb3BlcnR5KG5hbWUpKVxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgZXZlbnRSZWdpc3RyeSA9IHRhZ05hbWUuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpXG4gICAgICAgICAgPyB0YWdOYW1lW2xvd2VyQ2FzZWROYW1lXVxuICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgaWYgKG51bGwgIT0gZXZlbnRSZWdpc3RyeSlcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJJbnZhbGlkIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/XCIsXG4gICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgIGV2ZW50UmVnaXN0cnlcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAod2FybmVkUHJvcGVydGllc1tuYW1lXSA9ICEwKVxuICAgICAgICAgICk7XG4gICAgICAgIGlmIChFVkVOVF9OQU1FX1JFR0VYLnRlc3QobmFtZSkpXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiVW5rbm93biBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuIEl0IHdpbGwgYmUgaWdub3JlZC5cIixcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICh3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gITApXG4gICAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIElOVkFMSURfRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIkludmFsaWQgZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiBSZWFjdCBldmVudHMgdXNlIHRoZSBjYW1lbENhc2UgbmFtaW5nIGNvbnZlbnRpb24sIGZvciBleGFtcGxlIGBvbkNsaWNrYC5cIixcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAod2FybmVkUHJvcGVydGllc1tuYW1lXSA9ICEwKVxuICAgICAgICApO1xuICAgICAgaWYgKHJBUklBLnRlc3QobmFtZSkgfHwgckFSSUFDYW1lbC50ZXN0KG5hbWUpKSByZXR1cm4gITA7XG4gICAgICBpZiAoXCJpbm5lcmh0bWxcIiA9PT0gbG93ZXJDYXNlZE5hbWUpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiRGlyZWN0bHkgc2V0dGluZyBwcm9wZXJ0eSBgaW5uZXJIVE1MYCBpcyBub3QgcGVybWl0dGVkLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgbG9va3VwIGRvY3VtZW50YXRpb24gb24gYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC5cIlxuICAgICAgICAgICksXG4gICAgICAgICAgKHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSAhMClcbiAgICAgICAgKTtcbiAgICAgIGlmIChcImFyaWFcIiA9PT0gbG93ZXJDYXNlZE5hbWUpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiVGhlIGBhcmlhYCBhdHRyaWJ1dGUgaXMgcmVzZXJ2ZWQgZm9yIGZ1dHVyZSB1c2UgaW4gUmVhY3QuIFBhc3MgaW5kaXZpZHVhbCBgYXJpYS1gIGF0dHJpYnV0ZXMgaW5zdGVhZC5cIlxuICAgICAgICAgICksXG4gICAgICAgICAgKHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSAhMClcbiAgICAgICAgKTtcbiAgICAgIGlmIChcbiAgICAgICAgXCJpc1wiID09PSBsb3dlckNhc2VkTmFtZSAmJlxuICAgICAgICBudWxsICE9PSB2YWx1ZSAmJlxuICAgICAgICB2b2lkIDAgIT09IHZhbHVlICYmXG4gICAgICAgIFwic3RyaW5nXCIgIT09IHR5cGVvZiB2YWx1ZVxuICAgICAgKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIlJlY2VpdmVkIGEgYCVzYCBmb3IgYSBzdHJpbmcgYXR0cmlidXRlIGBpc2AuIElmIHRoaXMgaXMgZXhwZWN0ZWQsIGNhc3QgdGhlIHZhbHVlIHRvIGEgc3RyaW5nLlwiLFxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlXG4gICAgICAgICAgKSxcbiAgICAgICAgICAod2FybmVkUHJvcGVydGllc1tuYW1lXSA9ICEwKVxuICAgICAgICApO1xuICAgICAgaWYgKFwibnVtYmVyXCIgPT09IHR5cGVvZiB2YWx1ZSAmJiBpc05hTih2YWx1ZSkpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiUmVjZWl2ZWQgTmFOIGZvciB0aGUgYCVzYCBhdHRyaWJ1dGUuIElmIHRoaXMgaXMgZXhwZWN0ZWQsIGNhc3QgdGhlIHZhbHVlIHRvIGEgc3RyaW5nLlwiLFxuICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICksXG4gICAgICAgICAgKHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSAhMClcbiAgICAgICAgKTtcbiAgICAgIGlmIChwb3NzaWJsZVN0YW5kYXJkTmFtZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAoKGxvd2VyQ2FzZWROYW1lID0gcG9zc2libGVTdGFuZGFyZE5hbWVzW2xvd2VyQ2FzZWROYW1lXSksXG4gICAgICAgICAgbG93ZXJDYXNlZE5hbWUgIT09IG5hbWUpXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJJbnZhbGlkIERPTSBwcm9wZXJ0eSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD9cIixcbiAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgbG93ZXJDYXNlZE5hbWVcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAod2FybmVkUHJvcGVydGllc1tuYW1lXSA9ICEwKVxuICAgICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKG5hbWUgIT09IGxvd2VyQ2FzZWROYW1lKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIlJlYWN0IGRvZXMgbm90IHJlY29nbml6ZSB0aGUgYCVzYCBwcm9wIG9uIGEgRE9NIGVsZW1lbnQuIElmIHlvdSBpbnRlbnRpb25hbGx5IHdhbnQgaXQgdG8gYXBwZWFyIGluIHRoZSBET00gYXMgYSBjdXN0b20gYXR0cmlidXRlLCBzcGVsbCBpdCBhcyBsb3dlcmNhc2UgYCVzYCBpbnN0ZWFkLiBJZiB5b3UgYWNjaWRlbnRhbGx5IHBhc3NlZCBpdCBmcm9tIGEgcGFyZW50IGNvbXBvbmVudCwgcmVtb3ZlIGl0IGZyb20gdGhlIERPTSBlbGVtZW50LlwiLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGxvd2VyQ2FzZWROYW1lXG4gICAgICAgICAgKSxcbiAgICAgICAgICAod2FybmVkUHJvcGVydGllc1tuYW1lXSA9ICEwKVxuICAgICAgICApO1xuICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgY2FzZSBcInN0eWxlXCI6XG4gICAgICAgIGNhc2UgXCJzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmdcIjpcbiAgICAgICAgY2FzZSBcInN1cHByZXNzSHlkcmF0aW9uV2FybmluZ1wiOlxuICAgICAgICBjYXNlIFwiZGVmYXVsdFZhbHVlXCI6XG4gICAgICAgIGNhc2UgXCJkZWZhdWx0Q2hlY2tlZFwiOlxuICAgICAgICBjYXNlIFwiaW5uZXJIVE1MXCI6XG4gICAgICAgIGNhc2UgXCJyZWZcIjpcbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgIGNhc2UgXCJpbm5lclRleHRcIjpcbiAgICAgICAgY2FzZSBcInRleHRDb250ZW50XCI6XG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfVxuICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJhdXRvRm9jdXNcIjpcbiAgICAgICAgICAgIGNhc2UgXCJjaGVja2VkXCI6XG4gICAgICAgICAgICBjYXNlIFwibXVsdGlwbGVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJtdXRlZFwiOlxuICAgICAgICAgICAgY2FzZSBcInNlbGVjdGVkXCI6XG4gICAgICAgICAgICBjYXNlIFwiY29udGVudEVkaXRhYmxlXCI6XG4gICAgICAgICAgICBjYXNlIFwic3BlbGxDaGVja1wiOlxuICAgICAgICAgICAgY2FzZSBcImRyYWdnYWJsZVwiOlxuICAgICAgICAgICAgY2FzZSBcInZhbHVlXCI6XG4gICAgICAgICAgICBjYXNlIFwiYXV0b1JldmVyc2VcIjpcbiAgICAgICAgICAgIGNhc2UgXCJleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkXCI6XG4gICAgICAgICAgICBjYXNlIFwiZm9jdXNhYmxlXCI6XG4gICAgICAgICAgICBjYXNlIFwicHJlc2VydmVBbHBoYVwiOlxuICAgICAgICAgICAgY2FzZSBcImFsbG93RnVsbFNjcmVlblwiOlxuICAgICAgICAgICAgY2FzZSBcImFzeW5jXCI6XG4gICAgICAgICAgICBjYXNlIFwiYXV0b1BsYXlcIjpcbiAgICAgICAgICAgIGNhc2UgXCJjb250cm9sc1wiOlxuICAgICAgICAgICAgY2FzZSBcImRlZmF1bHRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJkZWZlclwiOlxuICAgICAgICAgICAgY2FzZSBcImRpc2FibGVkXCI6XG4gICAgICAgICAgICBjYXNlIFwiZGlzYWJsZVBpY3R1cmVJblBpY3R1cmVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJkaXNhYmxlUmVtb3RlUGxheWJhY2tcIjpcbiAgICAgICAgICAgIGNhc2UgXCJmb3JtTm9WYWxpZGF0ZVwiOlxuICAgICAgICAgICAgY2FzZSBcImhpZGRlblwiOlxuICAgICAgICAgICAgY2FzZSBcImxvb3BcIjpcbiAgICAgICAgICAgIGNhc2UgXCJub01vZHVsZVwiOlxuICAgICAgICAgICAgY2FzZSBcIm5vVmFsaWRhdGVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJvcGVuXCI6XG4gICAgICAgICAgICBjYXNlIFwicGxheXNJbmxpbmVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJyZWFkT25seVwiOlxuICAgICAgICAgICAgY2FzZSBcInJlcXVpcmVkXCI6XG4gICAgICAgICAgICBjYXNlIFwicmV2ZXJzZWRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzY29wZWRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzZWFtbGVzc1wiOlxuICAgICAgICAgICAgY2FzZSBcIml0ZW1TY29wZVwiOlxuICAgICAgICAgICAgY2FzZSBcImNhcHR1cmVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJkb3dubG9hZFwiOlxuICAgICAgICAgICAgY2FzZSBcImluZXJ0XCI6XG4gICAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGxvd2VyQ2FzZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpLnNsaWNlKDAsIDUpO1xuICAgICAgICAgICAgICBpZiAoXCJkYXRhLVwiID09PSBsb3dlckNhc2VkTmFtZSB8fCBcImFyaWEtXCIgPT09IGxvd2VyQ2FzZWROYW1lKVxuICAgICAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICdSZWNlaXZlZCBgJXNgIGZvciBhIG5vbi1ib29sZWFuIGF0dHJpYnV0ZSBgJXNgLlxcblxcbklmIHlvdSB3YW50IHRvIHdyaXRlIGl0IHRvIHRoZSBET00sIHBhc3MgYSBzdHJpbmcgaW5zdGVhZDogJXM9XCIlc1wiIG9yICVzPXt2YWx1ZS50b1N0cmluZygpfS4nLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICA6IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICdSZWNlaXZlZCBgJXNgIGZvciBhIG5vbi1ib29sZWFuIGF0dHJpYnV0ZSBgJXNgLlxcblxcbklmIHlvdSB3YW50IHRvIHdyaXRlIGl0IHRvIHRoZSBET00sIHBhc3MgYSBzdHJpbmcgaW5zdGVhZDogJXM9XCIlc1wiIG9yICVzPXt2YWx1ZS50b1N0cmluZygpfS5cXG5cXG5JZiB5b3UgdXNlZCB0byBjb25kaXRpb25hbGx5IG9taXQgaXQgd2l0aCAlcz17Y29uZGl0aW9uICYmIHZhbHVlfSwgcGFzcyAlcz17Y29uZGl0aW9uID8gdmFsdWUgOiB1bmRlZmluZWR9IGluc3RlYWQuJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXR1cm4gKHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSAhMCk7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgICAgIHJldHVybiAod2FybmVkUHJvcGVydGllc1tuYW1lXSA9ICEwKSwgITE7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICBpZiAoXCJmYWxzZVwiID09PSB2YWx1ZSB8fCBcInRydWVcIiA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAgICAgICBjYXNlIFwiY2hlY2tlZFwiOlxuICAgICAgICAgICAgICBjYXNlIFwic2VsZWN0ZWRcIjpcbiAgICAgICAgICAgICAgY2FzZSBcIm11bHRpcGxlXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJtdXRlZFwiOlxuICAgICAgICAgICAgICBjYXNlIFwiYWxsb3dGdWxsU2NyZWVuXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJhc3luY1wiOlxuICAgICAgICAgICAgICBjYXNlIFwiYXV0b1BsYXlcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImNvbnRyb2xzXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJkZWZhdWx0XCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJkZWZlclwiOlxuICAgICAgICAgICAgICBjYXNlIFwiZGlzYWJsZWRcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImRpc2FibGVQaWN0dXJlSW5QaWN0dXJlXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJkaXNhYmxlUmVtb3RlUGxheWJhY2tcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImZvcm1Ob1ZhbGlkYXRlXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJoaWRkZW5cIjpcbiAgICAgICAgICAgICAgY2FzZSBcImxvb3BcIjpcbiAgICAgICAgICAgICAgY2FzZSBcIm5vTW9kdWxlXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJub1ZhbGlkYXRlXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJvcGVuXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJwbGF5c0lubGluZVwiOlxuICAgICAgICAgICAgICBjYXNlIFwicmVhZE9ubHlcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInJlcXVpcmVkXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJyZXZlcnNlZFwiOlxuICAgICAgICAgICAgICBjYXNlIFwic2NvcGVkXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJzZWFtbGVzc1wiOlxuICAgICAgICAgICAgICBjYXNlIFwiaXRlbVNjb3BlXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJpbmVydFwiOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVjZWl2ZWQgdGhlIHN0cmluZyBgJXNgIGZvciB0aGUgYm9vbGVhbiBhdHRyaWJ1dGUgYCVzYC4gJXMgRGlkIHlvdSBtZWFuICVzPXslc30/XCIsXG4gICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICBcImZhbHNlXCIgPT09IHZhbHVlXG4gICAgICAgICAgICAgICAgPyBcIlRoZSBicm93c2VyIHdpbGwgaW50ZXJwcmV0IGl0IGFzIGEgdHJ1dGh5IHZhbHVlLlwiXG4gICAgICAgICAgICAgICAgOiAnQWx0aG91Z2ggdGhpcyB3b3JrcywgaXQgd2lsbCBub3Qgd29yayBhcyBleHBlY3RlZCBpZiB5b3UgcGFzcyB0aGUgc3RyaW5nIFwiZmFsc2VcIi4nLFxuICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSAhMDtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gITA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhcm5Vbmtub3duUHJvcGVydGllcyh0eXBlLCBwcm9wcywgZXZlbnRSZWdpc3RyeSkge1xuICAgICAgdmFyIHVua25vd25Qcm9wcyA9IFtdLFxuICAgICAgICBrZXk7XG4gICAgICBmb3IgKGtleSBpbiBwcm9wcylcbiAgICAgICAgdmFsaWRhdGVQcm9wZXJ0eSh0eXBlLCBrZXksIHByb3BzW2tleV0sIGV2ZW50UmVnaXN0cnkpIHx8XG4gICAgICAgICAgdW5rbm93blByb3BzLnB1c2goa2V5KTtcbiAgICAgIHByb3BzID0gdW5rbm93blByb3BzXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICByZXR1cm4gXCJgXCIgKyBwcm9wICsgXCJgXCI7XG4gICAgICAgIH0pXG4gICAgICAgIC5qb2luKFwiLCBcIik7XG4gICAgICAxID09PSB1bmtub3duUHJvcHMubGVuZ3RoXG4gICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiSW52YWxpZCB2YWx1ZSBmb3IgcHJvcCAlcyBvbiA8JXM+IHRhZy4gRWl0aGVyIHJlbW92ZSBpdCBmcm9tIHRoZSBlbGVtZW50LCBvciBwYXNzIGEgc3RyaW5nIG9yIG51bWJlciB2YWx1ZSB0byBrZWVwIGl0IGluIHRoZSBET00uIEZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9hdHRyaWJ1dGUtYmVoYXZpb3IgXCIsXG4gICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgIHR5cGVcbiAgICAgICAgICApXG4gICAgICAgIDogMSA8IHVua25vd25Qcm9wcy5sZW5ndGggJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJJbnZhbGlkIHZhbHVlcyBmb3IgcHJvcHMgJXMgb24gPCVzPiB0YWcuIEVpdGhlciByZW1vdmUgdGhlbSBmcm9tIHRoZSBlbGVtZW50LCBvciBwYXNzIGEgc3RyaW5nIG9yIG51bWJlciB2YWx1ZSB0byBrZWVwIHRoZW0gaW4gdGhlIERPTS4gRm9yIGRldGFpbHMsIHNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL2F0dHJpYnV0ZS1iZWhhdmlvciBcIixcbiAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgdHlwZVxuICAgICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhbWVsaXplKHN0cmluZykge1xuICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKGh5cGhlblBhdHRlcm4sIGZ1bmN0aW9uIChfLCBjaGFyYWN0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGNoYXJhY3Rlci50b1VwcGVyQ2FzZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVzY2FwZVRleHRGb3JCcm93c2VyKHRleHQpIHtcbiAgICAgIGlmIChcbiAgICAgICAgXCJib29sZWFuXCIgPT09IHR5cGVvZiB0ZXh0IHx8XG4gICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiB0ZXh0IHx8XG4gICAgICAgIFwiYmlnaW50XCIgPT09IHR5cGVvZiB0ZXh0XG4gICAgICApXG4gICAgICAgIHJldHVybiBcIlwiICsgdGV4dDtcbiAgICAgIGNoZWNrSHRtbFN0cmluZ0NvZXJjaW9uKHRleHQpO1xuICAgICAgdGV4dCA9IFwiXCIgKyB0ZXh0O1xuICAgICAgdmFyIG1hdGNoID0gbWF0Y2hIdG1sUmVnRXhwLmV4ZWModGV4dCk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgdmFyIGh0bWwgPSBcIlwiLFxuICAgICAgICAgIGluZGV4LFxuICAgICAgICAgIGxhc3RJbmRleCA9IDA7XG4gICAgICAgIGZvciAoaW5kZXggPSBtYXRjaC5pbmRleDsgaW5kZXggPCB0ZXh0Lmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgIHN3aXRjaCAodGV4dC5jaGFyQ29kZUF0KGluZGV4KSkge1xuICAgICAgICAgICAgY2FzZSAzNDpcbiAgICAgICAgICAgICAgbWF0Y2ggPSBcIiZxdW90O1wiO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzg6XG4gICAgICAgICAgICAgIG1hdGNoID0gXCImYW1wO1wiO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzk6XG4gICAgICAgICAgICAgIG1hdGNoID0gXCImI3gyNztcIjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDYwOlxuICAgICAgICAgICAgICBtYXRjaCA9IFwiJmx0O1wiO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNjI6XG4gICAgICAgICAgICAgIG1hdGNoID0gXCImZ3Q7XCI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxhc3RJbmRleCAhPT0gaW5kZXggJiYgKGh0bWwgKz0gdGV4dC5zbGljZShsYXN0SW5kZXgsIGluZGV4KSk7XG4gICAgICAgICAgbGFzdEluZGV4ID0gaW5kZXggKyAxO1xuICAgICAgICAgIGh0bWwgKz0gbWF0Y2g7XG4gICAgICAgIH1cbiAgICAgICAgdGV4dCA9IGxhc3RJbmRleCAhPT0gaW5kZXggPyBodG1sICsgdGV4dC5zbGljZShsYXN0SW5kZXgsIGluZGV4KSA6IGh0bWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2FuaXRpemVVUkwodXJsKSB7XG4gICAgICByZXR1cm4gaXNKYXZhU2NyaXB0UHJvdG9jb2wudGVzdChcIlwiICsgdXJsKVxuICAgICAgICA/IFwiamF2YXNjcmlwdDp0aHJvdyBuZXcgRXJyb3IoJ1JlYWN0IGhhcyBibG9ja2VkIGEgamF2YXNjcmlwdDogVVJMIGFzIGEgc2VjdXJpdHkgcHJlY2F1dGlvbi4nKVwiXG4gICAgICAgIDogdXJsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlc2NhcGVFbnRpcmVJbmxpbmVTY3JpcHRDb250ZW50KHNjcmlwdFRleHQpIHtcbiAgICAgIGNoZWNrSHRtbFN0cmluZ0NvZXJjaW9uKHNjcmlwdFRleHQpO1xuICAgICAgcmV0dXJuIChcIlwiICsgc2NyaXB0VGV4dCkucmVwbGFjZShzY3JpcHRSZWdleCwgc2NyaXB0UmVwbGFjZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVSZW5kZXJTdGF0ZShcbiAgICAgIHJlc3VtYWJsZVN0YXRlLFxuICAgICAgbm9uY2UsXG4gICAgICBleHRlcm5hbFJ1bnRpbWVDb25maWcsXG4gICAgICBpbXBvcnRNYXAsXG4gICAgICBvbkhlYWRlcnMsXG4gICAgICBtYXhIZWFkZXJzTGVuZ3RoXG4gICAgKSB7XG4gICAgICB2YXIgaW5saW5lU2NyaXB0V2l0aE5vbmNlID1cbiAgICAgICAgICB2b2lkIDAgPT09IG5vbmNlXG4gICAgICAgICAgICA/IHN0YXJ0SW5saW5lU2NyaXB0XG4gICAgICAgICAgICA6IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcbiAgICAgICAgICAgICAgICAnPHNjcmlwdCBub25jZT1cIicgKyBlc2NhcGVUZXh0Rm9yQnJvd3Nlcihub25jZSkgKyAnXCI+J1xuICAgICAgICAgICAgICApLFxuICAgICAgICBpZFByZWZpeCA9IHJlc3VtYWJsZVN0YXRlLmlkUHJlZml4O1xuICAgICAgZXh0ZXJuYWxSdW50aW1lQ29uZmlnID0gW107XG4gICAgICB2YXIgYm9vdHN0cmFwU2NyaXB0Q29udGVudCA9IHJlc3VtYWJsZVN0YXRlLmJvb3RzdHJhcFNjcmlwdENvbnRlbnQsXG4gICAgICAgIGJvb3RzdHJhcFNjcmlwdHMgPSByZXN1bWFibGVTdGF0ZS5ib290c3RyYXBTY3JpcHRzLFxuICAgICAgICBib290c3RyYXBNb2R1bGVzID0gcmVzdW1hYmxlU3RhdGUuYm9vdHN0cmFwTW9kdWxlcztcbiAgICAgIHZvaWQgMCAhPT0gYm9vdHN0cmFwU2NyaXB0Q29udGVudCAmJlxuICAgICAgICBleHRlcm5hbFJ1bnRpbWVDb25maWcucHVzaChcbiAgICAgICAgICBpbmxpbmVTY3JpcHRXaXRoTm9uY2UsXG4gICAgICAgICAgc3RyaW5nVG9DaHVuayhcbiAgICAgICAgICAgIGVzY2FwZUVudGlyZUlubGluZVNjcmlwdENvbnRlbnQoYm9vdHN0cmFwU2NyaXB0Q29udGVudClcbiAgICAgICAgICApLFxuICAgICAgICAgIGVuZElubGluZVNjcmlwdFxuICAgICAgICApO1xuICAgICAgYm9vdHN0cmFwU2NyaXB0Q29udGVudCA9IFtdO1xuICAgICAgdm9pZCAwICE9PSBpbXBvcnRNYXAgJiZcbiAgICAgICAgKGJvb3RzdHJhcFNjcmlwdENvbnRlbnQucHVzaChpbXBvcnRNYXBTY3JpcHRTdGFydCksXG4gICAgICAgIGJvb3RzdHJhcFNjcmlwdENvbnRlbnQucHVzaChcbiAgICAgICAgICBzdHJpbmdUb0NodW5rKFxuICAgICAgICAgICAgZXNjYXBlRW50aXJlSW5saW5lU2NyaXB0Q29udGVudChKU09OLnN0cmluZ2lmeShpbXBvcnRNYXApKVxuICAgICAgICAgIClcbiAgICAgICAgKSxcbiAgICAgICAgYm9vdHN0cmFwU2NyaXB0Q29udGVudC5wdXNoKGltcG9ydE1hcFNjcmlwdEVuZCkpO1xuICAgICAgb25IZWFkZXJzICYmXG4gICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiBtYXhIZWFkZXJzTGVuZ3RoICYmXG4gICAgICAgIDAgPj0gbWF4SGVhZGVyc0xlbmd0aCAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiUmVhY3QgZXhwZWN0ZWQgYSBwb3NpdGl2ZSBub24temVybyBgbWF4SGVhZGVyc0xlbmd0aGAgb3B0aW9uIGJ1dCBmb3VuZCAlcyBpbnN0ZWFkLiBXaGVuIHVzaW5nIHRoZSBgb25IZWFkZXJzYCBvcHRpb24geW91IG1heSBzdXBwbHkgYW4gb3B0aW9uYWwgYG1heEhlYWRlcnNMZW5ndGhgIG9wdGlvbiBhcyB3ZWxsIGhvd2V2ZXIsIHdoZW4gc2V0dGluZyB0aGlzIHZhbHVlIHRvIHplcm8gb3IgbGVzcyBubyBoZWFkZXJzIHdpbGwgYmUgY2FwdHVyZWQuXCIsXG4gICAgICAgICAgMCA9PT0gbWF4SGVhZGVyc0xlbmd0aCA/IFwiemVyb1wiIDogbWF4SGVhZGVyc0xlbmd0aFxuICAgICAgICApO1xuICAgICAgaW1wb3J0TWFwID0gb25IZWFkZXJzXG4gICAgICAgID8ge1xuICAgICAgICAgICAgcHJlY29ubmVjdHM6IFwiXCIsXG4gICAgICAgICAgICBmb250UHJlbG9hZHM6IFwiXCIsXG4gICAgICAgICAgICBoaWdoSW1hZ2VQcmVsb2FkczogXCJcIixcbiAgICAgICAgICAgIHJlbWFpbmluZ0NhcGFjaXR5OlxuICAgICAgICAgICAgICAyICtcbiAgICAgICAgICAgICAgKFwibnVtYmVyXCIgPT09IHR5cGVvZiBtYXhIZWFkZXJzTGVuZ3RoID8gbWF4SGVhZGVyc0xlbmd0aCA6IDJlMylcbiAgICAgICAgICB9XG4gICAgICAgIDogbnVsbDtcbiAgICAgIG9uSGVhZGVycyA9IHtcbiAgICAgICAgcGxhY2Vob2xkZXJQcmVmaXg6IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhpZFByZWZpeCArIFwiUDpcIiksXG4gICAgICAgIHNlZ21lbnRQcmVmaXg6IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhpZFByZWZpeCArIFwiUzpcIiksXG4gICAgICAgIGJvdW5kYXJ5UHJlZml4OiBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoaWRQcmVmaXggKyBcIkI6XCIpLFxuICAgICAgICBzdGFydElubGluZVNjcmlwdDogaW5saW5lU2NyaXB0V2l0aE5vbmNlLFxuICAgICAgICBodG1sQ2h1bmtzOiBudWxsLFxuICAgICAgICBoZWFkQ2h1bmtzOiBudWxsLFxuICAgICAgICBleHRlcm5hbFJ1bnRpbWVTY3JpcHQ6IG51bGwsXG4gICAgICAgIGJvb3RzdHJhcENodW5rczogZXh0ZXJuYWxSdW50aW1lQ29uZmlnLFxuICAgICAgICBpbXBvcnRNYXBDaHVua3M6IGJvb3RzdHJhcFNjcmlwdENvbnRlbnQsXG4gICAgICAgIG9uSGVhZGVyczogb25IZWFkZXJzLFxuICAgICAgICBoZWFkZXJzOiBpbXBvcnRNYXAsXG4gICAgICAgIHJlc2V0czoge1xuICAgICAgICAgIGZvbnQ6IHt9LFxuICAgICAgICAgIGRuczoge30sXG4gICAgICAgICAgY29ubmVjdDogeyBkZWZhdWx0OiB7fSwgYW5vbnltb3VzOiB7fSwgY3JlZGVudGlhbHM6IHt9IH0sXG4gICAgICAgICAgaW1hZ2U6IHt9LFxuICAgICAgICAgIHN0eWxlOiB7fVxuICAgICAgICB9LFxuICAgICAgICBjaGFyc2V0Q2h1bmtzOiBbXSxcbiAgICAgICAgdmlld3BvcnRDaHVua3M6IFtdLFxuICAgICAgICBob2lzdGFibGVDaHVua3M6IFtdLFxuICAgICAgICBwcmVjb25uZWN0czogbmV3IFNldCgpLFxuICAgICAgICBmb250UHJlbG9hZHM6IG5ldyBTZXQoKSxcbiAgICAgICAgaGlnaEltYWdlUHJlbG9hZHM6IG5ldyBTZXQoKSxcbiAgICAgICAgc3R5bGVzOiBuZXcgTWFwKCksXG4gICAgICAgIGJvb3RzdHJhcFNjcmlwdHM6IG5ldyBTZXQoKSxcbiAgICAgICAgc2NyaXB0czogbmV3IFNldCgpLFxuICAgICAgICBidWxrUHJlbG9hZHM6IG5ldyBTZXQoKSxcbiAgICAgICAgcHJlbG9hZHM6IHtcbiAgICAgICAgICBpbWFnZXM6IG5ldyBNYXAoKSxcbiAgICAgICAgICBzdHlsZXNoZWV0czogbmV3IE1hcCgpLFxuICAgICAgICAgIHNjcmlwdHM6IG5ldyBNYXAoKSxcbiAgICAgICAgICBtb2R1bGVTY3JpcHRzOiBuZXcgTWFwKClcbiAgICAgICAgfSxcbiAgICAgICAgbm9uY2U6IG5vbmNlLFxuICAgICAgICBob2lzdGFibGVTdGF0ZTogbnVsbCxcbiAgICAgICAgc3R5bGVzVG9Ib2lzdDogITFcbiAgICAgIH07XG4gICAgICBpZiAodm9pZCAwICE9PSBib290c3RyYXBTY3JpcHRzKVxuICAgICAgICBmb3IgKGltcG9ydE1hcCA9IDA7IGltcG9ydE1hcCA8IGJvb3RzdHJhcFNjcmlwdHMubGVuZ3RoOyBpbXBvcnRNYXArKykge1xuICAgICAgICAgIG1heEhlYWRlcnNMZW5ndGggPSBib290c3RyYXBTY3JpcHRzW2ltcG9ydE1hcF07XG4gICAgICAgICAgYm9vdHN0cmFwU2NyaXB0Q29udGVudCA9IGlkUHJlZml4ID0gdm9pZCAwO1xuICAgICAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgICAgIHJlbDogXCJwcmVsb2FkXCIsXG4gICAgICAgICAgICBhczogXCJzY3JpcHRcIixcbiAgICAgICAgICAgIGZldGNoUHJpb3JpdHk6IFwibG93XCIsXG4gICAgICAgICAgICBub25jZTogbm9uY2VcbiAgICAgICAgICB9O1xuICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBtYXhIZWFkZXJzTGVuZ3RoXG4gICAgICAgICAgICA/IChwcm9wcy5ocmVmID0gaW5saW5lU2NyaXB0V2l0aE5vbmNlID0gbWF4SGVhZGVyc0xlbmd0aClcbiAgICAgICAgICAgIDogKChwcm9wcy5ocmVmID0gaW5saW5lU2NyaXB0V2l0aE5vbmNlID0gbWF4SGVhZGVyc0xlbmd0aC5zcmMpLFxuICAgICAgICAgICAgICAocHJvcHMuaW50ZWdyaXR5ID0gYm9vdHN0cmFwU2NyaXB0Q29udGVudCA9XG4gICAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG1heEhlYWRlcnNMZW5ndGguaW50ZWdyaXR5XG4gICAgICAgICAgICAgICAgICA/IG1heEhlYWRlcnNMZW5ndGguaW50ZWdyaXR5XG4gICAgICAgICAgICAgICAgICA6IHZvaWQgMCksXG4gICAgICAgICAgICAgIChwcm9wcy5jcm9zc09yaWdpbiA9IGlkUHJlZml4ID1cbiAgICAgICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgbWF4SGVhZGVyc0xlbmd0aCB8fFxuICAgICAgICAgICAgICAgIG51bGwgPT0gbWF4SGVhZGVyc0xlbmd0aC5jcm9zc09yaWdpblxuICAgICAgICAgICAgICAgICAgPyB2b2lkIDBcbiAgICAgICAgICAgICAgICAgIDogXCJ1c2UtY3JlZGVudGlhbHNcIiA9PT0gbWF4SGVhZGVyc0xlbmd0aC5jcm9zc09yaWdpblxuICAgICAgICAgICAgICAgICAgICA/IFwidXNlLWNyZWRlbnRpYWxzXCJcbiAgICAgICAgICAgICAgICAgICAgOiBcIlwiKSk7XG4gICAgICAgICAgcHJlbG9hZEJvb3RzdHJhcFNjcmlwdE9yTW9kdWxlKFxuICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICBvbkhlYWRlcnMsXG4gICAgICAgICAgICBpbmxpbmVTY3JpcHRXaXRoTm9uY2UsXG4gICAgICAgICAgICBwcm9wc1xuICAgICAgICAgICk7XG4gICAgICAgICAgZXh0ZXJuYWxSdW50aW1lQ29uZmlnLnB1c2goXG4gICAgICAgICAgICBzdGFydFNjcmlwdFNyYyxcbiAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoaW5saW5lU2NyaXB0V2l0aE5vbmNlKSlcbiAgICAgICAgICApO1xuICAgICAgICAgIG5vbmNlICYmXG4gICAgICAgICAgICBleHRlcm5hbFJ1bnRpbWVDb25maWcucHVzaChcbiAgICAgICAgICAgICAgc2NyaXB0Tm9uY2UsXG4gICAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIobm9uY2UpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgYm9vdHN0cmFwU2NyaXB0Q29udGVudCAmJlxuICAgICAgICAgICAgZXh0ZXJuYWxSdW50aW1lQ29uZmlnLnB1c2goXG4gICAgICAgICAgICAgIHNjcmlwdEludGVnaXJ0eSxcbiAgICAgICAgICAgICAgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3Nlcihib290c3RyYXBTY3JpcHRDb250ZW50KSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGlkUHJlZml4ICYmXG4gICAgICAgICAgICBleHRlcm5hbFJ1bnRpbWVDb25maWcucHVzaChcbiAgICAgICAgICAgICAgc2NyaXB0Q3Jvc3NPcmlnaW4sXG4gICAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoaWRQcmVmaXgpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBleHRlcm5hbFJ1bnRpbWVDb25maWcucHVzaChlbmRBc3luY1NjcmlwdCk7XG4gICAgICAgIH1cbiAgICAgIGlmICh2b2lkIDAgIT09IGJvb3RzdHJhcE1vZHVsZXMpXG4gICAgICAgIGZvciAoXG4gICAgICAgICAgYm9vdHN0cmFwU2NyaXB0cyA9IDA7XG4gICAgICAgICAgYm9vdHN0cmFwU2NyaXB0cyA8IGJvb3RzdHJhcE1vZHVsZXMubGVuZ3RoO1xuICAgICAgICAgIGJvb3RzdHJhcFNjcmlwdHMrK1xuICAgICAgICApXG4gICAgICAgICAgKGltcG9ydE1hcCA9IGJvb3RzdHJhcE1vZHVsZXNbYm9vdHN0cmFwU2NyaXB0c10pLFxuICAgICAgICAgICAgKGlkUHJlZml4ID0gaW5saW5lU2NyaXB0V2l0aE5vbmNlID0gdm9pZCAwKSxcbiAgICAgICAgICAgIChib290c3RyYXBTY3JpcHRDb250ZW50ID0ge1xuICAgICAgICAgICAgICByZWw6IFwibW9kdWxlcHJlbG9hZFwiLFxuICAgICAgICAgICAgICBmZXRjaFByaW9yaXR5OiBcImxvd1wiLFxuICAgICAgICAgICAgICBub25jZTogbm9uY2VcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGltcG9ydE1hcFxuICAgICAgICAgICAgICA/IChib290c3RyYXBTY3JpcHRDb250ZW50LmhyZWYgPSBtYXhIZWFkZXJzTGVuZ3RoID0gaW1wb3J0TWFwKVxuICAgICAgICAgICAgICA6ICgoYm9vdHN0cmFwU2NyaXB0Q29udGVudC5ocmVmID0gbWF4SGVhZGVyc0xlbmd0aCA9XG4gICAgICAgICAgICAgICAgICBpbXBvcnRNYXAuc3JjKSxcbiAgICAgICAgICAgICAgICAoYm9vdHN0cmFwU2NyaXB0Q29udGVudC5pbnRlZ3JpdHkgPSBpZFByZWZpeCA9XG4gICAgICAgICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgaW1wb3J0TWFwLmludGVncml0eVxuICAgICAgICAgICAgICAgICAgICA/IGltcG9ydE1hcC5pbnRlZ3JpdHlcbiAgICAgICAgICAgICAgICAgICAgOiB2b2lkIDApLFxuICAgICAgICAgICAgICAgIChib290c3RyYXBTY3JpcHRDb250ZW50LmNyb3NzT3JpZ2luID0gaW5saW5lU2NyaXB0V2l0aE5vbmNlID1cbiAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBpbXBvcnRNYXAgfHwgbnVsbCA9PSBpbXBvcnRNYXAuY3Jvc3NPcmlnaW5cbiAgICAgICAgICAgICAgICAgICAgPyB2b2lkIDBcbiAgICAgICAgICAgICAgICAgICAgOiBcInVzZS1jcmVkZW50aWFsc1wiID09PSBpbXBvcnRNYXAuY3Jvc3NPcmlnaW5cbiAgICAgICAgICAgICAgICAgICAgICA/IFwidXNlLWNyZWRlbnRpYWxzXCJcbiAgICAgICAgICAgICAgICAgICAgICA6IFwiXCIpKSxcbiAgICAgICAgICAgIHByZWxvYWRCb290c3RyYXBTY3JpcHRPck1vZHVsZShcbiAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICAgIG9uSGVhZGVycyxcbiAgICAgICAgICAgICAgbWF4SGVhZGVyc0xlbmd0aCxcbiAgICAgICAgICAgICAgYm9vdHN0cmFwU2NyaXB0Q29udGVudFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGV4dGVybmFsUnVudGltZUNvbmZpZy5wdXNoKFxuICAgICAgICAgICAgICBzdGFydE1vZHVsZVNyYyxcbiAgICAgICAgICAgICAgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihtYXhIZWFkZXJzTGVuZ3RoKSlcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBub25jZSAmJlxuICAgICAgICAgICAgICBleHRlcm5hbFJ1bnRpbWVDb25maWcucHVzaChcbiAgICAgICAgICAgICAgICBzY3JpcHROb25jZSxcbiAgICAgICAgICAgICAgICBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKG5vbmNlKSlcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBpZFByZWZpeCAmJlxuICAgICAgICAgICAgICBleHRlcm5hbFJ1bnRpbWVDb25maWcucHVzaChcbiAgICAgICAgICAgICAgICBzY3JpcHRJbnRlZ2lydHksXG4gICAgICAgICAgICAgICAgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihpZFByZWZpeCkpXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgaW5saW5lU2NyaXB0V2l0aE5vbmNlICYmXG4gICAgICAgICAgICAgIGV4dGVybmFsUnVudGltZUNvbmZpZy5wdXNoKFxuICAgICAgICAgICAgICAgIHNjcmlwdENyb3NzT3JpZ2luLFxuICAgICAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoaW5saW5lU2NyaXB0V2l0aE5vbmNlKSlcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGV4dGVybmFsUnVudGltZUNvbmZpZy5wdXNoKGVuZEFzeW5jU2NyaXB0KTtcbiAgICAgIHJldHVybiBvbkhlYWRlcnM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlc3VtYWJsZVN0YXRlKFxuICAgICAgaWRlbnRpZmllclByZWZpeCxcbiAgICAgIGV4dGVybmFsUnVudGltZUNvbmZpZyxcbiAgICAgIGJvb3RzdHJhcFNjcmlwdENvbnRlbnQsXG4gICAgICBib290c3RyYXBTY3JpcHRzLFxuICAgICAgYm9vdHN0cmFwTW9kdWxlc1xuICAgICkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWRQcmVmaXg6IHZvaWQgMCA9PT0gaWRlbnRpZmllclByZWZpeCA/IFwiXCIgOiBpZGVudGlmaWVyUHJlZml4LFxuICAgICAgICBuZXh0Rm9ybUlEOiAwLFxuICAgICAgICBzdHJlYW1pbmdGb3JtYXQ6IDAsXG4gICAgICAgIGJvb3RzdHJhcFNjcmlwdENvbnRlbnQ6IGJvb3RzdHJhcFNjcmlwdENvbnRlbnQsXG4gICAgICAgIGJvb3RzdHJhcFNjcmlwdHM6IGJvb3RzdHJhcFNjcmlwdHMsXG4gICAgICAgIGJvb3RzdHJhcE1vZHVsZXM6IGJvb3RzdHJhcE1vZHVsZXMsXG4gICAgICAgIGluc3RydWN0aW9uczogTm90aGluZ1NlbnQsXG4gICAgICAgIGhhc0JvZHk6ICExLFxuICAgICAgICBoYXNIdG1sOiAhMSxcbiAgICAgICAgdW5rbm93blJlc291cmNlczoge30sXG4gICAgICAgIGRuc1Jlc291cmNlczoge30sXG4gICAgICAgIGNvbm5lY3RSZXNvdXJjZXM6IHsgZGVmYXVsdDoge30sIGFub255bW91czoge30sIGNyZWRlbnRpYWxzOiB7fSB9LFxuICAgICAgICBpbWFnZVJlc291cmNlczoge30sXG4gICAgICAgIHN0eWxlUmVzb3VyY2VzOiB7fSxcbiAgICAgICAgc2NyaXB0UmVzb3VyY2VzOiB7fSxcbiAgICAgICAgbW9kdWxlVW5rbm93blJlc291cmNlczoge30sXG4gICAgICAgIG1vZHVsZVNjcmlwdFJlc291cmNlczoge31cbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZvcm1hdENvbnRleHQoaW5zZXJ0aW9uTW9kZSwgc2VsZWN0ZWRWYWx1ZSwgdGFnU2NvcGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluc2VydGlvbk1vZGU6IGluc2VydGlvbk1vZGUsXG4gICAgICAgIHNlbGVjdGVkVmFsdWU6IHNlbGVjdGVkVmFsdWUsXG4gICAgICAgIHRhZ1Njb3BlOiB0YWdTY29wZVxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlUm9vdEZvcm1hdENvbnRleHQobmFtZXNwYWNlVVJJKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChcbiAgICAgICAgXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiID09PSBuYW1lc3BhY2VVUklcbiAgICAgICAgICA/IFNWR19NT0RFXG4gICAgICAgICAgOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIiA9PT0gbmFtZXNwYWNlVVJJXG4gICAgICAgICAgICA/IE1BVEhNTF9NT0RFXG4gICAgICAgICAgICA6IFJPT1RfSFRNTF9NT0RFLFxuICAgICAgICBudWxsLFxuICAgICAgICAwXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDaGlsZEZvcm1hdENvbnRleHQocGFyZW50Q29udGV4dCwgdHlwZSwgcHJvcHMpIHtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwibm9zY3JpcHRcIjpcbiAgICAgICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChcbiAgICAgICAgICAgIEhUTUxfTU9ERSxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBwYXJlbnRDb250ZXh0LnRhZ1Njb3BlIHwgMVxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgXCJzZWxlY3RcIjpcbiAgICAgICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChcbiAgICAgICAgICAgIEhUTUxfTU9ERSxcbiAgICAgICAgICAgIG51bGwgIT0gcHJvcHMudmFsdWUgPyBwcm9wcy52YWx1ZSA6IHByb3BzLmRlZmF1bHRWYWx1ZSxcbiAgICAgICAgICAgIHBhcmVudENvbnRleHQudGFnU2NvcGVcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIFwic3ZnXCI6XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoU1ZHX01PREUsIG51bGwsIHBhcmVudENvbnRleHQudGFnU2NvcGUpO1xuICAgICAgICBjYXNlIFwicGljdHVyZVwiOlxuICAgICAgICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KFxuICAgICAgICAgICAgSFRNTF9NT0RFLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHBhcmVudENvbnRleHQudGFnU2NvcGUgfCAyXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBcIm1hdGhcIjpcbiAgICAgICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChNQVRITUxfTU9ERSwgbnVsbCwgcGFyZW50Q29udGV4dC50YWdTY29wZSk7XG4gICAgICAgIGNhc2UgXCJmb3JlaWduT2JqZWN0XCI6XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoSFRNTF9NT0RFLCBudWxsLCBwYXJlbnRDb250ZXh0LnRhZ1Njb3BlKTtcbiAgICAgICAgY2FzZSBcInRhYmxlXCI6XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoXG4gICAgICAgICAgICBIVE1MX1RBQkxFX01PREUsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgcGFyZW50Q29udGV4dC50YWdTY29wZVxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgXCJ0aGVhZFwiOlxuICAgICAgICBjYXNlIFwidGJvZHlcIjpcbiAgICAgICAgY2FzZSBcInRmb290XCI6XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoXG4gICAgICAgICAgICBIVE1MX1RBQkxFX0JPRFlfTU9ERSxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBwYXJlbnRDb250ZXh0LnRhZ1Njb3BlXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBcImNvbGdyb3VwXCI6XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoXG4gICAgICAgICAgICBIVE1MX0NPTEdST1VQX01PREUsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgcGFyZW50Q29udGV4dC50YWdTY29wZVxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgXCJ0clwiOlxuICAgICAgICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KFxuICAgICAgICAgICAgSFRNTF9UQUJMRV9ST1dfTU9ERSxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBwYXJlbnRDb250ZXh0LnRhZ1Njb3BlXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJlbnRDb250ZXh0Lmluc2VydGlvbk1vZGUgPj0gSFRNTF9UQUJMRV9NT0RFXG4gICAgICAgID8gY3JlYXRlRm9ybWF0Q29udGV4dChIVE1MX01PREUsIG51bGwsIHBhcmVudENvbnRleHQudGFnU2NvcGUpXG4gICAgICAgIDogcGFyZW50Q29udGV4dC5pbnNlcnRpb25Nb2RlID09PSBST09UX0hUTUxfTU9ERVxuICAgICAgICAgID8gXCJodG1sXCIgPT09IHR5cGVcbiAgICAgICAgICAgID8gY3JlYXRlRm9ybWF0Q29udGV4dChIVE1MX0hUTUxfTU9ERSwgbnVsbCwgcGFyZW50Q29udGV4dC50YWdTY29wZSlcbiAgICAgICAgICAgIDogY3JlYXRlRm9ybWF0Q29udGV4dChIVE1MX01PREUsIG51bGwsIHBhcmVudENvbnRleHQudGFnU2NvcGUpXG4gICAgICAgICAgOiBwYXJlbnRDb250ZXh0Lmluc2VydGlvbk1vZGUgPT09IEhUTUxfSFRNTF9NT0RFXG4gICAgICAgICAgICA/IGNyZWF0ZUZvcm1hdENvbnRleHQoSFRNTF9NT0RFLCBudWxsLCBwYXJlbnRDb250ZXh0LnRhZ1Njb3BlKVxuICAgICAgICAgICAgOiBwYXJlbnRDb250ZXh0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoVGV4dEluc3RhbmNlKHRhcmdldCwgdGV4dCwgcmVuZGVyU3RhdGUsIHRleHRFbWJlZGRlZCkge1xuICAgICAgaWYgKFwiXCIgPT09IHRleHQpIHJldHVybiB0ZXh0RW1iZWRkZWQ7XG4gICAgICB0ZXh0RW1iZWRkZWQgJiYgdGFyZ2V0LnB1c2godGV4dFNlcGFyYXRvcik7XG4gICAgICB0YXJnZXQucHVzaChzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKHRleHQpKSk7XG4gICAgICByZXR1cm4gITA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hTdHlsZUF0dHJpYnV0ZSh0YXJnZXQsIHN0eWxlKSB7XG4gICAgICBpZiAoXCJvYmplY3RcIiAhPT0gdHlwZW9mIHN0eWxlKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIlRoZSBgc3R5bGVgIHByb3AgZXhwZWN0cyBhIG1hcHBpbmcgZnJvbSBzdHlsZSBwcm9wZXJ0aWVzIHRvIHZhbHVlcywgbm90IGEgc3RyaW5nLiBGb3IgZXhhbXBsZSwgc3R5bGU9e3ttYXJnaW5SaWdodDogc3BhY2luZyArICdlbSd9fSB3aGVuIHVzaW5nIEpTWC5cIlxuICAgICAgICApO1xuICAgICAgdmFyIGlzRmlyc3QgPSAhMCxcbiAgICAgICAgc3R5bGVOYW1lO1xuICAgICAgZm9yIChzdHlsZU5hbWUgaW4gc3R5bGUpXG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHN0eWxlLCBzdHlsZU5hbWUpKSB7XG4gICAgICAgICAgdmFyIHN0eWxlVmFsdWUgPSBzdHlsZVtzdHlsZU5hbWVdO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIG51bGwgIT0gc3R5bGVWYWx1ZSAmJlxuICAgICAgICAgICAgXCJib29sZWFuXCIgIT09IHR5cGVvZiBzdHlsZVZhbHVlICYmXG4gICAgICAgICAgICBcIlwiICE9PSBzdHlsZVZhbHVlXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAoMCA9PT0gc3R5bGVOYW1lLmluZGV4T2YoXCItLVwiKSkge1xuICAgICAgICAgICAgICB2YXIgbmFtZUNodW5rID0gc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihzdHlsZU5hbWUpKTtcbiAgICAgICAgICAgICAgY2hlY2tDU1NQcm9wZXJ0eVN0cmluZ0NvZXJjaW9uKHN0eWxlVmFsdWUsIHN0eWxlTmFtZSk7XG4gICAgICAgICAgICAgIHN0eWxlVmFsdWUgPSBzdHJpbmdUb0NodW5rKFxuICAgICAgICAgICAgICAgIGVzY2FwZVRleHRGb3JCcm93c2VyKChcIlwiICsgc3R5bGVWYWx1ZSkudHJpbSgpKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmFtZUNodW5rID0gc3R5bGVOYW1lO1xuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBzdHlsZVZhbHVlO1xuICAgICAgICAgICAgICBpZiAoLTEgPCBuYW1lQ2h1bmsuaW5kZXhPZihcIi1cIikpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IG5hbWVDaHVuaztcbiAgICAgICAgICAgICAgICAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJlxuICAgICAgICAgICAgICAgICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSkgfHxcbiAgICAgICAgICAgICAgICAgICgod2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9ICEwKSxcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiVW5zdXBwb3J0ZWQgc3R5bGUgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz9cIixcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgY2FtZWxpemUobmFtZS5yZXBsYWNlKG1zUGF0dGVybiQxLCBcIm1zLVwiKSlcbiAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybi50ZXN0KG5hbWVDaHVuaykpXG4gICAgICAgICAgICAgICAgKG5hbWUgPSBuYW1lQ2h1bmspLFxuICAgICAgICAgICAgICAgICAgKHdhcm5lZFN0eWxlTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKCh3YXJuZWRTdHlsZU5hbWVzW25hbWVdID0gITApLFxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgIFwiVW5zdXBwb3J0ZWQgdmVuZG9yLXByZWZpeGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/XCIsXG4gICAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKVxuICAgICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgZWxzZSBpZiAoYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IG5hbWVDaHVuaztcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUkanNjb21wJDAgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAod2FybmVkU3R5bGVWYWx1ZXMuaGFzT3duUHJvcGVydHkodmFsdWUkanNjb21wJDApICYmXG4gICAgICAgICAgICAgICAgICB3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZSRqc2NvbXAkMF0pIHx8XG4gICAgICAgICAgICAgICAgICAoKHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlJGpzY29tcCQwXSA9ICEwKSxcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICdTdHlsZSBwcm9wZXJ0eSB2YWx1ZXMgc2hvdWxkblxcJ3QgY29udGFpbiBhIHNlbWljb2xvbi4gVHJ5IFwiJXM6ICVzXCIgaW5zdGVhZC4nLFxuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSRqc2NvbXAkMC5yZXBsYWNlKFxuICAgICAgICAgICAgICAgICAgICAgIGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybixcbiAgICAgICAgICAgICAgICAgICAgICBcIlwiXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICAgICAgICAgIChpc05hTih2YWx1ZSlcbiAgICAgICAgICAgICAgICAgID8gd2FybmVkRm9yTmFOVmFsdWUgfHxcbiAgICAgICAgICAgICAgICAgICAgKCh3YXJuZWRGb3JOYU5WYWx1ZSA9ICEwKSxcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICBcImBOYU5gIGlzIGFuIGludmFsaWQgdmFsdWUgZm9yIHRoZSBgJXNgIGNzcyBzdHlsZSBwcm9wZXJ0eS5cIixcbiAgICAgICAgICAgICAgICAgICAgICBuYW1lQ2h1bmtcbiAgICAgICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgICAgIDogaXNGaW5pdGUodmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgICAgIHdhcm5lZEZvckluZmluaXR5VmFsdWUgfHxcbiAgICAgICAgICAgICAgICAgICAgKCh3YXJuZWRGb3JJbmZpbml0eVZhbHVlID0gITApLFxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgIFwiYEluZmluaXR5YCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgbmFtZUNodW5rXG4gICAgICAgICAgICAgICAgICAgICkpKTtcbiAgICAgICAgICAgICAgbmFtZUNodW5rID0gc3R5bGVOYW1lO1xuICAgICAgICAgICAgICB2YWx1ZSA9IHN0eWxlTmFtZUNhY2hlLmdldChuYW1lQ2h1bmspO1xuICAgICAgICAgICAgICB2b2lkIDAgIT09IHZhbHVlXG4gICAgICAgICAgICAgICAgPyAobmFtZUNodW5rID0gdmFsdWUpXG4gICAgICAgICAgICAgICAgOiAoKHZhbHVlID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFxuICAgICAgICAgICAgICAgICAgICBlc2NhcGVUZXh0Rm9yQnJvd3NlcihcbiAgICAgICAgICAgICAgICAgICAgICBuYW1lQ2h1bmtcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKHVwcGVyY2FzZVBhdHRlcm4sIFwiLSQxXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UobXNQYXR0ZXJuLCBcIi1tcy1cIilcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICBzdHlsZU5hbWVDYWNoZS5zZXQobmFtZUNodW5rLCB2YWx1ZSksXG4gICAgICAgICAgICAgICAgICAobmFtZUNodW5rID0gdmFsdWUpKTtcbiAgICAgICAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIHN0eWxlVmFsdWVcbiAgICAgICAgICAgICAgICA/IChzdHlsZVZhbHVlID1cbiAgICAgICAgICAgICAgICAgICAgMCA9PT0gc3R5bGVWYWx1ZSB8fCB1bml0bGVzc051bWJlcnMuaGFzKHN0eWxlTmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICA/IHN0cmluZ1RvQ2h1bmsoXCJcIiArIHN0eWxlVmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgOiBzdHJpbmdUb0NodW5rKHN0eWxlVmFsdWUgKyBcInB4XCIpKVxuICAgICAgICAgICAgICAgIDogKGNoZWNrQ1NTUHJvcGVydHlTdHJpbmdDb2VyY2lvbihzdHlsZVZhbHVlLCBzdHlsZU5hbWUpLFxuICAgICAgICAgICAgICAgICAgKHN0eWxlVmFsdWUgPSBzdHJpbmdUb0NodW5rKFxuICAgICAgICAgICAgICAgICAgICBlc2NhcGVUZXh0Rm9yQnJvd3NlcigoXCJcIiArIHN0eWxlVmFsdWUpLnRyaW0oKSlcbiAgICAgICAgICAgICAgICAgICkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzRmlyc3RcbiAgICAgICAgICAgICAgPyAoKGlzRmlyc3QgPSAhMSksXG4gICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2goXG4gICAgICAgICAgICAgICAgICBzdHlsZUF0dHJpYnV0ZVN0YXJ0LFxuICAgICAgICAgICAgICAgICAgbmFtZUNodW5rLFxuICAgICAgICAgICAgICAgICAgc3R5bGVBc3NpZ24sXG4gICAgICAgICAgICAgICAgICBzdHlsZVZhbHVlXG4gICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgOiB0YXJnZXQucHVzaChzdHlsZVNlcGFyYXRvciwgbmFtZUNodW5rLCBzdHlsZUFzc2lnbiwgc3R5bGVWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBpc0ZpcnN0IHx8IHRhcmdldC5wdXNoKGF0dHJpYnV0ZUVuZCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hCb29sZWFuQXR0cmlidXRlKHRhcmdldCwgbmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhbHVlICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHZhbHVlICYmXG4gICAgICAgIFwic3ltYm9sXCIgIT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICB0YXJnZXQucHVzaChcbiAgICAgICAgICBhdHRyaWJ1dGVTZXBhcmF0b3IsXG4gICAgICAgICAgc3RyaW5nVG9DaHVuayhuYW1lKSxcbiAgICAgICAgICBhdHRyaWJ1dGVFbXB0eVN0cmluZ1xuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoU3RyaW5nQXR0cmlidXRlKHRhcmdldCwgbmFtZSwgdmFsdWUpIHtcbiAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHZhbHVlICYmXG4gICAgICAgIFwic3ltYm9sXCIgIT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICBcImJvb2xlYW5cIiAhPT0gdHlwZW9mIHZhbHVlICYmXG4gICAgICAgIHRhcmdldC5wdXNoKFxuICAgICAgICAgIGF0dHJpYnV0ZVNlcGFyYXRvcixcbiAgICAgICAgICBzdHJpbmdUb0NodW5rKG5hbWUpLFxuICAgICAgICAgIGF0dHJpYnV0ZUFzc2lnbixcbiAgICAgICAgICBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKHZhbHVlKSksXG4gICAgICAgICAgYXR0cmlidXRlRW5kXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hBZGRpdGlvbmFsRm9ybUZpZWxkKHZhbHVlLCBrZXkpIHtcbiAgICAgIHRoaXMucHVzaChzdGFydEhpZGRlbklucHV0Q2h1bmspO1xuICAgICAgdmFsaWRhdGVBZGRpdGlvbmFsRm9ybUZpZWxkKHZhbHVlKTtcbiAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGhpcywgXCJuYW1lXCIsIGtleSk7XG4gICAgICBwdXNoU3RyaW5nQXR0cmlidXRlKHRoaXMsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgdGhpcy5wdXNoKGVuZE9mU3RhcnRUYWdTZWxmQ2xvc2luZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlQWRkaXRpb25hbEZvcm1GaWVsZCh2YWx1ZSkge1xuICAgICAgaWYgKFwic3RyaW5nXCIgIT09IHR5cGVvZiB2YWx1ZSlcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJGaWxlL0Jsb2IgZmllbGRzIGFyZSBub3QgeWV0IHN1cHBvcnRlZCBpbiBwcm9ncmVzc2l2ZSBmb3Jtcy4gV2lsbCBmYWxsYmFjayB0byBjbGllbnQgaHlkcmF0aW9uLlwiXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEN1c3RvbUZvcm1GaWVsZHMocmVzdW1hYmxlU3RhdGUsIGZvcm1BY3Rpb24pIHtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBmb3JtQWN0aW9uLiQkRk9STV9BQ1RJT04pIHtcbiAgICAgICAgdmFyIGlkID0gcmVzdW1hYmxlU3RhdGUubmV4dEZvcm1JRCsrO1xuICAgICAgICByZXN1bWFibGVTdGF0ZSA9IHJlc3VtYWJsZVN0YXRlLmlkUHJlZml4ICsgaWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGN1c3RvbUZpZWxkcyA9IGZvcm1BY3Rpb24uJCRGT1JNX0FDVElPTihyZXN1bWFibGVTdGF0ZSk7XG4gICAgICAgICAgaWYgKGN1c3RvbUZpZWxkcykge1xuICAgICAgICAgICAgdmFyIGZvcm1EYXRhID0gY3VzdG9tRmllbGRzLmRhdGE7XG4gICAgICAgICAgICBudWxsICE9IGZvcm1EYXRhICYmIGZvcm1EYXRhLmZvckVhY2godmFsaWRhdGVBZGRpdGlvbmFsRm9ybUZpZWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGN1c3RvbUZpZWxkcztcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiB4ICYmXG4gICAgICAgICAgICBudWxsICE9PSB4ICYmXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB4LnRoZW5cbiAgICAgICAgICApXG4gICAgICAgICAgICB0aHJvdyB4O1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkZhaWxlZCB0byBzZXJpYWxpemUgYW4gYWN0aW9uIGZvciBwcm9ncmVzc2l2ZSBlbmhhbmNlbWVudDpcXG4lc1wiLFxuICAgICAgICAgICAgeFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoRm9ybUFjdGlvbkF0dHJpYnV0ZShcbiAgICAgIHRhcmdldCxcbiAgICAgIHJlc3VtYWJsZVN0YXRlLFxuICAgICAgcmVuZGVyU3RhdGUsXG4gICAgICBmb3JtQWN0aW9uLFxuICAgICAgZm9ybUVuY1R5cGUsXG4gICAgICBmb3JtTWV0aG9kLFxuICAgICAgZm9ybVRhcmdldCxcbiAgICAgIG5hbWVcbiAgICApIHtcbiAgICAgIHZhciBmb3JtRGF0YSA9IG51bGw7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZm9ybUFjdGlvbikge1xuICAgICAgICBudWxsID09PSBuYW1lIHx8XG4gICAgICAgICAgZGlkV2FybkZvcm1BY3Rpb25OYW1lIHx8XG4gICAgICAgICAgKChkaWRXYXJuRm9ybUFjdGlvbk5hbWUgPSAhMCksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICdDYW5ub3Qgc3BlY2lmeSBhIFwibmFtZVwiIHByb3AgZm9yIGEgYnV0dG9uIHRoYXQgc3BlY2lmaWVzIGEgZnVuY3Rpb24gYXMgYSBmb3JtQWN0aW9uLiBSZWFjdCBuZWVkcyBpdCB0byBlbmNvZGUgd2hpY2ggYWN0aW9uIHNob3VsZCBiZSBpbnZva2VkLiBJdCB3aWxsIGdldCBvdmVycmlkZGVuLidcbiAgICAgICAgICApKTtcbiAgICAgICAgKG51bGwgPT09IGZvcm1FbmNUeXBlICYmIG51bGwgPT09IGZvcm1NZXRob2QpIHx8XG4gICAgICAgICAgZGlkV2FybkZvcm1BY3Rpb25NZXRob2QgfHxcbiAgICAgICAgICAoKGRpZFdhcm5Gb3JtQWN0aW9uTWV0aG9kID0gITApLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkNhbm5vdCBzcGVjaWZ5IGEgZm9ybUVuY1R5cGUgb3IgZm9ybU1ldGhvZCBmb3IgYSBidXR0b24gdGhhdCBzcGVjaWZpZXMgYSBmdW5jdGlvbiBhcyBhIGZvcm1BY3Rpb24uIFJlYWN0IHByb3ZpZGVzIHRob3NlIGF1dG9tYXRpY2FsbHkuIFRoZXkgd2lsbCBnZXQgb3ZlcnJpZGRlbi5cIlxuICAgICAgICAgICkpO1xuICAgICAgICBudWxsID09PSBmb3JtVGFyZ2V0IHx8XG4gICAgICAgICAgZGlkV2FybkZvcm1BY3Rpb25UYXJnZXQgfHxcbiAgICAgICAgICAoKGRpZFdhcm5Gb3JtQWN0aW9uVGFyZ2V0ID0gITApLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkNhbm5vdCBzcGVjaWZ5IGEgZm9ybVRhcmdldCBmb3IgYSBidXR0b24gdGhhdCBzcGVjaWZpZXMgYSBmdW5jdGlvbiBhcyBhIGZvcm1BY3Rpb24uIFRoZSBmdW5jdGlvbiB3aWxsIGFsd2F5cyBiZSBleGVjdXRlZCBpbiB0aGUgc2FtZSB3aW5kb3cuXCJcbiAgICAgICAgICApKTtcbiAgICAgICAgdmFyIGN1c3RvbUZpZWxkcyA9IGdldEN1c3RvbUZvcm1GaWVsZHMocmVzdW1hYmxlU3RhdGUsIGZvcm1BY3Rpb24pO1xuICAgICAgICBudWxsICE9PSBjdXN0b21GaWVsZHNcbiAgICAgICAgICA/ICgobmFtZSA9IGN1c3RvbUZpZWxkcy5uYW1lKSxcbiAgICAgICAgICAgIChmb3JtQWN0aW9uID0gY3VzdG9tRmllbGRzLmFjdGlvbiB8fCBcIlwiKSxcbiAgICAgICAgICAgIChmb3JtRW5jVHlwZSA9IGN1c3RvbUZpZWxkcy5lbmNUeXBlKSxcbiAgICAgICAgICAgIChmb3JtTWV0aG9kID0gY3VzdG9tRmllbGRzLm1ldGhvZCksXG4gICAgICAgICAgICAoZm9ybVRhcmdldCA9IGN1c3RvbUZpZWxkcy50YXJnZXQpLFxuICAgICAgICAgICAgKGZvcm1EYXRhID0gY3VzdG9tRmllbGRzLmRhdGEpKVxuICAgICAgICAgIDogKHRhcmdldC5wdXNoKFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVTZXBhcmF0b3IsXG4gICAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsoXCJmb3JtQWN0aW9uXCIpLFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVBc3NpZ24sXG4gICAgICAgICAgICAgIGFjdGlvbkphdmFTY3JpcHRVUkwsXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZUVuZFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIChmb3JtVGFyZ2V0ID0gZm9ybU1ldGhvZCA9IGZvcm1FbmNUeXBlID0gZm9ybUFjdGlvbiA9IG5hbWUgPSBudWxsKSxcbiAgICAgICAgICAgIGluamVjdEZvcm1SZXBsYXlpbmdSdW50aW1lKHJlc3VtYWJsZVN0YXRlLCByZW5kZXJTdGF0ZSkpO1xuICAgICAgfVxuICAgICAgbnVsbCAhPSBuYW1lICYmIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgICBudWxsICE9IGZvcm1BY3Rpb24gJiYgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIFwiZm9ybUFjdGlvblwiLCBmb3JtQWN0aW9uKTtcbiAgICAgIG51bGwgIT0gZm9ybUVuY1R5cGUgJiYgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIFwiZm9ybUVuY1R5cGVcIiwgZm9ybUVuY1R5cGUpO1xuICAgICAgbnVsbCAhPSBmb3JtTWV0aG9kICYmIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBcImZvcm1NZXRob2RcIiwgZm9ybU1ldGhvZCk7XG4gICAgICBudWxsICE9IGZvcm1UYXJnZXQgJiYgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIFwiZm9ybVRhcmdldFwiLCBmb3JtVGFyZ2V0KTtcbiAgICAgIHJldHVybiBmb3JtRGF0YTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIG5hbWUsIHZhbHVlKSB7XG4gICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgY2FzZSBcImNsYXNzTmFtZVwiOlxuICAgICAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCBcImNsYXNzXCIsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInRhYkluZGV4XCI6XG4gICAgICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsIFwidGFiaW5kZXhcIiwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZGlyXCI6XG4gICAgICAgIGNhc2UgXCJyb2xlXCI6XG4gICAgICAgIGNhc2UgXCJ2aWV3Qm94XCI6XG4gICAgICAgIGNhc2UgXCJ3aWR0aFwiOlxuICAgICAgICBjYXNlIFwiaGVpZ2h0XCI6XG4gICAgICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInN0eWxlXCI6XG4gICAgICAgICAgcHVzaFN0eWxlQXR0cmlidXRlKHRhcmdldCwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic3JjXCI6XG4gICAgICAgIGNhc2UgXCJocmVmXCI6XG4gICAgICAgICAgaWYgKFwiXCIgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICBcInNyY1wiID09PSBuYW1lXG4gICAgICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICdBbiBlbXB0eSBzdHJpbmcgKFwiXCIpIHdhcyBwYXNzZWQgdG8gdGhlICVzIGF0dHJpYnV0ZS4gVGhpcyBtYXkgY2F1c2UgdGhlIGJyb3dzZXIgdG8gZG93bmxvYWQgdGhlIHdob2xlIHBhZ2UgYWdhaW4gb3ZlciB0aGUgbmV0d29yay4gVG8gZml4IHRoaXMsIGVpdGhlciBkbyBub3QgcmVuZGVyIHRoZSBlbGVtZW50IGF0IGFsbCBvciBwYXNzIG51bGwgdG8gJXMgaW5zdGVhZCBvZiBhbiBlbXB0eSBzdHJpbmcuJyxcbiAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAnQW4gZW1wdHkgc3RyaW5nIChcIlwiKSB3YXMgcGFzc2VkIHRvIHRoZSAlcyBhdHRyaWJ1dGUuIFRvIGZpeCB0aGlzLCBlaXRoZXIgZG8gbm90IHJlbmRlciB0aGUgZWxlbWVudCBhdCBhbGwgb3IgcGFzcyBudWxsIHRvICVzIGluc3RlYWQgb2YgYW4gZW1wdHkgc3RyaW5nLicsXG4gICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJhY3Rpb25cIjpcbiAgICAgICAgY2FzZSBcImZvcm1BY3Rpb25cIjpcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBudWxsID09IHZhbHVlIHx8XG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB2YWx1ZSB8fFxuICAgICAgICAgICAgXCJzeW1ib2xcIiA9PT0gdHlwZW9mIHZhbHVlIHx8XG4gICAgICAgICAgICBcImJvb2xlYW5cIiA9PT0gdHlwZW9mIHZhbHVlXG4gICAgICAgICAgKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgbmFtZSk7XG4gICAgICAgICAgdmFsdWUgPSBzYW5pdGl6ZVVSTChcIlwiICsgdmFsdWUpO1xuICAgICAgICAgIHRhcmdldC5wdXNoKFxuICAgICAgICAgICAgYXR0cmlidXRlU2VwYXJhdG9yLFxuICAgICAgICAgICAgc3RyaW5nVG9DaHVuayhuYW1lKSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZUFzc2lnbixcbiAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIodmFsdWUpKSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZUVuZFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkZWZhdWx0VmFsdWVcIjpcbiAgICAgICAgY2FzZSBcImRlZmF1bHRDaGVja2VkXCI6XG4gICAgICAgIGNhc2UgXCJpbm5lckhUTUxcIjpcbiAgICAgICAgY2FzZSBcInN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZ1wiOlxuICAgICAgICBjYXNlIFwic3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nXCI6XG4gICAgICAgIGNhc2UgXCJyZWZcIjpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImF1dG9Gb2N1c1wiOlxuICAgICAgICBjYXNlIFwibXVsdGlwbGVcIjpcbiAgICAgICAgY2FzZSBcIm11dGVkXCI6XG4gICAgICAgICAgcHVzaEJvb2xlYW5BdHRyaWJ1dGUodGFyZ2V0LCBuYW1lLnRvTG93ZXJDYXNlKCksIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInhsaW5rSHJlZlwiOlxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHZhbHVlIHx8XG4gICAgICAgICAgICBcInN5bWJvbFwiID09PSB0eXBlb2YgdmFsdWUgfHxcbiAgICAgICAgICAgIFwiYm9vbGVhblwiID09PSB0eXBlb2YgdmFsdWVcbiAgICAgICAgICApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBuYW1lKTtcbiAgICAgICAgICB2YWx1ZSA9IHNhbml0aXplVVJMKFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgdGFyZ2V0LnB1c2goXG4gICAgICAgICAgICBhdHRyaWJ1dGVTZXBhcmF0b3IsXG4gICAgICAgICAgICBzdHJpbmdUb0NodW5rKFwieGxpbms6aHJlZlwiKSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZUFzc2lnbixcbiAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIodmFsdWUpKSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZUVuZFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJjb250ZW50RWRpdGFibGVcIjpcbiAgICAgICAgY2FzZSBcInNwZWxsQ2hlY2tcIjpcbiAgICAgICAgY2FzZSBcImRyYWdnYWJsZVwiOlxuICAgICAgICBjYXNlIFwidmFsdWVcIjpcbiAgICAgICAgY2FzZSBcImF1dG9SZXZlcnNlXCI6XG4gICAgICAgIGNhc2UgXCJleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkXCI6XG4gICAgICAgIGNhc2UgXCJmb2N1c2FibGVcIjpcbiAgICAgICAgY2FzZSBcInByZXNlcnZlQWxwaGFcIjpcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICAgICAgXCJzeW1ib2xcIiAhPT0gdHlwZW9mIHZhbHVlICYmXG4gICAgICAgICAgICB0YXJnZXQucHVzaChcbiAgICAgICAgICAgICAgYXR0cmlidXRlU2VwYXJhdG9yLFxuICAgICAgICAgICAgICBzdHJpbmdUb0NodW5rKG5hbWUpLFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVBc3NpZ24sXG4gICAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIodmFsdWUpKSxcbiAgICAgICAgICAgICAgYXR0cmlidXRlRW5kXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiaW5lcnRcIjpcbiAgICAgICAgICBcIlwiICE9PSB2YWx1ZSB8fFxuICAgICAgICAgICAgZGlkV2FybkZvck5ld0Jvb2xlYW5Qcm9wc1dpdGhFbXB0eVZhbHVlW25hbWVdIHx8XG4gICAgICAgICAgICAoKGRpZFdhcm5Gb3JOZXdCb29sZWFuUHJvcHNXaXRoRW1wdHlWYWx1ZVtuYW1lXSA9ICEwKSxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVjZWl2ZWQgYW4gZW1wdHkgc3RyaW5nIGZvciBhIGJvb2xlYW4gYXR0cmlidXRlIGAlc2AuIFRoaXMgd2lsbCB0cmVhdCB0aGUgYXR0cmlidXRlIGFzIGlmIGl0IHdlcmUgZmFsc2UuIEVpdGhlciBwYXNzIGBmYWxzZWAgdG8gc2lsZW5jZSB0aGlzIHdhcm5pbmcsIG9yIHBhc3MgYHRydWVgIGlmIHlvdSB1c2VkIGFuIGVtcHR5IHN0cmluZyBpbiBlYXJsaWVyIHZlcnNpb25zIG9mIFJlYWN0IHRvIGluZGljYXRlIHRoaXMgYXR0cmlidXRlIGlzIHRydWUuXCIsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICkpO1xuICAgICAgICBjYXNlIFwiYWxsb3dGdWxsU2NyZWVuXCI6XG4gICAgICAgIGNhc2UgXCJhc3luY1wiOlxuICAgICAgICBjYXNlIFwiYXV0b1BsYXlcIjpcbiAgICAgICAgY2FzZSBcImNvbnRyb2xzXCI6XG4gICAgICAgIGNhc2UgXCJkZWZhdWx0XCI6XG4gICAgICAgIGNhc2UgXCJkZWZlclwiOlxuICAgICAgICBjYXNlIFwiZGlzYWJsZWRcIjpcbiAgICAgICAgY2FzZSBcImRpc2FibGVQaWN0dXJlSW5QaWN0dXJlXCI6XG4gICAgICAgIGNhc2UgXCJkaXNhYmxlUmVtb3RlUGxheWJhY2tcIjpcbiAgICAgICAgY2FzZSBcImZvcm1Ob1ZhbGlkYXRlXCI6XG4gICAgICAgIGNhc2UgXCJoaWRkZW5cIjpcbiAgICAgICAgY2FzZSBcImxvb3BcIjpcbiAgICAgICAgY2FzZSBcIm5vTW9kdWxlXCI6XG4gICAgICAgIGNhc2UgXCJub1ZhbGlkYXRlXCI6XG4gICAgICAgIGNhc2UgXCJvcGVuXCI6XG4gICAgICAgIGNhc2UgXCJwbGF5c0lubGluZVwiOlxuICAgICAgICBjYXNlIFwicmVhZE9ubHlcIjpcbiAgICAgICAgY2FzZSBcInJlcXVpcmVkXCI6XG4gICAgICAgIGNhc2UgXCJyZXZlcnNlZFwiOlxuICAgICAgICBjYXNlIFwic2NvcGVkXCI6XG4gICAgICAgIGNhc2UgXCJzZWFtbGVzc1wiOlxuICAgICAgICBjYXNlIFwiaXRlbVNjb3BlXCI6XG4gICAgICAgICAgdmFsdWUgJiZcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHZhbHVlICYmXG4gICAgICAgICAgICBcInN5bWJvbFwiICE9PSB0eXBlb2YgdmFsdWUgJiZcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVTZXBhcmF0b3IsXG4gICAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsobmFtZSksXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZUVtcHR5U3RyaW5nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiY2FwdHVyZVwiOlxuICAgICAgICBjYXNlIFwiZG93bmxvYWRcIjpcbiAgICAgICAgICAhMCA9PT0gdmFsdWVcbiAgICAgICAgICAgID8gdGFyZ2V0LnB1c2goXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlU2VwYXJhdG9yLFxuICAgICAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsobmFtZSksXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlRW1wdHlTdHJpbmdcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgOiAhMSAhPT0gdmFsdWUgJiZcbiAgICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgdmFsdWUgJiZcbiAgICAgICAgICAgICAgXCJzeW1ib2xcIiAhPT0gdHlwZW9mIHZhbHVlICYmXG4gICAgICAgICAgICAgIHRhcmdldC5wdXNoKFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZVNlcGFyYXRvcixcbiAgICAgICAgICAgICAgICBzdHJpbmdUb0NodW5rKG5hbWUpLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUFzc2lnbixcbiAgICAgICAgICAgICAgICBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKHZhbHVlKSksXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlRW5kXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJjb2xzXCI6XG4gICAgICAgIGNhc2UgXCJyb3dzXCI6XG4gICAgICAgIGNhc2UgXCJzaXplXCI6XG4gICAgICAgIGNhc2UgXCJzcGFuXCI6XG4gICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgdmFsdWUgJiZcbiAgICAgICAgICAgIFwic3ltYm9sXCIgIT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICAgICAgIWlzTmFOKHZhbHVlKSAmJlxuICAgICAgICAgICAgMSA8PSB2YWx1ZSAmJlxuICAgICAgICAgICAgdGFyZ2V0LnB1c2goXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZVNlcGFyYXRvcixcbiAgICAgICAgICAgICAgc3RyaW5nVG9DaHVuayhuYW1lKSxcbiAgICAgICAgICAgICAgYXR0cmlidXRlQXNzaWduLFxuICAgICAgICAgICAgICBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKHZhbHVlKSksXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZUVuZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInJvd1NwYW5cIjpcbiAgICAgICAgY2FzZSBcInN0YXJ0XCI6XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdmFsdWUgfHxcbiAgICAgICAgICAgIFwic3ltYm9sXCIgPT09IHR5cGVvZiB2YWx1ZSB8fFxuICAgICAgICAgICAgaXNOYU4odmFsdWUpIHx8XG4gICAgICAgICAgICB0YXJnZXQucHVzaChcbiAgICAgICAgICAgICAgYXR0cmlidXRlU2VwYXJhdG9yLFxuICAgICAgICAgICAgICBzdHJpbmdUb0NodW5rKG5hbWUpLFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVBc3NpZ24sXG4gICAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIodmFsdWUpKSxcbiAgICAgICAgICAgICAgYXR0cmlidXRlRW5kXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwieGxpbmtBY3R1YXRlXCI6XG4gICAgICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsIFwieGxpbms6YWN0dWF0ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ4bGlua0FyY3JvbGVcIjpcbiAgICAgICAgICBwdXNoU3RyaW5nQXR0cmlidXRlKHRhcmdldCwgXCJ4bGluazphcmNyb2xlXCIsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInhsaW5rUm9sZVwiOlxuICAgICAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCBcInhsaW5rOnJvbGVcIiwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwieGxpbmtTaG93XCI6XG4gICAgICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsIFwieGxpbms6c2hvd1wiLCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ4bGlua1RpdGxlXCI6XG4gICAgICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsIFwieGxpbms6dGl0bGVcIiwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwieGxpbmtUeXBlXCI6XG4gICAgICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsIFwieGxpbms6dHlwZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ4bWxCYXNlXCI6XG4gICAgICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsIFwieG1sOmJhc2VcIiwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwieG1sTGFuZ1wiOlxuICAgICAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCBcInhtbDpsYW5nXCIsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInhtbFNwYWNlXCI6XG4gICAgICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsIFwieG1sOnNwYWNlXCIsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhKDIgPCBuYW1lLmxlbmd0aCkgfHxcbiAgICAgICAgICAgIChcIm9cIiAhPT0gbmFtZVswXSAmJiBcIk9cIiAhPT0gbmFtZVswXSkgfHxcbiAgICAgICAgICAgIChcIm5cIiAhPT0gbmFtZVsxXSAmJiBcIk5cIiAhPT0gbmFtZVsxXSlcbiAgICAgICAgICApXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICgobmFtZSA9IGFsaWFzZXMuZ2V0KG5hbWUpIHx8IG5hbWUpLCBpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICAgICAgICB2YXIgcHJlZml4ID0gbmFtZS50b0xvd2VyQ2FzZSgpLnNsaWNlKDAsIDUpO1xuICAgICAgICAgICAgICAgICAgaWYgKFwiZGF0YS1cIiAhPT0gcHJlZml4ICYmIFwiYXJpYS1cIiAhPT0gcHJlZml4KSByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGFyZ2V0LnB1c2goXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlU2VwYXJhdG9yLFxuICAgICAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsobmFtZSksXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlQXNzaWduLFxuICAgICAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIodmFsdWUpKSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVFbmRcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaElubmVySFRNTCh0YXJnZXQsIGlubmVySFRNTCwgY2hpbGRyZW4pIHtcbiAgICAgIGlmIChudWxsICE9IGlubmVySFRNTCkge1xuICAgICAgICBpZiAobnVsbCAhPSBjaGlsZHJlbilcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiQ2FuIG9ubHkgc2V0IG9uZSBvZiBgY2hpbGRyZW5gIG9yIGBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAuXCJcbiAgICAgICAgICApO1xuICAgICAgICBpZiAoXCJvYmplY3RcIiAhPT0gdHlwZW9mIGlubmVySFRNTCB8fCAhKFwiX19odG1sXCIgaW4gaW5uZXJIVE1MKSlcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBtdXN0IGJlIGluIHRoZSBmb3JtIGB7X19odG1sOiAuLi59YC4gUGxlYXNlIHZpc2l0IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvZGFuZ2Vyb3VzbHktc2V0LWlubmVyLWh0bWwgZm9yIG1vcmUgaW5mb3JtYXRpb24uXCJcbiAgICAgICAgICApO1xuICAgICAgICBpbm5lckhUTUwgPSBpbm5lckhUTUwuX19odG1sO1xuICAgICAgICBudWxsICE9PSBpbm5lckhUTUwgJiZcbiAgICAgICAgICB2b2lkIDAgIT09IGlubmVySFRNTCAmJlxuICAgICAgICAgIChjaGVja0h0bWxTdHJpbmdDb2VyY2lvbihpbm5lckhUTUwpLFxuICAgICAgICAgIHRhcmdldC5wdXNoKHN0cmluZ1RvQ2h1bmsoXCJcIiArIGlubmVySFRNTCkpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tTZWxlY3RQcm9wKHByb3BzLCBwcm9wTmFtZSkge1xuICAgICAgdmFyIHZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgbnVsbCAhPSB2YWx1ZSAmJlxuICAgICAgICAoKHZhbHVlID0gaXNBcnJheUltcGwodmFsdWUpKSxcbiAgICAgICAgcHJvcHMubXVsdGlwbGUgJiYgIXZhbHVlXG4gICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlRoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhbiBhcnJheSBpZiBgbXVsdGlwbGVgIGlzIHRydWUuXCIsXG4gICAgICAgICAgICAgIHByb3BOYW1lXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiAhcHJvcHMubXVsdGlwbGUgJiZcbiAgICAgICAgICAgIHZhbHVlICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlRoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhIHNjYWxhciB2YWx1ZSBpZiBgbXVsdGlwbGVgIGlzIGZhbHNlLlwiLFxuICAgICAgICAgICAgICBwcm9wTmFtZVxuICAgICAgICAgICAgKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsYXR0ZW5PcHRpb25DaGlsZHJlbihjaGlsZHJlbikge1xuICAgICAgdmFyIGNvbnRlbnQgPSBcIlwiO1xuICAgICAgUmVhY3QuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIG51bGwgIT0gY2hpbGQgJiZcbiAgICAgICAgICAoKGNvbnRlbnQgKz0gY2hpbGQpLFxuICAgICAgICAgIGRpZFdhcm5JbnZhbGlkT3B0aW9uQ2hpbGRyZW4gfHxcbiAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBjaGlsZCB8fFxuICAgICAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIGNoaWxkIHx8XG4gICAgICAgICAgICBcImJpZ2ludFwiID09PSB0eXBlb2YgY2hpbGQgfHxcbiAgICAgICAgICAgICgoZGlkV2FybkludmFsaWRPcHRpb25DaGlsZHJlbiA9ICEwKSxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiQ2Fubm90IGluZmVyIHRoZSBvcHRpb24gdmFsdWUgb2YgY29tcGxleCBjaGlsZHJlbi4gUGFzcyBhIGB2YWx1ZWAgcHJvcCBvciB1c2UgYSBwbGFpbiBzdHJpbmcgYXMgY2hpbGRyZW4gdG8gPG9wdGlvbj4uXCJcbiAgICAgICAgICAgICkpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGluamVjdEZvcm1SZXBsYXlpbmdSdW50aW1lKHJlc3VtYWJsZVN0YXRlLCByZW5kZXJTdGF0ZSkge1xuICAgICAgKHJlc3VtYWJsZVN0YXRlLmluc3RydWN0aW9ucyAmIDE2KSA9PT0gTm90aGluZ1NlbnQgJiZcbiAgICAgICAgKChyZXN1bWFibGVTdGF0ZS5pbnN0cnVjdGlvbnMgfD0gMTYpLFxuICAgICAgICByZW5kZXJTdGF0ZS5ib290c3RyYXBDaHVua3MudW5zaGlmdChcbiAgICAgICAgICByZW5kZXJTdGF0ZS5zdGFydElubGluZVNjcmlwdCxcbiAgICAgICAgICBmb3JtUmVwbGF5aW5nUnVudGltZVNjcmlwdCxcbiAgICAgICAgICBlbmRJbmxpbmVTY3JpcHRcbiAgICAgICAgKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hMaW5rSW1wbCh0YXJnZXQsIHByb3BzKSB7XG4gICAgICB0YXJnZXQucHVzaChzdGFydENodW5rRm9yVGFnKFwibGlua1wiKSk7XG4gICAgICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKVxuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG4gICAgICAgICAgaWYgKG51bGwgIT0gcHJvcFZhbHVlKVxuICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgIFwibGluayBpcyBhIHNlbGYtY2xvc2luZyB0YWcgYW5kIG11c3QgbmVpdGhlciBoYXZlIGBjaGlsZHJlbmAgbm9yIHVzZSBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLlwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZ1NlbGZDbG9zaW5nKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlc2NhcGVTdHlsZVRleHRDb250ZW50KHN0eWxlVGV4dCkge1xuICAgICAgY2hlY2tIdG1sU3RyaW5nQ29lcmNpb24oc3R5bGVUZXh0KTtcbiAgICAgIHJldHVybiAoXCJcIiArIHN0eWxlVGV4dCkucmVwbGFjZShzdHlsZVJlZ2V4LCBzdHlsZVJlcGxhY2VyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaFNlbGZDbG9zaW5nKHRhcmdldCwgcHJvcHMsIHRhZykge1xuICAgICAgdGFyZ2V0LnB1c2goc3RhcnRDaHVua0ZvclRhZyh0YWcpKTtcbiAgICAgIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpXG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcbiAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wVmFsdWUpXG4gICAgICAgICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgdGFnICtcbiAgICAgICAgICAgICAgICAgICAgXCIgaXMgYSBzZWxmLWNsb3NpbmcgdGFnIGFuZCBtdXN0IG5laXRoZXIgaGF2ZSBgY2hpbGRyZW5gIG5vciB1c2UgYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC5cIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIHRhcmdldC5wdXNoKGVuZE9mU3RhcnRUYWdTZWxmQ2xvc2luZyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaFRpdGxlSW1wbCh0YXJnZXQsIHByb3BzKSB7XG4gICAgICB0YXJnZXQucHVzaChzdGFydENodW5rRm9yVGFnKFwidGl0bGVcIikpO1xuICAgICAgdmFyIGNoaWxkcmVuID0gbnVsbCxcbiAgICAgICAgaW5uZXJIVE1MID0gbnVsbCxcbiAgICAgICAgcHJvcEtleTtcbiAgICAgIGZvciAocHJvcEtleSBpbiBwcm9wcylcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuICAgICAgICAgIGlmIChudWxsICE9IHByb3BWYWx1ZSlcbiAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICBjaGlsZHJlbiA9IHByb3BWYWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgaW5uZXJIVE1MID0gcHJvcFZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB0YXJnZXQucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgICAgIHByb3BzID0gQXJyYXkuaXNBcnJheShjaGlsZHJlbilcbiAgICAgICAgPyAyID4gY2hpbGRyZW4ubGVuZ3RoXG4gICAgICAgICAgPyBjaGlsZHJlblswXVxuICAgICAgICAgIDogbnVsbFxuICAgICAgICA6IGNoaWxkcmVuO1xuICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgcHJvcHMgJiZcbiAgICAgICAgXCJzeW1ib2xcIiAhPT0gdHlwZW9mIHByb3BzICYmXG4gICAgICAgIG51bGwgIT09IHByb3BzICYmXG4gICAgICAgIHZvaWQgMCAhPT0gcHJvcHMgJiZcbiAgICAgICAgdGFyZ2V0LnB1c2goc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihcIlwiICsgcHJvcHMpKSk7XG4gICAgICBwdXNoSW5uZXJIVE1MKHRhcmdldCwgaW5uZXJIVE1MLCBjaGlsZHJlbik7XG4gICAgICB0YXJnZXQucHVzaChlbmRDaHVua0ZvclRhZyhcInRpdGxlXCIpKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoU2NyaXB0SW1wbCh0YXJnZXQsIHByb3BzKSB7XG4gICAgICB0YXJnZXQucHVzaChzdGFydENodW5rRm9yVGFnKFwic2NyaXB0XCIpKTtcbiAgICAgIHZhciBjaGlsZHJlbiA9IG51bGwsXG4gICAgICAgIGlubmVySFRNTCA9IG51bGwsXG4gICAgICAgIHByb3BLZXk7XG4gICAgICBmb3IgKHByb3BLZXkgaW4gcHJvcHMpXG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcbiAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wVmFsdWUpXG4gICAgICAgICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgIGlubmVySFRNTCA9IHByb3BWYWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gICAgICBudWxsICE9IGNoaWxkcmVuICYmXG4gICAgICAgIFwic3RyaW5nXCIgIT09IHR5cGVvZiBjaGlsZHJlbiAmJlxuICAgICAgICAoKHByb3BzID1cbiAgICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgY2hpbGRyZW5cbiAgICAgICAgICAgID8gXCJhIG51bWJlciBmb3IgY2hpbGRyZW5cIlxuICAgICAgICAgICAgOiBBcnJheS5pc0FycmF5KGNoaWxkcmVuKVxuICAgICAgICAgICAgICA/IFwiYW4gYXJyYXkgZm9yIGNoaWxkcmVuXCJcbiAgICAgICAgICAgICAgOiBcInNvbWV0aGluZyB1bmV4cGVjdGVkIGZvciBjaGlsZHJlblwiKSxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkEgc2NyaXB0IGVsZW1lbnQgd2FzIHJlbmRlcmVkIHdpdGggJXMuIElmIHNjcmlwdCBlbGVtZW50IGhhcyBjaGlsZHJlbiBpdCBtdXN0IGJlIGEgc2luZ2xlIHN0cmluZy4gQ29uc2lkZXIgdXNpbmcgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgb3IgcGFzc2luZyBhIHBsYWluIHN0cmluZyBhcyBjaGlsZHJlbi5cIixcbiAgICAgICAgICBwcm9wc1xuICAgICAgICApKTtcbiAgICAgIHB1c2hJbm5lckhUTUwodGFyZ2V0LCBpbm5lckhUTUwsIGNoaWxkcmVuKTtcbiAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBjaGlsZHJlbiAmJlxuICAgICAgICB0YXJnZXQucHVzaChzdHJpbmdUb0NodW5rKGVzY2FwZUVudGlyZUlubGluZVNjcmlwdENvbnRlbnQoY2hpbGRyZW4pKSk7XG4gICAgICB0YXJnZXQucHVzaChlbmRDaHVua0ZvclRhZyhcInNjcmlwdFwiKSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaFN0YXJ0R2VuZXJpY0VsZW1lbnQodGFyZ2V0LCBwcm9wcywgdGFnKSB7XG4gICAgICB0YXJnZXQucHVzaChzdGFydENodW5rRm9yVGFnKHRhZykpO1xuICAgICAgdmFyIGlubmVySFRNTCA9ICh0YWcgPSBudWxsKSxcbiAgICAgICAgcHJvcEtleTtcbiAgICAgIGZvciAocHJvcEtleSBpbiBwcm9wcylcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuICAgICAgICAgIGlmIChudWxsICE9IHByb3BWYWx1ZSlcbiAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICB0YWcgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgIGlubmVySFRNTCA9IHByb3BWYWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gICAgICBwdXNoSW5uZXJIVE1MKHRhcmdldCwgaW5uZXJIVE1MLCB0YWcpO1xuICAgICAgcmV0dXJuIFwic3RyaW5nXCIgPT09IHR5cGVvZiB0YWdcbiAgICAgICAgPyAodGFyZ2V0LnB1c2goc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3Nlcih0YWcpKSksIG51bGwpXG4gICAgICAgIDogdGFnO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdGFydENodW5rRm9yVGFnKHRhZykge1xuICAgICAgdmFyIHRhZ1N0YXJ0Q2h1bmsgPSB2YWxpZGF0ZWRUYWdDYWNoZS5nZXQodGFnKTtcbiAgICAgIGlmICh2b2lkIDAgPT09IHRhZ1N0YXJ0Q2h1bmspIHtcbiAgICAgICAgaWYgKCFWQUxJRF9UQUdfUkVHRVgudGVzdCh0YWcpKSB0aHJvdyBFcnJvcihcIkludmFsaWQgdGFnOiBcIiArIHRhZyk7XG4gICAgICAgIHRhZ1N0YXJ0Q2h1bmsgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCI8XCIgKyB0YWcpO1xuICAgICAgICB2YWxpZGF0ZWRUYWdDYWNoZS5zZXQodGFnLCB0YWdTdGFydENodW5rKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YWdTdGFydENodW5rO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoU3RhcnRJbnN0YW5jZShcbiAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgIHR5cGUsXG4gICAgICBwcm9wcyxcbiAgICAgIHJlc3VtYWJsZVN0YXRlLFxuICAgICAgcmVuZGVyU3RhdGUsXG4gICAgICBob2lzdGFibGVTdGF0ZSxcbiAgICAgIGZvcm1hdENvbnRleHQsXG4gICAgICB0ZXh0RW1iZWRkZWQsXG4gICAgICBpc0ZhbGxiYWNrXG4gICAgKSB7XG4gICAgICB2YWxpZGF0ZVByb3BlcnRpZXMkMih0eXBlLCBwcm9wcyk7XG4gICAgICAoXCJpbnB1dFwiICE9PSB0eXBlICYmIFwidGV4dGFyZWFcIiAhPT0gdHlwZSAmJiBcInNlbGVjdFwiICE9PSB0eXBlKSB8fFxuICAgICAgICBudWxsID09IHByb3BzIHx8XG4gICAgICAgIG51bGwgIT09IHByb3BzLnZhbHVlIHx8XG4gICAgICAgIGRpZFdhcm5WYWx1ZU51bGwgfHxcbiAgICAgICAgKChkaWRXYXJuVmFsdWVOdWxsID0gITApLFxuICAgICAgICBcInNlbGVjdFwiID09PSB0eXBlICYmIHByb3BzLm11bHRpcGxlXG4gICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcImB2YWx1ZWAgcHJvcCBvbiBgJXNgIHNob3VsZCBub3QgYmUgbnVsbC4gQ29uc2lkZXIgdXNpbmcgYW4gZW1wdHkgYXJyYXkgd2hlbiBgbXVsdGlwbGVgIGlzIHNldCB0byBgdHJ1ZWAgdG8gY2xlYXIgdGhlIGNvbXBvbmVudCBvciBgdW5kZWZpbmVkYCBmb3IgdW5jb250cm9sbGVkIGNvbXBvbmVudHMuXCIsXG4gICAgICAgICAgICAgIHR5cGVcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiYHZhbHVlYCBwcm9wIG9uIGAlc2Agc2hvdWxkIG5vdCBiZSBudWxsLiBDb25zaWRlciB1c2luZyBhbiBlbXB0eSBzdHJpbmcgdG8gY2xlYXIgdGhlIGNvbXBvbmVudCBvciBgdW5kZWZpbmVkYCBmb3IgdW5jb250cm9sbGVkIGNvbXBvbmVudHMuXCIsXG4gICAgICAgICAgICAgIHR5cGVcbiAgICAgICAgICAgICkpO1xuICAgICAgYjogaWYgKC0xID09PSB0eXBlLmluZGV4T2YoXCItXCIpKSB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITE7XG4gICAgICBlbHNlXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJhbm5vdGF0aW9uLXhtbFwiOlxuICAgICAgICAgIGNhc2UgXCJjb2xvci1wcm9maWxlXCI6XG4gICAgICAgICAgY2FzZSBcImZvbnQtZmFjZVwiOlxuICAgICAgICAgIGNhc2UgXCJmb250LWZhY2Utc3JjXCI6XG4gICAgICAgICAgY2FzZSBcImZvbnQtZmFjZS11cmlcIjpcbiAgICAgICAgICBjYXNlIFwiZm9udC1mYWNlLWZvcm1hdFwiOlxuICAgICAgICAgIGNhc2UgXCJmb250LWZhY2UtbmFtZVwiOlxuICAgICAgICAgIGNhc2UgXCJtaXNzaW5nLWdseXBoXCI6XG4gICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMTtcbiAgICAgICAgICAgIGJyZWFrIGI7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICEwO1xuICAgICAgICB9XG4gICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgfHxcbiAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHByb3BzLmlzIHx8XG4gICAgICAgIHdhcm5Vbmtub3duUHJvcGVydGllcyh0eXBlLCBwcm9wcywgbnVsbCk7XG4gICAgICAhcHJvcHMuc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nICYmXG4gICAgICAgIHByb3BzLmNvbnRlbnRFZGl0YWJsZSAmJlxuICAgICAgICBudWxsICE9IHByb3BzLmNoaWxkcmVuICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJBIGNvbXBvbmVudCBpcyBgY29udGVudEVkaXRhYmxlYCBhbmQgY29udGFpbnMgYGNoaWxkcmVuYCBtYW5hZ2VkIGJ5IFJlYWN0LiBJdCBpcyBub3cgeW91ciByZXNwb25zaWJpbGl0eSB0byBndWFyYW50ZWUgdGhhdCBub25lIG9mIHRob3NlIG5vZGVzIGFyZSB1bmV4cGVjdGVkbHkgbW9kaWZpZWQgb3IgZHVwbGljYXRlZC4gVGhpcyBpcyBwcm9iYWJseSBub3QgaW50ZW50aW9uYWwuXCJcbiAgICAgICAgKTtcbiAgICAgIGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSAhPT0gU1ZHX01PREUgJiZcbiAgICAgICAgZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlICE9PSBNQVRITUxfTU9ERSAmJlxuICAgICAgICAtMSA9PT0gdHlwZS5pbmRleE9mKFwiLVwiKSAmJlxuICAgICAgICB0eXBlLnRvTG93ZXJDYXNlKCkgIT09IHR5cGUgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIjwlcyAvPiBpcyB1c2luZyBpbmNvcnJlY3QgY2FzaW5nLiBVc2UgUGFzY2FsQ2FzZSBmb3IgUmVhY3QgY29tcG9uZW50cywgb3IgbG93ZXJjYXNlIGZvciBIVE1MIGVsZW1lbnRzLlwiLFxuICAgICAgICAgIHR5cGVcbiAgICAgICAgKTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwiZGl2XCI6XG4gICAgICAgIGNhc2UgXCJzcGFuXCI6XG4gICAgICAgIGNhc2UgXCJzdmdcIjpcbiAgICAgICAgY2FzZSBcInBhdGhcIjpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImFcIjpcbiAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChzdGFydENodW5rRm9yVGFnKFwiYVwiKSk7XG4gICAgICAgICAgdmFyIGNoaWxkcmVuID0gbnVsbCxcbiAgICAgICAgICAgIGlubmVySFRNTCA9IG51bGwsXG4gICAgICAgICAgICBwcm9wS2V5O1xuICAgICAgICAgIGZvciAocHJvcEtleSBpbiBwcm9wcylcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG4gICAgICAgICAgICAgIGlmIChudWxsICE9IHByb3BWYWx1ZSlcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbiA9IHByb3BWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJIVE1MID0gcHJvcFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJocmVmXCI6XG4gICAgICAgICAgICAgICAgICAgIFwiXCIgPT09IHByb3BWYWx1ZVxuICAgICAgICAgICAgICAgICAgICAgID8gcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQkanNjb21wJDAsIFwiaHJlZlwiLCBcIlwiKVxuICAgICAgICAgICAgICAgICAgICAgIDogcHVzaEF0dHJpYnV0ZSh0YXJnZXQkanNjb21wJDAsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQkanNjb21wJDAsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKGVuZE9mU3RhcnRUYWcpO1xuICAgICAgICAgIHB1c2hJbm5lckhUTUwodGFyZ2V0JGpzY29tcCQwLCBpbm5lckhUTUwsIGNoaWxkcmVuKTtcbiAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGNoaWxkcmVuKSB7XG4gICAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKGNoaWxkcmVuKSkpO1xuICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMCA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMCA9IGNoaWxkcmVuO1xuICAgICAgICAgIHJldHVybiBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDA7XG4gICAgICAgIGNhc2UgXCJnXCI6XG4gICAgICAgIGNhc2UgXCJwXCI6XG4gICAgICAgIGNhc2UgXCJsaVwiOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic2VsZWN0XCI6XG4gICAgICAgICAgY2hlY2tDb250cm9sbGVkVmFsdWVQcm9wcyhcInNlbGVjdFwiLCBwcm9wcyk7XG4gICAgICAgICAgY2hlY2tTZWxlY3RQcm9wKHByb3BzLCBcInZhbHVlXCIpO1xuICAgICAgICAgIGNoZWNrU2VsZWN0UHJvcChwcm9wcywgXCJkZWZhdWx0VmFsdWVcIik7XG4gICAgICAgICAgdm9pZCAwID09PSBwcm9wcy52YWx1ZSB8fFxuICAgICAgICAgICAgdm9pZCAwID09PSBwcm9wcy5kZWZhdWx0VmFsdWUgfHxcbiAgICAgICAgICAgIGRpZFdhcm5EZWZhdWx0U2VsZWN0VmFsdWUgfHxcbiAgICAgICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlNlbGVjdCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCBib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBzZWxlY3QgZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiBodHRwczovL3JlYWN0LmRldi9saW5rL2NvbnRyb2xsZWQtY29tcG9uZW50c1wiXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgKGRpZFdhcm5EZWZhdWx0U2VsZWN0VmFsdWUgPSAhMCkpO1xuICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoXCJzZWxlY3RcIikpO1xuICAgICAgICAgIHZhciBjaGlsZHJlbiRqc2NvbXAkMCA9IG51bGwsXG4gICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDAgPSBudWxsLFxuICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkMDtcbiAgICAgICAgICBmb3IgKHByb3BLZXkkanNjb21wJDAgaW4gcHJvcHMpXG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSRqc2NvbXAkMCkpIHtcbiAgICAgICAgICAgICAgdmFyIHByb3BWYWx1ZSRqc2NvbXAkMCA9IHByb3BzW3Byb3BLZXkkanNjb21wJDBdO1xuICAgICAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wVmFsdWUkanNjb21wJDApXG4gICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5JGpzY29tcCQwKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4kanNjb21wJDAgPSBwcm9wVmFsdWUkanNjb21wJDA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgICAgIGlubmVySFRNTCRqc2NvbXAkMCA9IHByb3BWYWx1ZSRqc2NvbXAkMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZGVmYXVsdFZhbHVlXCI6XG4gICAgICAgICAgICAgICAgICBjYXNlIFwidmFsdWVcIjpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBwdXNoQXR0cmlidXRlKFxuICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BWYWx1ZSRqc2NvbXAkMFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgICAgICAgICBwdXNoSW5uZXJIVE1MKHRhcmdldCRqc2NvbXAkMCwgaW5uZXJIVE1MJGpzY29tcCQwLCBjaGlsZHJlbiRqc2NvbXAkMCk7XG4gICAgICAgICAgcmV0dXJuIGNoaWxkcmVuJGpzY29tcCQwO1xuICAgICAgICBjYXNlIFwib3B0aW9uXCI6XG4gICAgICAgICAgdmFyIHNlbGVjdGVkVmFsdWUgPSBmb3JtYXRDb250ZXh0LnNlbGVjdGVkVmFsdWU7XG4gICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goc3RhcnRDaHVua0ZvclRhZyhcIm9wdGlvblwiKSk7XG4gICAgICAgICAgdmFyIGNoaWxkcmVuJGpzY29tcCQxID0gbnVsbCxcbiAgICAgICAgICAgIHZhbHVlID0gbnVsbCxcbiAgICAgICAgICAgIHNlbGVjdGVkID0gbnVsbCxcbiAgICAgICAgICAgIGlubmVySFRNTCRqc2NvbXAkMSA9IG51bGwsXG4gICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQxO1xuICAgICAgICAgIGZvciAocHJvcEtleSRqc2NvbXAkMSBpbiBwcm9wcylcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5JGpzY29tcCQxKSkge1xuICAgICAgICAgICAgICB2YXIgcHJvcFZhbHVlJGpzY29tcCQxID0gcHJvcHNbcHJvcEtleSRqc2NvbXAkMV07XG4gICAgICAgICAgICAgIGlmIChudWxsICE9IHByb3BWYWx1ZSRqc2NvbXAkMSlcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHByb3BLZXkkanNjb21wJDEpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbiRqc2NvbXAkMSA9IHByb3BWYWx1ZSRqc2NvbXAkMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwic2VsZWN0ZWRcIjpcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSBwcm9wVmFsdWUkanNjb21wJDE7XG4gICAgICAgICAgICAgICAgICAgIGRpZFdhcm5TZWxlY3RlZFNldE9uT3B0aW9uIHx8XG4gICAgICAgICAgICAgICAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlVzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBvbiA8c2VsZWN0PiBpbnN0ZWFkIG9mIHNldHRpbmcgYHNlbGVjdGVkYCBvbiA8b3B0aW9uPi5cIlxuICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgKGRpZFdhcm5TZWxlY3RlZFNldE9uT3B0aW9uID0gITApKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJIVE1MJGpzY29tcCQxID0gcHJvcFZhbHVlJGpzY29tcCQxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJ2YWx1ZVwiOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHByb3BWYWx1ZSRqc2NvbXAkMTtcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHB1c2hBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BLZXkkanNjb21wJDEsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcFZhbHVlJGpzY29tcCQxXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIGlmIChudWxsICE9IHNlbGVjdGVkVmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChudWxsICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBcInZhbHVlXCIpO1xuICAgICAgICAgICAgICB2YXIgc3RyaW5nVmFsdWUgPSBcIlwiICsgdmFsdWU7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgbnVsbCA9PT0gaW5uZXJIVE1MJGpzY29tcCQxIHx8XG4gICAgICAgICAgICAgICAgZGlkV2FybkludmFsaWRPcHRpb25Jbm5lckhUTUwgfHxcbiAgICAgICAgICAgICAgICAoKGRpZFdhcm5JbnZhbGlkT3B0aW9uSW5uZXJIVE1MID0gITApLFxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlBhc3MgYSBgdmFsdWVgIHByb3AgaWYgeW91IHNldCBkYW5nZXJvdXNseUlubmVySFRNTCBzbyBSZWFjdCBrbm93cyB3aGljaCB2YWx1ZSBzaG91bGQgYmUgc2VsZWN0ZWQuXCJcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAoc3RyaW5nVmFsdWUgPSBmbGF0dGVuT3B0aW9uQ2hpbGRyZW4oY2hpbGRyZW4kanNjb21wJDEpKTtcbiAgICAgICAgICAgIGlmIChpc0FycmF5SW1wbChzZWxlY3RlZFZhbHVlKSlcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxlY3RlZFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgKGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24oc2VsZWN0ZWRWYWx1ZVtpXSwgXCJ2YWx1ZVwiKSxcbiAgICAgICAgICAgICAgICAgIFwiXCIgKyBzZWxlY3RlZFZhbHVlW2ldID09PSBzdHJpbmdWYWx1ZSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKHNlbGVjdGVkTWFya2VyQXR0cmlidXRlKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHNlbGVjdGVkVmFsdWUsIFwic2VsZWN0LnZhbHVlXCIpLFxuICAgICAgICAgICAgICAgIFwiXCIgKyBzZWxlY3RlZFZhbHVlID09PSBzdHJpbmdWYWx1ZSAmJlxuICAgICAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goc2VsZWN0ZWRNYXJrZXJBdHRyaWJ1dGUpO1xuICAgICAgICAgIH0gZWxzZSBzZWxlY3RlZCAmJiB0YXJnZXQkanNjb21wJDAucHVzaChzZWxlY3RlZE1hcmtlckF0dHJpYnV0ZSk7XG4gICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gICAgICAgICAgcHVzaElubmVySFRNTCh0YXJnZXQkanNjb21wJDAsIGlubmVySFRNTCRqc2NvbXAkMSwgY2hpbGRyZW4kanNjb21wJDEpO1xuICAgICAgICAgIHJldHVybiBjaGlsZHJlbiRqc2NvbXAkMTtcbiAgICAgICAgY2FzZSBcInRleHRhcmVhXCI6XG4gICAgICAgICAgY2hlY2tDb250cm9sbGVkVmFsdWVQcm9wcyhcInRleHRhcmVhXCIsIHByb3BzKTtcbiAgICAgICAgICB2b2lkIDAgPT09IHByb3BzLnZhbHVlIHx8XG4gICAgICAgICAgICB2b2lkIDAgPT09IHByb3BzLmRlZmF1bHRWYWx1ZSB8fFxuICAgICAgICAgICAgZGlkV2FybkRlZmF1bHRUZXh0YXJlYVZhbHVlIHx8XG4gICAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJUZXh0YXJlYSBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCBib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCB0ZXh0YXJlYSBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiBodHRwczovL3JlYWN0LmRldi9saW5rL2NvbnRyb2xsZWQtY29tcG9uZW50c1wiXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgKGRpZFdhcm5EZWZhdWx0VGV4dGFyZWFWYWx1ZSA9ICEwKSk7XG4gICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goc3RhcnRDaHVua0ZvclRhZyhcInRleHRhcmVhXCIpKTtcbiAgICAgICAgICB2YXIgdmFsdWUkanNjb21wJDAgPSBudWxsLFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlID0gbnVsbCxcbiAgICAgICAgICAgIGNoaWxkcmVuJGpzY29tcCQyID0gbnVsbCxcbiAgICAgICAgICAgIHByb3BLZXkkanNjb21wJDI7XG4gICAgICAgICAgZm9yIChwcm9wS2V5JGpzY29tcCQyIGluIHByb3BzKVxuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkkanNjb21wJDIpKSB7XG4gICAgICAgICAgICAgIHZhciBwcm9wVmFsdWUkanNjb21wJDIgPSBwcm9wc1twcm9wS2V5JGpzY29tcCQyXTtcbiAgICAgICAgICAgICAgaWYgKG51bGwgIT0gcHJvcFZhbHVlJGpzY29tcCQyKVxuICAgICAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSRqc2NvbXAkMikge1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuJGpzY29tcCQyID0gcHJvcFZhbHVlJGpzY29tcCQyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJ2YWx1ZVwiOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSRqc2NvbXAkMCA9IHByb3BWYWx1ZSRqc2NvbXAkMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZGVmYXVsdFZhbHVlXCI6XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9IHByb3BWYWx1ZSRqc2NvbXAkMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgXCJgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIGRvZXMgbm90IG1ha2Ugc2Vuc2Ugb24gPHRleHRhcmVhPi5cIlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkMixcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wVmFsdWUkanNjb21wJDJcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgbnVsbCA9PT0gdmFsdWUkanNjb21wJDAgJiZcbiAgICAgICAgICAgIG51bGwgIT09IGRlZmF1bHRWYWx1ZSAmJlxuICAgICAgICAgICAgKHZhbHVlJGpzY29tcCQwID0gZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgICAgICAgICBpZiAobnVsbCAhPSBjaGlsZHJlbiRqc2NvbXAkMikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJVc2UgdGhlIGBkZWZhdWx0VmFsdWVgIG9yIGB2YWx1ZWAgcHJvcHMgaW5zdGVhZCBvZiBzZXR0aW5nIGNoaWxkcmVuIG9uIDx0ZXh0YXJlYT4uXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAobnVsbCAhPSB2YWx1ZSRqc2NvbXAkMClcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJJZiB5b3Ugc3VwcGx5IGBkZWZhdWx0VmFsdWVgIG9uIGEgPHRleHRhcmVhPiwgZG8gbm90IHBhc3MgY2hpbGRyZW4uXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChpc0FycmF5SW1wbChjaGlsZHJlbiRqc2NvbXAkMikpIHtcbiAgICAgICAgICAgICAgaWYgKDEgPCBjaGlsZHJlbiRqc2NvbXAkMi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCI8dGV4dGFyZWE+IGNhbiBvbmx5IGhhdmUgYXQgbW9zdCBvbmUgY2hpbGQuXCIpO1xuICAgICAgICAgICAgICBjaGVja0h0bWxTdHJpbmdDb2VyY2lvbihjaGlsZHJlbiRqc2NvbXAkMlswXSk7XG4gICAgICAgICAgICAgIHZhbHVlJGpzY29tcCQwID0gXCJcIiArIGNoaWxkcmVuJGpzY29tcCQyWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hlY2tIdG1sU3RyaW5nQ29lcmNpb24oY2hpbGRyZW4kanNjb21wJDIpO1xuICAgICAgICAgICAgdmFsdWUkanNjb21wJDAgPSBcIlwiICsgY2hpbGRyZW4kanNjb21wJDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiB2YWx1ZSRqc2NvbXAkMCAmJlxuICAgICAgICAgICAgXCJcXG5cIiA9PT0gdmFsdWUkanNjb21wJDBbMF0gJiZcbiAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKGxlYWRpbmdOZXdsaW5lKTtcbiAgICAgICAgICBudWxsICE9PSB2YWx1ZSRqc2NvbXAkMCAmJlxuICAgICAgICAgICAgKGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odmFsdWUkanNjb21wJDAsIFwidmFsdWVcIiksXG4gICAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChcbiAgICAgICAgICAgICAgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihcIlwiICsgdmFsdWUkanNjb21wJDApKVxuICAgICAgICAgICAgKSk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNhc2UgXCJpbnB1dFwiOlxuICAgICAgICAgIGNoZWNrQ29udHJvbGxlZFZhbHVlUHJvcHMoXCJpbnB1dFwiLCBwcm9wcyk7XG4gICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goc3RhcnRDaHVua0ZvclRhZyhcImlucHV0XCIpKTtcbiAgICAgICAgICB2YXIgbmFtZSA9IG51bGwsXG4gICAgICAgICAgICBmb3JtQWN0aW9uID0gbnVsbCxcbiAgICAgICAgICAgIGZvcm1FbmNUeXBlID0gbnVsbCxcbiAgICAgICAgICAgIGZvcm1NZXRob2QgPSBudWxsLFxuICAgICAgICAgICAgZm9ybVRhcmdldCA9IG51bGwsXG4gICAgICAgICAgICB2YWx1ZSRqc2NvbXAkMSA9IG51bGwsXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWUkanNjb21wJDAgPSBudWxsLFxuICAgICAgICAgICAgY2hlY2tlZCA9IG51bGwsXG4gICAgICAgICAgICBkZWZhdWx0Q2hlY2tlZCA9IG51bGwsXG4gICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQzO1xuICAgICAgICAgIGZvciAocHJvcEtleSRqc2NvbXAkMyBpbiBwcm9wcylcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5JGpzY29tcCQzKSkge1xuICAgICAgICAgICAgICB2YXIgcHJvcFZhbHVlJGpzY29tcCQzID0gcHJvcHNbcHJvcEtleSRqc2NvbXAkM107XG4gICAgICAgICAgICAgIGlmIChudWxsICE9IHByb3BWYWx1ZSRqc2NvbXAkMylcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHByb3BLZXkkanNjb21wJDMpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgIFwiaW5wdXQgaXMgYSBzZWxmLWNsb3NpbmcgdGFnIGFuZCBtdXN0IG5laXRoZXIgaGF2ZSBgY2hpbGRyZW5gIG5vciB1c2UgYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC5cIlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcIm5hbWVcIjpcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IHByb3BWYWx1ZSRqc2NvbXAkMztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZm9ybUFjdGlvblwiOlxuICAgICAgICAgICAgICAgICAgICBmb3JtQWN0aW9uID0gcHJvcFZhbHVlJGpzY29tcCQzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJmb3JtRW5jVHlwZVwiOlxuICAgICAgICAgICAgICAgICAgICBmb3JtRW5jVHlwZSA9IHByb3BWYWx1ZSRqc2NvbXAkMztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZm9ybU1ldGhvZFwiOlxuICAgICAgICAgICAgICAgICAgICBmb3JtTWV0aG9kID0gcHJvcFZhbHVlJGpzY29tcCQzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJmb3JtVGFyZ2V0XCI6XG4gICAgICAgICAgICAgICAgICAgIGZvcm1UYXJnZXQgPSBwcm9wVmFsdWUkanNjb21wJDM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImRlZmF1bHRDaGVja2VkXCI6XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRDaGVja2VkID0gcHJvcFZhbHVlJGpzY29tcCQzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJkZWZhdWx0VmFsdWVcIjpcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlJGpzY29tcCQwID0gcHJvcFZhbHVlJGpzY29tcCQzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJjaGVja2VkXCI6XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrZWQgPSBwcm9wVmFsdWUkanNjb21wJDM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcInZhbHVlXCI6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlJGpzY29tcCQxID0gcHJvcFZhbHVlJGpzY29tcCQzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHB1c2hBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BLZXkkanNjb21wJDMsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcFZhbHVlJGpzY29tcCQzXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIG51bGwgPT09IGZvcm1BY3Rpb24gfHxcbiAgICAgICAgICAgIFwiaW1hZ2VcIiA9PT0gcHJvcHMudHlwZSB8fFxuICAgICAgICAgICAgXCJzdWJtaXRcIiA9PT0gcHJvcHMudHlwZSB8fFxuICAgICAgICAgICAgZGlkV2FybkZvcm1BY3Rpb25UeXBlIHx8XG4gICAgICAgICAgICAoKGRpZFdhcm5Gb3JtQWN0aW9uVHlwZSA9ICEwKSxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICdBbiBpbnB1dCBjYW4gb25seSBzcGVjaWZ5IGEgZm9ybUFjdGlvbiBhbG9uZyB3aXRoIHR5cGU9XCJzdWJtaXRcIiBvciB0eXBlPVwiaW1hZ2VcIi4nXG4gICAgICAgICAgICApKTtcbiAgICAgICAgICB2YXIgZm9ybURhdGEgPSBwdXNoRm9ybUFjdGlvbkF0dHJpYnV0ZShcbiAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLFxuICAgICAgICAgICAgcmVuZGVyU3RhdGUsXG4gICAgICAgICAgICBmb3JtQWN0aW9uLFxuICAgICAgICAgICAgZm9ybUVuY1R5cGUsXG4gICAgICAgICAgICBmb3JtTWV0aG9kLFxuICAgICAgICAgICAgZm9ybVRhcmdldCxcbiAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICApO1xuICAgICAgICAgIG51bGwgPT09IGNoZWNrZWQgfHxcbiAgICAgICAgICAgIG51bGwgPT09IGRlZmF1bHRDaGVja2VkIHx8XG4gICAgICAgICAgICBkaWRXYXJuRGVmYXVsdENoZWNrZWQgfHxcbiAgICAgICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzIGNvbnRhaW5zIGFuIGlucHV0IG9mIHR5cGUgJXMgd2l0aCBib3RoIGNoZWNrZWQgYW5kIGRlZmF1bHRDaGVja2VkIHByb3BzLiBJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAoc3BlY2lmeSBlaXRoZXIgdGhlIGNoZWNrZWQgcHJvcCwgb3IgdGhlIGRlZmF1bHRDaGVja2VkIHByb3AsIGJ1dCBub3QgYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiBodHRwczovL3JlYWN0LmRldi9saW5rL2NvbnRyb2xsZWQtY29tcG9uZW50c1wiLFxuICAgICAgICAgICAgICBcIkEgY29tcG9uZW50XCIsXG4gICAgICAgICAgICAgIHByb3BzLnR5cGVcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAoZGlkV2FybkRlZmF1bHRDaGVja2VkID0gITApKTtcbiAgICAgICAgICBudWxsID09PSB2YWx1ZSRqc2NvbXAkMSB8fFxuICAgICAgICAgICAgbnVsbCA9PT0gZGVmYXVsdFZhbHVlJGpzY29tcCQwIHx8XG4gICAgICAgICAgICBkaWRXYXJuRGVmYXVsdElucHV0VmFsdWUgfHxcbiAgICAgICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzIGNvbnRhaW5zIGFuIGlucHV0IG9mIHR5cGUgJXMgd2l0aCBib3RoIHZhbHVlIGFuZCBkZWZhdWx0VmFsdWUgcHJvcHMuIElucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIChzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90IGJvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0IGVsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHNcIixcbiAgICAgICAgICAgICAgXCJBIGNvbXBvbmVudFwiLFxuICAgICAgICAgICAgICBwcm9wcy50eXBlXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgKGRpZFdhcm5EZWZhdWx0SW5wdXRWYWx1ZSA9ICEwKSk7XG4gICAgICAgICAgbnVsbCAhPT0gY2hlY2tlZFxuICAgICAgICAgICAgPyBwdXNoQm9vbGVhbkF0dHJpYnV0ZSh0YXJnZXQkanNjb21wJDAsIFwiY2hlY2tlZFwiLCBjaGVja2VkKVxuICAgICAgICAgICAgOiBudWxsICE9PSBkZWZhdWx0Q2hlY2tlZCAmJlxuICAgICAgICAgICAgICBwdXNoQm9vbGVhbkF0dHJpYnV0ZSh0YXJnZXQkanNjb21wJDAsIFwiY2hlY2tlZFwiLCBkZWZhdWx0Q2hlY2tlZCk7XG4gICAgICAgICAgbnVsbCAhPT0gdmFsdWUkanNjb21wJDFcbiAgICAgICAgICAgID8gcHVzaEF0dHJpYnV0ZSh0YXJnZXQkanNjb21wJDAsIFwidmFsdWVcIiwgdmFsdWUkanNjb21wJDEpXG4gICAgICAgICAgICA6IG51bGwgIT09IGRlZmF1bHRWYWx1ZSRqc2NvbXAkMCAmJlxuICAgICAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCRqc2NvbXAkMCwgXCJ2YWx1ZVwiLCBkZWZhdWx0VmFsdWUkanNjb21wJDApO1xuICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKGVuZE9mU3RhcnRUYWdTZWxmQ2xvc2luZyk7XG4gICAgICAgICAgbnVsbCAhPSBmb3JtRGF0YSAmJlxuICAgICAgICAgICAgZm9ybURhdGEuZm9yRWFjaChwdXNoQWRkaXRpb25hbEZvcm1GaWVsZCwgdGFyZ2V0JGpzY29tcCQwKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSBcImJ1dHRvblwiOlxuICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoXCJidXR0b25cIikpO1xuICAgICAgICAgIHZhciBjaGlsZHJlbiRqc2NvbXAkMyA9IG51bGwsXG4gICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDIgPSBudWxsLFxuICAgICAgICAgICAgbmFtZSRqc2NvbXAkMCA9IG51bGwsXG4gICAgICAgICAgICBmb3JtQWN0aW9uJGpzY29tcCQwID0gbnVsbCxcbiAgICAgICAgICAgIGZvcm1FbmNUeXBlJGpzY29tcCQwID0gbnVsbCxcbiAgICAgICAgICAgIGZvcm1NZXRob2QkanNjb21wJDAgPSBudWxsLFxuICAgICAgICAgICAgZm9ybVRhcmdldCRqc2NvbXAkMCA9IG51bGwsXG4gICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQ0O1xuICAgICAgICAgIGZvciAocHJvcEtleSRqc2NvbXAkNCBpbiBwcm9wcylcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5JGpzY29tcCQ0KSkge1xuICAgICAgICAgICAgICB2YXIgcHJvcFZhbHVlJGpzY29tcCQ0ID0gcHJvcHNbcHJvcEtleSRqc2NvbXAkNF07XG4gICAgICAgICAgICAgIGlmIChudWxsICE9IHByb3BWYWx1ZSRqc2NvbXAkNClcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHByb3BLZXkkanNjb21wJDQpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbiRqc2NvbXAkMyA9IHByb3BWYWx1ZSRqc2NvbXAkNDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJIVE1MJGpzY29tcCQyID0gcHJvcFZhbHVlJGpzY29tcCQ0O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJuYW1lXCI6XG4gICAgICAgICAgICAgICAgICAgIG5hbWUkanNjb21wJDAgPSBwcm9wVmFsdWUkanNjb21wJDQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImZvcm1BY3Rpb25cIjpcbiAgICAgICAgICAgICAgICAgICAgZm9ybUFjdGlvbiRqc2NvbXAkMCA9IHByb3BWYWx1ZSRqc2NvbXAkNDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZm9ybUVuY1R5cGVcIjpcbiAgICAgICAgICAgICAgICAgICAgZm9ybUVuY1R5cGUkanNjb21wJDAgPSBwcm9wVmFsdWUkanNjb21wJDQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImZvcm1NZXRob2RcIjpcbiAgICAgICAgICAgICAgICAgICAgZm9ybU1ldGhvZCRqc2NvbXAkMCA9IHByb3BWYWx1ZSRqc2NvbXAkNDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZm9ybVRhcmdldFwiOlxuICAgICAgICAgICAgICAgICAgICBmb3JtVGFyZ2V0JGpzY29tcCQwID0gcHJvcFZhbHVlJGpzY29tcCQ0O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHB1c2hBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BLZXkkanNjb21wJDQsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcFZhbHVlJGpzY29tcCQ0XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIG51bGwgPT09IGZvcm1BY3Rpb24kanNjb21wJDAgfHxcbiAgICAgICAgICAgIG51bGwgPT0gcHJvcHMudHlwZSB8fFxuICAgICAgICAgICAgXCJzdWJtaXRcIiA9PT0gcHJvcHMudHlwZSB8fFxuICAgICAgICAgICAgZGlkV2FybkZvcm1BY3Rpb25UeXBlIHx8XG4gICAgICAgICAgICAoKGRpZFdhcm5Gb3JtQWN0aW9uVHlwZSA9ICEwKSxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICdBIGJ1dHRvbiBjYW4gb25seSBzcGVjaWZ5IGEgZm9ybUFjdGlvbiBhbG9uZyB3aXRoIHR5cGU9XCJzdWJtaXRcIiBvciBubyB0eXBlLidcbiAgICAgICAgICAgICkpO1xuICAgICAgICAgIHZhciBmb3JtRGF0YSRqc2NvbXAkMCA9IHB1c2hGb3JtQWN0aW9uQXR0cmlidXRlKFxuICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLFxuICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICByZW5kZXJTdGF0ZSxcbiAgICAgICAgICAgIGZvcm1BY3Rpb24kanNjb21wJDAsXG4gICAgICAgICAgICBmb3JtRW5jVHlwZSRqc2NvbXAkMCxcbiAgICAgICAgICAgIGZvcm1NZXRob2QkanNjb21wJDAsXG4gICAgICAgICAgICBmb3JtVGFyZ2V0JGpzY29tcCQwLFxuICAgICAgICAgICAgbmFtZSRqc2NvbXAkMFxuICAgICAgICAgICk7XG4gICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gICAgICAgICAgbnVsbCAhPSBmb3JtRGF0YSRqc2NvbXAkMCAmJlxuICAgICAgICAgICAgZm9ybURhdGEkanNjb21wJDAuZm9yRWFjaChwdXNoQWRkaXRpb25hbEZvcm1GaWVsZCwgdGFyZ2V0JGpzY29tcCQwKTtcbiAgICAgICAgICBwdXNoSW5uZXJIVE1MKHRhcmdldCRqc2NvbXAkMCwgaW5uZXJIVE1MJGpzY29tcCQyLCBjaGlsZHJlbiRqc2NvbXAkMyk7XG4gICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBjaGlsZHJlbiRqc2NvbXAkMykge1xuICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goXG4gICAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoY2hpbGRyZW4kanNjb21wJDMpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDEgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDEgPSBjaGlsZHJlbiRqc2NvbXAkMztcbiAgICAgICAgICByZXR1cm4gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQxO1xuICAgICAgICBjYXNlIFwiZm9ybVwiOlxuICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoXCJmb3JtXCIpKTtcbiAgICAgICAgICB2YXIgY2hpbGRyZW4kanNjb21wJDQgPSBudWxsLFxuICAgICAgICAgICAgaW5uZXJIVE1MJGpzY29tcCQzID0gbnVsbCxcbiAgICAgICAgICAgIGZvcm1BY3Rpb24kanNjb21wJDEgPSBudWxsLFxuICAgICAgICAgICAgZm9ybUVuY1R5cGUkanNjb21wJDEgPSBudWxsLFxuICAgICAgICAgICAgZm9ybU1ldGhvZCRqc2NvbXAkMSA9IG51bGwsXG4gICAgICAgICAgICBmb3JtVGFyZ2V0JGpzY29tcCQxID0gbnVsbCxcbiAgICAgICAgICAgIHByb3BLZXkkanNjb21wJDU7XG4gICAgICAgICAgZm9yIChwcm9wS2V5JGpzY29tcCQ1IGluIHByb3BzKVxuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkkanNjb21wJDUpKSB7XG4gICAgICAgICAgICAgIHZhciBwcm9wVmFsdWUkanNjb21wJDUgPSBwcm9wc1twcm9wS2V5JGpzY29tcCQ1XTtcbiAgICAgICAgICAgICAgaWYgKG51bGwgIT0gcHJvcFZhbHVlJGpzY29tcCQ1KVxuICAgICAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSRqc2NvbXAkNSkge1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuJGpzY29tcCQ0ID0gcHJvcFZhbHVlJGpzY29tcCQ1O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDMgPSBwcm9wVmFsdWUkanNjb21wJDU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImFjdGlvblwiOlxuICAgICAgICAgICAgICAgICAgICBmb3JtQWN0aW9uJGpzY29tcCQxID0gcHJvcFZhbHVlJGpzY29tcCQ1O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmNUeXBlXCI6XG4gICAgICAgICAgICAgICAgICAgIGZvcm1FbmNUeXBlJGpzY29tcCQxID0gcHJvcFZhbHVlJGpzY29tcCQ1O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJtZXRob2RcIjpcbiAgICAgICAgICAgICAgICAgICAgZm9ybU1ldGhvZCRqc2NvbXAkMSA9IHByb3BWYWx1ZSRqc2NvbXAkNTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwidGFyZ2V0XCI6XG4gICAgICAgICAgICAgICAgICAgIGZvcm1UYXJnZXQkanNjb21wJDEgPSBwcm9wVmFsdWUkanNjb21wJDU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkNSxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wVmFsdWUkanNjb21wJDVcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGZvcm1EYXRhJGpzY29tcCQxID0gbnVsbCxcbiAgICAgICAgICAgIGZvcm1BY3Rpb25OYW1lID0gbnVsbDtcbiAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZm9ybUFjdGlvbiRqc2NvbXAkMSkge1xuICAgICAgICAgICAgKG51bGwgPT09IGZvcm1FbmNUeXBlJGpzY29tcCQxICYmIG51bGwgPT09IGZvcm1NZXRob2QkanNjb21wJDEpIHx8XG4gICAgICAgICAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uTWV0aG9kIHx8XG4gICAgICAgICAgICAgICgoZGlkV2FybkZvcm1BY3Rpb25NZXRob2QgPSAhMCksXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJDYW5ub3Qgc3BlY2lmeSBhIGVuY1R5cGUgb3IgbWV0aG9kIGZvciBhIGZvcm0gdGhhdCBzcGVjaWZpZXMgYSBmdW5jdGlvbiBhcyB0aGUgYWN0aW9uLiBSZWFjdCBwcm92aWRlcyB0aG9zZSBhdXRvbWF0aWNhbGx5LiBUaGV5IHdpbGwgZ2V0IG92ZXJyaWRkZW4uXCJcbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICBudWxsID09PSBmb3JtVGFyZ2V0JGpzY29tcCQxIHx8XG4gICAgICAgICAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uVGFyZ2V0IHx8XG4gICAgICAgICAgICAgICgoZGlkV2FybkZvcm1BY3Rpb25UYXJnZXQgPSAhMCksXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJDYW5ub3Qgc3BlY2lmeSBhIHRhcmdldCBmb3IgYSBmb3JtIHRoYXQgc3BlY2lmaWVzIGEgZnVuY3Rpb24gYXMgdGhlIGFjdGlvbi4gVGhlIGZ1bmN0aW9uIHdpbGwgYWx3YXlzIGJlIGV4ZWN1dGVkIGluIHRoZSBzYW1lIHdpbmRvdy5cIlxuICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIHZhciBjdXN0b21GaWVsZHMgPSBnZXRDdXN0b21Gb3JtRmllbGRzKFxuICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZSxcbiAgICAgICAgICAgICAgZm9ybUFjdGlvbiRqc2NvbXAkMVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG51bGwgIT09IGN1c3RvbUZpZWxkc1xuICAgICAgICAgICAgICA/ICgoZm9ybUFjdGlvbiRqc2NvbXAkMSA9IGN1c3RvbUZpZWxkcy5hY3Rpb24gfHwgXCJcIiksXG4gICAgICAgICAgICAgICAgKGZvcm1FbmNUeXBlJGpzY29tcCQxID0gY3VzdG9tRmllbGRzLmVuY1R5cGUpLFxuICAgICAgICAgICAgICAgIChmb3JtTWV0aG9kJGpzY29tcCQxID0gY3VzdG9tRmllbGRzLm1ldGhvZCksXG4gICAgICAgICAgICAgICAgKGZvcm1UYXJnZXQkanNjb21wJDEgPSBjdXN0b21GaWVsZHMudGFyZ2V0KSxcbiAgICAgICAgICAgICAgICAoZm9ybURhdGEkanNjb21wJDEgPSBjdXN0b21GaWVsZHMuZGF0YSksXG4gICAgICAgICAgICAgICAgKGZvcm1BY3Rpb25OYW1lID0gY3VzdG9tRmllbGRzLm5hbWUpKVxuICAgICAgICAgICAgICA6ICh0YXJnZXQkanNjb21wJDAucHVzaChcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZVNlcGFyYXRvcixcbiAgICAgICAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsoXCJhY3Rpb25cIiksXG4gICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVBc3NpZ24sXG4gICAgICAgICAgICAgICAgICBhY3Rpb25KYXZhU2NyaXB0VVJMLFxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlRW5kXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAoZm9ybVRhcmdldCRqc2NvbXAkMSA9XG4gICAgICAgICAgICAgICAgICBmb3JtTWV0aG9kJGpzY29tcCQxID1cbiAgICAgICAgICAgICAgICAgIGZvcm1FbmNUeXBlJGpzY29tcCQxID1cbiAgICAgICAgICAgICAgICAgIGZvcm1BY3Rpb24kanNjb21wJDEgPVxuICAgICAgICAgICAgICAgICAgICBudWxsKSxcbiAgICAgICAgICAgICAgICBpbmplY3RGb3JtUmVwbGF5aW5nUnVudGltZShyZXN1bWFibGVTdGF0ZSwgcmVuZGVyU3RhdGUpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbnVsbCAhPSBmb3JtQWN0aW9uJGpzY29tcCQxICYmXG4gICAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCRqc2NvbXAkMCwgXCJhY3Rpb25cIiwgZm9ybUFjdGlvbiRqc2NvbXAkMSk7XG4gICAgICAgICAgbnVsbCAhPSBmb3JtRW5jVHlwZSRqc2NvbXAkMSAmJlxuICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQkanNjb21wJDAsIFwiZW5jVHlwZVwiLCBmb3JtRW5jVHlwZSRqc2NvbXAkMSk7XG4gICAgICAgICAgbnVsbCAhPSBmb3JtTWV0aG9kJGpzY29tcCQxICYmXG4gICAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCRqc2NvbXAkMCwgXCJtZXRob2RcIiwgZm9ybU1ldGhvZCRqc2NvbXAkMSk7XG4gICAgICAgICAgbnVsbCAhPSBmb3JtVGFyZ2V0JGpzY29tcCQxICYmXG4gICAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCRqc2NvbXAkMCwgXCJ0YXJnZXRcIiwgZm9ybVRhcmdldCRqc2NvbXAkMSk7XG4gICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gICAgICAgICAgbnVsbCAhPT0gZm9ybUFjdGlvbk5hbWUgJiZcbiAgICAgICAgICAgICh0YXJnZXQkanNjb21wJDAucHVzaChzdGFydEhpZGRlbklucHV0Q2h1bmspLFxuICAgICAgICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQkanNjb21wJDAsIFwibmFtZVwiLCBmb3JtQWN0aW9uTmFtZSksXG4gICAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChlbmRPZlN0YXJ0VGFnU2VsZkNsb3NpbmcpLFxuICAgICAgICAgICAgbnVsbCAhPSBmb3JtRGF0YSRqc2NvbXAkMSAmJlxuICAgICAgICAgICAgICBmb3JtRGF0YSRqc2NvbXAkMS5mb3JFYWNoKFxuICAgICAgICAgICAgICAgIHB1c2hBZGRpdGlvbmFsRm9ybUZpZWxkLFxuICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMFxuICAgICAgICAgICAgICApKTtcbiAgICAgICAgICBwdXNoSW5uZXJIVE1MKHRhcmdldCRqc2NvbXAkMCwgaW5uZXJIVE1MJGpzY29tcCQzLCBjaGlsZHJlbiRqc2NvbXAkNCk7XG4gICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBjaGlsZHJlbiRqc2NvbXAkNCkge1xuICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goXG4gICAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoY2hpbGRyZW4kanNjb21wJDQpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDIgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDIgPSBjaGlsZHJlbiRqc2NvbXAkNDtcbiAgICAgICAgICByZXR1cm4gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQyO1xuICAgICAgICBjYXNlIFwibWVudWl0ZW1cIjpcbiAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChzdGFydENodW5rRm9yVGFnKFwibWVudWl0ZW1cIikpO1xuICAgICAgICAgIGZvciAodmFyIHByb3BLZXkkanNjb21wJDYgaW4gcHJvcHMpXG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSRqc2NvbXAkNikpIHtcbiAgICAgICAgICAgICAgdmFyIHByb3BWYWx1ZSRqc2NvbXAkNiA9IHByb3BzW3Byb3BLZXkkanNjb21wJDZdO1xuICAgICAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wVmFsdWUkanNjb21wJDYpXG4gICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5JGpzY29tcCQ2KSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICBcIm1lbnVpdGVtcyBjYW5ub3QgaGF2ZSBgY2hpbGRyZW5gIG5vciBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLlwiXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBwdXNoQXR0cmlidXRlKFxuICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQ2LFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BWYWx1ZSRqc2NvbXAkNlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoXCJvYmplY3RcIikpO1xuICAgICAgICAgIHZhciBjaGlsZHJlbiRqc2NvbXAkNSA9IG51bGwsXG4gICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDQgPSBudWxsLFxuICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkNztcbiAgICAgICAgICBmb3IgKHByb3BLZXkkanNjb21wJDcgaW4gcHJvcHMpXG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSRqc2NvbXAkNykpIHtcbiAgICAgICAgICAgICAgdmFyIHByb3BWYWx1ZSRqc2NvbXAkNyA9IHByb3BzW3Byb3BLZXkkanNjb21wJDddO1xuICAgICAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wVmFsdWUkanNjb21wJDcpXG4gICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5JGpzY29tcCQ3KSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4kanNjb21wJDUgPSBwcm9wVmFsdWUkanNjb21wJDc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgICAgIGlubmVySFRNTCRqc2NvbXAkNCA9IHByb3BWYWx1ZSRqc2NvbXAkNztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZGF0YVwiOlxuICAgICAgICAgICAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHByb3BWYWx1ZSRqc2NvbXAkNywgXCJkYXRhXCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2FuaXRpemVkVmFsdWUgPSBzYW5pdGl6ZVVSTChcIlwiICsgcHJvcFZhbHVlJGpzY29tcCQ3KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwiXCIgPT09IHNhbml0aXplZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICdBbiBlbXB0eSBzdHJpbmcgKFwiXCIpIHdhcyBwYXNzZWQgdG8gdGhlICVzIGF0dHJpYnV0ZS4gVG8gZml4IHRoaXMsIGVpdGhlciBkbyBub3QgcmVuZGVyIHRoZSBlbGVtZW50IGF0IGFsbCBvciBwYXNzIG51bGwgdG8gJXMgaW5zdGVhZCBvZiBhbiBlbXB0eSBzdHJpbmcuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BLZXkkanNjb21wJDcsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQ3XG4gICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVTZXBhcmF0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgc3RyaW5nVG9DaHVuayhcImRhdGFcIiksXG4gICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlQXNzaWduLFxuICAgICAgICAgICAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoc2FuaXRpemVkVmFsdWUpKSxcbiAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVFbmRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBwdXNoQXR0cmlidXRlKFxuICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQ3LFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BWYWx1ZSRqc2NvbXAkN1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgICAgICAgICBwdXNoSW5uZXJIVE1MKHRhcmdldCRqc2NvbXAkMCwgaW5uZXJIVE1MJGpzY29tcCQ0LCBjaGlsZHJlbiRqc2NvbXAkNSk7XG4gICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBjaGlsZHJlbiRqc2NvbXAkNSkge1xuICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goXG4gICAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoY2hpbGRyZW4kanNjb21wJDUpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDMgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDMgPSBjaGlsZHJlbiRqc2NvbXAkNTtcbiAgICAgICAgICByZXR1cm4gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQzO1xuICAgICAgICBjYXNlIFwidGl0bGVcIjpcbiAgICAgICAgICB2YXIgaW5zZXJ0aW9uTW9kZSA9IGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSxcbiAgICAgICAgICAgIG5vc2NyaXB0VGFnSW5TY29wZSA9ICEhKGZvcm1hdENvbnRleHQudGFnU2NvcGUgJiAxKTtcbiAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgXCJjaGlsZHJlblwiKSkge1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuJGpzY29tcCQ2ID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICAgICAgICAgIGNoaWxkID0gQXJyYXkuaXNBcnJheShjaGlsZHJlbiRqc2NvbXAkNilcbiAgICAgICAgICAgICAgICA/IDIgPiBjaGlsZHJlbiRqc2NvbXAkNi5sZW5ndGhcbiAgICAgICAgICAgICAgICAgID8gY2hpbGRyZW4kanNjb21wJDZbMF1cbiAgICAgICAgICAgICAgICAgIDogbnVsbFxuICAgICAgICAgICAgICAgIDogY2hpbGRyZW4kanNjb21wJDY7XG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KGNoaWxkcmVuJGpzY29tcCQ2KSAmJiAxIDwgY2hpbGRyZW4kanNjb21wJDYubGVuZ3RoXG4gICAgICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiUmVhY3QgZXhwZWN0cyB0aGUgYGNoaWxkcmVuYCBwcm9wIG9mIDx0aXRsZT4gdGFncyB0byBiZSBhIHN0cmluZywgbnVtYmVyLCBiaWdpbnQsIG9yIG9iamVjdCB3aXRoIGEgbm92ZWwgYHRvU3RyaW5nYCBtZXRob2QgYnV0IGZvdW5kIGFuIEFycmF5IHdpdGggbGVuZ3RoICVzIGluc3RlYWQuIEJyb3dzZXJzIHRyZWF0IGFsbCBjaGlsZCBOb2RlcyBvZiA8dGl0bGU+IHRhZ3MgYXMgVGV4dCBjb250ZW50IGFuZCBSZWFjdCBleHBlY3RzIHRvIGJlIGFibGUgdG8gY29udmVydCBgY2hpbGRyZW5gIG9mIDx0aXRsZT4gdGFncyB0byBhIHNpbmdsZSBzdHJpbmcgdmFsdWUgd2hpY2ggaXMgd2h5IEFycmF5cyBvZiBsZW5ndGggZ3JlYXRlciB0aGFuIDEgYXJlIG5vdCBzdXBwb3J0ZWQuIFdoZW4gdXNpbmcgSlNYIGl0IGNhbiBiZSBjb21tb25nIHRvIGNvbWJpbmUgdGV4dCBub2RlcyBhbmQgdmFsdWUgbm9kZXMuIEZvciBleGFtcGxlOiA8dGl0bGU+aGVsbG8ge25hbWVPZlVzZXJ9PC90aXRsZT4uIFdoaWxlIG5vdCBpbW1lZGlhdGVseSBhcHBhcmVudCwgYGNoaWxkcmVuYCBpbiB0aGlzIGNhc2UgaXMgYW4gQXJyYXkgd2l0aCBsZW5ndGggMi4gSWYgeW91ciBgY2hpbGRyZW5gIHByb3AgaXMgdXNpbmcgdGhpcyBmb3JtIHRyeSByZXdyaXRpbmcgaXQgdXNpbmcgYSB0ZW1wbGF0ZSBzdHJpbmc6IDx0aXRsZT57YGhlbGxvICR7bmFtZU9mVXNlcn1gfTwvdGl0bGU+LlwiLFxuICAgICAgICAgICAgICAgICAgY2hpbGRyZW4kanNjb21wJDYubGVuZ3RoXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNoaWxkIHx8IFwic3ltYm9sXCIgPT09IHR5cGVvZiBjaGlsZFxuICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJSZWFjdCBleHBlY3QgY2hpbGRyZW4gb2YgPHRpdGxlPiB0YWdzIHRvIGJlIGEgc3RyaW5nLCBudW1iZXIsIGJpZ2ludCwgb3Igb2JqZWN0IHdpdGggYSBub3ZlbCBgdG9TdHJpbmdgIG1ldGhvZCBidXQgZm91bmQgJXMgaW5zdGVhZC4gQnJvd3NlcnMgdHJlYXQgYWxsIGNoaWxkIE5vZGVzIG9mIDx0aXRsZT4gdGFncyBhcyBUZXh0IGNvbnRlbnQgYW5kIFJlYWN0IGV4cGVjdHMgdG8gYmUgYWJsZSB0byBjb252ZXJ0IGNoaWxkcmVuIG9mIDx0aXRsZT4gdGFncyB0byBhIHNpbmdsZSBzdHJpbmcgdmFsdWUuXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNoaWxkID8gXCJhIEZ1bmN0aW9uXCIgOiBcImEgU3libW9sXCJcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICA6IGNoaWxkICYmXG4gICAgICAgICAgICAgICAgICBjaGlsZC50b1N0cmluZyA9PT0ge30udG9TdHJpbmcgJiZcbiAgICAgICAgICAgICAgICAgIChudWxsICE9IGNoaWxkLiQkdHlwZW9mXG4gICAgICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiUmVhY3QgZXhwZWN0cyB0aGUgYGNoaWxkcmVuYCBwcm9wIG9mIDx0aXRsZT4gdGFncyB0byBiZSBhIHN0cmluZywgbnVtYmVyLCBiaWdpbnQsIG9yIG9iamVjdCB3aXRoIGEgbm92ZWwgYHRvU3RyaW5nYCBtZXRob2QgYnV0IGZvdW5kIGFuIG9iamVjdCB0aGF0IGFwcGVhcnMgdG8gYmUgYSBSZWFjdCBlbGVtZW50IHdoaWNoIG5ldmVyIGltcGxlbWVudHMgYSBzdWl0YWJsZSBgdG9TdHJpbmdgIG1ldGhvZC4gQnJvd3NlcnMgdHJlYXQgYWxsIGNoaWxkIE5vZGVzIG9mIDx0aXRsZT4gdGFncyBhcyBUZXh0IGNvbnRlbnQgYW5kIFJlYWN0IGV4cGVjdHMgdG8gYmUgYWJsZSB0byBjb252ZXJ0IGNoaWxkcmVuIG9mIDx0aXRsZT4gdGFncyB0byBhIHNpbmdsZSBzdHJpbmcgdmFsdWUgd2hpY2ggaXMgd2h5IHJlbmRlcmluZyBSZWFjdCBlbGVtZW50cyBpcyBub3Qgc3VwcG9ydGVkLiBJZiB0aGUgYGNoaWxkcmVuYCBvZiA8dGl0bGU+IGlzIGEgUmVhY3QgQ29tcG9uZW50IHRyeSBtb3ZpbmcgdGhlIDx0aXRsZT4gdGFnIGludG8gdGhhdCBjb21wb25lbnQuIElmIHRoZSBgY2hpbGRyZW5gIG9mIDx0aXRsZT4gaXMgc29tZSBIVE1MIG1hcmt1cCBjaGFuZ2UgaXQgdG8gYmUgVGV4dCBvbmx5IHRvIGJlIHZhbGlkIEhUTUwuXCJcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIDogY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiUmVhY3QgZXhwZWN0cyB0aGUgYGNoaWxkcmVuYCBwcm9wIG9mIDx0aXRsZT4gdGFncyB0byBiZSBhIHN0cmluZywgbnVtYmVyLCBiaWdpbnQsIG9yIG9iamVjdCB3aXRoIGEgbm92ZWwgYHRvU3RyaW5nYCBtZXRob2QgYnV0IGZvdW5kIGFuIG9iamVjdCB0aGF0IGRvZXMgbm90IGltcGxlbWVudCBhIHN1aXRhYmxlIGB0b1N0cmluZ2AgbWV0aG9kLiBCcm93c2VycyB0cmVhdCBhbGwgY2hpbGQgTm9kZXMgb2YgPHRpdGxlPiB0YWdzIGFzIFRleHQgY29udGVudCBhbmQgUmVhY3QgZXhwZWN0cyB0byBiZSBhYmxlIHRvIGNvbnZlcnQgY2hpbGRyZW4gb2YgPHRpdGxlPiB0YWdzIHRvIGEgc2luZ2xlIHN0cmluZyB2YWx1ZS4gVXNpbmcgdGhlIGRlZmF1bHQgYHRvU3RyaW5nYCBtZXRob2QgYXZhaWxhYmxlIG9uIGV2ZXJ5IG9iamVjdCBpcyBhbG1vc3QgY2VydGFpbmx5IGFuIGVycm9yLiBDb25zaWRlciB3aGV0aGVyIHRoZSBgY2hpbGRyZW5gIG9mIHRoaXMgPHRpdGxlPiBpcyBhbiBvYmplY3QgaW4gZXJyb3IgYW5kIGNoYW5nZSBpdCB0byBhIHN0cmluZyBvciBudW1iZXIgdmFsdWUgaWYgc28uIE90aGVyd2lzZSBpbXBsZW1lbnQgYSBgdG9TdHJpbmdgIG1ldGhvZCB0aGF0IFJlYWN0IGNhbiB1c2UgdG8gcHJvZHVjZSBhIHZhbGlkIDx0aXRsZT4uXCJcbiAgICAgICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgaW5zZXJ0aW9uTW9kZSA9PT0gU1ZHX01PREUgfHxcbiAgICAgICAgICAgIG5vc2NyaXB0VGFnSW5TY29wZSB8fFxuICAgICAgICAgICAgbnVsbCAhPSBwcm9wcy5pdGVtUHJvcFxuICAgICAgICAgIClcbiAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDQgPSBwdXNoVGl0bGVJbXBsKFxuICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICAgIHByb3BzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGlzRmFsbGJhY2tcbiAgICAgICAgICAgICAgPyAoSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ0ID0gbnVsbClcbiAgICAgICAgICAgICAgOiAocHVzaFRpdGxlSW1wbChyZW5kZXJTdGF0ZS5ob2lzdGFibGVDaHVua3MsIHByb3BzKSxcbiAgICAgICAgICAgICAgICAoSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ0ID0gdm9pZCAwKSk7XG4gICAgICAgICAgcmV0dXJuIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkNDtcbiAgICAgICAgY2FzZSBcImxpbmtcIjpcbiAgICAgICAgICB2YXIgcmVsID0gcHJvcHMucmVsLFxuICAgICAgICAgICAgaHJlZiA9IHByb3BzLmhyZWYsXG4gICAgICAgICAgICBwcmVjZWRlbmNlID0gcHJvcHMucHJlY2VkZW5jZTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBmb3JtYXRDb250ZXh0Lmluc2VydGlvbk1vZGUgPT09IFNWR19NT0RFIHx8XG4gICAgICAgICAgICBmb3JtYXRDb250ZXh0LnRhZ1Njb3BlICYgMSB8fFxuICAgICAgICAgICAgbnVsbCAhPSBwcm9wcy5pdGVtUHJvcCB8fFxuICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIHJlbCB8fFxuICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIGhyZWYgfHxcbiAgICAgICAgICAgIFwiXCIgPT09IGhyZWZcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIFwic3R5bGVzaGVldFwiID09PSByZWwgJiZcbiAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHByb3BzLnByZWNlZGVuY2UgJiZcbiAgICAgICAgICAgICAgKChcInN0cmluZ1wiID09PSB0eXBlb2YgaHJlZiAmJiBocmVmKSB8fFxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAnUmVhY3QgZW5jb3VudGVyZWQgYSBgPGxpbmsgcmVsPVwic3R5bGVzaGVldFwiIC4uLi8+YCB3aXRoIGEgYHByZWNlZGVuY2VgIHByb3AgYW5kIGV4cGVjdGVkIHRoZSBgaHJlZmAgcHJvcCB0byBiZSBhIG5vbi1lbXB0eSBzdHJpbmcgYnV0IGVjb3VudGVyZWQgJXMgaW5zdGVhZC4gSWYgeW91ciBpbnRlbnQgd2FzIHRvIGhhdmUgUmVhY3QgaG9pc3QgYW5kIGRlZHVwbGNpYXRlIHRoaXMgc3R5bGVzaGVldCB1c2luZyB0aGUgYHByZWNlZGVuY2VgIHByb3AgZW5zdXJlIHRoZXJlIGlzIGEgbm9uLWVtcHR5IHN0cmluZyBgaHJlZmAgcHJvcCBhcyB3ZWxsLCBvdGhlcndpc2UgcmVtb3ZlIHRoZSBgcHJlY2VkZW5jZWAgcHJvcC4nLFxuICAgICAgICAgICAgICAgICAgbnVsbCA9PT0gaHJlZlxuICAgICAgICAgICAgICAgICAgICA/IFwiYG51bGxgXCJcbiAgICAgICAgICAgICAgICAgICAgOiB2b2lkIDAgPT09IGhyZWZcbiAgICAgICAgICAgICAgICAgICAgICA/IFwiYHVuZGVmaW5lZGBcIlxuICAgICAgICAgICAgICAgICAgICAgIDogXCJcIiA9PT0gaHJlZlxuICAgICAgICAgICAgICAgICAgICAgICAgPyBcImFuIGVtcHR5IHN0cmluZ1wiXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICdzb21ldGhpbmcgd2l0aCB0eXBlIFwiJyArIHR5cGVvZiBocmVmICsgJ1wiJ1xuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgcHVzaExpbmtJbXBsKHRhcmdldCRqc2NvbXAkMCwgcHJvcHMpO1xuICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkNSA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIGlmIChcInN0eWxlc2hlZXRcIiA9PT0gcHJvcHMucmVsKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2YgcHJlY2VkZW5jZSB8fFxuICAgICAgICAgICAgICBudWxsICE9IHByb3BzLmRpc2FibGVkIHx8XG4gICAgICAgICAgICAgIHByb3BzLm9uTG9hZCB8fFxuICAgICAgICAgICAgICBwcm9wcy5vbkVycm9yXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBwcmVjZWRlbmNlKVxuICAgICAgICAgICAgICAgIGlmIChudWxsICE9IHByb3BzLmRpc2FibGVkKVxuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgJ1JlYWN0IGVuY291bnRlcmVkIGEgYDxsaW5rIHJlbD1cInN0eWxlc2hlZXRcIiAuLi4vPmAgd2l0aCBhIGBwcmVjZWRlbmNlYCBwcm9wIGFuZCBhIGBkaXNhYmxlZGAgcHJvcC4gVGhlIHByZXNlbmNlIG9mIHRoZSBgZGlzYWJsZWRgIHByb3AgaW5kaWNhdGVzIGFuIGludGVudCB0byBtYW5hZ2UgdGhlIHN0eWxlc2hlZXQgYWN0aXZlIHN0YXRlIGZyb20geW91ciBmcm9tIHlvdXIgQ29tcG9uZW50IGNvZGUgYW5kIFJlYWN0IHdpbGwgbm90IGhvaXN0IG9yIGRlZHVwbGljYXRlIHRoaXMgc3R5bGVzaGVldC4gSWYgeW91ciBpbnRlbnQgd2FzIHRvIGhhdmUgUmVhY3QgaG9pc3QgYW5kIGRlZHVwbGNpYXRlIHRoaXMgc3R5bGVzaGVldCB1c2luZyB0aGUgYHByZWNlZGVuY2VgIHByb3AgcmVtb3ZlIHRoZSBgZGlzYWJsZWRgIHByb3AsIG90aGVyd2lzZSByZW1vdmUgdGhlIGBwcmVjZWRlbmNlYCBwcm9wLidcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJvcHMub25Mb2FkIHx8IHByb3BzLm9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBwcm9wRGVzY3JpcHRpb24gPVxuICAgICAgICAgICAgICAgICAgICBwcm9wcy5vbkxvYWQgJiYgcHJvcHMub25FcnJvclxuICAgICAgICAgICAgICAgICAgICAgID8gXCJgb25Mb2FkYCBhbmQgYG9uRXJyb3JgIHByb3BzXCJcbiAgICAgICAgICAgICAgICAgICAgICA6IHByb3BzLm9uTG9hZFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBcImBvbkxvYWRgIHByb3BcIlxuICAgICAgICAgICAgICAgICAgICAgICAgOiBcImBvbkVycm9yYCBwcm9wXCI7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAnUmVhY3QgZW5jb3VudGVyZWQgYSBgPGxpbmsgcmVsPVwic3R5bGVzaGVldFwiIC4uLi8+YCB3aXRoIGEgYHByZWNlZGVuY2VgIHByb3AgYW5kICVzLiBUaGUgcHJlc2VuY2Ugb2YgbG9hZGluZyBhbmQgZXJyb3IgaGFuZGxlcnMgaW5kaWNhdGVzIGFuIGludGVudCB0byBtYW5hZ2UgdGhlIHN0eWxlc2hlZXQgbG9hZGluZyBzdGF0ZSBmcm9tIHlvdXIgZnJvbSB5b3VyIENvbXBvbmVudCBjb2RlIGFuZCBSZWFjdCB3aWxsIG5vdCBob2lzdCBvciBkZWR1cGxpY2F0ZSB0aGlzIHN0eWxlc2hlZXQuIElmIHlvdXIgaW50ZW50IHdhcyB0byBoYXZlIFJlYWN0IGhvaXN0IGFuZCBkZWR1cGxjaWF0ZSB0aGlzIHN0eWxlc2hlZXQgdXNpbmcgdGhlIGBwcmVjZWRlbmNlYCBwcm9wIHJlbW92ZSB0aGUgJXMsIG90aGVyd2lzZSByZW1vdmUgdGhlIGBwcmVjZWRlbmNlYCBwcm9wLicsXG4gICAgICAgICAgICAgICAgICAgIHByb3BEZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgcHJvcERlc2NyaXB0aW9uXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ1ID0gcHVzaExpbmtJbXBsKFxuICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICBwcm9wc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHN0eWxlUXVldWUgPSByZW5kZXJTdGF0ZS5zdHlsZXMuZ2V0KHByZWNlZGVuY2UpLFxuICAgICAgICAgICAgICAgIHJlc291cmNlU3RhdGUgPSByZXN1bWFibGVTdGF0ZS5zdHlsZVJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShcbiAgICAgICAgICAgICAgICAgIGhyZWZcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICA/IHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzW2hyZWZdXG4gICAgICAgICAgICAgICAgICA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgaWYgKHJlc291cmNlU3RhdGUgIT09IEVYSVNUUykge1xuICAgICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzW2hyZWZdID0gRVhJU1RTO1xuICAgICAgICAgICAgICAgIHN0eWxlUXVldWUgfHxcbiAgICAgICAgICAgICAgICAgICgoc3R5bGVRdWV1ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihwcmVjZWRlbmNlKSksXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgaHJlZnM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBzaGVldHM6IG5ldyBNYXAoKVxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5zdHlsZXMuc2V0KHByZWNlZGVuY2UsIHN0eWxlUXVldWUpKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVzb3VyY2UgPSB7XG4gICAgICAgICAgICAgICAgICBzdGF0ZTogUEVORElORyQxLFxuICAgICAgICAgICAgICAgICAgcHJvcHM6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICAgICAgICAgICAgXCJkYXRhLXByZWNlZGVuY2VcIjogcHJvcHMucHJlY2VkZW5jZSxcbiAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogbnVsbFxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChyZXNvdXJjZVN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAyID09PSByZXNvdXJjZVN0YXRlLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICBhZG9wdFByZWxvYWRDcmVkZW50aWFscyhyZXNvdXJjZS5wcm9wcywgcmVzb3VyY2VTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICB2YXIgcHJlbG9hZFJlc291cmNlID1cbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUucHJlbG9hZHMuc3R5bGVzaGVldHMuZ2V0KGhyZWYpO1xuICAgICAgICAgICAgICAgICAgcHJlbG9hZFJlc291cmNlICYmIDAgPCBwcmVsb2FkUmVzb3VyY2UubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgID8gKHByZWxvYWRSZXNvdXJjZS5sZW5ndGggPSAwKVxuICAgICAgICAgICAgICAgICAgICA6IChyZXNvdXJjZS5zdGF0ZSA9IFBSRUxPQURFRCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0eWxlUXVldWUuc2hlZXRzLnNldChocmVmLCByZXNvdXJjZSk7XG4gICAgICAgICAgICAgICAgaG9pc3RhYmxlU3RhdGUgJiYgaG9pc3RhYmxlU3RhdGUuc3R5bGVzaGVldHMuYWRkKHJlc291cmNlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHlsZVF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9yZXNvdXJjZSA9IHN0eWxlUXVldWUuc2hlZXRzLmdldChocmVmKTtcbiAgICAgICAgICAgICAgICBfcmVzb3VyY2UgJiZcbiAgICAgICAgICAgICAgICAgIGhvaXN0YWJsZVN0YXRlICYmXG4gICAgICAgICAgICAgICAgICBob2lzdGFibGVTdGF0ZS5zdHlsZXNoZWV0cy5hZGQoX3Jlc291cmNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0ZXh0RW1iZWRkZWQgJiYgdGFyZ2V0JGpzY29tcCQwLnB1c2godGV4dFNlcGFyYXRvcik7XG4gICAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkNSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgcHJvcHMub25Mb2FkIHx8IHByb3BzLm9uRXJyb3JcbiAgICAgICAgICAgICAgPyAoSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ1ID0gcHVzaExpbmtJbXBsKFxuICAgICAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgcHJvcHNcbiAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICA6ICh0ZXh0RW1iZWRkZWQgJiYgdGFyZ2V0JGpzY29tcCQwLnB1c2godGV4dFNlcGFyYXRvciksXG4gICAgICAgICAgICAgICAgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkNSA9IGlzRmFsbGJhY2tcbiAgICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgICAgOiBwdXNoTGlua0ltcGwocmVuZGVyU3RhdGUuaG9pc3RhYmxlQ2h1bmtzLCBwcm9wcykpKTtcbiAgICAgICAgICByZXR1cm4gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ1O1xuICAgICAgICBjYXNlIFwic2NyaXB0XCI6XG4gICAgICAgICAgdmFyIGFzeW5jUHJvcCA9IHByb3BzLmFzeW5jO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIFwic3RyaW5nXCIgIT09IHR5cGVvZiBwcm9wcy5zcmMgfHxcbiAgICAgICAgICAgICFwcm9wcy5zcmMgfHxcbiAgICAgICAgICAgICFhc3luY1Byb3AgfHxcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGFzeW5jUHJvcCB8fFxuICAgICAgICAgICAgXCJzeW1ib2xcIiA9PT0gdHlwZW9mIGFzeW5jUHJvcCB8fFxuICAgICAgICAgICAgcHJvcHMub25Mb2FkIHx8XG4gICAgICAgICAgICBwcm9wcy5vbkVycm9yIHx8XG4gICAgICAgICAgICBmb3JtYXRDb250ZXh0Lmluc2VydGlvbk1vZGUgPT09IFNWR19NT0RFIHx8XG4gICAgICAgICAgICBmb3JtYXRDb250ZXh0LnRhZ1Njb3BlICYgMSB8fFxuICAgICAgICAgICAgbnVsbCAhPSBwcm9wcy5pdGVtUHJvcFxuICAgICAgICAgIClcbiAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDYgPSBwdXNoU2NyaXB0SW1wbChcbiAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLFxuICAgICAgICAgICAgICBwcm9wc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBwcm9wcy5zcmM7XG4gICAgICAgICAgICBpZiAoXCJtb2R1bGVcIiA9PT0gcHJvcHMudHlwZSkge1xuICAgICAgICAgICAgICB2YXIgcmVzb3VyY2VzID0gcmVzdW1hYmxlU3RhdGUubW9kdWxlU2NyaXB0UmVzb3VyY2VzO1xuICAgICAgICAgICAgICB2YXIgcHJlbG9hZHMgPSByZW5kZXJTdGF0ZS5wcmVsb2Fkcy5tb2R1bGVTY3JpcHRzO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgIChyZXNvdXJjZXMgPSByZXN1bWFibGVTdGF0ZS5zY3JpcHRSZXNvdXJjZXMpLFxuICAgICAgICAgICAgICAgIChwcmVsb2FkcyA9IHJlbmRlclN0YXRlLnByZWxvYWRzLnNjcmlwdHMpO1xuICAgICAgICAgICAgdmFyIHJlc291cmNlU3RhdGUkanNjb21wJDAgPSByZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoa2V5KVxuICAgICAgICAgICAgICA/IHJlc291cmNlc1trZXldXG4gICAgICAgICAgICAgIDogdm9pZCAwO1xuICAgICAgICAgICAgaWYgKHJlc291cmNlU3RhdGUkanNjb21wJDAgIT09IEVYSVNUUykge1xuICAgICAgICAgICAgICByZXNvdXJjZXNba2V5XSA9IEVYSVNUUztcbiAgICAgICAgICAgICAgdmFyIHNjcmlwdFByb3BzID0gcHJvcHM7XG4gICAgICAgICAgICAgIGlmIChyZXNvdXJjZVN0YXRlJGpzY29tcCQwKSB7XG4gICAgICAgICAgICAgICAgMiA9PT0gcmVzb3VyY2VTdGF0ZSRqc2NvbXAkMC5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICgoc2NyaXB0UHJvcHMgPSBhc3NpZ24oe30sIHByb3BzKSksXG4gICAgICAgICAgICAgICAgICBhZG9wdFByZWxvYWRDcmVkZW50aWFscyhzY3JpcHRQcm9wcywgcmVzb3VyY2VTdGF0ZSRqc2NvbXAkMCkpO1xuICAgICAgICAgICAgICAgIHZhciBwcmVsb2FkUmVzb3VyY2UkanNjb21wJDAgPSBwcmVsb2Fkcy5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICBwcmVsb2FkUmVzb3VyY2UkanNjb21wJDAgJiZcbiAgICAgICAgICAgICAgICAgIChwcmVsb2FkUmVzb3VyY2UkanNjb21wJDAubGVuZ3RoID0gMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIHJlc291cmNlJGpzY29tcCQwID0gW107XG4gICAgICAgICAgICAgIHJlbmRlclN0YXRlLnNjcmlwdHMuYWRkKHJlc291cmNlJGpzY29tcCQwKTtcbiAgICAgICAgICAgICAgcHVzaFNjcmlwdEltcGwocmVzb3VyY2UkanNjb21wJDAsIHNjcmlwdFByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRleHRFbWJlZGRlZCAmJiB0YXJnZXQkanNjb21wJDAucHVzaCh0ZXh0U2VwYXJhdG9yKTtcbiAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkNiA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDY7XG4gICAgICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgICAgIHZhciBpbnNlcnRpb25Nb2RlJGpzY29tcCQwID0gZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlLFxuICAgICAgICAgICAgbm9zY3JpcHRUYWdJblNjb3BlJGpzY29tcCQwID0gISEoZm9ybWF0Q29udGV4dC50YWdTY29wZSAmIDEpO1xuICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBcImNoaWxkcmVuXCIpKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4kanNjb21wJDcgPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgICAgICAgICAgY2hpbGQkanNjb21wJDAgPSBBcnJheS5pc0FycmF5KGNoaWxkcmVuJGpzY29tcCQ3KVxuICAgICAgICAgICAgICAgID8gMiA+IGNoaWxkcmVuJGpzY29tcCQ3Lmxlbmd0aFxuICAgICAgICAgICAgICAgICAgPyBjaGlsZHJlbiRqc2NvbXAkN1swXVxuICAgICAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgICAgICAgOiBjaGlsZHJlbiRqc2NvbXAkNztcbiAgICAgICAgICAgIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjaGlsZCRqc2NvbXAkMCB8fFxuICAgICAgICAgICAgICBcInN5bWJvbFwiID09PSB0eXBlb2YgY2hpbGQkanNjb21wJDAgfHxcbiAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShjaGlsZCRqc2NvbXAkMCkpICYmXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJSZWFjdCBleHBlY3QgY2hpbGRyZW4gb2YgPHN0eWxlPiB0YWdzIHRvIGJlIGEgc3RyaW5nLCBudW1iZXIsIG9yIG9iamVjdCB3aXRoIGEgYHRvU3RyaW5nYCBtZXRob2QgYnV0IGZvdW5kICVzIGluc3RlYWQuIEluIGJyb3dzZXJzIHN0eWxlIEVsZW1lbnRzIGNhbiBvbmx5IGhhdmUgYFRleHRgIE5vZGVzIGFzIGNoaWxkcmVuLlwiLFxuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNoaWxkJGpzY29tcCQwXG4gICAgICAgICAgICAgICAgICA/IFwiYSBGdW5jdGlvblwiXG4gICAgICAgICAgICAgICAgICA6IFwic3ltYm9sXCIgPT09IHR5cGVvZiBjaGlsZCRqc2NvbXAkMFxuICAgICAgICAgICAgICAgICAgICA/IFwiYSBTeWJtb2xcIlxuICAgICAgICAgICAgICAgICAgICA6IFwiYW4gQXJyYXlcIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcHJlY2VkZW5jZSRqc2NvbXAkMCA9IHByb3BzLnByZWNlZGVuY2UsXG4gICAgICAgICAgICBocmVmJGpzY29tcCQwID0gcHJvcHMuaHJlZjtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBpbnNlcnRpb25Nb2RlJGpzY29tcCQwID09PSBTVkdfTU9ERSB8fFxuICAgICAgICAgICAgbm9zY3JpcHRUYWdJblNjb3BlJGpzY29tcCQwIHx8XG4gICAgICAgICAgICBudWxsICE9IHByb3BzLml0ZW1Qcm9wIHx8XG4gICAgICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2YgcHJlY2VkZW5jZSRqc2NvbXAkMCB8fFxuICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIGhyZWYkanNjb21wJDAgfHxcbiAgICAgICAgICAgIFwiXCIgPT09IGhyZWYkanNjb21wJDBcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoXCJzdHlsZVwiKSk7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4kanNjb21wJDggPSBudWxsLFxuICAgICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDUgPSBudWxsLFxuICAgICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQ4O1xuICAgICAgICAgICAgZm9yIChwcm9wS2V5JGpzY29tcCQ4IGluIHByb3BzKVxuICAgICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSRqc2NvbXAkOCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcFZhbHVlJGpzY29tcCQ4ID0gcHJvcHNbcHJvcEtleSRqc2NvbXAkOF07XG4gICAgICAgICAgICAgICAgaWYgKG51bGwgIT0gcHJvcFZhbHVlJGpzY29tcCQ4KVxuICAgICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5JGpzY29tcCQ4KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuJGpzY29tcCQ4ID0gcHJvcFZhbHVlJGpzY29tcCQ4O1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDUgPSBwcm9wVmFsdWUkanNjb21wJDg7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BLZXkkanNjb21wJDgsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wVmFsdWUkanNjb21wJDhcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgICAgICAgICAgIHZhciBjaGlsZCRqc2NvbXAkMSA9IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4kanNjb21wJDgpXG4gICAgICAgICAgICAgID8gMiA+IGNoaWxkcmVuJGpzY29tcCQ4Lmxlbmd0aFxuICAgICAgICAgICAgICAgID8gY2hpbGRyZW4kanNjb21wJDhbMF1cbiAgICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICAgICAgOiBjaGlsZHJlbiRqc2NvbXAkODtcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGNoaWxkJGpzY29tcCQxICYmXG4gICAgICAgICAgICAgIFwic3ltYm9sXCIgIT09IHR5cGVvZiBjaGlsZCRqc2NvbXAkMSAmJlxuICAgICAgICAgICAgICBudWxsICE9PSBjaGlsZCRqc2NvbXAkMSAmJlxuICAgICAgICAgICAgICB2b2lkIDAgIT09IGNoaWxkJGpzY29tcCQxICYmXG4gICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKFxuICAgICAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsoZXNjYXBlU3R5bGVUZXh0Q29udGVudChjaGlsZCRqc2NvbXAkMSkpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBwdXNoSW5uZXJIVE1MKFxuICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICAgIGlubmVySFRNTCRqc2NvbXAkNSxcbiAgICAgICAgICAgICAgY2hpbGRyZW4kanNjb21wJDhcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChlbmRDaHVua0ZvclRhZyhcInN0eWxlXCIpKTtcbiAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDcgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBocmVmJGpzY29tcCQwLmluY2x1ZGVzKFwiIFwiKSAmJlxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICdSZWFjdCBleHBlY3RlZCB0aGUgYGhyZWZgIHByb3AgZm9yIGEgPHN0eWxlPiB0YWcgb3B0aW5nIGludG8gaG9pc3Rpbmcgc2VtYW50aWNzIHVzaW5nIHRoZSBgcHJlY2VkZW5jZWAgcHJvcCB0byBub3QgaGF2ZSBhbnkgc3BhY2VzIGJ1dCBlY291bnRlcmVkIHNwYWNlcyBpbnN0ZWFkLiB1c2luZyBzcGFjZXMgaW4gdGhpcyBwcm9wIHdpbGwgY2F1c2UgaHlkcmF0aW9uIG9mIHRoaXMgc3R5bGUgdG8gZmFpbCBvbiB0aGUgY2xpZW50LiBUaGUgaHJlZiBmb3IgdGhlIDxzdHlsZT4gd2hlcmUgdGhpcyBvY3VycmVkIGlzIFwiJXNcIi4nLFxuICAgICAgICAgICAgICAgIGhyZWYkanNjb21wJDBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHZhciBzdHlsZVF1ZXVlJGpzY29tcCQwID1cbiAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5zdHlsZXMuZ2V0KHByZWNlZGVuY2UkanNjb21wJDApLFxuICAgICAgICAgICAgICByZXNvdXJjZVN0YXRlJGpzY29tcCQxID1cbiAgICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZS5zdHlsZVJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShocmVmJGpzY29tcCQwKVxuICAgICAgICAgICAgICAgICAgPyByZXN1bWFibGVTdGF0ZS5zdHlsZVJlc291cmNlc1tocmVmJGpzY29tcCQwXVxuICAgICAgICAgICAgICAgICAgOiB2b2lkIDA7XG4gICAgICAgICAgICBpZiAocmVzb3VyY2VTdGF0ZSRqc2NvbXAkMSAhPT0gRVhJU1RTKSB7XG4gICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzW2hyZWYkanNjb21wJDBdID0gRVhJU1RTO1xuICAgICAgICAgICAgICByZXNvdXJjZVN0YXRlJGpzY29tcCQxICYmXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICdSZWFjdCBlbmNvdW50ZXJlZCBhIGhvaXN0YWJsZSBzdHlsZSB0YWcgZm9yIHRoZSBzYW1lIGhyZWYgYXMgYSBwcmVsb2FkOiBcIiVzXCIuIFdoZW4gdXNpbmcgYSBzdHlsZSB0YWcgdG8gaW5saW5lIHN0eWxlcyB5b3Ugc2hvdWxkIG5vdCBhbHNvIHByZWxvYWQgaXQgYXMgYSBzdHlsc2hlZXQuJyxcbiAgICAgICAgICAgICAgICAgIGhyZWYkanNjb21wJDBcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBzdHlsZVF1ZXVlJGpzY29tcCQwXG4gICAgICAgICAgICAgICAgPyBzdHlsZVF1ZXVlJGpzY29tcCQwLmhyZWZzLnB1c2goXG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoaHJlZiRqc2NvbXAkMCkpXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgOiAoKHN0eWxlUXVldWUkanNjb21wJDAgPSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IHN0cmluZ1RvQ2h1bmsoXG4gICAgICAgICAgICAgICAgICAgICAgZXNjYXBlVGV4dEZvckJyb3dzZXIocHJlY2VkZW5jZSRqc2NvbXAkMClcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgcnVsZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBocmVmczogW3N0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoaHJlZiRqc2NvbXAkMCkpXSxcbiAgICAgICAgICAgICAgICAgICAgc2hlZXRzOiBuZXcgTWFwKClcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuc3R5bGVzLnNldChcbiAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZSRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVRdWV1ZSRqc2NvbXAkMFxuICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBzdHlsZVF1ZXVlJGpzY29tcCQwLnJ1bGVzLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuJGpzY29tcCQ5ID0gbnVsbCxcbiAgICAgICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDYgPSBudWxsLFxuICAgICAgICAgICAgICAgIHByb3BLZXkkanNjb21wJDk7XG4gICAgICAgICAgICAgIGZvciAocHJvcEtleSRqc2NvbXAkOSBpbiBwcm9wcylcbiAgICAgICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSRqc2NvbXAkOSkpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBwcm9wVmFsdWUkanNjb21wJDkgPSBwcm9wc1twcm9wS2V5JGpzY29tcCQ5XTtcbiAgICAgICAgICAgICAgICAgIGlmIChudWxsICE9IHByb3BWYWx1ZSRqc2NvbXAkOSlcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5JGpzY29tcCQ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbiRqc2NvbXAkOSA9IHByb3BWYWx1ZSRqc2NvbXAkOTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJIVE1MJGpzY29tcCQ2ID0gcHJvcFZhbHVlJGpzY29tcCQ5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgY2hpbGQkanNjb21wJDIgPSBBcnJheS5pc0FycmF5KGNoaWxkcmVuJGpzY29tcCQ5KVxuICAgICAgICAgICAgICAgID8gMiA+IGNoaWxkcmVuJGpzY29tcCQ5Lmxlbmd0aFxuICAgICAgICAgICAgICAgICAgPyBjaGlsZHJlbiRqc2NvbXAkOVswXVxuICAgICAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgICAgICAgOiBjaGlsZHJlbiRqc2NvbXAkOTtcbiAgICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgY2hpbGQkanNjb21wJDIgJiZcbiAgICAgICAgICAgICAgICBcInN5bWJvbFwiICE9PSB0eXBlb2YgY2hpbGQkanNjb21wJDIgJiZcbiAgICAgICAgICAgICAgICBudWxsICE9PSBjaGlsZCRqc2NvbXAkMiAmJlxuICAgICAgICAgICAgICAgIHZvaWQgMCAhPT0gY2hpbGQkanNjb21wJDIgJiZcbiAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChcbiAgICAgICAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsoZXNjYXBlU3R5bGVUZXh0Q29udGVudChjaGlsZCRqc2NvbXAkMikpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcHVzaElubmVySFRNTCh0YXJnZXQsIGlubmVySFRNTCRqc2NvbXAkNiwgY2hpbGRyZW4kanNjb21wJDkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3R5bGVRdWV1ZSRqc2NvbXAkMCAmJlxuICAgICAgICAgICAgICBob2lzdGFibGVTdGF0ZSAmJlxuICAgICAgICAgICAgICBob2lzdGFibGVTdGF0ZS5zdHlsZXMuYWRkKHN0eWxlUXVldWUkanNjb21wJDApO1xuICAgICAgICAgICAgdGV4dEVtYmVkZGVkICYmIHRhcmdldCRqc2NvbXAkMC5wdXNoKHRleHRTZXBhcmF0b3IpO1xuICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ3ID0gdm9pZCAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ3O1xuICAgICAgICBjYXNlIFwibWV0YVwiOlxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSA9PT0gU1ZHX01PREUgfHxcbiAgICAgICAgICAgIGZvcm1hdENvbnRleHQudGFnU2NvcGUgJiAxIHx8XG4gICAgICAgICAgICBudWxsICE9IHByb3BzLml0ZW1Qcm9wXG4gICAgICAgICAgKVxuICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkOCA9IHB1c2hTZWxmQ2xvc2luZyhcbiAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLFxuICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgICAgXCJtZXRhXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGV4dEVtYmVkZGVkICYmIHRhcmdldCRqc2NvbXAkMC5wdXNoKHRleHRTZXBhcmF0b3IpLFxuICAgICAgICAgICAgICAoSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ4ID0gaXNGYWxsYmFja1xuICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgIDogXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHByb3BzLmNoYXJTZXRcbiAgICAgICAgICAgICAgICAgID8gcHVzaFNlbGZDbG9zaW5nKHJlbmRlclN0YXRlLmNoYXJzZXRDaHVua3MsIHByb3BzLCBcIm1ldGFcIilcbiAgICAgICAgICAgICAgICAgIDogXCJ2aWV3cG9ydFwiID09PSBwcm9wcy5uYW1lXG4gICAgICAgICAgICAgICAgICAgID8gcHVzaFNlbGZDbG9zaW5nKHJlbmRlclN0YXRlLnZpZXdwb3J0Q2h1bmtzLCBwcm9wcywgXCJtZXRhXCIpXG4gICAgICAgICAgICAgICAgICAgIDogcHVzaFNlbGZDbG9zaW5nKFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuaG9pc3RhYmxlQ2h1bmtzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIm1ldGFcIlxuICAgICAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgIHJldHVybiBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDg7XG4gICAgICAgIGNhc2UgXCJsaXN0aW5nXCI6XG4gICAgICAgIGNhc2UgXCJwcmVcIjpcbiAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChzdGFydENodW5rRm9yVGFnKHR5cGUpKTtcbiAgICAgICAgICB2YXIgY2hpbGRyZW4kanNjb21wJDEwID0gbnVsbCxcbiAgICAgICAgICAgIGlubmVySFRNTCRqc2NvbXAkNyA9IG51bGwsXG4gICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQxMDtcbiAgICAgICAgICBmb3IgKHByb3BLZXkkanNjb21wJDEwIGluIHByb3BzKVxuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkkanNjb21wJDEwKSkge1xuICAgICAgICAgICAgICB2YXIgcHJvcFZhbHVlJGpzY29tcCQxMCA9IHByb3BzW3Byb3BLZXkkanNjb21wJDEwXTtcbiAgICAgICAgICAgICAgaWYgKG51bGwgIT0gcHJvcFZhbHVlJGpzY29tcCQxMClcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHByb3BLZXkkanNjb21wJDEwKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4kanNjb21wJDEwID0gcHJvcFZhbHVlJGpzY29tcCQxMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJIVE1MJGpzY29tcCQ3ID0gcHJvcFZhbHVlJGpzY29tcCQxMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBwdXNoQXR0cmlidXRlKFxuICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQxMCxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wVmFsdWUkanNjb21wJDEwXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKGVuZE9mU3RhcnRUYWcpO1xuICAgICAgICAgIGlmIChudWxsICE9IGlubmVySFRNTCRqc2NvbXAkNykge1xuICAgICAgICAgICAgaWYgKG51bGwgIT0gY2hpbGRyZW4kanNjb21wJDEwKVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIkNhbiBvbmx5IHNldCBvbmUgb2YgYGNoaWxkcmVuYCBvciBgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIFwib2JqZWN0XCIgIT09IHR5cGVvZiBpbm5lckhUTUwkanNjb21wJDcgfHxcbiAgICAgICAgICAgICAgIShcIl9faHRtbFwiIGluIGlubmVySFRNTCRqc2NvbXAkNylcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIG11c3QgYmUgaW4gdGhlIGZvcm0gYHtfX2h0bWw6IC4uLn1gLiBQbGVhc2UgdmlzaXQgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9kYW5nZXJvdXNseS1zZXQtaW5uZXItaHRtbCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgdmFyIGh0bWwgPSBpbm5lckhUTUwkanNjb21wJDcuX19odG1sO1xuICAgICAgICAgICAgbnVsbCAhPT0gaHRtbCAmJlxuICAgICAgICAgICAgICB2b2lkIDAgIT09IGh0bWwgJiZcbiAgICAgICAgICAgICAgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBodG1sICYmIDAgPCBodG1sLmxlbmd0aCAmJiBcIlxcblwiID09PSBodG1sWzBdXG4gICAgICAgICAgICAgICAgPyB0YXJnZXQkanNjb21wJDAucHVzaChsZWFkaW5nTmV3bGluZSwgc3RyaW5nVG9DaHVuayhodG1sKSlcbiAgICAgICAgICAgICAgICA6IChjaGVja0h0bWxTdHJpbmdDb2VyY2lvbihodG1sKSxcbiAgICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKHN0cmluZ1RvQ2h1bmsoXCJcIiArIGh0bWwpKSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgY2hpbGRyZW4kanNjb21wJDEwICYmXG4gICAgICAgICAgICBcIlxcblwiID09PSBjaGlsZHJlbiRqc2NvbXAkMTBbMF0gJiZcbiAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKGxlYWRpbmdOZXdsaW5lKTtcbiAgICAgICAgICByZXR1cm4gY2hpbGRyZW4kanNjb21wJDEwO1xuICAgICAgICBjYXNlIFwiaW1nXCI6XG4gICAgICAgICAgdmFyIHNyYyA9IHByb3BzLnNyYyxcbiAgICAgICAgICAgIHNyY1NldCA9IHByb3BzLnNyY1NldDtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhKFxuICAgICAgICAgICAgICBcImxhenlcIiA9PT0gcHJvcHMubG9hZGluZyB8fFxuICAgICAgICAgICAgICAoIXNyYyAmJiAhc3JjU2V0KSB8fFxuICAgICAgICAgICAgICAoXCJzdHJpbmdcIiAhPT0gdHlwZW9mIHNyYyAmJiBudWxsICE9IHNyYykgfHxcbiAgICAgICAgICAgICAgKFwic3RyaW5nXCIgIT09IHR5cGVvZiBzcmNTZXQgJiYgbnVsbCAhPSBzcmNTZXQpXG4gICAgICAgICAgICApICYmXG4gICAgICAgICAgICBcImxvd1wiICE9PSBwcm9wcy5mZXRjaFByaW9yaXR5ICYmXG4gICAgICAgICAgICAhMSA9PT0gISEoZm9ybWF0Q29udGV4dC50YWdTY29wZSAmIDMpICYmXG4gICAgICAgICAgICAoXCJzdHJpbmdcIiAhPT0gdHlwZW9mIHNyYyB8fFxuICAgICAgICAgICAgICBcIjpcIiAhPT0gc3JjWzRdIHx8XG4gICAgICAgICAgICAgIChcImRcIiAhPT0gc3JjWzBdICYmIFwiRFwiICE9PSBzcmNbMF0pIHx8XG4gICAgICAgICAgICAgIChcImFcIiAhPT0gc3JjWzFdICYmIFwiQVwiICE9PSBzcmNbMV0pIHx8XG4gICAgICAgICAgICAgIChcInRcIiAhPT0gc3JjWzJdICYmIFwiVFwiICE9PSBzcmNbMl0pIHx8XG4gICAgICAgICAgICAgIChcImFcIiAhPT0gc3JjWzNdICYmIFwiQVwiICE9PSBzcmNbM10pKSAmJlxuICAgICAgICAgICAgKFwic3RyaW5nXCIgIT09IHR5cGVvZiBzcmNTZXQgfHxcbiAgICAgICAgICAgICAgXCI6XCIgIT09IHNyY1NldFs0XSB8fFxuICAgICAgICAgICAgICAoXCJkXCIgIT09IHNyY1NldFswXSAmJiBcIkRcIiAhPT0gc3JjU2V0WzBdKSB8fFxuICAgICAgICAgICAgICAoXCJhXCIgIT09IHNyY1NldFsxXSAmJiBcIkFcIiAhPT0gc3JjU2V0WzFdKSB8fFxuICAgICAgICAgICAgICAoXCJ0XCIgIT09IHNyY1NldFsyXSAmJiBcIlRcIiAhPT0gc3JjU2V0WzJdKSB8fFxuICAgICAgICAgICAgICAoXCJhXCIgIT09IHNyY1NldFszXSAmJiBcIkFcIiAhPT0gc3JjU2V0WzNdKSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciBzaXplcyA9IFwic3RyaW5nXCIgPT09IHR5cGVvZiBwcm9wcy5zaXplcyA/IHByb3BzLnNpemVzIDogdm9pZCAwLFxuICAgICAgICAgICAgICBrZXkkanNjb21wJDAgPSBzcmNTZXQgPyBzcmNTZXQgKyBcIlxcblwiICsgKHNpemVzIHx8IFwiXCIpIDogc3JjLFxuICAgICAgICAgICAgICBwcm9tb3RhYmxlUHJlbG9hZHMgPSByZW5kZXJTdGF0ZS5wcmVsb2Fkcy5pbWFnZXMsXG4gICAgICAgICAgICAgIHJlc291cmNlJGpzY29tcCQxID0gcHJvbW90YWJsZVByZWxvYWRzLmdldChrZXkkanNjb21wJDApO1xuICAgICAgICAgICAgaWYgKHJlc291cmNlJGpzY29tcCQxKSB7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBcImhpZ2hcIiA9PT0gcHJvcHMuZmV0Y2hQcmlvcml0eSB8fFxuICAgICAgICAgICAgICAgIDEwID4gcmVuZGVyU3RhdGUuaGlnaEltYWdlUHJlbG9hZHMuc2l6ZVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgcHJvbW90YWJsZVByZWxvYWRzLmRlbGV0ZShrZXkkanNjb21wJDApLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuaGlnaEltYWdlUHJlbG9hZHMuYWRkKHJlc291cmNlJGpzY29tcCQxKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICFyZXN1bWFibGVTdGF0ZS5pbWFnZVJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShrZXkkanNjb21wJDApXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUuaW1hZ2VSZXNvdXJjZXNba2V5JGpzY29tcCQwXSA9IFBSRUxPQURfTk9fQ1JFRFM7XG4gICAgICAgICAgICAgIHZhciBpbnB1dCA9IHByb3BzLmNyb3NzT3JpZ2luO1xuICAgICAgICAgICAgICB2YXIgY3Jvc3NPcmlnaW4gPVxuICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBpbnB1dFxuICAgICAgICAgICAgICAgICAgPyBcInVzZS1jcmVkZW50aWFsc1wiID09PSBpbnB1dFxuICAgICAgICAgICAgICAgICAgICA/IGlucHV0XG4gICAgICAgICAgICAgICAgICAgIDogXCJcIlxuICAgICAgICAgICAgICAgICAgOiB2b2lkIDA7XG4gICAgICAgICAgICAgIHZhciBoZWFkZXJzID0gcmVuZGVyU3RhdGUuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBoZWFkZXI7XG4gICAgICAgICAgICAgIGhlYWRlcnMgJiZcbiAgICAgICAgICAgICAgMCA8IGhlYWRlcnMucmVtYWluaW5nQ2FwYWNpdHkgJiZcbiAgICAgICAgICAgICAgKFwiaGlnaFwiID09PSBwcm9wcy5mZXRjaFByaW9yaXR5IHx8XG4gICAgICAgICAgICAgICAgNTAwID4gaGVhZGVycy5oaWdoSW1hZ2VQcmVsb2Fkcy5sZW5ndGgpICYmXG4gICAgICAgICAgICAgICgoaGVhZGVyID0gZ2V0UHJlbG9hZEFzSGVhZGVyKHNyYywgXCJpbWFnZVwiLCB7XG4gICAgICAgICAgICAgICAgaW1hZ2VTcmNTZXQ6IHByb3BzLnNyY1NldCxcbiAgICAgICAgICAgICAgICBpbWFnZVNpemVzOiBwcm9wcy5zaXplcyxcbiAgICAgICAgICAgICAgICBjcm9zc09yaWdpbjogY3Jvc3NPcmlnaW4sXG4gICAgICAgICAgICAgICAgaW50ZWdyaXR5OiBwcm9wcy5pbnRlZ3JpdHksXG4gICAgICAgICAgICAgICAgbm9uY2U6IHByb3BzLm5vbmNlLFxuICAgICAgICAgICAgICAgIHR5cGU6IHByb3BzLnR5cGUsXG4gICAgICAgICAgICAgICAgZmV0Y2hQcmlvcml0eTogcHJvcHMuZmV0Y2hQcmlvcml0eSxcbiAgICAgICAgICAgICAgICByZWZlcnJlclBvbGljeTogcHJvcHMucmVmZXJlclBvbGljeVxuICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICAgIDAgPD0gKGhlYWRlcnMucmVtYWluaW5nQ2FwYWNpdHkgLT0gaGVhZGVyLmxlbmd0aCArIDIpKVxuICAgICAgICAgICAgICAgID8gKChyZW5kZXJTdGF0ZS5yZXNldHMuaW1hZ2Vba2V5JGpzY29tcCQwXSA9IFBSRUxPQURfTk9fQ1JFRFMpLFxuICAgICAgICAgICAgICAgICAgaGVhZGVycy5oaWdoSW1hZ2VQcmVsb2FkcyAmJlxuICAgICAgICAgICAgICAgICAgICAoaGVhZGVycy5oaWdoSW1hZ2VQcmVsb2FkcyArPSBcIiwgXCIpLFxuICAgICAgICAgICAgICAgICAgKGhlYWRlcnMuaGlnaEltYWdlUHJlbG9hZHMgKz0gaGVhZGVyKSlcbiAgICAgICAgICAgICAgICA6ICgocmVzb3VyY2UkanNjb21wJDEgPSBbXSksXG4gICAgICAgICAgICAgICAgICBwdXNoTGlua0ltcGwocmVzb3VyY2UkanNjb21wJDEsIHtcbiAgICAgICAgICAgICAgICAgICAgcmVsOiBcInByZWxvYWRcIixcbiAgICAgICAgICAgICAgICAgICAgYXM6IFwiaW1hZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgaHJlZjogc3JjU2V0ID8gdm9pZCAwIDogc3JjLFxuICAgICAgICAgICAgICAgICAgICBpbWFnZVNyY1NldDogc3JjU2V0LFxuICAgICAgICAgICAgICAgICAgICBpbWFnZVNpemVzOiBzaXplcyxcbiAgICAgICAgICAgICAgICAgICAgY3Jvc3NPcmlnaW46IGNyb3NzT3JpZ2luLFxuICAgICAgICAgICAgICAgICAgICBpbnRlZ3JpdHk6IHByb3BzLmludGVncml0eSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogcHJvcHMudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgZmV0Y2hQcmlvcml0eTogcHJvcHMuZmV0Y2hQcmlvcml0eSxcbiAgICAgICAgICAgICAgICAgICAgcmVmZXJyZXJQb2xpY3k6IHByb3BzLnJlZmVycmVyUG9saWN5XG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgIFwiaGlnaFwiID09PSBwcm9wcy5mZXRjaFByaW9yaXR5IHx8XG4gICAgICAgICAgICAgICAgICAxMCA+IHJlbmRlclN0YXRlLmhpZ2hJbWFnZVByZWxvYWRzLnNpemVcbiAgICAgICAgICAgICAgICAgICAgPyByZW5kZXJTdGF0ZS5oaWdoSW1hZ2VQcmVsb2Fkcy5hZGQocmVzb3VyY2UkanNjb21wJDEpXG4gICAgICAgICAgICAgICAgICAgIDogKHJlbmRlclN0YXRlLmJ1bGtQcmVsb2Fkcy5hZGQocmVzb3VyY2UkanNjb21wJDEpLFxuICAgICAgICAgICAgICAgICAgICAgIHByb21vdGFibGVQcmVsb2Fkcy5zZXQoa2V5JGpzY29tcCQwLCByZXNvdXJjZSRqc2NvbXAkMSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHB1c2hTZWxmQ2xvc2luZyh0YXJnZXQkanNjb21wJDAsIHByb3BzLCBcImltZ1wiKTtcbiAgICAgICAgY2FzZSBcImJhc2VcIjpcbiAgICAgICAgY2FzZSBcImFyZWFcIjpcbiAgICAgICAgY2FzZSBcImJyXCI6XG4gICAgICAgIGNhc2UgXCJjb2xcIjpcbiAgICAgICAgY2FzZSBcImVtYmVkXCI6XG4gICAgICAgIGNhc2UgXCJoclwiOlxuICAgICAgICBjYXNlIFwia2V5Z2VuXCI6XG4gICAgICAgIGNhc2UgXCJwYXJhbVwiOlxuICAgICAgICBjYXNlIFwic291cmNlXCI6XG4gICAgICAgIGNhc2UgXCJ0cmFja1wiOlxuICAgICAgICBjYXNlIFwid2JyXCI6XG4gICAgICAgICAgcmV0dXJuIHB1c2hTZWxmQ2xvc2luZyh0YXJnZXQkanNjb21wJDAsIHByb3BzLCB0eXBlKTtcbiAgICAgICAgY2FzZSBcImFubm90YXRpb24teG1sXCI6XG4gICAgICAgIGNhc2UgXCJjb2xvci1wcm9maWxlXCI6XG4gICAgICAgIGNhc2UgXCJmb250LWZhY2VcIjpcbiAgICAgICAgY2FzZSBcImZvbnQtZmFjZS1zcmNcIjpcbiAgICAgICAgY2FzZSBcImZvbnQtZmFjZS11cmlcIjpcbiAgICAgICAgY2FzZSBcImZvbnQtZmFjZS1mb3JtYXRcIjpcbiAgICAgICAgY2FzZSBcImZvbnQtZmFjZS1uYW1lXCI6XG4gICAgICAgIGNhc2UgXCJtaXNzaW5nLWdseXBoXCI6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJoZWFkXCI6XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlIDwgSFRNTF9NT0RFICYmXG4gICAgICAgICAgICBudWxsID09PSByZW5kZXJTdGF0ZS5oZWFkQ2h1bmtzXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5oZWFkQ2h1bmtzID0gW107XG4gICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ5ID0gcHVzaFN0YXJ0R2VuZXJpY0VsZW1lbnQoXG4gICAgICAgICAgICAgIHJlbmRlclN0YXRlLmhlYWRDaHVua3MsXG4gICAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgICBcImhlYWRcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkOSA9IHB1c2hTdGFydEdlbmVyaWNFbGVtZW50KFxuICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgICBcImhlYWRcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ5O1xuICAgICAgICBjYXNlIFwiaHRtbFwiOlxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSA9PT0gUk9PVF9IVE1MX01PREUgJiZcbiAgICAgICAgICAgIG51bGwgPT09IHJlbmRlclN0YXRlLmh0bWxDaHVua3NcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJlbmRlclN0YXRlLmh0bWxDaHVua3MgPSBbZG9jdHlwZUNodW5rXTtcbiAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDEwID0gcHVzaFN0YXJ0R2VuZXJpY0VsZW1lbnQoXG4gICAgICAgICAgICAgIHJlbmRlclN0YXRlLmh0bWxDaHVua3MsXG4gICAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgICBcImh0bWxcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMTAgPSBwdXNoU3RhcnRHZW5lcmljRWxlbWVudChcbiAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLFxuICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgICAgXCJodG1sXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMTA7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKC0xICE9PSB0eXBlLmluZGV4T2YoXCItXCIpKSB7XG4gICAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChzdGFydENodW5rRm9yVGFnKHR5cGUpKTtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiRqc2NvbXAkMTEgPSBudWxsLFxuICAgICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDggPSBudWxsLFxuICAgICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQxMTtcbiAgICAgICAgICAgIGZvciAocHJvcEtleSRqc2NvbXAkMTEgaW4gcHJvcHMpXG4gICAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5JGpzY29tcCQxMSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcFZhbHVlJGpzY29tcCQxMSA9IHByb3BzW3Byb3BLZXkkanNjb21wJDExXTtcbiAgICAgICAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wVmFsdWUkanNjb21wJDExKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IHByb3BLZXkkanNjb21wJDExO1xuICAgICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5JGpzY29tcCQxMSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbiRqc2NvbXAkMTEgPSBwcm9wVmFsdWUkanNjb21wJDExO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDggPSBwcm9wVmFsdWUkanNjb21wJDExO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3R5bGVcIjpcbiAgICAgICAgICAgICAgICAgICAgICBwdXNoU3R5bGVBdHRyaWJ1dGUodGFyZ2V0JGpzY29tcCQwLCBwcm9wVmFsdWUkanNjb21wJDExKTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZ1wiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJyZWZcIjpcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNsYXNzTmFtZVwiOlxuICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWUgPSBcImNsYXNzXCI7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNBdHRyaWJ1dGVOYW1lU2FmZShwcm9wS2V5JGpzY29tcCQxMSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHByb3BWYWx1ZSRqc2NvbXAkMTEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIFwic3ltYm9sXCIgIT09IHR5cGVvZiBwcm9wVmFsdWUkanNjb21wJDExICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhMSAhPT0gcHJvcFZhbHVlJGpzY29tcCQxMVxuICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEwID09PSBwcm9wVmFsdWUkanNjb21wJDExKVxuICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wVmFsdWUkanNjb21wJDExID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBwcm9wVmFsdWUkanNjb21wJDExKVxuICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVTZXBhcmF0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsoYXR0cmlidXRlTmFtZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUFzc2lnbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nVG9DaHVuayhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVUZXh0Rm9yQnJvd3Nlcihwcm9wVmFsdWUkanNjb21wJDExKVxuICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVFbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gICAgICAgICAgICBwdXNoSW5uZXJIVE1MKFxuICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICAgIGlubmVySFRNTCRqc2NvbXAkOCxcbiAgICAgICAgICAgICAgY2hpbGRyZW4kanNjb21wJDExXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkcmVuJGpzY29tcCQxMTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcHVzaFN0YXJ0R2VuZXJpY0VsZW1lbnQodGFyZ2V0JGpzY29tcCQwLCBwcm9wcywgdHlwZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVuZENodW5rRm9yVGFnKHRhZykge1xuICAgICAgdmFyIGNodW5rID0gZW5kVGFnQ2FjaGUuZ2V0KHRhZyk7XG4gICAgICB2b2lkIDAgPT09IGNodW5rICYmXG4gICAgICAgICgoY2h1bmsgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCI8L1wiICsgdGFnICsgXCI+XCIpKSxcbiAgICAgICAgZW5kVGFnQ2FjaGUuc2V0KHRhZywgY2h1bmspKTtcbiAgICAgIHJldHVybiBjaHVuaztcbiAgICB9XG4gICAgZnVuY3Rpb24gd3JpdGVCb290c3RyYXAoZGVzdGluYXRpb24sIHJlbmRlclN0YXRlKSB7XG4gICAgICByZW5kZXJTdGF0ZSA9IHJlbmRlclN0YXRlLmJvb3RzdHJhcENodW5rcztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVuZGVyU3RhdGUubGVuZ3RoIC0gMTsgaSsrKVxuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZVtpXSk7XG4gICAgICByZXR1cm4gaSA8IHJlbmRlclN0YXRlLmxlbmd0aFxuICAgICAgICA/ICgoaSA9IHJlbmRlclN0YXRlW2ldKSxcbiAgICAgICAgICAocmVuZGVyU3RhdGUubGVuZ3RoID0gMCksXG4gICAgICAgICAgd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgaSkpXG4gICAgICAgIDogITA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdyaXRlU3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeShkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUsIGlkKSB7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdGFydFBlbmRpbmdTdXNwZW5zZUJvdW5kYXJ5MSk7XG4gICAgICBpZiAobnVsbCA9PT0gaWQpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiQW4gSUQgbXVzdCBoYXZlIGJlZW4gYXNzaWduZWQgYmVmb3JlIHdlIGNhbiBjb21wbGV0ZSB0aGUgYm91bmRhcnkuXCJcbiAgICAgICAgKTtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHJlbmRlclN0YXRlLmJvdW5kYXJ5UHJlZml4KTtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoaWQudG9TdHJpbmcoMTYpKSk7XG4gICAgICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgc3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeTIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3cml0ZVN0YXJ0U2VnbWVudChkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUsIGZvcm1hdENvbnRleHQsIGlkKSB7XG4gICAgICBzd2l0Y2ggKGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSkge1xuICAgICAgICBjYXNlIFJPT1RfSFRNTF9NT0RFOlxuICAgICAgICBjYXNlIEhUTUxfSFRNTF9NT0RFOlxuICAgICAgICBjYXNlIEhUTUxfTU9ERTpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RhcnRTZWdtZW50SFRNTCksXG4gICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZS5zZWdtZW50UHJlZml4KSxcbiAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoaWQudG9TdHJpbmcoMTYpKSksXG4gICAgICAgICAgICB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRIVE1MMilcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIFNWR19NT0RFOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRTVkcpLFxuICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUuc2VnbWVudFByZWZpeCksXG4gICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGlkLnRvU3RyaW5nKDE2KSkpLFxuICAgICAgICAgICAgd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgc3RhcnRTZWdtZW50U1ZHMilcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIE1BVEhNTF9NT0RFOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRNYXRoTUwpLFxuICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUuc2VnbWVudFByZWZpeCksXG4gICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGlkLnRvU3RyaW5nKDE2KSkpLFxuICAgICAgICAgICAgd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgc3RhcnRTZWdtZW50TWF0aE1MMilcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIEhUTUxfVEFCTEVfTU9ERTpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RhcnRTZWdtZW50VGFibGUpLFxuICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUuc2VnbWVudFByZWZpeCksXG4gICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGlkLnRvU3RyaW5nKDE2KSkpLFxuICAgICAgICAgICAgd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgc3RhcnRTZWdtZW50VGFibGUyKVxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgSFRNTF9UQUJMRV9CT0RZX01PREU6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0YXJ0U2VnbWVudFRhYmxlQm9keSksXG4gICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZS5zZWdtZW50UHJlZml4KSxcbiAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoaWQudG9TdHJpbmcoMTYpKSksXG4gICAgICAgICAgICB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRUYWJsZUJvZHkyKVxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgSFRNTF9UQUJMRV9ST1dfTU9ERTpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RhcnRTZWdtZW50VGFibGVSb3cpLFxuICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUuc2VnbWVudFByZWZpeCksXG4gICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGlkLnRvU3RyaW5nKDE2KSkpLFxuICAgICAgICAgICAgd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgc3RhcnRTZWdtZW50VGFibGVSb3cyKVxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgSFRNTF9DT0xHUk9VUF9NT0RFOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRDb2xHcm91cCksXG4gICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZS5zZWdtZW50UHJlZml4KSxcbiAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoaWQudG9TdHJpbmcoMTYpKSksXG4gICAgICAgICAgICB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRDb2xHcm91cDIpXG4gICAgICAgICAgKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBFcnJvcihcIlVua25vd24gaW5zZXJ0aW9uIG1vZGUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB3cml0ZUVuZFNlZ21lbnQoZGVzdGluYXRpb24sIGZvcm1hdENvbnRleHQpIHtcbiAgICAgIHN3aXRjaCAoZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlKSB7XG4gICAgICAgIGNhc2UgUk9PVF9IVE1MX01PREU6XG4gICAgICAgIGNhc2UgSFRNTF9IVE1MX01PREU6XG4gICAgICAgIGNhc2UgSFRNTF9NT0RFOlxuICAgICAgICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBlbmRTZWdtZW50SFRNTCk7XG4gICAgICAgIGNhc2UgU1ZHX01PREU6XG4gICAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGVuZFNlZ21lbnRTVkcpO1xuICAgICAgICBjYXNlIE1BVEhNTF9NT0RFOlxuICAgICAgICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBlbmRTZWdtZW50TWF0aE1MKTtcbiAgICAgICAgY2FzZSBIVE1MX1RBQkxFX01PREU6XG4gICAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGVuZFNlZ21lbnRUYWJsZSk7XG4gICAgICAgIGNhc2UgSFRNTF9UQUJMRV9CT0RZX01PREU6XG4gICAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGVuZFNlZ21lbnRUYWJsZUJvZHkpO1xuICAgICAgICBjYXNlIEhUTUxfVEFCTEVfUk9XX01PREU6XG4gICAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGVuZFNlZ21lbnRUYWJsZVJvdyk7XG4gICAgICAgIGNhc2UgSFRNTF9DT0xHUk9VUF9NT0RFOlxuICAgICAgICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBlbmRTZWdtZW50Q29sR3JvdXApO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IEVycm9yKFwiVW5rbm93biBpbnNlcnRpb24gbW9kZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVzY2FwZUpTU3RyaW5nc0Zvckluc3RydWN0aW9uU2NyaXB0cyhpbnB1dCkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGlucHV0KS5yZXBsYWNlKFxuICAgICAgICByZWdleEZvckpTU3RyaW5nc0luSW5zdHJ1Y3Rpb25TY3JpcHRzLFxuICAgICAgICBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgICBzd2l0Y2ggKG1hdGNoKSB7XG4gICAgICAgICAgICBjYXNlIFwiPFwiOlxuICAgICAgICAgICAgICByZXR1cm4gXCJcXFxcdTAwM2NcIjtcbiAgICAgICAgICAgIGNhc2UgXCJcXHUyMDI4XCI6XG4gICAgICAgICAgICAgIHJldHVybiBcIlxcXFx1MjAyOFwiO1xuICAgICAgICAgICAgY2FzZSBcIlxcdTIwMjlcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIFwiXFxcXHUyMDI5XCI7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcImVzY2FwZUpTU3RyaW5nc0Zvckluc3RydWN0aW9uU2NyaXB0cyBlbmNvdW50ZXJlZCBhIG1hdGNoIGl0IGRvZXMgbm90IGtub3cgaG93IHRvIHJlcGxhY2UuIHRoaXMgbWVhbnMgdGhlIG1hdGNoIHJlZ2V4IGFuZCB0aGUgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBhcmUgbm8gbG9uZ2VyIGluIHN5bmMuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3RcIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXNjYXBlSlNPYmplY3RGb3JJbnN0cnVjdGlvblNjcmlwdHMoaW5wdXQpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShpbnB1dCkucmVwbGFjZShcbiAgICAgICAgcmVnZXhGb3JKU1N0cmluZ3NJblNjcmlwdHMsXG4gICAgICAgIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgIHN3aXRjaCAobWF0Y2gpIHtcbiAgICAgICAgICAgIGNhc2UgXCImXCI6XG4gICAgICAgICAgICAgIHJldHVybiBcIlxcXFx1MDAyNlwiO1xuICAgICAgICAgICAgY2FzZSBcIj5cIjpcbiAgICAgICAgICAgICAgcmV0dXJuIFwiXFxcXHUwMDNlXCI7XG4gICAgICAgICAgICBjYXNlIFwiPFwiOlxuICAgICAgICAgICAgICByZXR1cm4gXCJcXFxcdTAwM2NcIjtcbiAgICAgICAgICAgIGNhc2UgXCJcXHUyMDI4XCI6XG4gICAgICAgICAgICAgIHJldHVybiBcIlxcXFx1MjAyOFwiO1xuICAgICAgICAgICAgY2FzZSBcIlxcdTIwMjlcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIFwiXFxcXHUyMDI5XCI7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcImVzY2FwZUpTT2JqZWN0Rm9ySW5zdHJ1Y3Rpb25TY3JpcHRzIGVuY291bnRlcmVkIGEgbWF0Y2ggaXQgZG9lcyBub3Qga25vdyBob3cgdG8gcmVwbGFjZS4gdGhpcyBtZWFucyB0aGUgbWF0Y2ggcmVnZXggYW5kIHRoZSByZXBsYWNlbWVudCBjaGFyYWN0ZXJzIGFyZSBubyBsb25nZXIgaW4gc3luYy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdFwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmbHVzaFN0eWxlVGFnc0xhdGVGb3JCb3VuZGFyeShzdHlsZVF1ZXVlKSB7XG4gICAgICB2YXIgcnVsZXMgPSBzdHlsZVF1ZXVlLnJ1bGVzLFxuICAgICAgICBocmVmcyA9IHN0eWxlUXVldWUuaHJlZnM7XG4gICAgICAwIDwgcnVsZXMubGVuZ3RoICYmXG4gICAgICAgIDAgPT09IGhyZWZzLmxlbmd0aCAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiUmVhY3QgZXhwZWN0ZWQgdG8gaGF2ZSBhdCBsZWFzdCBvbmUgaHJlZiBmb3IgYW4gYSBob2lzdGFibGUgc3R5bGUgYnV0IGZvdW5kIG5vbmUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgKTtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIGlmIChocmVmcy5sZW5ndGgpIHtcbiAgICAgICAgd3JpdGVDaHVuayh0aGlzLCBsYXRlU3R5bGVUYWdSZXNvdXJjZU9wZW4xKTtcbiAgICAgICAgd3JpdGVDaHVuayh0aGlzLCBzdHlsZVF1ZXVlLnByZWNlZGVuY2UpO1xuICAgICAgICBmb3IgKFxuICAgICAgICAgIHdyaXRlQ2h1bmsodGhpcywgbGF0ZVN0eWxlVGFnUmVzb3VyY2VPcGVuMik7XG4gICAgICAgICAgaSA8IGhyZWZzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgaSsrXG4gICAgICAgIClcbiAgICAgICAgICB3cml0ZUNodW5rKHRoaXMsIGhyZWZzW2ldKSwgd3JpdGVDaHVuayh0aGlzLCBzcGFjZVNlcGFyYXRvcik7XG4gICAgICAgIHdyaXRlQ2h1bmsodGhpcywgaHJlZnNbaV0pO1xuICAgICAgICB3cml0ZUNodW5rKHRoaXMsIGxhdGVTdHlsZVRhZ1Jlc291cmNlT3BlbjMpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHdyaXRlQ2h1bmsodGhpcywgcnVsZXNbaV0pO1xuICAgICAgICBkZXN0aW5hdGlvbkhhc0NhcGFjaXR5ID0gd3JpdGVDaHVua0FuZFJldHVybihcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIGxhdGVTdHlsZVRhZ1RlbXBsYXRlQ2xvc2VcbiAgICAgICAgKTtcbiAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nQm91bmRhcnlIYXNTdHlsZXNUb0hvaXN0ID0gITA7XG4gICAgICAgIHJ1bGVzLmxlbmd0aCA9IDA7XG4gICAgICAgIGhyZWZzLmxlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhc1N0eWxlc1RvSG9pc3Qoc3R5bGVzaGVldCkge1xuICAgICAgcmV0dXJuIHN0eWxlc2hlZXQuc3RhdGUgIT09IFBSRUFNQkxFXG4gICAgICAgID8gKGN1cnJlbnRseVJlbmRlcmluZ0JvdW5kYXJ5SGFzU3R5bGVzVG9Ib2lzdCA9ICEwKVxuICAgICAgICA6ICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3cml0ZUhvaXN0YWJsZXNGb3JCb3VuZGFyeShcbiAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgaG9pc3RhYmxlU3RhdGUsXG4gICAgICByZW5kZXJTdGF0ZVxuICAgICkge1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nQm91bmRhcnlIYXNTdHlsZXNUb0hvaXN0ID0gITE7XG4gICAgICBkZXN0aW5hdGlvbkhhc0NhcGFjaXR5ID0gITA7XG4gICAgICBob2lzdGFibGVTdGF0ZS5zdHlsZXMuZm9yRWFjaChmbHVzaFN0eWxlVGFnc0xhdGVGb3JCb3VuZGFyeSwgZGVzdGluYXRpb24pO1xuICAgICAgaG9pc3RhYmxlU3RhdGUuc3R5bGVzaGVldHMuZm9yRWFjaChoYXNTdHlsZXNUb0hvaXN0KTtcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0JvdW5kYXJ5SGFzU3R5bGVzVG9Ib2lzdCAmJlxuICAgICAgICAocmVuZGVyU3RhdGUuc3R5bGVzVG9Ib2lzdCA9ICEwKTtcbiAgICAgIHJldHVybiBkZXN0aW5hdGlvbkhhc0NhcGFjaXR5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBmbHVzaFJlc291cmNlKHJlc291cmNlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc291cmNlLmxlbmd0aDsgaSsrKSB3cml0ZUNodW5rKHRoaXMsIHJlc291cmNlW2ldKTtcbiAgICAgIHJlc291cmNlLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsdXNoU3R5bGVJblByZWFtYmxlKHN0eWxlc2hlZXQpIHtcbiAgICAgIHB1c2hMaW5rSW1wbChzdHlsZXNoZWV0Rmx1c2hpbmdRdWV1ZSwgc3R5bGVzaGVldC5wcm9wcyk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlc2hlZXRGbHVzaGluZ1F1ZXVlLmxlbmd0aDsgaSsrKVxuICAgICAgICB3cml0ZUNodW5rKHRoaXMsIHN0eWxlc2hlZXRGbHVzaGluZ1F1ZXVlW2ldKTtcbiAgICAgIHN0eWxlc2hlZXRGbHVzaGluZ1F1ZXVlLmxlbmd0aCA9IDA7XG4gICAgICBzdHlsZXNoZWV0LnN0YXRlID0gUFJFQU1CTEU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsdXNoU3R5bGVzSW5QcmVhbWJsZShzdHlsZVF1ZXVlKSB7XG4gICAgICB2YXIgaGFzU3R5bGVzaGVldHMgPSAwIDwgc3R5bGVRdWV1ZS5zaGVldHMuc2l6ZTtcbiAgICAgIHN0eWxlUXVldWUuc2hlZXRzLmZvckVhY2goZmx1c2hTdHlsZUluUHJlYW1ibGUsIHRoaXMpO1xuICAgICAgc3R5bGVRdWV1ZS5zaGVldHMuY2xlYXIoKTtcbiAgICAgIHZhciBydWxlcyA9IHN0eWxlUXVldWUucnVsZXMsXG4gICAgICAgIGhyZWZzID0gc3R5bGVRdWV1ZS5ocmVmcztcbiAgICAgIGlmICghaGFzU3R5bGVzaGVldHMgfHwgaHJlZnMubGVuZ3RoKSB7XG4gICAgICAgIHdyaXRlQ2h1bmsodGhpcywgc3R5bGVUYWdSZXNvdXJjZU9wZW4xKTtcbiAgICAgICAgd3JpdGVDaHVuayh0aGlzLCBzdHlsZVF1ZXVlLnByZWNlZGVuY2UpO1xuICAgICAgICBzdHlsZVF1ZXVlID0gMDtcbiAgICAgICAgaWYgKGhyZWZzLmxlbmd0aCkge1xuICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICB3cml0ZUNodW5rKHRoaXMsIHN0eWxlVGFnUmVzb3VyY2VPcGVuMik7XG4gICAgICAgICAgICBzdHlsZVF1ZXVlIDwgaHJlZnMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHN0eWxlUXVldWUrK1xuICAgICAgICAgIClcbiAgICAgICAgICAgIHdyaXRlQ2h1bmsodGhpcywgaHJlZnNbc3R5bGVRdWV1ZV0pLFxuICAgICAgICAgICAgICB3cml0ZUNodW5rKHRoaXMsIHNwYWNlU2VwYXJhdG9yKTtcbiAgICAgICAgICB3cml0ZUNodW5rKHRoaXMsIGhyZWZzW3N0eWxlUXVldWVdKTtcbiAgICAgICAgfVxuICAgICAgICB3cml0ZUNodW5rKHRoaXMsIHN0eWxlVGFnUmVzb3VyY2VPcGVuMyk7XG4gICAgICAgIGZvciAoc3R5bGVRdWV1ZSA9IDA7IHN0eWxlUXVldWUgPCBydWxlcy5sZW5ndGg7IHN0eWxlUXVldWUrKylcbiAgICAgICAgICB3cml0ZUNodW5rKHRoaXMsIHJ1bGVzW3N0eWxlUXVldWVdKTtcbiAgICAgICAgd3JpdGVDaHVuayh0aGlzLCBzdHlsZVRhZ1Jlc291cmNlQ2xvc2UpO1xuICAgICAgICBydWxlcy5sZW5ndGggPSAwO1xuICAgICAgICBocmVmcy5sZW5ndGggPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwcmVsb2FkTGF0ZVN0eWxlKHN0eWxlc2hlZXQpIHtcbiAgICAgIGlmIChzdHlsZXNoZWV0LnN0YXRlID09PSBQRU5ESU5HJDEpIHtcbiAgICAgICAgc3R5bGVzaGVldC5zdGF0ZSA9IFBSRUxPQURFRDtcbiAgICAgICAgdmFyIHByb3BzID0gc3R5bGVzaGVldC5wcm9wcztcbiAgICAgICAgcHVzaExpbmtJbXBsKHN0eWxlc2hlZXRGbHVzaGluZ1F1ZXVlLCB7XG4gICAgICAgICAgcmVsOiBcInByZWxvYWRcIixcbiAgICAgICAgICBhczogXCJzdHlsZVwiLFxuICAgICAgICAgIGhyZWY6IHN0eWxlc2hlZXQucHJvcHMuaHJlZixcbiAgICAgICAgICBjcm9zc09yaWdpbjogcHJvcHMuY3Jvc3NPcmlnaW4sXG4gICAgICAgICAgZmV0Y2hQcmlvcml0eTogcHJvcHMuZmV0Y2hQcmlvcml0eSxcbiAgICAgICAgICBpbnRlZ3JpdHk6IHByb3BzLmludGVncml0eSxcbiAgICAgICAgICBtZWRpYTogcHJvcHMubWVkaWEsXG4gICAgICAgICAgaHJlZkxhbmc6IHByb3BzLmhyZWZMYW5nLFxuICAgICAgICAgIHJlZmVycmVyUG9saWN5OiBwcm9wcy5yZWZlcnJlclBvbGljeVxuICAgICAgICB9KTtcbiAgICAgICAgZm9yIChcbiAgICAgICAgICBzdHlsZXNoZWV0ID0gMDtcbiAgICAgICAgICBzdHlsZXNoZWV0IDwgc3R5bGVzaGVldEZsdXNoaW5nUXVldWUubGVuZ3RoO1xuICAgICAgICAgIHN0eWxlc2hlZXQrK1xuICAgICAgICApXG4gICAgICAgICAgd3JpdGVDaHVuayh0aGlzLCBzdHlsZXNoZWV0Rmx1c2hpbmdRdWV1ZVtzdHlsZXNoZWV0XSk7XG4gICAgICAgIHN0eWxlc2hlZXRGbHVzaGluZ1F1ZXVlLmxlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByZWxvYWRMYXRlU3R5bGVzKHN0eWxlUXVldWUpIHtcbiAgICAgIHN0eWxlUXVldWUuc2hlZXRzLmZvckVhY2gocHJlbG9hZExhdGVTdHlsZSwgdGhpcyk7XG4gICAgICBzdHlsZVF1ZXVlLnNoZWV0cy5jbGVhcigpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3cml0ZVN0eWxlUmVzb3VyY2VEZXBlbmRlbmNpZXNJbkpTKGRlc3RpbmF0aW9uLCBob2lzdGFibGVTdGF0ZSkge1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgYXJyYXlGaXJzdE9wZW5CcmFja2V0KTtcbiAgICAgIHZhciBuZXh0QXJyYXlPcGVuQnJhY2tDaHVuayA9IGFycmF5Rmlyc3RPcGVuQnJhY2tldDtcbiAgICAgIGhvaXN0YWJsZVN0YXRlLnN0eWxlc2hlZXRzLmZvckVhY2goZnVuY3Rpb24gKHJlc291cmNlKSB7XG4gICAgICAgIGlmIChyZXNvdXJjZS5zdGF0ZSAhPT0gUFJFQU1CTEUpXG4gICAgICAgICAgaWYgKHJlc291cmNlLnN0YXRlID09PSBMQVRFKVxuICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgbmV4dEFycmF5T3BlbkJyYWNrQ2h1bmspLFxuICAgICAgICAgICAgICAocmVzb3VyY2UgPSByZXNvdXJjZS5wcm9wcy5ocmVmKSxcbiAgICAgICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbihyZXNvdXJjZSwgXCJocmVmXCIpLFxuICAgICAgICAgICAgICB3cml0ZUNodW5rKFxuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsoXG4gICAgICAgICAgICAgICAgICBlc2NhcGVKU09iamVjdEZvckluc3RydWN0aW9uU2NyaXB0cyhcIlwiICsgcmVzb3VyY2UpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBhcnJheUNsb3NlQnJhY2tldCksXG4gICAgICAgICAgICAgIChuZXh0QXJyYXlPcGVuQnJhY2tDaHVuayA9IGFycmF5U3Vic2VxdWVudE9wZW5CcmFja2V0KTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIG5leHRBcnJheU9wZW5CcmFja0NodW5rKTtcbiAgICAgICAgICAgIHZhciBwcmVjZWRlbmNlID0gcmVzb3VyY2UucHJvcHNbXCJkYXRhLXByZWNlZGVuY2VcIl0sXG4gICAgICAgICAgICAgIHByb3BzID0gcmVzb3VyY2UucHJvcHMsXG4gICAgICAgICAgICAgIGNvZXJjZWRIcmVmID0gc2FuaXRpemVVUkwoXCJcIiArIHJlc291cmNlLnByb3BzLmhyZWYpO1xuICAgICAgICAgICAgd3JpdGVDaHVuayhcbiAgICAgICAgICAgICAgZGVzdGluYXRpb24sXG4gICAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsoZXNjYXBlSlNPYmplY3RGb3JJbnN0cnVjdGlvblNjcmlwdHMoY29lcmNlZEhyZWYpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24ocHJlY2VkZW5jZSwgXCJwcmVjZWRlbmNlXCIpO1xuICAgICAgICAgICAgcHJlY2VkZW5jZSA9IFwiXCIgKyBwcmVjZWRlbmNlO1xuICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgYXJyYXlJbnRlcnN0aXRpYWwpO1xuICAgICAgICAgICAgd3JpdGVDaHVuayhcbiAgICAgICAgICAgICAgZGVzdGluYXRpb24sXG4gICAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsoZXNjYXBlSlNPYmplY3RGb3JJbnN0cnVjdGlvblNjcmlwdHMocHJlY2VkZW5jZSkpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcylcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpICYmXG4gICAgICAgICAgICAgICAgKChwcmVjZWRlbmNlID0gcHJvcHNbcHJvcEtleV0pLCBudWxsICE9IHByZWNlZGVuY2UpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJocmVmXCI6XG4gICAgICAgICAgICAgICAgICBjYXNlIFwicmVsXCI6XG4gICAgICAgICAgICAgICAgICBjYXNlIFwicHJlY2VkZW5jZVwiOlxuICAgICAgICAgICAgICAgICAgY2FzZSBcImRhdGEtcHJlY2VkZW5jZVwiOlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgIFwibGluayBpcyBhIHNlbGYtY2xvc2luZyB0YWcgYW5kIG11c3QgbmVpdGhlciBoYXZlIGBjaGlsZHJlbmAgbm9yIHVzZSBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLlwiXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB3cml0ZVN0eWxlUmVzb3VyY2VBdHRyaWJ1dGVJbkpTKFxuICAgICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BLZXksXG4gICAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGFycmF5Q2xvc2VCcmFja2V0KTtcbiAgICAgICAgICAgIG5leHRBcnJheU9wZW5CcmFja0NodW5rID0gYXJyYXlTdWJzZXF1ZW50T3BlbkJyYWNrZXQ7XG4gICAgICAgICAgICByZXNvdXJjZS5zdGF0ZSA9IExBVEU7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBhcnJheUNsb3NlQnJhY2tldCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdyaXRlU3R5bGVSZXNvdXJjZUF0dHJpYnV0ZUluSlMoZGVzdGluYXRpb24sIG5hbWUsIHZhbHVlKSB7XG4gICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgIGNhc2UgXCJpbm5lckhUTUxcIjpcbiAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgIGNhc2UgXCJzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmdcIjpcbiAgICAgICAgY2FzZSBcInN1cHByZXNzSHlkcmF0aW9uV2FybmluZ1wiOlxuICAgICAgICBjYXNlIFwic3R5bGVcIjpcbiAgICAgICAgY2FzZSBcInJlZlwiOlxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSBcImNsYXNzTmFtZVwiOlxuICAgICAgICAgIGF0dHJpYnV0ZU5hbWUgPSBcImNsYXNzXCI7XG4gICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgYXR0cmlidXRlTmFtZSk7XG4gICAgICAgICAgbmFtZSA9IFwiXCIgKyB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImhpZGRlblwiOlxuICAgICAgICAgIGlmICghMSA9PT0gdmFsdWUpIHJldHVybjtcbiAgICAgICAgICBuYW1lID0gXCJcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNyY1wiOlxuICAgICAgICBjYXNlIFwiaHJlZlwiOlxuICAgICAgICAgIHZhbHVlID0gc2FuaXRpemVVUkwodmFsdWUpO1xuICAgICAgICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odmFsdWUsIGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICAgIG5hbWUgPSBcIlwiICsgdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKDIgPCBuYW1lLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAoXCJvXCIgPT09IG5hbWVbMF0gfHwgXCJPXCIgPT09IG5hbWVbMF0pICYmXG4gICAgICAgICAgICAgIChcIm5cIiA9PT0gbmFtZVsxXSB8fCBcIk5cIiA9PT0gbmFtZVsxXSkpIHx8XG4gICAgICAgICAgICAhaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKVxuICAgICAgICAgIClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICBuYW1lID0gXCJcIiArIHZhbHVlO1xuICAgICAgfVxuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgYXJyYXlJbnRlcnN0aXRpYWwpO1xuICAgICAgd3JpdGVDaHVuayhcbiAgICAgICAgZGVzdGluYXRpb24sXG4gICAgICAgIHN0cmluZ1RvQ2h1bmsoZXNjYXBlSlNPYmplY3RGb3JJbnN0cnVjdGlvblNjcmlwdHMoYXR0cmlidXRlTmFtZSkpXG4gICAgICApO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgYXJyYXlJbnRlcnN0aXRpYWwpO1xuICAgICAgd3JpdGVDaHVuayhcbiAgICAgICAgZGVzdGluYXRpb24sXG4gICAgICAgIHN0cmluZ1RvQ2h1bmsoZXNjYXBlSlNPYmplY3RGb3JJbnN0cnVjdGlvblNjcmlwdHMobmFtZSkpXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVIb2lzdGFibGVTdGF0ZSgpIHtcbiAgICAgIHJldHVybiB7IHN0eWxlczogbmV3IFNldCgpLCBzdHlsZXNoZWV0czogbmV3IFNldCgpIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByZWxvYWRCb290c3RyYXBTY3JpcHRPck1vZHVsZShcbiAgICAgIHJlc3VtYWJsZVN0YXRlLFxuICAgICAgcmVuZGVyU3RhdGUsXG4gICAgICBocmVmLFxuICAgICAgcHJvcHNcbiAgICApIHtcbiAgICAgIChyZXN1bWFibGVTdGF0ZS5zY3JpcHRSZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoaHJlZikgfHxcbiAgICAgICAgcmVzdW1hYmxlU3RhdGUubW9kdWxlU2NyaXB0UmVzb3VyY2VzLmhhc093blByb3BlcnR5KGhyZWYpKSAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICdJbnRlcm5hbCBSZWFjdCBFcnJvcjogUmVhY3QgZXhwZWN0ZWQgYm9vdHN0cmFwIHNjcmlwdCBvciBtb2R1bGUgd2l0aCBzcmMgXCIlc1wiIHRvIG5vdCBoYXZlIGJlZW4gcHJlbG9hZGVkIGFscmVhZHkuIHBsZWFzZSBmaWxlIGFuIGlzc3VlJyxcbiAgICAgICAgICBocmVmXG4gICAgICAgICk7XG4gICAgICByZXN1bWFibGVTdGF0ZS5zY3JpcHRSZXNvdXJjZXNbaHJlZl0gPSBFWElTVFM7XG4gICAgICByZXN1bWFibGVTdGF0ZS5tb2R1bGVTY3JpcHRSZXNvdXJjZXNbaHJlZl0gPSBFWElTVFM7XG4gICAgICByZXN1bWFibGVTdGF0ZSA9IFtdO1xuICAgICAgcHVzaExpbmtJbXBsKHJlc3VtYWJsZVN0YXRlLCBwcm9wcyk7XG4gICAgICByZW5kZXJTdGF0ZS5ib290c3RyYXBTY3JpcHRzLmFkZChyZXN1bWFibGVTdGF0ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkb3B0UHJlbG9hZENyZWRlbnRpYWxzKHRhcmdldCwgcHJlbG9hZFN0YXRlKSB7XG4gICAgICBudWxsID09IHRhcmdldC5jcm9zc09yaWdpbiAmJiAodGFyZ2V0LmNyb3NzT3JpZ2luID0gcHJlbG9hZFN0YXRlWzBdKTtcbiAgICAgIG51bGwgPT0gdGFyZ2V0LmludGVncml0eSAmJiAodGFyZ2V0LmludGVncml0eSA9IHByZWxvYWRTdGF0ZVsxXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFByZWxvYWRBc0hlYWRlcihocmVmLCBhcywgcGFyYW1zKSB7XG4gICAgICBocmVmID0gZXNjYXBlSHJlZkZvckxpbmtIZWFkZXJVUkxDb250ZXh0KGhyZWYpO1xuICAgICAgYXMgPSBlc2NhcGVTdHJpbmdGb3JMaW5rSGVhZGVyUXVvdGVkUGFyYW1WYWx1ZUNvbnRleHQoYXMsIFwiYXNcIik7XG4gICAgICBhcyA9IFwiPFwiICsgaHJlZiArICc+OyByZWw9cHJlbG9hZDsgYXM9XCInICsgYXMgKyAnXCInO1xuICAgICAgZm9yICh2YXIgcGFyYW1OYW1lIGluIHBhcmFtcylcbiAgICAgICAgaGFzT3duUHJvcGVydHkuY2FsbChwYXJhbXMsIHBhcmFtTmFtZSkgJiZcbiAgICAgICAgICAoKGhyZWYgPSBwYXJhbXNbcGFyYW1OYW1lXSksXG4gICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGhyZWYgJiZcbiAgICAgICAgICAgIChhcyArPVxuICAgICAgICAgICAgICBcIjsgXCIgK1xuICAgICAgICAgICAgICBwYXJhbU5hbWUudG9Mb3dlckNhc2UoKSArXG4gICAgICAgICAgICAgICc9XCInICtcbiAgICAgICAgICAgICAgZXNjYXBlU3RyaW5nRm9yTGlua0hlYWRlclF1b3RlZFBhcmFtVmFsdWVDb250ZXh0KFxuICAgICAgICAgICAgICAgIGhyZWYsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lXG4gICAgICAgICAgICAgICkgK1xuICAgICAgICAgICAgICAnXCInKSk7XG4gICAgICByZXR1cm4gYXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVzY2FwZUhyZWZGb3JMaW5rSGVhZGVyVVJMQ29udGV4dChocmVmSW5wdXQpIHtcbiAgICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24oaHJlZklucHV0LCBcImhyZWZcIik7XG4gICAgICByZXR1cm4gKFwiXCIgKyBocmVmSW5wdXQpLnJlcGxhY2UoXG4gICAgICAgIHJlZ2V4Rm9ySHJlZkluTGlua0hlYWRlclVSTENvbnRleHQsXG4gICAgICAgIGVzY2FwZUhyZWZGb3JMaW5rSGVhZGVyVVJMQ29udGV4dFJlcGxhY2VyXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlc2NhcGVIcmVmRm9yTGlua0hlYWRlclVSTENvbnRleHRSZXBsYWNlcihtYXRjaCkge1xuICAgICAgc3dpdGNoIChtYXRjaCkge1xuICAgICAgICBjYXNlIFwiPFwiOlxuICAgICAgICAgIHJldHVybiBcIiUzQ1wiO1xuICAgICAgICBjYXNlIFwiPlwiOlxuICAgICAgICAgIHJldHVybiBcIiUzRVwiO1xuICAgICAgICBjYXNlIFwiXFxuXCI6XG4gICAgICAgICAgcmV0dXJuIFwiJTBBXCI7XG4gICAgICAgIGNhc2UgXCJcXHJcIjpcbiAgICAgICAgICByZXR1cm4gXCIlMERcIjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiZXNjYXBlTGlua0hyZWZGb3JIZWFkZXJDb250ZXh0UmVwbGFjZXIgZW5jb3VudGVyZWQgYSBtYXRjaCBpdCBkb2VzIG5vdCBrbm93IGhvdyB0byByZXBsYWNlLiB0aGlzIG1lYW5zIHRoZSBtYXRjaCByZWdleCBhbmQgdGhlIHJlcGxhY2VtZW50IGNoYXJhY3RlcnMgYXJlIG5vIGxvbmdlciBpbiBzeW5jLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0XCJcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBlc2NhcGVTdHJpbmdGb3JMaW5rSGVhZGVyUXVvdGVkUGFyYW1WYWx1ZUNvbnRleHQodmFsdWUsIG5hbWUpIHtcbiAgICAgIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSAmJlxuICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlRoZSBwcm92aWRlZCBgJXNgIG9wdGlvbiBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLiBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS5cIixcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHR5cGVOYW1lKHZhbHVlKVxuICAgICAgICApLFxuICAgICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpKTtcbiAgICAgIHJldHVybiAoXCJcIiArIHZhbHVlKS5yZXBsYWNlKFxuICAgICAgICByZWdleEZvckxpbmtIZWFkZXJRdW90ZWRQYXJhbVZhbHVlQ29udGV4dCxcbiAgICAgICAgZXNjYXBlU3RyaW5nRm9yTGlua0hlYWRlclF1b3RlZFBhcmFtVmFsdWVDb250ZXh0UmVwbGFjZXJcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVzY2FwZVN0cmluZ0ZvckxpbmtIZWFkZXJRdW90ZWRQYXJhbVZhbHVlQ29udGV4dFJlcGxhY2VyKG1hdGNoKSB7XG4gICAgICBzd2l0Y2ggKG1hdGNoKSB7XG4gICAgICAgIGNhc2UgJ1wiJzpcbiAgICAgICAgICByZXR1cm4gXCIlMjJcIjtcbiAgICAgICAgY2FzZSBcIidcIjpcbiAgICAgICAgICByZXR1cm4gXCIlMjdcIjtcbiAgICAgICAgY2FzZSBcIjtcIjpcbiAgICAgICAgICByZXR1cm4gXCIlM0JcIjtcbiAgICAgICAgY2FzZSBcIixcIjpcbiAgICAgICAgICByZXR1cm4gXCIlMkNcIjtcbiAgICAgICAgY2FzZSBcIlxcblwiOlxuICAgICAgICAgIHJldHVybiBcIiUwQVwiO1xuICAgICAgICBjYXNlIFwiXFxyXCI6XG4gICAgICAgICAgcmV0dXJuIFwiJTBEXCI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcImVzY2FwZVN0cmluZ0ZvckxpbmtIZWFkZXJRdW90ZWRQYXJhbVZhbHVlQ29udGV4dFJlcGxhY2VyIGVuY291bnRlcmVkIGEgbWF0Y2ggaXQgZG9lcyBub3Qga25vdyBob3cgdG8gcmVwbGFjZS4gdGhpcyBtZWFucyB0aGUgbWF0Y2ggcmVnZXggYW5kIHRoZSByZXBsYWNlbWVudCBjaGFyYWN0ZXJzIGFyZSBubyBsb25nZXIgaW4gc3luYy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdFwiXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaG9pc3RTdHlsZVF1ZXVlRGVwZW5kZW5jeShzdHlsZVF1ZXVlKSB7XG4gICAgICB0aGlzLnN0eWxlcy5hZGQoc3R5bGVRdWV1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhvaXN0U3R5bGVzaGVldERlcGVuZGVuY3koc3R5bGVzaGVldCkge1xuICAgICAgdGhpcy5zdHlsZXNoZWV0cy5hZGQoc3R5bGVzaGVldCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB7XG4gICAgICBpZiAobnVsbCA9PSB0eXBlKSByZXR1cm4gbnVsbDtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICByZXR1cm4gdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRVxuICAgICAgICAgID8gbnVsbFxuICAgICAgICAgIDogdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZSkgcmV0dXJuIHR5cGU7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIkZyYWdtZW50XCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiUG9ydGFsXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJQcm9maWxlclwiO1xuICAgICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiU3RyaWN0TW9kZVwiO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VMaXN0XCI7XG4gICAgICB9XG4gICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHN3aXRjaCAoXG4gICAgICAgICAgKFwibnVtYmVyXCIgPT09IHR5cGVvZiB0eXBlLnRhZyAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoKS4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgIHR5cGUuJCR0eXBlb2YpXG4gICAgICAgICkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuICh0eXBlLmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiKSArIFwiLlByb3ZpZGVyXCI7XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuICh0eXBlLl9jb250ZXh0LmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiKSArIFwiLkNvbnN1bWVyXCI7XG4gICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgdmFyIGlubmVyVHlwZSA9IHR5cGUucmVuZGVyO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuZGlzcGxheU5hbWU7XG4gICAgICAgICAgICB0eXBlIHx8XG4gICAgICAgICAgICAgICgodHlwZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCBcIlwiKSxcbiAgICAgICAgICAgICAgKHR5cGUgPSBcIlwiICE9PSB0eXBlID8gXCJGb3J3YXJkUmVmKFwiICsgdHlwZSArIFwiKVwiIDogXCJGb3J3YXJkUmVmXCIpKTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKGlubmVyVHlwZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgbnVsbCksXG4gICAgICAgICAgICAgIG51bGwgIT09IGlubmVyVHlwZVxuICAgICAgICAgICAgICAgID8gaW5uZXJUeXBlXG4gICAgICAgICAgICAgICAgOiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCBcIk1lbW9cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgIGlubmVyVHlwZSA9IHR5cGUuX3BheWxvYWQ7XG4gICAgICAgICAgICB0eXBlID0gdHlwZS5faW5pdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZShpbm5lclR5cGUpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb3BUb05lYXJlc3RDb21tb25BbmNlc3RvcihwcmV2LCBuZXh0KSB7XG4gICAgICBpZiAocHJldiAhPT0gbmV4dCkge1xuICAgICAgICBwcmV2LmNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IHByZXYucGFyZW50VmFsdWU7XG4gICAgICAgIHByZXYgPSBwcmV2LnBhcmVudDtcbiAgICAgICAgdmFyIHBhcmVudE5leHQgPSBuZXh0LnBhcmVudDtcbiAgICAgICAgaWYgKG51bGwgPT09IHByZXYpIHtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gcGFyZW50TmV4dClcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICBcIlRoZSBzdGFja3MgbXVzdCByZWFjaCB0aGUgcm9vdCBhdCB0aGUgc2FtZSB0aW1lLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChudWxsID09PSBwYXJlbnROZXh0KVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgIFwiVGhlIHN0YWNrcyBtdXN0IHJlYWNoIHRoZSByb290IGF0IHRoZSBzYW1lIHRpbWUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgcG9wVG9OZWFyZXN0Q29tbW9uQW5jZXN0b3IocHJldiwgcGFyZW50TmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dC5jb250ZXh0Ll9jdXJyZW50VmFsdWUgPSBuZXh0LnZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwb3BBbGxQcmV2aW91cyhwcmV2KSB7XG4gICAgICBwcmV2LmNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IHByZXYucGFyZW50VmFsdWU7XG4gICAgICBwcmV2ID0gcHJldi5wYXJlbnQ7XG4gICAgICBudWxsICE9PSBwcmV2ICYmIHBvcEFsbFByZXZpb3VzKHByZXYpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoQWxsTmV4dChuZXh0KSB7XG4gICAgICB2YXIgcGFyZW50TmV4dCA9IG5leHQucGFyZW50O1xuICAgICAgbnVsbCAhPT0gcGFyZW50TmV4dCAmJiBwdXNoQWxsTmV4dChwYXJlbnROZXh0KTtcbiAgICAgIG5leHQuY29udGV4dC5fY3VycmVudFZhbHVlID0gbmV4dC52YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wUHJldmlvdXNUb0NvbW1vbkxldmVsKHByZXYsIG5leHQpIHtcbiAgICAgIHByZXYuY29udGV4dC5fY3VycmVudFZhbHVlID0gcHJldi5wYXJlbnRWYWx1ZTtcbiAgICAgIHByZXYgPSBwcmV2LnBhcmVudDtcbiAgICAgIGlmIChudWxsID09PSBwcmV2KVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIlRoZSBkZXB0aCBtdXN0IGVxdWFsIGF0IGxlYXN0IGF0IHplcm8gYmVmb3JlIHJlYWNoaW5nIHRoZSByb290LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICk7XG4gICAgICBwcmV2LmRlcHRoID09PSBuZXh0LmRlcHRoXG4gICAgICAgID8gcG9wVG9OZWFyZXN0Q29tbW9uQW5jZXN0b3IocHJldiwgbmV4dClcbiAgICAgICAgOiBwb3BQcmV2aW91c1RvQ29tbW9uTGV2ZWwocHJldiwgbmV4dCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvcE5leHRUb0NvbW1vbkxldmVsKHByZXYsIG5leHQpIHtcbiAgICAgIHZhciBwYXJlbnROZXh0ID0gbmV4dC5wYXJlbnQ7XG4gICAgICBpZiAobnVsbCA9PT0gcGFyZW50TmV4dClcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJUaGUgZGVwdGggbXVzdCBlcXVhbCBhdCBsZWFzdCBhdCB6ZXJvIGJlZm9yZSByZWFjaGluZyB0aGUgcm9vdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICApO1xuICAgICAgcHJldi5kZXB0aCA9PT0gcGFyZW50TmV4dC5kZXB0aFxuICAgICAgICA/IHBvcFRvTmVhcmVzdENvbW1vbkFuY2VzdG9yKHByZXYsIHBhcmVudE5leHQpXG4gICAgICAgIDogcG9wTmV4dFRvQ29tbW9uTGV2ZWwocHJldiwgcGFyZW50TmV4dCk7XG4gICAgICBuZXh0LmNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IG5leHQudmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN3aXRjaENvbnRleHQobmV3U25hcHNob3QpIHtcbiAgICAgIHZhciBwcmV2ID0gY3VycmVudEFjdGl2ZVNuYXBzaG90O1xuICAgICAgcHJldiAhPT0gbmV3U25hcHNob3QgJiZcbiAgICAgICAgKG51bGwgPT09IHByZXZcbiAgICAgICAgICA/IHB1c2hBbGxOZXh0KG5ld1NuYXBzaG90KVxuICAgICAgICAgIDogbnVsbCA9PT0gbmV3U25hcHNob3RcbiAgICAgICAgICAgID8gcG9wQWxsUHJldmlvdXMocHJldilcbiAgICAgICAgICAgIDogcHJldi5kZXB0aCA9PT0gbmV3U25hcHNob3QuZGVwdGhcbiAgICAgICAgICAgICAgPyBwb3BUb05lYXJlc3RDb21tb25BbmNlc3RvcihwcmV2LCBuZXdTbmFwc2hvdClcbiAgICAgICAgICAgICAgOiBwcmV2LmRlcHRoID4gbmV3U25hcHNob3QuZGVwdGhcbiAgICAgICAgICAgICAgICA/IHBvcFByZXZpb3VzVG9Db21tb25MZXZlbChwcmV2LCBuZXdTbmFwc2hvdClcbiAgICAgICAgICAgICAgICA6IHBvcE5leHRUb0NvbW1vbkxldmVsKHByZXYsIG5ld1NuYXBzaG90KSxcbiAgICAgICAgKGN1cnJlbnRBY3RpdmVTbmFwc2hvdCA9IG5ld1NuYXBzaG90KSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaykge1xuICAgICAgaWYgKG51bGwgIT09IGNhbGxiYWNrICYmIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBrZXkgPSBTdHJpbmcoY2FsbGJhY2spO1xuICAgICAgICBkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2suaGFzKGtleSkgfHxcbiAgICAgICAgICAoZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrLmFkZChrZXkpLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkV4cGVjdGVkIHRoZSBsYXN0IG9wdGlvbmFsIGBjYWxsYmFja2AgYXJndW1lbnQgdG8gYmUgYSBmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuXCIsXG4gICAgICAgICAgICBjYWxsYmFja1xuICAgICAgICAgICkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgY2FsbGVyTmFtZSkge1xuICAgICAgcHVibGljSW5zdGFuY2UgPVxuICAgICAgICAoKHB1YmxpY0luc3RhbmNlID0gcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3IpICYmXG4gICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHB1YmxpY0luc3RhbmNlKSkgfHxcbiAgICAgICAgXCJSZWFjdENsYXNzXCI7XG4gICAgICB2YXIgd2FybmluZ0tleSA9IHB1YmxpY0luc3RhbmNlICsgXCIuXCIgKyBjYWxsZXJOYW1lO1xuICAgICAgZGlkV2FybkFib3V0Tm9vcFVwZGF0ZUZvckNvbXBvbmVudFt3YXJuaW5nS2V5XSB8fFxuICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkNhbiBvbmx5IHVwZGF0ZSBhIG1vdW50aW5nIGNvbXBvbmVudC4gVGhpcyB1c3VhbGx5IG1lYW5zIHlvdSBjYWxsZWQgJXMoKSBvdXRzaWRlIGNvbXBvbmVudFdpbGxNb3VudCgpIG9uIHRoZSBzZXJ2ZXIuIFRoaXMgaXMgYSBuby1vcC5cXG5cXG5QbGVhc2UgY2hlY2sgdGhlIGNvZGUgZm9yIHRoZSAlcyBjb21wb25lbnQuXCIsXG4gICAgICAgICAgY2FsbGVyTmFtZSxcbiAgICAgICAgICBwdWJsaWNJbnN0YW5jZVxuICAgICAgICApLFxuICAgICAgICAoZGlkV2FybkFib3V0Tm9vcFVwZGF0ZUZvckNvbXBvbmVudFt3YXJuaW5nS2V5XSA9ICEwKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hUcmVlQ29udGV4dChiYXNlQ29udGV4dCwgdG90YWxDaGlsZHJlbiwgaW5kZXgpIHtcbiAgICAgIHZhciBiYXNlSWRXaXRoTGVhZGluZ0JpdCA9IGJhc2VDb250ZXh0LmlkO1xuICAgICAgYmFzZUNvbnRleHQgPSBiYXNlQ29udGV4dC5vdmVyZmxvdztcbiAgICAgIHZhciBiYXNlTGVuZ3RoID0gMzIgLSBjbHozMihiYXNlSWRXaXRoTGVhZGluZ0JpdCkgLSAxO1xuICAgICAgYmFzZUlkV2l0aExlYWRpbmdCaXQgJj0gfigxIDw8IGJhc2VMZW5ndGgpO1xuICAgICAgaW5kZXggKz0gMTtcbiAgICAgIHZhciBsZW5ndGggPSAzMiAtIGNsejMyKHRvdGFsQ2hpbGRyZW4pICsgYmFzZUxlbmd0aDtcbiAgICAgIGlmICgzMCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgbnVtYmVyT2ZPdmVyZmxvd0JpdHMgPSBiYXNlTGVuZ3RoIC0gKGJhc2VMZW5ndGggJSA1KTtcbiAgICAgICAgbGVuZ3RoID0gKFxuICAgICAgICAgIGJhc2VJZFdpdGhMZWFkaW5nQml0ICZcbiAgICAgICAgICAoKDEgPDwgbnVtYmVyT2ZPdmVyZmxvd0JpdHMpIC0gMSlcbiAgICAgICAgKS50b1N0cmluZygzMik7XG4gICAgICAgIGJhc2VJZFdpdGhMZWFkaW5nQml0ID4+PSBudW1iZXJPZk92ZXJmbG93Qml0cztcbiAgICAgICAgYmFzZUxlbmd0aCAtPSBudW1iZXJPZk92ZXJmbG93Qml0cztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpZDpcbiAgICAgICAgICAgICgxIDw8ICgzMiAtIGNsejMyKHRvdGFsQ2hpbGRyZW4pICsgYmFzZUxlbmd0aCkpIHxcbiAgICAgICAgICAgIChpbmRleCA8PCBiYXNlTGVuZ3RoKSB8XG4gICAgICAgICAgICBiYXNlSWRXaXRoTGVhZGluZ0JpdCxcbiAgICAgICAgICBvdmVyZmxvdzogbGVuZ3RoICsgYmFzZUNvbnRleHRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlkOiAoMSA8PCBsZW5ndGgpIHwgKGluZGV4IDw8IGJhc2VMZW5ndGgpIHwgYmFzZUlkV2l0aExlYWRpbmdCaXQsXG4gICAgICAgIG92ZXJmbG93OiBiYXNlQ29udGV4dFxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2x6MzJGYWxsYmFjayh4KSB7XG4gICAgICB4ID4+Pj0gMDtcbiAgICAgIHJldHVybiAwID09PSB4ID8gMzIgOiAoMzEgLSAoKGxvZyh4KSAvIExOMikgfCAwKSkgfCAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub29wJDIoKSB7fVxuICAgIGZ1bmN0aW9uIHRyYWNrVXNlZFRoZW5hYmxlKHRoZW5hYmxlU3RhdGUsIHRoZW5hYmxlLCBpbmRleCkge1xuICAgICAgaW5kZXggPSB0aGVuYWJsZVN0YXRlW2luZGV4XTtcbiAgICAgIHZvaWQgMCA9PT0gaW5kZXhcbiAgICAgICAgPyB0aGVuYWJsZVN0YXRlLnB1c2godGhlbmFibGUpXG4gICAgICAgIDogaW5kZXggIT09IHRoZW5hYmxlICYmXG4gICAgICAgICAgKHRoZW5hYmxlLnRoZW4obm9vcCQyLCBub29wJDIpLCAodGhlbmFibGUgPSBpbmRleCkpO1xuICAgICAgc3dpdGNoICh0aGVuYWJsZS5zdGF0dXMpIHtcbiAgICAgICAgY2FzZSBcImZ1bGZpbGxlZFwiOlxuICAgICAgICAgIHJldHVybiB0aGVuYWJsZS52YWx1ZTtcbiAgICAgICAgY2FzZSBcInJlamVjdGVkXCI6XG4gICAgICAgICAgdGhyb3cgdGhlbmFibGUucmVhc29uO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiB0aGVuYWJsZS5zdGF0dXNcbiAgICAgICAgICAgID8gdGhlbmFibGUudGhlbihub29wJDIsIG5vb3AkMilcbiAgICAgICAgICAgIDogKCh0aGVuYWJsZVN0YXRlID0gdGhlbmFibGUpLFxuICAgICAgICAgICAgICAodGhlbmFibGVTdGF0ZS5zdGF0dXMgPSBcInBlbmRpbmdcIiksXG4gICAgICAgICAgICAgIHRoZW5hYmxlU3RhdGUudGhlbihcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZnVsZmlsbGVkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChcInBlbmRpbmdcIiA9PT0gdGhlbmFibGUuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmdWxmaWxsZWRUaGVuYWJsZSA9IHRoZW5hYmxlO1xuICAgICAgICAgICAgICAgICAgICBmdWxmaWxsZWRUaGVuYWJsZS5zdGF0dXMgPSBcImZ1bGZpbGxlZFwiO1xuICAgICAgICAgICAgICAgICAgICBmdWxmaWxsZWRUaGVuYWJsZS52YWx1ZSA9IGZ1bGZpbGxlZFZhbHVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoXCJwZW5kaW5nXCIgPT09IHRoZW5hYmxlLnN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVqZWN0ZWRUaGVuYWJsZSA9IHRoZW5hYmxlO1xuICAgICAgICAgICAgICAgICAgICByZWplY3RlZFRoZW5hYmxlLnN0YXR1cyA9IFwicmVqZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0ZWRUaGVuYWJsZS5yZWFzb24gPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICkpO1xuICAgICAgICAgIHN3aXRjaCAodGhlbmFibGUuc3RhdHVzKSB7XG4gICAgICAgICAgICBjYXNlIFwiZnVsZmlsbGVkXCI6XG4gICAgICAgICAgICAgIHJldHVybiB0aGVuYWJsZS52YWx1ZTtcbiAgICAgICAgICAgIGNhc2UgXCJyZWplY3RlZFwiOlxuICAgICAgICAgICAgICB0aHJvdyB0aGVuYWJsZS5yZWFzb247XG4gICAgICAgICAgfVxuICAgICAgICAgIHN1c3BlbmRlZFRoZW5hYmxlID0gdGhlbmFibGU7XG4gICAgICAgICAgdGhyb3cgU3VzcGVuc2VFeGNlcHRpb247XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFN1c3BlbmRlZFRoZW5hYmxlKCkge1xuICAgICAgaWYgKG51bGwgPT09IHN1c3BlbmRlZFRoZW5hYmxlKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIkV4cGVjdGVkIGEgc3VzcGVuZGVkIHRoZW5hYmxlLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICApO1xuICAgICAgdmFyIHRoZW5hYmxlID0gc3VzcGVuZGVkVGhlbmFibGU7XG4gICAgICBzdXNwZW5kZWRUaGVuYWJsZSA9IG51bGw7XG4gICAgICByZXR1cm4gdGhlbmFibGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgICAgIHJldHVybiAoeCA9PT0geSAmJiAoMCAhPT0geCB8fCAxIC8geCA9PT0gMSAvIHkpKSB8fCAoeCAhPT0geCAmJiB5ICE9PSB5KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpIHtcbiAgICAgIGlmIChudWxsID09PSBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiSW52YWxpZCBob29rIGNhbGwuIEhvb2tzIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgb2YgdGhlIGJvZHkgb2YgYSBmdW5jdGlvbiBjb21wb25lbnQuIFRoaXMgY291bGQgaGFwcGVuIGZvciBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOlxcbjEuIFlvdSBtaWdodCBoYXZlIG1pc21hdGNoaW5nIHZlcnNpb25zIG9mIFJlYWN0IGFuZCB0aGUgcmVuZGVyZXIgKHN1Y2ggYXMgUmVhY3QgRE9NKVxcbjIuIFlvdSBtaWdodCBiZSBicmVha2luZyB0aGUgUnVsZXMgb2YgSG9va3NcXG4zLiBZb3UgbWlnaHQgaGF2ZSBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QgaW4gdGhlIHNhbWUgYXBwXFxuU2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvaW52YWxpZC1ob29rLWNhbGwgZm9yIHRpcHMgYWJvdXQgaG93IHRvIGRlYnVnIGFuZCBmaXggdGhpcyBwcm9ibGVtLlwiXG4gICAgICAgICk7XG4gICAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkRvIG5vdCBjYWxsIEhvb2tzIGluc2lkZSB1c2VFZmZlY3QoLi4uKSwgdXNlTWVtbyguLi4pLCBvciBvdGhlciBidWlsdC1pbiBIb29rcy4gWW91IGNhbiBvbmx5IGNhbGwgSG9va3MgYXQgdGhlIHRvcCBsZXZlbCBvZiB5b3VyIFJlYWN0IGZ1bmN0aW9uLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvcnVsZXMtb2YtaG9va3NcIlxuICAgICAgICApO1xuICAgICAgcmV0dXJuIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlSG9vaygpIHtcbiAgICAgIGlmICgwIDwgbnVtYmVyT2ZSZVJlbmRlcnMpXG4gICAgICAgIHRocm93IEVycm9yKFwiUmVuZGVyZWQgbW9yZSBob29rcyB0aGFuIGR1cmluZyB0aGUgcHJldmlvdXMgcmVuZGVyXCIpO1xuICAgICAgcmV0dXJuIHsgbWVtb2l6ZWRTdGF0ZTogbnVsbCwgcXVldWU6IG51bGwsIG5leHQ6IG51bGwgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkge1xuICAgICAgbnVsbCA9PT0gd29ya0luUHJvZ3Jlc3NIb29rXG4gICAgICAgID8gbnVsbCA9PT0gZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2tcbiAgICAgICAgICA/ICgoaXNSZVJlbmRlciA9ICExKSxcbiAgICAgICAgICAgIChmaXJzdFdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vayA9IGNyZWF0ZUhvb2soKSkpXG4gICAgICAgICAgOiAoKGlzUmVSZW5kZXIgPSAhMCksICh3b3JrSW5Qcm9ncmVzc0hvb2sgPSBmaXJzdFdvcmtJblByb2dyZXNzSG9vaykpXG4gICAgICAgIDogbnVsbCA9PT0gd29ya0luUHJvZ3Jlc3NIb29rLm5leHRcbiAgICAgICAgICA/ICgoaXNSZVJlbmRlciA9ICExKSxcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc0hvb2sgPSB3b3JrSW5Qcm9ncmVzc0hvb2submV4dCA9IGNyZWF0ZUhvb2soKSkpXG4gICAgICAgICAgOiAoKGlzUmVSZW5kZXIgPSAhMCksICh3b3JrSW5Qcm9ncmVzc0hvb2sgPSB3b3JrSW5Qcm9ncmVzc0hvb2submV4dCkpO1xuICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzSG9vaztcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0VGhlbmFibGVTdGF0ZUFmdGVyU3VzcGVuZGluZygpIHtcbiAgICAgIHZhciBzdGF0ZSA9IHRoZW5hYmxlU3RhdGU7XG4gICAgICB0aGVuYWJsZVN0YXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzZXRIb29rc1N0YXRlKCkge1xuICAgICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gITE7XG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdLZXlQYXRoID1cbiAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nUmVxdWVzdCA9XG4gICAgICAgIGN1cnJlbnRseVJlbmRlcmluZ1Rhc2sgPVxuICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPVxuICAgICAgICAgIG51bGw7XG4gICAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gITE7XG4gICAgICBmaXJzdFdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG4gICAgICBudW1iZXJPZlJlUmVuZGVycyA9IDA7XG4gICAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSByZW5kZXJQaGFzZVVwZGF0ZXMgPSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWFkQ29udGV4dChjb250ZXh0KSB7XG4gICAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkNvbnRleHQgY2FuIG9ubHkgYmUgcmVhZCB3aGlsZSBSZWFjdCBpcyByZW5kZXJpbmcuIEluIGNsYXNzZXMsIHlvdSBjYW4gcmVhZCBpdCBpbiB0aGUgcmVuZGVyIG1ldGhvZCBvciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuIEluIGZ1bmN0aW9uIGNvbXBvbmVudHMsIHlvdSBjYW4gcmVhZCBpdCBkaXJlY3RseSBpbiB0aGUgZnVuY3Rpb24gYm9keSwgYnV0IG5vdCBpbnNpZGUgSG9va3MgbGlrZSB1c2VSZWR1Y2VyKCkgb3IgdXNlTWVtbygpLlwiXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gY29udGV4dC5fY3VycmVudFZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBiYXNpY1N0YXRlUmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgICByZXR1cm4gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgYWN0aW9uID8gYWN0aW9uKHN0YXRlKSA6IGFjdGlvbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICByZWR1Y2VyICE9PSBiYXNpY1N0YXRlUmVkdWNlciAmJiAoY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVJlZHVjZXJcIik7XG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPSByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gICAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIGlmIChpc1JlUmVuZGVyKSB7XG4gICAgICAgIGluaXQgPSB3b3JrSW5Qcm9ncmVzc0hvb2sucXVldWU7XG4gICAgICAgIGluaXRpYWxBcmcgPSBpbml0LmRpc3BhdGNoO1xuICAgICAgICBpZiAobnVsbCAhPT0gcmVuZGVyUGhhc2VVcGRhdGVzKSB7XG4gICAgICAgICAgdmFyIGZpcnN0UmVuZGVyUGhhc2VVcGRhdGUgPSByZW5kZXJQaGFzZVVwZGF0ZXMuZ2V0KGluaXQpO1xuICAgICAgICAgIGlmICh2b2lkIDAgIT09IGZpcnN0UmVuZGVyUGhhc2VVcGRhdGUpIHtcbiAgICAgICAgICAgIHJlbmRlclBoYXNlVXBkYXRlcy5kZWxldGUoaW5pdCk7XG4gICAgICAgICAgICBpbml0ID0gd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHZhciBhY3Rpb24gPSBmaXJzdFJlbmRlclBoYXNlVXBkYXRlLmFjdGlvbjtcbiAgICAgICAgICAgICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gITA7XG4gICAgICAgICAgICAgIGluaXQgPSByZWR1Y2VyKGluaXQsIGFjdGlvbik7XG4gICAgICAgICAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9ICExO1xuICAgICAgICAgICAgICBmaXJzdFJlbmRlclBoYXNlVXBkYXRlID0gZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZS5uZXh0O1xuICAgICAgICAgICAgfSB3aGlsZSAobnVsbCAhPT0gZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSk7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSA9IGluaXQ7XG4gICAgICAgICAgICByZXR1cm4gW2luaXQsIGluaXRpYWxBcmddO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3dvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlLCBpbml0aWFsQXJnXTtcbiAgICAgIH1cbiAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9ICEwO1xuICAgICAgcmVkdWNlciA9XG4gICAgICAgIHJlZHVjZXIgPT09IGJhc2ljU3RhdGVSZWR1Y2VyXG4gICAgICAgICAgPyBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbml0aWFsQXJnXG4gICAgICAgICAgICA/IGluaXRpYWxBcmcoKVxuICAgICAgICAgICAgOiBpbml0aWFsQXJnXG4gICAgICAgICAgOiB2b2lkIDAgIT09IGluaXRcbiAgICAgICAgICAgID8gaW5pdChpbml0aWFsQXJnKVxuICAgICAgICAgICAgOiBpbml0aWFsQXJnO1xuICAgICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gITE7XG4gICAgICB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSA9IHJlZHVjZXI7XG4gICAgICByZWR1Y2VyID0gd29ya0luUHJvZ3Jlc3NIb29rLnF1ZXVlID0geyBsYXN0OiBudWxsLCBkaXNwYXRjaDogbnVsbCB9O1xuICAgICAgcmVkdWNlciA9IHJlZHVjZXIuZGlzcGF0Y2ggPSBkaXNwYXRjaEFjdGlvbi5iaW5kKFxuICAgICAgICBudWxsLFxuICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQsXG4gICAgICAgIHJlZHVjZXJcbiAgICAgICk7XG4gICAgICByZXR1cm4gW3dvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlLCByZWR1Y2VyXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXNlTWVtbyhuZXh0Q3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPSByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gICAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIGRlcHMgPSB2b2lkIDAgPT09IGRlcHMgPyBudWxsIDogZGVwcztcbiAgICAgIGlmIChudWxsICE9PSB3b3JrSW5Qcm9ncmVzc0hvb2spIHtcbiAgICAgICAgdmFyIHByZXZTdGF0ZSA9IHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlO1xuICAgICAgICBpZiAobnVsbCAhPT0gcHJldlN0YXRlICYmIG51bGwgIT09IGRlcHMpIHtcbiAgICAgICAgICBhOiB7XG4gICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gcHJldlN0YXRlWzFdO1xuICAgICAgICAgICAgaWYgKG51bGwgPT09IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdClcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIiVzIHJlY2VpdmVkIGEgZmluYWwgYXJndW1lbnQgZHVyaW5nIHRoaXMgcmVuZGVyLCBidXQgbm90IGR1cmluZyB0aGUgcHJldmlvdXMgcmVuZGVyLiBFdmVuIHRob3VnaCB0aGUgZmluYWwgYXJndW1lbnQgaXMgb3B0aW9uYWwsIGl0cyB0eXBlIGNhbm5vdCBjaGFuZ2UgYmV0d2VlbiByZW5kZXJzLlwiLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2XG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICExKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBkZXBzLmxlbmd0aCAhPT0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0Lmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlRoZSBmaW5hbCBhcmd1bWVudCBwYXNzZWQgdG8gJXMgY2hhbmdlZCBzaXplIGJldHdlZW4gcmVuZGVycy4gVGhlIG9yZGVyIGFuZCBzaXplIG9mIHRoaXMgYXJyYXkgbXVzdCByZW1haW4gY29uc3RhbnQuXFxuXFxuUHJldmlvdXM6ICVzXFxuSW5jb21pbmc6ICVzXCIsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldixcbiAgICAgICAgICAgICAgICAgIFwiW1wiICsgZGVwcy5qb2luKFwiLCBcIikgKyBcIl1cIixcbiAgICAgICAgICAgICAgICAgIFwiW1wiICsgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LmpvaW4oXCIsIFwiKSArIFwiXVwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICAgICAgaSA8IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdC5sZW5ndGggJiYgaSA8IGRlcHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGkrK1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgaWYgKCFvYmplY3RJcyhkZXBzW2ldLCBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHRbaV0pKSB7XG4gICAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCkgcmV0dXJuIHByZXZTdGF0ZVswXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gITA7XG4gICAgICBuZXh0Q3JlYXRlID0gbmV4dENyZWF0ZSgpO1xuICAgICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gITE7XG4gICAgICB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSA9IFtuZXh0Q3JlYXRlLCBkZXBzXTtcbiAgICAgIHJldHVybiBuZXh0Q3JlYXRlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNwYXRjaEFjdGlvbihjb21wb25lbnRJZGVudGl0eSwgcXVldWUsIGFjdGlvbikge1xuICAgICAgaWYgKDI1IDw9IG51bWJlck9mUmVSZW5kZXJzKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIlRvbyBtYW55IHJlLXJlbmRlcnMuIFJlYWN0IGxpbWl0cyB0aGUgbnVtYmVyIG9mIHJlbmRlcnMgdG8gcHJldmVudCBhbiBpbmZpbml0ZSBsb29wLlwiXG4gICAgICAgICk7XG4gICAgICBpZiAoY29tcG9uZW50SWRlbnRpdHkgPT09IGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudClcbiAgICAgICAgaWYgKFxuICAgICAgICAgICgoZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9ICEwKSxcbiAgICAgICAgICAoY29tcG9uZW50SWRlbnRpdHkgPSB7IGFjdGlvbjogYWN0aW9uLCBuZXh0OiBudWxsIH0pLFxuICAgICAgICAgIG51bGwgPT09IHJlbmRlclBoYXNlVXBkYXRlcyAmJiAocmVuZGVyUGhhc2VVcGRhdGVzID0gbmV3IE1hcCgpKSxcbiAgICAgICAgICAoYWN0aW9uID0gcmVuZGVyUGhhc2VVcGRhdGVzLmdldChxdWV1ZSkpLFxuICAgICAgICAgIHZvaWQgMCA9PT0gYWN0aW9uKVxuICAgICAgICApXG4gICAgICAgICAgcmVuZGVyUGhhc2VVcGRhdGVzLnNldChxdWV1ZSwgY29tcG9uZW50SWRlbnRpdHkpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBmb3IgKHF1ZXVlID0gYWN0aW9uOyBudWxsICE9PSBxdWV1ZS5uZXh0OyApIHF1ZXVlID0gcXVldWUubmV4dDtcbiAgICAgICAgICBxdWV1ZS5uZXh0ID0gY29tcG9uZW50SWRlbnRpdHk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdW5zdXBwb3J0ZWRTdGFydFRyYW5zaXRpb24oKSB7XG4gICAgICB0aHJvdyBFcnJvcihcInN0YXJ0VHJhbnNpdGlvbiBjYW5ub3QgYmUgY2FsbGVkIGR1cmluZyBzZXJ2ZXIgcmVuZGVyaW5nLlwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdW5zdXBwb3J0ZWRTZXRPcHRpbWlzdGljU3RhdGUoKSB7XG4gICAgICB0aHJvdyBFcnJvcihcIkNhbm5vdCB1cGRhdGUgb3B0aW1pc3RpYyBzdGF0ZSB3aGlsZSByZW5kZXJpbmcuXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1c2VBY3Rpb25TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSwgcGVybWFsaW5rKSB7XG4gICAgICByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gICAgICB2YXIgYWN0aW9uU3RhdGVIb29rSW5kZXggPSBhY3Rpb25TdGF0ZUNvdW50ZXIrKyxcbiAgICAgICAgcmVxdWVzdCA9IGN1cnJlbnRseVJlbmRlcmluZ1JlcXVlc3Q7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgYWN0aW9uLiQkRk9STV9BQ1RJT04pIHtcbiAgICAgICAgdmFyIG5leHRQb3N0YmFja1N0YXRlS2V5ID0gbnVsbCxcbiAgICAgICAgICBjb21wb25lbnRLZXlQYXRoID0gY3VycmVudGx5UmVuZGVyaW5nS2V5UGF0aDtcbiAgICAgICAgcmVxdWVzdCA9IHJlcXVlc3QuZm9ybVN0YXRlO1xuICAgICAgICB2YXIgaXNTaWduYXR1cmVFcXVhbCA9IGFjdGlvbi4kJElTX1NJR05BVFVSRV9FUVVBTDtcbiAgICAgICAgaWYgKG51bGwgIT09IHJlcXVlc3QgJiYgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaXNTaWduYXR1cmVFcXVhbCkge1xuICAgICAgICAgIHZhciBwb3N0YmFja0tleSA9IHJlcXVlc3RbMV07XG4gICAgICAgICAgaXNTaWduYXR1cmVFcXVhbC5jYWxsKGFjdGlvbiwgcmVxdWVzdFsyXSwgcmVxdWVzdFszXSkgJiZcbiAgICAgICAgICAgICgobmV4dFBvc3RiYWNrU3RhdGVLZXkgPVxuICAgICAgICAgICAgICB2b2lkIDAgIT09IHBlcm1hbGlua1xuICAgICAgICAgICAgICAgID8gXCJwXCIgKyBwZXJtYWxpbmtcbiAgICAgICAgICAgICAgICA6IFwia1wiICtcbiAgICAgICAgICAgICAgICAgIG11cm11cmhhc2gzXzMyX2djKFxuICAgICAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShbXG4gICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50S2V5UGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgIGFjdGlvblN0YXRlSG9va0luZGV4XG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgIHBvc3RiYWNrS2V5ID09PSBuZXh0UG9zdGJhY2tTdGF0ZUtleSAmJlxuICAgICAgICAgICAgICAoKGFjdGlvblN0YXRlTWF0Y2hpbmdJbmRleCA9IGFjdGlvblN0YXRlSG9va0luZGV4KSxcbiAgICAgICAgICAgICAgKGluaXRpYWxTdGF0ZSA9IHJlcXVlc3RbMF0pKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJvdW5kQWN0aW9uID0gYWN0aW9uLmJpbmQobnVsbCwgaW5pdGlhbFN0YXRlKTtcbiAgICAgICAgYWN0aW9uID0gZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgICBib3VuZEFjdGlvbihwYXlsb2FkKTtcbiAgICAgICAgfTtcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgYm91bmRBY3Rpb24uJCRGT1JNX0FDVElPTiAmJlxuICAgICAgICAgIChhY3Rpb24uJCRGT1JNX0FDVElPTiA9IGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICAgICAgICAgIHByZWZpeCA9IGJvdW5kQWN0aW9uLiQkRk9STV9BQ1RJT04ocHJlZml4KTtcbiAgICAgICAgICAgIHZvaWQgMCAhPT0gcGVybWFsaW5rICYmXG4gICAgICAgICAgICAgIChjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHBlcm1hbGluaywgXCJ0YXJnZXRcIiksXG4gICAgICAgICAgICAgIChwZXJtYWxpbmsgKz0gXCJcIiksXG4gICAgICAgICAgICAgIChwcmVmaXguYWN0aW9uID0gcGVybWFsaW5rKSk7XG4gICAgICAgICAgICB2YXIgZm9ybURhdGEgPSBwcmVmaXguZGF0YTtcbiAgICAgICAgICAgIGZvcm1EYXRhICYmXG4gICAgICAgICAgICAgIChudWxsID09PSBuZXh0UG9zdGJhY2tTdGF0ZUtleSAmJlxuICAgICAgICAgICAgICAgIChuZXh0UG9zdGJhY2tTdGF0ZUtleSA9XG4gICAgICAgICAgICAgICAgICB2b2lkIDAgIT09IHBlcm1hbGlua1xuICAgICAgICAgICAgICAgICAgICA/IFwicFwiICsgcGVybWFsaW5rXG4gICAgICAgICAgICAgICAgICAgIDogXCJrXCIgK1xuICAgICAgICAgICAgICAgICAgICAgIG11cm11cmhhc2gzXzMyX2djKFxuICAgICAgICAgICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoW1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRLZXlQYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25TdGF0ZUhvb2tJbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChcIiRBQ1RJT05fS0VZXCIsIG5leHRQb3N0YmFja1N0YXRlS2V5KSk7XG4gICAgICAgICAgICByZXR1cm4gcHJlZml4O1xuICAgICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gW2luaXRpYWxTdGF0ZSwgYWN0aW9uLCAhMV07XG4gICAgICB9XG4gICAgICB2YXIgX2JvdW5kQWN0aW9uID0gYWN0aW9uLmJpbmQobnVsbCwgaW5pdGlhbFN0YXRlKTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIGluaXRpYWxTdGF0ZSxcbiAgICAgICAgZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgICBfYm91bmRBY3Rpb24ocGF5bG9hZCk7XG4gICAgICAgIH0sXG4gICAgICAgICExXG4gICAgICBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1bndyYXBUaGVuYWJsZSh0aGVuYWJsZSkge1xuICAgICAgdmFyIGluZGV4ID0gdGhlbmFibGVJbmRleENvdW50ZXI7XG4gICAgICB0aGVuYWJsZUluZGV4Q291bnRlciArPSAxO1xuICAgICAgbnVsbCA9PT0gdGhlbmFibGVTdGF0ZSAmJiAodGhlbmFibGVTdGF0ZSA9IFtdKTtcbiAgICAgIHJldHVybiB0cmFja1VzZWRUaGVuYWJsZSh0aGVuYWJsZVN0YXRlLCB0aGVuYWJsZSwgaW5kZXgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1bnN1cHBvcnRlZFJlZnJlc2goKSB7XG4gICAgICB0aHJvdyBFcnJvcihcIkNhY2hlIGNhbm5vdCBiZSByZWZyZXNoZWQgZHVyaW5nIHNlcnZlciByZW5kZXJpbmcuXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub29wJDEoKSB7fVxuICAgIGZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cbiAgICBmdW5jdGlvbiBkaXNhYmxlTG9ncygpIHtcbiAgICAgIGlmICgwID09PSBkaXNhYmxlZERlcHRoKSB7XG4gICAgICAgIHByZXZMb2cgPSBjb25zb2xlLmxvZztcbiAgICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgICBwcmV2RXJyb3IgPSBjb25zb2xlLmVycm9yO1xuICAgICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgICBwcmV2R3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kO1xuICAgICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICB2YWx1ZTogZGlzYWJsZWRMb2csXG4gICAgICAgICAgd3JpdGFibGU6ICEwXG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGRpc2FibGVkRGVwdGgrKztcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICAgICAgZGlzYWJsZWREZXB0aC0tO1xuICAgICAgaWYgKDAgPT09IGRpc2FibGVkRGVwdGgpIHtcbiAgICAgICAgdmFyIHByb3BzID0geyBjb25maWd1cmFibGU6ICEwLCBlbnVtZXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZMb2cgfSksXG4gICAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkluZm8gfSksXG4gICAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldldhcm4gfSksXG4gICAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZFcnJvciB9KSxcbiAgICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkdyb3VwIH0pLFxuICAgICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWQgfSksXG4gICAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZHcm91cEVuZCB9KVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIDAgPiBkaXNhYmxlZERlcHRoICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkge1xuICAgICAgaWYgKHZvaWQgMCA9PT0gcHJlZml4KVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICAgIHByZWZpeCA9IChtYXRjaCAmJiBtYXRjaFsxXSkgfHwgXCJcIjtcbiAgICAgICAgICBzdWZmaXggPVxuICAgICAgICAgICAgLTEgPCB4LnN0YWNrLmluZGV4T2YoXCJcXG4gICAgYXRcIilcbiAgICAgICAgICAgICAgPyBcIiAoPGFub255bW91cz4pXCJcbiAgICAgICAgICAgICAgOiAtMSA8IHguc3RhY2suaW5kZXhPZihcIkBcIilcbiAgICAgICAgICAgICAgICA/IFwiQHVua25vd246MDowXCJcbiAgICAgICAgICAgICAgICA6IFwiXCI7XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBcIlxcblwiICsgcHJlZml4ICsgbmFtZSArIHN1ZmZpeDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XG4gICAgICBpZiAoIWZuIHx8IHJlZW50cnkpIHJldHVybiBcIlwiO1xuICAgICAgdmFyIGZyYW1lID0gY29tcG9uZW50RnJhbWVDYWNoZS5nZXQoZm4pO1xuICAgICAgaWYgKHZvaWQgMCAhPT0gZnJhbWUpIHJldHVybiBmcmFtZTtcbiAgICAgIHJlZW50cnkgPSAhMDtcbiAgICAgIGZyYW1lID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7XG4gICAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHZvaWQgMDtcbiAgICAgIHZhciBwcmV2aW91c0Rpc3BhdGNoZXIgPSBudWxsO1xuICAgICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBudWxsO1xuICAgICAgZGlzYWJsZUxvZ3MoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBSdW5JblJvb3RGcmFtZSA9IHtcbiAgICAgICAgICBEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsIFwicHJvcHNcIiwge1xuICAgICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBSZWZsZWN0ICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250cm9sID0geDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoeCQwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2wgPSB4JDA7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoeCQxKSB7XG4gICAgICAgICAgICAgICAgICBjb250cm9sID0geCQxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAoRmFrZSA9IGZuKCkpICYmXG4gICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBGYWtlLmNhdGNoICYmXG4gICAgICAgICAgICAgICAgICBGYWtlLmNhdGNoKGZ1bmN0aW9uICgpIHt9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgICAgICAgICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiBcInN0cmluZ1wiID09PSB0eXBlb2Ygc2FtcGxlLnN0YWNrKVxuICAgICAgICAgICAgICAgIHJldHVybiBbc2FtcGxlLnN0YWNrLCBjb250cm9sLnN0YWNrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QuZGlzcGxheU5hbWUgPVxuICAgICAgICAgIFwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290XCI7XG4gICAgICAgIHZhciBuYW1lUHJvcERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFxuICAgICAgICAgIFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCxcbiAgICAgICAgICBcIm5hbWVcIlxuICAgICAgICApO1xuICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IgJiZcbiAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IuY29uZmlndXJhYmxlICYmXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICAgICAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LFxuICAgICAgICAgICAgXCJuYW1lXCIsXG4gICAgICAgICAgICB7IHZhbHVlOiBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiIH1cbiAgICAgICAgICApO1xuICAgICAgICB2YXIgX1J1bkluUm9vdEZyYW1lJERldGVyID1cbiAgICAgICAgICAgIFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCgpLFxuICAgICAgICAgIHNhbXBsZVN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzBdLFxuICAgICAgICAgIGNvbnRyb2xTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclsxXTtcbiAgICAgICAgaWYgKHNhbXBsZVN0YWNrICYmIGNvbnRyb2xTdGFjaykge1xuICAgICAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZVN0YWNrLnNwbGl0KFwiXFxuXCIpLFxuICAgICAgICAgICAgY29udHJvbExpbmVzID0gY29udHJvbFN0YWNrLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPSBuYW1lUHJvcERlc2NyaXB0b3IgPSAwO1xuICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yIDwgc2FtcGxlTGluZXMubGVuZ3RoICYmXG4gICAgICAgICAgICAhc2FtcGxlTGluZXNbbmFtZVByb3BEZXNjcmlwdG9yXS5pbmNsdWRlcyhcbiAgICAgICAgICAgICAgXCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3RcIlxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgIClcbiAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvcisrO1xuICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICA7XG4gICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPCBjb250cm9sTGluZXMubGVuZ3RoICYmXG4gICAgICAgICAgICAhY29udHJvbExpbmVzW19SdW5JblJvb3RGcmFtZSREZXRlcl0uaW5jbHVkZXMoXG4gICAgICAgICAgICAgIFwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290XCJcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICApXG4gICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXIrKztcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IgPT09IHNhbXBsZUxpbmVzLmxlbmd0aCB8fFxuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyID09PSBjb250cm9sTGluZXMubGVuZ3RoXG4gICAgICAgICAgKVxuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgMSA8PSBuYW1lUHJvcERlc2NyaXB0b3IgJiZcbiAgICAgICAgICAgICAgMCA8PSBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgJiZcbiAgICAgICAgICAgICAgc2FtcGxlTGluZXNbbmFtZVByb3BEZXNjcmlwdG9yXSAhPT1cbiAgICAgICAgICAgICAgICBjb250cm9sTGluZXNbX1J1bkluUm9vdEZyYW1lJERldGVyXTtcblxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXItLTtcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgMSA8PSBuYW1lUHJvcERlc2NyaXB0b3IgJiYgMCA8PSBfUnVuSW5Sb290RnJhbWUkRGV0ZXI7XG4gICAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3ItLSwgX1J1bkluUm9vdEZyYW1lJERldGVyLS1cbiAgICAgICAgICApXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0gIT09XG4gICAgICAgICAgICAgIGNvbnRyb2xMaW5lc1tfUnVuSW5Sb290RnJhbWUkRGV0ZXJdXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgaWYgKDEgIT09IG5hbWVQcm9wRGVzY3JpcHRvciB8fCAxICE9PSBfUnVuSW5Sb290RnJhbWUkRGV0ZXIpIHtcbiAgICAgICAgICAgICAgICBkb1xuICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAobmFtZVByb3BEZXNjcmlwdG9yLS0sXG4gICAgICAgICAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlci0tLFxuICAgICAgICAgICAgICAgICAgICAwID4gX1J1bkluUm9vdEZyYW1lJERldGVyIHx8XG4gICAgICAgICAgICAgICAgICAgICAgc2FtcGxlTGluZXNbbmFtZVByb3BEZXNjcmlwdG9yXSAhPT1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xMaW5lc1tfUnVuSW5Sb290RnJhbWUkRGV0ZXJdKVxuICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPVxuICAgICAgICAgICAgICAgICAgICAgIFwiXFxuXCIgK1xuICAgICAgICAgICAgICAgICAgICAgIHNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0ucmVwbGFjZShcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiIGF0IG5ldyBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiIGF0IFwiXG4gICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgZm4uZGlzcGxheU5hbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICBfZnJhbWUuaW5jbHVkZXMoXCI8YW5vbnltb3VzPlwiKSAmJlxuICAgICAgICAgICAgICAgICAgICAgIChfZnJhbWUgPSBfZnJhbWUucmVwbGFjZShcIjxhbm9ueW1vdXM+XCIsIGZuLmRpc3BsYXlOYW1lKSk7XG4gICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGZuICYmXG4gICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKDEgPD0gbmFtZVByb3BEZXNjcmlwdG9yICYmIDAgPD0gX1J1bkluUm9vdEZyYW1lJERldGVyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgKHJlZW50cnkgPSAhMSksXG4gICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2aW91c0Rpc3BhdGNoZXIpLFxuICAgICAgICAgIHJlZW5hYmxlTG9ncygpLFxuICAgICAgICAgIChFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IGZyYW1lKTtcbiAgICAgIH1cbiAgICAgIHNhbXBsZUxpbmVzID0gKHNhbXBsZUxpbmVzID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogXCJcIilcbiAgICAgICAgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShzYW1wbGVMaW5lcylcbiAgICAgICAgOiBcIlwiO1xuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZm4gJiYgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHNhbXBsZUxpbmVzKTtcbiAgICAgIHJldHVybiBzYW1wbGVMaW5lcztcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVDb21wb25lbnRTdGFja0J5VHlwZSh0eXBlKSB7XG4gICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGUpIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSh0eXBlKTtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICByZXR1cm4gdHlwZS5wcm90b3R5cGUgJiYgdHlwZS5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudFxuICAgICAgICAgID8gKCh0eXBlID0gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCAhMCkpLCB0eXBlKVxuICAgICAgICAgIDogZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCAhMSk7XG4gICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUgJiYgbnVsbCAhPT0gdHlwZSkge1xuICAgICAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLnJlbmRlciwgITEpO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZS50eXBlLCAhMSk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGUsXG4gICAgICAgICAgICAgIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgICAgbGF6eUNvbXBvbmVudCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB0eXBlID0gbGF6eUNvbXBvbmVudChwYXlsb2FkKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKFwiTGF6eVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZUNvbXBvbmVudFN0YWNrQnlUeXBlKHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZS5uYW1lKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAocGF5bG9hZCA9IHR5cGUuZW52KSxcbiAgICAgICAgICAgIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKFxuICAgICAgICAgICAgICB0eXBlLm5hbWUgKyAocGF5bG9hZCA/IFwiIFtcIiArIHBheWxvYWQgKyBcIl1cIiA6IFwiXCIpXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoXCJTdXNwZW5zZUxpc3RcIik7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoXCJTdXNwZW5zZVwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRTdGFja0J5Q29tcG9uZW50U3RhY2tOb2RlKGNvbXBvbmVudFN0YWNrKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgaW5mbyA9IFwiXCI7XG4gICAgICAgIGRvXG4gICAgICAgICAgKGluZm8gKz0gZGVzY3JpYmVDb21wb25lbnRTdGFja0J5VHlwZShjb21wb25lbnRTdGFjay50eXBlKSksXG4gICAgICAgICAgICAoY29tcG9uZW50U3RhY2sgPSBjb21wb25lbnRTdGFjay5wYXJlbnQpO1xuICAgICAgICB3aGlsZSAoY29tcG9uZW50U3RhY2spO1xuICAgICAgICByZXR1cm4gaW5mbztcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgcmV0dXJuIFwiXFxuRXJyb3IgZ2VuZXJhdGluZyBzdGFjazogXCIgKyB4Lm1lc3NhZ2UgKyBcIlxcblwiICsgeC5zdGFjaztcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZGVmYXVsdEVycm9ySGFuZGxlcihlcnJvcikge1xuICAgICAgaWYgKFxuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgZXJyb3IgJiZcbiAgICAgICAgbnVsbCAhPT0gZXJyb3IgJiZcbiAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGVycm9yLmVudmlyb25tZW50TmFtZVxuICAgICAgKSB7XG4gICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBlcnJvci5lbnZpcm9ubWVudE5hbWU7XG4gICAgICAgIGVycm9yID0gW2Vycm9yXS5zbGljZSgwKTtcbiAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGVycm9yWzBdXG4gICAgICAgICAgPyBlcnJvci5zcGxpY2UoXG4gICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAgIFwiJWMlcyVjIFwiICsgZXJyb3JbMF0sXG4gICAgICAgICAgICAgIFwiYmFja2dyb3VuZDogI2U2ZTZlNjtiYWNrZ3JvdW5kOiBsaWdodC1kYXJrKHJnYmEoMCwwLDAsMC4xKSwgcmdiYSgyNTUsMjU1LDI1NSwwLjI1KSk7Y29sb3I6ICMwMDAwMDA7Y29sb3I6IGxpZ2h0LWRhcmsoIzAwMDAwMCwgI2ZmZmZmZik7Ym9yZGVyLXJhZGl1czogMnB4XCIsXG4gICAgICAgICAgICAgIFwiIFwiICsgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ICsgXCIgXCIsXG4gICAgICAgICAgICAgIFwiXCJcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IGVycm9yLnNwbGljZShcbiAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgXCIlYyVzJWMgXCIsXG4gICAgICAgICAgICAgIFwiYmFja2dyb3VuZDogI2U2ZTZlNjtiYWNrZ3JvdW5kOiBsaWdodC1kYXJrKHJnYmEoMCwwLDAsMC4xKSwgcmdiYSgyNTUsMjU1LDI1NSwwLjI1KSk7Y29sb3I6ICMwMDAwMDA7Y29sb3I6IGxpZ2h0LWRhcmsoIzAwMDAwMCwgI2ZmZmZmZik7Ym9yZGVyLXJhZGl1czogMnB4XCIsXG4gICAgICAgICAgICAgIFwiIFwiICsgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ICsgXCIgXCIsXG4gICAgICAgICAgICAgIFwiXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgIGVycm9yLnVuc2hpZnQoY29uc29sZSk7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IGJpbmQuYXBwbHkoY29uc29sZS5lcnJvciwgZXJyb3IpO1xuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQoKTtcbiAgICAgIH0gZWxzZSBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub29wKCkge31cbiAgICBmdW5jdGlvbiBSZXF1ZXN0SW5zdGFuY2UoXG4gICAgICByZXN1bWFibGVTdGF0ZSxcbiAgICAgIHJlbmRlclN0YXRlLFxuICAgICAgcm9vdEZvcm1hdENvbnRleHQsXG4gICAgICBwcm9ncmVzc2l2ZUNodW5rU2l6ZSxcbiAgICAgIG9uRXJyb3IsXG4gICAgICBvbkFsbFJlYWR5LFxuICAgICAgb25TaGVsbFJlYWR5LFxuICAgICAgb25TaGVsbEVycm9yLFxuICAgICAgb25GYXRhbEVycm9yLFxuICAgICAgb25Qb3N0cG9uZSxcbiAgICAgIGZvcm1TdGF0ZVxuICAgICkge1xuICAgICAgdmFyIGFib3J0U2V0ID0gbmV3IFNldCgpO1xuICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IG51bGw7XG4gICAgICB0aGlzLmZsdXNoU2NoZWR1bGVkID0gITE7XG4gICAgICB0aGlzLnJlc3VtYWJsZVN0YXRlID0gcmVzdW1hYmxlU3RhdGU7XG4gICAgICB0aGlzLnJlbmRlclN0YXRlID0gcmVuZGVyU3RhdGU7XG4gICAgICB0aGlzLnJvb3RGb3JtYXRDb250ZXh0ID0gcm9vdEZvcm1hdENvbnRleHQ7XG4gICAgICB0aGlzLnByb2dyZXNzaXZlQ2h1bmtTaXplID1cbiAgICAgICAgdm9pZCAwID09PSBwcm9ncmVzc2l2ZUNodW5rU2l6ZSA/IDEyODAwIDogcHJvZ3Jlc3NpdmVDaHVua1NpemU7XG4gICAgICB0aGlzLnN0YXR1cyA9IDEwO1xuICAgICAgdGhpcy5mYXRhbEVycm9yID0gbnVsbDtcbiAgICAgIHRoaXMucGVuZGluZ1Jvb3RUYXNrcyA9IHRoaXMuYWxsUGVuZGluZ1Rhc2tzID0gdGhpcy5uZXh0U2VnbWVudElkID0gMDtcbiAgICAgIHRoaXMuY29tcGxldGVkUm9vdFNlZ21lbnQgPSBudWxsO1xuICAgICAgdGhpcy5hYm9ydGFibGVUYXNrcyA9IGFib3J0U2V0O1xuICAgICAgdGhpcy5waW5nZWRUYXNrcyA9IFtdO1xuICAgICAgdGhpcy5jbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMgPSBbXTtcbiAgICAgIHRoaXMuY29tcGxldGVkQm91bmRhcmllcyA9IFtdO1xuICAgICAgdGhpcy5wYXJ0aWFsQm91bmRhcmllcyA9IFtdO1xuICAgICAgdGhpcy50cmFja2VkUG9zdHBvbmVzID0gbnVsbDtcbiAgICAgIHRoaXMub25FcnJvciA9IHZvaWQgMCA9PT0gb25FcnJvciA/IGRlZmF1bHRFcnJvckhhbmRsZXIgOiBvbkVycm9yO1xuICAgICAgdGhpcy5vblBvc3Rwb25lID0gdm9pZCAwID09PSBvblBvc3Rwb25lID8gbm9vcCA6IG9uUG9zdHBvbmU7XG4gICAgICB0aGlzLm9uQWxsUmVhZHkgPSB2b2lkIDAgPT09IG9uQWxsUmVhZHkgPyBub29wIDogb25BbGxSZWFkeTtcbiAgICAgIHRoaXMub25TaGVsbFJlYWR5ID0gdm9pZCAwID09PSBvblNoZWxsUmVhZHkgPyBub29wIDogb25TaGVsbFJlYWR5O1xuICAgICAgdGhpcy5vblNoZWxsRXJyb3IgPSB2b2lkIDAgPT09IG9uU2hlbGxFcnJvciA/IG5vb3AgOiBvblNoZWxsRXJyb3I7XG4gICAgICB0aGlzLm9uRmF0YWxFcnJvciA9IHZvaWQgMCA9PT0gb25GYXRhbEVycm9yID8gbm9vcCA6IG9uRmF0YWxFcnJvcjtcbiAgICAgIHRoaXMuZm9ybVN0YXRlID0gdm9pZCAwID09PSBmb3JtU3RhdGUgPyBudWxsIDogZm9ybVN0YXRlO1xuICAgICAgdGhpcy5kaWRXYXJuRm9yS2V5ID0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlUmVxdWVzdChcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgcmVzdW1hYmxlU3RhdGUsXG4gICAgICByZW5kZXJTdGF0ZSxcbiAgICAgIHJvb3RGb3JtYXRDb250ZXh0LFxuICAgICAgcHJvZ3Jlc3NpdmVDaHVua1NpemUsXG4gICAgICBvbkVycm9yLFxuICAgICAgb25BbGxSZWFkeSxcbiAgICAgIG9uU2hlbGxSZWFkeSxcbiAgICAgIG9uU2hlbGxFcnJvcixcbiAgICAgIG9uRmF0YWxFcnJvcixcbiAgICAgIG9uUG9zdHBvbmUsXG4gICAgICBmb3JtU3RhdGVcbiAgICApIHtcbiAgICAgIHJlc3VtYWJsZVN0YXRlID0gbmV3IFJlcXVlc3RJbnN0YW5jZShcbiAgICAgICAgcmVzdW1hYmxlU3RhdGUsXG4gICAgICAgIHJlbmRlclN0YXRlLFxuICAgICAgICByb290Rm9ybWF0Q29udGV4dCxcbiAgICAgICAgcHJvZ3Jlc3NpdmVDaHVua1NpemUsXG4gICAgICAgIG9uRXJyb3IsXG4gICAgICAgIG9uQWxsUmVhZHksXG4gICAgICAgIG9uU2hlbGxSZWFkeSxcbiAgICAgICAgb25TaGVsbEVycm9yLFxuICAgICAgICBvbkZhdGFsRXJyb3IsXG4gICAgICAgIG9uUG9zdHBvbmUsXG4gICAgICAgIGZvcm1TdGF0ZVxuICAgICAgKTtcbiAgICAgIHJlbmRlclN0YXRlID0gY3JlYXRlUGVuZGluZ1NlZ21lbnQoXG4gICAgICAgIHJlc3VtYWJsZVN0YXRlLFxuICAgICAgICAwLFxuICAgICAgICBudWxsLFxuICAgICAgICByb290Rm9ybWF0Q29udGV4dCxcbiAgICAgICAgITEsXG4gICAgICAgICExXG4gICAgICApO1xuICAgICAgcmVuZGVyU3RhdGUucGFyZW50Rmx1c2hlZCA9ICEwO1xuICAgICAgY2hpbGRyZW4gPSBjcmVhdGVSZW5kZXJUYXNrKFxuICAgICAgICByZXN1bWFibGVTdGF0ZSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIC0xLFxuICAgICAgICBudWxsLFxuICAgICAgICByZW5kZXJTdGF0ZSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgcmVzdW1hYmxlU3RhdGUuYWJvcnRhYmxlVGFza3MsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHJvb3RGb3JtYXRDb250ZXh0LFxuICAgICAgICBudWxsLFxuICAgICAgICBlbXB0eVRyZWVDb250ZXh0LFxuICAgICAgICBudWxsLFxuICAgICAgICAhMVxuICAgICAgKTtcbiAgICAgIHB1c2hDb21wb25lbnRTdGFjayhjaGlsZHJlbik7XG4gICAgICByZXN1bWFibGVTdGF0ZS5waW5nZWRUYXNrcy5wdXNoKGNoaWxkcmVuKTtcbiAgICAgIHJldHVybiByZXN1bWFibGVTdGF0ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlUHJlcmVuZGVyUmVxdWVzdChcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgcmVzdW1hYmxlU3RhdGUsXG4gICAgICByZW5kZXJTdGF0ZSxcbiAgICAgIHJvb3RGb3JtYXRDb250ZXh0LFxuICAgICAgcHJvZ3Jlc3NpdmVDaHVua1NpemUsXG4gICAgICBvbkVycm9yLFxuICAgICAgb25BbGxSZWFkeSxcbiAgICAgIG9uU2hlbGxSZWFkeSxcbiAgICAgIG9uU2hlbGxFcnJvcixcbiAgICAgIG9uRmF0YWxFcnJvcixcbiAgICAgIG9uUG9zdHBvbmVcbiAgICApIHtcbiAgICAgIGNoaWxkcmVuID0gY3JlYXRlUmVxdWVzdChcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIHJlc3VtYWJsZVN0YXRlLFxuICAgICAgICByZW5kZXJTdGF0ZSxcbiAgICAgICAgcm9vdEZvcm1hdENvbnRleHQsXG4gICAgICAgIHByb2dyZXNzaXZlQ2h1bmtTaXplLFxuICAgICAgICBvbkVycm9yLFxuICAgICAgICBvbkFsbFJlYWR5LFxuICAgICAgICBvblNoZWxsUmVhZHksXG4gICAgICAgIG9uU2hlbGxFcnJvcixcbiAgICAgICAgb25GYXRhbEVycm9yLFxuICAgICAgICBvblBvc3Rwb25lLFxuICAgICAgICB2b2lkIDBcbiAgICAgICk7XG4gICAgICBjaGlsZHJlbi50cmFja2VkUG9zdHBvbmVzID0ge1xuICAgICAgICB3b3JraW5nTWFwOiBuZXcgTWFwKCksXG4gICAgICAgIHJvb3ROb2RlczogW10sXG4gICAgICAgIHJvb3RTbG90czogbnVsbFxuICAgICAgfTtcbiAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGluZ1Rhc2socmVxdWVzdCwgdGFzaykge1xuICAgICAgcmVxdWVzdC5waW5nZWRUYXNrcy5wdXNoKHRhc2spO1xuICAgICAgMSA9PT0gcmVxdWVzdC5waW5nZWRUYXNrcy5sZW5ndGggJiZcbiAgICAgICAgKChyZXF1ZXN0LmZsdXNoU2NoZWR1bGVkID0gbnVsbCAhPT0gcmVxdWVzdC5kZXN0aW5hdGlvbiksXG4gICAgICAgIG51bGwgIT09IHJlcXVlc3QudHJhY2tlZFBvc3Rwb25lcyB8fCAxMCA9PT0gcmVxdWVzdC5zdGF0dXNcbiAgICAgICAgICA/IHNjaGVkdWxlTWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBlcmZvcm1Xb3JrKHJlcXVlc3QpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICA6IHNjaGVkdWxlV29yayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwZXJmb3JtV29yayhyZXF1ZXN0KTtcbiAgICAgICAgICAgIH0pKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlU3VzcGVuc2VCb3VuZGFyeShyZXF1ZXN0LCBmYWxsYmFja0Fib3J0YWJsZVRhc2tzKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXM6IFBFTkRJTkcsXG4gICAgICAgIHJvb3RTZWdtZW50SUQ6IC0xLFxuICAgICAgICBwYXJlbnRGbHVzaGVkOiAhMSxcbiAgICAgICAgcGVuZGluZ1Rhc2tzOiAwLFxuICAgICAgICBjb21wbGV0ZWRTZWdtZW50czogW10sXG4gICAgICAgIGJ5dGVTaXplOiAwLFxuICAgICAgICBmYWxsYmFja0Fib3J0YWJsZVRhc2tzOiBmYWxsYmFja0Fib3J0YWJsZVRhc2tzLFxuICAgICAgICBlcnJvckRpZ2VzdDogbnVsbCxcbiAgICAgICAgY29udGVudFN0YXRlOiBjcmVhdGVIb2lzdGFibGVTdGF0ZSgpLFxuICAgICAgICBmYWxsYmFja1N0YXRlOiBjcmVhdGVIb2lzdGFibGVTdGF0ZSgpLFxuICAgICAgICB0cmFja2VkQ29udGVudEtleVBhdGg6IG51bGwsXG4gICAgICAgIHRyYWNrZWRGYWxsYmFja05vZGU6IG51bGwsXG4gICAgICAgIGVycm9yTWVzc2FnZTogbnVsbCxcbiAgICAgICAgZXJyb3JTdGFjazogbnVsbCxcbiAgICAgICAgZXJyb3JDb21wb25lbnRTdGFjazogbnVsbFxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlUmVuZGVyVGFzayhcbiAgICAgIHJlcXVlc3QsXG4gICAgICB0aGVuYWJsZVN0YXRlLFxuICAgICAgbm9kZSxcbiAgICAgIGNoaWxkSW5kZXgsXG4gICAgICBibG9ja2VkQm91bmRhcnksXG4gICAgICBibG9ja2VkU2VnbWVudCxcbiAgICAgIGhvaXN0YWJsZVN0YXRlLFxuICAgICAgYWJvcnRTZXQsXG4gICAgICBrZXlQYXRoLFxuICAgICAgZm9ybWF0Q29udGV4dCxcbiAgICAgIGNvbnRleHQsXG4gICAgICB0cmVlQ29udGV4dCxcbiAgICAgIGNvbXBvbmVudFN0YWNrLFxuICAgICAgaXNGYWxsYmFja1xuICAgICkge1xuICAgICAgcmVxdWVzdC5hbGxQZW5kaW5nVGFza3MrKztcbiAgICAgIG51bGwgPT09IGJsb2NrZWRCb3VuZGFyeVxuICAgICAgICA/IHJlcXVlc3QucGVuZGluZ1Jvb3RUYXNrcysrXG4gICAgICAgIDogYmxvY2tlZEJvdW5kYXJ5LnBlbmRpbmdUYXNrcysrO1xuICAgICAgdmFyIHRhc2sgPSB7XG4gICAgICAgIHJlcGxheTogbnVsbCxcbiAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgY2hpbGRJbmRleDogY2hpbGRJbmRleCxcbiAgICAgICAgcGluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBwaW5nVGFzayhyZXF1ZXN0LCB0YXNrKTtcbiAgICAgICAgfSxcbiAgICAgICAgYmxvY2tlZEJvdW5kYXJ5OiBibG9ja2VkQm91bmRhcnksXG4gICAgICAgIGJsb2NrZWRTZWdtZW50OiBibG9ja2VkU2VnbWVudCxcbiAgICAgICAgaG9pc3RhYmxlU3RhdGU6IGhvaXN0YWJsZVN0YXRlLFxuICAgICAgICBhYm9ydFNldDogYWJvcnRTZXQsXG4gICAgICAgIGtleVBhdGg6IGtleVBhdGgsXG4gICAgICAgIGZvcm1hdENvbnRleHQ6IGZvcm1hdENvbnRleHQsXG4gICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgIHRyZWVDb250ZXh0OiB0cmVlQ29udGV4dCxcbiAgICAgICAgY29tcG9uZW50U3RhY2s6IGNvbXBvbmVudFN0YWNrLFxuICAgICAgICB0aGVuYWJsZVN0YXRlOiB0aGVuYWJsZVN0YXRlLFxuICAgICAgICBpc0ZhbGxiYWNrOiBpc0ZhbGxiYWNrXG4gICAgICB9O1xuICAgICAgYWJvcnRTZXQuYWRkKHRhc2spO1xuICAgICAgcmV0dXJuIHRhc2s7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlcGxheVRhc2soXG4gICAgICByZXF1ZXN0LFxuICAgICAgdGhlbmFibGVTdGF0ZSxcbiAgICAgIHJlcGxheSxcbiAgICAgIG5vZGUsXG4gICAgICBjaGlsZEluZGV4LFxuICAgICAgYmxvY2tlZEJvdW5kYXJ5LFxuICAgICAgaG9pc3RhYmxlU3RhdGUsXG4gICAgICBhYm9ydFNldCxcbiAgICAgIGtleVBhdGgsXG4gICAgICBmb3JtYXRDb250ZXh0LFxuICAgICAgY29udGV4dCxcbiAgICAgIHRyZWVDb250ZXh0LFxuICAgICAgY29tcG9uZW50U3RhY2ssXG4gICAgICBpc0ZhbGxiYWNrXG4gICAgKSB7XG4gICAgICByZXF1ZXN0LmFsbFBlbmRpbmdUYXNrcysrO1xuICAgICAgbnVsbCA9PT0gYmxvY2tlZEJvdW5kYXJ5XG4gICAgICAgID8gcmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzKytcbiAgICAgICAgOiBibG9ja2VkQm91bmRhcnkucGVuZGluZ1Rhc2tzKys7XG4gICAgICByZXBsYXkucGVuZGluZ1Rhc2tzKys7XG4gICAgICB2YXIgdGFzayA9IHtcbiAgICAgICAgcmVwbGF5OiByZXBsYXksXG4gICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgIGNoaWxkSW5kZXg6IGNoaWxkSW5kZXgsXG4gICAgICAgIHBpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gcGluZ1Rhc2socmVxdWVzdCwgdGFzayk7XG4gICAgICAgIH0sXG4gICAgICAgIGJsb2NrZWRCb3VuZGFyeTogYmxvY2tlZEJvdW5kYXJ5LFxuICAgICAgICBibG9ja2VkU2VnbWVudDogbnVsbCxcbiAgICAgICAgaG9pc3RhYmxlU3RhdGU6IGhvaXN0YWJsZVN0YXRlLFxuICAgICAgICBhYm9ydFNldDogYWJvcnRTZXQsXG4gICAgICAgIGtleVBhdGg6IGtleVBhdGgsXG4gICAgICAgIGZvcm1hdENvbnRleHQ6IGZvcm1hdENvbnRleHQsXG4gICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgIHRyZWVDb250ZXh0OiB0cmVlQ29udGV4dCxcbiAgICAgICAgY29tcG9uZW50U3RhY2s6IGNvbXBvbmVudFN0YWNrLFxuICAgICAgICB0aGVuYWJsZVN0YXRlOiB0aGVuYWJsZVN0YXRlLFxuICAgICAgICBpc0ZhbGxiYWNrOiBpc0ZhbGxiYWNrXG4gICAgICB9O1xuICAgICAgYWJvcnRTZXQuYWRkKHRhc2spO1xuICAgICAgcmV0dXJuIHRhc2s7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVBlbmRpbmdTZWdtZW50KFxuICAgICAgcmVxdWVzdCxcbiAgICAgIGluZGV4LFxuICAgICAgYm91bmRhcnksXG4gICAgICBwYXJlbnRGb3JtYXRDb250ZXh0LFxuICAgICAgbGFzdFB1c2hlZFRleHQsXG4gICAgICB0ZXh0RW1iZWRkZWRcbiAgICApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXR1czogUEVORElORyxcbiAgICAgICAgaWQ6IC0xLFxuICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgIHBhcmVudEZsdXNoZWQ6ICExLFxuICAgICAgICBjaHVua3M6IFtdLFxuICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgIHBhcmVudEZvcm1hdENvbnRleHQ6IHBhcmVudEZvcm1hdENvbnRleHQsXG4gICAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICAgICAgbGFzdFB1c2hlZFRleHQ6IGxhc3RQdXNoZWRUZXh0LFxuICAgICAgICB0ZXh0RW1iZWRkZWQ6IHRleHRFbWJlZGRlZFxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Q3VycmVudFN0YWNrSW5ERVYoKSB7XG4gICAgICByZXR1cm4gbnVsbCA9PT0gY3VycmVudFRhc2tJbkRFViB8fFxuICAgICAgICBudWxsID09PSBjdXJyZW50VGFza0luREVWLmNvbXBvbmVudFN0YWNrXG4gICAgICAgID8gXCJcIlxuICAgICAgICA6IGdldFN0YWNrQnlDb21wb25lbnRTdGFja05vZGUoY3VycmVudFRhc2tJbkRFVi5jb21wb25lbnRTdGFjayk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hTZXJ2ZXJDb21wb25lbnRTdGFjayh0YXNrLCBkZWJ1Z0luZm8pIHtcbiAgICAgIGlmIChudWxsICE9IGRlYnVnSW5mbylcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWJ1Z0luZm8ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgY29tcG9uZW50SW5mbyA9IGRlYnVnSW5mb1tpXTtcbiAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgY29tcG9uZW50SW5mby5uYW1lICYmXG4gICAgICAgICAgICAodGFzay5jb21wb25lbnRTdGFjayA9IHtcbiAgICAgICAgICAgICAgcGFyZW50OiB0YXNrLmNvbXBvbmVudFN0YWNrLFxuICAgICAgICAgICAgICB0eXBlOiBjb21wb25lbnRJbmZvLFxuICAgICAgICAgICAgICBvd25lcjogY29tcG9uZW50SW5mby5vd25lcixcbiAgICAgICAgICAgICAgc3RhY2s6IG51bGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hDb21wb25lbnRTdGFjayh0YXNrKSB7XG4gICAgICB2YXIgbm9kZSA9IHRhc2subm9kZTtcbiAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2Ygbm9kZSAmJiBudWxsICE9PSBub2RlKVxuICAgICAgICBzd2l0Y2ggKG5vZGUuJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICAgIHZhciB0eXBlID0gbm9kZS50eXBlLFxuICAgICAgICAgICAgICBvd25lciA9IG5vZGUuX293bmVyO1xuICAgICAgICAgICAgcHVzaFNlcnZlckNvbXBvbmVudFN0YWNrKHRhc2ssIG5vZGUuX2RlYnVnSW5mbyk7XG4gICAgICAgICAgICB0YXNrLmNvbXBvbmVudFN0YWNrID0ge1xuICAgICAgICAgICAgICBwYXJlbnQ6IHRhc2suY29tcG9uZW50U3RhY2ssXG4gICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgIG93bmVyOiBvd25lcixcbiAgICAgICAgICAgICAgc3RhY2s6IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgIHB1c2hTZXJ2ZXJDb21wb25lbnRTdGFjayh0YXNrLCBub2RlLl9kZWJ1Z0luZm8pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG5vZGUudGhlbiAmJlxuICAgICAgICAgICAgICBwdXNoU2VydmVyQ29tcG9uZW50U3RhY2sodGFzaywgbm9kZS5fZGVidWdJbmZvKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRUaHJvd25JbmZvKG5vZGUpIHtcbiAgICAgIHZhciBlcnJvckluZm8gPSB7fTtcbiAgICAgIG5vZGUgJiZcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVycm9ySW5mbywgXCJjb21wb25lbnRTdGFja1wiLCB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzdGFjayA9IGdldFN0YWNrQnlDb21wb25lbnRTdGFja05vZGUobm9kZSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyb3JJbmZvLCBcImNvbXBvbmVudFN0YWNrXCIsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHN0YWNrXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBzdGFjaztcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgcmV0dXJuIGVycm9ySW5mbztcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5jb2RlRXJyb3JGb3JCb3VuZGFyeShcbiAgICAgIGJvdW5kYXJ5LFxuICAgICAgZGlnZXN0LFxuICAgICAgZXJyb3IsXG4gICAgICB0aHJvd25JbmZvLFxuICAgICAgd2FzQWJvcnRlZFxuICAgICkge1xuICAgICAgYm91bmRhcnkuZXJyb3JEaWdlc3QgPSBkaWdlc3Q7XG4gICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yXG4gICAgICAgID8gKChkaWdlc3QgPSBTdHJpbmcoZXJyb3IubWVzc2FnZSkpLCAoZXJyb3IgPSBTdHJpbmcoZXJyb3Iuc3RhY2spKSlcbiAgICAgICAgOiAoKGRpZ2VzdCA9XG4gICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgZXJyb3IgJiYgbnVsbCAhPT0gZXJyb3JcbiAgICAgICAgICAgICAgPyBkZXNjcmliZU9iamVjdEZvckVycm9yTWVzc2FnZShlcnJvcilcbiAgICAgICAgICAgICAgOiBTdHJpbmcoZXJyb3IpKSxcbiAgICAgICAgICAoZXJyb3IgPSBudWxsKSk7XG4gICAgICB3YXNBYm9ydGVkID0gd2FzQWJvcnRlZFxuICAgICAgICA/IFwiU3dpdGNoZWQgdG8gY2xpZW50IHJlbmRlcmluZyBiZWNhdXNlIHRoZSBzZXJ2ZXIgcmVuZGVyaW5nIGFib3J0ZWQgZHVlIHRvOlxcblxcblwiXG4gICAgICAgIDogXCJTd2l0Y2hlZCB0byBjbGllbnQgcmVuZGVyaW5nIGJlY2F1c2UgdGhlIHNlcnZlciByZW5kZXJpbmcgZXJyb3JlZDpcXG5cXG5cIjtcbiAgICAgIGJvdW5kYXJ5LmVycm9yTWVzc2FnZSA9IHdhc0Fib3J0ZWQgKyBkaWdlc3Q7XG4gICAgICBib3VuZGFyeS5lcnJvclN0YWNrID0gbnVsbCAhPT0gZXJyb3IgPyB3YXNBYm9ydGVkICsgZXJyb3IgOiBudWxsO1xuICAgICAgYm91bmRhcnkuZXJyb3JDb21wb25lbnRTdGFjayA9IHRocm93bkluZm8uY29tcG9uZW50U3RhY2s7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxvZ1JlY292ZXJhYmxlRXJyb3IocmVxdWVzdCwgZXJyb3IsIGVycm9ySW5mbykge1xuICAgICAgcmVxdWVzdCA9IHJlcXVlc3Qub25FcnJvcjtcbiAgICAgIGVycm9yID0gcmVxdWVzdChlcnJvciwgZXJyb3JJbmZvKTtcbiAgICAgIGlmIChudWxsICE9IGVycm9yICYmIFwic3RyaW5nXCIgIT09IHR5cGVvZiBlcnJvcilcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAnb25FcnJvciByZXR1cm5lZCBzb21ldGhpbmcgd2l0aCBhIHR5cGUgb3RoZXIgdGhhbiBcInN0cmluZ1wiLiBvbkVycm9yIHNob3VsZCByZXR1cm4gYSBzdHJpbmcgYW5kIG1heSByZXR1cm4gbnVsbCBvciB1bmRlZmluZWQgYnV0IG11c3Qgbm90IHJldHVybiBhbnl0aGluZyBlbHNlLiBJdCByZWNlaXZlZCBzb21ldGhpbmcgb2YgdHlwZSBcIiVzXCIgaW5zdGVhZCcsXG4gICAgICAgICAgdHlwZW9mIGVycm9yXG4gICAgICAgICk7XG4gICAgICBlbHNlIHJldHVybiBlcnJvcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmF0YWxFcnJvcihyZXF1ZXN0LCBlcnJvcikge1xuICAgICAgdmFyIG9uU2hlbGxFcnJvciA9IHJlcXVlc3Qub25TaGVsbEVycm9yLFxuICAgICAgICBvbkZhdGFsRXJyb3IgPSByZXF1ZXN0Lm9uRmF0YWxFcnJvcjtcbiAgICAgIG9uU2hlbGxFcnJvcihlcnJvcik7XG4gICAgICBvbkZhdGFsRXJyb3IoZXJyb3IpO1xuICAgICAgbnVsbCAhPT0gcmVxdWVzdC5kZXN0aW5hdGlvblxuICAgICAgICA/ICgocmVxdWVzdC5zdGF0dXMgPSBDTE9TRUQpLFxuICAgICAgICAgIGNsb3NlV2l0aEVycm9yKHJlcXVlc3QuZGVzdGluYXRpb24sIGVycm9yKSlcbiAgICAgICAgOiAoKHJlcXVlc3Quc3RhdHVzID0gMTMpLCAocmVxdWVzdC5mYXRhbEVycm9yID0gZXJyb3IpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVuZGVyV2l0aEhvb2tzKFxuICAgICAgcmVxdWVzdCxcbiAgICAgIHRhc2ssXG4gICAgICBrZXlQYXRoLFxuICAgICAgQ29tcG9uZW50LFxuICAgICAgcHJvcHMsXG4gICAgICBzZWNvbmRBcmdcbiAgICApIHtcbiAgICAgIHZhciBwcmV2VGhlbmFibGVTdGF0ZSA9IHRhc2sudGhlbmFibGVTdGF0ZTtcbiAgICAgIHRhc2sudGhlbmFibGVTdGF0ZSA9IG51bGw7XG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPSB7fTtcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ1Rhc2sgPSB0YXNrO1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nUmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdLZXlQYXRoID0ga2V5UGF0aDtcbiAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9ICExO1xuICAgICAgYWN0aW9uU3RhdGVDb3VudGVyID0gbG9jYWxJZENvdW50ZXIgPSAwO1xuICAgICAgYWN0aW9uU3RhdGVNYXRjaGluZ0luZGV4ID0gLTE7XG4gICAgICB0aGVuYWJsZUluZGV4Q291bnRlciA9IDA7XG4gICAgICB0aGVuYWJsZVN0YXRlID0gcHJldlRoZW5hYmxlU3RhdGU7XG4gICAgICBmb3IgKFxuICAgICAgICByZXF1ZXN0ID0gY2FsbENvbXBvbmVudEluREVWKENvbXBvbmVudCwgcHJvcHMsIHNlY29uZEFyZyk7XG4gICAgICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGU7XG5cbiAgICAgIClcbiAgICAgICAgKGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSAhMSksXG4gICAgICAgICAgKGFjdGlvblN0YXRlQ291bnRlciA9IGxvY2FsSWRDb3VudGVyID0gMCksXG4gICAgICAgICAgKGFjdGlvblN0YXRlTWF0Y2hpbmdJbmRleCA9IC0xKSxcbiAgICAgICAgICAodGhlbmFibGVJbmRleENvdW50ZXIgPSAwKSxcbiAgICAgICAgICAobnVtYmVyT2ZSZVJlbmRlcnMgKz0gMSksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzSG9vayA9IG51bGwpLFxuICAgICAgICAgIChyZXF1ZXN0ID0gQ29tcG9uZW50KHByb3BzLCBzZWNvbmRBcmcpKTtcbiAgICAgIHJlc2V0SG9va3NTdGF0ZSgpO1xuICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmlzaEZ1bmN0aW9uQ29tcG9uZW50KFxuICAgICAgcmVxdWVzdCxcbiAgICAgIHRhc2ssXG4gICAgICBrZXlQYXRoLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBoYXNJZCxcbiAgICAgIGFjdGlvblN0YXRlQ291bnQsXG4gICAgICBhY3Rpb25TdGF0ZU1hdGNoaW5nSW5kZXhcbiAgICApIHtcbiAgICAgIHZhciBkaWRFbWl0QWN0aW9uU3RhdGVNYXJrZXJzID0gITE7XG4gICAgICBpZiAoMCAhPT0gYWN0aW9uU3RhdGVDb3VudCAmJiBudWxsICE9PSByZXF1ZXN0LmZvcm1TdGF0ZSkge1xuICAgICAgICB2YXIgc2VnbWVudCA9IHRhc2suYmxvY2tlZFNlZ21lbnQ7XG4gICAgICAgIGlmIChudWxsICE9PSBzZWdtZW50KSB7XG4gICAgICAgICAgZGlkRW1pdEFjdGlvblN0YXRlTWFya2VycyA9ICEwO1xuICAgICAgICAgIHNlZ21lbnQgPSBzZWdtZW50LmNodW5rcztcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFjdGlvblN0YXRlQ291bnQ7IGkrKylcbiAgICAgICAgICAgIGkgPT09IGFjdGlvblN0YXRlTWF0Y2hpbmdJbmRleFxuICAgICAgICAgICAgICA/IHNlZ21lbnQucHVzaChmb3JtU3RhdGVNYXJrZXJJc01hdGNoaW5nKVxuICAgICAgICAgICAgICA6IHNlZ21lbnQucHVzaChmb3JtU3RhdGVNYXJrZXJJc05vdE1hdGNoaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYWN0aW9uU3RhdGVDb3VudCA9IHRhc2sua2V5UGF0aDtcbiAgICAgIHRhc2sua2V5UGF0aCA9IGtleVBhdGg7XG4gICAgICBoYXNJZFxuICAgICAgICA/ICgoa2V5UGF0aCA9IHRhc2sudHJlZUNvbnRleHQpLFxuICAgICAgICAgICh0YXNrLnRyZWVDb250ZXh0ID0gcHVzaFRyZWVDb250ZXh0KGtleVBhdGgsIDEsIDApKSxcbiAgICAgICAgICByZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIGNoaWxkcmVuLCAtMSksXG4gICAgICAgICAgKHRhc2sudHJlZUNvbnRleHQgPSBrZXlQYXRoKSlcbiAgICAgICAgOiBkaWRFbWl0QWN0aW9uU3RhdGVNYXJrZXJzXG4gICAgICAgICAgPyByZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIGNoaWxkcmVuLCAtMSlcbiAgICAgICAgICA6IHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBjaGlsZHJlbiwgLTEpO1xuICAgICAgdGFzay5rZXlQYXRoID0gYWN0aW9uU3RhdGVDb3VudDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVuZGVyRWxlbWVudChyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCB0eXBlLCBwcm9wcywgcmVmKSB7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgaWYgKHR5cGUucHJvdG90eXBlICYmIHR5cGUucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpIHtcbiAgICAgICAgICB2YXIgbmV3UHJvcHMgPSBwcm9wcztcbiAgICAgICAgICBpZiAoXCJyZWZcIiBpbiBwcm9wcykge1xuICAgICAgICAgICAgbmV3UHJvcHMgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIHByb3BOYW1lIGluIHByb3BzKVxuICAgICAgICAgICAgICBcInJlZlwiICE9PSBwcm9wTmFtZSAmJiAobmV3UHJvcHNbcHJvcE5hbWVdID0gcHJvcHNbcHJvcE5hbWVdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuICAgICAgICAgIGlmIChkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgICAgIG5ld1Byb3BzID09PSBwcm9wcyAmJiAobmV3UHJvcHMgPSBhc3NpZ24oe30sIG5ld1Byb3BzLCBwcm9wcykpO1xuICAgICAgICAgICAgZm9yICh2YXIgX3Byb3BOYW1lIGluIGRlZmF1bHRQcm9wcylcbiAgICAgICAgICAgICAgdm9pZCAwID09PSBuZXdQcm9wc1tfcHJvcE5hbWVdICYmXG4gICAgICAgICAgICAgICAgKG5ld1Byb3BzW19wcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbX3Byb3BOYW1lXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZXNvbHZlZFByb3BzID0gbmV3UHJvcHM7XG4gICAgICAgICAgdmFyIGNvbnRleHQgPSBlbXB0eUNvbnRleHRPYmplY3QsXG4gICAgICAgICAgICBjb250ZXh0VHlwZSA9IHR5cGUuY29udGV4dFR5cGU7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgXCJjb250ZXh0VHlwZVwiIGluIHR5cGUgJiZcbiAgICAgICAgICAgIG51bGwgIT09IGNvbnRleHRUeXBlICYmXG4gICAgICAgICAgICAodm9pZCAwID09PSBjb250ZXh0VHlwZSB8fFxuICAgICAgICAgICAgICBjb250ZXh0VHlwZS4kJHR5cGVvZiAhPT0gUkVBQ1RfQ09OVEVYVF9UWVBFKSAmJlxuICAgICAgICAgICAgIWRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZS5oYXModHlwZSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZS5hZGQodHlwZSk7XG4gICAgICAgICAgICB2YXIgYWRkZW5kdW0gPVxuICAgICAgICAgICAgICB2b2lkIDAgPT09IGNvbnRleHRUeXBlXG4gICAgICAgICAgICAgICAgPyBcIiBIb3dldmVyLCBpdCBpcyBzZXQgdG8gdW5kZWZpbmVkLiBUaGlzIGNhbiBiZSBjYXVzZWQgYnkgYSB0eXBvIG9yIGJ5IG1peGluZyB1cCBuYW1lZCBhbmQgZGVmYXVsdCBpbXBvcnRzLiBUaGlzIGNhbiBhbHNvIGhhcHBlbiBkdWUgdG8gYSBjaXJjdWxhciBkZXBlbmRlbmN5LCBzbyB0cnkgbW92aW5nIHRoZSBjcmVhdGVDb250ZXh0KCkgY2FsbCB0byBhIHNlcGFyYXRlIGZpbGUuXCJcbiAgICAgICAgICAgICAgICA6IFwib2JqZWN0XCIgIT09IHR5cGVvZiBjb250ZXh0VHlwZVxuICAgICAgICAgICAgICAgICAgPyBcIiBIb3dldmVyLCBpdCBpcyBzZXQgdG8gYSBcIiArIHR5cGVvZiBjb250ZXh0VHlwZSArIFwiLlwiXG4gICAgICAgICAgICAgICAgICA6IGNvbnRleHRUeXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05TVU1FUl9UWVBFXG4gICAgICAgICAgICAgICAgICAgID8gXCIgRGlkIHlvdSBhY2NpZGVudGFsbHkgcGFzcyB0aGUgQ29udGV4dC5Db25zdW1lciBpbnN0ZWFkP1wiXG4gICAgICAgICAgICAgICAgICAgIDogXCIgSG93ZXZlciwgaXQgaXMgc2V0IHRvIGFuIG9iamVjdCB3aXRoIGtleXMge1wiICtcbiAgICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhjb250ZXh0VHlwZSkuam9pbihcIiwgXCIpICtcbiAgICAgICAgICAgICAgICAgICAgICBcIn0uXCI7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzIGRlZmluZXMgYW4gaW52YWxpZCBjb250ZXh0VHlwZS4gY29udGV4dFR5cGUgc2hvdWxkIHBvaW50IHRvIHRoZSBDb250ZXh0IG9iamVjdCByZXR1cm5lZCBieSBSZWFjdC5jcmVhdGVDb250ZXh0KCkuJXNcIixcbiAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8IFwiQ29tcG9uZW50XCIsXG4gICAgICAgICAgICAgIGFkZGVuZHVtXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgY29udGV4dFR5cGUgJiZcbiAgICAgICAgICAgIG51bGwgIT09IGNvbnRleHRUeXBlICYmXG4gICAgICAgICAgICAoY29udGV4dCA9IGNvbnRleHRUeXBlLl9jdXJyZW50VmFsdWUpO1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyB0eXBlKHJlc29sdmVkUHJvcHMsIGNvbnRleHQpO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzICYmXG4gICAgICAgICAgICAobnVsbCA9PT0gaW5zdGFuY2Uuc3RhdGUgfHwgdm9pZCAwID09PSBpbnN0YW5jZS5zdGF0ZSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8IFwiQ29tcG9uZW50XCI7XG4gICAgICAgICAgICBkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUuaGFzKGNvbXBvbmVudE5hbWUpIHx8XG4gICAgICAgICAgICAgIChkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUuYWRkKGNvbXBvbmVudE5hbWUpLFxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiYCVzYCB1c2VzIGBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNgIGJ1dCBpdHMgaW5pdGlhbCBzdGF0ZSBpcyAlcy4gVGhpcyBpcyBub3QgcmVjb21tZW5kZWQuIEluc3RlYWQsIGRlZmluZSB0aGUgaW5pdGlhbCBzdGF0ZSBieSBhc3NpZ25pbmcgYW4gb2JqZWN0IHRvIGB0aGlzLnN0YXRlYCBpbiB0aGUgY29uc3RydWN0b3Igb2YgYCVzYC4gVGhpcyBlbnN1cmVzIHRoYXQgYGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc2AgYXJndW1lbnRzIGhhdmUgYSBjb25zaXN0ZW50IHNoYXBlLlwiLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudE5hbWUsXG4gICAgICAgICAgICAgICAgbnVsbCA9PT0gaW5zdGFuY2Uuc3RhdGUgPyBcIm51bGxcIiA6IFwidW5kZWZpbmVkXCIsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgICAgICAgICAgICApKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgfHxcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgZm91bmRXaWxsTW91bnROYW1lID0gbnVsbCxcbiAgICAgICAgICAgICAgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSA9IG51bGwsXG4gICAgICAgICAgICAgIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSBudWxsO1xuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ICYmXG4gICAgICAgICAgICAhMCAhPT0gaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50Ll9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdcbiAgICAgICAgICAgICAgPyAoZm91bmRXaWxsTW91bnROYW1lID0gXCJjb21wb25lbnRXaWxsTW91bnRcIilcbiAgICAgICAgICAgICAgOiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ICYmXG4gICAgICAgICAgICAgICAgKGZvdW5kV2lsbE1vdW50TmFtZSA9IFwiVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudFwiKTtcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgJiZcbiAgICAgICAgICAgICEwICE9PVxuICAgICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdcbiAgICAgICAgICAgICAgPyAoZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSA9IFwiY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1wiKVxuICAgICAgICAgICAgICA6IFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICAgICAgICAgIHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAmJlxuICAgICAgICAgICAgICAgIChmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lID1cbiAgICAgICAgICAgICAgICAgIFwiVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNcIik7XG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlICYmXG4gICAgICAgICAgICAhMCAhPT0gaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZS5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nXG4gICAgICAgICAgICAgID8gKGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSBcImNvbXBvbmVudFdpbGxVcGRhdGVcIilcbiAgICAgICAgICAgICAgOiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSAmJlxuICAgICAgICAgICAgICAgIChmb3VuZFdpbGxVcGRhdGVOYW1lID0gXCJVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZVwiKTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgbnVsbCAhPT0gZm91bmRXaWxsTW91bnROYW1lIHx8XG4gICAgICAgICAgICAgIG51bGwgIT09IGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgfHxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gZm91bmRXaWxsVXBkYXRlTmFtZVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHZhciBfY29tcG9uZW50TmFtZSA9XG4gICAgICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgXCJDb21wb25lbnRcIixcbiAgICAgICAgICAgICAgICBuZXdBcGlOYW1lID1cbiAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzXG4gICAgICAgICAgICAgICAgICAgID8gXCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoKVwiXG4gICAgICAgICAgICAgICAgICAgIDogXCJnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpXCI7XG4gICAgICAgICAgICAgIGRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUuaGFzKF9jb21wb25lbnROYW1lKSB8fFxuICAgICAgICAgICAgICAgIChkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlLmFkZChcbiAgICAgICAgICAgICAgICAgIF9jb21wb25lbnROYW1lXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJVbnNhZmUgbGVnYWN5IGxpZmVjeWNsZXMgd2lsbCBub3QgYmUgY2FsbGVkIGZvciBjb21wb25lbnRzIHVzaW5nIG5ldyBjb21wb25lbnQgQVBJcy5cXG5cXG4lcyB1c2VzICVzIGJ1dCBhbHNvIGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcgbGVnYWN5IGxpZmVjeWNsZXM6JXMlcyVzXFxuXFxuVGhlIGFib3ZlIGxpZmVjeWNsZXMgc2hvdWxkIGJlIHJlbW92ZWQuIExlYXJuIG1vcmUgYWJvdXQgdGhpcyB3YXJuaW5nIGhlcmU6XFxuaHR0cHM6Ly9yZWFjdC5kZXYvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXNcIixcbiAgICAgICAgICAgICAgICAgIF9jb21wb25lbnROYW1lLFxuICAgICAgICAgICAgICAgICAgbmV3QXBpTmFtZSxcbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IGZvdW5kV2lsbE1vdW50TmFtZVxuICAgICAgICAgICAgICAgICAgICA/IFwiXFxuICBcIiArIGZvdW5kV2lsbE1vdW50TmFtZVxuICAgICAgICAgICAgICAgICAgICA6IFwiXCIsXG4gICAgICAgICAgICAgICAgICBudWxsICE9PSBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lXG4gICAgICAgICAgICAgICAgICAgID8gXCJcXG4gIFwiICsgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZVxuICAgICAgICAgICAgICAgICAgICA6IFwiXCIsXG4gICAgICAgICAgICAgICAgICBudWxsICE9PSBmb3VuZFdpbGxVcGRhdGVOYW1lXG4gICAgICAgICAgICAgICAgICAgID8gXCJcXG4gIFwiICsgZm91bmRXaWxsVXBkYXRlTmFtZVxuICAgICAgICAgICAgICAgICAgICA6IFwiXCJcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgXCJDb21wb25lbnRcIjtcbiAgICAgICAgICBpbnN0YW5jZS5yZW5kZXIgfHxcbiAgICAgICAgICAgICh0eXBlLnByb3RvdHlwZSAmJiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlLnByb3RvdHlwZS5yZW5kZXJcbiAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJObyBgcmVuZGVyYCBtZXRob2QgZm91bmQgb24gdGhlICVzIGluc3RhbmNlOiBkaWQgeW91IGFjY2lkZW50YWxseSByZXR1cm4gYW4gb2JqZWN0IGZyb20gdGhlIGNvbnN0cnVjdG9yP1wiLFxuICAgICAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJObyBgcmVuZGVyYCBtZXRob2QgZm91bmQgb24gdGhlICVzIGluc3RhbmNlOiB5b3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIGRlZmluZSBgcmVuZGVyYC5cIixcbiAgICAgICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAhaW5zdGFuY2UuZ2V0SW5pdGlhbFN0YXRlIHx8XG4gICAgICAgICAgICBpbnN0YW5jZS5nZXRJbml0aWFsU3RhdGUuaXNSZWFjdENsYXNzQXBwcm92ZWQgfHxcbiAgICAgICAgICAgIGluc3RhbmNlLnN0YXRlIHx8XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcImdldEluaXRpYWxTdGF0ZSB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiBUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuIERpZCB5b3UgbWVhbiB0byBkZWZpbmUgYSBzdGF0ZSBwcm9wZXJ0eSBpbnN0ZWFkP1wiLFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGluc3RhbmNlLmdldERlZmF1bHRQcm9wcyAmJlxuICAgICAgICAgICAgIWluc3RhbmNlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJnZXREZWZhdWx0UHJvcHMgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgdG8gZGVmaW5lIGRlZmF1bHRQcm9wcyBpbnN0ZWFkLlwiLFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGluc3RhbmNlLmNvbnRleHRUeXBlICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcImNvbnRleHRUeXBlIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgdG8gZGVmaW5lIGNvbnRleHRUeXBlIGluc3RlYWQuXCIsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgdHlwZS5jaGlsZENvbnRleHRUeXBlcyAmJlxuICAgICAgICAgICAgIWRpZFdhcm5BYm91dENoaWxkQ29udGV4dFR5cGVzLmhhcyh0eXBlKSAmJlxuICAgICAgICAgICAgKGRpZFdhcm5BYm91dENoaWxkQ29udGV4dFR5cGVzLmFkZCh0eXBlKSxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiJXMgdXNlcyB0aGUgbGVnYWN5IGNoaWxkQ29udGV4dFR5cGVzIEFQSSB3aGljaCB3YXMgcmVtb3ZlZCBpbiBSZWFjdCAxOS4gVXNlIFJlYWN0LmNyZWF0ZUNvbnRleHQoKSBpbnN0ZWFkLiAoaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9sZWdhY3ktY29udGV4dClcIixcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKSk7XG4gICAgICAgICAgdHlwZS5jb250ZXh0VHlwZXMgJiZcbiAgICAgICAgICAgICFkaWRXYXJuQWJvdXRDb250ZXh0VHlwZXMkMS5oYXModHlwZSkgJiZcbiAgICAgICAgICAgIChkaWRXYXJuQWJvdXRDb250ZXh0VHlwZXMkMS5hZGQodHlwZSksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzIHVzZXMgdGhlIGxlZ2FjeSBjb250ZXh0VHlwZXMgQVBJIHdoaWNoIHdhcyByZW1vdmVkIGluIFJlYWN0IDE5LiBVc2UgUmVhY3QuY3JlYXRlQ29udGV4dCgpIHdpdGggc3RhdGljIGNvbnRleHRUeXBlIGluc3RlYWQuIChodHRwczovL3JlYWN0LmRldi9saW5rL2xlZ2FjeS1jb250ZXh0KVwiLFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApKTtcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRTaG91bGRVcGRhdGUgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBjb21wb25lbnRTaG91bGRVcGRhdGUoKS4gRGlkIHlvdSBtZWFuIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpPyBUaGUgbmFtZSBpcyBwaHJhc2VkIGFzIGEgcXVlc3Rpb24gYmVjYXVzZSB0aGUgZnVuY3Rpb24gaXMgZXhwZWN0ZWQgdG8gcmV0dXJuIGEgdmFsdWUuXCIsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgdHlwZS5wcm90b3R5cGUgJiZcbiAgICAgICAgICAgIHR5cGUucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50ICYmXG4gICAgICAgICAgICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgc2hvdWxkQ29tcG9uZW50VXBkYXRlKCkuIHNob3VsZENvbXBvbmVudFVwZGF0ZSBzaG91bGQgbm90IGJlIHVzZWQgd2hlbiBleHRlbmRpbmcgUmVhY3QuUHVyZUNvbXBvbmVudC4gUGxlYXNlIGV4dGVuZCBSZWFjdC5Db21wb25lbnQgaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIGlzIHVzZWQuXCIsXG4gICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCBcIkEgcHVyZSBjb21wb25lbnRcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVbm1vdW50ICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgY29tcG9uZW50RGlkVW5tb3VudCgpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiBEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFVubW91bnQoKT9cIixcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRSZWNlaXZlUHJvcHMgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBjb21wb25lbnREaWRSZWNlaXZlUHJvcHMoKS4gQnV0IHRoZXJlIGlzIG5vIHN1Y2ggbGlmZWN5Y2xlIG1ldGhvZC4gSWYgeW91IG1lYW50IHRvIHVwZGF0ZSB0aGUgc3RhdGUgaW4gcmVzcG9uc2UgdG8gY2hhbmdpbmcgcHJvcHMsIHVzZSBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCkuIElmIHlvdSBtZWFudCB0byBmZXRjaCBkYXRhIG9yIHJ1biBzaWRlLWVmZmVjdHMgb3IgbXV0YXRpb25zIGFmdGVyIFJlYWN0IGhhcyB1cGRhdGVkIHRoZSBVSSwgdXNlIGNvbXBvbmVudERpZFVwZGF0ZSgpLlwiLFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/XCIsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiBEaWQgeW91IG1lYW4gVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT9cIixcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB2YXIgaGFzTXV0YXRlZFByb3BzID0gaW5zdGFuY2UucHJvcHMgIT09IHJlc29sdmVkUHJvcHM7XG4gICAgICAgICAgdm9pZCAwICE9PSBpbnN0YW5jZS5wcm9wcyAmJlxuICAgICAgICAgICAgaGFzTXV0YXRlZFByb3BzICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIldoZW4gY2FsbGluZyBzdXBlcigpIGluIGAlc2AsIG1ha2Ugc3VyZSB0byBwYXNzIHVwIHRoZSBzYW1lIHByb3BzIHRoYXQgeW91ciBjb21wb25lbnQncyBjb25zdHJ1Y3RvciB3YXMgcGFzc2VkLlwiLFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGluc3RhbmNlLmRlZmF1bHRQcm9wcyAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJTZXR0aW5nIGRlZmF1bHRQcm9wcyBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcyBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlZmluZSBkZWZhdWx0UHJvcHMgYXMgYSBzdGF0aWMgcHJvcGVydHkgb24gJXMuXCIsXG4gICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgfHxcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSB8fFxuICAgICAgICAgICAgZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlLmhhcyh0eXBlKSB8fFxuICAgICAgICAgICAgKGRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZS5hZGQodHlwZSksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzOiBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIHNob3VsZCBiZSB1c2VkIHdpdGggY29tcG9uZW50RGlkVXBkYXRlKCkuIFRoaXMgY29tcG9uZW50IGRlZmluZXMgZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSBvbmx5LlwiLFxuICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSlcbiAgICAgICAgICAgICkpO1xuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlczogZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCkgaXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBtZXRob2QgYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCwgZGVjbGFyZSBpdCBhcyBhIHN0YXRpYyBtZXRob2QuXCIsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzOiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoKSBpcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIG1ldGhvZCBhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWNsYXJlIGl0IGFzIGEgc3RhdGljIG1ldGhvZC5cIixcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzOiBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIGlzIGRlZmluZWQgYXMgYSBzdGF0aWMgbWV0aG9kIGFuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlY2xhcmUgaXQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kLlwiLFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHZhciBzdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuICAgICAgICAgIHN0YXRlICYmXG4gICAgICAgICAgICAoXCJvYmplY3RcIiAhPT0gdHlwZW9mIHN0YXRlIHx8IGlzQXJyYXlJbXBsKHN0YXRlKSkgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCIlcy5zdGF0ZTogbXVzdCBiZSBzZXQgdG8gYW4gb2JqZWN0IG9yIG51bGxcIiwgbmFtZSk7XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0ICYmXG4gICAgICAgICAgICBcIm9iamVjdFwiICE9PSB0eXBlb2YgdHlwZS5jaGlsZENvbnRleHRUeXBlcyAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlcy5nZXRDaGlsZENvbnRleHQoKTogY2hpbGRDb250ZXh0VHlwZXMgbXVzdCBiZSBkZWZpbmVkIGluIG9yZGVyIHRvIHVzZSBnZXRDaGlsZENvbnRleHQoKS5cIixcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB2YXIgaW5pdGlhbFN0YXRlID0gdm9pZCAwICE9PSBpbnN0YW5jZS5zdGF0ZSA/IGluc3RhbmNlLnN0YXRlIDogbnVsbDtcbiAgICAgICAgICBpbnN0YW5jZS51cGRhdGVyID0gY2xhc3NDb21wb25lbnRVcGRhdGVyO1xuICAgICAgICAgIGluc3RhbmNlLnByb3BzID0gcmVzb2x2ZWRQcm9wcztcbiAgICAgICAgICBpbnN0YW5jZS5zdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgICAgICAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IHsgcXVldWU6IFtdLCByZXBsYWNlOiAhMSB9O1xuICAgICAgICAgIGluc3RhbmNlLl9yZWFjdEludGVybmFscyA9IGludGVybmFsSW5zdGFuY2U7XG4gICAgICAgICAgdmFyIGNvbnRleHRUeXBlJGpzY29tcCQwID0gdHlwZS5jb250ZXh0VHlwZTtcbiAgICAgICAgICBpbnN0YW5jZS5jb250ZXh0ID1cbiAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBjb250ZXh0VHlwZSRqc2NvbXAkMCAmJlxuICAgICAgICAgICAgbnVsbCAhPT0gY29udGV4dFR5cGUkanNjb21wJDBcbiAgICAgICAgICAgICAgPyBjb250ZXh0VHlwZSRqc2NvbXAkMC5fY3VycmVudFZhbHVlXG4gICAgICAgICAgICAgIDogZW1wdHlDb250ZXh0T2JqZWN0O1xuICAgICAgICAgIGlmIChpbnN0YW5jZS5zdGF0ZSA9PT0gcmVzb2x2ZWRQcm9wcykge1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUkanNjb21wJDAgPVxuICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgXCJDb21wb25lbnRcIjtcbiAgICAgICAgICAgIGRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlLmhhcyhcbiAgICAgICAgICAgICAgY29tcG9uZW50TmFtZSRqc2NvbXAkMFxuICAgICAgICAgICAgKSB8fFxuICAgICAgICAgICAgICAoZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUuYWRkKFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudE5hbWUkanNjb21wJDBcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIiVzOiBJdCBpcyBub3QgcmVjb21tZW5kZWQgdG8gYXNzaWduIHByb3BzIGRpcmVjdGx5IHRvIHN0YXRlIGJlY2F1c2UgdXBkYXRlcyB0byBwcm9wcyB3b24ndCBiZSByZWZsZWN0ZWQgaW4gc3RhdGUuIEluIG1vc3QgY2FzZXMsIGl0IGlzIGJldHRlciB0byB1c2UgcHJvcHMgZGlyZWN0bHkuXCIsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50TmFtZSRqc2NvbXAkMFxuICAgICAgICAgICAgICApKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IHR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzO1xuICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMpIHtcbiAgICAgICAgICAgIHZhciBwYXJ0aWFsU3RhdGUgPSBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoXG4gICAgICAgICAgICAgIHJlc29sdmVkUHJvcHMsXG4gICAgICAgICAgICAgIGluaXRpYWxTdGF0ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IHBhcnRpYWxTdGF0ZSkge1xuICAgICAgICAgICAgICB2YXIgY29tcG9uZW50TmFtZSRqc2NvbXAkMSA9XG4gICAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8IFwiQ29tcG9uZW50XCI7XG4gICAgICAgICAgICAgIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZS5oYXMoY29tcG9uZW50TmFtZSRqc2NvbXAkMSkgfHxcbiAgICAgICAgICAgICAgICAoZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlLmFkZChjb21wb25lbnROYW1lJGpzY29tcCQxKSxcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCIlcy5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoKTogQSB2YWxpZCBzdGF0ZSBvYmplY3QgKG9yIG51bGwpIG11c3QgYmUgcmV0dXJuZWQuIFlvdSBoYXZlIHJldHVybmVkIHVuZGVmaW5lZC5cIixcbiAgICAgICAgICAgICAgICAgIGNvbXBvbmVudE5hbWUkanNjb21wJDFcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPVxuICAgICAgICAgICAgICBudWxsID09PSBwYXJ0aWFsU3RhdGUgfHwgdm9pZCAwID09PSBwYXJ0aWFsU3RhdGVcbiAgICAgICAgICAgICAgICA/IGluaXRpYWxTdGF0ZVxuICAgICAgICAgICAgICAgIDogYXNzaWduKHt9LCBpbml0aWFsU3RhdGUsIHBhcnRpYWxTdGF0ZSk7XG4gICAgICAgICAgICBpbnN0YW5jZS5zdGF0ZSA9IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgdHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgJiZcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlICYmXG4gICAgICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCB8fFxuICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgb2xkU3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTtcbiAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQpIHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICEwICE9PSBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ1xuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB2YXIgY29tcG9uZW50TmFtZSRqc2NvbXAkMiA9XG4gICAgICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgXCJVbmtub3duXCI7XG4gICAgICAgICAgICAgICAgZGlkV2FybkFib3V0RGVwcmVjYXRlZFdpbGxNb3VudFtjb21wb25lbnROYW1lJGpzY29tcCQyXSB8fFxuICAgICAgICAgICAgICAgICAgKGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAgICAgXCJjb21wb25lbnRXaWxsTW91bnQgaGFzIGJlZW4gcmVuYW1lZCwgYW5kIGlzIG5vdCByZWNvbW1lbmRlZCBmb3IgdXNlLiBTZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuKiBNb3ZlIGNvZGUgZnJvbSBjb21wb25lbnRXaWxsTW91bnQgdG8gY29tcG9uZW50RGlkTW91bnQgKHByZWZlcnJlZCBpbiBtb3N0IGNhc2VzKSBvciB0aGUgY29uc3RydWN0b3IuXFxuXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzXCIsXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudE5hbWUkanNjb21wJDJcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAoZGlkV2FybkFib3V0RGVwcmVjYXRlZFdpbGxNb3VudFtjb21wb25lbnROYW1lJGpzY29tcCQyXSA9XG4gICAgICAgICAgICAgICAgICAgICEwKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ICYmXG4gICAgICAgICAgICAgIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgICAgICAgICAgIG9sZFN0YXRlICE9PSBpbnN0YW5jZS5zdGF0ZSAmJlxuICAgICAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIiVzLmNvbXBvbmVudFdpbGxNb3VudCgpOiBBc3NpZ25pbmcgZGlyZWN0bHkgdG8gdGhpcy5zdGF0ZSBpcyBkZXByZWNhdGVkIChleGNlcHQgaW5zaWRlIGEgY29tcG9uZW50J3MgY29uc3RydWN0b3IpLiBVc2Ugc2V0U3RhdGUgaW5zdGVhZC5cIixcbiAgICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgXCJDb21wb25lbnRcIlxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBjbGFzc0NvbXBvbmVudFVwZGF0ZXIuZW5xdWV1ZVJlcGxhY2VTdGF0ZShcbiAgICAgICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5zdGF0ZSxcbiAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBudWxsICE9PSBpbnRlcm5hbEluc3RhbmNlLnF1ZXVlICYmXG4gICAgICAgICAgICAgIDAgPCBpbnRlcm5hbEluc3RhbmNlLnF1ZXVlLmxlbmd0aFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHZhciBvbGRRdWV1ZSA9IGludGVybmFsSW5zdGFuY2UucXVldWUsXG4gICAgICAgICAgICAgICAgb2xkUmVwbGFjZSA9IGludGVybmFsSW5zdGFuY2UucmVwbGFjZTtcbiAgICAgICAgICAgICAgaW50ZXJuYWxJbnN0YW5jZS5xdWV1ZSA9IG51bGw7XG4gICAgICAgICAgICAgIGludGVybmFsSW5zdGFuY2UucmVwbGFjZSA9ICExO1xuICAgICAgICAgICAgICBpZiAob2xkUmVwbGFjZSAmJiAxID09PSBvbGRRdWV1ZS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgaW5zdGFuY2Uuc3RhdGUgPSBvbGRRdWV1ZVswXTtcbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICAgIHZhciBuZXh0U3RhdGUgPSBvbGRSZXBsYWNlID8gb2xkUXVldWVbMF0gOiBpbnN0YW5jZS5zdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgZG9udE11dGF0ZSA9ICEwLFxuICAgICAgICAgICAgICAgICAgICBpID0gb2xkUmVwbGFjZSA/IDEgOiAwO1xuICAgICAgICAgICAgICAgICAgaSA8IG9sZFF1ZXVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgIGkrK1xuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgdmFyIHBhcnRpYWwgPSBvbGRRdWV1ZVtpXSxcbiAgICAgICAgICAgICAgICAgICAgcGFydGlhbFN0YXRlJGpzY29tcCQwID1cbiAgICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBwYXJ0aWFsXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHBhcnRpYWwuY2FsbChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0U3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBwYXJ0aWFsO1xuICAgICAgICAgICAgICAgICAgbnVsbCAhPSBwYXJ0aWFsU3RhdGUkanNjb21wJDAgJiZcbiAgICAgICAgICAgICAgICAgICAgKGRvbnRNdXRhdGVcbiAgICAgICAgICAgICAgICAgICAgICA/ICgoZG9udE11dGF0ZSA9ICExKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIChuZXh0U3RhdGUgPSBhc3NpZ24oXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0U3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWxTdGF0ZSRqc2NvbXAkMFxuICAgICAgICAgICAgICAgICAgICAgICAgKSkpXG4gICAgICAgICAgICAgICAgICAgICAgOiBhc3NpZ24obmV4dFN0YXRlLCBwYXJ0aWFsU3RhdGUkanNjb21wJDApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5zdGFuY2Uuc3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpbnRlcm5hbEluc3RhbmNlLnF1ZXVlID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG5leHRDaGlsZHJlbiA9IGNhbGxSZW5kZXJJbkRFVihpbnN0YW5jZSk7XG4gICAgICAgICAgaWYgKDEyID09PSByZXF1ZXN0LnN0YXR1cykgdGhyb3cgbnVsbDtcbiAgICAgICAgICBpbnN0YW5jZS5wcm9wcyAhPT0gcmVzb2x2ZWRQcm9wcyAmJlxuICAgICAgICAgICAgKGRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMgfHxcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIkl0IGxvb2tzIGxpa2UgJXMgaXMgcmVhc3NpZ25pbmcgaXRzIG93biBgdGhpcy5wcm9wc2Agd2hpbGUgcmVuZGVyaW5nLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQgYW5kIGNhbiBsZWFkIHRvIGNvbmZ1c2luZyBidWdzLlwiLFxuICAgICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCBcImEgY29tcG9uZW50XCJcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIChkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzID0gITApKTtcbiAgICAgICAgICB2YXIgcHJldktleVBhdGggPSB0YXNrLmtleVBhdGg7XG4gICAgICAgICAgdGFzay5rZXlQYXRoID0ga2V5UGF0aDtcbiAgICAgICAgICByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgbmV4dENoaWxkcmVuLCAtMSk7XG4gICAgICAgICAgdGFzay5rZXlQYXRoID0gcHJldktleVBhdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHR5cGUucHJvdG90eXBlICYmIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUucHJvdG90eXBlLnJlbmRlcikge1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUkanNjb21wJDMgPVxuICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgXCJVbmtub3duXCI7XG4gICAgICAgICAgICBkaWRXYXJuQWJvdXRCYWRDbGFzc1tjb21wb25lbnROYW1lJGpzY29tcCQzXSB8fFxuICAgICAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIlRoZSA8JXMgLz4gY29tcG9uZW50IGFwcGVhcnMgdG8gaGF2ZSBhIHJlbmRlciBtZXRob2QsIGJ1dCBkb2Vzbid0IGV4dGVuZCBSZWFjdC5Db21wb25lbnQuIFRoaXMgaXMgbGlrZWx5IHRvIGNhdXNlIGVycm9ycy4gQ2hhbmdlICVzIHRvIGV4dGVuZCBSZWFjdC5Db21wb25lbnQgaW5zdGVhZC5cIixcbiAgICAgICAgICAgICAgICBjb21wb25lbnROYW1lJGpzY29tcCQzLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudE5hbWUkanNjb21wJDNcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgKGRpZFdhcm5BYm91dEJhZENsYXNzW2NvbXBvbmVudE5hbWUkanNjb21wJDNdID0gITApKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHZhbHVlID0gcmVuZGVyV2l0aEhvb2tzKFxuICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgIHRhc2ssXG4gICAgICAgICAgICBrZXlQYXRoLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgdm9pZCAwXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoMTIgPT09IHJlcXVlc3Quc3RhdHVzKSB0aHJvdyBudWxsO1xuICAgICAgICAgIHZhciBoYXNJZCA9IDAgIT09IGxvY2FsSWRDb3VudGVyLFxuICAgICAgICAgICAgYWN0aW9uU3RhdGVDb3VudCA9IGFjdGlvblN0YXRlQ291bnRlcixcbiAgICAgICAgICAgIGFjdGlvblN0YXRlTWF0Y2hpbmdJbmRleCRqc2NvbXAkMCA9IGFjdGlvblN0YXRlTWF0Y2hpbmdJbmRleDtcbiAgICAgICAgICBpZiAodHlwZS5jb250ZXh0VHlwZXMpIHtcbiAgICAgICAgICAgIHZhciBfY29tcG9uZW50TmFtZSRqc2NvbXAkMCA9XG4gICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCBcIlVua25vd25cIjtcbiAgICAgICAgICAgIGRpZFdhcm5BYm91dENvbnRleHRUeXBlc1tfY29tcG9uZW50TmFtZSRqc2NvbXAkMF0gfHxcbiAgICAgICAgICAgICAgKChkaWRXYXJuQWJvdXRDb250ZXh0VHlwZXNbX2NvbXBvbmVudE5hbWUkanNjb21wJDBdID0gITApLFxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiJXMgdXNlcyB0aGUgbGVnYWN5IGNvbnRleHRUeXBlcyBBUEkgd2hpY2ggd2FzIHJlbW92ZWQgaW4gUmVhY3QgMTkuIFVzZSBSZWFjdC5jcmVhdGVDb250ZXh0KCkgd2l0aCBSZWFjdC51c2VDb250ZXh0KCkgaW5zdGVhZC4gKGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvbGVnYWN5LWNvbnRleHQpXCIsXG4gICAgICAgICAgICAgICAgX2NvbXBvbmVudE5hbWUkanNjb21wJDBcbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHR5cGUgJiZcbiAgICAgICAgICAgIHR5cGUuY2hpbGRDb250ZXh0VHlwZXMgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiY2hpbGRDb250ZXh0VHlwZXMgY2Fubm90IGJlIGRlZmluZWQgb24gYSBmdW5jdGlvbiBjb21wb25lbnQuXFxuICAlcy5jaGlsZENvbnRleHRUeXBlcyA9IC4uLlwiLFxuICAgICAgICAgICAgICB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBcIkNvbXBvbmVudFwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcykge1xuICAgICAgICAgICAgdmFyIF9jb21wb25lbnROYW1lMiA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCBcIlVua25vd25cIjtcbiAgICAgICAgICAgIGRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnRbX2NvbXBvbmVudE5hbWUyXSB8fFxuICAgICAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIiVzOiBGdW5jdGlvbiBjb21wb25lbnRzIGRvIG5vdCBzdXBwb3J0IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy5cIixcbiAgICAgICAgICAgICAgICBfY29tcG9uZW50TmFtZTJcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgKGRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnRbX2NvbXBvbmVudE5hbWUyXSA9XG4gICAgICAgICAgICAgICAgITApKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUuY29udGV4dFR5cGUgJiZcbiAgICAgICAgICAgIG51bGwgIT09IHR5cGUuY29udGV4dFR5cGVcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciBfY29tcG9uZW50TmFtZTMgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgXCJVbmtub3duXCI7XG4gICAgICAgICAgICBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnRbX2NvbXBvbmVudE5hbWUzXSB8fFxuICAgICAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIiVzOiBGdW5jdGlvbiBjb21wb25lbnRzIGRvIG5vdCBzdXBwb3J0IGNvbnRleHRUeXBlLlwiLFxuICAgICAgICAgICAgICAgIF9jb21wb25lbnROYW1lM1xuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAoZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lM10gPVxuICAgICAgICAgICAgICAgICEwKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZpbmlzaEZ1bmN0aW9uQ29tcG9uZW50KFxuICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgIHRhc2ssXG4gICAgICAgICAgICBrZXlQYXRoLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBoYXNJZCxcbiAgICAgICAgICAgIGFjdGlvblN0YXRlQ291bnQsXG4gICAgICAgICAgICBhY3Rpb25TdGF0ZU1hdGNoaW5nSW5kZXgkanNjb21wJDBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICBlbHNlIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZSkge1xuICAgICAgICB2YXIgc2VnbWVudCA9IHRhc2suYmxvY2tlZFNlZ21lbnQ7XG4gICAgICAgIGlmIChudWxsID09PSBzZWdtZW50KSB7XG4gICAgICAgICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICAgICAgICBwcmV2Q29udGV4dCA9IHRhc2suZm9ybWF0Q29udGV4dCxcbiAgICAgICAgICAgIHByZXZLZXlQYXRoJGpzY29tcCQwID0gdGFzay5rZXlQYXRoO1xuICAgICAgICAgIHRhc2suZm9ybWF0Q29udGV4dCA9IGdldENoaWxkRm9ybWF0Q29udGV4dChwcmV2Q29udGV4dCwgdHlwZSwgcHJvcHMpO1xuICAgICAgICAgIHRhc2sua2V5UGF0aCA9IGtleVBhdGg7XG4gICAgICAgICAgcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBjaGlsZHJlbiwgLTEpO1xuICAgICAgICAgIHRhc2suZm9ybWF0Q29udGV4dCA9IHByZXZDb250ZXh0O1xuICAgICAgICAgIHRhc2sua2V5UGF0aCA9IHByZXZLZXlQYXRoJGpzY29tcCQwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfY2hpbGRyZW4gPSBwdXNoU3RhcnRJbnN0YW5jZShcbiAgICAgICAgICAgIHNlZ21lbnQuY2h1bmtzLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgcmVxdWVzdC5yZXN1bWFibGVTdGF0ZSxcbiAgICAgICAgICAgIHJlcXVlc3QucmVuZGVyU3RhdGUsXG4gICAgICAgICAgICB0YXNrLmhvaXN0YWJsZVN0YXRlLFxuICAgICAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0LFxuICAgICAgICAgICAgc2VnbWVudC5sYXN0UHVzaGVkVGV4dCxcbiAgICAgICAgICAgIHRhc2suaXNGYWxsYmFja1xuICAgICAgICAgICk7XG4gICAgICAgICAgc2VnbWVudC5sYXN0UHVzaGVkVGV4dCA9ICExO1xuICAgICAgICAgIHZhciBfcHJldkNvbnRleHQgPSB0YXNrLmZvcm1hdENvbnRleHQsXG4gICAgICAgICAgICBfcHJldktleVBhdGgyID0gdGFzay5rZXlQYXRoO1xuICAgICAgICAgIHRhc2suZm9ybWF0Q29udGV4dCA9IGdldENoaWxkRm9ybWF0Q29udGV4dChfcHJldkNvbnRleHQsIHR5cGUsIHByb3BzKTtcbiAgICAgICAgICB0YXNrLmtleVBhdGggPSBrZXlQYXRoO1xuICAgICAgICAgIHJlbmRlck5vZGUocmVxdWVzdCwgdGFzaywgX2NoaWxkcmVuLCAtMSk7XG4gICAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0ID0gX3ByZXZDb250ZXh0O1xuICAgICAgICAgIHRhc2sua2V5UGF0aCA9IF9wcmV2S2V5UGF0aDI7XG4gICAgICAgICAgYToge1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHNlZ21lbnQuY2h1bmtzLFxuICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZSA9IHJlcXVlc3QucmVzdW1hYmxlU3RhdGU7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcInRpdGxlXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgICAgICAgICBjYXNlIFwic2NyaXB0XCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJhcmVhXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJiYXNlXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJiclwiOlxuICAgICAgICAgICAgICBjYXNlIFwiY29sXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbWJlZFwiOlxuICAgICAgICAgICAgICBjYXNlIFwiaHJcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImltZ1wiOlxuICAgICAgICAgICAgICBjYXNlIFwiaW5wdXRcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImtleWdlblwiOlxuICAgICAgICAgICAgICBjYXNlIFwibGlua1wiOlxuICAgICAgICAgICAgICBjYXNlIFwibWV0YVwiOlxuICAgICAgICAgICAgICBjYXNlIFwicGFyYW1cIjpcbiAgICAgICAgICAgICAgY2FzZSBcInNvdXJjZVwiOlxuICAgICAgICAgICAgICBjYXNlIFwidHJhY2tcIjpcbiAgICAgICAgICAgICAgY2FzZSBcIndiclwiOlxuICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIGNhc2UgXCJib2R5XCI6XG4gICAgICAgICAgICAgICAgaWYgKF9wcmV2Q29udGV4dC5pbnNlcnRpb25Nb2RlIDw9IEhUTUxfSFRNTF9NT0RFKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZS5oYXNCb2R5ID0gITA7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcImh0bWxcIjpcbiAgICAgICAgICAgICAgICBpZiAoX3ByZXZDb250ZXh0Lmluc2VydGlvbk1vZGUgPT09IFJPT1RfSFRNTF9NT0RFKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZS5oYXNIdG1sID0gITA7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhcmdldC5wdXNoKGVuZENodW5rRm9yVGFnKHR5cGUpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VnbWVudC5sYXN0UHVzaGVkVGV4dCA9ICExO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICAgICAgdmFyIHByZXZLZXlQYXRoJGpzY29tcCQxID0gdGFzay5rZXlQYXRoO1xuICAgICAgICAgICAgdGFzay5rZXlQYXRoID0ga2V5UGF0aDtcbiAgICAgICAgICAgIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBwcm9wcy5jaGlsZHJlbiwgLTEpO1xuICAgICAgICAgICAgdGFzay5rZXlQYXRoID0gcHJldktleVBhdGgkanNjb21wJDE7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgY2FzZSBSRUFDVF9PRkZTQ1JFRU5fVFlQRTpcbiAgICAgICAgICAgIGlmIChcImhpZGRlblwiICE9PSBwcm9wcy5tb2RlKSB7XG4gICAgICAgICAgICAgIHZhciBwcmV2S2V5UGF0aCRqc2NvbXAkMiA9IHRhc2sua2V5UGF0aDtcbiAgICAgICAgICAgICAgdGFzay5rZXlQYXRoID0ga2V5UGF0aDtcbiAgICAgICAgICAgICAgcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIHByb3BzLmNoaWxkcmVuLCAtMSk7XG4gICAgICAgICAgICAgIHRhc2sua2V5UGF0aCA9IHByZXZLZXlQYXRoJGpzY29tcCQyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgICAgdmFyIF9wcmV2S2V5UGF0aDMgPSB0YXNrLmtleVBhdGg7XG4gICAgICAgICAgICB0YXNrLmtleVBhdGggPSBrZXlQYXRoO1xuICAgICAgICAgICAgcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIHByb3BzLmNoaWxkcmVuLCAtMSk7XG4gICAgICAgICAgICB0YXNrLmtleVBhdGggPSBfcHJldktleVBhdGgzO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfU0NPUEVfVFlQRTpcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICBcIlJlYWN0RE9NU2VydmVyIGRvZXMgbm90IHlldCBzdXBwb3J0IHNjb3BlIGNvbXBvbmVudHMuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgICAgYTogaWYgKG51bGwgIT09IHRhc2sucmVwbGF5KSB7XG4gICAgICAgICAgICAgIHZhciBfcHJldktleVBhdGggPSB0YXNrLmtleVBhdGg7XG4gICAgICAgICAgICAgIHRhc2sua2V5UGF0aCA9IGtleVBhdGg7XG4gICAgICAgICAgICAgIHZhciBfY29udGVudCA9IHByb3BzLmNoaWxkcmVuO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlbmRlck5vZGUocmVxdWVzdCwgdGFzaywgX2NvbnRlbnQsIC0xKTtcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0YXNrLmtleVBhdGggPSBfcHJldktleVBhdGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBwcmV2S2V5UGF0aCRqc2NvbXAkMyA9IHRhc2sua2V5UGF0aCxcbiAgICAgICAgICAgICAgICBwYXJlbnRCb3VuZGFyeSA9IHRhc2suYmxvY2tlZEJvdW5kYXJ5LFxuICAgICAgICAgICAgICAgIHBhcmVudEhvaXN0YWJsZVN0YXRlID0gdGFzay5ob2lzdGFibGVTdGF0ZSxcbiAgICAgICAgICAgICAgICBwYXJlbnRTZWdtZW50ID0gdGFzay5ibG9ja2VkU2VnbWVudCxcbiAgICAgICAgICAgICAgICBmYWxsYmFjayA9IHByb3BzLmZhbGxiYWNrLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgICAgICAgICAgICBmYWxsYmFja0Fib3J0U2V0ID0gbmV3IFNldCgpLFxuICAgICAgICAgICAgICAgIG5ld0JvdW5kYXJ5ID0gY3JlYXRlU3VzcGVuc2VCb3VuZGFyeShyZXF1ZXN0LCBmYWxsYmFja0Fib3J0U2V0KTtcbiAgICAgICAgICAgICAgbnVsbCAhPT0gcmVxdWVzdC50cmFja2VkUG9zdHBvbmVzICYmXG4gICAgICAgICAgICAgICAgKG5ld0JvdW5kYXJ5LnRyYWNrZWRDb250ZW50S2V5UGF0aCA9IGtleVBhdGgpO1xuICAgICAgICAgICAgICB2YXIgYm91bmRhcnlTZWdtZW50ID0gY3JlYXRlUGVuZGluZ1NlZ21lbnQoXG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICBwYXJlbnRTZWdtZW50LmNodW5rcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgbmV3Qm91bmRhcnksXG4gICAgICAgICAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0LFxuICAgICAgICAgICAgICAgICExLFxuICAgICAgICAgICAgICAgICExXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHBhcmVudFNlZ21lbnQuY2hpbGRyZW4ucHVzaChib3VuZGFyeVNlZ21lbnQpO1xuICAgICAgICAgICAgICBwYXJlbnRTZWdtZW50Lmxhc3RQdXNoZWRUZXh0ID0gITE7XG4gICAgICAgICAgICAgIHZhciBjb250ZW50Um9vdFNlZ21lbnQgPSBjcmVhdGVQZW5kaW5nU2VnbWVudChcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQsXG4gICAgICAgICAgICAgICAgITEsXG4gICAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgY29udGVudFJvb3RTZWdtZW50LnBhcmVudEZsdXNoZWQgPSAhMDtcbiAgICAgICAgICAgICAgaWYgKG51bGwgIT09IHJlcXVlc3QudHJhY2tlZFBvc3Rwb25lcykge1xuICAgICAgICAgICAgICAgIHZhciBmYWxsYmFja0tleVBhdGggPSBbXG4gICAgICAgICAgICAgICAgICAgIGtleVBhdGhbMF0sXG4gICAgICAgICAgICAgICAgICAgIFwiU3VzcGVuc2UgRmFsbGJhY2tcIixcbiAgICAgICAgICAgICAgICAgICAga2V5UGF0aFsyXVxuICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgIGZhbGxiYWNrUmVwbGF5Tm9kZSA9IFtcbiAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2tLZXlQYXRoWzFdLFxuICAgICAgICAgICAgICAgICAgICBmYWxsYmFja0tleVBhdGhbMl0sXG4gICAgICAgICAgICAgICAgICAgIFtdLFxuICAgICAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIHJlcXVlc3QudHJhY2tlZFBvc3Rwb25lcy53b3JraW5nTWFwLnNldChcbiAgICAgICAgICAgICAgICAgIGZhbGxiYWNrS2V5UGF0aCxcbiAgICAgICAgICAgICAgICAgIGZhbGxiYWNrUmVwbGF5Tm9kZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgbmV3Qm91bmRhcnkudHJhY2tlZEZhbGxiYWNrTm9kZSA9IGZhbGxiYWNrUmVwbGF5Tm9kZTtcbiAgICAgICAgICAgICAgICB0YXNrLmJsb2NrZWRTZWdtZW50ID0gYm91bmRhcnlTZWdtZW50O1xuICAgICAgICAgICAgICAgIHRhc2sua2V5UGF0aCA9IGZhbGxiYWNrS2V5UGF0aDtcbiAgICAgICAgICAgICAgICBib3VuZGFyeVNlZ21lbnQuc3RhdHVzID0gNjtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBmYWxsYmFjaywgLTEpLFxuICAgICAgICAgICAgICAgICAgICBib3VuZGFyeVNlZ21lbnQubGFzdFB1c2hlZFRleHQgJiZcbiAgICAgICAgICAgICAgICAgICAgICBib3VuZGFyeVNlZ21lbnQudGV4dEVtYmVkZGVkICYmXG4gICAgICAgICAgICAgICAgICAgICAgYm91bmRhcnlTZWdtZW50LmNodW5rcy5wdXNoKHRleHRTZXBhcmF0b3IpLFxuICAgICAgICAgICAgICAgICAgICAoYm91bmRhcnlTZWdtZW50LnN0YXR1cyA9IENPTVBMRVRFRCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAodGhyb3duVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IChcbiAgICAgICAgICAgICAgICAgICAgKChib3VuZGFyeVNlZ21lbnQuc3RhdHVzID0gMTIgPT09IHJlcXVlc3Quc3RhdHVzID8gMyA6IDQpLFxuICAgICAgICAgICAgICAgICAgICB0aHJvd25WYWx1ZSlcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICh0YXNrLmJsb2NrZWRTZWdtZW50ID0gcGFyZW50U2VnbWVudCksXG4gICAgICAgICAgICAgICAgICAgICh0YXNrLmtleVBhdGggPSBwcmV2S2V5UGF0aCRqc2NvbXAkMyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzdXNwZW5kZWRQcmltYXJ5VGFzayA9IGNyZWF0ZVJlbmRlclRhc2soXG4gICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAtMSxcbiAgICAgICAgICAgICAgICAgIG5ld0JvdW5kYXJ5LFxuICAgICAgICAgICAgICAgICAgY29udGVudFJvb3RTZWdtZW50LFxuICAgICAgICAgICAgICAgICAgbmV3Qm91bmRhcnkuY29udGVudFN0YXRlLFxuICAgICAgICAgICAgICAgICAgdGFzay5hYm9ydFNldCxcbiAgICAgICAgICAgICAgICAgIGtleVBhdGgsXG4gICAgICAgICAgICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQsXG4gICAgICAgICAgICAgICAgICB0YXNrLmNvbnRleHQsXG4gICAgICAgICAgICAgICAgICB0YXNrLnRyZWVDb250ZXh0LFxuICAgICAgICAgICAgICAgICAgdGFzay5jb21wb25lbnRTdGFjayxcbiAgICAgICAgICAgICAgICAgIHRhc2suaXNGYWxsYmFja1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcHVzaENvbXBvbmVudFN0YWNrKHN1c3BlbmRlZFByaW1hcnlUYXNrKTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnBpbmdlZFRhc2tzLnB1c2goc3VzcGVuZGVkUHJpbWFyeVRhc2spO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhc2suYmxvY2tlZEJvdW5kYXJ5ID0gbmV3Qm91bmRhcnk7XG4gICAgICAgICAgICAgICAgdGFzay5ob2lzdGFibGVTdGF0ZSA9IG5ld0JvdW5kYXJ5LmNvbnRlbnRTdGF0ZTtcbiAgICAgICAgICAgICAgICB0YXNrLmJsb2NrZWRTZWdtZW50ID0gY29udGVudFJvb3RTZWdtZW50O1xuICAgICAgICAgICAgICAgIHRhc2sua2V5UGF0aCA9IGtleVBhdGg7XG4gICAgICAgICAgICAgICAgY29udGVudFJvb3RTZWdtZW50LnN0YXR1cyA9IDY7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgKHJlbmRlck5vZGUocmVxdWVzdCwgdGFzaywgY29udGVudCwgLTEpLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50Um9vdFNlZ21lbnQubGFzdFB1c2hlZFRleHQgJiZcbiAgICAgICAgICAgICAgICAgICAgICBjb250ZW50Um9vdFNlZ21lbnQudGV4dEVtYmVkZGVkICYmXG4gICAgICAgICAgICAgICAgICAgICAgY29udGVudFJvb3RTZWdtZW50LmNodW5rcy5wdXNoKHRleHRTZXBhcmF0b3IpLFxuICAgICAgICAgICAgICAgICAgICAoY29udGVudFJvb3RTZWdtZW50LnN0YXR1cyA9IENPTVBMRVRFRCksXG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlQ29tcGxldGVkU2VnbWVudChuZXdCb3VuZGFyeSwgY29udGVudFJvb3RTZWdtZW50KSxcbiAgICAgICAgICAgICAgICAgICAgMCA9PT0gbmV3Qm91bmRhcnkucGVuZGluZ1Rhc2tzICYmXG4gICAgICAgICAgICAgICAgICAgICAgbmV3Qm91bmRhcnkuc3RhdHVzID09PSBQRU5ESU5HKVxuICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0JvdW5kYXJ5LnN0YXR1cyA9IENPTVBMRVRFRDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoICh0aHJvd25WYWx1ZSQyKSB7XG4gICAgICAgICAgICAgICAgICBuZXdCb3VuZGFyeS5zdGF0dXMgPSBDTElFTlRfUkVOREVSRUQ7XG4gICAgICAgICAgICAgICAgICBpZiAoMTIgPT09IHJlcXVlc3Quc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRSb290U2VnbWVudC5zdGF0dXMgPSAzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSByZXF1ZXN0LmZhdGFsRXJyb3I7XG4gICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgKGNvbnRlbnRSb290U2VnbWVudC5zdGF0dXMgPSA0KSwgKGVycm9yID0gdGhyb3duVmFsdWUkMik7XG4gICAgICAgICAgICAgICAgICB2YXIgdGhyb3duSW5mbyA9IGdldFRocm93bkluZm8odGFzay5jb21wb25lbnRTdGFjayk7XG4gICAgICAgICAgICAgICAgICB2YXIgZXJyb3JEaWdlc3QgPSBsb2dSZWNvdmVyYWJsZUVycm9yKFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgdGhyb3duSW5mb1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGVuY29kZUVycm9yRm9yQm91bmRhcnkoXG4gICAgICAgICAgICAgICAgICAgIG5ld0JvdW5kYXJ5LFxuICAgICAgICAgICAgICAgICAgICBlcnJvckRpZ2VzdCxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIHRocm93bkluZm8sXG4gICAgICAgICAgICAgICAgICAgICExXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgdW50cmFja0JvdW5kYXJ5KHJlcXVlc3QsIG5ld0JvdW5kYXJ5KTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgKHRhc2suYmxvY2tlZEJvdW5kYXJ5ID0gcGFyZW50Qm91bmRhcnkpLFxuICAgICAgICAgICAgICAgICAgICAodGFzay5ob2lzdGFibGVTdGF0ZSA9IHBhcmVudEhvaXN0YWJsZVN0YXRlKSxcbiAgICAgICAgICAgICAgICAgICAgKHRhc2suYmxvY2tlZFNlZ21lbnQgPSBwYXJlbnRTZWdtZW50KSxcbiAgICAgICAgICAgICAgICAgICAgKHRhc2sua2V5UGF0aCA9IHByZXZLZXlQYXRoJGpzY29tcCQzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHN1c3BlbmRlZEZhbGxiYWNrVGFzayA9IGNyZWF0ZVJlbmRlclRhc2soXG4gICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgIGZhbGxiYWNrLFxuICAgICAgICAgICAgICAgICAgLTEsXG4gICAgICAgICAgICAgICAgICBwYXJlbnRCb3VuZGFyeSxcbiAgICAgICAgICAgICAgICAgIGJvdW5kYXJ5U2VnbWVudCxcbiAgICAgICAgICAgICAgICAgIG5ld0JvdW5kYXJ5LmZhbGxiYWNrU3RhdGUsXG4gICAgICAgICAgICAgICAgICBmYWxsYmFja0Fib3J0U2V0LFxuICAgICAgICAgICAgICAgICAgW2tleVBhdGhbMF0sIFwiU3VzcGVuc2UgRmFsbGJhY2tcIiwga2V5UGF0aFsyXV0sXG4gICAgICAgICAgICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQsXG4gICAgICAgICAgICAgICAgICB0YXNrLmNvbnRleHQsXG4gICAgICAgICAgICAgICAgICB0YXNrLnRyZWVDb250ZXh0LFxuICAgICAgICAgICAgICAgICAgdGFzay5jb21wb25lbnRTdGFjayxcbiAgICAgICAgICAgICAgICAgICEwXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBwdXNoQ29tcG9uZW50U3RhY2soc3VzcGVuZGVkRmFsbGJhY2tUYXNrKTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnBpbmdlZFRhc2tzLnB1c2goc3VzcGVuZGVkRmFsbGJhY2tUYXNrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSAmJiBudWxsICE9PSB0eXBlKVxuICAgICAgICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgICBpZiAoXCJyZWZcIiBpbiBwcm9wcykge1xuICAgICAgICAgICAgICAgIHZhciBwcm9wc1dpdGhvdXRSZWYgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpXG4gICAgICAgICAgICAgICAgICBcInJlZlwiICE9PSBrZXkgJiYgKHByb3BzV2l0aG91dFJlZltrZXldID0gcHJvcHNba2V5XSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBwcm9wc1dpdGhvdXRSZWYgPSBwcm9wcztcbiAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuJGpzY29tcCQwID0gcmVuZGVyV2l0aEhvb2tzKFxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgdGFzayxcbiAgICAgICAgICAgICAgICBrZXlQYXRoLFxuICAgICAgICAgICAgICAgIHR5cGUucmVuZGVyLFxuICAgICAgICAgICAgICAgIHByb3BzV2l0aG91dFJlZixcbiAgICAgICAgICAgICAgICByZWZcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgZmluaXNoRnVuY3Rpb25Db21wb25lbnQoXG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICB0YXNrLFxuICAgICAgICAgICAgICAgIGtleVBhdGgsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4kanNjb21wJDAsXG4gICAgICAgICAgICAgICAgMCAhPT0gbG9jYWxJZENvdW50ZXIsXG4gICAgICAgICAgICAgICAgYWN0aW9uU3RhdGVDb3VudGVyLFxuICAgICAgICAgICAgICAgIGFjdGlvblN0YXRlTWF0Y2hpbmdJbmRleFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgICAgcmVuZGVyRWxlbWVudChyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCB0eXBlLnR5cGUsIHByb3BzLCByZWYpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgICAgdmFyIHZhbHVlJGpzY29tcCQwID0gcHJvcHMudmFsdWUsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4kanNjb21wJDEgPSBwcm9wcy5jaGlsZHJlbjtcbiAgICAgICAgICAgICAgdmFyIHByZXZTbmFwc2hvdCA9IHRhc2suY29udGV4dDtcbiAgICAgICAgICAgICAgdmFyIHByZXZLZXlQYXRoJGpzY29tcCQ0ID0gdGFzay5rZXlQYXRoO1xuICAgICAgICAgICAgICB2YXIgcHJldlZhbHVlID0gdHlwZS5fY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgICB0eXBlLl9jdXJyZW50VmFsdWUgPSB2YWx1ZSRqc2NvbXAkMDtcbiAgICAgICAgICAgICAgdm9pZCAwICE9PSB0eXBlLl9jdXJyZW50UmVuZGVyZXIgJiZcbiAgICAgICAgICAgICAgICBudWxsICE9PSB0eXBlLl9jdXJyZW50UmVuZGVyZXIgJiZcbiAgICAgICAgICAgICAgICB0eXBlLl9jdXJyZW50UmVuZGVyZXIgIT09IHJlbmRlcmVyU2lnaWwgJiZcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJEZXRlY3RlZCBtdWx0aXBsZSByZW5kZXJlcnMgY29uY3VycmVudGx5IHJlbmRlcmluZyB0aGUgc2FtZSBjb250ZXh0IHByb3ZpZGVyLiBUaGlzIGlzIGN1cnJlbnRseSB1bnN1cHBvcnRlZC5cIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHR5cGUuX2N1cnJlbnRSZW5kZXJlciA9IHJlbmRlcmVyU2lnaWw7XG4gICAgICAgICAgICAgIHZhciBwcmV2Tm9kZSA9IGN1cnJlbnRBY3RpdmVTbmFwc2hvdCxcbiAgICAgICAgICAgICAgICBuZXdOb2RlID0ge1xuICAgICAgICAgICAgICAgICAgcGFyZW50OiBwcmV2Tm9kZSxcbiAgICAgICAgICAgICAgICAgIGRlcHRoOiBudWxsID09PSBwcmV2Tm9kZSA/IDAgOiBwcmV2Tm9kZS5kZXB0aCArIDEsXG4gICAgICAgICAgICAgICAgICBjb250ZXh0OiB0eXBlLFxuICAgICAgICAgICAgICAgICAgcGFyZW50VmFsdWU6IHByZXZWYWx1ZSxcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSRqc2NvbXAkMFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGN1cnJlbnRBY3RpdmVTbmFwc2hvdCA9IG5ld05vZGU7XG4gICAgICAgICAgICAgIHRhc2suY29udGV4dCA9IG5ld05vZGU7XG4gICAgICAgICAgICAgIHRhc2sua2V5UGF0aCA9IGtleVBhdGg7XG4gICAgICAgICAgICAgIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBjaGlsZHJlbiRqc2NvbXAkMSwgLTEpO1xuICAgICAgICAgICAgICB2YXIgcHJldlNuYXBzaG90JGpzY29tcCQwID0gY3VycmVudEFjdGl2ZVNuYXBzaG90O1xuICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gcHJldlNuYXBzaG90JGpzY29tcCQwKVxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJUcmllZCB0byBwb3AgYSBDb250ZXh0IGF0IHRoZSByb290IG9mIHRoZSBhcHAuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBwcmV2U25hcHNob3QkanNjb21wJDAuY29udGV4dCAhPT0gdHlwZSAmJlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlRoZSBwYXJlbnQgY29udGV4dCBpcyBub3QgdGhlIGV4cGVjdGVkIGNvbnRleHQuIFRoaXMgaXMgcHJvYmFibHkgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBwcmV2U25hcHNob3QkanNjb21wJDAuY29udGV4dC5fY3VycmVudFZhbHVlID1cbiAgICAgICAgICAgICAgICBwcmV2U25hcHNob3QkanNjb21wJDAucGFyZW50VmFsdWU7XG4gICAgICAgICAgICAgIHZvaWQgMCAhPT0gdHlwZS5fY3VycmVudFJlbmRlcmVyICYmXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gdHlwZS5fY3VycmVudFJlbmRlcmVyICYmXG4gICAgICAgICAgICAgICAgdHlwZS5fY3VycmVudFJlbmRlcmVyICE9PSByZW5kZXJlclNpZ2lsICYmXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiRGV0ZWN0ZWQgbXVsdGlwbGUgcmVuZGVyZXJzIGNvbmN1cnJlbnRseSByZW5kZXJpbmcgdGhlIHNhbWUgY29udGV4dCBwcm92aWRlci4gVGhpcyBpcyBjdXJyZW50bHkgdW5zdXBwb3J0ZWQuXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB0eXBlLl9jdXJyZW50UmVuZGVyZXIgPSByZW5kZXJlclNpZ2lsO1xuICAgICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwID0gKGN1cnJlbnRBY3RpdmVTbmFwc2hvdCA9XG4gICAgICAgICAgICAgICAgcHJldlNuYXBzaG90JGpzY29tcCQwLnBhcmVudCk7XG4gICAgICAgICAgICAgIHRhc2suY29udGV4dCA9IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMDtcbiAgICAgICAgICAgICAgdGFzay5rZXlQYXRoID0gcHJldktleVBhdGgkanNjb21wJDQ7XG4gICAgICAgICAgICAgIHByZXZTbmFwc2hvdCAhPT0gdGFzay5jb250ZXh0ICYmXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiUG9wcGluZyB0aGUgY29udGV4dCBwcm92aWRlciBkaWQgbm90IHJldHVybiBiYWNrIHRvIHRoZSBvcmlnaW5hbCBzbmFwc2hvdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OU1VNRVJfVFlQRTpcbiAgICAgICAgICAgICAgdmFyIGNvbnRleHQkanNjb21wJDAgPSB0eXBlLl9jb250ZXh0LFxuICAgICAgICAgICAgICAgIHJlbmRlciA9IHByb3BzLmNoaWxkcmVuO1xuICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiByZW5kZXIgJiZcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJBIGNvbnRleHQgY29uc3VtZXIgd2FzIHJlbmRlcmVkIHdpdGggbXVsdGlwbGUgY2hpbGRyZW4sIG9yIGEgY2hpbGQgdGhhdCBpc24ndCBhIGZ1bmN0aW9uLiBBIGNvbnRleHQgY29uc3VtZXIgZXhwZWN0cyBhIHNpbmdsZSBjaGlsZCB0aGF0IGlzIGEgZnVuY3Rpb24uIElmIHlvdSBkaWQgcGFzcyBhIGZ1bmN0aW9uLCBtYWtlIHN1cmUgdGhlcmUgaXMgbm8gdHJhaWxpbmcgb3IgbGVhZGluZyB3aGl0ZXNwYWNlIGFyb3VuZCBpdC5cIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHZhciBuZXdDaGlsZHJlbiA9IHJlbmRlcihjb250ZXh0JGpzY29tcCQwLl9jdXJyZW50VmFsdWUpLFxuICAgICAgICAgICAgICAgIHByZXZLZXlQYXRoJGpzY29tcCQ1ID0gdGFzay5rZXlQYXRoO1xuICAgICAgICAgICAgICB0YXNrLmtleVBhdGggPSBrZXlQYXRoO1xuICAgICAgICAgICAgICByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgbmV3Q2hpbGRyZW4sIC0xKTtcbiAgICAgICAgICAgICAgdGFzay5rZXlQYXRoID0gcHJldktleVBhdGgkanNjb21wJDU7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgICB2YXIgQ29tcG9uZW50ID0gY2FsbExhenlJbml0SW5ERVYodHlwZSk7XG4gICAgICAgICAgICAgIGlmICgxMiA9PT0gcmVxdWVzdC5zdGF0dXMpIHRocm93IG51bGw7XG4gICAgICAgICAgICAgIHJlbmRlckVsZW1lbnQocmVxdWVzdCwgdGFzaywga2V5UGF0aCwgQ29tcG9uZW50LCBwcm9wcywgcmVmKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgdmFyIGluZm8gPSBcIlwiO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgdm9pZCAwID09PSB0eXBlIHx8XG4gICAgICAgICAgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlICYmXG4gICAgICAgICAgICBudWxsICE9PSB0eXBlICYmXG4gICAgICAgICAgICAwID09PSBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGgpXG4gICAgICAgIClcbiAgICAgICAgICBpbmZvICs9XG4gICAgICAgICAgICBcIiBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSBpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiRWxlbWVudCB0eXBlIGlzIGludmFsaWQ6IGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBidXQgZ290OiBcIiArXG4gICAgICAgICAgICAoKG51bGwgPT0gdHlwZSA/IHR5cGUgOiB0eXBlb2YgdHlwZSkgKyBcIi5cIiArIGluZm8pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc3VtZU5vZGUocmVxdWVzdCwgdGFzaywgc2VnbWVudElkLCBub2RlLCBjaGlsZEluZGV4KSB7XG4gICAgICB2YXIgcHJldlJlcGxheSA9IHRhc2sucmVwbGF5LFxuICAgICAgICBibG9ja2VkQm91bmRhcnkgPSB0YXNrLmJsb2NrZWRCb3VuZGFyeSxcbiAgICAgICAgcmVzdW1lZFNlZ21lbnQgPSBjcmVhdGVQZW5kaW5nU2VnbWVudChcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIDAsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQsXG4gICAgICAgICAgITEsXG4gICAgICAgICAgITFcbiAgICAgICAgKTtcbiAgICAgIHJlc3VtZWRTZWdtZW50LmlkID0gc2VnbWVudElkO1xuICAgICAgcmVzdW1lZFNlZ21lbnQucGFyZW50Rmx1c2hlZCA9ICEwO1xuICAgICAgdHJ5IHtcbiAgICAgICAgKHRhc2sucmVwbGF5ID0gbnVsbCksXG4gICAgICAgICAgKHRhc2suYmxvY2tlZFNlZ21lbnQgPSByZXN1bWVkU2VnbWVudCksXG4gICAgICAgICAgcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBub2RlLCBjaGlsZEluZGV4KSxcbiAgICAgICAgICAocmVzdW1lZFNlZ21lbnQuc3RhdHVzID0gQ09NUExFVEVEKSxcbiAgICAgICAgICBudWxsID09PSBibG9ja2VkQm91bmRhcnlcbiAgICAgICAgICAgID8gKHJlcXVlc3QuY29tcGxldGVkUm9vdFNlZ21lbnQgPSByZXN1bWVkU2VnbWVudClcbiAgICAgICAgICAgIDogKHF1ZXVlQ29tcGxldGVkU2VnbWVudChibG9ja2VkQm91bmRhcnksIHJlc3VtZWRTZWdtZW50KSxcbiAgICAgICAgICAgICAgYmxvY2tlZEJvdW5kYXJ5LnBhcmVudEZsdXNoZWQgJiZcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnBhcnRpYWxCb3VuZGFyaWVzLnB1c2goYmxvY2tlZEJvdW5kYXJ5KSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICAodGFzay5yZXBsYXkgPSBwcmV2UmVwbGF5KSwgKHRhc2suYmxvY2tlZFNlZ21lbnQgPSBudWxsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIG5vZGUsIGNoaWxkSW5kZXgpIHtcbiAgICAgIG51bGwgIT09IHRhc2sucmVwbGF5ICYmIFwibnVtYmVyXCIgPT09IHR5cGVvZiB0YXNrLnJlcGxheS5zbG90c1xuICAgICAgICA/IHJlc3VtZU5vZGUocmVxdWVzdCwgdGFzaywgdGFzay5yZXBsYXkuc2xvdHMsIG5vZGUsIGNoaWxkSW5kZXgpXG4gICAgICAgIDogKCh0YXNrLm5vZGUgPSBub2RlKSxcbiAgICAgICAgICAodGFzay5jaGlsZEluZGV4ID0gY2hpbGRJbmRleCksXG4gICAgICAgICAgKG5vZGUgPSB0YXNrLmNvbXBvbmVudFN0YWNrKSxcbiAgICAgICAgICBwdXNoQ29tcG9uZW50U3RhY2sodGFzayksXG4gICAgICAgICAgcmV0cnlOb2RlKHJlcXVlc3QsIHRhc2spLFxuICAgICAgICAgICh0YXNrLmNvbXBvbmVudFN0YWNrID0gbm9kZSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXRyeU5vZGUocmVxdWVzdCwgdGFzaykge1xuICAgICAgdmFyIG5vZGUgPSB0YXNrLm5vZGUsXG4gICAgICAgIGNoaWxkSW5kZXggPSB0YXNrLmNoaWxkSW5kZXg7XG4gICAgICBpZiAobnVsbCAhPT0gbm9kZSkge1xuICAgICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIG5vZGUpIHtcbiAgICAgICAgICBzd2l0Y2ggKG5vZGUuJCR0eXBlb2YpIHtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgICAgICB2YXIgdHlwZSA9IG5vZGUudHlwZSxcbiAgICAgICAgICAgICAgICBrZXkgPSBub2RlLmtleSxcbiAgICAgICAgICAgICAgICBwcm9wcyA9IG5vZGUucHJvcHM7XG4gICAgICAgICAgICAgIG5vZGUgPSBwcm9wcy5yZWY7XG4gICAgICAgICAgICAgIHZhciByZWYgPSB2b2lkIDAgIT09IG5vZGUgPyBub2RlIDogbnVsbCxcbiAgICAgICAgICAgICAgICBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpLFxuICAgICAgICAgICAgICAgIGtleU9ySW5kZXggPVxuICAgICAgICAgICAgICAgICAgbnVsbCA9PSBrZXkgPyAoLTEgPT09IGNoaWxkSW5kZXggPyAwIDogY2hpbGRJbmRleCkgOiBrZXksXG4gICAgICAgICAgICAgICAga2V5UGF0aCA9IFt0YXNrLmtleVBhdGgsIG5hbWUsIGtleU9ySW5kZXhdO1xuICAgICAgICAgICAgICBpZiAobnVsbCAhPT0gdGFzay5yZXBsYXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVwbGF5ID0gdGFzay5yZXBsYXk7XG4gICAgICAgICAgICAgICAgY2hpbGRJbmRleCA9IHJlcGxheS5ub2RlcztcbiAgICAgICAgICAgICAgICBmb3IgKG5vZGUgPSAwOyBub2RlIDwgY2hpbGRJbmRleC5sZW5ndGg7IG5vZGUrKylcbiAgICAgICAgICAgICAgICAgIGlmICgoKGtleSA9IGNoaWxkSW5kZXhbbm9kZV0pLCBrZXlPckluZGV4ID09PSBrZXlbMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICg0ID09PSBrZXkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKG51bGwgIT09IG5hbWUgJiYgbmFtZSAhPT0ga2V5WzBdKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiRXhwZWN0ZWQgdGhlIHJlc3VtZSB0byByZW5kZXIgPFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlbMF0gK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiPiBpbiB0aGlzIHNsb3QgYnV0IGluc3RlYWQgaXQgcmVuZGVyZWQgPFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIj4uIFRoZSB0cmVlIGRvZXNuJ3QgbWF0Y2ggc28gUmVhY3Qgd2lsbCBmYWxsYmFjayB0byBjbGllbnQgcmVuZGVyaW5nLlwiXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZE5vZGVzID0ga2V5WzJdO1xuICAgICAgICAgICAgICAgICAgICAgIGtleSA9IGtleVszXTtcbiAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gdGFzay5ub2RlO1xuICAgICAgICAgICAgICAgICAgICAgIHRhc2sucmVwbGF5ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXM6IGNoaWxkTm9kZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBzbG90czoga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1Rhc2tzOiAxXG4gICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyRWxlbWVudChyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCB0eXBlLCBwcm9wcywgcmVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgMSA9PT0gdGFzay5yZXBsYXkucGVuZGluZ1Rhc2tzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDAgPCB0YXNrLnJlcGxheS5ub2Rlcy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJDb3VsZG4ndCBmaW5kIGFsbCByZXN1bWFibGUgc2xvdHMgYnkga2V5L2luZGV4IGR1cmluZyByZXBsYXlpbmcuIFRoZSB0cmVlIGRvZXNuJ3QgbWF0Y2ggc28gUmVhY3Qgd2lsbCBmYWxsYmFjayB0byBjbGllbnQgcmVuZGVyaW5nLlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrLnJlcGxheS5wZW5kaW5nVGFza3MtLTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiB4ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwgIT09IHggJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKHggPT09IFN1c3BlbnNlRXhjZXB0aW9uIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgeC50aGVuKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRhc2subm9kZSA9PT0gbmFtZSAmJiAodGFzay5yZXBsYXkgPSByZXBsYXkpLCB4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFzay5yZXBsYXkucGVuZGluZ1Rhc2tzLS07XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wcyA9IGdldFRocm93bkluZm8odGFzay5jb21wb25lbnRTdGFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcmVkUmVwbGF5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0YXNrLmJsb2NrZWRCb3VuZGFyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGtleVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgdGFzay5yZXBsYXkgPSByZXBsYXk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgIT09IFJFQUNUX1NVU1BFTlNFX1RZUEUpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJFeHBlY3RlZCB0aGUgcmVzdW1lIHRvIHJlbmRlciA8U3VzcGVuc2U+IGluIHRoaXMgc2xvdCBidXQgaW5zdGVhZCBpdCByZW5kZXJlZCA8XCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgXCJVbmtub3duXCIpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIj4uIFRoZSB0cmVlIGRvZXNuJ3QgbWF0Y2ggc28gUmVhY3Qgd2lsbCBmYWxsYmFjayB0byBjbGllbnQgcmVuZGVyaW5nLlwiXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWYgPSBrZXlbNV07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXBsYXkgPSBrZXlbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0ga2V5WzNdO1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5T3JJbmRleCA9IG51bGwgPT09IGtleVs0XSA/IFtdIDoga2V5WzRdWzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gbnVsbCA9PT0ga2V5WzRdID8gbnVsbCA6IGtleVs0XVszXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcmV2S2V5UGF0aCA9IHRhc2sua2V5UGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNSZXBsYXlTZXQgPSB0YXNrLnJlcGxheSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Qm91bmRhcnkgPSB0YXNrLmJsb2NrZWRCb3VuZGFyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50SG9pc3RhYmxlU3RhdGUgPSB0YXNrLmhvaXN0YWJsZVN0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gcHJvcHMuY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wcyA9IHByb3BzLmZhbGxiYWNrO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZhbGxiYWNrQWJvcnRTZXQgPSBuZXcgU2V0KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VtZWRCb3VuZGFyeSA9IGNyZWF0ZVN1c3BlbnNlQm91bmRhcnkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxsYmFja0Fib3J0U2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bWVkQm91bmRhcnkucGFyZW50Rmx1c2hlZCA9ICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdW1lZEJvdW5kYXJ5LnJvb3RTZWdtZW50SUQgPSByZWY7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrLmJsb2NrZWRCb3VuZGFyeSA9IHJlc3VtZWRCb3VuZGFyeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2suaG9pc3RhYmxlU3RhdGUgPSByZXN1bWVkQm91bmRhcnkuY29udGVudFN0YXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFzay5rZXlQYXRoID0ga2V5UGF0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2sucmVwbGF5ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlczogcmVwbGF5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBzbG90czogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1Rhc2tzOiAxXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBjb250ZW50LCAtMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxID09PSB0YXNrLnJlcGxheS5wZW5kaW5nVGFza3MgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAwIDwgdGFzay5yZXBsYXkubm9kZXMubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiQ291bGRuJ3QgZmluZCBhbGwgcmVzdW1hYmxlIHNsb3RzIGJ5IGtleS9pbmRleCBkdXJpbmcgcmVwbGF5aW5nLiBUaGUgdHJlZSBkb2Vzbid0IG1hdGNoIHNvIFJlYWN0IHdpbGwgZmFsbGJhY2sgdG8gY2xpZW50IHJlbmRlcmluZy5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRhc2sucmVwbGF5LnBlbmRpbmdUYXNrcy0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMCA9PT0gcmVzdW1lZEJvdW5kYXJ5LnBlbmRpbmdUYXNrcyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VtZWRCb3VuZGFyeS5zdGF0dXMgPT09IFBFTkRJTkdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdW1lZEJvdW5kYXJ5LnN0YXR1cyA9IENPTVBMRVRFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmNvbXBsZXRlZEJvdW5kYXJpZXMucHVzaChyZXN1bWVkQm91bmRhcnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIChyZXN1bWVkQm91bmRhcnkuc3RhdHVzID0gQ0xJRU5UX1JFTkRFUkVEKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoY2hpbGROb2RlcyA9IGdldFRocm93bkluZm8odGFzay5jb21wb25lbnRTdGFjaykpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlID0gbG9nUmVjb3ZlcmFibGVFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVFcnJvckZvckJvdW5kYXJ5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdW1lZEJvdW5kYXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICExXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXNrLnJlcGxheS5wZW5kaW5nVGFza3MtLSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmNsaWVudFJlbmRlcmVkQm91bmRhcmllcy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdW1lZEJvdW5kYXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICh0YXNrLmJsb2NrZWRCb3VuZGFyeSA9IHBhcmVudEJvdW5kYXJ5KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAodGFzay5ob2lzdGFibGVTdGF0ZSA9IHBhcmVudEhvaXN0YWJsZVN0YXRlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAodGFzay5yZXBsYXkgPSBwcmV2aW91c1JlcGxheVNldCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRhc2sua2V5UGF0aCA9IHByZXZLZXlQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZXMgPSBjcmVhdGVSZXBsYXlUYXNrKFxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB7IG5vZGVzOiBrZXlPckluZGV4LCBzbG90czoga2V5LCBwZW5kaW5nVGFza3M6IDAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC0xLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRCb3VuZGFyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdW1lZEJvdW5kYXJ5LmZhbGxiYWNrU3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrQWJvcnRTZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFtrZXlQYXRoWzBdLCBcIlN1c3BlbnNlIEZhbGxiYWNrXCIsIGtleVBhdGhbMl1dLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRhc2suY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGFzay50cmVlQ29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGFzay5jb21wb25lbnRTdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgITBcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwdXNoQ29tcG9uZW50U3RhY2soY2hpbGROb2Rlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnBpbmdlZFRhc2tzLnB1c2goY2hpbGROb2Rlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkSW5kZXguc3BsaWNlKG5vZGUsIDEpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHJlbmRlckVsZW1lbnQocmVxdWVzdCwgdGFzaywga2V5UGF0aCwgdHlwZSwgcHJvcHMsIHJlZik7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiUG9ydGFscyBhcmUgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQgYnkgdGhlIHNlcnZlciByZW5kZXJlci4gUmVuZGVyIHRoZW0gY29uZGl0aW9uYWxseSBzbyB0aGF0IHRoZXkgb25seSBhcHBlYXIgb24gdGhlIGNsaWVudCByZW5kZXIuXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgICBub2RlID0gY2FsbExhenlJbml0SW5ERVYobm9kZSk7XG4gICAgICAgICAgICAgIGlmICgxMiA9PT0gcmVxdWVzdC5zdGF0dXMpIHRocm93IG51bGw7XG4gICAgICAgICAgICAgIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBub2RlLCBjaGlsZEluZGV4KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNBcnJheUltcGwobm9kZSkpIHtcbiAgICAgICAgICAgIHJlbmRlckNoaWxkcmVuQXJyYXkocmVxdWVzdCwgdGFzaywgbm9kZSwgY2hpbGRJbmRleCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIG51bGwgPT09IG5vZGUgfHwgXCJvYmplY3RcIiAhPT0gdHlwZW9mIG5vZGVcbiAgICAgICAgICAgID8gKHByb3BzID0gbnVsbClcbiAgICAgICAgICAgIDogKChjaGlsZE5vZGVzID1cbiAgICAgICAgICAgICAgICAoTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG5vZGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSkgfHxcbiAgICAgICAgICAgICAgICBub2RlW1wiQEBpdGVyYXRvclwiXSksXG4gICAgICAgICAgICAgIChwcm9wcyA9IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNoaWxkTm9kZXMgPyBjaGlsZE5vZGVzIDogbnVsbCkpO1xuICAgICAgICAgIGlmIChwcm9wcyAmJiAoY2hpbGROb2RlcyA9IHByb3BzLmNhbGwobm9kZSkpKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGROb2RlcyA9PT0gbm9kZSkge1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgLTEgIT09IGNoaWxkSW5kZXggfHxcbiAgICAgICAgICAgICAgICBudWxsID09PSB0YXNrLmNvbXBvbmVudFN0YWNrIHx8XG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgdGFzay5jb21wb25lbnRTdGFjay50eXBlIHx8XG4gICAgICAgICAgICAgICAgXCJbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXVwiICE9PVxuICAgICAgICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRhc2suY29tcG9uZW50U3RhY2sudHlwZSkgfHxcbiAgICAgICAgICAgICAgICBcIltvYmplY3QgR2VuZXJhdG9yXVwiICE9PVxuICAgICAgICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGNoaWxkTm9kZXMpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBkaWRXYXJuQWJvdXRHZW5lcmF0b3JzIHx8XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIlVzaW5nIEl0ZXJhdG9ycyBhcyBjaGlsZHJlbiBpcyB1bnN1cHBvcnRlZCBhbmQgd2lsbCBsaWtlbHkgeWllbGQgdW5leHBlY3RlZCByZXN1bHRzIGJlY2F1c2UgZW51bWVyYXRpbmcgYSBnZW5lcmF0b3IgbXV0YXRlcyBpdC4gWW91IG1heSBjb252ZXJ0IGl0IHRvIGFuIGFycmF5IHdpdGggYEFycmF5LmZyb20oKWAgb3IgdGhlIGBbLi4uc3ByZWFkXWAgb3BlcmF0b3IgYmVmb3JlIHJlbmRlcmluZy4gWW91IGNhbiBhbHNvIHVzZSBhbiBJdGVyYWJsZSB0aGF0IGNhbiBpdGVyYXRlIG11bHRpcGxlIHRpbWVzIG92ZXIgdGhlIHNhbWUgaXRlbXMuXCJcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAoZGlkV2FybkFib3V0R2VuZXJhdG9ycyA9ICEwKTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICBub2RlLmVudHJpZXMgIT09IHByb3BzIHx8XG4gICAgICAgICAgICAgICAgZGlkV2FybkFib3V0TWFwcyB8fFxuICAgICAgICAgICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIG5vdCBzdXBwb3J0ZWQuIFVzZSBhbiBhcnJheSBvZiBrZXllZCBSZWFjdEVsZW1lbnRzIGluc3RlYWQuXCJcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIChkaWRXYXJuQWJvdXRNYXBzID0gITApKTtcbiAgICAgICAgICAgIG5vZGUgPSBjaGlsZE5vZGVzLm5leHQoKTtcbiAgICAgICAgICAgIGlmICghbm9kZS5kb25lKSB7XG4gICAgICAgICAgICAgIHByb3BzID0gW107XG4gICAgICAgICAgICAgIGRvIHByb3BzLnB1c2gobm9kZS52YWx1ZSksIChub2RlID0gY2hpbGROb2Rlcy5uZXh0KCkpO1xuICAgICAgICAgICAgICB3aGlsZSAoIW5vZGUuZG9uZSk7XG4gICAgICAgICAgICAgIHJlbmRlckNoaWxkcmVuQXJyYXkocmVxdWVzdCwgdGFzaywgcHJvcHMsIGNoaWxkSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2Ygbm9kZS50aGVuKVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKHRhc2sudGhlbmFibGVTdGF0ZSA9IG51bGwpLFxuICAgICAgICAgICAgICByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUoXG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICB0YXNrLFxuICAgICAgICAgICAgICAgIHVud3JhcFRoZW5hYmxlKG5vZGUpLFxuICAgICAgICAgICAgICAgIGNoaWxkSW5kZXhcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBpZiAobm9kZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFKVxuICAgICAgICAgICAgcmV0dXJuIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShcbiAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgdGFzayxcbiAgICAgICAgICAgICAgbm9kZS5fY3VycmVudFZhbHVlLFxuICAgICAgICAgICAgICBjaGlsZEluZGV4XG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNoaWxkSW5kZXggPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobm9kZSk7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIk9iamVjdHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkIChmb3VuZDogXCIgK1xuICAgICAgICAgICAgICAoXCJbb2JqZWN0IE9iamVjdF1cIiA9PT0gY2hpbGRJbmRleFxuICAgICAgICAgICAgICAgID8gXCJvYmplY3Qgd2l0aCBrZXlzIHtcIiArIE9iamVjdC5rZXlzKG5vZGUpLmpvaW4oXCIsIFwiKSArIFwifVwiXG4gICAgICAgICAgICAgICAgOiBjaGlsZEluZGV4KSArXG4gICAgICAgICAgICAgIFwiKS4gSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4sIHVzZSBhbiBhcnJheSBpbnN0ZWFkLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygbm9kZVxuICAgICAgICAgID8gKChjaGlsZEluZGV4ID0gdGFzay5ibG9ja2VkU2VnbWVudCksXG4gICAgICAgICAgICBudWxsICE9PSBjaGlsZEluZGV4ICYmXG4gICAgICAgICAgICAgIChjaGlsZEluZGV4Lmxhc3RQdXNoZWRUZXh0ID0gcHVzaFRleHRJbnN0YW5jZShcbiAgICAgICAgICAgICAgICBjaGlsZEluZGV4LmNodW5rcyxcbiAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgIHJlcXVlc3QucmVuZGVyU3RhdGUsXG4gICAgICAgICAgICAgICAgY2hpbGRJbmRleC5sYXN0UHVzaGVkVGV4dFxuICAgICAgICAgICAgICApKSlcbiAgICAgICAgICA6IFwibnVtYmVyXCIgPT09IHR5cGVvZiBub2RlIHx8IFwiYmlnaW50XCIgPT09IHR5cGVvZiBub2RlXG4gICAgICAgICAgICA/ICgoY2hpbGRJbmRleCA9IHRhc2suYmxvY2tlZFNlZ21lbnQpLFxuICAgICAgICAgICAgICBudWxsICE9PSBjaGlsZEluZGV4ICYmXG4gICAgICAgICAgICAgICAgKGNoaWxkSW5kZXgubGFzdFB1c2hlZFRleHQgPSBwdXNoVGV4dEluc3RhbmNlKFxuICAgICAgICAgICAgICAgICAgY2hpbGRJbmRleC5jaHVua3MsXG4gICAgICAgICAgICAgICAgICBcIlwiICsgbm9kZSxcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3QucmVuZGVyU3RhdGUsXG4gICAgICAgICAgICAgICAgICBjaGlsZEluZGV4Lmxhc3RQdXNoZWRUZXh0XG4gICAgICAgICAgICAgICAgKSkpXG4gICAgICAgICAgICA6IChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBub2RlICYmXG4gICAgICAgICAgICAgICAgKChjaGlsZEluZGV4ID0gbm9kZS5kaXNwbGF5TmFtZSB8fCBub2RlLm5hbWUgfHwgXCJDb21wb25lbnRcIiksXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiRnVuY3Rpb25zIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZC4gVGhpcyBtYXkgaGFwcGVuIGlmIHlvdSByZXR1cm4gJXMgaW5zdGVhZCBvZiA8JXMgLz4gZnJvbSByZW5kZXIuIE9yIG1heWJlIHlvdSBtZWFudCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gcmF0aGVyIHRoYW4gcmV0dXJuIGl0LlwiLFxuICAgICAgICAgICAgICAgICAgY2hpbGRJbmRleCxcbiAgICAgICAgICAgICAgICAgIGNoaWxkSW5kZXhcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgXCJzeW1ib2xcIiA9PT0gdHlwZW9mIG5vZGUgJiZcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJTeW1ib2xzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZC5cXG4gICVzXCIsXG4gICAgICAgICAgICAgICAgICBTdHJpbmcobm9kZSlcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVuZGVyQ2hpbGRyZW5BcnJheShyZXF1ZXN0JGpzY29tcCQwLCB0YXNrLCBjaGlsZHJlbiwgY2hpbGRJbmRleCkge1xuICAgICAgdmFyIHByZXZLZXlQYXRoID0gdGFzay5rZXlQYXRoLFxuICAgICAgICBwcmV2aW91c0NvbXBvbmVudFN0YWNrID0gdGFzay5jb21wb25lbnRTdGFjaztcbiAgICAgIHB1c2hTZXJ2ZXJDb21wb25lbnRTdGFjayh0YXNrLCB0YXNrLm5vZGUuX2RlYnVnSW5mbyk7XG4gICAgICBpZiAoXG4gICAgICAgIC0xICE9PSBjaGlsZEluZGV4ICYmXG4gICAgICAgICgodGFzay5rZXlQYXRoID0gW3Rhc2sua2V5UGF0aCwgXCJGcmFnbWVudFwiLCBjaGlsZEluZGV4XSksXG4gICAgICAgIG51bGwgIT09IHRhc2sucmVwbGF5KVxuICAgICAgKSB7XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgdmFyIHJlcGxheSA9IHRhc2sucmVwbGF5LCByZXBsYXlOb2RlcyA9IHJlcGxheS5ub2RlcywgaiA9IDA7XG4gICAgICAgICAgaiA8IHJlcGxheU5vZGVzLmxlbmd0aDtcbiAgICAgICAgICBqKytcbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSByZXBsYXlOb2Rlc1tqXTtcbiAgICAgICAgICBpZiAobm9kZVsxXSA9PT0gY2hpbGRJbmRleCkge1xuICAgICAgICAgICAgY2hpbGRJbmRleCA9IG5vZGVbMl07XG4gICAgICAgICAgICBub2RlID0gbm9kZVszXTtcbiAgICAgICAgICAgIHRhc2sucmVwbGF5ID0geyBub2RlczogY2hpbGRJbmRleCwgc2xvdHM6IG5vZGUsIHBlbmRpbmdUYXNrczogMSB9O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmVuZGVyQ2hpbGRyZW5BcnJheShyZXF1ZXN0JGpzY29tcCQwLCB0YXNrLCBjaGlsZHJlbiwgLTEpO1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgMSA9PT0gdGFzay5yZXBsYXkucGVuZGluZ1Rhc2tzICYmXG4gICAgICAgICAgICAgICAgMCA8IHRhc2sucmVwbGF5Lm5vZGVzLmxlbmd0aFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIkNvdWxkbid0IGZpbmQgYWxsIHJlc3VtYWJsZSBzbG90cyBieSBrZXkvaW5kZXggZHVyaW5nIHJlcGxheWluZy4gVGhlIHRyZWUgZG9lc24ndCBtYXRjaCBzbyBSZWFjdCB3aWxsIGZhbGxiYWNrIHRvIGNsaWVudCByZW5kZXJpbmcuXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB0YXNrLnJlcGxheS5wZW5kaW5nVGFza3MtLTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiB4ICYmXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0geCAmJlxuICAgICAgICAgICAgICAgICh4ID09PSBTdXNwZW5zZUV4Y2VwdGlvbiB8fCBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB4LnRoZW4pXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICB0aHJvdyB4O1xuICAgICAgICAgICAgICB0YXNrLnJlcGxheS5wZW5kaW5nVGFza3MtLTtcbiAgICAgICAgICAgICAgY2hpbGRyZW4gPSBnZXRUaHJvd25JbmZvKHRhc2suY29tcG9uZW50U3RhY2spO1xuICAgICAgICAgICAgICBlcnJvcmVkUmVwbGF5KFxuICAgICAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgdGFzay5ibG9ja2VkQm91bmRhcnksXG4gICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgICAgICAgICBjaGlsZEluZGV4LFxuICAgICAgICAgICAgICAgIG5vZGVcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhc2sucmVwbGF5ID0gcmVwbGF5O1xuICAgICAgICAgICAgcmVwbGF5Tm9kZXMuc3BsaWNlKGosIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRhc2sua2V5UGF0aCA9IHByZXZLZXlQYXRoO1xuICAgICAgICB0YXNrLmNvbXBvbmVudFN0YWNrID0gcHJldmlvdXNDb21wb25lbnRTdGFjaztcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVwbGF5ID0gdGFzay50cmVlQ29udGV4dDtcbiAgICAgIHJlcGxheU5vZGVzID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgaWYgKFxuICAgICAgICBudWxsICE9PSB0YXNrLnJlcGxheSAmJlxuICAgICAgICAoKGogPSB0YXNrLnJlcGxheS5zbG90cyksIG51bGwgIT09IGogJiYgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGopXG4gICAgICApIHtcbiAgICAgICAgZm9yIChjaGlsZEluZGV4ID0gMDsgY2hpbGRJbmRleCA8IHJlcGxheU5vZGVzOyBjaGlsZEluZGV4KyspIHtcbiAgICAgICAgICBub2RlID0gY2hpbGRyZW5bY2hpbGRJbmRleF07XG4gICAgICAgICAgdGFzay50cmVlQ29udGV4dCA9IHB1c2hUcmVlQ29udGV4dChyZXBsYXksIHJlcGxheU5vZGVzLCBjaGlsZEluZGV4KTtcbiAgICAgICAgICB2YXIgcmVzdW1lU2VnbWVudElEID0galtjaGlsZEluZGV4XTtcbiAgICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgcmVzdW1lU2VnbWVudElEXG4gICAgICAgICAgICA/IChyZXN1bWVOb2RlKFxuICAgICAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgdGFzayxcbiAgICAgICAgICAgICAgICByZXN1bWVTZWdtZW50SUQsXG4gICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICBjaGlsZEluZGV4XG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIGRlbGV0ZSBqW2NoaWxkSW5kZXhdKVxuICAgICAgICAgICAgOiByZW5kZXJOb2RlKHJlcXVlc3QkanNjb21wJDAsIHRhc2ssIG5vZGUsIGNoaWxkSW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHRhc2sudHJlZUNvbnRleHQgPSByZXBsYXk7XG4gICAgICAgIHRhc2sua2V5UGF0aCA9IHByZXZLZXlQYXRoO1xuICAgICAgICB0YXNrLmNvbXBvbmVudFN0YWNrID0gcHJldmlvdXNDb21wb25lbnRTdGFjaztcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yIChqID0gMDsgaiA8IHJlcGxheU5vZGVzOyBqKyspIHtcbiAgICAgICAgY2hpbGRJbmRleCA9IGNoaWxkcmVuW2pdO1xuICAgICAgICB2YXIgcmVxdWVzdCA9IHJlcXVlc3QkanNjb21wJDA7XG4gICAgICAgIG5vZGUgPSB0YXNrO1xuICAgICAgICByZXN1bWVTZWdtZW50SUQgPSBjaGlsZEluZGV4O1xuICAgICAgICBpZiAoXG4gICAgICAgICAgbnVsbCAhPT0gcmVzdW1lU2VnbWVudElEICYmXG4gICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHJlc3VtZVNlZ21lbnRJRCAmJlxuICAgICAgICAgIChyZXN1bWVTZWdtZW50SUQuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSB8fFxuICAgICAgICAgICAgcmVzdW1lU2VnbWVudElELiQkdHlwZW9mID09PSBSRUFDVF9QT1JUQUxfVFlQRSkgJiZcbiAgICAgICAgICByZXN1bWVTZWdtZW50SUQuX3N0b3JlICYmXG4gICAgICAgICAgKCghcmVzdW1lU2VnbWVudElELl9zdG9yZS52YWxpZGF0ZWQgJiYgbnVsbCA9PSByZXN1bWVTZWdtZW50SUQua2V5KSB8fFxuICAgICAgICAgICAgMiA9PT0gcmVzdW1lU2VnbWVudElELl9zdG9yZS52YWxpZGF0ZWQpXG4gICAgICAgICkge1xuICAgICAgICAgIGlmIChcIm9iamVjdFwiICE9PSB0eXBlb2YgcmVzdW1lU2VnbWVudElELl9zdG9yZSlcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICBcIlJlYWN0IENvbXBvbmVudCBpbiB3YXJuRm9yTWlzc2luZ0tleSBzaG91bGQgaGF2ZSBhIF9zdG9yZS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICByZXN1bWVTZWdtZW50SUQuX3N0b3JlLnZhbGlkYXRlZCA9IDE7XG4gICAgICAgICAgdmFyIGRpZFdhcm5Gb3JLZXkgPSByZXF1ZXN0LmRpZFdhcm5Gb3JLZXk7XG4gICAgICAgICAgbnVsbCA9PSBkaWRXYXJuRm9yS2V5ICYmXG4gICAgICAgICAgICAoZGlkV2FybkZvcktleSA9IHJlcXVlc3QuZGlkV2FybkZvcktleSA9IG5ldyBXZWFrU2V0KCkpO1xuICAgICAgICAgIHJlcXVlc3QgPSBub2RlLmNvbXBvbmVudFN0YWNrO1xuICAgICAgICAgIGlmIChudWxsICE9PSByZXF1ZXN0ICYmICFkaWRXYXJuRm9yS2V5LmhhcyhyZXF1ZXN0KSkge1xuICAgICAgICAgICAgZGlkV2FybkZvcktleS5hZGQocmVxdWVzdCk7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShyZXN1bWVTZWdtZW50SUQudHlwZSk7XG4gICAgICAgICAgICBkaWRXYXJuRm9yS2V5ID0gcmVzdW1lU2VnbWVudElELl9vd25lcjtcbiAgICAgICAgICAgIHZhciBwYXJlbnRPd25lciA9IHJlcXVlc3Qub3duZXI7XG4gICAgICAgICAgICByZXF1ZXN0ID0gXCJcIjtcbiAgICAgICAgICAgIGlmIChwYXJlbnRPd25lciAmJiBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgcGFyZW50T3duZXIudHlwZSkge1xuICAgICAgICAgICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShwYXJlbnRPd25lci50eXBlKTtcbiAgICAgICAgICAgICAgbmFtZSAmJlxuICAgICAgICAgICAgICAgIChyZXF1ZXN0ID0gXCJcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgXCIgKyBuYW1lICsgXCJgLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcXVlc3QgfHxcbiAgICAgICAgICAgICAgKGNvbXBvbmVudE5hbWUgJiZcbiAgICAgICAgICAgICAgICAocmVxdWVzdCA9XG4gICAgICAgICAgICAgICAgICBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICtcbiAgICAgICAgICAgICAgICAgIGNvbXBvbmVudE5hbWUgK1xuICAgICAgICAgICAgICAgICAgXCI+LlwiKSk7XG4gICAgICAgICAgICBjb21wb25lbnROYW1lID0gXCJcIjtcbiAgICAgICAgICAgIG51bGwgIT0gZGlkV2FybkZvcktleSAmJlxuICAgICAgICAgICAgICBwYXJlbnRPd25lciAhPT0gZGlkV2FybkZvcktleSAmJlxuICAgICAgICAgICAgICAoKHBhcmVudE93bmVyID0gbnVsbCksXG4gICAgICAgICAgICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBkaWRXYXJuRm9yS2V5LnR5cGVcbiAgICAgICAgICAgICAgICA/IChwYXJlbnRPd25lciA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShkaWRXYXJuRm9yS2V5LnR5cGUpKVxuICAgICAgICAgICAgICAgIDogXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGRpZFdhcm5Gb3JLZXkubmFtZSAmJlxuICAgICAgICAgICAgICAgICAgKHBhcmVudE93bmVyID0gZGlkV2FybkZvcktleS5uYW1lKSxcbiAgICAgICAgICAgICAgcGFyZW50T3duZXIgJiZcbiAgICAgICAgICAgICAgICAoY29tcG9uZW50TmFtZSA9XG4gICAgICAgICAgICAgICAgICBcIiBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSBcIiArIHBhcmVudE93bmVyICsgXCIuXCIpKTtcbiAgICAgICAgICAgIGRpZFdhcm5Gb3JLZXkgPSBub2RlLmNvbXBvbmVudFN0YWNrO1xuICAgICAgICAgICAgbm9kZS5jb21wb25lbnRTdGFjayA9IHtcbiAgICAgICAgICAgICAgcGFyZW50OiBub2RlLmNvbXBvbmVudFN0YWNrLFxuICAgICAgICAgICAgICB0eXBlOiByZXN1bWVTZWdtZW50SUQudHlwZSxcbiAgICAgICAgICAgICAgb3duZXI6IHJlc3VtZVNlZ21lbnRJRC5fb3duZXIsXG4gICAgICAgICAgICAgIHN0YWNrOiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgJ0VhY2ggY2hpbGQgaW4gYSBsaXN0IHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4lcyVzIFNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL3dhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLFxuICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbm9kZS5jb21wb25lbnRTdGFjayA9IGRpZFdhcm5Gb3JLZXk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRhc2sudHJlZUNvbnRleHQgPSBwdXNoVHJlZUNvbnRleHQocmVwbGF5LCByZXBsYXlOb2Rlcywgaik7XG4gICAgICAgIHJlbmRlck5vZGUocmVxdWVzdCRqc2NvbXAkMCwgdGFzaywgY2hpbGRJbmRleCwgaik7XG4gICAgICB9XG4gICAgICB0YXNrLnRyZWVDb250ZXh0ID0gcmVwbGF5O1xuICAgICAgdGFzay5rZXlQYXRoID0gcHJldktleVBhdGg7XG4gICAgICB0YXNrLmNvbXBvbmVudFN0YWNrID0gcHJldmlvdXNDb21wb25lbnRTdGFjaztcbiAgICB9XG4gICAgZnVuY3Rpb24gdW50cmFja0JvdW5kYXJ5KHJlcXVlc3QsIGJvdW5kYXJ5KSB7XG4gICAgICByZXF1ZXN0ID0gcmVxdWVzdC50cmFja2VkUG9zdHBvbmVzO1xuICAgICAgbnVsbCAhPT0gcmVxdWVzdCAmJlxuICAgICAgICAoKGJvdW5kYXJ5ID0gYm91bmRhcnkudHJhY2tlZENvbnRlbnRLZXlQYXRoKSxcbiAgICAgICAgbnVsbCAhPT0gYm91bmRhcnkgJiZcbiAgICAgICAgICAoKGJvdW5kYXJ5ID0gcmVxdWVzdC53b3JraW5nTWFwLmdldChib3VuZGFyeSkpLFxuICAgICAgICAgIHZvaWQgMCAhPT0gYm91bmRhcnkgJiZcbiAgICAgICAgICAgICgoYm91bmRhcnkubGVuZ3RoID0gNCksIChib3VuZGFyeVsyXSA9IFtdKSwgKGJvdW5kYXJ5WzNdID0gbnVsbCkpKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNwYXduTmV3U3VzcGVuZGVkUmVwbGF5VGFzayhyZXF1ZXN0LCB0YXNrLCB0aGVuYWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm4gY3JlYXRlUmVwbGF5VGFzayhcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgdGhlbmFibGVTdGF0ZSxcbiAgICAgICAgdGFzay5yZXBsYXksXG4gICAgICAgIHRhc2subm9kZSxcbiAgICAgICAgdGFzay5jaGlsZEluZGV4LFxuICAgICAgICB0YXNrLmJsb2NrZWRCb3VuZGFyeSxcbiAgICAgICAgdGFzay5ob2lzdGFibGVTdGF0ZSxcbiAgICAgICAgdGFzay5hYm9ydFNldCxcbiAgICAgICAgdGFzay5rZXlQYXRoLFxuICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQsXG4gICAgICAgIHRhc2suY29udGV4dCxcbiAgICAgICAgdGFzay50cmVlQ29udGV4dCxcbiAgICAgICAgdGFzay5jb21wb25lbnRTdGFjayxcbiAgICAgICAgdGFzay5pc0ZhbGxiYWNrXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzcGF3bk5ld1N1c3BlbmRlZFJlbmRlclRhc2socmVxdWVzdCwgdGFzaywgdGhlbmFibGVTdGF0ZSkge1xuICAgICAgdmFyIHNlZ21lbnQgPSB0YXNrLmJsb2NrZWRTZWdtZW50LFxuICAgICAgICBuZXdTZWdtZW50ID0gY3JlYXRlUGVuZGluZ1NlZ21lbnQoXG4gICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICBzZWdtZW50LmNodW5rcy5sZW5ndGgsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQsXG4gICAgICAgICAgc2VnbWVudC5sYXN0UHVzaGVkVGV4dCxcbiAgICAgICAgICAhMFxuICAgICAgICApO1xuICAgICAgc2VnbWVudC5jaGlsZHJlbi5wdXNoKG5ld1NlZ21lbnQpO1xuICAgICAgc2VnbWVudC5sYXN0UHVzaGVkVGV4dCA9ICExO1xuICAgICAgcmV0dXJuIGNyZWF0ZVJlbmRlclRhc2soXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIHRoZW5hYmxlU3RhdGUsXG4gICAgICAgIHRhc2subm9kZSxcbiAgICAgICAgdGFzay5jaGlsZEluZGV4LFxuICAgICAgICB0YXNrLmJsb2NrZWRCb3VuZGFyeSxcbiAgICAgICAgbmV3U2VnbWVudCxcbiAgICAgICAgdGFzay5ob2lzdGFibGVTdGF0ZSxcbiAgICAgICAgdGFzay5hYm9ydFNldCxcbiAgICAgICAgdGFzay5rZXlQYXRoLFxuICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQsXG4gICAgICAgIHRhc2suY29udGV4dCxcbiAgICAgICAgdGFzay50cmVlQ29udGV4dCxcbiAgICAgICAgdGFzay5jb21wb25lbnRTdGFjayxcbiAgICAgICAgdGFzay5pc0ZhbGxiYWNrXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIG5vZGUsIGNoaWxkSW5kZXgpIHtcbiAgICAgIHZhciBwcmV2aW91c0Zvcm1hdENvbnRleHQgPSB0YXNrLmZvcm1hdENvbnRleHQsXG4gICAgICAgIHByZXZpb3VzQ29udGV4dCA9IHRhc2suY29udGV4dCxcbiAgICAgICAgcHJldmlvdXNLZXlQYXRoID0gdGFzay5rZXlQYXRoLFxuICAgICAgICBwcmV2aW91c1RyZWVDb250ZXh0ID0gdGFzay50cmVlQ29udGV4dCxcbiAgICAgICAgcHJldmlvdXNDb21wb25lbnRTdGFjayA9IHRhc2suY29tcG9uZW50U3RhY2ssXG4gICAgICAgIHNlZ21lbnQgPSB0YXNrLmJsb2NrZWRTZWdtZW50O1xuICAgICAgaWYgKG51bGwgPT09IHNlZ21lbnQpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBub2RlLCBjaGlsZEluZGV4KTtcbiAgICAgICAgfSBjYXRjaCAodGhyb3duVmFsdWUpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAocmVzZXRIb29rc1N0YXRlKCksXG4gICAgICAgICAgICAobm9kZSA9XG4gICAgICAgICAgICAgIHRocm93blZhbHVlID09PSBTdXNwZW5zZUV4Y2VwdGlvblxuICAgICAgICAgICAgICAgID8gZ2V0U3VzcGVuZGVkVGhlbmFibGUoKVxuICAgICAgICAgICAgICAgIDogdGhyb3duVmFsdWUpLFxuICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG5vZGUgJiYgbnVsbCAhPT0gbm9kZSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBub2RlLnRoZW4pIHtcbiAgICAgICAgICAgICAgY2hpbGRJbmRleCA9IGdldFRoZW5hYmxlU3RhdGVBZnRlclN1c3BlbmRpbmcoKTtcbiAgICAgICAgICAgICAgcmVxdWVzdCA9IHNwYXduTmV3U3VzcGVuZGVkUmVwbGF5VGFzayhcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIHRhc2ssXG4gICAgICAgICAgICAgICAgY2hpbGRJbmRleFxuICAgICAgICAgICAgICApLnBpbmc7XG4gICAgICAgICAgICAgIG5vZGUudGhlbihyZXF1ZXN0LCByZXF1ZXN0KTtcbiAgICAgICAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0ID0gcHJldmlvdXNGb3JtYXRDb250ZXh0O1xuICAgICAgICAgICAgICB0YXNrLmNvbnRleHQgPSBwcmV2aW91c0NvbnRleHQ7XG4gICAgICAgICAgICAgIHRhc2sua2V5UGF0aCA9IHByZXZpb3VzS2V5UGF0aDtcbiAgICAgICAgICAgICAgdGFzay50cmVlQ29udGV4dCA9IHByZXZpb3VzVHJlZUNvbnRleHQ7XG4gICAgICAgICAgICAgIHRhc2suY29tcG9uZW50U3RhY2sgPSBwcmV2aW91c0NvbXBvbmVudFN0YWNrO1xuICAgICAgICAgICAgICBzd2l0Y2hDb250ZXh0KHByZXZpb3VzQ29udGV4dCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChcIk1heGltdW0gY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIgPT09IG5vZGUubWVzc2FnZSkge1xuICAgICAgICAgICAgICBub2RlID0gZ2V0VGhlbmFibGVTdGF0ZUFmdGVyU3VzcGVuZGluZygpO1xuICAgICAgICAgICAgICBub2RlID0gc3Bhd25OZXdTdXNwZW5kZWRSZXBsYXlUYXNrKHJlcXVlc3QsIHRhc2ssIG5vZGUpO1xuICAgICAgICAgICAgICByZXF1ZXN0LnBpbmdlZFRhc2tzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgIHRhc2suZm9ybWF0Q29udGV4dCA9IHByZXZpb3VzRm9ybWF0Q29udGV4dDtcbiAgICAgICAgICAgICAgdGFzay5jb250ZXh0ID0gcHJldmlvdXNDb250ZXh0O1xuICAgICAgICAgICAgICB0YXNrLmtleVBhdGggPSBwcmV2aW91c0tleVBhdGg7XG4gICAgICAgICAgICAgIHRhc2sudHJlZUNvbnRleHQgPSBwcmV2aW91c1RyZWVDb250ZXh0O1xuICAgICAgICAgICAgICB0YXNrLmNvbXBvbmVudFN0YWNrID0gcHJldmlvdXNDb21wb25lbnRTdGFjaztcbiAgICAgICAgICAgICAgc3dpdGNoQ29udGV4dChwcmV2aW91c0NvbnRleHQpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gc2VnbWVudC5jaGlsZHJlbi5sZW5ndGgsXG4gICAgICAgICAgY2h1bmtMZW5ndGggPSBzZWdtZW50LmNodW5rcy5sZW5ndGg7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBub2RlLCBjaGlsZEluZGV4KTtcbiAgICAgICAgfSBjYXRjaCAodGhyb3duVmFsdWUkMykge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIChyZXNldEhvb2tzU3RhdGUoKSxcbiAgICAgICAgICAgIChzZWdtZW50LmNoaWxkcmVuLmxlbmd0aCA9IGNoaWxkcmVuTGVuZ3RoKSxcbiAgICAgICAgICAgIChzZWdtZW50LmNodW5rcy5sZW5ndGggPSBjaHVua0xlbmd0aCksXG4gICAgICAgICAgICAobm9kZSA9XG4gICAgICAgICAgICAgIHRocm93blZhbHVlJDMgPT09IFN1c3BlbnNlRXhjZXB0aW9uXG4gICAgICAgICAgICAgICAgPyBnZXRTdXNwZW5kZWRUaGVuYWJsZSgpXG4gICAgICAgICAgICAgICAgOiB0aHJvd25WYWx1ZSQzKSxcbiAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBub2RlICYmIG51bGwgIT09IG5vZGUpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2Ygbm9kZS50aGVuKSB7XG4gICAgICAgICAgICAgIGNoaWxkSW5kZXggPSBnZXRUaGVuYWJsZVN0YXRlQWZ0ZXJTdXNwZW5kaW5nKCk7XG4gICAgICAgICAgICAgIHJlcXVlc3QgPSBzcGF3bk5ld1N1c3BlbmRlZFJlbmRlclRhc2soXG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICB0YXNrLFxuICAgICAgICAgICAgICAgIGNoaWxkSW5kZXhcbiAgICAgICAgICAgICAgKS5waW5nO1xuICAgICAgICAgICAgICBub2RlLnRoZW4ocmVxdWVzdCwgcmVxdWVzdCk7XG4gICAgICAgICAgICAgIHRhc2suZm9ybWF0Q29udGV4dCA9IHByZXZpb3VzRm9ybWF0Q29udGV4dDtcbiAgICAgICAgICAgICAgdGFzay5jb250ZXh0ID0gcHJldmlvdXNDb250ZXh0O1xuICAgICAgICAgICAgICB0YXNrLmtleVBhdGggPSBwcmV2aW91c0tleVBhdGg7XG4gICAgICAgICAgICAgIHRhc2sudHJlZUNvbnRleHQgPSBwcmV2aW91c1RyZWVDb250ZXh0O1xuICAgICAgICAgICAgICB0YXNrLmNvbXBvbmVudFN0YWNrID0gcHJldmlvdXNDb21wb25lbnRTdGFjaztcbiAgICAgICAgICAgICAgc3dpdGNoQ29udGV4dChwcmV2aW91c0NvbnRleHQpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXCJNYXhpbXVtIGNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiID09PSBub2RlLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgbm9kZSA9IGdldFRoZW5hYmxlU3RhdGVBZnRlclN1c3BlbmRpbmcoKTtcbiAgICAgICAgICAgICAgbm9kZSA9IHNwYXduTmV3U3VzcGVuZGVkUmVuZGVyVGFzayhyZXF1ZXN0LCB0YXNrLCBub2RlKTtcbiAgICAgICAgICAgICAgcmVxdWVzdC5waW5nZWRUYXNrcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQgPSBwcmV2aW91c0Zvcm1hdENvbnRleHQ7XG4gICAgICAgICAgICAgIHRhc2suY29udGV4dCA9IHByZXZpb3VzQ29udGV4dDtcbiAgICAgICAgICAgICAgdGFzay5rZXlQYXRoID0gcHJldmlvdXNLZXlQYXRoO1xuICAgICAgICAgICAgICB0YXNrLnRyZWVDb250ZXh0ID0gcHJldmlvdXNUcmVlQ29udGV4dDtcbiAgICAgICAgICAgICAgdGFzay5jb21wb25lbnRTdGFjayA9IHByZXZpb3VzQ29tcG9uZW50U3RhY2s7XG4gICAgICAgICAgICAgIHN3aXRjaENvbnRleHQocHJldmlvdXNDb250ZXh0KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGFzay5mb3JtYXRDb250ZXh0ID0gcHJldmlvdXNGb3JtYXRDb250ZXh0O1xuICAgICAgdGFzay5jb250ZXh0ID0gcHJldmlvdXNDb250ZXh0O1xuICAgICAgdGFzay5rZXlQYXRoID0gcHJldmlvdXNLZXlQYXRoO1xuICAgICAgdGFzay50cmVlQ29udGV4dCA9IHByZXZpb3VzVHJlZUNvbnRleHQ7XG4gICAgICBzd2l0Y2hDb250ZXh0KHByZXZpb3VzQ29udGV4dCk7XG4gICAgICB0aHJvdyBub2RlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlcnJvcmVkUmVwbGF5KFxuICAgICAgcmVxdWVzdCxcbiAgICAgIGJvdW5kYXJ5LFxuICAgICAgZXJyb3IsXG4gICAgICBlcnJvckluZm8sXG4gICAgICByZXBsYXlOb2RlcyxcbiAgICAgIHJlc3VtZVNsb3RzXG4gICAgKSB7XG4gICAgICB2YXIgZXJyb3JEaWdlc3QgPSBsb2dSZWNvdmVyYWJsZUVycm9yKHJlcXVlc3QsIGVycm9yLCBlcnJvckluZm8pO1xuICAgICAgYWJvcnRSZW1haW5pbmdSZXBsYXlOb2RlcyhcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgYm91bmRhcnksXG4gICAgICAgIHJlcGxheU5vZGVzLFxuICAgICAgICByZXN1bWVTbG90cyxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIGVycm9yRGlnZXN0LFxuICAgICAgICBlcnJvckluZm8sXG4gICAgICAgICExXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhYm9ydFRhc2tTb2Z0KHRhc2spIHtcbiAgICAgIHZhciBib3VuZGFyeSA9IHRhc2suYmxvY2tlZEJvdW5kYXJ5O1xuICAgICAgdGFzayA9IHRhc2suYmxvY2tlZFNlZ21lbnQ7XG4gICAgICBudWxsICE9PSB0YXNrICYmICgodGFzay5zdGF0dXMgPSAzKSwgZmluaXNoZWRUYXNrKHRoaXMsIGJvdW5kYXJ5LCB0YXNrKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFib3J0UmVtYWluaW5nUmVwbGF5Tm9kZXMoXG4gICAgICByZXF1ZXN0JGpzY29tcCQwLFxuICAgICAgYm91bmRhcnksXG4gICAgICBub2RlcyxcbiAgICAgIHNsb3RzLFxuICAgICAgZXJyb3IkanNjb21wJDAsXG4gICAgICBlcnJvckRpZ2VzdCRqc2NvbXAkMCxcbiAgICAgIGVycm9ySW5mbyRqc2NvbXAkMCxcbiAgICAgIGFib3J0ZWRcbiAgICApIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgaWYgKDQgPT09IG5vZGUubGVuZ3RoKVxuICAgICAgICAgIGFib3J0UmVtYWluaW5nUmVwbGF5Tm9kZXMoXG4gICAgICAgICAgICByZXF1ZXN0JGpzY29tcCQwLFxuICAgICAgICAgICAgYm91bmRhcnksXG4gICAgICAgICAgICBub2RlWzJdLFxuICAgICAgICAgICAgbm9kZVszXSxcbiAgICAgICAgICAgIGVycm9yJGpzY29tcCQwLFxuICAgICAgICAgICAgZXJyb3JEaWdlc3QkanNjb21wJDAsXG4gICAgICAgICAgICBlcnJvckluZm8kanNjb21wJDAsXG4gICAgICAgICAgICBhYm9ydGVkXG4gICAgICAgICAgKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIHJlcXVlc3QgPSByZXF1ZXN0JGpzY29tcCQwO1xuICAgICAgICAgIG5vZGUgPSBub2RlWzVdO1xuICAgICAgICAgIHZhciBlcnJvciA9IGVycm9yJGpzY29tcCQwLFxuICAgICAgICAgICAgZXJyb3JEaWdlc3QgPSBlcnJvckRpZ2VzdCRqc2NvbXAkMCxcbiAgICAgICAgICAgIGVycm9ySW5mbyA9IGVycm9ySW5mbyRqc2NvbXAkMCxcbiAgICAgICAgICAgIHdhc0Fib3J0ZWQgPSBhYm9ydGVkLFxuICAgICAgICAgICAgcmVzdW1lZEJvdW5kYXJ5ID0gY3JlYXRlU3VzcGVuc2VCb3VuZGFyeShyZXF1ZXN0LCBuZXcgU2V0KCkpO1xuICAgICAgICAgIHJlc3VtZWRCb3VuZGFyeS5wYXJlbnRGbHVzaGVkID0gITA7XG4gICAgICAgICAgcmVzdW1lZEJvdW5kYXJ5LnJvb3RTZWdtZW50SUQgPSBub2RlO1xuICAgICAgICAgIHJlc3VtZWRCb3VuZGFyeS5zdGF0dXMgPSBDTElFTlRfUkVOREVSRUQ7XG4gICAgICAgICAgZW5jb2RlRXJyb3JGb3JCb3VuZGFyeShcbiAgICAgICAgICAgIHJlc3VtZWRCb3VuZGFyeSxcbiAgICAgICAgICAgIGVycm9yRGlnZXN0LFxuICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICBlcnJvckluZm8sXG4gICAgICAgICAgICB3YXNBYm9ydGVkXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXN1bWVkQm91bmRhcnkucGFyZW50Rmx1c2hlZCAmJlxuICAgICAgICAgICAgcmVxdWVzdC5jbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMucHVzaChyZXN1bWVkQm91bmRhcnkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBub2Rlcy5sZW5ndGggPSAwO1xuICAgICAgaWYgKG51bGwgIT09IHNsb3RzKSB7XG4gICAgICAgIGlmIChudWxsID09PSBib3VuZGFyeSlcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiV2Ugc2hvdWxkIG5vdCBoYXZlIGFueSByZXN1bWFibGUgbm9kZXMgaW4gdGhlIHNoZWxsLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgYm91bmRhcnkuc3RhdHVzICE9PSBDTElFTlRfUkVOREVSRUQgJiZcbiAgICAgICAgICAoKGJvdW5kYXJ5LnN0YXR1cyA9IENMSUVOVF9SRU5ERVJFRCksXG4gICAgICAgICAgZW5jb2RlRXJyb3JGb3JCb3VuZGFyeShcbiAgICAgICAgICAgIGJvdW5kYXJ5LFxuICAgICAgICAgICAgZXJyb3JEaWdlc3QkanNjb21wJDAsXG4gICAgICAgICAgICBlcnJvciRqc2NvbXAkMCxcbiAgICAgICAgICAgIGVycm9ySW5mbyRqc2NvbXAkMCxcbiAgICAgICAgICAgIGFib3J0ZWRcbiAgICAgICAgICApLFxuICAgICAgICAgIGJvdW5kYXJ5LnBhcmVudEZsdXNoZWQgJiZcbiAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDAuY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzLnB1c2goYm91bmRhcnkpKTtcbiAgICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBzbG90cylcbiAgICAgICAgICBmb3IgKHZhciBpbmRleCBpbiBzbG90cykgZGVsZXRlIHNsb3RzW2luZGV4XTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYWJvcnRUYXNrKHRhc2ssIHJlcXVlc3QsIGVycm9yKSB7XG4gICAgICB2YXIgYm91bmRhcnkgPSB0YXNrLmJsb2NrZWRCb3VuZGFyeSxcbiAgICAgICAgc2VnbWVudCA9IHRhc2suYmxvY2tlZFNlZ21lbnQ7XG4gICAgICBpZiAobnVsbCAhPT0gc2VnbWVudCkge1xuICAgICAgICBpZiAoNiA9PT0gc2VnbWVudC5zdGF0dXMpIHJldHVybjtcbiAgICAgICAgc2VnbWVudC5zdGF0dXMgPSAzO1xuICAgICAgfVxuICAgICAgc2VnbWVudCA9IGdldFRocm93bkluZm8odGFzay5jb21wb25lbnRTdGFjayk7XG4gICAgICBpZiAobnVsbCA9PT0gYm91bmRhcnkpIHtcbiAgICAgICAgaWYgKDEzICE9PSByZXF1ZXN0LnN0YXR1cyAmJiByZXF1ZXN0LnN0YXR1cyAhPT0gQ0xPU0VEKSB7XG4gICAgICAgICAgYm91bmRhcnkgPSB0YXNrLnJlcGxheTtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gYm91bmRhcnkpIHtcbiAgICAgICAgICAgIGxvZ1JlY292ZXJhYmxlRXJyb3IocmVxdWVzdCwgZXJyb3IsIHNlZ21lbnQpO1xuICAgICAgICAgICAgZmF0YWxFcnJvcihyZXF1ZXN0LCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGJvdW5kYXJ5LnBlbmRpbmdUYXNrcy0tO1xuICAgICAgICAgIDAgPT09IGJvdW5kYXJ5LnBlbmRpbmdUYXNrcyAmJlxuICAgICAgICAgICAgMCA8IGJvdW5kYXJ5Lm5vZGVzLmxlbmd0aCAmJlxuICAgICAgICAgICAgKCh0YXNrID0gbG9nUmVjb3ZlcmFibGVFcnJvcihyZXF1ZXN0LCBlcnJvciwgc2VnbWVudCkpLFxuICAgICAgICAgICAgYWJvcnRSZW1haW5pbmdSZXBsYXlOb2RlcyhcbiAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgYm91bmRhcnkubm9kZXMsXG4gICAgICAgICAgICAgIGJvdW5kYXJ5LnNsb3RzLFxuICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgdGFzayxcbiAgICAgICAgICAgICAgc2VnbWVudCxcbiAgICAgICAgICAgICAgITBcbiAgICAgICAgICAgICkpO1xuICAgICAgICAgIHJlcXVlc3QucGVuZGluZ1Jvb3RUYXNrcy0tO1xuICAgICAgICAgIDAgPT09IHJlcXVlc3QucGVuZGluZ1Jvb3RUYXNrcyAmJiBjb21wbGV0ZVNoZWxsKHJlcXVlc3QpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2VcbiAgICAgICAgYm91bmRhcnkucGVuZGluZ1Rhc2tzLS0sXG4gICAgICAgICAgYm91bmRhcnkuc3RhdHVzICE9PSBDTElFTlRfUkVOREVSRUQgJiZcbiAgICAgICAgICAgICgoYm91bmRhcnkuc3RhdHVzID0gQ0xJRU5UX1JFTkRFUkVEKSxcbiAgICAgICAgICAgICh0YXNrID0gbG9nUmVjb3ZlcmFibGVFcnJvcihyZXF1ZXN0LCBlcnJvciwgc2VnbWVudCkpLFxuICAgICAgICAgICAgKGJvdW5kYXJ5LnN0YXR1cyA9IENMSUVOVF9SRU5ERVJFRCksXG4gICAgICAgICAgICBlbmNvZGVFcnJvckZvckJvdW5kYXJ5KGJvdW5kYXJ5LCB0YXNrLCBlcnJvciwgc2VnbWVudCwgITApLFxuICAgICAgICAgICAgdW50cmFja0JvdW5kYXJ5KHJlcXVlc3QsIGJvdW5kYXJ5KSxcbiAgICAgICAgICAgIGJvdW5kYXJ5LnBhcmVudEZsdXNoZWQgJiZcbiAgICAgICAgICAgICAgcmVxdWVzdC5jbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMucHVzaChib3VuZGFyeSkpLFxuICAgICAgICAgIGJvdW5kYXJ5LmZhbGxiYWNrQWJvcnRhYmxlVGFza3MuZm9yRWFjaChmdW5jdGlvbiAoZmFsbGJhY2tUYXNrKSB7XG4gICAgICAgICAgICByZXR1cm4gYWJvcnRUYXNrKGZhbGxiYWNrVGFzaywgcmVxdWVzdCwgZXJyb3IpO1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIGJvdW5kYXJ5LmZhbGxiYWNrQWJvcnRhYmxlVGFza3MuY2xlYXIoKTtcbiAgICAgIHJlcXVlc3QuYWxsUGVuZGluZ1Rhc2tzLS07XG4gICAgICAwID09PSByZXF1ZXN0LmFsbFBlbmRpbmdUYXNrcyAmJiBjb21wbGV0ZUFsbChyZXF1ZXN0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2FmZWx5RW1pdEVhcmx5UHJlbG9hZHMocmVxdWVzdCwgc2hlbGxDb21wbGV0ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHJlbmRlclN0YXRlID0gcmVxdWVzdC5yZW5kZXJTdGF0ZSxcbiAgICAgICAgICBvbkhlYWRlcnMgPSByZW5kZXJTdGF0ZS5vbkhlYWRlcnM7XG4gICAgICAgIGlmIChvbkhlYWRlcnMpIHtcbiAgICAgICAgICB2YXIgaGVhZGVycyA9IHJlbmRlclN0YXRlLmhlYWRlcnM7XG4gICAgICAgICAgaWYgKGhlYWRlcnMpIHtcbiAgICAgICAgICAgIHJlbmRlclN0YXRlLmhlYWRlcnMgPSBudWxsO1xuICAgICAgICAgICAgdmFyIGxpbmtIZWFkZXIgPSBoZWFkZXJzLnByZWNvbm5lY3RzO1xuICAgICAgICAgICAgaGVhZGVycy5mb250UHJlbG9hZHMgJiZcbiAgICAgICAgICAgICAgKGxpbmtIZWFkZXIgJiYgKGxpbmtIZWFkZXIgKz0gXCIsIFwiKSxcbiAgICAgICAgICAgICAgKGxpbmtIZWFkZXIgKz0gaGVhZGVycy5mb250UHJlbG9hZHMpKTtcbiAgICAgICAgICAgIGhlYWRlcnMuaGlnaEltYWdlUHJlbG9hZHMgJiZcbiAgICAgICAgICAgICAgKGxpbmtIZWFkZXIgJiYgKGxpbmtIZWFkZXIgKz0gXCIsIFwiKSxcbiAgICAgICAgICAgICAgKGxpbmtIZWFkZXIgKz0gaGVhZGVycy5oaWdoSW1hZ2VQcmVsb2FkcykpO1xuICAgICAgICAgICAgaWYgKCFzaGVsbENvbXBsZXRlKSB7XG4gICAgICAgICAgICAgIHZhciBxdWV1ZUl0ZXIgPSByZW5kZXJTdGF0ZS5zdHlsZXMudmFsdWVzKCksXG4gICAgICAgICAgICAgICAgcXVldWVTdGVwID0gcXVldWVJdGVyLm5leHQoKTtcbiAgICAgICAgICAgICAgYjogZm9yIChcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgMCA8IGhlYWRlcnMucmVtYWluaW5nQ2FwYWNpdHkgJiYgIXF1ZXVlU3RlcC5kb25lO1xuICAgICAgICAgICAgICAgIHF1ZXVlU3RlcCA9IHF1ZXVlSXRlci5uZXh0KClcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgICB2YXIgc2hlZXRJdGVyID0gcXVldWVTdGVwLnZhbHVlLnNoZWV0cy52YWx1ZXMoKSxcbiAgICAgICAgICAgICAgICAgICAgc2hlZXRTdGVwID0gc2hlZXRJdGVyLm5leHQoKTtcbiAgICAgICAgICAgICAgICAgIDAgPCBoZWFkZXJzLnJlbWFpbmluZ0NhcGFjaXR5ICYmICFzaGVldFN0ZXAuZG9uZTtcbiAgICAgICAgICAgICAgICAgIHNoZWV0U3RlcCA9IHNoZWV0SXRlci5uZXh0KClcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIHZhciBzaGVldCA9IHNoZWV0U3RlcC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMgPSBzaGVldC5wcm9wcyxcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gcHJvcHMuaHJlZixcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMkanNjb21wJDAgPSBzaGVldC5wcm9wcztcbiAgICAgICAgICAgICAgICAgIHZhciBoZWFkZXIgPSBnZXRQcmVsb2FkQXNIZWFkZXIoXG4gICAgICAgICAgICAgICAgICAgIHByb3BzJGpzY29tcCQwLmhyZWYsXG4gICAgICAgICAgICAgICAgICAgIFwic3R5bGVcIixcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgIGNyb3NzT3JpZ2luOiBwcm9wcyRqc2NvbXAkMC5jcm9zc09yaWdpbixcbiAgICAgICAgICAgICAgICAgICAgICBpbnRlZ3JpdHk6IHByb3BzJGpzY29tcCQwLmludGVncml0eSxcbiAgICAgICAgICAgICAgICAgICAgICBub25jZTogcHJvcHMkanNjb21wJDAubm9uY2UsXG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogcHJvcHMkanNjb21wJDAudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICBmZXRjaFByaW9yaXR5OiBwcm9wcyRqc2NvbXAkMC5mZXRjaFByaW9yaXR5LFxuICAgICAgICAgICAgICAgICAgICAgIHJlZmVycmVyUG9saWN5OiBwcm9wcyRqc2NvbXAkMC5yZWZlcnJlclBvbGljeSxcbiAgICAgICAgICAgICAgICAgICAgICBtZWRpYTogcHJvcHMkanNjb21wJDAubWVkaWFcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGlmICgwIDw9IChoZWFkZXJzLnJlbWFpbmluZ0NhcGFjaXR5IC09IGhlYWRlci5sZW5ndGggKyAyKSlcbiAgICAgICAgICAgICAgICAgICAgKHJlbmRlclN0YXRlLnJlc2V0cy5zdHlsZVtrZXldID0gUFJFTE9BRF9OT19DUkVEUyksXG4gICAgICAgICAgICAgICAgICAgICAgbGlua0hlYWRlciAmJiAobGlua0hlYWRlciArPSBcIiwgXCIpLFxuICAgICAgICAgICAgICAgICAgICAgIChsaW5rSGVhZGVyICs9IGhlYWRlciksXG4gICAgICAgICAgICAgICAgICAgICAgKHJlbmRlclN0YXRlLnJlc2V0cy5zdHlsZVtrZXldID1cbiAgICAgICAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBwcm9wcy5jcm9zc09yaWdpbiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHByb3BzLmludGVncml0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICA/IFtwcm9wcy5jcm9zc09yaWdpbiwgcHJvcHMuaW50ZWdyaXR5XVxuICAgICAgICAgICAgICAgICAgICAgICAgICA6IFBSRUxPQURfTk9fQ1JFRFMpO1xuICAgICAgICAgICAgICAgICAgZWxzZSBicmVhayBiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbmtIZWFkZXIgPyBvbkhlYWRlcnMoeyBMaW5rOiBsaW5rSGVhZGVyIH0pIDogb25IZWFkZXJzKHt9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ1JlY292ZXJhYmxlRXJyb3IocmVxdWVzdCwgZXJyb3IsIHt9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcGxldGVTaGVsbChyZXF1ZXN0KSB7XG4gICAgICBudWxsID09PSByZXF1ZXN0LnRyYWNrZWRQb3N0cG9uZXMgJiYgc2FmZWx5RW1pdEVhcmx5UHJlbG9hZHMocmVxdWVzdCwgITApO1xuICAgICAgcmVxdWVzdC5vblNoZWxsRXJyb3IgPSBub29wO1xuICAgICAgcmVxdWVzdCA9IHJlcXVlc3Qub25TaGVsbFJlYWR5O1xuICAgICAgcmVxdWVzdCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wbGV0ZUFsbChyZXF1ZXN0KSB7XG4gICAgICBzYWZlbHlFbWl0RWFybHlQcmVsb2FkcyhcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgbnVsbCA9PT0gcmVxdWVzdC50cmFja2VkUG9zdHBvbmVzXG4gICAgICAgICAgPyAhMFxuICAgICAgICAgIDogbnVsbCA9PT0gcmVxdWVzdC5jb21wbGV0ZWRSb290U2VnbWVudCB8fFxuICAgICAgICAgICAgICByZXF1ZXN0LmNvbXBsZXRlZFJvb3RTZWdtZW50LnN0YXR1cyAhPT0gUE9TVFBPTkVEXG4gICAgICApO1xuICAgICAgcmVxdWVzdCA9IHJlcXVlc3Qub25BbGxSZWFkeTtcbiAgICAgIHJlcXVlc3QoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcXVldWVDb21wbGV0ZWRTZWdtZW50KGJvdW5kYXJ5LCBzZWdtZW50KSB7XG4gICAgICBpZiAoXG4gICAgICAgIDAgPT09IHNlZ21lbnQuY2h1bmtzLmxlbmd0aCAmJlxuICAgICAgICAxID09PSBzZWdtZW50LmNoaWxkcmVuLmxlbmd0aCAmJlxuICAgICAgICBudWxsID09PSBzZWdtZW50LmNoaWxkcmVuWzBdLmJvdW5kYXJ5ICYmXG4gICAgICAgIC0xID09PSBzZWdtZW50LmNoaWxkcmVuWzBdLmlkXG4gICAgICApIHtcbiAgICAgICAgdmFyIGNoaWxkU2VnbWVudCA9IHNlZ21lbnQuY2hpbGRyZW5bMF07XG4gICAgICAgIGNoaWxkU2VnbWVudC5pZCA9IHNlZ21lbnQuaWQ7XG4gICAgICAgIGNoaWxkU2VnbWVudC5wYXJlbnRGbHVzaGVkID0gITA7XG4gICAgICAgIGNoaWxkU2VnbWVudC5zdGF0dXMgPT09IENPTVBMRVRFRCAmJlxuICAgICAgICAgIHF1ZXVlQ29tcGxldGVkU2VnbWVudChib3VuZGFyeSwgY2hpbGRTZWdtZW50KTtcbiAgICAgIH0gZWxzZSBib3VuZGFyeS5jb21wbGV0ZWRTZWdtZW50cy5wdXNoKHNlZ21lbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5pc2hlZFRhc2socmVxdWVzdCwgYm91bmRhcnksIHNlZ21lbnQpIHtcbiAgICAgIGlmIChudWxsID09PSBib3VuZGFyeSkge1xuICAgICAgICBpZiAobnVsbCAhPT0gc2VnbWVudCAmJiBzZWdtZW50LnBhcmVudEZsdXNoZWQpIHtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gcmVxdWVzdC5jb21wbGV0ZWRSb290U2VnbWVudClcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICBcIlRoZXJlIGNhbiBvbmx5IGJlIG9uZSByb290IHNlZ21lbnQuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgcmVxdWVzdC5jb21wbGV0ZWRSb290U2VnbWVudCA9IHNlZ21lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzLS07XG4gICAgICAgIDAgPT09IHJlcXVlc3QucGVuZGluZ1Jvb3RUYXNrcyAmJiBjb21wbGV0ZVNoZWxsKHJlcXVlc3QpO1xuICAgICAgfSBlbHNlXG4gICAgICAgIGJvdW5kYXJ5LnBlbmRpbmdUYXNrcy0tLFxuICAgICAgICAgIGJvdW5kYXJ5LnN0YXR1cyAhPT0gQ0xJRU5UX1JFTkRFUkVEICYmXG4gICAgICAgICAgICAoMCA9PT0gYm91bmRhcnkucGVuZGluZ1Rhc2tzXG4gICAgICAgICAgICAgID8gKGJvdW5kYXJ5LnN0YXR1cyA9PT0gUEVORElORyAmJiAoYm91bmRhcnkuc3RhdHVzID0gQ09NUExFVEVEKSxcbiAgICAgICAgICAgICAgICBudWxsICE9PSBzZWdtZW50ICYmXG4gICAgICAgICAgICAgICAgICBzZWdtZW50LnBhcmVudEZsdXNoZWQgJiZcbiAgICAgICAgICAgICAgICAgIHNlZ21lbnQuc3RhdHVzID09PSBDT01QTEVURUQgJiZcbiAgICAgICAgICAgICAgICAgIHF1ZXVlQ29tcGxldGVkU2VnbWVudChib3VuZGFyeSwgc2VnbWVudCksXG4gICAgICAgICAgICAgICAgYm91bmRhcnkucGFyZW50Rmx1c2hlZCAmJlxuICAgICAgICAgICAgICAgICAgcmVxdWVzdC5jb21wbGV0ZWRCb3VuZGFyaWVzLnB1c2goYm91bmRhcnkpLFxuICAgICAgICAgICAgICAgIGJvdW5kYXJ5LnN0YXR1cyA9PT0gQ09NUExFVEVEICYmXG4gICAgICAgICAgICAgICAgICAoYm91bmRhcnkuZmFsbGJhY2tBYm9ydGFibGVUYXNrcy5mb3JFYWNoKFxuICAgICAgICAgICAgICAgICAgICBhYm9ydFRhc2tTb2Z0LFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0XG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgYm91bmRhcnkuZmFsbGJhY2tBYm9ydGFibGVUYXNrcy5jbGVhcigpKSlcbiAgICAgICAgICAgICAgOiBudWxsICE9PSBzZWdtZW50ICYmXG4gICAgICAgICAgICAgICAgc2VnbWVudC5wYXJlbnRGbHVzaGVkICYmXG4gICAgICAgICAgICAgICAgc2VnbWVudC5zdGF0dXMgPT09IENPTVBMRVRFRCAmJlxuICAgICAgICAgICAgICAgIChxdWV1ZUNvbXBsZXRlZFNlZ21lbnQoYm91bmRhcnksIHNlZ21lbnQpLFxuICAgICAgICAgICAgICAgIDEgPT09IGJvdW5kYXJ5LmNvbXBsZXRlZFNlZ21lbnRzLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgYm91bmRhcnkucGFyZW50Rmx1c2hlZCAmJlxuICAgICAgICAgICAgICAgICAgcmVxdWVzdC5wYXJ0aWFsQm91bmRhcmllcy5wdXNoKGJvdW5kYXJ5KSkpO1xuICAgICAgcmVxdWVzdC5hbGxQZW5kaW5nVGFza3MtLTtcbiAgICAgIDAgPT09IHJlcXVlc3QuYWxsUGVuZGluZ1Rhc2tzICYmIGNvbXBsZXRlQWxsKHJlcXVlc3QpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwZXJmb3JtV29yayhyZXF1ZXN0JGpzY29tcCQxKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHJlcXVlc3QkanNjb21wJDEuc3RhdHVzICE9PSBDTE9TRUQgJiZcbiAgICAgICAgMTMgIT09IHJlcXVlc3QkanNjb21wJDEuc3RhdHVzXG4gICAgICApIHtcbiAgICAgICAgdmFyIHByZXZDb250ZXh0ID0gY3VycmVudEFjdGl2ZVNuYXBzaG90LFxuICAgICAgICAgIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEhvb2tzRGlzcGF0Y2hlcjtcbiAgICAgICAgdmFyIHByZXZBc3luY0Rpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5BO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5BID0gRGVmYXVsdEFzeW5jRGlzcGF0Y2hlcjtcbiAgICAgICAgdmFyIHByZXZSZXF1ZXN0ID0gY3VycmVudFJlcXVlc3Q7XG4gICAgICAgIGN1cnJlbnRSZXF1ZXN0ID0gcmVxdWVzdCRqc2NvbXAkMTtcbiAgICAgICAgdmFyIHByZXZHZXRDdXJyZW50U3RhY2tJbXBsID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuZ2V0Q3VycmVudFN0YWNrO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2sgPSBnZXRDdXJyZW50U3RhY2tJbkRFVjtcbiAgICAgICAgdmFyIHByZXZSZXN1bWFibGVTdGF0ZSA9IGN1cnJlbnRSZXN1bWFibGVTdGF0ZTtcbiAgICAgICAgY3VycmVudFJlc3VtYWJsZVN0YXRlID0gcmVxdWVzdCRqc2NvbXAkMS5yZXN1bWFibGVTdGF0ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgcGluZ2VkVGFza3MgPSByZXF1ZXN0JGpzY29tcCQxLnBpbmdlZFRhc2tzLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGluZ2VkVGFza3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gcmVxdWVzdCRqc2NvbXAkMSxcbiAgICAgICAgICAgICAgdGFzayA9IHBpbmdlZFRhc2tzW2ldLFxuICAgICAgICAgICAgICBzZWdtZW50ID0gdGFzay5ibG9ja2VkU2VnbWVudDtcbiAgICAgICAgICAgIGlmIChudWxsID09PSBzZWdtZW50KSB7XG4gICAgICAgICAgICAgIHZhciBwcmV2VGFza0luREVWID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDAgPSByZXF1ZXN0O1xuICAgICAgICAgICAgICByZXF1ZXN0ID0gdGFzaztcbiAgICAgICAgICAgICAgaWYgKDAgIT09IHJlcXVlc3QucmVwbGF5LnBlbmRpbmdUYXNrcykge1xuICAgICAgICAgICAgICAgIHN3aXRjaENvbnRleHQocmVxdWVzdC5jb250ZXh0KTtcbiAgICAgICAgICAgICAgICBwcmV2VGFza0luREVWID0gY3VycmVudFRhc2tJbkRFVjtcbiAgICAgICAgICAgICAgICBjdXJyZW50VGFza0luREVWID0gcmVxdWVzdDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIHJlcXVlc3QucmVwbGF5LnNsb3RzXG4gICAgICAgICAgICAgICAgICAgID8gcmVzdW1lTm9kZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5yZXBsYXkuc2xvdHMsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0Lm5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmNoaWxkSW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIDogcmV0cnlOb2RlKHJlcXVlc3QkanNjb21wJDAsIHJlcXVlc3QpO1xuICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAxID09PSByZXF1ZXN0LnJlcGxheS5wZW5kaW5nVGFza3MgJiZcbiAgICAgICAgICAgICAgICAgICAgMCA8IHJlcXVlc3QucmVwbGF5Lm5vZGVzLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICBcIkNvdWxkbid0IGZpbmQgYWxsIHJlc3VtYWJsZSBzbG90cyBieSBrZXkvaW5kZXggZHVyaW5nIHJlcGxheWluZy4gVGhlIHRyZWUgZG9lc24ndCBtYXRjaCBzbyBSZWFjdCB3aWxsIGZhbGxiYWNrIHRvIGNsaWVudCByZW5kZXJpbmcuXCJcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3QucmVwbGF5LnBlbmRpbmdUYXNrcy0tO1xuICAgICAgICAgICAgICAgICAgcmVxdWVzdC5hYm9ydFNldC5kZWxldGUocmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFRhc2socmVxdWVzdCRqc2NvbXAkMCwgcmVxdWVzdC5ibG9ja2VkQm91bmRhcnksIG51bGwpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHRocm93blZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICByZXNldEhvb2tzU3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgIHZhciB4ID1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3duVmFsdWUgPT09IFN1c3BlbnNlRXhjZXB0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgPyBnZXRTdXNwZW5kZWRUaGVuYWJsZSgpXG4gICAgICAgICAgICAgICAgICAgICAgOiB0aHJvd25WYWx1ZTtcbiAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHggJiZcbiAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0geCAmJlxuICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB4LnRoZW5cbiAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGluZyA9IHJlcXVlc3QucGluZztcbiAgICAgICAgICAgICAgICAgICAgeC50aGVuKHBpbmcsIHBpbmcpO1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnRoZW5hYmxlU3RhdGUgPSBnZXRUaGVuYWJsZVN0YXRlQWZ0ZXJTdXNwZW5kaW5nKCk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnJlcGxheS5wZW5kaW5nVGFza3MtLTtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5hYm9ydFNldC5kZWxldGUocmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvckluZm8gPSBnZXRUaHJvd25JbmZvKHJlcXVlc3QuY29tcG9uZW50U3RhY2spO1xuICAgICAgICAgICAgICAgICAgICBlcnJvcmVkUmVwbGF5KFxuICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5ibG9ja2VkQm91bmRhcnksXG4gICAgICAgICAgICAgICAgICAgICAgMTIgPT09IHJlcXVlc3QkanNjb21wJDAuc3RhdHVzXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHJlcXVlc3QkanNjb21wJDAuZmF0YWxFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgOiB4LFxuICAgICAgICAgICAgICAgICAgICAgIGVycm9ySW5mbyxcbiAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnJlcGxheS5ub2RlcyxcbiAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnJlcGxheS5zbG90c1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0JGpzY29tcCQwLnBlbmRpbmdSb290VGFza3MtLTtcbiAgICAgICAgICAgICAgICAgICAgMCA9PT0gcmVxdWVzdCRqc2NvbXAkMC5wZW5kaW5nUm9vdFRhc2tzICYmXG4gICAgICAgICAgICAgICAgICAgICAgY29tcGxldGVTaGVsbChyZXF1ZXN0JGpzY29tcCQwKTtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCRqc2NvbXAkMC5hbGxQZW5kaW5nVGFza3MtLTtcbiAgICAgICAgICAgICAgICAgICAgMCA9PT0gcmVxdWVzdCRqc2NvbXAkMC5hbGxQZW5kaW5nVGFza3MgJiZcbiAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZUFsbChyZXF1ZXN0JGpzY29tcCQwKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgY3VycmVudFRhc2tJbkRFViA9IHByZXZUYXNrSW5ERVY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXF1ZXN0JGpzY29tcCQwID0gcHJldlRhc2tJbkRFViA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgdmFyIHRhc2skanNjb21wJDAgPSB0YXNrLFxuICAgICAgICAgICAgICAgIHNlZ21lbnQkanNjb21wJDAgPSBzZWdtZW50O1xuICAgICAgICAgICAgICBpZiAoc2VnbWVudCRqc2NvbXAkMC5zdGF0dXMgPT09IFBFTkRJTkcpIHtcbiAgICAgICAgICAgICAgICBzZWdtZW50JGpzY29tcCQwLnN0YXR1cyA9IDY7XG4gICAgICAgICAgICAgICAgc3dpdGNoQ29udGV4dCh0YXNrJGpzY29tcCQwLmNvbnRleHQpO1xuICAgICAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDAgPSBjdXJyZW50VGFza0luREVWO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRUYXNrSW5ERVYgPSB0YXNrJGpzY29tcCQwO1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZHJlbkxlbmd0aCA9IHNlZ21lbnQkanNjb21wJDAuY2hpbGRyZW4ubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgY2h1bmtMZW5ndGggPSBzZWdtZW50JGpzY29tcCQwLmNodW5rcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHJldHJ5Tm9kZShyZXF1ZXN0LCB0YXNrJGpzY29tcCQwKSxcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudCRqc2NvbXAkMC5sYXN0UHVzaGVkVGV4dCAmJlxuICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnQkanNjb21wJDAudGV4dEVtYmVkZGVkICYmXG4gICAgICAgICAgICAgICAgICAgICAgc2VnbWVudCRqc2NvbXAkMC5jaHVua3MucHVzaCh0ZXh0U2VwYXJhdG9yKSxcbiAgICAgICAgICAgICAgICAgICAgdGFzayRqc2NvbXAkMC5hYm9ydFNldC5kZWxldGUodGFzayRqc2NvbXAkMCksXG4gICAgICAgICAgICAgICAgICAgIChzZWdtZW50JGpzY29tcCQwLnN0YXR1cyA9IENPTVBMRVRFRCksXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkVGFzayhcbiAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICAgIHRhc2skanNjb21wJDAuYmxvY2tlZEJvdW5kYXJ5LFxuICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnQkanNjb21wJDBcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoICh0aHJvd25WYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgcmVzZXRIb29rc1N0YXRlKCk7XG4gICAgICAgICAgICAgICAgICBzZWdtZW50JGpzY29tcCQwLmNoaWxkcmVuLmxlbmd0aCA9IGNoaWxkcmVuTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgc2VnbWVudCRqc2NvbXAkMC5jaHVua3MubGVuZ3RoID0gY2h1bmtMZW5ndGg7XG4gICAgICAgICAgICAgICAgICB2YXIgeCRqc2NvbXAkMCA9XG4gICAgICAgICAgICAgICAgICAgIHRocm93blZhbHVlID09PSBTdXNwZW5zZUV4Y2VwdGlvblxuICAgICAgICAgICAgICAgICAgICAgID8gZ2V0U3VzcGVuZGVkVGhlbmFibGUoKVxuICAgICAgICAgICAgICAgICAgICAgIDogMTIgPT09IHJlcXVlc3Quc3RhdHVzXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHJlcXVlc3QuZmF0YWxFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0aHJvd25WYWx1ZTtcbiAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHgkanNjb21wJDAgJiZcbiAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0geCRqc2NvbXAkMCAmJlxuICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB4JGpzY29tcCQwLnRoZW5cbiAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBzZWdtZW50JGpzY29tcCQwLnN0YXR1cyA9IFBFTkRJTkc7XG4gICAgICAgICAgICAgICAgICAgIHRhc2skanNjb21wJDAudGhlbmFibGVTdGF0ZSA9XG4gICAgICAgICAgICAgICAgICAgICAgZ2V0VGhlbmFibGVTdGF0ZUFmdGVyU3VzcGVuZGluZygpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGluZyRqc2NvbXAkMCA9IHRhc2skanNjb21wJDAucGluZztcbiAgICAgICAgICAgICAgICAgICAgeCRqc2NvbXAkMC50aGVuKHBpbmckanNjb21wJDAsIHBpbmckanNjb21wJDApO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9ySW5mbyRqc2NvbXAkMCA9IGdldFRocm93bkluZm8oXG4gICAgICAgICAgICAgICAgICAgICAgdGFzayRqc2NvbXAkMC5jb21wb25lbnRTdGFja1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB0YXNrJGpzY29tcCQwLmFib3J0U2V0LmRlbGV0ZSh0YXNrJGpzY29tcCQwKTtcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudCRqc2NvbXAkMC5zdGF0dXMgPSA0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgYm91bmRhcnkgPSB0YXNrJGpzY29tcCQwLmJsb2NrZWRCb3VuZGFyeTtcbiAgICAgICAgICAgICAgICAgICAgcHJldlRhc2tJbkRFViA9IGxvZ1JlY292ZXJhYmxlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgICB4JGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICAgIGVycm9ySW5mbyRqc2NvbXAkMFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBudWxsID09PSBib3VuZGFyeVxuICAgICAgICAgICAgICAgICAgICAgID8gZmF0YWxFcnJvcihyZXF1ZXN0LCB4JGpzY29tcCQwKVxuICAgICAgICAgICAgICAgICAgICAgIDogKGJvdW5kYXJ5LnBlbmRpbmdUYXNrcy0tLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRhcnkuc3RhdHVzICE9PSBDTElFTlRfUkVOREVSRUQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKChib3VuZGFyeS5zdGF0dXMgPSBDTElFTlRfUkVOREVSRUQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVFcnJvckZvckJvdW5kYXJ5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kYXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZUYXNrSW5ERVYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvckluZm8kanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdW50cmFja0JvdW5kYXJ5KHJlcXVlc3QsIGJvdW5kYXJ5KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRhcnkucGFyZW50Rmx1c2hlZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzLnB1c2goYm91bmRhcnkpKSk7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuYWxsUGVuZGluZ1Rhc2tzLS07XG4gICAgICAgICAgICAgICAgICAgIDAgPT09IHJlcXVlc3QuYWxsUGVuZGluZ1Rhc2tzICYmIGNvbXBsZXRlQWxsKHJlcXVlc3QpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50VGFza0luREVWID0gcmVxdWVzdCRqc2NvbXAkMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcGluZ2VkVGFza3Muc3BsaWNlKDAsIGkpO1xuICAgICAgICAgIG51bGwgIT09IHJlcXVlc3QkanNjb21wJDEuZGVzdGluYXRpb24gJiZcbiAgICAgICAgICAgIGZsdXNoQ29tcGxldGVkUXVldWVzKFxuICAgICAgICAgICAgICByZXF1ZXN0JGpzY29tcCQxLFxuICAgICAgICAgICAgICByZXF1ZXN0JGpzY29tcCQxLmRlc3RpbmF0aW9uXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGxvZ1JlY292ZXJhYmxlRXJyb3IocmVxdWVzdCRqc2NvbXAkMSwgZXJyb3IsIHt9KSxcbiAgICAgICAgICAgIGZhdGFsRXJyb3IocmVxdWVzdCRqc2NvbXAkMSwgZXJyb3IpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIChjdXJyZW50UmVzdW1hYmxlU3RhdGUgPSBwcmV2UmVzdW1hYmxlU3RhdGUpLFxuICAgICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlciksXG4gICAgICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuQSA9IHByZXZBc3luY0Rpc3BhdGNoZXIpLFxuICAgICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjayA9IHByZXZHZXRDdXJyZW50U3RhY2tJbXBsKSxcbiAgICAgICAgICAgIHByZXZEaXNwYXRjaGVyID09PSBIb29rc0Rpc3BhdGNoZXIgJiYgc3dpdGNoQ29udGV4dChwcmV2Q29udGV4dCksXG4gICAgICAgICAgICAoY3VycmVudFJlcXVlc3QgPSBwcmV2UmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZmx1c2hTdWJ0cmVlKHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBzZWdtZW50LCBob2lzdGFibGVTdGF0ZSkge1xuICAgICAgc2VnbWVudC5wYXJlbnRGbHVzaGVkID0gITA7XG4gICAgICBzd2l0Y2ggKHNlZ21lbnQuc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgUEVORElORzpcbiAgICAgICAgICBzZWdtZW50LmlkID0gcmVxdWVzdC5uZXh0U2VnbWVudElkKys7XG4gICAgICAgIGNhc2UgUE9TVFBPTkVEOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoaG9pc3RhYmxlU3RhdGUgPSBzZWdtZW50LmlkKSxcbiAgICAgICAgICAgIChzZWdtZW50Lmxhc3RQdXNoZWRUZXh0ID0gITEpLFxuICAgICAgICAgICAgKHNlZ21lbnQudGV4dEVtYmVkZGVkID0gITEpLFxuICAgICAgICAgICAgKHJlcXVlc3QgPSByZXF1ZXN0LnJlbmRlclN0YXRlKSxcbiAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHBsYWNlaG9sZGVyMSksXG4gICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZXF1ZXN0LnBsYWNlaG9sZGVyUHJlZml4KSxcbiAgICAgICAgICAgIChyZXF1ZXN0ID0gc3RyaW5nVG9DaHVuayhob2lzdGFibGVTdGF0ZS50b1N0cmluZygxNikpKSxcbiAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHJlcXVlc3QpLFxuICAgICAgICAgICAgd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgcGxhY2Vob2xkZXIyKVxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgQ09NUExFVEVEOlxuICAgICAgICAgIHNlZ21lbnQuc3RhdHVzID0gRkxVU0hFRDtcbiAgICAgICAgICB2YXIgciA9ICEwLFxuICAgICAgICAgICAgY2h1bmtzID0gc2VnbWVudC5jaHVua3MsXG4gICAgICAgICAgICBjaHVua0lkeCA9IDA7XG4gICAgICAgICAgc2VnbWVudCA9IHNlZ21lbnQuY2hpbGRyZW47XG4gICAgICAgICAgZm9yICh2YXIgY2hpbGRJZHggPSAwOyBjaGlsZElkeCA8IHNlZ21lbnQubGVuZ3RoOyBjaGlsZElkeCsrKSB7XG4gICAgICAgICAgICBmb3IgKHIgPSBzZWdtZW50W2NoaWxkSWR4XTsgY2h1bmtJZHggPCByLmluZGV4OyBjaHVua0lkeCsrKVxuICAgICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjaHVua3NbY2h1bmtJZHhdKTtcbiAgICAgICAgICAgIHIgPSBmbHVzaFNlZ21lbnQocmVxdWVzdCwgZGVzdGluYXRpb24sIHIsIGhvaXN0YWJsZVN0YXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICg7IGNodW5rSWR4IDwgY2h1bmtzLmxlbmd0aCAtIDE7IGNodW5rSWR4KyspXG4gICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjaHVua3NbY2h1bmtJZHhdKTtcbiAgICAgICAgICBjaHVua0lkeCA8IGNodW5rcy5sZW5ndGggJiZcbiAgICAgICAgICAgIChyID0gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgY2h1bmtzW2NodW5rSWR4XSkpO1xuICAgICAgICAgIHJldHVybiByO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJBYm9ydGVkLCBlcnJvcmVkIG9yIGFscmVhZHkgZmx1c2hlZCBib3VuZGFyaWVzIHNob3VsZCBub3QgYmUgZmx1c2hlZCBhZ2Fpbi4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsdXNoU2VnbWVudChyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgc2VnbWVudCwgaG9pc3RhYmxlU3RhdGUpIHtcbiAgICAgIHZhciBib3VuZGFyeSA9IHNlZ21lbnQuYm91bmRhcnk7XG4gICAgICBpZiAobnVsbCA9PT0gYm91bmRhcnkpXG4gICAgICAgIHJldHVybiBmbHVzaFN1YnRyZWUocmVxdWVzdCwgZGVzdGluYXRpb24sIHNlZ21lbnQsIGhvaXN0YWJsZVN0YXRlKTtcbiAgICAgIGJvdW5kYXJ5LnBhcmVudEZsdXNoZWQgPSAhMDtcbiAgICAgIGlmIChib3VuZGFyeS5zdGF0dXMgPT09IENMSUVOVF9SRU5ERVJFRCkge1xuICAgICAgICB2YXIgZXJyb3JEaWdlc3QgPSBib3VuZGFyeS5lcnJvckRpZ2VzdCxcbiAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBib3VuZGFyeS5lcnJvck1lc3NhZ2UsXG4gICAgICAgICAgZXJyb3JTdGFjayA9IGJvdW5kYXJ5LmVycm9yU3RhY2s7XG4gICAgICAgIGJvdW5kYXJ5ID0gYm91bmRhcnkuZXJyb3JDb21wb25lbnRTdGFjaztcbiAgICAgICAgd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgc3RhcnRDbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnkpO1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjEpO1xuICAgICAgICBlcnJvckRpZ2VzdCAmJlxuICAgICAgICAgICh3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjFBKSxcbiAgICAgICAgICB3cml0ZUNodW5rKFxuICAgICAgICAgICAgZGVzdGluYXRpb24sXG4gICAgICAgICAgICBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKGVycm9yRGlnZXN0KSlcbiAgICAgICAgICApLFxuICAgICAgICAgIHdyaXRlQ2h1bmsoXG4gICAgICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgICAgICAgIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yQXR0ckludGVyc3RpdGlhbFxuICAgICAgICAgICkpO1xuICAgICAgICBlcnJvck1lc3NhZ2UgJiZcbiAgICAgICAgICAod3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxQiksXG4gICAgICAgICAgd3JpdGVDaHVuayhcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICAgICAgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihlcnJvck1lc3NhZ2UpKVxuICAgICAgICAgICksXG4gICAgICAgICAgd3JpdGVDaHVuayhcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICAgICAgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3JBdHRySW50ZXJzdGl0aWFsXG4gICAgICAgICAgKSk7XG4gICAgICAgIGVycm9yU3RhY2sgJiZcbiAgICAgICAgICAod3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxQyksXG4gICAgICAgICAgd3JpdGVDaHVuayhcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICAgICAgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihlcnJvclN0YWNrKSlcbiAgICAgICAgICApLFxuICAgICAgICAgIHdyaXRlQ2h1bmsoXG4gICAgICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgICAgICAgIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yQXR0ckludGVyc3RpdGlhbFxuICAgICAgICAgICkpO1xuICAgICAgICBib3VuZGFyeSAmJlxuICAgICAgICAgICh3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjFEKSxcbiAgICAgICAgICB3cml0ZUNodW5rKFxuICAgICAgICAgICAgZGVzdGluYXRpb24sXG4gICAgICAgICAgICBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKGJvdW5kYXJ5KSlcbiAgICAgICAgICApLFxuICAgICAgICAgIHdyaXRlQ2h1bmsoXG4gICAgICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgICAgICAgIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yQXR0ckludGVyc3RpdGlhbFxuICAgICAgICAgICkpO1xuICAgICAgICB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjIpO1xuICAgICAgICBmbHVzaFN1YnRyZWUocmVxdWVzdCwgZGVzdGluYXRpb24sIHNlZ21lbnQsIGhvaXN0YWJsZVN0YXRlKTtcbiAgICAgIH0gZWxzZSBpZiAoYm91bmRhcnkuc3RhdHVzICE9PSBDT01QTEVURUQpXG4gICAgICAgIGJvdW5kYXJ5LnN0YXR1cyA9PT0gUEVORElORyAmJlxuICAgICAgICAgIChib3VuZGFyeS5yb290U2VnbWVudElEID0gcmVxdWVzdC5uZXh0U2VnbWVudElkKyspLFxuICAgICAgICAgIDAgPCBib3VuZGFyeS5jb21wbGV0ZWRTZWdtZW50cy5sZW5ndGggJiZcbiAgICAgICAgICAgIHJlcXVlc3QucGFydGlhbEJvdW5kYXJpZXMucHVzaChib3VuZGFyeSksXG4gICAgICAgICAgd3JpdGVTdGFydFBlbmRpbmdTdXNwZW5zZUJvdW5kYXJ5KFxuICAgICAgICAgICAgZGVzdGluYXRpb24sXG4gICAgICAgICAgICByZXF1ZXN0LnJlbmRlclN0YXRlLFxuICAgICAgICAgICAgYm91bmRhcnkucm9vdFNlZ21lbnRJRFxuICAgICAgICAgICksXG4gICAgICAgICAgaG9pc3RhYmxlU3RhdGUgJiZcbiAgICAgICAgICAgICgoYm91bmRhcnkgPSBib3VuZGFyeS5mYWxsYmFja1N0YXRlKSxcbiAgICAgICAgICAgIGJvdW5kYXJ5LnN0eWxlcy5mb3JFYWNoKGhvaXN0U3R5bGVRdWV1ZURlcGVuZGVuY3ksIGhvaXN0YWJsZVN0YXRlKSxcbiAgICAgICAgICAgIGJvdW5kYXJ5LnN0eWxlc2hlZXRzLmZvckVhY2goXG4gICAgICAgICAgICAgIGhvaXN0U3R5bGVzaGVldERlcGVuZGVuY3ksXG4gICAgICAgICAgICAgIGhvaXN0YWJsZVN0YXRlXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICBmbHVzaFN1YnRyZWUocmVxdWVzdCwgZGVzdGluYXRpb24sIHNlZ21lbnQsIGhvaXN0YWJsZVN0YXRlKTtcbiAgICAgIGVsc2UgaWYgKGJvdW5kYXJ5LmJ5dGVTaXplID4gcmVxdWVzdC5wcm9ncmVzc2l2ZUNodW5rU2l6ZSlcbiAgICAgICAgKGJvdW5kYXJ5LnJvb3RTZWdtZW50SUQgPSByZXF1ZXN0Lm5leHRTZWdtZW50SWQrKyksXG4gICAgICAgICAgcmVxdWVzdC5jb21wbGV0ZWRCb3VuZGFyaWVzLnB1c2goYm91bmRhcnkpLFxuICAgICAgICAgIHdyaXRlU3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeShcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICAgICAgcmVxdWVzdC5yZW5kZXJTdGF0ZSxcbiAgICAgICAgICAgIGJvdW5kYXJ5LnJvb3RTZWdtZW50SURcbiAgICAgICAgICApLFxuICAgICAgICAgIGZsdXNoU3VidHJlZShyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgc2VnbWVudCwgaG9pc3RhYmxlU3RhdGUpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGhvaXN0YWJsZVN0YXRlICYmXG4gICAgICAgICAgKChzZWdtZW50ID0gYm91bmRhcnkuY29udGVudFN0YXRlKSxcbiAgICAgICAgICBzZWdtZW50LnN0eWxlcy5mb3JFYWNoKGhvaXN0U3R5bGVRdWV1ZURlcGVuZGVuY3ksIGhvaXN0YWJsZVN0YXRlKSxcbiAgICAgICAgICBzZWdtZW50LnN0eWxlc2hlZXRzLmZvckVhY2goXG4gICAgICAgICAgICBob2lzdFN0eWxlc2hlZXREZXBlbmRlbmN5LFxuICAgICAgICAgICAgaG9pc3RhYmxlU3RhdGVcbiAgICAgICAgICApKTtcbiAgICAgICAgd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgc3RhcnRDb21wbGV0ZWRTdXNwZW5zZUJvdW5kYXJ5KTtcbiAgICAgICAgc2VnbWVudCA9IGJvdW5kYXJ5LmNvbXBsZXRlZFNlZ21lbnRzO1xuICAgICAgICBpZiAoMSAhPT0gc2VnbWVudC5sZW5ndGgpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIkEgcHJldmlvdXNseSB1bnZpc2l0ZWQgYm91bmRhcnkgbXVzdCBoYXZlIGV4YWN0bHkgb25lIHJvb3Qgc2VnbWVudC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICk7XG4gICAgICAgIGZsdXNoU2VnbWVudChyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgc2VnbWVudFswXSwgaG9pc3RhYmxlU3RhdGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGVuZFN1c3BlbnNlQm91bmRhcnkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmbHVzaFNlZ21lbnRDb250YWluZXIoXG4gICAgICByZXF1ZXN0LFxuICAgICAgZGVzdGluYXRpb24sXG4gICAgICBzZWdtZW50LFxuICAgICAgaG9pc3RhYmxlU3RhdGVcbiAgICApIHtcbiAgICAgIHdyaXRlU3RhcnRTZWdtZW50KFxuICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgICAgcmVxdWVzdC5yZW5kZXJTdGF0ZSxcbiAgICAgICAgc2VnbWVudC5wYXJlbnRGb3JtYXRDb250ZXh0LFxuICAgICAgICBzZWdtZW50LmlkXG4gICAgICApO1xuICAgICAgZmx1c2hTZWdtZW50KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBzZWdtZW50LCBob2lzdGFibGVTdGF0ZSk7XG4gICAgICByZXR1cm4gd3JpdGVFbmRTZWdtZW50KGRlc3RpbmF0aW9uLCBzZWdtZW50LnBhcmVudEZvcm1hdENvbnRleHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmbHVzaENvbXBsZXRlZEJvdW5kYXJ5KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBib3VuZGFyeSkge1xuICAgICAgZm9yIChcbiAgICAgICAgdmFyIGNvbXBsZXRlZFNlZ21lbnRzID0gYm91bmRhcnkuY29tcGxldGVkU2VnbWVudHMsIGkgPSAwO1xuICAgICAgICBpIDwgY29tcGxldGVkU2VnbWVudHMubGVuZ3RoO1xuICAgICAgICBpKytcbiAgICAgIClcbiAgICAgICAgZmx1c2hQYXJ0aWFsbHlDb21wbGV0ZWRTZWdtZW50KFxuICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgZGVzdGluYXRpb24sXG4gICAgICAgICAgYm91bmRhcnksXG4gICAgICAgICAgY29tcGxldGVkU2VnbWVudHNbaV1cbiAgICAgICAgKTtcbiAgICAgIGNvbXBsZXRlZFNlZ21lbnRzLmxlbmd0aCA9IDA7XG4gICAgICB3cml0ZUhvaXN0YWJsZXNGb3JCb3VuZGFyeShcbiAgICAgICAgZGVzdGluYXRpb24sXG4gICAgICAgIGJvdW5kYXJ5LmNvbnRlbnRTdGF0ZSxcbiAgICAgICAgcmVxdWVzdC5yZW5kZXJTdGF0ZVxuICAgICAgKTtcbiAgICAgIGNvbXBsZXRlZFNlZ21lbnRzID0gcmVxdWVzdC5yZXN1bWFibGVTdGF0ZTtcbiAgICAgIHJlcXVlc3QgPSByZXF1ZXN0LnJlbmRlclN0YXRlO1xuICAgICAgaSA9IGJvdW5kYXJ5LnJvb3RTZWdtZW50SUQ7XG4gICAgICBib3VuZGFyeSA9IGJvdW5kYXJ5LmNvbnRlbnRTdGF0ZTtcbiAgICAgIHZhciByZXF1aXJlc1N0eWxlSW5zZXJ0aW9uID0gcmVxdWVzdC5zdHlsZXNUb0hvaXN0O1xuICAgICAgcmVxdWVzdC5zdHlsZXNUb0hvaXN0ID0gITE7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZXF1ZXN0LnN0YXJ0SW5saW5lU2NyaXB0KTtcbiAgICAgIHJlcXVpcmVzU3R5bGVJbnNlcnRpb25cbiAgICAgICAgPyAoY29tcGxldGVkU2VnbWVudHMuaW5zdHJ1Y3Rpb25zICYgU2VudENvbXBsZXRlQm91bmRhcnlGdW5jdGlvbikgPT09XG4gICAgICAgICAgTm90aGluZ1NlbnRcbiAgICAgICAgICA/ICgoY29tcGxldGVkU2VnbWVudHMuaW5zdHJ1Y3Rpb25zID1cbiAgICAgICAgICAgICAgY29tcGxldGVkU2VnbWVudHMuaW5zdHJ1Y3Rpb25zIHxcbiAgICAgICAgICAgICAgU2VudFN0eWxlSW5zZXJ0aW9uRnVuY3Rpb24gfFxuICAgICAgICAgICAgICBTZW50Q29tcGxldGVCb3VuZGFyeUZ1bmN0aW9uKSxcbiAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNvbXBsZXRlQm91bmRhcnlXaXRoU3R5bGVzU2NyaXB0MUZ1bGxCb3RoKSlcbiAgICAgICAgICA6IChjb21wbGV0ZWRTZWdtZW50cy5pbnN0cnVjdGlvbnMgJiBTZW50U3R5bGVJbnNlcnRpb25GdW5jdGlvbikgPT09XG4gICAgICAgICAgICAgIE5vdGhpbmdTZW50XG4gICAgICAgICAgICA/ICgoY29tcGxldGVkU2VnbWVudHMuaW5zdHJ1Y3Rpb25zIHw9IFNlbnRTdHlsZUluc2VydGlvbkZ1bmN0aW9uKSxcbiAgICAgICAgICAgICAgd3JpdGVDaHVuayhcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgICAgICAgICAgICBjb21wbGV0ZUJvdW5kYXJ5V2l0aFN0eWxlc1NjcmlwdDFGdWxsUGFydGlhbFxuICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgOiB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjb21wbGV0ZUJvdW5kYXJ5V2l0aFN0eWxlc1NjcmlwdDFQYXJ0aWFsKVxuICAgICAgICA6IChjb21wbGV0ZWRTZWdtZW50cy5pbnN0cnVjdGlvbnMgJiBTZW50Q29tcGxldGVCb3VuZGFyeUZ1bmN0aW9uKSA9PT1cbiAgICAgICAgICAgIE5vdGhpbmdTZW50XG4gICAgICAgICAgPyAoKGNvbXBsZXRlZFNlZ21lbnRzLmluc3RydWN0aW9ucyB8PSBTZW50Q29tcGxldGVCb3VuZGFyeUZ1bmN0aW9uKSxcbiAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNvbXBsZXRlQm91bmRhcnlTY3JpcHQxRnVsbCkpXG4gICAgICAgICAgOiB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0MVBhcnRpYWwpO1xuICAgICAgY29tcGxldGVkU2VnbWVudHMgPSBzdHJpbmdUb0NodW5rKGkudG9TdHJpbmcoMTYpKTtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHJlcXVlc3QuYm91bmRhcnlQcmVmaXgpO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVkU2VnbWVudHMpO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVCb3VuZGFyeVNjcmlwdDIpO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVxdWVzdC5zZWdtZW50UHJlZml4KTtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNvbXBsZXRlZFNlZ21lbnRzKTtcbiAgICAgIHJlcXVpcmVzU3R5bGVJbnNlcnRpb25cbiAgICAgICAgPyAod3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVCb3VuZGFyeVNjcmlwdDNhKSxcbiAgICAgICAgICB3cml0ZVN0eWxlUmVzb3VyY2VEZXBlbmRlbmNpZXNJbkpTKGRlc3RpbmF0aW9uLCBib3VuZGFyeSkpXG4gICAgICAgIDogd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVCb3VuZGFyeVNjcmlwdDNiKTtcbiAgICAgIGJvdW5kYXJ5ID0gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgY29tcGxldGVCb3VuZGFyeVNjcmlwdEVuZCk7XG4gICAgICByZXR1cm4gd3JpdGVCb290c3RyYXAoZGVzdGluYXRpb24sIHJlcXVlc3QpICYmIGJvdW5kYXJ5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBmbHVzaFBhcnRpYWxseUNvbXBsZXRlZFNlZ21lbnQoXG4gICAgICByZXF1ZXN0LFxuICAgICAgZGVzdGluYXRpb24sXG4gICAgICBib3VuZGFyeSxcbiAgICAgIHNlZ21lbnRcbiAgICApIHtcbiAgICAgIGlmIChzZWdtZW50LnN0YXR1cyA9PT0gRkxVU0hFRCkgcmV0dXJuICEwO1xuICAgICAgdmFyIGhvaXN0YWJsZVN0YXRlID0gYm91bmRhcnkuY29udGVudFN0YXRlLFxuICAgICAgICBzZWdtZW50SUQgPSBzZWdtZW50LmlkO1xuICAgICAgaWYgKC0xID09PSBzZWdtZW50SUQpIHtcbiAgICAgICAgaWYgKC0xID09PSAoc2VnbWVudC5pZCA9IGJvdW5kYXJ5LnJvb3RTZWdtZW50SUQpKVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJBIHJvb3Qgc2VnbWVudCBJRCBtdXN0IGhhdmUgYmVlbiBhc3NpZ25lZCBieSBub3cuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICApO1xuICAgICAgICByZXR1cm4gZmx1c2hTZWdtZW50Q29udGFpbmVyKFxuICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgZGVzdGluYXRpb24sXG4gICAgICAgICAgc2VnbWVudCxcbiAgICAgICAgICBob2lzdGFibGVTdGF0ZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHNlZ21lbnRJRCA9PT0gYm91bmRhcnkucm9vdFNlZ21lbnRJRClcbiAgICAgICAgcmV0dXJuIGZsdXNoU2VnbWVudENvbnRhaW5lcihcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICAgIHNlZ21lbnQsXG4gICAgICAgICAgaG9pc3RhYmxlU3RhdGVcbiAgICAgICAgKTtcbiAgICAgIGZsdXNoU2VnbWVudENvbnRhaW5lcihyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgc2VnbWVudCwgaG9pc3RhYmxlU3RhdGUpO1xuICAgICAgYm91bmRhcnkgPSByZXF1ZXN0LnJlc3VtYWJsZVN0YXRlO1xuICAgICAgcmVxdWVzdCA9IHJlcXVlc3QucmVuZGVyU3RhdGU7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZXF1ZXN0LnN0YXJ0SW5saW5lU2NyaXB0KTtcbiAgICAgIChib3VuZGFyeS5pbnN0cnVjdGlvbnMgJiBTZW50Q29tcGxldGVTZWdtZW50RnVuY3Rpb24pID09PSBOb3RoaW5nU2VudFxuICAgICAgICA/ICgoYm91bmRhcnkuaW5zdHJ1Y3Rpb25zIHw9IFNlbnRDb21wbGV0ZVNlZ21lbnRGdW5jdGlvbiksXG4gICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVTZWdtZW50U2NyaXB0MUZ1bGwpKVxuICAgICAgICA6IHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNvbXBsZXRlU2VnbWVudFNjcmlwdDFQYXJ0aWFsKTtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHJlcXVlc3Quc2VnbWVudFByZWZpeCk7XG4gICAgICBzZWdtZW50SUQgPSBzdHJpbmdUb0NodW5rKHNlZ21lbnRJRC50b1N0cmluZygxNikpO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc2VnbWVudElEKTtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNvbXBsZXRlU2VnbWVudFNjcmlwdDIpO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVxdWVzdC5wbGFjZWhvbGRlclByZWZpeCk7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzZWdtZW50SUQpO1xuICAgICAgZGVzdGluYXRpb24gPSB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBjb21wbGV0ZVNlZ21lbnRTY3JpcHRFbmQpO1xuICAgICAgcmV0dXJuIGRlc3RpbmF0aW9uO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmbHVzaENvbXBsZXRlZFF1ZXVlcyhyZXF1ZXN0LCBkZXN0aW5hdGlvbikge1xuICAgICAgY3VycmVudFZpZXcgPSBuZXcgVWludDhBcnJheSgyMDQ4KTtcbiAgICAgIHdyaXR0ZW5CeXRlcyA9IDA7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoISgwIDwgcmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzKSkge1xuICAgICAgICAgIHZhciBpLFxuICAgICAgICAgICAgY29tcGxldGVkUm9vdFNlZ21lbnQgPSByZXF1ZXN0LmNvbXBsZXRlZFJvb3RTZWdtZW50O1xuICAgICAgICAgIGlmIChudWxsICE9PSBjb21wbGV0ZWRSb290U2VnbWVudCkge1xuICAgICAgICAgICAgaWYgKGNvbXBsZXRlZFJvb3RTZWdtZW50LnN0YXR1cyA9PT0gUE9TVFBPTkVEKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgcmVuZGVyU3RhdGUgPSByZXF1ZXN0LnJlbmRlclN0YXRlLFxuICAgICAgICAgICAgICBodG1sQ2h1bmtzID0gcmVuZGVyU3RhdGUuaHRtbENodW5rcyxcbiAgICAgICAgICAgICAgaGVhZENodW5rcyA9IHJlbmRlclN0YXRlLmhlYWRDaHVua3MsXG4gICAgICAgICAgICAgIGkkanNjb21wJDA7XG4gICAgICAgICAgICBpZiAoaHRtbENodW5rcykge1xuICAgICAgICAgICAgICBmb3IgKGkkanNjb21wJDAgPSAwOyBpJGpzY29tcCQwIDwgaHRtbENodW5rcy5sZW5ndGg7IGkkanNjb21wJDArKylcbiAgICAgICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBodG1sQ2h1bmtzW2kkanNjb21wJDBdKTtcbiAgICAgICAgICAgICAgaWYgKGhlYWRDaHVua3MpXG4gICAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICAgIGkkanNjb21wJDAgPSAwO1xuICAgICAgICAgICAgICAgICAgaSRqc2NvbXAkMCA8IGhlYWRDaHVua3MubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgaSRqc2NvbXAkMCsrXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgaGVhZENodW5rc1tpJGpzY29tcCQwXSk7XG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdGFydENodW5rRm9yVGFnKFwiaGVhZFwiKSksXG4gICAgICAgICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBlbmRPZlN0YXJ0VGFnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaGVhZENodW5rcylcbiAgICAgICAgICAgICAgZm9yIChpJGpzY29tcCQwID0gMDsgaSRqc2NvbXAkMCA8IGhlYWRDaHVua3MubGVuZ3RoOyBpJGpzY29tcCQwKyspXG4gICAgICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgaGVhZENodW5rc1tpJGpzY29tcCQwXSk7XG4gICAgICAgICAgICB2YXIgY2hhcnNldENodW5rcyA9IHJlbmRlclN0YXRlLmNoYXJzZXRDaHVua3M7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICBpJGpzY29tcCQwID0gMDtcbiAgICAgICAgICAgICAgaSRqc2NvbXAkMCA8IGNoYXJzZXRDaHVua3MubGVuZ3RoO1xuICAgICAgICAgICAgICBpJGpzY29tcCQwKytcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2hhcnNldENodW5rc1tpJGpzY29tcCQwXSk7XG4gICAgICAgICAgICBjaGFyc2V0Q2h1bmtzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5wcmVjb25uZWN0cy5mb3JFYWNoKGZsdXNoUmVzb3VyY2UsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgIHJlbmRlclN0YXRlLnByZWNvbm5lY3RzLmNsZWFyKCk7XG4gICAgICAgICAgICB2YXIgdmlld3BvcnRDaHVua3MgPSByZW5kZXJTdGF0ZS52aWV3cG9ydENodW5rcztcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIGkkanNjb21wJDAgPSAwO1xuICAgICAgICAgICAgICBpJGpzY29tcCQwIDwgdmlld3BvcnRDaHVua3MubGVuZ3RoO1xuICAgICAgICAgICAgICBpJGpzY29tcCQwKytcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgdmlld3BvcnRDaHVua3NbaSRqc2NvbXAkMF0pO1xuICAgICAgICAgICAgdmlld3BvcnRDaHVua3MubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHJlbmRlclN0YXRlLmZvbnRQcmVsb2Fkcy5mb3JFYWNoKGZsdXNoUmVzb3VyY2UsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgIHJlbmRlclN0YXRlLmZvbnRQcmVsb2Fkcy5jbGVhcigpO1xuICAgICAgICAgICAgcmVuZGVyU3RhdGUuaGlnaEltYWdlUHJlbG9hZHMuZm9yRWFjaChmbHVzaFJlc291cmNlLCBkZXN0aW5hdGlvbik7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5oaWdoSW1hZ2VQcmVsb2Fkcy5jbGVhcigpO1xuICAgICAgICAgICAgcmVuZGVyU3RhdGUuc3R5bGVzLmZvckVhY2goZmx1c2hTdHlsZXNJblByZWFtYmxlLCBkZXN0aW5hdGlvbik7XG4gICAgICAgICAgICB2YXIgaW1wb3J0TWFwQ2h1bmtzID0gcmVuZGVyU3RhdGUuaW1wb3J0TWFwQ2h1bmtzO1xuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgaSRqc2NvbXAkMCA9IDA7XG4gICAgICAgICAgICAgIGkkanNjb21wJDAgPCBpbXBvcnRNYXBDaHVua3MubGVuZ3RoO1xuICAgICAgICAgICAgICBpJGpzY29tcCQwKytcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgaW1wb3J0TWFwQ2h1bmtzW2kkanNjb21wJDBdKTtcbiAgICAgICAgICAgIGltcG9ydE1hcENodW5rcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgcmVuZGVyU3RhdGUuYm9vdHN0cmFwU2NyaXB0cy5mb3JFYWNoKGZsdXNoUmVzb3VyY2UsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgIHJlbmRlclN0YXRlLnNjcmlwdHMuZm9yRWFjaChmbHVzaFJlc291cmNlLCBkZXN0aW5hdGlvbik7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5zY3JpcHRzLmNsZWFyKCk7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5idWxrUHJlbG9hZHMuZm9yRWFjaChmbHVzaFJlc291cmNlLCBkZXN0aW5hdGlvbik7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5idWxrUHJlbG9hZHMuY2xlYXIoKTtcbiAgICAgICAgICAgIHZhciBob2lzdGFibGVDaHVua3MgPSByZW5kZXJTdGF0ZS5ob2lzdGFibGVDaHVua3M7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICBpJGpzY29tcCQwID0gMDtcbiAgICAgICAgICAgICAgaSRqc2NvbXAkMCA8IGhvaXN0YWJsZUNodW5rcy5sZW5ndGg7XG4gICAgICAgICAgICAgIGkkanNjb21wJDArK1xuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBob2lzdGFibGVDaHVua3NbaSRqc2NvbXAkMF0pO1xuICAgICAgICAgICAgaG9pc3RhYmxlQ2h1bmtzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICBodG1sQ2h1bmtzICYmXG4gICAgICAgICAgICAgIG51bGwgPT09IGhlYWRDaHVua3MgJiZcbiAgICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgZW5kQ2h1bmtGb3JUYWcoXCJoZWFkXCIpKTtcbiAgICAgICAgICAgIGZsdXNoU2VnbWVudChyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgY29tcGxldGVkUm9vdFNlZ21lbnQsIG51bGwpO1xuICAgICAgICAgICAgcmVxdWVzdC5jb21wbGV0ZWRSb290U2VnbWVudCA9IG51bGw7XG4gICAgICAgICAgICB3cml0ZUJvb3RzdHJhcChkZXN0aW5hdGlvbiwgcmVxdWVzdC5yZW5kZXJTdGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZW5kZXJTdGF0ZSRqc2NvbXAkMCA9IHJlcXVlc3QucmVuZGVyU3RhdGU7XG4gICAgICAgICAgY29tcGxldGVkUm9vdFNlZ21lbnQgPSAwO1xuICAgICAgICAgIHZhciB2aWV3cG9ydENodW5rcyRqc2NvbXAkMCA9IHJlbmRlclN0YXRlJGpzY29tcCQwLnZpZXdwb3J0Q2h1bmtzO1xuICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICBjb21wbGV0ZWRSb290U2VnbWVudCA9IDA7XG4gICAgICAgICAgICBjb21wbGV0ZWRSb290U2VnbWVudCA8IHZpZXdwb3J0Q2h1bmtzJGpzY29tcCQwLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbXBsZXRlZFJvb3RTZWdtZW50KytcbiAgICAgICAgICApXG4gICAgICAgICAgICB3cml0ZUNodW5rKFxuICAgICAgICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgICAgICAgICAgdmlld3BvcnRDaHVua3MkanNjb21wJDBbY29tcGxldGVkUm9vdFNlZ21lbnRdXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHZpZXdwb3J0Q2h1bmtzJGpzY29tcCQwLmxlbmd0aCA9IDA7XG4gICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDAucHJlY29ubmVjdHMuZm9yRWFjaChmbHVzaFJlc291cmNlLCBkZXN0aW5hdGlvbik7XG4gICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDAucHJlY29ubmVjdHMuY2xlYXIoKTtcbiAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMC5mb250UHJlbG9hZHMuZm9yRWFjaChmbHVzaFJlc291cmNlLCBkZXN0aW5hdGlvbik7XG4gICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDAuZm9udFByZWxvYWRzLmNsZWFyKCk7XG4gICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDAuaGlnaEltYWdlUHJlbG9hZHMuZm9yRWFjaChcbiAgICAgICAgICAgIGZsdXNoUmVzb3VyY2UsXG4gICAgICAgICAgICBkZXN0aW5hdGlvblxuICAgICAgICAgICk7XG4gICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDAuaGlnaEltYWdlUHJlbG9hZHMuY2xlYXIoKTtcbiAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMC5zdHlsZXMuZm9yRWFjaChwcmVsb2FkTGF0ZVN0eWxlcywgZGVzdGluYXRpb24pO1xuICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQwLnNjcmlwdHMuZm9yRWFjaChmbHVzaFJlc291cmNlLCBkZXN0aW5hdGlvbik7XG4gICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDAuc2NyaXB0cy5jbGVhcigpO1xuICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQwLmJ1bGtQcmVsb2Fkcy5mb3JFYWNoKGZsdXNoUmVzb3VyY2UsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMC5idWxrUHJlbG9hZHMuY2xlYXIoKTtcbiAgICAgICAgICB2YXIgaG9pc3RhYmxlQ2h1bmtzJGpzY29tcCQwID0gcmVuZGVyU3RhdGUkanNjb21wJDAuaG9pc3RhYmxlQ2h1bmtzO1xuICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICBjb21wbGV0ZWRSb290U2VnbWVudCA9IDA7XG4gICAgICAgICAgICBjb21wbGV0ZWRSb290U2VnbWVudCA8IGhvaXN0YWJsZUNodW5rcyRqc2NvbXAkMC5sZW5ndGg7XG4gICAgICAgICAgICBjb21wbGV0ZWRSb290U2VnbWVudCsrXG4gICAgICAgICAgKVxuICAgICAgICAgICAgd3JpdGVDaHVuayhcbiAgICAgICAgICAgICAgZGVzdGluYXRpb24sXG4gICAgICAgICAgICAgIGhvaXN0YWJsZUNodW5rcyRqc2NvbXAkMFtjb21wbGV0ZWRSb290U2VnbWVudF1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgaG9pc3RhYmxlQ2h1bmtzJGpzY29tcCQwLmxlbmd0aCA9IDA7XG4gICAgICAgICAgdmFyIGNsaWVudFJlbmRlcmVkQm91bmRhcmllcyA9IHJlcXVlc3QuY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBib3VuZGFyeSA9IGNsaWVudFJlbmRlcmVkQm91bmRhcmllc1tpXTtcbiAgICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQwID0gZGVzdGluYXRpb247XG4gICAgICAgICAgICB2YXIgcmVzdW1hYmxlU3RhdGUgPSByZXF1ZXN0LnJlc3VtYWJsZVN0YXRlLFxuICAgICAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMSA9IHJlcXVlc3QucmVuZGVyU3RhdGUsXG4gICAgICAgICAgICAgIGlkID0gYm91bmRhcnkucm9vdFNlZ21lbnRJRCxcbiAgICAgICAgICAgICAgZXJyb3JEaWdlc3QgPSBib3VuZGFyeS5lcnJvckRpZ2VzdCxcbiAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gYm91bmRhcnkuZXJyb3JNZXNzYWdlLFxuICAgICAgICAgICAgICBlcnJvclN0YWNrID0gYm91bmRhcnkuZXJyb3JTdGFjayxcbiAgICAgICAgICAgICAgZXJyb3JDb21wb25lbnRTdGFjayA9IGJvdW5kYXJ5LmVycm9yQ29tcG9uZW50U3RhY2s7XG4gICAgICAgICAgICB3cml0ZUNodW5rKFxuICAgICAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDEuc3RhcnRJbmxpbmVTY3JpcHRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICAocmVzdW1hYmxlU3RhdGUuaW5zdHJ1Y3Rpb25zICYgU2VudENsaWVudFJlbmRlckZ1bmN0aW9uKSA9PT1cbiAgICAgICAgICAgIE5vdGhpbmdTZW50XG4gICAgICAgICAgICAgID8gKChyZXN1bWFibGVTdGF0ZS5pbnN0cnVjdGlvbnMgfD0gU2VudENsaWVudFJlbmRlckZ1bmN0aW9uKSxcbiAgICAgICAgICAgICAgICB3cml0ZUNodW5rKHJlbmRlclN0YXRlJGpzY29tcCQwLCBjbGllbnRSZW5kZXJTY3JpcHQxRnVsbCkpXG4gICAgICAgICAgICAgIDogd3JpdGVDaHVuayhyZW5kZXJTdGF0ZSRqc2NvbXAkMCwgY2xpZW50UmVuZGVyU2NyaXB0MVBhcnRpYWwpO1xuICAgICAgICAgICAgd3JpdGVDaHVuayhcbiAgICAgICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDAsXG4gICAgICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQxLmJvdW5kYXJ5UHJlZml4XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgd3JpdGVDaHVuayhyZW5kZXJTdGF0ZSRqc2NvbXAkMCwgc3RyaW5nVG9DaHVuayhpZC50b1N0cmluZygxNikpKTtcbiAgICAgICAgICAgIHdyaXRlQ2h1bmsocmVuZGVyU3RhdGUkanNjb21wJDAsIGNsaWVudFJlbmRlclNjcmlwdDFBKTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgZXJyb3JEaWdlc3QgfHxcbiAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlIHx8XG4gICAgICAgICAgICAgIGVycm9yU3RhY2sgfHxcbiAgICAgICAgICAgICAgZXJyb3JDb21wb25lbnRTdGFja1xuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB3cml0ZUNodW5rKFxuICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQwLFxuICAgICAgICAgICAgICAgIGNsaWVudFJlbmRlckVycm9yU2NyaXB0QXJnSW50ZXJzdGl0aWFsXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgd3JpdGVDaHVuayhcbiAgICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgc3RyaW5nVG9DaHVuayhcbiAgICAgICAgICAgICAgICAgICAgZXNjYXBlSlNTdHJpbmdzRm9ySW5zdHJ1Y3Rpb25TY3JpcHRzKGVycm9yRGlnZXN0IHx8IFwiXCIpXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChlcnJvck1lc3NhZ2UgfHwgZXJyb3JTdGFjayB8fCBlcnJvckNvbXBvbmVudFN0YWNrKVxuICAgICAgICAgICAgICB3cml0ZUNodW5rKFxuICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQwLFxuICAgICAgICAgICAgICAgIGNsaWVudFJlbmRlckVycm9yU2NyaXB0QXJnSW50ZXJzdGl0aWFsXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgd3JpdGVDaHVuayhcbiAgICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgc3RyaW5nVG9DaHVuayhcbiAgICAgICAgICAgICAgICAgICAgZXNjYXBlSlNTdHJpbmdzRm9ySW5zdHJ1Y3Rpb25TY3JpcHRzKGVycm9yTWVzc2FnZSB8fCBcIlwiKVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoZXJyb3JTdGFjayB8fCBlcnJvckNvbXBvbmVudFN0YWNrKVxuICAgICAgICAgICAgICB3cml0ZUNodW5rKFxuICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQwLFxuICAgICAgICAgICAgICAgIGNsaWVudFJlbmRlckVycm9yU2NyaXB0QXJnSW50ZXJzdGl0aWFsXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgd3JpdGVDaHVuayhcbiAgICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgc3RyaW5nVG9DaHVuayhcbiAgICAgICAgICAgICAgICAgICAgZXNjYXBlSlNTdHJpbmdzRm9ySW5zdHJ1Y3Rpb25TY3JpcHRzKGVycm9yU3RhY2sgfHwgXCJcIilcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgZXJyb3JDb21wb25lbnRTdGFjayAmJlxuICAgICAgICAgICAgICAod3JpdGVDaHVuayhcbiAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICBjbGllbnRSZW5kZXJFcnJvclNjcmlwdEFyZ0ludGVyc3RpdGlhbFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICB3cml0ZUNodW5rKFxuICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQwLFxuICAgICAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsoXG4gICAgICAgICAgICAgICAgICBlc2NhcGVKU1N0cmluZ3NGb3JJbnN0cnVjdGlvblNjcmlwdHMoZXJyb3JDb21wb25lbnRTdGFjaylcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IHdyaXRlQ2h1bmtBbmRSZXR1cm4oXG4gICAgICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQwLFxuICAgICAgICAgICAgICBjbGllbnRSZW5kZXJTY3JpcHRFbmRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoIUpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCkge1xuICAgICAgICAgICAgICByZXF1ZXN0LmRlc3RpbmF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICBjbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMuc3BsaWNlKDAsIGkpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNsaWVudFJlbmRlcmVkQm91bmRhcmllcy5zcGxpY2UoMCwgaSk7XG4gICAgICAgICAgdmFyIGNvbXBsZXRlZEJvdW5kYXJpZXMgPSByZXF1ZXN0LmNvbXBsZXRlZEJvdW5kYXJpZXM7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbXBsZXRlZEJvdW5kYXJpZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICFmbHVzaENvbXBsZXRlZEJvdW5kYXJ5KFxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24sXG4gICAgICAgICAgICAgICAgY29tcGxldGVkQm91bmRhcmllc1tpXVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgcmVxdWVzdC5kZXN0aW5hdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgY29tcGxldGVkQm91bmRhcmllcy5zcGxpY2UoMCwgaSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjb21wbGV0ZWRCb3VuZGFyaWVzLnNwbGljZSgwLCBpKTtcbiAgICAgICAgICBjb21wbGV0ZVdyaXRpbmcoZGVzdGluYXRpb24pO1xuICAgICAgICAgIGN1cnJlbnRWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoMjA0OCk7XG4gICAgICAgICAgd3JpdHRlbkJ5dGVzID0gMDtcbiAgICAgICAgICB2YXIgcGFydGlhbEJvdW5kYXJpZXMgPSByZXF1ZXN0LnBhcnRpYWxCb3VuZGFyaWVzO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXJ0aWFsQm91bmRhcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYToge1xuICAgICAgICAgICAgICBjbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMgPSByZXF1ZXN0O1xuICAgICAgICAgICAgICBib3VuZGFyeSA9IGRlc3RpbmF0aW9uO1xuICAgICAgICAgICAgICB2YXIgYm91bmRhcnkkanNjb21wJDAgPSBwYXJ0aWFsQm91bmRhcmllc1tpXSxcbiAgICAgICAgICAgICAgICBjb21wbGV0ZWRTZWdtZW50cyA9IGJvdW5kYXJ5JGpzY29tcCQwLmNvbXBsZXRlZFNlZ21lbnRzO1xuICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IDA7XG4gICAgICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0IDwgY29tcGxldGVkU2VnbWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCsrXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAhZmx1c2hQYXJ0aWFsbHlDb21wbGV0ZWRTZWdtZW50KFxuICAgICAgICAgICAgICAgICAgICBjbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMsXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kYXJ5LFxuICAgICAgICAgICAgICAgICAgICBib3VuZGFyeSRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGVkU2VnbWVudHNbSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0XVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0Kys7XG4gICAgICAgICAgICAgICAgICBjb21wbGV0ZWRTZWdtZW50cy5zcGxpY2UoMCwgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDAgPSAhMTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb21wbGV0ZWRTZWdtZW50cy5zcGxpY2UoMCwgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0KTtcbiAgICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwID0gd3JpdGVIb2lzdGFibGVzRm9yQm91bmRhcnkoXG4gICAgICAgICAgICAgICAgYm91bmRhcnksXG4gICAgICAgICAgICAgICAgYm91bmRhcnkkanNjb21wJDAuY29udGVudFN0YXRlLFxuICAgICAgICAgICAgICAgIGNsaWVudFJlbmRlcmVkQm91bmRhcmllcy5yZW5kZXJTdGF0ZVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDApIHtcbiAgICAgICAgICAgICAgcmVxdWVzdC5kZXN0aW5hdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgcGFydGlhbEJvdW5kYXJpZXMuc3BsaWNlKDAsIGkpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcnRpYWxCb3VuZGFyaWVzLnNwbGljZSgwLCBpKTtcbiAgICAgICAgICB2YXIgbGFyZ2VCb3VuZGFyaWVzID0gcmVxdWVzdC5jb21wbGV0ZWRCb3VuZGFyaWVzO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsYXJnZUJvdW5kYXJpZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICFmbHVzaENvbXBsZXRlZEJvdW5kYXJ5KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBsYXJnZUJvdW5kYXJpZXNbaV0pXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgcmVxdWVzdC5kZXN0aW5hdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgbGFyZ2VCb3VuZGFyaWVzLnNwbGljZSgwLCBpKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGxhcmdlQm91bmRhcmllcy5zcGxpY2UoMCwgaSk7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIDAgPT09IHJlcXVlc3QuYWxsUGVuZGluZ1Rhc2tzICYmXG4gICAgICAgIDAgPT09IHJlcXVlc3QucGluZ2VkVGFza3MubGVuZ3RoICYmXG4gICAgICAgIDAgPT09IHJlcXVlc3QuY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzLmxlbmd0aCAmJlxuICAgICAgICAwID09PSByZXF1ZXN0LmNvbXBsZXRlZEJvdW5kYXJpZXMubGVuZ3RoXG4gICAgICAgICAgPyAoKHJlcXVlc3QuZmx1c2hTY2hlZHVsZWQgPSAhMSksXG4gICAgICAgICAgICAoaSA9IHJlcXVlc3QucmVzdW1hYmxlU3RhdGUpLFxuICAgICAgICAgICAgaS5oYXNCb2R5ICYmIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGVuZENodW5rRm9yVGFnKFwiYm9keVwiKSksXG4gICAgICAgICAgICBpLmhhc0h0bWwgJiYgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgZW5kQ2h1bmtGb3JUYWcoXCJodG1sXCIpKSxcbiAgICAgICAgICAgIGNvbXBsZXRlV3JpdGluZyhkZXN0aW5hdGlvbiksXG4gICAgICAgICAgICAwICE9PSByZXF1ZXN0LmFib3J0YWJsZVRhc2tzLnNpemUgJiZcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIlRoZXJlIHdhcyBzdGlsbCBhYm9ydGFibGUgdGFzayBhdCB0aGUgcm9vdCB3aGVuIHdlIGNsb3NlZC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKHJlcXVlc3Quc3RhdHVzID0gQ0xPU0VEKSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLmNsb3NlKCksXG4gICAgICAgICAgICAocmVxdWVzdC5kZXN0aW5hdGlvbiA9IG51bGwpKVxuICAgICAgICAgIDogY29tcGxldGVXcml0aW5nKGRlc3RpbmF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc3RhcnRXb3JrKHJlcXVlc3QpIHtcbiAgICAgIHJlcXVlc3QuZmx1c2hTY2hlZHVsZWQgPSBudWxsICE9PSByZXF1ZXN0LmRlc3RpbmF0aW9uO1xuICAgICAgc2NoZWR1bGVNaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcGVyZm9ybVdvcmsocmVxdWVzdCk7XG4gICAgICB9KTtcbiAgICAgIHNjaGVkdWxlV29yayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIDEwID09PSByZXF1ZXN0LnN0YXR1cyAmJiAocmVxdWVzdC5zdGF0dXMgPSAxMSk7XG4gICAgICAgIG51bGwgPT09IHJlcXVlc3QudHJhY2tlZFBvc3Rwb25lcyAmJlxuICAgICAgICAgIHNhZmVseUVtaXRFYXJseVByZWxvYWRzKHJlcXVlc3QsIDAgPT09IHJlcXVlc3QucGVuZGluZ1Jvb3RUYXNrcyk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5xdWV1ZUZsdXNoKHJlcXVlc3QpIHtcbiAgICAgICExID09PSByZXF1ZXN0LmZsdXNoU2NoZWR1bGVkICYmXG4gICAgICAgIDAgPT09IHJlcXVlc3QucGluZ2VkVGFza3MubGVuZ3RoICYmXG4gICAgICAgIG51bGwgIT09IHJlcXVlc3QuZGVzdGluYXRpb24gJiZcbiAgICAgICAgKChyZXF1ZXN0LmZsdXNoU2NoZWR1bGVkID0gITApLFxuICAgICAgICBzY2hlZHVsZVdvcmsoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHJlcXVlc3QuZGVzdGluYXRpb247XG4gICAgICAgICAgZGVzdGluYXRpb25cbiAgICAgICAgICAgID8gZmx1c2hDb21wbGV0ZWRRdWV1ZXMocmVxdWVzdCwgZGVzdGluYXRpb24pXG4gICAgICAgICAgICA6IChyZXF1ZXN0LmZsdXNoU2NoZWR1bGVkID0gITEpO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0YXJ0Rmxvd2luZyhyZXF1ZXN0LCBkZXN0aW5hdGlvbikge1xuICAgICAgaWYgKDEzID09PSByZXF1ZXN0LnN0YXR1cylcbiAgICAgICAgKHJlcXVlc3Quc3RhdHVzID0gQ0xPU0VEKSxcbiAgICAgICAgICBjbG9zZVdpdGhFcnJvcihkZXN0aW5hdGlvbiwgcmVxdWVzdC5mYXRhbEVycm9yKTtcbiAgICAgIGVsc2UgaWYgKHJlcXVlc3Quc3RhdHVzICE9PSBDTE9TRUQgJiYgbnVsbCA9PT0gcmVxdWVzdC5kZXN0aW5hdGlvbikge1xuICAgICAgICByZXF1ZXN0LmRlc3RpbmF0aW9uID0gZGVzdGluYXRpb247XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZmx1c2hDb21wbGV0ZWRRdWV1ZXMocmVxdWVzdCwgZGVzdGluYXRpb24pO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGxvZ1JlY292ZXJhYmxlRXJyb3IocmVxdWVzdCwgZXJyb3IsIHt9KSwgZmF0YWxFcnJvcihyZXF1ZXN0LCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYWJvcnQocmVxdWVzdCwgcmVhc29uKSB7XG4gICAgICBpZiAoMTEgPT09IHJlcXVlc3Quc3RhdHVzIHx8IDEwID09PSByZXF1ZXN0LnN0YXR1cykgcmVxdWVzdC5zdGF0dXMgPSAxMjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBhYm9ydGFibGVUYXNrcyA9IHJlcXVlc3QuYWJvcnRhYmxlVGFza3M7XG4gICAgICAgIGlmICgwIDwgYWJvcnRhYmxlVGFza3Muc2l6ZSkge1xuICAgICAgICAgIHZhciBlcnJvciA9XG4gICAgICAgICAgICB2b2lkIDAgPT09IHJlYXNvblxuICAgICAgICAgICAgICA/IEVycm9yKFwiVGhlIHJlbmRlciB3YXMgYWJvcnRlZCBieSB0aGUgc2VydmVyIHdpdGhvdXQgYSByZWFzb24uXCIpXG4gICAgICAgICAgICAgIDogXCJvYmplY3RcIiA9PT0gdHlwZW9mIHJlYXNvbiAmJlxuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gcmVhc29uICYmXG4gICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZWFzb24udGhlblxuICAgICAgICAgICAgICAgID8gRXJyb3IoXCJUaGUgcmVuZGVyIHdhcyBhYm9ydGVkIGJ5IHRoZSBzZXJ2ZXIgd2l0aCBhIHByb21pc2UuXCIpXG4gICAgICAgICAgICAgICAgOiByZWFzb247XG4gICAgICAgICAgcmVxdWVzdC5mYXRhbEVycm9yID0gZXJyb3I7XG4gICAgICAgICAgYWJvcnRhYmxlVGFza3MuZm9yRWFjaChmdW5jdGlvbiAodGFzaykge1xuICAgICAgICAgICAgcmV0dXJuIGFib3J0VGFzayh0YXNrLCByZXF1ZXN0LCBlcnJvcik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYWJvcnRhYmxlVGFza3MuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICBudWxsICE9PSByZXF1ZXN0LmRlc3RpbmF0aW9uICYmXG4gICAgICAgICAgZmx1c2hDb21wbGV0ZWRRdWV1ZXMocmVxdWVzdCwgcmVxdWVzdC5kZXN0aW5hdGlvbik7XG4gICAgICB9IGNhdGNoIChlcnJvciQ0KSB7XG4gICAgICAgIGxvZ1JlY292ZXJhYmxlRXJyb3IocmVxdWVzdCwgZXJyb3IkNCwge30pLCBmYXRhbEVycm9yKHJlcXVlc3QsIGVycm9yJDQpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBlbnN1cmVDb3JyZWN0SXNvbW9ycGhpY1JlYWN0VmVyc2lvbigpIHtcbiAgICAgIHZhciBpc29tb3JwaGljUmVhY3RQYWNrYWdlVmVyc2lvbiA9IFJlYWN0LnZlcnNpb247XG4gICAgICBpZiAoXCIxOS4wLjAtcmMtNjVlMDZjYjctMjAyNDEyMThcIiAhPT0gaXNvbW9ycGhpY1JlYWN0UGFja2FnZVZlcnNpb24pXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICdJbmNvbXBhdGlibGUgUmVhY3QgdmVyc2lvbnM6IFRoZSBcInJlYWN0XCIgYW5kIFwicmVhY3QtZG9tXCIgcGFja2FnZXMgbXVzdCBoYXZlIHRoZSBleGFjdCBzYW1lIHZlcnNpb24uIEluc3RlYWQgZ290OlxcbiAgLSByZWFjdDogICAgICAnICtcbiAgICAgICAgICAgIChpc29tb3JwaGljUmVhY3RQYWNrYWdlVmVyc2lvbiArXG4gICAgICAgICAgICAgIFwiXFxuICAtIHJlYWN0LWRvbTogIDE5LjAuMC1yYy02NWUwNmNiNy0yMDI0MTIxOFxcbkxlYXJuIG1vcmU6IGh0dHBzOi8vcmVhY3QuZGV2L3dhcm5pbmdzL3ZlcnNpb24tbWlzbWF0Y2hcIilcbiAgICAgICAgKTtcbiAgICB9XG4gICAgdmFyIFJlYWN0ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdFwiKSxcbiAgICAgIFJlYWN0RE9NID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdC1kb21cIiksXG4gICAgICBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QudHJhbnNpdGlvbmFsLmVsZW1lbnRcIiksXG4gICAgICBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wb3J0YWxcIiksXG4gICAgICBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpLFxuICAgICAgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKSxcbiAgICAgIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvZmlsZXJcIiksXG4gICAgICBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnByb3ZpZGVyXCIpLFxuICAgICAgUkVBQ1RfQ09OU1VNRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb25zdW1lclwiKSxcbiAgICAgIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpLFxuICAgICAgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKSxcbiAgICAgIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIiksXG4gICAgICBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VfbGlzdFwiKSxcbiAgICAgIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpLFxuICAgICAgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIiksXG4gICAgICBSRUFDVF9TQ09QRV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnNjb3BlXCIpLFxuICAgICAgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZGVidWdfdHJhY2VfbW9kZVwiKSxcbiAgICAgIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0Lm9mZnNjcmVlblwiKSxcbiAgICAgIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5sZWdhY3lfaGlkZGVuXCIpLFxuICAgICAgUkVBQ1RfTUVNT19DQUNIRV9TRU5USU5FTCA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vX2NhY2hlX3NlbnRpbmVsXCIpLFxuICAgICAgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yLFxuICAgICAgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5LFxuICAgICAganN4UHJvcHNQYXJlbnRzID0gbmV3IFdlYWtNYXAoKSxcbiAgICAgIGpzeENoaWxkcmVuUGFyZW50cyA9IG5ldyBXZWFrTWFwKCksXG4gICAgICBDTElFTlRfUkVGRVJFTkNFX1RBRyA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpLFxuICAgICAgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpLFxuICAgICAgdGFza1F1ZXVlID0gW107XG4gICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdGFzayA9IHRhc2tRdWV1ZS5zaGlmdCgpO1xuICAgICAgdGFzayAmJiB0YXNrKCk7XG4gICAgfTtcbiAgICB2YXIgTG9jYWxQcm9taXNlID0gUHJvbWlzZSxcbiAgICAgIHNjaGVkdWxlTWljcm90YXNrID1cbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcXVldWVNaWNyb3Rhc2tcbiAgICAgICAgICA/IHF1ZXVlTWljcm90YXNrXG4gICAgICAgICAgOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgTG9jYWxQcm9taXNlLnJlc29sdmUobnVsbClcbiAgICAgICAgICAgICAgICAudGhlbihjYWxsYmFjaylcbiAgICAgICAgICAgICAgICAuY2F0Y2goaGFuZGxlRXJyb3JJbk5leHRUaWNrKTtcbiAgICAgICAgICAgIH0sXG4gICAgICBjdXJyZW50VmlldyA9IG51bGwsXG4gICAgICB3cml0dGVuQnl0ZXMgPSAwLFxuICAgICAgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKSxcbiAgICAgIGFzc2lnbiA9IE9iamVjdC5hc3NpZ24sXG4gICAgICBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG4gICAgICBWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWCA9IFJlZ0V4cChcbiAgICAgICAgXCJeWzpBLVpfYS16XFxcXHUwMEMwLVxcXFx1MDBENlxcXFx1MDBEOC1cXFxcdTAwRjZcXFxcdTAwRjgtXFxcXHUwMkZGXFxcXHUwMzcwLVxcXFx1MDM3RFxcXFx1MDM3Ri1cXFxcdTFGRkZcXFxcdTIwMEMtXFxcXHUyMDBEXFxcXHUyMDcwLVxcXFx1MjE4RlxcXFx1MkMwMC1cXFxcdTJGRUZcXFxcdTMwMDEtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRkRdWzpBLVpfYS16XFxcXHUwMEMwLVxcXFx1MDBENlxcXFx1MDBEOC1cXFxcdTAwRjZcXFxcdTAwRjgtXFxcXHUwMkZGXFxcXHUwMzcwLVxcXFx1MDM3RFxcXFx1MDM3Ri1cXFxcdTFGRkZcXFxcdTIwMEMtXFxcXHUyMDBEXFxcXHUyMDcwLVxcXFx1MjE4RlxcXFx1MkMwMC1cXFxcdTJGRUZcXFxcdTMwMDEtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRkRcXFxcLS4wLTlcXFxcdTAwQjdcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUyMDNGLVxcXFx1MjA0MF0qJFwiXG4gICAgICApLFxuICAgICAgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9LFxuICAgICAgdmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlID0ge30sXG4gICAgICB1bml0bGVzc051bWJlcnMgPSBuZXcgU2V0KFxuICAgICAgICBcImFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50IGFzcGVjdFJhdGlvIGJvcmRlckltYWdlT3V0c2V0IGJvcmRlckltYWdlU2xpY2UgYm9yZGVySW1hZ2VXaWR0aCBib3hGbGV4IGJveEZsZXhHcm91cCBib3hPcmRpbmFsR3JvdXAgY29sdW1uQ291bnQgY29sdW1ucyBmbGV4IGZsZXhHcm93IGZsZXhQb3NpdGl2ZSBmbGV4U2hyaW5rIGZsZXhOZWdhdGl2ZSBmbGV4T3JkZXIgZ3JpZEFyZWEgZ3JpZFJvdyBncmlkUm93RW5kIGdyaWRSb3dTcGFuIGdyaWRSb3dTdGFydCBncmlkQ29sdW1uIGdyaWRDb2x1bW5FbmQgZ3JpZENvbHVtblNwYW4gZ3JpZENvbHVtblN0YXJ0IGZvbnRXZWlnaHQgbGluZUNsYW1wIGxpbmVIZWlnaHQgb3BhY2l0eSBvcmRlciBvcnBoYW5zIHNjYWxlIHRhYlNpemUgd2lkb3dzIHpJbmRleCB6b29tIGZpbGxPcGFjaXR5IGZsb29kT3BhY2l0eSBzdG9wT3BhY2l0eSBzdHJva2VEYXNoYXJyYXkgc3Ryb2tlRGFzaG9mZnNldCBzdHJva2VNaXRlcmxpbWl0IHN0cm9rZU9wYWNpdHkgc3Ryb2tlV2lkdGggTW96QW5pbWF0aW9uSXRlcmF0aW9uQ291bnQgTW96Qm94RmxleCBNb3pCb3hGbGV4R3JvdXAgTW96TGluZUNsYW1wIG1zQW5pbWF0aW9uSXRlcmF0aW9uQ291bnQgbXNGbGV4IG1zWm9vbSBtc0ZsZXhHcm93IG1zRmxleE5lZ2F0aXZlIG1zRmxleE9yZGVyIG1zRmxleFBvc2l0aXZlIG1zRmxleFNocmluayBtc0dyaWRDb2x1bW4gbXNHcmlkQ29sdW1uU3BhbiBtc0dyaWRSb3cgbXNHcmlkUm93U3BhbiBXZWJraXRBbmltYXRpb25JdGVyYXRpb25Db3VudCBXZWJraXRCb3hGbGV4IFdlYktpdEJveEZsZXhHcm91cCBXZWJraXRCb3hPcmRpbmFsR3JvdXAgV2Via2l0Q29sdW1uQ291bnQgV2Via2l0Q29sdW1ucyBXZWJraXRGbGV4IFdlYmtpdEZsZXhHcm93IFdlYmtpdEZsZXhQb3NpdGl2ZSBXZWJraXRGbGV4U2hyaW5rIFdlYmtpdExpbmVDbGFtcFwiLnNwbGl0KFxuICAgICAgICAgIFwiIFwiXG4gICAgICAgIClcbiAgICAgICksXG4gICAgICBhbGlhc2VzID0gbmV3IE1hcChbXG4gICAgICAgIFtcImFjY2VwdENoYXJzZXRcIiwgXCJhY2NlcHQtY2hhcnNldFwiXSxcbiAgICAgICAgW1wiaHRtbEZvclwiLCBcImZvclwiXSxcbiAgICAgICAgW1wiaHR0cEVxdWl2XCIsIFwiaHR0cC1lcXVpdlwiXSxcbiAgICAgICAgW1wiY3Jvc3NPcmlnaW5cIiwgXCJjcm9zc29yaWdpblwiXSxcbiAgICAgICAgW1wiYWNjZW50SGVpZ2h0XCIsIFwiYWNjZW50LWhlaWdodFwiXSxcbiAgICAgICAgW1wiYWxpZ25tZW50QmFzZWxpbmVcIiwgXCJhbGlnbm1lbnQtYmFzZWxpbmVcIl0sXG4gICAgICAgIFtcImFyYWJpY0Zvcm1cIiwgXCJhcmFiaWMtZm9ybVwiXSxcbiAgICAgICAgW1wiYmFzZWxpbmVTaGlmdFwiLCBcImJhc2VsaW5lLXNoaWZ0XCJdLFxuICAgICAgICBbXCJjYXBIZWlnaHRcIiwgXCJjYXAtaGVpZ2h0XCJdLFxuICAgICAgICBbXCJjbGlwUGF0aFwiLCBcImNsaXAtcGF0aFwiXSxcbiAgICAgICAgW1wiY2xpcFJ1bGVcIiwgXCJjbGlwLXJ1bGVcIl0sXG4gICAgICAgIFtcImNvbG9ySW50ZXJwb2xhdGlvblwiLCBcImNvbG9yLWludGVycG9sYXRpb25cIl0sXG4gICAgICAgIFtcImNvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnNcIiwgXCJjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnNcIl0sXG4gICAgICAgIFtcImNvbG9yUHJvZmlsZVwiLCBcImNvbG9yLXByb2ZpbGVcIl0sXG4gICAgICAgIFtcImNvbG9yUmVuZGVyaW5nXCIsIFwiY29sb3ItcmVuZGVyaW5nXCJdLFxuICAgICAgICBbXCJkb21pbmFudEJhc2VsaW5lXCIsIFwiZG9taW5hbnQtYmFzZWxpbmVcIl0sXG4gICAgICAgIFtcImVuYWJsZUJhY2tncm91bmRcIiwgXCJlbmFibGUtYmFja2dyb3VuZFwiXSxcbiAgICAgICAgW1wiZmlsbE9wYWNpdHlcIiwgXCJmaWxsLW9wYWNpdHlcIl0sXG4gICAgICAgIFtcImZpbGxSdWxlXCIsIFwiZmlsbC1ydWxlXCJdLFxuICAgICAgICBbXCJmbG9vZENvbG9yXCIsIFwiZmxvb2QtY29sb3JcIl0sXG4gICAgICAgIFtcImZsb29kT3BhY2l0eVwiLCBcImZsb29kLW9wYWNpdHlcIl0sXG4gICAgICAgIFtcImZvbnRGYW1pbHlcIiwgXCJmb250LWZhbWlseVwiXSxcbiAgICAgICAgW1wiZm9udFNpemVcIiwgXCJmb250LXNpemVcIl0sXG4gICAgICAgIFtcImZvbnRTaXplQWRqdXN0XCIsIFwiZm9udC1zaXplLWFkanVzdFwiXSxcbiAgICAgICAgW1wiZm9udFN0cmV0Y2hcIiwgXCJmb250LXN0cmV0Y2hcIl0sXG4gICAgICAgIFtcImZvbnRTdHlsZVwiLCBcImZvbnQtc3R5bGVcIl0sXG4gICAgICAgIFtcImZvbnRWYXJpYW50XCIsIFwiZm9udC12YXJpYW50XCJdLFxuICAgICAgICBbXCJmb250V2VpZ2h0XCIsIFwiZm9udC13ZWlnaHRcIl0sXG4gICAgICAgIFtcImdseXBoTmFtZVwiLCBcImdseXBoLW5hbWVcIl0sXG4gICAgICAgIFtcImdseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsXCIsIFwiZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbFwiXSxcbiAgICAgICAgW1wiZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsXCIsIFwiZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWxcIl0sXG4gICAgICAgIFtcImhvcml6QWR2WFwiLCBcImhvcml6LWFkdi14XCJdLFxuICAgICAgICBbXCJob3Jpek9yaWdpblhcIiwgXCJob3Jpei1vcmlnaW4teFwiXSxcbiAgICAgICAgW1wiaW1hZ2VSZW5kZXJpbmdcIiwgXCJpbWFnZS1yZW5kZXJpbmdcIl0sXG4gICAgICAgIFtcImxldHRlclNwYWNpbmdcIiwgXCJsZXR0ZXItc3BhY2luZ1wiXSxcbiAgICAgICAgW1wibGlnaHRpbmdDb2xvclwiLCBcImxpZ2h0aW5nLWNvbG9yXCJdLFxuICAgICAgICBbXCJtYXJrZXJFbmRcIiwgXCJtYXJrZXItZW5kXCJdLFxuICAgICAgICBbXCJtYXJrZXJNaWRcIiwgXCJtYXJrZXItbWlkXCJdLFxuICAgICAgICBbXCJtYXJrZXJTdGFydFwiLCBcIm1hcmtlci1zdGFydFwiXSxcbiAgICAgICAgW1wib3ZlcmxpbmVQb3NpdGlvblwiLCBcIm92ZXJsaW5lLXBvc2l0aW9uXCJdLFxuICAgICAgICBbXCJvdmVybGluZVRoaWNrbmVzc1wiLCBcIm92ZXJsaW5lLXRoaWNrbmVzc1wiXSxcbiAgICAgICAgW1wicGFpbnRPcmRlclwiLCBcInBhaW50LW9yZGVyXCJdLFxuICAgICAgICBbXCJwYW5vc2UtMVwiLCBcInBhbm9zZS0xXCJdLFxuICAgICAgICBbXCJwb2ludGVyRXZlbnRzXCIsIFwicG9pbnRlci1ldmVudHNcIl0sXG4gICAgICAgIFtcInJlbmRlcmluZ0ludGVudFwiLCBcInJlbmRlcmluZy1pbnRlbnRcIl0sXG4gICAgICAgIFtcInNoYXBlUmVuZGVyaW5nXCIsIFwic2hhcGUtcmVuZGVyaW5nXCJdLFxuICAgICAgICBbXCJzdG9wQ29sb3JcIiwgXCJzdG9wLWNvbG9yXCJdLFxuICAgICAgICBbXCJzdG9wT3BhY2l0eVwiLCBcInN0b3Atb3BhY2l0eVwiXSxcbiAgICAgICAgW1wic3RyaWtldGhyb3VnaFBvc2l0aW9uXCIsIFwic3RyaWtldGhyb3VnaC1wb3NpdGlvblwiXSxcbiAgICAgICAgW1wic3RyaWtldGhyb3VnaFRoaWNrbmVzc1wiLCBcInN0cmlrZXRocm91Z2gtdGhpY2tuZXNzXCJdLFxuICAgICAgICBbXCJzdHJva2VEYXNoYXJyYXlcIiwgXCJzdHJva2UtZGFzaGFycmF5XCJdLFxuICAgICAgICBbXCJzdHJva2VEYXNob2Zmc2V0XCIsIFwic3Ryb2tlLWRhc2hvZmZzZXRcIl0sXG4gICAgICAgIFtcInN0cm9rZUxpbmVjYXBcIiwgXCJzdHJva2UtbGluZWNhcFwiXSxcbiAgICAgICAgW1wic3Ryb2tlTGluZWpvaW5cIiwgXCJzdHJva2UtbGluZWpvaW5cIl0sXG4gICAgICAgIFtcInN0cm9rZU1pdGVybGltaXRcIiwgXCJzdHJva2UtbWl0ZXJsaW1pdFwiXSxcbiAgICAgICAgW1wic3Ryb2tlT3BhY2l0eVwiLCBcInN0cm9rZS1vcGFjaXR5XCJdLFxuICAgICAgICBbXCJzdHJva2VXaWR0aFwiLCBcInN0cm9rZS13aWR0aFwiXSxcbiAgICAgICAgW1widGV4dEFuY2hvclwiLCBcInRleHQtYW5jaG9yXCJdLFxuICAgICAgICBbXCJ0ZXh0RGVjb3JhdGlvblwiLCBcInRleHQtZGVjb3JhdGlvblwiXSxcbiAgICAgICAgW1widGV4dFJlbmRlcmluZ1wiLCBcInRleHQtcmVuZGVyaW5nXCJdLFxuICAgICAgICBbXCJ0cmFuc2Zvcm1PcmlnaW5cIiwgXCJ0cmFuc2Zvcm0tb3JpZ2luXCJdLFxuICAgICAgICBbXCJ1bmRlcmxpbmVQb3NpdGlvblwiLCBcInVuZGVybGluZS1wb3NpdGlvblwiXSxcbiAgICAgICAgW1widW5kZXJsaW5lVGhpY2tuZXNzXCIsIFwidW5kZXJsaW5lLXRoaWNrbmVzc1wiXSxcbiAgICAgICAgW1widW5pY29kZUJpZGlcIiwgXCJ1bmljb2RlLWJpZGlcIl0sXG4gICAgICAgIFtcInVuaWNvZGVSYW5nZVwiLCBcInVuaWNvZGUtcmFuZ2VcIl0sXG4gICAgICAgIFtcInVuaXRzUGVyRW1cIiwgXCJ1bml0cy1wZXItZW1cIl0sXG4gICAgICAgIFtcInZBbHBoYWJldGljXCIsIFwidi1hbHBoYWJldGljXCJdLFxuICAgICAgICBbXCJ2SGFuZ2luZ1wiLCBcInYtaGFuZ2luZ1wiXSxcbiAgICAgICAgW1widklkZW9ncmFwaGljXCIsIFwidi1pZGVvZ3JhcGhpY1wiXSxcbiAgICAgICAgW1widk1hdGhlbWF0aWNhbFwiLCBcInYtbWF0aGVtYXRpY2FsXCJdLFxuICAgICAgICBbXCJ2ZWN0b3JFZmZlY3RcIiwgXCJ2ZWN0b3ItZWZmZWN0XCJdLFxuICAgICAgICBbXCJ2ZXJ0QWR2WVwiLCBcInZlcnQtYWR2LXlcIl0sXG4gICAgICAgIFtcInZlcnRPcmlnaW5YXCIsIFwidmVydC1vcmlnaW4teFwiXSxcbiAgICAgICAgW1widmVydE9yaWdpbllcIiwgXCJ2ZXJ0LW9yaWdpbi15XCJdLFxuICAgICAgICBbXCJ3b3JkU3BhY2luZ1wiLCBcIndvcmQtc3BhY2luZ1wiXSxcbiAgICAgICAgW1wid3JpdGluZ01vZGVcIiwgXCJ3cml0aW5nLW1vZGVcIl0sXG4gICAgICAgIFtcInhtbG5zWGxpbmtcIiwgXCJ4bWxuczp4bGlua1wiXSxcbiAgICAgICAgW1wieEhlaWdodFwiLCBcIngtaGVpZ2h0XCJdXG4gICAgICBdKSxcbiAgICAgIGhhc1JlYWRPbmx5VmFsdWUgPSB7XG4gICAgICAgIGJ1dHRvbjogITAsXG4gICAgICAgIGNoZWNrYm94OiAhMCxcbiAgICAgICAgaW1hZ2U6ICEwLFxuICAgICAgICBoaWRkZW46ICEwLFxuICAgICAgICByYWRpbzogITAsXG4gICAgICAgIHJlc2V0OiAhMCxcbiAgICAgICAgc3VibWl0OiAhMFxuICAgICAgfSxcbiAgICAgIGFyaWFQcm9wZXJ0aWVzID0ge1xuICAgICAgICBcImFyaWEtY3VycmVudFwiOiAwLFxuICAgICAgICBcImFyaWEtZGVzY3JpcHRpb25cIjogMCxcbiAgICAgICAgXCJhcmlhLWRldGFpbHNcIjogMCxcbiAgICAgICAgXCJhcmlhLWRpc2FibGVkXCI6IDAsXG4gICAgICAgIFwiYXJpYS1oaWRkZW5cIjogMCxcbiAgICAgICAgXCJhcmlhLWludmFsaWRcIjogMCxcbiAgICAgICAgXCJhcmlhLWtleXNob3J0Y3V0c1wiOiAwLFxuICAgICAgICBcImFyaWEtbGFiZWxcIjogMCxcbiAgICAgICAgXCJhcmlhLXJvbGVkZXNjcmlwdGlvblwiOiAwLFxuICAgICAgICBcImFyaWEtYXV0b2NvbXBsZXRlXCI6IDAsXG4gICAgICAgIFwiYXJpYS1jaGVja2VkXCI6IDAsXG4gICAgICAgIFwiYXJpYS1leHBhbmRlZFwiOiAwLFxuICAgICAgICBcImFyaWEtaGFzcG9wdXBcIjogMCxcbiAgICAgICAgXCJhcmlhLWxldmVsXCI6IDAsXG4gICAgICAgIFwiYXJpYS1tb2RhbFwiOiAwLFxuICAgICAgICBcImFyaWEtbXVsdGlsaW5lXCI6IDAsXG4gICAgICAgIFwiYXJpYS1tdWx0aXNlbGVjdGFibGVcIjogMCxcbiAgICAgICAgXCJhcmlhLW9yaWVudGF0aW9uXCI6IDAsXG4gICAgICAgIFwiYXJpYS1wbGFjZWhvbGRlclwiOiAwLFxuICAgICAgICBcImFyaWEtcHJlc3NlZFwiOiAwLFxuICAgICAgICBcImFyaWEtcmVhZG9ubHlcIjogMCxcbiAgICAgICAgXCJhcmlhLXJlcXVpcmVkXCI6IDAsXG4gICAgICAgIFwiYXJpYS1zZWxlY3RlZFwiOiAwLFxuICAgICAgICBcImFyaWEtc29ydFwiOiAwLFxuICAgICAgICBcImFyaWEtdmFsdWVtYXhcIjogMCxcbiAgICAgICAgXCJhcmlhLXZhbHVlbWluXCI6IDAsXG4gICAgICAgIFwiYXJpYS12YWx1ZW5vd1wiOiAwLFxuICAgICAgICBcImFyaWEtdmFsdWV0ZXh0XCI6IDAsXG4gICAgICAgIFwiYXJpYS1hdG9taWNcIjogMCxcbiAgICAgICAgXCJhcmlhLWJ1c3lcIjogMCxcbiAgICAgICAgXCJhcmlhLWxpdmVcIjogMCxcbiAgICAgICAgXCJhcmlhLXJlbGV2YW50XCI6IDAsXG4gICAgICAgIFwiYXJpYS1kcm9wZWZmZWN0XCI6IDAsXG4gICAgICAgIFwiYXJpYS1ncmFiYmVkXCI6IDAsXG4gICAgICAgIFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCI6IDAsXG4gICAgICAgIFwiYXJpYS1jb2xjb3VudFwiOiAwLFxuICAgICAgICBcImFyaWEtY29saW5kZXhcIjogMCxcbiAgICAgICAgXCJhcmlhLWNvbHNwYW5cIjogMCxcbiAgICAgICAgXCJhcmlhLWNvbnRyb2xzXCI6IDAsXG4gICAgICAgIFwiYXJpYS1kZXNjcmliZWRieVwiOiAwLFxuICAgICAgICBcImFyaWEtZXJyb3JtZXNzYWdlXCI6IDAsXG4gICAgICAgIFwiYXJpYS1mbG93dG9cIjogMCxcbiAgICAgICAgXCJhcmlhLWxhYmVsbGVkYnlcIjogMCxcbiAgICAgICAgXCJhcmlhLW93bnNcIjogMCxcbiAgICAgICAgXCJhcmlhLXBvc2luc2V0XCI6IDAsXG4gICAgICAgIFwiYXJpYS1yb3djb3VudFwiOiAwLFxuICAgICAgICBcImFyaWEtcm93aW5kZXhcIjogMCxcbiAgICAgICAgXCJhcmlhLXJvd3NwYW5cIjogMCxcbiAgICAgICAgXCJhcmlhLXNldHNpemVcIjogMFxuICAgICAgfSxcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMSA9IHt9LFxuICAgICAgckFSSUEkMSA9IFJlZ0V4cChcbiAgICAgICAgXCJeKGFyaWEpLVs6QS1aX2EtelxcXFx1MDBDMC1cXFxcdTAwRDZcXFxcdTAwRDgtXFxcXHUwMEY2XFxcXHUwMEY4LVxcXFx1MDJGRlxcXFx1MDM3MC1cXFxcdTAzN0RcXFxcdTAzN0YtXFxcXHUxRkZGXFxcXHUyMDBDLVxcXFx1MjAwRFxcXFx1MjA3MC1cXFxcdTIxOEZcXFxcdTJDMDAtXFxcXHUyRkVGXFxcXHUzMDAxLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkZEXFxcXC0uMC05XFxcXHUwMEI3XFxcXHUwMzAwLVxcXFx1MDM2RlxcXFx1MjAzRi1cXFxcdTIwNDBdKiRcIlxuICAgICAgKSxcbiAgICAgIHJBUklBQ2FtZWwkMSA9IFJlZ0V4cChcbiAgICAgICAgXCJeKGFyaWEpW0EtWl1bOkEtWl9hLXpcXFxcdTAwQzAtXFxcXHUwMEQ2XFxcXHUwMEQ4LVxcXFx1MDBGNlxcXFx1MDBGOC1cXFxcdTAyRkZcXFxcdTAzNzAtXFxcXHUwMzdEXFxcXHUwMzdGLVxcXFx1MUZGRlxcXFx1MjAwQy1cXFxcdTIwMERcXFxcdTIwNzAtXFxcXHUyMThGXFxcXHUyQzAwLVxcXFx1MkZFRlxcXFx1MzAwMS1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZGRFxcXFwtLjAtOVxcXFx1MDBCN1xcXFx1MDMwMC1cXFxcdTAzNkZcXFxcdTIwM0YtXFxcXHUyMDQwXSokXCJcbiAgICAgICksXG4gICAgICBkaWRXYXJuVmFsdWVOdWxsID0gITEsXG4gICAgICBwb3NzaWJsZVN0YW5kYXJkTmFtZXMgPSB7XG4gICAgICAgIGFjY2VwdDogXCJhY2NlcHRcIixcbiAgICAgICAgYWNjZXB0Y2hhcnNldDogXCJhY2NlcHRDaGFyc2V0XCIsXG4gICAgICAgIFwiYWNjZXB0LWNoYXJzZXRcIjogXCJhY2NlcHRDaGFyc2V0XCIsXG4gICAgICAgIGFjY2Vzc2tleTogXCJhY2Nlc3NLZXlcIixcbiAgICAgICAgYWN0aW9uOiBcImFjdGlvblwiLFxuICAgICAgICBhbGxvd2Z1bGxzY3JlZW46IFwiYWxsb3dGdWxsU2NyZWVuXCIsXG4gICAgICAgIGFsdDogXCJhbHRcIixcbiAgICAgICAgYXM6IFwiYXNcIixcbiAgICAgICAgYXN5bmM6IFwiYXN5bmNcIixcbiAgICAgICAgYXV0b2NhcGl0YWxpemU6IFwiYXV0b0NhcGl0YWxpemVcIixcbiAgICAgICAgYXV0b2NvbXBsZXRlOiBcImF1dG9Db21wbGV0ZVwiLFxuICAgICAgICBhdXRvY29ycmVjdDogXCJhdXRvQ29ycmVjdFwiLFxuICAgICAgICBhdXRvZm9jdXM6IFwiYXV0b0ZvY3VzXCIsXG4gICAgICAgIGF1dG9wbGF5OiBcImF1dG9QbGF5XCIsXG4gICAgICAgIGF1dG9zYXZlOiBcImF1dG9TYXZlXCIsXG4gICAgICAgIGNhcHR1cmU6IFwiY2FwdHVyZVwiLFxuICAgICAgICBjZWxscGFkZGluZzogXCJjZWxsUGFkZGluZ1wiLFxuICAgICAgICBjZWxsc3BhY2luZzogXCJjZWxsU3BhY2luZ1wiLFxuICAgICAgICBjaGFsbGVuZ2U6IFwiY2hhbGxlbmdlXCIsXG4gICAgICAgIGNoYXJzZXQ6IFwiY2hhclNldFwiLFxuICAgICAgICBjaGVja2VkOiBcImNoZWNrZWRcIixcbiAgICAgICAgY2hpbGRyZW46IFwiY2hpbGRyZW5cIixcbiAgICAgICAgY2l0ZTogXCJjaXRlXCIsXG4gICAgICAgIGNsYXNzOiBcImNsYXNzTmFtZVwiLFxuICAgICAgICBjbGFzc2lkOiBcImNsYXNzSURcIixcbiAgICAgICAgY2xhc3NuYW1lOiBcImNsYXNzTmFtZVwiLFxuICAgICAgICBjb2xzOiBcImNvbHNcIixcbiAgICAgICAgY29sc3BhbjogXCJjb2xTcGFuXCIsXG4gICAgICAgIGNvbnRlbnQ6IFwiY29udGVudFwiLFxuICAgICAgICBjb250ZW50ZWRpdGFibGU6IFwiY29udGVudEVkaXRhYmxlXCIsXG4gICAgICAgIGNvbnRleHRtZW51OiBcImNvbnRleHRNZW51XCIsXG4gICAgICAgIGNvbnRyb2xzOiBcImNvbnRyb2xzXCIsXG4gICAgICAgIGNvbnRyb2xzbGlzdDogXCJjb250cm9sc0xpc3RcIixcbiAgICAgICAgY29vcmRzOiBcImNvb3Jkc1wiLFxuICAgICAgICBjcm9zc29yaWdpbjogXCJjcm9zc09yaWdpblwiLFxuICAgICAgICBkYW5nZXJvdXNseXNldGlubmVyaHRtbDogXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiLFxuICAgICAgICBkYXRhOiBcImRhdGFcIixcbiAgICAgICAgZGF0ZXRpbWU6IFwiZGF0ZVRpbWVcIixcbiAgICAgICAgZGVmYXVsdDogXCJkZWZhdWx0XCIsXG4gICAgICAgIGRlZmF1bHRjaGVja2VkOiBcImRlZmF1bHRDaGVja2VkXCIsXG4gICAgICAgIGRlZmF1bHR2YWx1ZTogXCJkZWZhdWx0VmFsdWVcIixcbiAgICAgICAgZGVmZXI6IFwiZGVmZXJcIixcbiAgICAgICAgZGlyOiBcImRpclwiLFxuICAgICAgICBkaXNhYmxlZDogXCJkaXNhYmxlZFwiLFxuICAgICAgICBkaXNhYmxlcGljdHVyZWlucGljdHVyZTogXCJkaXNhYmxlUGljdHVyZUluUGljdHVyZVwiLFxuICAgICAgICBkaXNhYmxlcmVtb3RlcGxheWJhY2s6IFwiZGlzYWJsZVJlbW90ZVBsYXliYWNrXCIsXG4gICAgICAgIGRvd25sb2FkOiBcImRvd25sb2FkXCIsXG4gICAgICAgIGRyYWdnYWJsZTogXCJkcmFnZ2FibGVcIixcbiAgICAgICAgZW5jdHlwZTogXCJlbmNUeXBlXCIsXG4gICAgICAgIGVudGVya2V5aGludDogXCJlbnRlcktleUhpbnRcIixcbiAgICAgICAgZmV0Y2hwcmlvcml0eTogXCJmZXRjaFByaW9yaXR5XCIsXG4gICAgICAgIGZvcjogXCJodG1sRm9yXCIsXG4gICAgICAgIGZvcm06IFwiZm9ybVwiLFxuICAgICAgICBmb3JtbWV0aG9kOiBcImZvcm1NZXRob2RcIixcbiAgICAgICAgZm9ybWFjdGlvbjogXCJmb3JtQWN0aW9uXCIsXG4gICAgICAgIGZvcm1lbmN0eXBlOiBcImZvcm1FbmNUeXBlXCIsXG4gICAgICAgIGZvcm1ub3ZhbGlkYXRlOiBcImZvcm1Ob1ZhbGlkYXRlXCIsXG4gICAgICAgIGZvcm10YXJnZXQ6IFwiZm9ybVRhcmdldFwiLFxuICAgICAgICBmcmFtZWJvcmRlcjogXCJmcmFtZUJvcmRlclwiLFxuICAgICAgICBoZWFkZXJzOiBcImhlYWRlcnNcIixcbiAgICAgICAgaGVpZ2h0OiBcImhlaWdodFwiLFxuICAgICAgICBoaWRkZW46IFwiaGlkZGVuXCIsXG4gICAgICAgIGhpZ2g6IFwiaGlnaFwiLFxuICAgICAgICBocmVmOiBcImhyZWZcIixcbiAgICAgICAgaHJlZmxhbmc6IFwiaHJlZkxhbmdcIixcbiAgICAgICAgaHRtbGZvcjogXCJodG1sRm9yXCIsXG4gICAgICAgIGh0dHBlcXVpdjogXCJodHRwRXF1aXZcIixcbiAgICAgICAgXCJodHRwLWVxdWl2XCI6IFwiaHR0cEVxdWl2XCIsXG4gICAgICAgIGljb246IFwiaWNvblwiLFxuICAgICAgICBpZDogXCJpZFwiLFxuICAgICAgICBpbWFnZXNpemVzOiBcImltYWdlU2l6ZXNcIixcbiAgICAgICAgaW1hZ2VzcmNzZXQ6IFwiaW1hZ2VTcmNTZXRcIixcbiAgICAgICAgaW5lcnQ6IFwiaW5lcnRcIixcbiAgICAgICAgaW5uZXJodG1sOiBcImlubmVySFRNTFwiLFxuICAgICAgICBpbnB1dG1vZGU6IFwiaW5wdXRNb2RlXCIsXG4gICAgICAgIGludGVncml0eTogXCJpbnRlZ3JpdHlcIixcbiAgICAgICAgaXM6IFwiaXNcIixcbiAgICAgICAgaXRlbWlkOiBcIml0ZW1JRFwiLFxuICAgICAgICBpdGVtcHJvcDogXCJpdGVtUHJvcFwiLFxuICAgICAgICBpdGVtcmVmOiBcIml0ZW1SZWZcIixcbiAgICAgICAgaXRlbXNjb3BlOiBcIml0ZW1TY29wZVwiLFxuICAgICAgICBpdGVtdHlwZTogXCJpdGVtVHlwZVwiLFxuICAgICAgICBrZXlwYXJhbXM6IFwia2V5UGFyYW1zXCIsXG4gICAgICAgIGtleXR5cGU6IFwia2V5VHlwZVwiLFxuICAgICAgICBraW5kOiBcImtpbmRcIixcbiAgICAgICAgbGFiZWw6IFwibGFiZWxcIixcbiAgICAgICAgbGFuZzogXCJsYW5nXCIsXG4gICAgICAgIGxpc3Q6IFwibGlzdFwiLFxuICAgICAgICBsb29wOiBcImxvb3BcIixcbiAgICAgICAgbG93OiBcImxvd1wiLFxuICAgICAgICBtYW5pZmVzdDogXCJtYW5pZmVzdFwiLFxuICAgICAgICBtYXJnaW53aWR0aDogXCJtYXJnaW5XaWR0aFwiLFxuICAgICAgICBtYXJnaW5oZWlnaHQ6IFwibWFyZ2luSGVpZ2h0XCIsXG4gICAgICAgIG1heDogXCJtYXhcIixcbiAgICAgICAgbWF4bGVuZ3RoOiBcIm1heExlbmd0aFwiLFxuICAgICAgICBtZWRpYTogXCJtZWRpYVwiLFxuICAgICAgICBtZWRpYWdyb3VwOiBcIm1lZGlhR3JvdXBcIixcbiAgICAgICAgbWV0aG9kOiBcIm1ldGhvZFwiLFxuICAgICAgICBtaW46IFwibWluXCIsXG4gICAgICAgIG1pbmxlbmd0aDogXCJtaW5MZW5ndGhcIixcbiAgICAgICAgbXVsdGlwbGU6IFwibXVsdGlwbGVcIixcbiAgICAgICAgbXV0ZWQ6IFwibXV0ZWRcIixcbiAgICAgICAgbmFtZTogXCJuYW1lXCIsXG4gICAgICAgIG5vbW9kdWxlOiBcIm5vTW9kdWxlXCIsXG4gICAgICAgIG5vbmNlOiBcIm5vbmNlXCIsXG4gICAgICAgIG5vdmFsaWRhdGU6IFwibm9WYWxpZGF0ZVwiLFxuICAgICAgICBvcGVuOiBcIm9wZW5cIixcbiAgICAgICAgb3B0aW11bTogXCJvcHRpbXVtXCIsXG4gICAgICAgIHBhdHRlcm46IFwicGF0dGVyblwiLFxuICAgICAgICBwbGFjZWhvbGRlcjogXCJwbGFjZWhvbGRlclwiLFxuICAgICAgICBwbGF5c2lubGluZTogXCJwbGF5c0lubGluZVwiLFxuICAgICAgICBwb3N0ZXI6IFwicG9zdGVyXCIsXG4gICAgICAgIHByZWxvYWQ6IFwicHJlbG9hZFwiLFxuICAgICAgICBwcm9maWxlOiBcInByb2ZpbGVcIixcbiAgICAgICAgcmFkaW9ncm91cDogXCJyYWRpb0dyb3VwXCIsXG4gICAgICAgIHJlYWRvbmx5OiBcInJlYWRPbmx5XCIsXG4gICAgICAgIHJlZmVycmVycG9saWN5OiBcInJlZmVycmVyUG9saWN5XCIsXG4gICAgICAgIHJlbDogXCJyZWxcIixcbiAgICAgICAgcmVxdWlyZWQ6IFwicmVxdWlyZWRcIixcbiAgICAgICAgcmV2ZXJzZWQ6IFwicmV2ZXJzZWRcIixcbiAgICAgICAgcm9sZTogXCJyb2xlXCIsXG4gICAgICAgIHJvd3M6IFwicm93c1wiLFxuICAgICAgICByb3dzcGFuOiBcInJvd1NwYW5cIixcbiAgICAgICAgc2FuZGJveDogXCJzYW5kYm94XCIsXG4gICAgICAgIHNjb3BlOiBcInNjb3BlXCIsXG4gICAgICAgIHNjb3BlZDogXCJzY29wZWRcIixcbiAgICAgICAgc2Nyb2xsaW5nOiBcInNjcm9sbGluZ1wiLFxuICAgICAgICBzZWFtbGVzczogXCJzZWFtbGVzc1wiLFxuICAgICAgICBzZWxlY3RlZDogXCJzZWxlY3RlZFwiLFxuICAgICAgICBzaGFwZTogXCJzaGFwZVwiLFxuICAgICAgICBzaXplOiBcInNpemVcIixcbiAgICAgICAgc2l6ZXM6IFwic2l6ZXNcIixcbiAgICAgICAgc3BhbjogXCJzcGFuXCIsXG4gICAgICAgIHNwZWxsY2hlY2s6IFwic3BlbGxDaGVja1wiLFxuICAgICAgICBzcmM6IFwic3JjXCIsXG4gICAgICAgIHNyY2RvYzogXCJzcmNEb2NcIixcbiAgICAgICAgc3JjbGFuZzogXCJzcmNMYW5nXCIsXG4gICAgICAgIHNyY3NldDogXCJzcmNTZXRcIixcbiAgICAgICAgc3RhcnQ6IFwic3RhcnRcIixcbiAgICAgICAgc3RlcDogXCJzdGVwXCIsXG4gICAgICAgIHN0eWxlOiBcInN0eWxlXCIsXG4gICAgICAgIHN1bW1hcnk6IFwic3VtbWFyeVwiLFxuICAgICAgICB0YWJpbmRleDogXCJ0YWJJbmRleFwiLFxuICAgICAgICB0YXJnZXQ6IFwidGFyZ2V0XCIsXG4gICAgICAgIHRpdGxlOiBcInRpdGxlXCIsXG4gICAgICAgIHR5cGU6IFwidHlwZVwiLFxuICAgICAgICB1c2VtYXA6IFwidXNlTWFwXCIsXG4gICAgICAgIHZhbHVlOiBcInZhbHVlXCIsXG4gICAgICAgIHdpZHRoOiBcIndpZHRoXCIsXG4gICAgICAgIHdtb2RlOiBcIndtb2RlXCIsXG4gICAgICAgIHdyYXA6IFwid3JhcFwiLFxuICAgICAgICBhYm91dDogXCJhYm91dFwiLFxuICAgICAgICBhY2NlbnRoZWlnaHQ6IFwiYWNjZW50SGVpZ2h0XCIsXG4gICAgICAgIFwiYWNjZW50LWhlaWdodFwiOiBcImFjY2VudEhlaWdodFwiLFxuICAgICAgICBhY2N1bXVsYXRlOiBcImFjY3VtdWxhdGVcIixcbiAgICAgICAgYWRkaXRpdmU6IFwiYWRkaXRpdmVcIixcbiAgICAgICAgYWxpZ25tZW50YmFzZWxpbmU6IFwiYWxpZ25tZW50QmFzZWxpbmVcIixcbiAgICAgICAgXCJhbGlnbm1lbnQtYmFzZWxpbmVcIjogXCJhbGlnbm1lbnRCYXNlbGluZVwiLFxuICAgICAgICBhbGxvd3Jlb3JkZXI6IFwiYWxsb3dSZW9yZGVyXCIsXG4gICAgICAgIGFscGhhYmV0aWM6IFwiYWxwaGFiZXRpY1wiLFxuICAgICAgICBhbXBsaXR1ZGU6IFwiYW1wbGl0dWRlXCIsXG4gICAgICAgIGFyYWJpY2Zvcm06IFwiYXJhYmljRm9ybVwiLFxuICAgICAgICBcImFyYWJpYy1mb3JtXCI6IFwiYXJhYmljRm9ybVwiLFxuICAgICAgICBhc2NlbnQ6IFwiYXNjZW50XCIsXG4gICAgICAgIGF0dHJpYnV0ZW5hbWU6IFwiYXR0cmlidXRlTmFtZVwiLFxuICAgICAgICBhdHRyaWJ1dGV0eXBlOiBcImF0dHJpYnV0ZVR5cGVcIixcbiAgICAgICAgYXV0b3JldmVyc2U6IFwiYXV0b1JldmVyc2VcIixcbiAgICAgICAgYXppbXV0aDogXCJhemltdXRoXCIsXG4gICAgICAgIGJhc2VmcmVxdWVuY3k6IFwiYmFzZUZyZXF1ZW5jeVwiLFxuICAgICAgICBiYXNlbGluZXNoaWZ0OiBcImJhc2VsaW5lU2hpZnRcIixcbiAgICAgICAgXCJiYXNlbGluZS1zaGlmdFwiOiBcImJhc2VsaW5lU2hpZnRcIixcbiAgICAgICAgYmFzZXByb2ZpbGU6IFwiYmFzZVByb2ZpbGVcIixcbiAgICAgICAgYmJveDogXCJiYm94XCIsXG4gICAgICAgIGJlZ2luOiBcImJlZ2luXCIsXG4gICAgICAgIGJpYXM6IFwiYmlhc1wiLFxuICAgICAgICBieTogXCJieVwiLFxuICAgICAgICBjYWxjbW9kZTogXCJjYWxjTW9kZVwiLFxuICAgICAgICBjYXBoZWlnaHQ6IFwiY2FwSGVpZ2h0XCIsXG4gICAgICAgIFwiY2FwLWhlaWdodFwiOiBcImNhcEhlaWdodFwiLFxuICAgICAgICBjbGlwOiBcImNsaXBcIixcbiAgICAgICAgY2xpcHBhdGg6IFwiY2xpcFBhdGhcIixcbiAgICAgICAgXCJjbGlwLXBhdGhcIjogXCJjbGlwUGF0aFwiLFxuICAgICAgICBjbGlwcGF0aHVuaXRzOiBcImNsaXBQYXRoVW5pdHNcIixcbiAgICAgICAgY2xpcHJ1bGU6IFwiY2xpcFJ1bGVcIixcbiAgICAgICAgXCJjbGlwLXJ1bGVcIjogXCJjbGlwUnVsZVwiLFxuICAgICAgICBjb2xvcjogXCJjb2xvclwiLFxuICAgICAgICBjb2xvcmludGVycG9sYXRpb246IFwiY29sb3JJbnRlcnBvbGF0aW9uXCIsXG4gICAgICAgIFwiY29sb3ItaW50ZXJwb2xhdGlvblwiOiBcImNvbG9ySW50ZXJwb2xhdGlvblwiLFxuICAgICAgICBjb2xvcmludGVycG9sYXRpb25maWx0ZXJzOiBcImNvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnNcIixcbiAgICAgICAgXCJjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnNcIjogXCJjb2xvckludGVycG9sYXRpb25GaWx0ZXJzXCIsXG4gICAgICAgIGNvbG9ycHJvZmlsZTogXCJjb2xvclByb2ZpbGVcIixcbiAgICAgICAgXCJjb2xvci1wcm9maWxlXCI6IFwiY29sb3JQcm9maWxlXCIsXG4gICAgICAgIGNvbG9ycmVuZGVyaW5nOiBcImNvbG9yUmVuZGVyaW5nXCIsXG4gICAgICAgIFwiY29sb3ItcmVuZGVyaW5nXCI6IFwiY29sb3JSZW5kZXJpbmdcIixcbiAgICAgICAgY29udGVudHNjcmlwdHR5cGU6IFwiY29udGVudFNjcmlwdFR5cGVcIixcbiAgICAgICAgY29udGVudHN0eWxldHlwZTogXCJjb250ZW50U3R5bGVUeXBlXCIsXG4gICAgICAgIGN1cnNvcjogXCJjdXJzb3JcIixcbiAgICAgICAgY3g6IFwiY3hcIixcbiAgICAgICAgY3k6IFwiY3lcIixcbiAgICAgICAgZDogXCJkXCIsXG4gICAgICAgIGRhdGF0eXBlOiBcImRhdGF0eXBlXCIsXG4gICAgICAgIGRlY2VsZXJhdGU6IFwiZGVjZWxlcmF0ZVwiLFxuICAgICAgICBkZXNjZW50OiBcImRlc2NlbnRcIixcbiAgICAgICAgZGlmZnVzZWNvbnN0YW50OiBcImRpZmZ1c2VDb25zdGFudFwiLFxuICAgICAgICBkaXJlY3Rpb246IFwiZGlyZWN0aW9uXCIsXG4gICAgICAgIGRpc3BsYXk6IFwiZGlzcGxheVwiLFxuICAgICAgICBkaXZpc29yOiBcImRpdmlzb3JcIixcbiAgICAgICAgZG9taW5hbnRiYXNlbGluZTogXCJkb21pbmFudEJhc2VsaW5lXCIsXG4gICAgICAgIFwiZG9taW5hbnQtYmFzZWxpbmVcIjogXCJkb21pbmFudEJhc2VsaW5lXCIsXG4gICAgICAgIGR1cjogXCJkdXJcIixcbiAgICAgICAgZHg6IFwiZHhcIixcbiAgICAgICAgZHk6IFwiZHlcIixcbiAgICAgICAgZWRnZW1vZGU6IFwiZWRnZU1vZGVcIixcbiAgICAgICAgZWxldmF0aW9uOiBcImVsZXZhdGlvblwiLFxuICAgICAgICBlbmFibGViYWNrZ3JvdW5kOiBcImVuYWJsZUJhY2tncm91bmRcIixcbiAgICAgICAgXCJlbmFibGUtYmFja2dyb3VuZFwiOiBcImVuYWJsZUJhY2tncm91bmRcIixcbiAgICAgICAgZW5kOiBcImVuZFwiLFxuICAgICAgICBleHBvbmVudDogXCJleHBvbmVudFwiLFxuICAgICAgICBleHRlcm5hbHJlc291cmNlc3JlcXVpcmVkOiBcImV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWRcIixcbiAgICAgICAgZmlsbDogXCJmaWxsXCIsXG4gICAgICAgIGZpbGxvcGFjaXR5OiBcImZpbGxPcGFjaXR5XCIsXG4gICAgICAgIFwiZmlsbC1vcGFjaXR5XCI6IFwiZmlsbE9wYWNpdHlcIixcbiAgICAgICAgZmlsbHJ1bGU6IFwiZmlsbFJ1bGVcIixcbiAgICAgICAgXCJmaWxsLXJ1bGVcIjogXCJmaWxsUnVsZVwiLFxuICAgICAgICBmaWx0ZXI6IFwiZmlsdGVyXCIsXG4gICAgICAgIGZpbHRlcnJlczogXCJmaWx0ZXJSZXNcIixcbiAgICAgICAgZmlsdGVydW5pdHM6IFwiZmlsdGVyVW5pdHNcIixcbiAgICAgICAgZmxvb2RvcGFjaXR5OiBcImZsb29kT3BhY2l0eVwiLFxuICAgICAgICBcImZsb29kLW9wYWNpdHlcIjogXCJmbG9vZE9wYWNpdHlcIixcbiAgICAgICAgZmxvb2Rjb2xvcjogXCJmbG9vZENvbG9yXCIsXG4gICAgICAgIFwiZmxvb2QtY29sb3JcIjogXCJmbG9vZENvbG9yXCIsXG4gICAgICAgIGZvY3VzYWJsZTogXCJmb2N1c2FibGVcIixcbiAgICAgICAgZm9udGZhbWlseTogXCJmb250RmFtaWx5XCIsXG4gICAgICAgIFwiZm9udC1mYW1pbHlcIjogXCJmb250RmFtaWx5XCIsXG4gICAgICAgIGZvbnRzaXplOiBcImZvbnRTaXplXCIsXG4gICAgICAgIFwiZm9udC1zaXplXCI6IFwiZm9udFNpemVcIixcbiAgICAgICAgZm9udHNpemVhZGp1c3Q6IFwiZm9udFNpemVBZGp1c3RcIixcbiAgICAgICAgXCJmb250LXNpemUtYWRqdXN0XCI6IFwiZm9udFNpemVBZGp1c3RcIixcbiAgICAgICAgZm9udHN0cmV0Y2g6IFwiZm9udFN0cmV0Y2hcIixcbiAgICAgICAgXCJmb250LXN0cmV0Y2hcIjogXCJmb250U3RyZXRjaFwiLFxuICAgICAgICBmb250c3R5bGU6IFwiZm9udFN0eWxlXCIsXG4gICAgICAgIFwiZm9udC1zdHlsZVwiOiBcImZvbnRTdHlsZVwiLFxuICAgICAgICBmb250dmFyaWFudDogXCJmb250VmFyaWFudFwiLFxuICAgICAgICBcImZvbnQtdmFyaWFudFwiOiBcImZvbnRWYXJpYW50XCIsXG4gICAgICAgIGZvbnR3ZWlnaHQ6IFwiZm9udFdlaWdodFwiLFxuICAgICAgICBcImZvbnQtd2VpZ2h0XCI6IFwiZm9udFdlaWdodFwiLFxuICAgICAgICBmb3JtYXQ6IFwiZm9ybWF0XCIsXG4gICAgICAgIGZyb206IFwiZnJvbVwiLFxuICAgICAgICBmeDogXCJmeFwiLFxuICAgICAgICBmeTogXCJmeVwiLFxuICAgICAgICBnMTogXCJnMVwiLFxuICAgICAgICBnMjogXCJnMlwiLFxuICAgICAgICBnbHlwaG5hbWU6IFwiZ2x5cGhOYW1lXCIsXG4gICAgICAgIFwiZ2x5cGgtbmFtZVwiOiBcImdseXBoTmFtZVwiLFxuICAgICAgICBnbHlwaG9yaWVudGF0aW9uaG9yaXpvbnRhbDogXCJnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbFwiLFxuICAgICAgICBcImdseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWxcIjogXCJnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbFwiLFxuICAgICAgICBnbHlwaG9yaWVudGF0aW9udmVydGljYWw6IFwiZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsXCIsXG4gICAgICAgIFwiZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWxcIjogXCJnbHlwaE9yaWVudGF0aW9uVmVydGljYWxcIixcbiAgICAgICAgZ2x5cGhyZWY6IFwiZ2x5cGhSZWZcIixcbiAgICAgICAgZ3JhZGllbnR0cmFuc2Zvcm06IFwiZ3JhZGllbnRUcmFuc2Zvcm1cIixcbiAgICAgICAgZ3JhZGllbnR1bml0czogXCJncmFkaWVudFVuaXRzXCIsXG4gICAgICAgIGhhbmdpbmc6IFwiaGFuZ2luZ1wiLFxuICAgICAgICBob3JpemFkdng6IFwiaG9yaXpBZHZYXCIsXG4gICAgICAgIFwiaG9yaXotYWR2LXhcIjogXCJob3JpekFkdlhcIixcbiAgICAgICAgaG9yaXpvcmlnaW54OiBcImhvcml6T3JpZ2luWFwiLFxuICAgICAgICBcImhvcml6LW9yaWdpbi14XCI6IFwiaG9yaXpPcmlnaW5YXCIsXG4gICAgICAgIGlkZW9ncmFwaGljOiBcImlkZW9ncmFwaGljXCIsXG4gICAgICAgIGltYWdlcmVuZGVyaW5nOiBcImltYWdlUmVuZGVyaW5nXCIsXG4gICAgICAgIFwiaW1hZ2UtcmVuZGVyaW5nXCI6IFwiaW1hZ2VSZW5kZXJpbmdcIixcbiAgICAgICAgaW4yOiBcImluMlwiLFxuICAgICAgICBpbjogXCJpblwiLFxuICAgICAgICBpbmxpc3Q6IFwiaW5saXN0XCIsXG4gICAgICAgIGludGVyY2VwdDogXCJpbnRlcmNlcHRcIixcbiAgICAgICAgazE6IFwiazFcIixcbiAgICAgICAgazI6IFwiazJcIixcbiAgICAgICAgazM6IFwiazNcIixcbiAgICAgICAgazQ6IFwiazRcIixcbiAgICAgICAgazogXCJrXCIsXG4gICAgICAgIGtlcm5lbG1hdHJpeDogXCJrZXJuZWxNYXRyaXhcIixcbiAgICAgICAga2VybmVsdW5pdGxlbmd0aDogXCJrZXJuZWxVbml0TGVuZ3RoXCIsXG4gICAgICAgIGtlcm5pbmc6IFwia2VybmluZ1wiLFxuICAgICAgICBrZXlwb2ludHM6IFwia2V5UG9pbnRzXCIsXG4gICAgICAgIGtleXNwbGluZXM6IFwia2V5U3BsaW5lc1wiLFxuICAgICAgICBrZXl0aW1lczogXCJrZXlUaW1lc1wiLFxuICAgICAgICBsZW5ndGhhZGp1c3Q6IFwibGVuZ3RoQWRqdXN0XCIsXG4gICAgICAgIGxldHRlcnNwYWNpbmc6IFwibGV0dGVyU3BhY2luZ1wiLFxuICAgICAgICBcImxldHRlci1zcGFjaW5nXCI6IFwibGV0dGVyU3BhY2luZ1wiLFxuICAgICAgICBsaWdodGluZ2NvbG9yOiBcImxpZ2h0aW5nQ29sb3JcIixcbiAgICAgICAgXCJsaWdodGluZy1jb2xvclwiOiBcImxpZ2h0aW5nQ29sb3JcIixcbiAgICAgICAgbGltaXRpbmdjb25lYW5nbGU6IFwibGltaXRpbmdDb25lQW5nbGVcIixcbiAgICAgICAgbG9jYWw6IFwibG9jYWxcIixcbiAgICAgICAgbWFya2VyZW5kOiBcIm1hcmtlckVuZFwiLFxuICAgICAgICBcIm1hcmtlci1lbmRcIjogXCJtYXJrZXJFbmRcIixcbiAgICAgICAgbWFya2VyaGVpZ2h0OiBcIm1hcmtlckhlaWdodFwiLFxuICAgICAgICBtYXJrZXJtaWQ6IFwibWFya2VyTWlkXCIsXG4gICAgICAgIFwibWFya2VyLW1pZFwiOiBcIm1hcmtlck1pZFwiLFxuICAgICAgICBtYXJrZXJzdGFydDogXCJtYXJrZXJTdGFydFwiLFxuICAgICAgICBcIm1hcmtlci1zdGFydFwiOiBcIm1hcmtlclN0YXJ0XCIsXG4gICAgICAgIG1hcmtlcnVuaXRzOiBcIm1hcmtlclVuaXRzXCIsXG4gICAgICAgIG1hcmtlcndpZHRoOiBcIm1hcmtlcldpZHRoXCIsXG4gICAgICAgIG1hc2s6IFwibWFza1wiLFxuICAgICAgICBtYXNrY29udGVudHVuaXRzOiBcIm1hc2tDb250ZW50VW5pdHNcIixcbiAgICAgICAgbWFza3VuaXRzOiBcIm1hc2tVbml0c1wiLFxuICAgICAgICBtYXRoZW1hdGljYWw6IFwibWF0aGVtYXRpY2FsXCIsXG4gICAgICAgIG1vZGU6IFwibW9kZVwiLFxuICAgICAgICBudW1vY3RhdmVzOiBcIm51bU9jdGF2ZXNcIixcbiAgICAgICAgb2Zmc2V0OiBcIm9mZnNldFwiLFxuICAgICAgICBvcGFjaXR5OiBcIm9wYWNpdHlcIixcbiAgICAgICAgb3BlcmF0b3I6IFwib3BlcmF0b3JcIixcbiAgICAgICAgb3JkZXI6IFwib3JkZXJcIixcbiAgICAgICAgb3JpZW50OiBcIm9yaWVudFwiLFxuICAgICAgICBvcmllbnRhdGlvbjogXCJvcmllbnRhdGlvblwiLFxuICAgICAgICBvcmlnaW46IFwib3JpZ2luXCIsXG4gICAgICAgIG92ZXJmbG93OiBcIm92ZXJmbG93XCIsXG4gICAgICAgIG92ZXJsaW5lcG9zaXRpb246IFwib3ZlcmxpbmVQb3NpdGlvblwiLFxuICAgICAgICBcIm92ZXJsaW5lLXBvc2l0aW9uXCI6IFwib3ZlcmxpbmVQb3NpdGlvblwiLFxuICAgICAgICBvdmVybGluZXRoaWNrbmVzczogXCJvdmVybGluZVRoaWNrbmVzc1wiLFxuICAgICAgICBcIm92ZXJsaW5lLXRoaWNrbmVzc1wiOiBcIm92ZXJsaW5lVGhpY2tuZXNzXCIsXG4gICAgICAgIHBhaW50b3JkZXI6IFwicGFpbnRPcmRlclwiLFxuICAgICAgICBcInBhaW50LW9yZGVyXCI6IFwicGFpbnRPcmRlclwiLFxuICAgICAgICBwYW5vc2UxOiBcInBhbm9zZTFcIixcbiAgICAgICAgXCJwYW5vc2UtMVwiOiBcInBhbm9zZTFcIixcbiAgICAgICAgcGF0aGxlbmd0aDogXCJwYXRoTGVuZ3RoXCIsXG4gICAgICAgIHBhdHRlcm5jb250ZW50dW5pdHM6IFwicGF0dGVybkNvbnRlbnRVbml0c1wiLFxuICAgICAgICBwYXR0ZXJudHJhbnNmb3JtOiBcInBhdHRlcm5UcmFuc2Zvcm1cIixcbiAgICAgICAgcGF0dGVybnVuaXRzOiBcInBhdHRlcm5Vbml0c1wiLFxuICAgICAgICBwb2ludGVyZXZlbnRzOiBcInBvaW50ZXJFdmVudHNcIixcbiAgICAgICAgXCJwb2ludGVyLWV2ZW50c1wiOiBcInBvaW50ZXJFdmVudHNcIixcbiAgICAgICAgcG9pbnRzOiBcInBvaW50c1wiLFxuICAgICAgICBwb2ludHNhdHg6IFwicG9pbnRzQXRYXCIsXG4gICAgICAgIHBvaW50c2F0eTogXCJwb2ludHNBdFlcIixcbiAgICAgICAgcG9pbnRzYXR6OiBcInBvaW50c0F0WlwiLFxuICAgICAgICBwb3BvdmVyOiBcInBvcG92ZXJcIixcbiAgICAgICAgcG9wb3ZlcnRhcmdldDogXCJwb3BvdmVyVGFyZ2V0XCIsXG4gICAgICAgIHBvcG92ZXJ0YXJnZXRhY3Rpb246IFwicG9wb3ZlclRhcmdldEFjdGlvblwiLFxuICAgICAgICBwcmVmaXg6IFwicHJlZml4XCIsXG4gICAgICAgIHByZXNlcnZlYWxwaGE6IFwicHJlc2VydmVBbHBoYVwiLFxuICAgICAgICBwcmVzZXJ2ZWFzcGVjdHJhdGlvOiBcInByZXNlcnZlQXNwZWN0UmF0aW9cIixcbiAgICAgICAgcHJpbWl0aXZldW5pdHM6IFwicHJpbWl0aXZlVW5pdHNcIixcbiAgICAgICAgcHJvcGVydHk6IFwicHJvcGVydHlcIixcbiAgICAgICAgcjogXCJyXCIsXG4gICAgICAgIHJhZGl1czogXCJyYWRpdXNcIixcbiAgICAgICAgcmVmeDogXCJyZWZYXCIsXG4gICAgICAgIHJlZnk6IFwicmVmWVwiLFxuICAgICAgICByZW5kZXJpbmdpbnRlbnQ6IFwicmVuZGVyaW5nSW50ZW50XCIsXG4gICAgICAgIFwicmVuZGVyaW5nLWludGVudFwiOiBcInJlbmRlcmluZ0ludGVudFwiLFxuICAgICAgICByZXBlYXRjb3VudDogXCJyZXBlYXRDb3VudFwiLFxuICAgICAgICByZXBlYXRkdXI6IFwicmVwZWF0RHVyXCIsXG4gICAgICAgIHJlcXVpcmVkZXh0ZW5zaW9uczogXCJyZXF1aXJlZEV4dGVuc2lvbnNcIixcbiAgICAgICAgcmVxdWlyZWRmZWF0dXJlczogXCJyZXF1aXJlZEZlYXR1cmVzXCIsXG4gICAgICAgIHJlc291cmNlOiBcInJlc291cmNlXCIsXG4gICAgICAgIHJlc3RhcnQ6IFwicmVzdGFydFwiLFxuICAgICAgICByZXN1bHQ6IFwicmVzdWx0XCIsXG4gICAgICAgIHJlc3VsdHM6IFwicmVzdWx0c1wiLFxuICAgICAgICByb3RhdGU6IFwicm90YXRlXCIsXG4gICAgICAgIHJ4OiBcInJ4XCIsXG4gICAgICAgIHJ5OiBcInJ5XCIsXG4gICAgICAgIHNjYWxlOiBcInNjYWxlXCIsXG4gICAgICAgIHNlY3VyaXR5OiBcInNlY3VyaXR5XCIsXG4gICAgICAgIHNlZWQ6IFwic2VlZFwiLFxuICAgICAgICBzaGFwZXJlbmRlcmluZzogXCJzaGFwZVJlbmRlcmluZ1wiLFxuICAgICAgICBcInNoYXBlLXJlbmRlcmluZ1wiOiBcInNoYXBlUmVuZGVyaW5nXCIsXG4gICAgICAgIHNsb3BlOiBcInNsb3BlXCIsXG4gICAgICAgIHNwYWNpbmc6IFwic3BhY2luZ1wiLFxuICAgICAgICBzcGVjdWxhcmNvbnN0YW50OiBcInNwZWN1bGFyQ29uc3RhbnRcIixcbiAgICAgICAgc3BlY3VsYXJleHBvbmVudDogXCJzcGVjdWxhckV4cG9uZW50XCIsXG4gICAgICAgIHNwZWVkOiBcInNwZWVkXCIsXG4gICAgICAgIHNwcmVhZG1ldGhvZDogXCJzcHJlYWRNZXRob2RcIixcbiAgICAgICAgc3RhcnRvZmZzZXQ6IFwic3RhcnRPZmZzZXRcIixcbiAgICAgICAgc3RkZGV2aWF0aW9uOiBcInN0ZERldmlhdGlvblwiLFxuICAgICAgICBzdGVtaDogXCJzdGVtaFwiLFxuICAgICAgICBzdGVtdjogXCJzdGVtdlwiLFxuICAgICAgICBzdGl0Y2h0aWxlczogXCJzdGl0Y2hUaWxlc1wiLFxuICAgICAgICBzdG9wY29sb3I6IFwic3RvcENvbG9yXCIsXG4gICAgICAgIFwic3RvcC1jb2xvclwiOiBcInN0b3BDb2xvclwiLFxuICAgICAgICBzdG9wb3BhY2l0eTogXCJzdG9wT3BhY2l0eVwiLFxuICAgICAgICBcInN0b3Atb3BhY2l0eVwiOiBcInN0b3BPcGFjaXR5XCIsXG4gICAgICAgIHN0cmlrZXRocm91Z2hwb3NpdGlvbjogXCJzdHJpa2V0aHJvdWdoUG9zaXRpb25cIixcbiAgICAgICAgXCJzdHJpa2V0aHJvdWdoLXBvc2l0aW9uXCI6IFwic3RyaWtldGhyb3VnaFBvc2l0aW9uXCIsXG4gICAgICAgIHN0cmlrZXRocm91Z2h0aGlja25lc3M6IFwic3RyaWtldGhyb3VnaFRoaWNrbmVzc1wiLFxuICAgICAgICBcInN0cmlrZXRocm91Z2gtdGhpY2tuZXNzXCI6IFwic3RyaWtldGhyb3VnaFRoaWNrbmVzc1wiLFxuICAgICAgICBzdHJpbmc6IFwic3RyaW5nXCIsXG4gICAgICAgIHN0cm9rZTogXCJzdHJva2VcIixcbiAgICAgICAgc3Ryb2tlZGFzaGFycmF5OiBcInN0cm9rZURhc2hhcnJheVwiLFxuICAgICAgICBcInN0cm9rZS1kYXNoYXJyYXlcIjogXCJzdHJva2VEYXNoYXJyYXlcIixcbiAgICAgICAgc3Ryb2tlZGFzaG9mZnNldDogXCJzdHJva2VEYXNob2Zmc2V0XCIsXG4gICAgICAgIFwic3Ryb2tlLWRhc2hvZmZzZXRcIjogXCJzdHJva2VEYXNob2Zmc2V0XCIsXG4gICAgICAgIHN0cm9rZWxpbmVjYXA6IFwic3Ryb2tlTGluZWNhcFwiLFxuICAgICAgICBcInN0cm9rZS1saW5lY2FwXCI6IFwic3Ryb2tlTGluZWNhcFwiLFxuICAgICAgICBzdHJva2VsaW5lam9pbjogXCJzdHJva2VMaW5lam9pblwiLFxuICAgICAgICBcInN0cm9rZS1saW5lam9pblwiOiBcInN0cm9rZUxpbmVqb2luXCIsXG4gICAgICAgIHN0cm9rZW1pdGVybGltaXQ6IFwic3Ryb2tlTWl0ZXJsaW1pdFwiLFxuICAgICAgICBcInN0cm9rZS1taXRlcmxpbWl0XCI6IFwic3Ryb2tlTWl0ZXJsaW1pdFwiLFxuICAgICAgICBzdHJva2V3aWR0aDogXCJzdHJva2VXaWR0aFwiLFxuICAgICAgICBcInN0cm9rZS13aWR0aFwiOiBcInN0cm9rZVdpZHRoXCIsXG4gICAgICAgIHN0cm9rZW9wYWNpdHk6IFwic3Ryb2tlT3BhY2l0eVwiLFxuICAgICAgICBcInN0cm9rZS1vcGFjaXR5XCI6IFwic3Ryb2tlT3BhY2l0eVwiLFxuICAgICAgICBzdXBwcmVzc2NvbnRlbnRlZGl0YWJsZXdhcm5pbmc6IFwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nXCIsXG4gICAgICAgIHN1cHByZXNzaHlkcmF0aW9ud2FybmluZzogXCJzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmdcIixcbiAgICAgICAgc3VyZmFjZXNjYWxlOiBcInN1cmZhY2VTY2FsZVwiLFxuICAgICAgICBzeXN0ZW1sYW5ndWFnZTogXCJzeXN0ZW1MYW5ndWFnZVwiLFxuICAgICAgICB0YWJsZXZhbHVlczogXCJ0YWJsZVZhbHVlc1wiLFxuICAgICAgICB0YXJnZXR4OiBcInRhcmdldFhcIixcbiAgICAgICAgdGFyZ2V0eTogXCJ0YXJnZXRZXCIsXG4gICAgICAgIHRleHRhbmNob3I6IFwidGV4dEFuY2hvclwiLFxuICAgICAgICBcInRleHQtYW5jaG9yXCI6IFwidGV4dEFuY2hvclwiLFxuICAgICAgICB0ZXh0ZGVjb3JhdGlvbjogXCJ0ZXh0RGVjb3JhdGlvblwiLFxuICAgICAgICBcInRleHQtZGVjb3JhdGlvblwiOiBcInRleHREZWNvcmF0aW9uXCIsXG4gICAgICAgIHRleHRsZW5ndGg6IFwidGV4dExlbmd0aFwiLFxuICAgICAgICB0ZXh0cmVuZGVyaW5nOiBcInRleHRSZW5kZXJpbmdcIixcbiAgICAgICAgXCJ0ZXh0LXJlbmRlcmluZ1wiOiBcInRleHRSZW5kZXJpbmdcIixcbiAgICAgICAgdG86IFwidG9cIixcbiAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zZm9ybVwiLFxuICAgICAgICB0cmFuc2Zvcm1vcmlnaW46IFwidHJhbnNmb3JtT3JpZ2luXCIsXG4gICAgICAgIFwidHJhbnNmb3JtLW9yaWdpblwiOiBcInRyYW5zZm9ybU9yaWdpblwiLFxuICAgICAgICB0eXBlb2Y6IFwidHlwZW9mXCIsXG4gICAgICAgIHUxOiBcInUxXCIsXG4gICAgICAgIHUyOiBcInUyXCIsXG4gICAgICAgIHVuZGVybGluZXBvc2l0aW9uOiBcInVuZGVybGluZVBvc2l0aW9uXCIsXG4gICAgICAgIFwidW5kZXJsaW5lLXBvc2l0aW9uXCI6IFwidW5kZXJsaW5lUG9zaXRpb25cIixcbiAgICAgICAgdW5kZXJsaW5ldGhpY2tuZXNzOiBcInVuZGVybGluZVRoaWNrbmVzc1wiLFxuICAgICAgICBcInVuZGVybGluZS10aGlja25lc3NcIjogXCJ1bmRlcmxpbmVUaGlja25lc3NcIixcbiAgICAgICAgdW5pY29kZTogXCJ1bmljb2RlXCIsXG4gICAgICAgIHVuaWNvZGViaWRpOiBcInVuaWNvZGVCaWRpXCIsXG4gICAgICAgIFwidW5pY29kZS1iaWRpXCI6IFwidW5pY29kZUJpZGlcIixcbiAgICAgICAgdW5pY29kZXJhbmdlOiBcInVuaWNvZGVSYW5nZVwiLFxuICAgICAgICBcInVuaWNvZGUtcmFuZ2VcIjogXCJ1bmljb2RlUmFuZ2VcIixcbiAgICAgICAgdW5pdHNwZXJlbTogXCJ1bml0c1BlckVtXCIsXG4gICAgICAgIFwidW5pdHMtcGVyLWVtXCI6IFwidW5pdHNQZXJFbVwiLFxuICAgICAgICB1bnNlbGVjdGFibGU6IFwidW5zZWxlY3RhYmxlXCIsXG4gICAgICAgIHZhbHBoYWJldGljOiBcInZBbHBoYWJldGljXCIsXG4gICAgICAgIFwidi1hbHBoYWJldGljXCI6IFwidkFscGhhYmV0aWNcIixcbiAgICAgICAgdmFsdWVzOiBcInZhbHVlc1wiLFxuICAgICAgICB2ZWN0b3JlZmZlY3Q6IFwidmVjdG9yRWZmZWN0XCIsXG4gICAgICAgIFwidmVjdG9yLWVmZmVjdFwiOiBcInZlY3RvckVmZmVjdFwiLFxuICAgICAgICB2ZXJzaW9uOiBcInZlcnNpb25cIixcbiAgICAgICAgdmVydGFkdnk6IFwidmVydEFkdllcIixcbiAgICAgICAgXCJ2ZXJ0LWFkdi15XCI6IFwidmVydEFkdllcIixcbiAgICAgICAgdmVydG9yaWdpbng6IFwidmVydE9yaWdpblhcIixcbiAgICAgICAgXCJ2ZXJ0LW9yaWdpbi14XCI6IFwidmVydE9yaWdpblhcIixcbiAgICAgICAgdmVydG9yaWdpbnk6IFwidmVydE9yaWdpbllcIixcbiAgICAgICAgXCJ2ZXJ0LW9yaWdpbi15XCI6IFwidmVydE9yaWdpbllcIixcbiAgICAgICAgdmhhbmdpbmc6IFwidkhhbmdpbmdcIixcbiAgICAgICAgXCJ2LWhhbmdpbmdcIjogXCJ2SGFuZ2luZ1wiLFxuICAgICAgICB2aWRlb2dyYXBoaWM6IFwidklkZW9ncmFwaGljXCIsXG4gICAgICAgIFwidi1pZGVvZ3JhcGhpY1wiOiBcInZJZGVvZ3JhcGhpY1wiLFxuICAgICAgICB2aWV3Ym94OiBcInZpZXdCb3hcIixcbiAgICAgICAgdmlld3RhcmdldDogXCJ2aWV3VGFyZ2V0XCIsXG4gICAgICAgIHZpc2liaWxpdHk6IFwidmlzaWJpbGl0eVwiLFxuICAgICAgICB2bWF0aGVtYXRpY2FsOiBcInZNYXRoZW1hdGljYWxcIixcbiAgICAgICAgXCJ2LW1hdGhlbWF0aWNhbFwiOiBcInZNYXRoZW1hdGljYWxcIixcbiAgICAgICAgdm9jYWI6IFwidm9jYWJcIixcbiAgICAgICAgd2lkdGhzOiBcIndpZHRoc1wiLFxuICAgICAgICB3b3Jkc3BhY2luZzogXCJ3b3JkU3BhY2luZ1wiLFxuICAgICAgICBcIndvcmQtc3BhY2luZ1wiOiBcIndvcmRTcGFjaW5nXCIsXG4gICAgICAgIHdyaXRpbmdtb2RlOiBcIndyaXRpbmdNb2RlXCIsXG4gICAgICAgIFwid3JpdGluZy1tb2RlXCI6IFwid3JpdGluZ01vZGVcIixcbiAgICAgICAgeDE6IFwieDFcIixcbiAgICAgICAgeDI6IFwieDJcIixcbiAgICAgICAgeDogXCJ4XCIsXG4gICAgICAgIHhjaGFubmVsc2VsZWN0b3I6IFwieENoYW5uZWxTZWxlY3RvclwiLFxuICAgICAgICB4aGVpZ2h0OiBcInhIZWlnaHRcIixcbiAgICAgICAgXCJ4LWhlaWdodFwiOiBcInhIZWlnaHRcIixcbiAgICAgICAgeGxpbmthY3R1YXRlOiBcInhsaW5rQWN0dWF0ZVwiLFxuICAgICAgICBcInhsaW5rOmFjdHVhdGVcIjogXCJ4bGlua0FjdHVhdGVcIixcbiAgICAgICAgeGxpbmthcmNyb2xlOiBcInhsaW5rQXJjcm9sZVwiLFxuICAgICAgICBcInhsaW5rOmFyY3JvbGVcIjogXCJ4bGlua0FyY3JvbGVcIixcbiAgICAgICAgeGxpbmtocmVmOiBcInhsaW5rSHJlZlwiLFxuICAgICAgICBcInhsaW5rOmhyZWZcIjogXCJ4bGlua0hyZWZcIixcbiAgICAgICAgeGxpbmtyb2xlOiBcInhsaW5rUm9sZVwiLFxuICAgICAgICBcInhsaW5rOnJvbGVcIjogXCJ4bGlua1JvbGVcIixcbiAgICAgICAgeGxpbmtzaG93OiBcInhsaW5rU2hvd1wiLFxuICAgICAgICBcInhsaW5rOnNob3dcIjogXCJ4bGlua1Nob3dcIixcbiAgICAgICAgeGxpbmt0aXRsZTogXCJ4bGlua1RpdGxlXCIsXG4gICAgICAgIFwieGxpbms6dGl0bGVcIjogXCJ4bGlua1RpdGxlXCIsXG4gICAgICAgIHhsaW5rdHlwZTogXCJ4bGlua1R5cGVcIixcbiAgICAgICAgXCJ4bGluazp0eXBlXCI6IFwieGxpbmtUeXBlXCIsXG4gICAgICAgIHhtbGJhc2U6IFwieG1sQmFzZVwiLFxuICAgICAgICBcInhtbDpiYXNlXCI6IFwieG1sQmFzZVwiLFxuICAgICAgICB4bWxsYW5nOiBcInhtbExhbmdcIixcbiAgICAgICAgXCJ4bWw6bGFuZ1wiOiBcInhtbExhbmdcIixcbiAgICAgICAgeG1sbnM6IFwieG1sbnNcIixcbiAgICAgICAgXCJ4bWw6c3BhY2VcIjogXCJ4bWxTcGFjZVwiLFxuICAgICAgICB4bWxuc3hsaW5rOiBcInhtbG5zWGxpbmtcIixcbiAgICAgICAgXCJ4bWxuczp4bGlua1wiOiBcInhtbG5zWGxpbmtcIixcbiAgICAgICAgeG1sc3BhY2U6IFwieG1sU3BhY2VcIixcbiAgICAgICAgeTE6IFwieTFcIixcbiAgICAgICAgeTI6IFwieTJcIixcbiAgICAgICAgeTogXCJ5XCIsXG4gICAgICAgIHljaGFubmVsc2VsZWN0b3I6IFwieUNoYW5uZWxTZWxlY3RvclwiLFxuICAgICAgICB6OiBcInpcIixcbiAgICAgICAgem9vbWFuZHBhbjogXCJ6b29tQW5kUGFuXCJcbiAgICAgIH0sXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzID0ge30sXG4gICAgICBFVkVOVF9OQU1FX1JFR0VYID0gL15vbi4vLFxuICAgICAgSU5WQUxJRF9FVkVOVF9OQU1FX1JFR0VYID0gL15vblteQS1aXS8sXG4gICAgICByQVJJQSA9IFJlZ0V4cChcbiAgICAgICAgXCJeKGFyaWEpLVs6QS1aX2EtelxcXFx1MDBDMC1cXFxcdTAwRDZcXFxcdTAwRDgtXFxcXHUwMEY2XFxcXHUwMEY4LVxcXFx1MDJGRlxcXFx1MDM3MC1cXFxcdTAzN0RcXFxcdTAzN0YtXFxcXHUxRkZGXFxcXHUyMDBDLVxcXFx1MjAwRFxcXFx1MjA3MC1cXFxcdTIxOEZcXFxcdTJDMDAtXFxcXHUyRkVGXFxcXHUzMDAxLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkZEXFxcXC0uMC05XFxcXHUwMEI3XFxcXHUwMzAwLVxcXFx1MDM2RlxcXFx1MjAzRi1cXFxcdTIwNDBdKiRcIlxuICAgICAgKSxcbiAgICAgIHJBUklBQ2FtZWwgPSBSZWdFeHAoXG4gICAgICAgIFwiXihhcmlhKVtBLVpdWzpBLVpfYS16XFxcXHUwMEMwLVxcXFx1MDBENlxcXFx1MDBEOC1cXFxcdTAwRjZcXFxcdTAwRjgtXFxcXHUwMkZGXFxcXHUwMzcwLVxcXFx1MDM3RFxcXFx1MDM3Ri1cXFxcdTFGRkZcXFxcdTIwMEMtXFxcXHUyMDBEXFxcXHUyMDcwLVxcXFx1MjE4RlxcXFx1MkMwMC1cXFxcdTJGRUZcXFxcdTMwMDEtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRkRcXFxcLS4wLTlcXFxcdTAwQjdcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUyMDNGLVxcXFx1MjA0MF0qJFwiXG4gICAgICApLFxuICAgICAgYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuID0gL14oPzp3ZWJraXR8bW96fG8pW0EtWl0vLFxuICAgICAgbXNQYXR0ZXJuJDEgPSAvXi1tcy0vLFxuICAgICAgaHlwaGVuUGF0dGVybiA9IC8tKC4pL2csXG4gICAgICBiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4gPSAvO1xccyokLyxcbiAgICAgIHdhcm5lZFN0eWxlTmFtZXMgPSB7fSxcbiAgICAgIHdhcm5lZFN0eWxlVmFsdWVzID0ge30sXG4gICAgICB3YXJuZWRGb3JOYU5WYWx1ZSA9ICExLFxuICAgICAgd2FybmVkRm9ySW5maW5pdHlWYWx1ZSA9ICExLFxuICAgICAgbWF0Y2hIdG1sUmVnRXhwID0gL1tcIicmPD5dLyxcbiAgICAgIHVwcGVyY2FzZVBhdHRlcm4gPSAvKFtBLVpdKS9nLFxuICAgICAgbXNQYXR0ZXJuID0gL15tcy0vLFxuICAgICAgaXNKYXZhU2NyaXB0UHJvdG9jb2wgPVxuICAgICAgICAvXltcXHUwMDAwLVxcdTAwMUYgXSpqW1xcclxcblxcdF0qYVtcXHJcXG5cXHRdKnZbXFxyXFxuXFx0XSphW1xcclxcblxcdF0qc1tcXHJcXG5cXHRdKmNbXFxyXFxuXFx0XSpyW1xcclxcblxcdF0qaVtcXHJcXG5cXHRdKnBbXFxyXFxuXFx0XSp0W1xcclxcblxcdF0qOi9pLFxuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPVxuICAgICAgICBSZWFjdC5fX0NMSUVOVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUsXG4gICAgICBSZWFjdERPTVNoYXJlZEludGVybmFscyA9XG4gICAgICAgIFJlYWN0RE9NLl9fRE9NX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERSxcbiAgICAgIE5vdFBlbmRpbmcgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgcGVuZGluZzogITEsXG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIG1ldGhvZDogbnVsbCxcbiAgICAgICAgYWN0aW9uOiBudWxsXG4gICAgICB9KSxcbiAgICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzLmQ7XG4gICAgUmVhY3RET01TaGFyZWRJbnRlcm5hbHMuZCA9IHtcbiAgICAgIGY6IHByZXZpb3VzRGlzcGF0Y2hlci5mLFxuICAgICAgcjogcHJldmlvdXNEaXNwYXRjaGVyLnIsXG4gICAgICBEOiBmdW5jdGlvbiAoaHJlZikge1xuICAgICAgICB2YXIgcmVxdWVzdCA9IGN1cnJlbnRSZXF1ZXN0ID8gY3VycmVudFJlcXVlc3QgOiBudWxsO1xuICAgICAgICBpZiAocmVxdWVzdCkge1xuICAgICAgICAgIHZhciByZXN1bWFibGVTdGF0ZSA9IHJlcXVlc3QucmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICByZW5kZXJTdGF0ZSA9IHJlcXVlc3QucmVuZGVyU3RhdGU7XG4gICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBocmVmICYmIGhyZWYpIHtcbiAgICAgICAgICAgIGlmICghcmVzdW1hYmxlU3RhdGUuZG5zUmVzb3VyY2VzLmhhc093blByb3BlcnR5KGhyZWYpKSB7XG4gICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLmRuc1Jlc291cmNlc1tocmVmXSA9IEVYSVNUUztcbiAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUgPSByZW5kZXJTdGF0ZS5oZWFkZXJzO1xuICAgICAgICAgICAgICB2YXIgaGVhZGVyLCBKU0NvbXBpbGVyX3RlbXA7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoSlNDb21waWxlcl90ZW1wID1cbiAgICAgICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlICYmIDAgPCByZXN1bWFibGVTdGF0ZS5yZW1haW5pbmdDYXBhY2l0eSlcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCA9XG4gICAgICAgICAgICAgICAgICAoKGhlYWRlciA9XG4gICAgICAgICAgICAgICAgICAgIFwiPFwiICtcbiAgICAgICAgICAgICAgICAgICAgZXNjYXBlSHJlZkZvckxpbmtIZWFkZXJVUkxDb250ZXh0KGhyZWYpICtcbiAgICAgICAgICAgICAgICAgICAgXCI+OyByZWw9ZG5zLXByZWZldGNoXCIpLFxuICAgICAgICAgICAgICAgICAgMCA8PSAocmVzdW1hYmxlU3RhdGUucmVtYWluaW5nQ2FwYWNpdHkgLT0gaGVhZGVyLmxlbmd0aCArIDIpKTtcbiAgICAgICAgICAgICAgSlNDb21waWxlcl90ZW1wXG4gICAgICAgICAgICAgICAgPyAoKHJlbmRlclN0YXRlLnJlc2V0cy5kbnNbaHJlZl0gPSBFWElTVFMpLFxuICAgICAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUucHJlY29ubmVjdHMgJiZcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VtYWJsZVN0YXRlLnByZWNvbm5lY3RzICs9IFwiLCBcIiksXG4gICAgICAgICAgICAgICAgICAocmVzdW1hYmxlU3RhdGUucHJlY29ubmVjdHMgKz0gaGVhZGVyKSlcbiAgICAgICAgICAgICAgICA6ICgoaGVhZGVyID0gW10pLFxuICAgICAgICAgICAgICAgICAgcHVzaExpbmtJbXBsKGhlYWRlciwgeyBocmVmOiBocmVmLCByZWw6IFwiZG5zLXByZWZldGNoXCIgfSksXG4gICAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5wcmVjb25uZWN0cy5hZGQoaGVhZGVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbnF1ZXVlRmx1c2gocmVxdWVzdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgcHJldmlvdXNEaXNwYXRjaGVyLkQoaHJlZik7XG4gICAgICB9LFxuICAgICAgQzogZnVuY3Rpb24gKGhyZWYsIGNyb3NzT3JpZ2luKSB7XG4gICAgICAgIHZhciByZXF1ZXN0ID0gY3VycmVudFJlcXVlc3QgPyBjdXJyZW50UmVxdWVzdCA6IG51bGw7XG4gICAgICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICAgICAgdmFyIHJlc3VtYWJsZVN0YXRlID0gcmVxdWVzdC5yZXN1bWFibGVTdGF0ZSxcbiAgICAgICAgICAgIHJlbmRlclN0YXRlID0gcmVxdWVzdC5yZW5kZXJTdGF0ZTtcbiAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGhyZWYgJiYgaHJlZikge1xuICAgICAgICAgICAgdmFyIGJ1Y2tldCA9XG4gICAgICAgICAgICAgIFwidXNlLWNyZWRlbnRpYWxzXCIgPT09IGNyb3NzT3JpZ2luXG4gICAgICAgICAgICAgICAgPyBcImNyZWRlbnRpYWxzXCJcbiAgICAgICAgICAgICAgICA6IFwic3RyaW5nXCIgPT09IHR5cGVvZiBjcm9zc09yaWdpblxuICAgICAgICAgICAgICAgICAgPyBcImFub255bW91c1wiXG4gICAgICAgICAgICAgICAgICA6IFwiZGVmYXVsdFwiO1xuICAgICAgICAgICAgaWYgKCFyZXN1bWFibGVTdGF0ZS5jb25uZWN0UmVzb3VyY2VzW2J1Y2tldF0uaGFzT3duUHJvcGVydHkoaHJlZikpIHtcbiAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUuY29ubmVjdFJlc291cmNlc1tidWNrZXRdW2hyZWZdID0gRVhJU1RTO1xuICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZSA9IHJlbmRlclN0YXRlLmhlYWRlcnM7XG4gICAgICAgICAgICAgIHZhciBoZWFkZXIsIEpTQ29tcGlsZXJfdGVtcDtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIChKU0NvbXBpbGVyX3RlbXAgPVxuICAgICAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUgJiYgMCA8IHJlc3VtYWJsZVN0YXRlLnJlbWFpbmluZ0NhcGFjaXR5KVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAgPVxuICAgICAgICAgICAgICAgICAgXCI8XCIgK1xuICAgICAgICAgICAgICAgICAgZXNjYXBlSHJlZkZvckxpbmtIZWFkZXJVUkxDb250ZXh0KGhyZWYpICtcbiAgICAgICAgICAgICAgICAgIFwiPjsgcmVsPXByZWNvbm5lY3RcIjtcbiAgICAgICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGNyb3NzT3JpZ2luKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZXNjYXBlZENyb3NzT3JpZ2luID1cbiAgICAgICAgICAgICAgICAgICAgZXNjYXBlU3RyaW5nRm9yTGlua0hlYWRlclF1b3RlZFBhcmFtVmFsdWVDb250ZXh0KFxuICAgICAgICAgICAgICAgICAgICAgIGNyb3NzT3JpZ2luLFxuICAgICAgICAgICAgICAgICAgICAgIFwiY3Jvc3NPcmlnaW5cIlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgSlNDb21waWxlcl90ZW1wICs9XG4gICAgICAgICAgICAgICAgICAgICc7IGNyb3Nzb3JpZ2luPVwiJyArIGVzY2FwZWRDcm9zc09yaWdpbiArICdcIic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCA9XG4gICAgICAgICAgICAgICAgICAoKGhlYWRlciA9IEpTQ29tcGlsZXJfdGVtcCksXG4gICAgICAgICAgICAgICAgICAwIDw9IChyZXN1bWFibGVTdGF0ZS5yZW1haW5pbmdDYXBhY2l0eSAtPSBoZWFkZXIubGVuZ3RoICsgMikpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcFxuICAgICAgICAgICAgICAgID8gKChyZW5kZXJTdGF0ZS5yZXNldHMuY29ubmVjdFtidWNrZXRdW2hyZWZdID0gRVhJU1RTKSxcbiAgICAgICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLnByZWNvbm5lY3RzICYmXG4gICAgICAgICAgICAgICAgICAgIChyZXN1bWFibGVTdGF0ZS5wcmVjb25uZWN0cyArPSBcIiwgXCIpLFxuICAgICAgICAgICAgICAgICAgKHJlc3VtYWJsZVN0YXRlLnByZWNvbm5lY3RzICs9IGhlYWRlcikpXG4gICAgICAgICAgICAgICAgOiAoKGJ1Y2tldCA9IFtdKSxcbiAgICAgICAgICAgICAgICAgIHB1c2hMaW5rSW1wbChidWNrZXQsIHtcbiAgICAgICAgICAgICAgICAgICAgcmVsOiBcInByZWNvbm5lY3RcIixcbiAgICAgICAgICAgICAgICAgICAgaHJlZjogaHJlZixcbiAgICAgICAgICAgICAgICAgICAgY3Jvc3NPcmlnaW46IGNyb3NzT3JpZ2luXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLnByZWNvbm5lY3RzLmFkZChidWNrZXQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVucXVldWVGbHVzaChyZXF1ZXN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBwcmV2aW91c0Rpc3BhdGNoZXIuQyhocmVmLCBjcm9zc09yaWdpbik7XG4gICAgICB9LFxuICAgICAgTDogZnVuY3Rpb24gKGhyZWYsIGFzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciByZXF1ZXN0ID0gY3VycmVudFJlcXVlc3QgPyBjdXJyZW50UmVxdWVzdCA6IG51bGw7XG4gICAgICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICAgICAgdmFyIHJlc3VtYWJsZVN0YXRlID0gcmVxdWVzdC5yZXN1bWFibGVTdGF0ZSxcbiAgICAgICAgICAgIHJlbmRlclN0YXRlID0gcmVxdWVzdC5yZW5kZXJTdGF0ZTtcbiAgICAgICAgICBpZiAoYXMgJiYgaHJlZikge1xuICAgICAgICAgICAgc3dpdGNoIChhcykge1xuICAgICAgICAgICAgICBjYXNlIFwiaW1hZ2VcIjpcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgdmFyIGltYWdlU3JjU2V0ID0gb3B0aW9ucy5pbWFnZVNyY1NldDtcbiAgICAgICAgICAgICAgICAgIHZhciBpbWFnZVNpemVzID0gb3B0aW9ucy5pbWFnZVNpemVzO1xuICAgICAgICAgICAgICAgICAgdmFyIGZldGNoUHJpb3JpdHkgPSBvcHRpb25zLmZldGNoUHJpb3JpdHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBpbWFnZVNyY1NldFxuICAgICAgICAgICAgICAgICAgPyBpbWFnZVNyY1NldCArIFwiXFxuXCIgKyAoaW1hZ2VTaXplcyB8fCBcIlwiKVxuICAgICAgICAgICAgICAgICAgOiBocmVmO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bWFibGVTdGF0ZS5pbWFnZVJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUuaW1hZ2VSZXNvdXJjZXNba2V5XSA9IFBSRUxPQURfTk9fQ1JFRFM7XG4gICAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUgPSByZW5kZXJTdGF0ZS5oZWFkZXJzO1xuICAgICAgICAgICAgICAgIHZhciBoZWFkZXI7XG4gICAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUgJiZcbiAgICAgICAgICAgICAgICAwIDwgcmVzdW1hYmxlU3RhdGUucmVtYWluaW5nQ2FwYWNpdHkgJiZcbiAgICAgICAgICAgICAgICBcImhpZ2hcIiA9PT0gZmV0Y2hQcmlvcml0eSAmJlxuICAgICAgICAgICAgICAgICgoaGVhZGVyID0gZ2V0UHJlbG9hZEFzSGVhZGVyKGhyZWYsIGFzLCBvcHRpb25zKSksXG4gICAgICAgICAgICAgICAgMCA8PSAocmVzdW1hYmxlU3RhdGUucmVtYWluaW5nQ2FwYWNpdHkgLT0gaGVhZGVyLmxlbmd0aCArIDIpKVxuICAgICAgICAgICAgICAgICAgPyAoKHJlbmRlclN0YXRlLnJlc2V0cy5pbWFnZVtrZXldID0gUFJFTE9BRF9OT19DUkVEUyksXG4gICAgICAgICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLmhpZ2hJbWFnZVByZWxvYWRzICYmXG4gICAgICAgICAgICAgICAgICAgICAgKHJlc3VtYWJsZVN0YXRlLmhpZ2hJbWFnZVByZWxvYWRzICs9IFwiLCBcIiksXG4gICAgICAgICAgICAgICAgICAgIChyZXN1bWFibGVTdGF0ZS5oaWdoSW1hZ2VQcmVsb2FkcyArPSBoZWFkZXIpKVxuICAgICAgICAgICAgICAgICAgOiAoKHJlc3VtYWJsZVN0YXRlID0gW10pLFxuICAgICAgICAgICAgICAgICAgICBwdXNoTGlua0ltcGwoXG4gICAgICAgICAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgYXNzaWduKFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZWw6IFwicHJlbG9hZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBocmVmOiBpbWFnZVNyY1NldCA/IHZvaWQgMCA6IGhyZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFzOiBhc1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIFwiaGlnaFwiID09PSBmZXRjaFByaW9yaXR5XG4gICAgICAgICAgICAgICAgICAgICAgPyByZW5kZXJTdGF0ZS5oaWdoSW1hZ2VQcmVsb2Fkcy5hZGQocmVzdW1hYmxlU3RhdGUpXG4gICAgICAgICAgICAgICAgICAgICAgOiAocmVuZGVyU3RhdGUuYnVsa1ByZWxvYWRzLmFkZChyZXN1bWFibGVTdGF0ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5wcmVsb2Fkcy5pbWFnZXMuc2V0KGtleSwgcmVzdW1hYmxlU3RhdGUpKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgICAgICAgICAgIGlmIChyZXN1bWFibGVTdGF0ZS5zdHlsZVJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShocmVmKSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGltYWdlU3JjU2V0ID0gW107XG4gICAgICAgICAgICAgICAgcHVzaExpbmtJbXBsKFxuICAgICAgICAgICAgICAgICAgaW1hZ2VTcmNTZXQsXG4gICAgICAgICAgICAgICAgICBhc3NpZ24oeyByZWw6IFwicHJlbG9hZFwiLCBocmVmOiBocmVmLCBhczogYXMgfSwgb3B0aW9ucylcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzW2hyZWZdID1cbiAgICAgICAgICAgICAgICAgICFvcHRpb25zIHx8XG4gICAgICAgICAgICAgICAgICAoXCJzdHJpbmdcIiAhPT0gdHlwZW9mIG9wdGlvbnMuY3Jvc3NPcmlnaW4gJiZcbiAgICAgICAgICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIG9wdGlvbnMuaW50ZWdyaXR5KVxuICAgICAgICAgICAgICAgICAgICA/IFBSRUxPQURfTk9fQ1JFRFNcbiAgICAgICAgICAgICAgICAgICAgOiBbb3B0aW9ucy5jcm9zc09yaWdpbiwgb3B0aW9ucy5pbnRlZ3JpdHldO1xuICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLnByZWxvYWRzLnN0eWxlc2hlZXRzLnNldChocmVmLCBpbWFnZVNyY1NldCk7XG4gICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuYnVsa1ByZWxvYWRzLmFkZChpbWFnZVNyY1NldCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJzY3JpcHRcIjpcbiAgICAgICAgICAgICAgICBpZiAocmVzdW1hYmxlU3RhdGUuc2NyaXB0UmVzb3VyY2VzLmhhc093blByb3BlcnR5KGhyZWYpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgaW1hZ2VTcmNTZXQgPSBbXTtcbiAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5wcmVsb2Fkcy5zY3JpcHRzLnNldChocmVmLCBpbWFnZVNyY1NldCk7XG4gICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuYnVsa1ByZWxvYWRzLmFkZChpbWFnZVNyY1NldCk7XG4gICAgICAgICAgICAgICAgcHVzaExpbmtJbXBsKFxuICAgICAgICAgICAgICAgICAgaW1hZ2VTcmNTZXQsXG4gICAgICAgICAgICAgICAgICBhc3NpZ24oeyByZWw6IFwicHJlbG9hZFwiLCBocmVmOiBocmVmLCBhczogYXMgfSwgb3B0aW9ucylcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLnNjcmlwdFJlc291cmNlc1tocmVmXSA9XG4gICAgICAgICAgICAgICAgICAhb3B0aW9ucyB8fFxuICAgICAgICAgICAgICAgICAgKFwic3RyaW5nXCIgIT09IHR5cGVvZiBvcHRpb25zLmNyb3NzT3JpZ2luICYmXG4gICAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgIT09IHR5cGVvZiBvcHRpb25zLmludGVncml0eSlcbiAgICAgICAgICAgICAgICAgICAgPyBQUkVMT0FEX05PX0NSRURTXG4gICAgICAgICAgICAgICAgICAgIDogW29wdGlvbnMuY3Jvc3NPcmlnaW4sIG9wdGlvbnMuaW50ZWdyaXR5XTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAocmVzdW1hYmxlU3RhdGUudW5rbm93blJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShhcykpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgKChpbWFnZVNyY1NldCA9IHJlc3VtYWJsZVN0YXRlLnVua25vd25SZXNvdXJjZXNbYXNdKSxcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VTcmNTZXQuaGFzT3duUHJvcGVydHkoaHJlZikpXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgIChpbWFnZVNyY1NldCA9IHt9KSxcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VtYWJsZVN0YXRlLnVua25vd25SZXNvdXJjZXNbYXNdID0gaW1hZ2VTcmNTZXQpO1xuICAgICAgICAgICAgICAgIGltYWdlU3JjU2V0W2hyZWZdID0gUFJFTE9BRF9OT19DUkVEUztcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAocmVzdW1hYmxlU3RhdGUgPSByZW5kZXJTdGF0ZS5oZWFkZXJzKSAmJlxuICAgICAgICAgICAgICAgICAgMCA8IHJlc3VtYWJsZVN0YXRlLnJlbWFpbmluZ0NhcGFjaXR5ICYmXG4gICAgICAgICAgICAgICAgICBcImZvbnRcIiA9PT0gYXMgJiZcbiAgICAgICAgICAgICAgICAgICgoa2V5ID0gZ2V0UHJlbG9hZEFzSGVhZGVyKGhyZWYsIGFzLCBvcHRpb25zKSksXG4gICAgICAgICAgICAgICAgICAwIDw9IChyZXN1bWFibGVTdGF0ZS5yZW1haW5pbmdDYXBhY2l0eSAtPSBrZXkubGVuZ3RoICsgMikpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgKHJlbmRlclN0YXRlLnJlc2V0cy5mb250W2hyZWZdID0gUFJFTE9BRF9OT19DUkVEUyksXG4gICAgICAgICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLmZvbnRQcmVsb2FkcyAmJlxuICAgICAgICAgICAgICAgICAgICAgIChyZXN1bWFibGVTdGF0ZS5mb250UHJlbG9hZHMgKz0gXCIsIFwiKSxcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VtYWJsZVN0YXRlLmZvbnRQcmVsb2FkcyArPSBrZXkpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgIHN3aXRjaCAoXG4gICAgICAgICAgICAgICAgICAgICgocmVzdW1hYmxlU3RhdGUgPSBbXSksXG4gICAgICAgICAgICAgICAgICAgIChocmVmID0gYXNzaWduKFxuICAgICAgICAgICAgICAgICAgICAgIHsgcmVsOiBcInByZWxvYWRcIiwgaHJlZjogaHJlZiwgYXM6IGFzIH0sXG4gICAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAgICAgcHVzaExpbmtJbXBsKHJlc3VtYWJsZVN0YXRlLCBocmVmKSxcbiAgICAgICAgICAgICAgICAgICAgYXMpXG4gICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImZvbnRcIjpcbiAgICAgICAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5mb250UHJlbG9hZHMuYWRkKHJlc3VtYWJsZVN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5idWxrUHJlbG9hZHMuYWRkKHJlc3VtYWJsZVN0YXRlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVucXVldWVGbHVzaChyZXF1ZXN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBwcmV2aW91c0Rpc3BhdGNoZXIuTChocmVmLCBhcywgb3B0aW9ucyk7XG4gICAgICB9LFxuICAgICAgbTogZnVuY3Rpb24gKGhyZWYsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJlcXVlc3QgPSBjdXJyZW50UmVxdWVzdCA/IGN1cnJlbnRSZXF1ZXN0IDogbnVsbDtcbiAgICAgICAgaWYgKHJlcXVlc3QpIHtcbiAgICAgICAgICB2YXIgcmVzdW1hYmxlU3RhdGUgPSByZXF1ZXN0LnJlc3VtYWJsZVN0YXRlLFxuICAgICAgICAgICAgcmVuZGVyU3RhdGUgPSByZXF1ZXN0LnJlbmRlclN0YXRlO1xuICAgICAgICAgIGlmIChocmVmKSB7XG4gICAgICAgICAgICB2YXIgYXMgPVxuICAgICAgICAgICAgICBvcHRpb25zICYmIFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLmFzID8gb3B0aW9ucy5hcyA6IFwic2NyaXB0XCI7XG4gICAgICAgICAgICBzd2l0Y2ggKGFzKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJzY3JpcHRcIjpcbiAgICAgICAgICAgICAgICBpZiAocmVzdW1hYmxlU3RhdGUubW9kdWxlU2NyaXB0UmVzb3VyY2VzLmhhc093blByb3BlcnR5KGhyZWYpKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGFzID0gW107XG4gICAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUubW9kdWxlU2NyaXB0UmVzb3VyY2VzW2hyZWZdID1cbiAgICAgICAgICAgICAgICAgICFvcHRpb25zIHx8XG4gICAgICAgICAgICAgICAgICAoXCJzdHJpbmdcIiAhPT0gdHlwZW9mIG9wdGlvbnMuY3Jvc3NPcmlnaW4gJiZcbiAgICAgICAgICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIG9wdGlvbnMuaW50ZWdyaXR5KVxuICAgICAgICAgICAgICAgICAgICA/IFBSRUxPQURfTk9fQ1JFRFNcbiAgICAgICAgICAgICAgICAgICAgOiBbb3B0aW9ucy5jcm9zc09yaWdpbiwgb3B0aW9ucy5pbnRlZ3JpdHldO1xuICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLnByZWxvYWRzLm1vZHVsZVNjcmlwdHMuc2V0KGhyZWYsIGFzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAocmVzdW1hYmxlU3RhdGUubW9kdWxlVW5rbm93blJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShhcykpIHtcbiAgICAgICAgICAgICAgICAgIHZhciByZXNvdXJjZXMgPSByZXN1bWFibGVTdGF0ZS51bmtub3duUmVzb3VyY2VzW2FzXTtcbiAgICAgICAgICAgICAgICAgIGlmIChyZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoaHJlZikpIHJldHVybjtcbiAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgIChyZXNvdXJjZXMgPSB7fSksXG4gICAgICAgICAgICAgICAgICAgIChyZXN1bWFibGVTdGF0ZS5tb2R1bGVVbmtub3duUmVzb3VyY2VzW2FzXSA9IHJlc291cmNlcyk7XG4gICAgICAgICAgICAgICAgYXMgPSBbXTtcbiAgICAgICAgICAgICAgICByZXNvdXJjZXNbaHJlZl0gPSBQUkVMT0FEX05PX0NSRURTO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHVzaExpbmtJbXBsKFxuICAgICAgICAgICAgICBhcyxcbiAgICAgICAgICAgICAgYXNzaWduKHsgcmVsOiBcIm1vZHVsZXByZWxvYWRcIiwgaHJlZjogaHJlZiB9LCBvcHRpb25zKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJlbmRlclN0YXRlLmJ1bGtQcmVsb2Fkcy5hZGQoYXMpO1xuICAgICAgICAgICAgZW5xdWV1ZUZsdXNoKHJlcXVlc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHByZXZpb3VzRGlzcGF0Y2hlci5tKGhyZWYsIG9wdGlvbnMpO1xuICAgICAgfSxcbiAgICAgIFg6IGZ1bmN0aW9uIChzcmMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJlcXVlc3QgPSBjdXJyZW50UmVxdWVzdCA/IGN1cnJlbnRSZXF1ZXN0IDogbnVsbDtcbiAgICAgICAgaWYgKHJlcXVlc3QpIHtcbiAgICAgICAgICB2YXIgcmVzdW1hYmxlU3RhdGUgPSByZXF1ZXN0LnJlc3VtYWJsZVN0YXRlLFxuICAgICAgICAgICAgcmVuZGVyU3RhdGUgPSByZXF1ZXN0LnJlbmRlclN0YXRlO1xuICAgICAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgICAgIHZhciByZXNvdXJjZVN0YXRlID0gcmVzdW1hYmxlU3RhdGUuc2NyaXB0UmVzb3VyY2VzLmhhc093blByb3BlcnR5KFxuICAgICAgICAgICAgICBzcmNcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgPyByZXN1bWFibGVTdGF0ZS5zY3JpcHRSZXNvdXJjZXNbc3JjXVxuICAgICAgICAgICAgICA6IHZvaWQgMDtcbiAgICAgICAgICAgIHJlc291cmNlU3RhdGUgIT09IEVYSVNUUyAmJlxuICAgICAgICAgICAgICAoKHJlc3VtYWJsZVN0YXRlLnNjcmlwdFJlc291cmNlc1tzcmNdID0gRVhJU1RTKSxcbiAgICAgICAgICAgICAgKG9wdGlvbnMgPSBhc3NpZ24oeyBzcmM6IHNyYywgYXN5bmM6ICEwIH0sIG9wdGlvbnMpKSxcbiAgICAgICAgICAgICAgcmVzb3VyY2VTdGF0ZSAmJlxuICAgICAgICAgICAgICAgICgyID09PSByZXNvdXJjZVN0YXRlLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgYWRvcHRQcmVsb2FkQ3JlZGVudGlhbHMob3B0aW9ucywgcmVzb3VyY2VTdGF0ZSksXG4gICAgICAgICAgICAgICAgKHNyYyA9IHJlbmRlclN0YXRlLnByZWxvYWRzLnNjcmlwdHMuZ2V0KHNyYykpKSAmJlxuICAgICAgICAgICAgICAgIChzcmMubGVuZ3RoID0gMCksXG4gICAgICAgICAgICAgIChzcmMgPSBbXSksXG4gICAgICAgICAgICAgIHJlbmRlclN0YXRlLnNjcmlwdHMuYWRkKHNyYyksXG4gICAgICAgICAgICAgIHB1c2hTY3JpcHRJbXBsKHNyYywgb3B0aW9ucyksXG4gICAgICAgICAgICAgIGVucXVldWVGbHVzaChyZXF1ZXN0KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgcHJldmlvdXNEaXNwYXRjaGVyLlgoc3JjLCBvcHRpb25zKTtcbiAgICAgIH0sXG4gICAgICBTOiBmdW5jdGlvbiAoaHJlZiwgcHJlY2VkZW5jZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgcmVxdWVzdCA9IGN1cnJlbnRSZXF1ZXN0ID8gY3VycmVudFJlcXVlc3QgOiBudWxsO1xuICAgICAgICBpZiAocmVxdWVzdCkge1xuICAgICAgICAgIHZhciByZXN1bWFibGVTdGF0ZSA9IHJlcXVlc3QucmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICByZW5kZXJTdGF0ZSA9IHJlcXVlc3QucmVuZGVyU3RhdGU7XG4gICAgICAgICAgaWYgKGhyZWYpIHtcbiAgICAgICAgICAgIHByZWNlZGVuY2UgPSBwcmVjZWRlbmNlIHx8IFwiZGVmYXVsdFwiO1xuICAgICAgICAgICAgdmFyIHN0eWxlUXVldWUgPSByZW5kZXJTdGF0ZS5zdHlsZXMuZ2V0KHByZWNlZGVuY2UpLFxuICAgICAgICAgICAgICByZXNvdXJjZVN0YXRlID0gcmVzdW1hYmxlU3RhdGUuc3R5bGVSZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoaHJlZilcbiAgICAgICAgICAgICAgICA/IHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzW2hyZWZdXG4gICAgICAgICAgICAgICAgOiB2b2lkIDA7XG4gICAgICAgICAgICByZXNvdXJjZVN0YXRlICE9PSBFWElTVFMgJiZcbiAgICAgICAgICAgICAgKChyZXN1bWFibGVTdGF0ZS5zdHlsZVJlc291cmNlc1tocmVmXSA9IEVYSVNUUyksXG4gICAgICAgICAgICAgIHN0eWxlUXVldWUgfHxcbiAgICAgICAgICAgICAgICAoKHN0eWxlUXVldWUgPSB7XG4gICAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKHByZWNlZGVuY2UpKSxcbiAgICAgICAgICAgICAgICAgIHJ1bGVzOiBbXSxcbiAgICAgICAgICAgICAgICAgIGhyZWZzOiBbXSxcbiAgICAgICAgICAgICAgICAgIHNoZWV0czogbmV3IE1hcCgpXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuc3R5bGVzLnNldChwcmVjZWRlbmNlLCBzdHlsZVF1ZXVlKSksXG4gICAgICAgICAgICAgIChwcmVjZWRlbmNlID0ge1xuICAgICAgICAgICAgICAgIHN0YXRlOiBQRU5ESU5HJDEsXG4gICAgICAgICAgICAgICAgcHJvcHM6IGFzc2lnbihcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcmVsOiBcInN0eWxlc2hlZXRcIixcbiAgICAgICAgICAgICAgICAgICAgaHJlZjogaHJlZixcbiAgICAgICAgICAgICAgICAgICAgXCJkYXRhLXByZWNlZGVuY2VcIjogcHJlY2VkZW5jZVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICByZXNvdXJjZVN0YXRlICYmXG4gICAgICAgICAgICAgICAgKDIgPT09IHJlc291cmNlU3RhdGUubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICBhZG9wdFByZWxvYWRDcmVkZW50aWFscyhwcmVjZWRlbmNlLnByb3BzLCByZXNvdXJjZVN0YXRlKSxcbiAgICAgICAgICAgICAgICAocmVuZGVyU3RhdGUgPSByZW5kZXJTdGF0ZS5wcmVsb2Fkcy5zdHlsZXNoZWV0cy5nZXQoaHJlZikpICYmXG4gICAgICAgICAgICAgICAgMCA8IHJlbmRlclN0YXRlLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgPyAocmVuZGVyU3RhdGUubGVuZ3RoID0gMClcbiAgICAgICAgICAgICAgICAgIDogKHByZWNlZGVuY2Uuc3RhdGUgPSBQUkVMT0FERUQpKSxcbiAgICAgICAgICAgICAgc3R5bGVRdWV1ZS5zaGVldHMuc2V0KGhyZWYsIHByZWNlZGVuY2UpLFxuICAgICAgICAgICAgICBlbnF1ZXVlRmx1c2gocmVxdWVzdCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHByZXZpb3VzRGlzcGF0Y2hlci5TKGhyZWYsIHByZWNlZGVuY2UsIG9wdGlvbnMpO1xuICAgICAgfSxcbiAgICAgIE06IGZ1bmN0aW9uIChzcmMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJlcXVlc3QgPSBjdXJyZW50UmVxdWVzdCA/IGN1cnJlbnRSZXF1ZXN0IDogbnVsbDtcbiAgICAgICAgaWYgKHJlcXVlc3QpIHtcbiAgICAgICAgICB2YXIgcmVzdW1hYmxlU3RhdGUgPSByZXF1ZXN0LnJlc3VtYWJsZVN0YXRlLFxuICAgICAgICAgICAgcmVuZGVyU3RhdGUgPSByZXF1ZXN0LnJlbmRlclN0YXRlO1xuICAgICAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgICAgIHZhciByZXNvdXJjZVN0YXRlID1cbiAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUubW9kdWxlU2NyaXB0UmVzb3VyY2VzLmhhc093blByb3BlcnR5KHNyYylcbiAgICAgICAgICAgICAgICA/IHJlc3VtYWJsZVN0YXRlLm1vZHVsZVNjcmlwdFJlc291cmNlc1tzcmNdXG4gICAgICAgICAgICAgICAgOiB2b2lkIDA7XG4gICAgICAgICAgICByZXNvdXJjZVN0YXRlICE9PSBFWElTVFMgJiZcbiAgICAgICAgICAgICAgKChyZXN1bWFibGVTdGF0ZS5tb2R1bGVTY3JpcHRSZXNvdXJjZXNbc3JjXSA9IEVYSVNUUyksXG4gICAgICAgICAgICAgIChvcHRpb25zID0gYXNzaWduKFxuICAgICAgICAgICAgICAgIHsgc3JjOiBzcmMsIHR5cGU6IFwibW9kdWxlXCIsIGFzeW5jOiAhMCB9LFxuICAgICAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIHJlc291cmNlU3RhdGUgJiZcbiAgICAgICAgICAgICAgICAoMiA9PT0gcmVzb3VyY2VTdGF0ZS5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgIGFkb3B0UHJlbG9hZENyZWRlbnRpYWxzKG9wdGlvbnMsIHJlc291cmNlU3RhdGUpLFxuICAgICAgICAgICAgICAgIChzcmMgPSByZW5kZXJTdGF0ZS5wcmVsb2Fkcy5tb2R1bGVTY3JpcHRzLmdldChzcmMpKSkgJiZcbiAgICAgICAgICAgICAgICAoc3JjLmxlbmd0aCA9IDApLFxuICAgICAgICAgICAgICAoc3JjID0gW10pLFxuICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5zY3JpcHRzLmFkZChzcmMpLFxuICAgICAgICAgICAgICBwdXNoU2NyaXB0SW1wbChzcmMsIG9wdGlvbnMpLFxuICAgICAgICAgICAgICBlbnF1ZXVlRmx1c2gocmVxdWVzdCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHByZXZpb3VzRGlzcGF0Y2hlci5NKHNyYywgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgTm90aGluZ1NlbnQgPSAwLFxuICAgICAgU2VudENvbXBsZXRlU2VnbWVudEZ1bmN0aW9uID0gMSxcbiAgICAgIFNlbnRDb21wbGV0ZUJvdW5kYXJ5RnVuY3Rpb24gPSAyLFxuICAgICAgU2VudENsaWVudFJlbmRlckZ1bmN0aW9uID0gNCxcbiAgICAgIFNlbnRTdHlsZUluc2VydGlvbkZ1bmN0aW9uID0gOCxcbiAgICAgIEVYSVNUUyA9IG51bGwsXG4gICAgICBQUkVMT0FEX05PX0NSRURTID0gW107XG4gICAgT2JqZWN0LmZyZWV6ZShQUkVMT0FEX05PX0NSRURTKTtcbiAgICBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiPjwvdGVtcGxhdGU+Jyk7XG4gICAgdmFyIHN0YXJ0SW5saW5lU2NyaXB0ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFwiPHNjcmlwdD5cIiksXG4gICAgICBlbmRJbmxpbmVTY3JpcHQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCJcXHgzYy9zY3JpcHQ+XCIpLFxuICAgICAgc3RhcnRTY3JpcHRTcmMgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzxzY3JpcHQgc3JjPVwiJyksXG4gICAgICBzdGFydE1vZHVsZVNyYyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHNjcmlwdCB0eXBlPVwibW9kdWxlXCIgc3JjPVwiJyksXG4gICAgICBzY3JpcHROb25jZSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIgbm9uY2U9XCInKSxcbiAgICAgIHNjcmlwdEludGVnaXJ0eSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIgaW50ZWdyaXR5PVwiJyksXG4gICAgICBzY3JpcHRDcm9zc09yaWdpbiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIgY3Jvc3NvcmlnaW49XCInKSxcbiAgICAgIGVuZEFzeW5jU2NyaXB0ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIiBhc3luYz1cIlwiPlxceDNjL3NjcmlwdD4nKSxcbiAgICAgIHNjcmlwdFJlZ2V4ID0gLyg8XFwvfDwpKHMpKGNyaXB0KS9naSxcbiAgICAgIGltcG9ydE1hcFNjcmlwdFN0YXJ0ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFxuICAgICAgICAnPHNjcmlwdCB0eXBlPVwiaW1wb3J0bWFwXCI+J1xuICAgICAgKSxcbiAgICAgIGltcG9ydE1hcFNjcmlwdEVuZCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcIlxceDNjL3NjcmlwdD5cIik7XG4gICAgdmFyIGRpZFdhcm5Gb3JOZXdCb29sZWFuUHJvcHNXaXRoRW1wdHlWYWx1ZSA9IHt9O1xuICAgIHZhciBST09UX0hUTUxfTU9ERSA9IDAsXG4gICAgICBIVE1MX0hUTUxfTU9ERSA9IDEsXG4gICAgICBIVE1MX01PREUgPSAyLFxuICAgICAgU1ZHX01PREUgPSAzLFxuICAgICAgTUFUSE1MX01PREUgPSA0LFxuICAgICAgSFRNTF9UQUJMRV9NT0RFID0gNSxcbiAgICAgIEhUTUxfVEFCTEVfQk9EWV9NT0RFID0gNixcbiAgICAgIEhUTUxfVEFCTEVfUk9XX01PREUgPSA3LFxuICAgICAgSFRNTF9DT0xHUk9VUF9NT0RFID0gOCxcbiAgICAgIHRleHRTZXBhcmF0b3IgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCJcXHgzYyEtLSAtLVxceDNlXCIpLFxuICAgICAgc3R5bGVOYW1lQ2FjaGUgPSBuZXcgTWFwKCksXG4gICAgICBzdHlsZUF0dHJpYnV0ZVN0YXJ0ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCcgc3R5bGU9XCInKSxcbiAgICAgIHN0eWxlQXNzaWduID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFwiOlwiKSxcbiAgICAgIHN0eWxlU2VwYXJhdG9yID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFwiO1wiKSxcbiAgICAgIGF0dHJpYnV0ZVNlcGFyYXRvciA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcIiBcIiksXG4gICAgICBhdHRyaWJ1dGVBc3NpZ24gPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJz1cIicpLFxuICAgICAgYXR0cmlidXRlRW5kID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIicpLFxuICAgICAgYXR0cmlidXRlRW1wdHlTdHJpbmcgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJz1cIlwiJyksXG4gICAgICBhY3Rpb25KYXZhU2NyaXB0VVJMID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFxuICAgICAgICBlc2NhcGVUZXh0Rm9yQnJvd3NlcihcbiAgICAgICAgICBcImphdmFzY3JpcHQ6dGhyb3cgbmV3IEVycm9yKCdSZWFjdCBmb3JtIHVuZXhwZWN0ZWRseSBzdWJtaXR0ZWQuJylcIlxuICAgICAgICApXG4gICAgICApLFxuICAgICAgc3RhcnRIaWRkZW5JbnB1dENodW5rID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8aW5wdXQgdHlwZT1cImhpZGRlblwiJyksXG4gICAgICBlbmRPZlN0YXJ0VGFnID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFwiPlwiKSxcbiAgICAgIGVuZE9mU3RhcnRUYWdTZWxmQ2xvc2luZyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcIi8+XCIpLFxuICAgICAgZGlkV2FybkRlZmF1bHRJbnB1dFZhbHVlID0gITEsXG4gICAgICBkaWRXYXJuRGVmYXVsdENoZWNrZWQgPSAhMSxcbiAgICAgIGRpZFdhcm5EZWZhdWx0U2VsZWN0VmFsdWUgPSAhMSxcbiAgICAgIGRpZFdhcm5EZWZhdWx0VGV4dGFyZWFWYWx1ZSA9ICExLFxuICAgICAgZGlkV2FybkludmFsaWRPcHRpb25DaGlsZHJlbiA9ICExLFxuICAgICAgZGlkV2FybkludmFsaWRPcHRpb25Jbm5lckhUTUwgPSAhMSxcbiAgICAgIGRpZFdhcm5TZWxlY3RlZFNldE9uT3B0aW9uID0gITEsXG4gICAgICBkaWRXYXJuRm9ybUFjdGlvblR5cGUgPSAhMSxcbiAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uTmFtZSA9ICExLFxuICAgICAgZGlkV2FybkZvcm1BY3Rpb25UYXJnZXQgPSAhMSxcbiAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uTWV0aG9kID0gITEsXG4gICAgICBzZWxlY3RlZE1hcmtlckF0dHJpYnV0ZSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnIHNlbGVjdGVkPVwiXCInKSxcbiAgICAgIGZvcm1SZXBsYXlpbmdSdW50aW1lU2NyaXB0ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFxuICAgICAgICAnYWRkRXZlbnRMaXN0ZW5lcihcInN1Ym1pdFwiLGZ1bmN0aW9uKGEpe2lmKCFhLmRlZmF1bHRQcmV2ZW50ZWQpe3ZhciBjPWEudGFyZ2V0LGQ9YS5zdWJtaXR0ZXIsZT1jLmFjdGlvbixiPWQ7aWYoZCl7dmFyIGY9ZC5nZXRBdHRyaWJ1dGUoXCJmb3JtQWN0aW9uXCIpO251bGwhPWYmJihlPWYsYj1udWxsKX1cImphdmFzY3JpcHQ6dGhyb3cgbmV3IEVycm9yKFxcJ1JlYWN0IGZvcm0gdW5leHBlY3RlZGx5IHN1Ym1pdHRlZC5cXCcpXCI9PT1lJiYoYS5wcmV2ZW50RGVmYXVsdCgpLGI/KGE9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpLGEubmFtZT1iLm5hbWUsYS52YWx1ZT1iLnZhbHVlLGIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYSxiKSxiPW5ldyBGb3JtRGF0YShjKSxhLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYSkpOmI9bmV3IEZvcm1EYXRhKGMpLGE9Yy5vd25lckRvY3VtZW50fHxjLChhLiQkcmVhY3RGb3JtUmVwbGF5PWEuJCRyZWFjdEZvcm1SZXBsYXl8fFtdKS5wdXNoKGMsZCxiKSl9fSk7J1xuICAgICAgKSxcbiAgICAgIGZvcm1TdGF0ZU1hcmtlcklzTWF0Y2hpbmcgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCJcXHgzYyEtLUYhLS1cXHgzZVwiKSxcbiAgICAgIGZvcm1TdGF0ZU1hcmtlcklzTm90TWF0Y2hpbmcgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCJcXHgzYyEtLUYtLVxceDNlXCIpLFxuICAgICAgc3R5bGVSZWdleCA9IC8oPFxcL3w8KShzKSh0eWxlKS9naSxcbiAgICAgIGxlYWRpbmdOZXdsaW5lID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFwiXFxuXCIpLFxuICAgICAgVkFMSURfVEFHX1JFR0VYID0gL15bYS16QS1aXVthLXpBLVo6X1xcLlxcLVxcZF0qJC8sXG4gICAgICB2YWxpZGF0ZWRUYWdDYWNoZSA9IG5ldyBNYXAoKSxcbiAgICAgIGRvY3R5cGVDaHVuayA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcIjwhRE9DVFlQRSBodG1sPlwiKSxcbiAgICAgIGVuZFRhZ0NhY2hlID0gbmV3IE1hcCgpLFxuICAgICAgcGxhY2Vob2xkZXIxID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8dGVtcGxhdGUgaWQ9XCInKSxcbiAgICAgIHBsYWNlaG9sZGVyMiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+PC90ZW1wbGF0ZT4nKSxcbiAgICAgIHN0YXJ0Q29tcGxldGVkU3VzcGVuc2VCb3VuZGFyeSA9XG4gICAgICAgIHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcIlxceDNjIS0tJC0tXFx4M2VcIiksXG4gICAgICBzdGFydFBlbmRpbmdTdXNwZW5zZUJvdW5kYXJ5MSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcbiAgICAgICAgJ1xceDNjIS0tJD8tLVxceDNlPHRlbXBsYXRlIGlkPVwiJ1xuICAgICAgKSxcbiAgICAgIHN0YXJ0UGVuZGluZ1N1c3BlbnNlQm91bmRhcnkyID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIj48L3RlbXBsYXRlPicpLFxuICAgICAgc3RhcnRDbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnkgPVxuICAgICAgICBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCJcXHgzYyEtLSQhLS1cXHgzZVwiKSxcbiAgICAgIGVuZFN1c3BlbnNlQm91bmRhcnkgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCJcXHgzYyEtLS8kLS1cXHgzZVwiKSxcbiAgICAgIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMSA9XG4gICAgICAgIHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcIjx0ZW1wbGF0ZVwiKSxcbiAgICAgIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yQXR0ckludGVyc3RpdGlhbCA9XG4gICAgICAgIHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCInKSxcbiAgICAgIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMUEgPVxuICAgICAgICBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJyBkYXRhLWRnc3Q9XCInKSxcbiAgICAgIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMUIgPVxuICAgICAgICBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJyBkYXRhLW1zZz1cIicpLFxuICAgICAgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxQyA9XG4gICAgICAgIHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnIGRhdGEtc3Rjaz1cIicpLFxuICAgICAgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxRCA9XG4gICAgICAgIHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnIGRhdGEtY3N0Y2s9XCInKSxcbiAgICAgIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMiA9XG4gICAgICAgIHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcIj48L3RlbXBsYXRlPlwiKSxcbiAgICAgIHN0YXJ0U2VnbWVudEhUTUwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzxkaXYgaGlkZGVuIGlkPVwiJyksXG4gICAgICBzdGFydFNlZ21lbnRIVE1MMiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+JyksXG4gICAgICBlbmRTZWdtZW50SFRNTCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcIjwvZGl2PlwiKSxcbiAgICAgIHN0YXJ0U2VnbWVudFNWRyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcbiAgICAgICAgJzxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgc3R5bGU9XCJkaXNwbGF5Om5vbmVcIiBpZD1cIidcbiAgICAgICksXG4gICAgICBzdGFydFNlZ21lbnRTVkcyID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIj4nKSxcbiAgICAgIGVuZFNlZ21lbnRTVkcgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCI8L3N2Zz5cIiksXG4gICAgICBzdGFydFNlZ21lbnRNYXRoTUwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXG4gICAgICAgICc8bWF0aCBhcmlhLWhpZGRlbj1cInRydWVcIiBzdHlsZT1cImRpc3BsYXk6bm9uZVwiIGlkPVwiJ1xuICAgICAgKSxcbiAgICAgIHN0YXJ0U2VnbWVudE1hdGhNTDIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiPicpLFxuICAgICAgZW5kU2VnbWVudE1hdGhNTCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcIjwvbWF0aD5cIiksXG4gICAgICBzdGFydFNlZ21lbnRUYWJsZSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHRhYmxlIGhpZGRlbiBpZD1cIicpLFxuICAgICAgc3RhcnRTZWdtZW50VGFibGUyID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIj4nKSxcbiAgICAgIGVuZFNlZ21lbnRUYWJsZSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcIjwvdGFibGU+XCIpLFxuICAgICAgc3RhcnRTZWdtZW50VGFibGVCb2R5ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFxuICAgICAgICAnPHRhYmxlIGhpZGRlbj48dGJvZHkgaWQ9XCInXG4gICAgICApLFxuICAgICAgc3RhcnRTZWdtZW50VGFibGVCb2R5MiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+JyksXG4gICAgICBlbmRTZWdtZW50VGFibGVCb2R5ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFwiPC90Ym9keT48L3RhYmxlPlwiKSxcbiAgICAgIHN0YXJ0U2VnbWVudFRhYmxlUm93ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8dGFibGUgaGlkZGVuPjx0ciBpZD1cIicpLFxuICAgICAgc3RhcnRTZWdtZW50VGFibGVSb3cyID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIj4nKSxcbiAgICAgIGVuZFNlZ21lbnRUYWJsZVJvdyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcIjwvdHI+PC90YWJsZT5cIiksXG4gICAgICBzdGFydFNlZ21lbnRDb2xHcm91cCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcbiAgICAgICAgJzx0YWJsZSBoaWRkZW4+PGNvbGdyb3VwIGlkPVwiJ1xuICAgICAgKSxcbiAgICAgIHN0YXJ0U2VnbWVudENvbEdyb3VwMiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+JyksXG4gICAgICBlbmRTZWdtZW50Q29sR3JvdXAgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCI8L2NvbGdyb3VwPjwvdGFibGU+XCIpLFxuICAgICAgY29tcGxldGVTZWdtZW50U2NyaXB0MUZ1bGwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXG4gICAgICAgICckUlM9ZnVuY3Rpb24oYSxiKXthPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGEpO2I9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYik7Zm9yKGEucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChhKTthLmZpcnN0Q2hpbGQ7KWIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYS5maXJzdENoaWxkLGIpO2IucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChiKX07JFJTKFwiJ1xuICAgICAgKSxcbiAgICAgIGNvbXBsZXRlU2VnbWVudFNjcmlwdDFQYXJ0aWFsID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCckUlMoXCInKSxcbiAgICAgIGNvbXBsZXRlU2VnbWVudFNjcmlwdDIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiLFwiJyksXG4gICAgICBjb21wbGV0ZVNlZ21lbnRTY3JpcHRFbmQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiKVxceDNjL3NjcmlwdD4nKTtcbiAgICBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzx0ZW1wbGF0ZSBkYXRhLXJzaT1cIlwiIGRhdGEtc2lkPVwiJyk7XG4gICAgc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIiBkYXRhLXBpZD1cIicpO1xuICAgIHZhciBjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0MUZ1bGwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXG4gICAgICAgICckUkM9ZnVuY3Rpb24oYixjLGUpe2M9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYyk7Yy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGMpO3ZhciBhPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGIpO2lmKGEpe2I9YS5wcmV2aW91c1NpYmxpbmc7aWYoZSliLmRhdGE9XCIkIVwiLGEuc2V0QXR0cmlidXRlKFwiZGF0YS1kZ3N0XCIsZSk7ZWxzZXtlPWIucGFyZW50Tm9kZTthPWIubmV4dFNpYmxpbmc7dmFyIGY9MDtkb3tpZihhJiY4PT09YS5ub2RlVHlwZSl7dmFyIGQ9YS5kYXRhO2lmKFwiLyRcIj09PWQpaWYoMD09PWYpYnJlYWs7ZWxzZSBmLS07ZWxzZVwiJFwiIT09ZCYmXCIkP1wiIT09ZCYmXCIkIVwiIT09ZHx8ZisrfWQ9YS5uZXh0U2libGluZztlLnJlbW92ZUNoaWxkKGEpO2E9ZH13aGlsZShhKTtmb3IoO2MuZmlyc3RDaGlsZDspZS5pbnNlcnRCZWZvcmUoYy5maXJzdENoaWxkLGEpO2IuZGF0YT1cIiRcIn1iLl9yZWFjdFJldHJ5JiZiLl9yZWFjdFJldHJ5KCl9fTskUkMoXCInXG4gICAgICApLFxuICAgICAgY29tcGxldGVCb3VuZGFyeVNjcmlwdDFQYXJ0aWFsID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCckUkMoXCInKSxcbiAgICAgIGNvbXBsZXRlQm91bmRhcnlXaXRoU3R5bGVzU2NyaXB0MUZ1bGxCb3RoID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFxuICAgICAgICAnJFJDPWZ1bmN0aW9uKGIsYyxlKXtjPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGMpO2MucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjKTt2YXIgYT1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChiKTtpZihhKXtiPWEucHJldmlvdXNTaWJsaW5nO2lmKGUpYi5kYXRhPVwiJCFcIixhLnNldEF0dHJpYnV0ZShcImRhdGEtZGdzdFwiLGUpO2Vsc2V7ZT1iLnBhcmVudE5vZGU7YT1iLm5leHRTaWJsaW5nO3ZhciBmPTA7ZG97aWYoYSYmOD09PWEubm9kZVR5cGUpe3ZhciBkPWEuZGF0YTtpZihcIi8kXCI9PT1kKWlmKDA9PT1mKWJyZWFrO2Vsc2UgZi0tO2Vsc2VcIiRcIiE9PWQmJlwiJD9cIiE9PWQmJlwiJCFcIiE9PWR8fGYrK31kPWEubmV4dFNpYmxpbmc7ZS5yZW1vdmVDaGlsZChhKTthPWR9d2hpbGUoYSk7Zm9yKDtjLmZpcnN0Q2hpbGQ7KWUuaW5zZXJ0QmVmb3JlKGMuZmlyc3RDaGlsZCxhKTtiLmRhdGE9XCIkXCJ9Yi5fcmVhY3RSZXRyeSYmYi5fcmVhY3RSZXRyeSgpfX07JFJNPW5ldyBNYXA7XFxuJFJSPWZ1bmN0aW9uKHQsdSx5KXtmdW5jdGlvbiB2KG4pe3RoaXMuX3A9bnVsbDtuKCl9Zm9yKHZhciB3PSRSQyxwPSRSTSxxPW5ldyBNYXAscj1kb2N1bWVudCxnLGIsaD1yLnF1ZXJ5U2VsZWN0b3JBbGwoXCJsaW5rW2RhdGEtcHJlY2VkZW5jZV0sc3R5bGVbZGF0YS1wcmVjZWRlbmNlXVwiKSx4PVtdLGs9MDtiPWhbaysrXTspXCJub3QgYWxsXCI9PT1iLmdldEF0dHJpYnV0ZShcIm1lZGlhXCIpP3gucHVzaChiKTooXCJMSU5LXCI9PT1iLnRhZ05hbWUmJnAuc2V0KGIuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSxiKSxxLnNldChiLmRhdGFzZXQucHJlY2VkZW5jZSxnPWIpKTtiPTA7aD1bXTt2YXIgbCxhO2ZvcihrPSEwOzspe2lmKGspe3ZhciBlPXlbYisrXTtpZighZSl7az0hMTtiPTA7Y29udGludWV9dmFyIGM9ITEsbT0wO3ZhciBkPWVbbSsrXTtpZihhPXAuZ2V0KGQpKXt2YXIgZj1hLl9wO2M9ITB9ZWxzZXthPXIuY3JlYXRlRWxlbWVudChcImxpbmtcIik7YS5ocmVmPVxcbmQ7YS5yZWw9XCJzdHlsZXNoZWV0XCI7Zm9yKGEuZGF0YXNldC5wcmVjZWRlbmNlPWw9ZVttKytdO2Y9ZVttKytdOylhLnNldEF0dHJpYnV0ZShmLGVbbSsrXSk7Zj1hLl9wPW5ldyBQcm9taXNlKGZ1bmN0aW9uKG4seil7YS5vbmxvYWQ9di5iaW5kKGEsbik7YS5vbmVycm9yPXYuYmluZChhLHopfSk7cC5zZXQoZCxhKX1kPWEuZ2V0QXR0cmlidXRlKFwibWVkaWFcIik7IWZ8fGQmJiFtYXRjaE1lZGlhKGQpLm1hdGNoZXN8fGgucHVzaChmKTtpZihjKWNvbnRpbnVlfWVsc2V7YT14W2IrK107aWYoIWEpYnJlYWs7bD1hLmdldEF0dHJpYnV0ZShcImRhdGEtcHJlY2VkZW5jZVwiKTthLnJlbW92ZUF0dHJpYnV0ZShcIm1lZGlhXCIpfWM9cS5nZXQobCl8fGc7Yz09PWcmJihnPWEpO3Euc2V0KGwsYSk7Yz9jLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGEsYy5uZXh0U2libGluZyk6KGM9ci5oZWFkLGMuaW5zZXJ0QmVmb3JlKGEsYy5maXJzdENoaWxkKSl9UHJvbWlzZS5hbGwoaCkudGhlbih3LmJpbmQobnVsbCxcXG50LHUsXCJcIiksdy5iaW5kKG51bGwsdCx1LFwiUmVzb3VyY2UgZmFpbGVkIHRvIGxvYWRcIikpfTskUlIoXCInXG4gICAgICApLFxuICAgICAgY29tcGxldGVCb3VuZGFyeVdpdGhTdHlsZXNTY3JpcHQxRnVsbFBhcnRpYWwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXG4gICAgICAgICckUk09bmV3IE1hcDtcXG4kUlI9ZnVuY3Rpb24odCx1LHkpe2Z1bmN0aW9uIHYobil7dGhpcy5fcD1udWxsO24oKX1mb3IodmFyIHc9JFJDLHA9JFJNLHE9bmV3IE1hcCxyPWRvY3VtZW50LGcsYixoPXIucXVlcnlTZWxlY3RvckFsbChcImxpbmtbZGF0YS1wcmVjZWRlbmNlXSxzdHlsZVtkYXRhLXByZWNlZGVuY2VdXCIpLHg9W10saz0wO2I9aFtrKytdOylcIm5vdCBhbGxcIj09PWIuZ2V0QXR0cmlidXRlKFwibWVkaWFcIik/eC5wdXNoKGIpOihcIkxJTktcIj09PWIudGFnTmFtZSYmcC5zZXQoYi5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpLGIpLHEuc2V0KGIuZGF0YXNldC5wcmVjZWRlbmNlLGc9YikpO2I9MDtoPVtdO3ZhciBsLGE7Zm9yKGs9ITA7Oyl7aWYoayl7dmFyIGU9eVtiKytdO2lmKCFlKXtrPSExO2I9MDtjb250aW51ZX12YXIgYz0hMSxtPTA7dmFyIGQ9ZVttKytdO2lmKGE9cC5nZXQoZCkpe3ZhciBmPWEuX3A7Yz0hMH1lbHNle2E9ci5jcmVhdGVFbGVtZW50KFwibGlua1wiKTthLmhyZWY9XFxuZDthLnJlbD1cInN0eWxlc2hlZXRcIjtmb3IoYS5kYXRhc2V0LnByZWNlZGVuY2U9bD1lW20rK107Zj1lW20rK107KWEuc2V0QXR0cmlidXRlKGYsZVttKytdKTtmPWEuX3A9bmV3IFByb21pc2UoZnVuY3Rpb24obix6KXthLm9ubG9hZD12LmJpbmQoYSxuKTthLm9uZXJyb3I9di5iaW5kKGEseil9KTtwLnNldChkLGEpfWQ9YS5nZXRBdHRyaWJ1dGUoXCJtZWRpYVwiKTshZnx8ZCYmIW1hdGNoTWVkaWEoZCkubWF0Y2hlc3x8aC5wdXNoKGYpO2lmKGMpY29udGludWV9ZWxzZXthPXhbYisrXTtpZighYSlicmVhaztsPWEuZ2V0QXR0cmlidXRlKFwiZGF0YS1wcmVjZWRlbmNlXCIpO2EucmVtb3ZlQXR0cmlidXRlKFwibWVkaWFcIil9Yz1xLmdldChsKXx8ZztjPT09ZyYmKGc9YSk7cS5zZXQobCxhKTtjP2MucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYSxjLm5leHRTaWJsaW5nKTooYz1yLmhlYWQsYy5pbnNlcnRCZWZvcmUoYSxjLmZpcnN0Q2hpbGQpKX1Qcm9taXNlLmFsbChoKS50aGVuKHcuYmluZChudWxsLFxcbnQsdSxcIlwiKSx3LmJpbmQobnVsbCx0LHUsXCJSZXNvdXJjZSBmYWlsZWQgdG8gbG9hZFwiKSl9OyRSUihcIidcbiAgICAgICksXG4gICAgICBjb21wbGV0ZUJvdW5kYXJ5V2l0aFN0eWxlc1NjcmlwdDFQYXJ0aWFsID1cbiAgICAgICAgc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCckUlIoXCInKSxcbiAgICAgIGNvbXBsZXRlQm91bmRhcnlTY3JpcHQyID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIixcIicpLFxuICAgICAgY29tcGxldGVCb3VuZGFyeVNjcmlwdDNhID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIiwnKSxcbiAgICAgIGNvbXBsZXRlQm91bmRhcnlTY3JpcHQzYiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCInKSxcbiAgICAgIGNvbXBsZXRlQm91bmRhcnlTY3JpcHRFbmQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCIpXFx4M2Mvc2NyaXB0PlwiKTtcbiAgICBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzx0ZW1wbGF0ZSBkYXRhLXJjaT1cIlwiIGRhdGEtYmlkPVwiJyk7XG4gICAgc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8dGVtcGxhdGUgZGF0YS1ycmk9XCJcIiBkYXRhLWJpZD1cIicpO1xuICAgIHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIgZGF0YS1zaWQ9XCInKTtcbiAgICBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiIGRhdGEtc3R5PVwiJyk7XG4gICAgdmFyIGNsaWVudFJlbmRlclNjcmlwdDFGdWxsID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFxuICAgICAgICAnJFJYPWZ1bmN0aW9uKGIsYyxkLGUsZil7dmFyIGE9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYik7YSYmKGI9YS5wcmV2aW91c1NpYmxpbmcsYi5kYXRhPVwiJCFcIixhPWEuZGF0YXNldCxjJiYoYS5kZ3N0PWMpLGQmJihhLm1zZz1kKSxlJiYoYS5zdGNrPWUpLGYmJihhLmNzdGNrPWYpLGIuX3JlYWN0UmV0cnkmJmIuX3JlYWN0UmV0cnkoKSl9OzskUlgoXCInXG4gICAgICApLFxuICAgICAgY2xpZW50UmVuZGVyU2NyaXB0MVBhcnRpYWwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJyRSWChcIicpLFxuICAgICAgY2xpZW50UmVuZGVyU2NyaXB0MUEgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiJyksXG4gICAgICBjbGllbnRSZW5kZXJFcnJvclNjcmlwdEFyZ0ludGVyc3RpdGlhbCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcIixcIiksXG4gICAgICBjbGllbnRSZW5kZXJTY3JpcHRFbmQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCIpXFx4M2Mvc2NyaXB0PlwiKTtcbiAgICBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzx0ZW1wbGF0ZSBkYXRhLXJ4aT1cIlwiIGRhdGEtYmlkPVwiJyk7XG4gICAgc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIiBkYXRhLWRnc3Q9XCInKTtcbiAgICBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiIGRhdGEtbXNnPVwiJyk7XG4gICAgc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIiBkYXRhLXN0Y2s9XCInKTtcbiAgICBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiIGRhdGEtY3N0Y2s9XCInKTtcbiAgICB2YXIgcmVnZXhGb3JKU1N0cmluZ3NJbkluc3RydWN0aW9uU2NyaXB0cyA9IC9bPFxcdTIwMjhcXHUyMDI5XS9nLFxuICAgICAgcmVnZXhGb3JKU1N0cmluZ3NJblNjcmlwdHMgPSAvWyY+PFxcdTIwMjhcXHUyMDI5XS9nLFxuICAgICAgbGF0ZVN0eWxlVGFnUmVzb3VyY2VPcGVuMSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcbiAgICAgICAgJzxzdHlsZSBtZWRpYT1cIm5vdCBhbGxcIiBkYXRhLXByZWNlZGVuY2U9XCInXG4gICAgICApLFxuICAgICAgbGF0ZVN0eWxlVGFnUmVzb3VyY2VPcGVuMiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIgZGF0YS1ocmVmPVwiJyksXG4gICAgICBsYXRlU3R5bGVUYWdSZXNvdXJjZU9wZW4zID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIj4nKSxcbiAgICAgIGxhdGVTdHlsZVRhZ1RlbXBsYXRlQ2xvc2UgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCI8L3N0eWxlPlwiKSxcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0JvdW5kYXJ5SGFzU3R5bGVzVG9Ib2lzdCA9ICExLFxuICAgICAgZGVzdGluYXRpb25IYXNDYXBhY2l0eSA9ICEwLFxuICAgICAgc3R5bGVzaGVldEZsdXNoaW5nUXVldWUgPSBbXSxcbiAgICAgIHN0eWxlVGFnUmVzb3VyY2VPcGVuMSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcbiAgICAgICAgJzxzdHlsZSBkYXRhLXByZWNlZGVuY2U9XCInXG4gICAgICApLFxuICAgICAgc3R5bGVUYWdSZXNvdXJjZU9wZW4yID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIiBkYXRhLWhyZWY9XCInKSxcbiAgICAgIHNwYWNlU2VwYXJhdG9yID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFwiIFwiKSxcbiAgICAgIHN0eWxlVGFnUmVzb3VyY2VPcGVuMyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+JyksXG4gICAgICBzdHlsZVRhZ1Jlc291cmNlQ2xvc2UgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCI8L3N0eWxlPlwiKSxcbiAgICAgIGFycmF5Rmlyc3RPcGVuQnJhY2tldCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcIltcIiksXG4gICAgICBhcnJheVN1YnNlcXVlbnRPcGVuQnJhY2tldCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcIixbXCIpLFxuICAgICAgYXJyYXlJbnRlcnN0aXRpYWwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCIsXCIpLFxuICAgICAgYXJyYXlDbG9zZUJyYWNrZXQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCJdXCIpLFxuICAgICAgUEVORElORyQxID0gMCxcbiAgICAgIFBSRUxPQURFRCA9IDEsXG4gICAgICBQUkVBTUJMRSA9IDIsXG4gICAgICBMQVRFID0gMyxcbiAgICAgIHJlZ2V4Rm9ySHJlZkluTGlua0hlYWRlclVSTENvbnRleHQgPSAvWzw+XFxyXFxuXS9nLFxuICAgICAgcmVnZXhGb3JMaW5rSGVhZGVyUXVvdGVkUGFyYW1WYWx1ZUNvbnRleHQgPSAvW1wiJzssXFxyXFxuXS9nLFxuICAgICAgYmluZCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLFxuICAgICAgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpLFxuICAgICAgZW1wdHlDb250ZXh0T2JqZWN0ID0ge307XG4gICAgT2JqZWN0LmZyZWV6ZShlbXB0eUNvbnRleHRPYmplY3QpO1xuICAgIHZhciByZW5kZXJlclNpZ2lsID0ge307XG4gICAgdmFyIGN1cnJlbnRBY3RpdmVTbmFwc2hvdCA9IG51bGwsXG4gICAgICBkaWRXYXJuQWJvdXROb29wVXBkYXRlRm9yQ29tcG9uZW50ID0ge30sXG4gICAgICBkaWRXYXJuQWJvdXREZXByZWNhdGVkV2lsbE1vdW50ID0ge307XG4gICAgdmFyIGRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZSA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZSA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZXMkMSA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2FybkFib3V0Q2hpbGRDb250ZXh0VHlwZXMgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZSA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrID0gbmV3IFNldCgpO1xuICAgIHZhciBjbGFzc0NvbXBvbmVudFVwZGF0ZXIgPSB7XG4gICAgICAgIGlzTW91bnRlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgfSxcbiAgICAgICAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAoaW5zdCwgcGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgaW50ZXJuYWxzID0gaW5zdC5fcmVhY3RJbnRlcm5hbHM7XG4gICAgICAgICAgbnVsbCA9PT0gaW50ZXJuYWxzLnF1ZXVlXG4gICAgICAgICAgICA/IHdhcm5Ob29wKGluc3QsIFwic2V0U3RhdGVcIilcbiAgICAgICAgICAgIDogKGludGVybmFscy5xdWV1ZS5wdXNoKHBheWxvYWQpLFxuICAgICAgICAgICAgICB2b2lkIDAgIT09IGNhbGxiYWNrICYmXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gY2FsbGJhY2sgJiZcbiAgICAgICAgICAgICAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2spKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKGluc3QsIHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgaW5zdCA9IGluc3QuX3JlYWN0SW50ZXJuYWxzO1xuICAgICAgICAgIGluc3QucmVwbGFjZSA9ICEwO1xuICAgICAgICAgIGluc3QucXVldWUgPSBbcGF5bG9hZF07XG4gICAgICAgICAgdm9pZCAwICE9PSBjYWxsYmFjayAmJlxuICAgICAgICAgICAgbnVsbCAhPT0gY2FsbGJhY2sgJiZcbiAgICAgICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjayk7XG4gICAgICAgIH0sXG4gICAgICAgIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKGluc3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgbnVsbCA9PT0gaW5zdC5fcmVhY3RJbnRlcm5hbHMucXVldWVcbiAgICAgICAgICAgID8gd2Fybk5vb3AoaW5zdCwgXCJmb3JjZVVwZGF0ZVwiKVxuICAgICAgICAgICAgOiB2b2lkIDAgIT09IGNhbGxiYWNrICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IGNhbGxiYWNrICYmXG4gICAgICAgICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBlbXB0eVRyZWVDb250ZXh0ID0geyBpZDogMSwgb3ZlcmZsb3c6IFwiXCIgfSxcbiAgICAgIGNsejMyID0gTWF0aC5jbHozMiA/IE1hdGguY2x6MzIgOiBjbHozMkZhbGxiYWNrLFxuICAgICAgbG9nID0gTWF0aC5sb2csXG4gICAgICBMTjIgPSBNYXRoLkxOMixcbiAgICAgIFN1c3BlbnNlRXhjZXB0aW9uID0gRXJyb3IoXG4gICAgICAgIFwiU3VzcGVuc2UgRXhjZXB0aW9uOiBUaGlzIGlzIG5vdCBhIHJlYWwgZXJyb3IhIEl0J3MgYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsIG9mIGB1c2VgIHRvIGludGVycnVwdCB0aGUgY3VycmVudCByZW5kZXIuIFlvdSBtdXN0IGVpdGhlciByZXRocm93IGl0IGltbWVkaWF0ZWx5LCBvciBtb3ZlIHRoZSBgdXNlYCBjYWxsIG91dHNpZGUgb2YgdGhlIGB0cnkvY2F0Y2hgIGJsb2NrLiBDYXB0dXJpbmcgd2l0aG91dCByZXRocm93aW5nIHdpbGwgbGVhZCB0byB1bmV4cGVjdGVkIGJlaGF2aW9yLlxcblxcblRvIGhhbmRsZSBhc3luYyBlcnJvcnMsIHdyYXAgeW91ciBjb21wb25lbnQgaW4gYW4gZXJyb3IgYm91bmRhcnksIG9yIGNhbGwgdGhlIHByb21pc2UncyBgLmNhdGNoYCBtZXRob2QgYW5kIHBhc3MgdGhlIHJlc3VsdCB0byBgdXNlYC5cIlxuICAgICAgKSxcbiAgICAgIHN1c3BlbmRlZFRoZW5hYmxlID0gbnVsbCxcbiAgICAgIG9iamVjdElzID0gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgT2JqZWN0LmlzID8gT2JqZWN0LmlzIDogaXMsXG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPSBudWxsLFxuICAgICAgY3VycmVudGx5UmVuZGVyaW5nVGFzayA9IG51bGwsXG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdSZXF1ZXN0ID0gbnVsbCxcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0tleVBhdGggPSBudWxsLFxuICAgICAgZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsLFxuICAgICAgd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbCxcbiAgICAgIGlzUmVSZW5kZXIgPSAhMSxcbiAgICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSAhMSxcbiAgICAgIGxvY2FsSWRDb3VudGVyID0gMCxcbiAgICAgIGFjdGlvblN0YXRlQ291bnRlciA9IDAsXG4gICAgICBhY3Rpb25TdGF0ZU1hdGNoaW5nSW5kZXggPSAtMSxcbiAgICAgIHRoZW5hYmxlSW5kZXhDb3VudGVyID0gMCxcbiAgICAgIHRoZW5hYmxlU3RhdGUgPSBudWxsLFxuICAgICAgcmVuZGVyUGhhc2VVcGRhdGVzID0gbnVsbCxcbiAgICAgIG51bWJlck9mUmVSZW5kZXJzID0gMCxcbiAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9ICExLFxuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYsXG4gICAgICBIb29rc0Rpc3BhdGNoZXIgPSB7XG4gICAgICAgIHJlYWRDb250ZXh0OiByZWFkQ29udGV4dCxcbiAgICAgICAgdXNlOiBmdW5jdGlvbiAodXNhYmxlKSB7XG4gICAgICAgICAgaWYgKG51bGwgIT09IHVzYWJsZSAmJiBcIm9iamVjdFwiID09PSB0eXBlb2YgdXNhYmxlKSB7XG4gICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdXNhYmxlLnRoZW4pXG4gICAgICAgICAgICAgIHJldHVybiB1bndyYXBUaGVuYWJsZSh1c2FibGUpO1xuICAgICAgICAgICAgaWYgKHVzYWJsZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFKVxuICAgICAgICAgICAgICByZXR1cm4gcmVhZENvbnRleHQodXNhYmxlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIkFuIHVuc3VwcG9ydGVkIHR5cGUgd2FzIHBhc3NlZCB0byB1c2UoKTogXCIgKyBTdHJpbmcodXNhYmxlKVxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNvbnRleHRcIjtcbiAgICAgICAgICByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgdXNlTWVtbzogdXNlTWVtbyxcbiAgICAgICAgdXNlUmVkdWNlcjogdXNlUmVkdWNlcixcbiAgICAgICAgdXNlUmVmOiBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50ID0gcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9IGNyZWF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgICAgIHZhciBwcmV2aW91c1JlZiA9IHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIHJldHVybiBudWxsID09PSBwcmV2aW91c1JlZlxuICAgICAgICAgICAgPyAoKGluaXRpYWxWYWx1ZSA9IHsgY3VycmVudDogaW5pdGlhbFZhbHVlIH0pLFxuICAgICAgICAgICAgICBPYmplY3Quc2VhbChpbml0aWFsVmFsdWUpLFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUgPSBpbml0aWFsVmFsdWUpKVxuICAgICAgICAgICAgOiBwcmV2aW91c1JlZjtcbiAgICAgICAgfSxcbiAgICAgICAgdXNlU3RhdGU6IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUpIHtcbiAgICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlU3RhdGVcIjtcbiAgICAgICAgICByZXR1cm4gdXNlUmVkdWNlcihiYXNpY1N0YXRlUmVkdWNlciwgaW5pdGlhbFN0YXRlKTtcbiAgICAgICAgfSxcbiAgICAgICAgdXNlSW5zZXJ0aW9uRWZmZWN0OiBub29wJDEsXG4gICAgICAgIHVzZUxheW91dEVmZmVjdDogbm9vcCQxLFxuICAgICAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICAgICAgcmV0dXJuIHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrO1xuICAgICAgICAgIH0sIGRlcHMpO1xuICAgICAgICB9LFxuICAgICAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBub29wJDEsXG4gICAgICAgIHVzZUVmZmVjdDogbm9vcCQxLFxuICAgICAgICB1c2VEZWJ1Z1ZhbHVlOiBub29wJDEsXG4gICAgICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgICAgcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICAgICAgICAgIHJldHVybiB2b2lkIDAgIT09IGluaXRpYWxWYWx1ZSA/IGluaXRpYWxWYWx1ZSA6IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICAgICAgICAgIHJldHVybiBbITEsIHVuc3VwcG9ydGVkU3RhcnRUcmFuc2l0aW9uXTtcbiAgICAgICAgfSxcbiAgICAgICAgdXNlSWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgdHJlZUlkID0gY3VycmVudGx5UmVuZGVyaW5nVGFzay50cmVlQ29udGV4dDtcbiAgICAgICAgICB2YXIgb3ZlcmZsb3cgPSB0cmVlSWQub3ZlcmZsb3c7XG4gICAgICAgICAgdHJlZUlkID0gdHJlZUlkLmlkO1xuICAgICAgICAgIHRyZWVJZCA9XG4gICAgICAgICAgICAodHJlZUlkICYgfigxIDw8ICgzMiAtIGNsejMyKHRyZWVJZCkgLSAxKSkpLnRvU3RyaW5nKDMyKSArIG92ZXJmbG93O1xuICAgICAgICAgIHZhciByZXN1bWFibGVTdGF0ZSA9IGN1cnJlbnRSZXN1bWFibGVTdGF0ZTtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gcmVzdW1hYmxlU3RhdGUpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgXCJJbnZhbGlkIGhvb2sgY2FsbC4gSG9va3MgY2FuIG9ubHkgYmUgY2FsbGVkIGluc2lkZSBvZiB0aGUgYm9keSBvZiBhIGZ1bmN0aW9uIGNvbXBvbmVudC5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBvdmVyZmxvdyA9IGxvY2FsSWRDb3VudGVyKys7XG4gICAgICAgICAgdHJlZUlkID0gXCI6XCIgKyByZXN1bWFibGVTdGF0ZS5pZFByZWZpeCArIFwiUlwiICsgdHJlZUlkO1xuICAgICAgICAgIDAgPCBvdmVyZmxvdyAmJiAodHJlZUlkICs9IFwiSFwiICsgb3ZlcmZsb3cudG9TdHJpbmcoMzIpKTtcbiAgICAgICAgICByZXR1cm4gdHJlZUlkICsgXCI6XCI7XG4gICAgICAgIH0sXG4gICAgICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiBmdW5jdGlvbiAoXG4gICAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICAgIGdldFNuYXBzaG90LFxuICAgICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICAgICkge1xuICAgICAgICAgIGlmICh2b2lkIDAgPT09IGdldFNlcnZlclNuYXBzaG90KVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgIFwiTWlzc2luZyBnZXRTZXJ2ZXJTbmFwc2hvdCwgd2hpY2ggaXMgcmVxdWlyZWQgZm9yIHNlcnZlci1yZW5kZXJlZCBjb250ZW50LiBXaWxsIHJldmVydCB0byBjbGllbnQgcmVuZGVyaW5nLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBnZXRTZXJ2ZXJTbmFwc2hvdCgpO1xuICAgICAgICB9LFxuICAgICAgICB1c2VDYWNoZVJlZnJlc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdW5zdXBwb3J0ZWRSZWZyZXNoO1xuICAgICAgICB9LFxuICAgICAgICB1c2VNZW1vQ2FjaGU6IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICAgICAgZm9yICh2YXIgZGF0YSA9IEFycmF5KHNpemUpLCBpID0gMDsgaSA8IHNpemU7IGkrKylcbiAgICAgICAgICAgIGRhdGFbaV0gPSBSRUFDVF9NRU1PX0NBQ0hFX1NFTlRJTkVMO1xuICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9LFxuICAgICAgICB1c2VIb3N0VHJhbnNpdGlvblN0YXR1czogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKTtcbiAgICAgICAgICByZXR1cm4gTm90UGVuZGluZztcbiAgICAgICAgfSxcbiAgICAgICAgdXNlT3B0aW1pc3RpYzogZnVuY3Rpb24gKHBhc3N0aHJvdWdoKSB7XG4gICAgICAgICAgcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICAgICAgICAgIHJldHVybiBbcGFzc3Rocm91Z2gsIHVuc3VwcG9ydGVkU2V0T3B0aW1pc3RpY1N0YXRlXTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICBIb29rc0Rpc3BhdGNoZXIudXNlRm9ybVN0YXRlID0gdXNlQWN0aW9uU3RhdGU7XG4gICAgSG9va3NEaXNwYXRjaGVyLnVzZUFjdGlvblN0YXRlID0gdXNlQWN0aW9uU3RhdGU7XG4gICAgdmFyIGN1cnJlbnRSZXN1bWFibGVTdGF0ZSA9IG51bGwsXG4gICAgICBjdXJyZW50VGFza0luREVWID0gbnVsbCxcbiAgICAgIERlZmF1bHRBc3luY0Rpc3BhdGNoZXIgPSB7XG4gICAgICAgIGdldENhY2hlRm9yVHlwZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRocm93IEVycm9yKFwiTm90IGltcGxlbWVudGVkLlwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0T3duZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbCA9PT0gY3VycmVudFRhc2tJbkRFVlxuICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICA6IGN1cnJlbnRUYXNrSW5ERVYuY29tcG9uZW50U3RhY2s7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkaXNhYmxlZERlcHRoID0gMCxcbiAgICAgIHByZXZMb2csXG4gICAgICBwcmV2SW5mbyxcbiAgICAgIHByZXZXYXJuLFxuICAgICAgcHJldkVycm9yLFxuICAgICAgcHJldkdyb3VwLFxuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkLFxuICAgICAgcHJldkdyb3VwRW5kO1xuICAgIGRpc2FibGVkTG9nLl9fcmVhY3REaXNhYmxlZExvZyA9ICEwO1xuICAgIHZhciBwcmVmaXgsXG4gICAgICBzdWZmaXgsXG4gICAgICByZWVudHJ5ID0gITE7XG4gICAgdmFyIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgKFxuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgV2Vha01hcCA/IFdlYWtNYXAgOiBNYXBcbiAgICApKCk7XG4gICAgdmFyIGNhbGxDb21wb25lbnQgPSB7XG4gICAgICAgIFwicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCI6IGZ1bmN0aW9uIChDb21wb25lbnQsIHByb3BzLCBzZWNvbmRBcmcpIHtcbiAgICAgICAgICByZXR1cm4gQ29tcG9uZW50KHByb3BzLCBzZWNvbmRBcmcpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2FsbENvbXBvbmVudEluREVWID1cbiAgICAgICAgY2FsbENvbXBvbmVudFtcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiXS5iaW5kKGNhbGxDb21wb25lbnQpLFxuICAgICAgY2FsbFJlbmRlciA9IHtcbiAgICAgICAgXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIjogZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICAgICAgcmV0dXJuIGluc3RhbmNlLnJlbmRlcigpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2FsbFJlbmRlckluREVWID0gY2FsbFJlbmRlcltcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiXS5iaW5kKGNhbGxSZW5kZXIpLFxuICAgICAgY2FsbExhenlJbml0ID0ge1xuICAgICAgICBcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiOiBmdW5jdGlvbiAobGF6eSkge1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eS5faW5pdDtcbiAgICAgICAgICByZXR1cm4gaW5pdChsYXp5Ll9wYXlsb2FkKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNhbGxMYXp5SW5pdEluREVWID1cbiAgICAgICAgY2FsbExhenlJbml0W1wicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCJdLmJpbmQoY2FsbExhenlJbml0KSxcbiAgICAgIENMSUVOVF9SRU5ERVJFRCA9IDQsXG4gICAgICBQRU5ESU5HID0gMCxcbiAgICAgIENPTVBMRVRFRCA9IDEsXG4gICAgICBGTFVTSEVEID0gMixcbiAgICAgIFBPU1RQT05FRCA9IDUsXG4gICAgICBDTE9TRUQgPSAxNCxcbiAgICAgIGN1cnJlbnRSZXF1ZXN0ID0gbnVsbCxcbiAgICAgIGRpZFdhcm5BYm91dEJhZENsYXNzID0ge30sXG4gICAgICBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZXMgPSB7fSxcbiAgICAgIGRpZFdhcm5BYm91dENvbnRleHRUeXBlT25GdW5jdGlvbkNvbXBvbmVudCA9IHt9LFxuICAgICAgZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudCA9IHt9LFxuICAgICAgZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyA9ICExLFxuICAgICAgZGlkV2FybkFib3V0R2VuZXJhdG9ycyA9ICExLFxuICAgICAgZGlkV2FybkFib3V0TWFwcyA9ICExO1xuICAgIGVuc3VyZUNvcnJlY3RJc29tb3JwaGljUmVhY3RWZXJzaW9uKCk7XG4gICAgZW5zdXJlQ29ycmVjdElzb21vcnBoaWNSZWFjdFZlcnNpb24oKTtcbiAgICBleHBvcnRzLnByZXJlbmRlciA9IGZ1bmN0aW9uIChjaGlsZHJlbiwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIG9uSGVhZGVycyA9IG9wdGlvbnMgPyBvcHRpb25zLm9uSGVhZGVycyA6IHZvaWQgMCxcbiAgICAgICAgICBvbkhlYWRlcnNJbXBsO1xuICAgICAgICBvbkhlYWRlcnMgJiZcbiAgICAgICAgICAob25IZWFkZXJzSW1wbCA9IGZ1bmN0aW9uIChoZWFkZXJzRGVzY3JpcHRvcikge1xuICAgICAgICAgICAgb25IZWFkZXJzKG5ldyBIZWFkZXJzKGhlYWRlcnNEZXNjcmlwdG9yKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIHZhciByZXNvdXJjZXMgPSBjcmVhdGVSZXN1bWFibGVTdGF0ZShcbiAgICAgICAgICAgIG9wdGlvbnMgPyBvcHRpb25zLmlkZW50aWZpZXJQcmVmaXggOiB2b2lkIDAsXG4gICAgICAgICAgICBvcHRpb25zID8gb3B0aW9ucy51bnN0YWJsZV9leHRlcm5hbFJ1bnRpbWVTcmMgOiB2b2lkIDAsXG4gICAgICAgICAgICBvcHRpb25zID8gb3B0aW9ucy5ib290c3RyYXBTY3JpcHRDb250ZW50IDogdm9pZCAwLFxuICAgICAgICAgICAgb3B0aW9ucyA/IG9wdGlvbnMuYm9vdHN0cmFwU2NyaXB0cyA6IHZvaWQgMCxcbiAgICAgICAgICAgIG9wdGlvbnMgPyBvcHRpb25zLmJvb3RzdHJhcE1vZHVsZXMgOiB2b2lkIDBcbiAgICAgICAgICApLFxuICAgICAgICAgIHJlcXVlc3QgPSBjcmVhdGVQcmVyZW5kZXJSZXF1ZXN0KFxuICAgICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAgICByZXNvdXJjZXMsXG4gICAgICAgICAgICBjcmVhdGVSZW5kZXJTdGF0ZShcbiAgICAgICAgICAgICAgcmVzb3VyY2VzLFxuICAgICAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgICAgIG9wdGlvbnMgPyBvcHRpb25zLnVuc3RhYmxlX2V4dGVybmFsUnVudGltZVNyYyA6IHZvaWQgMCxcbiAgICAgICAgICAgICAgb3B0aW9ucyA/IG9wdGlvbnMuaW1wb3J0TWFwIDogdm9pZCAwLFxuICAgICAgICAgICAgICBvbkhlYWRlcnNJbXBsLFxuICAgICAgICAgICAgICBvcHRpb25zID8gb3B0aW9ucy5tYXhIZWFkZXJzTGVuZ3RoIDogdm9pZCAwXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgY3JlYXRlUm9vdEZvcm1hdENvbnRleHQob3B0aW9ucyA/IG9wdGlvbnMubmFtZXNwYWNlVVJJIDogdm9pZCAwKSxcbiAgICAgICAgICAgIG9wdGlvbnMgPyBvcHRpb25zLnByb2dyZXNzaXZlQ2h1bmtTaXplIDogdm9pZCAwLFxuICAgICAgICAgICAgb3B0aW9ucyA/IG9wdGlvbnMub25FcnJvciA6IHZvaWQgMCxcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICBwcmVsdWRlOiBuZXcgUmVhZGFibGVTdHJlYW0oXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYnl0ZXNcIixcbiAgICAgICAgICAgICAgICAgICAgcHVsbDogZnVuY3Rpb24gKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzdGFydEZsb3dpbmcocmVxdWVzdCwgY29udHJvbGxlcik7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuZGVzdGluYXRpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KHJlcXVlc3QsIHJlYXNvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB7IGhpZ2hXYXRlck1hcms6IDAgfVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICAgIHJlamVjdCxcbiAgICAgICAgICAgIG9wdGlvbnMgPyBvcHRpb25zLm9uUG9zdHBvbmUgOiB2b2lkIDBcbiAgICAgICAgICApO1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnNpZ25hbCkge1xuICAgICAgICAgIHZhciBzaWduYWwgPSBvcHRpb25zLnNpZ25hbDtcbiAgICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIGFib3J0KHJlcXVlc3QsIHNpZ25hbC5yZWFzb24pO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBhYm9ydChyZXF1ZXN0LCBzaWduYWwucmVhc29uKTtcbiAgICAgICAgICAgICAgc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBsaXN0ZW5lcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXJ0V29yayhyZXF1ZXN0KTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgZXhwb3J0cy5yZW5kZXJUb1JlYWRhYmxlU3RyZWFtID0gZnVuY3Rpb24gKGNoaWxkcmVuLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgb25GYXRhbEVycm9yLFxuICAgICAgICAgIG9uQWxsUmVhZHksXG4gICAgICAgICAgYWxsUmVhZHkgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzLCByZWopIHtcbiAgICAgICAgICAgIG9uQWxsUmVhZHkgPSByZXM7XG4gICAgICAgICAgICBvbkZhdGFsRXJyb3IgPSByZWo7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgb25IZWFkZXJzID0gb3B0aW9ucyA/IG9wdGlvbnMub25IZWFkZXJzIDogdm9pZCAwLFxuICAgICAgICAgIG9uSGVhZGVyc0ltcGw7XG4gICAgICAgIG9uSGVhZGVycyAmJlxuICAgICAgICAgIChvbkhlYWRlcnNJbXBsID0gZnVuY3Rpb24gKGhlYWRlcnNEZXNjcmlwdG9yKSB7XG4gICAgICAgICAgICBvbkhlYWRlcnMobmV3IEhlYWRlcnMoaGVhZGVyc0Rlc2NyaXB0b3IpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgdmFyIHJlc3VtYWJsZVN0YXRlID0gY3JlYXRlUmVzdW1hYmxlU3RhdGUoXG4gICAgICAgICAgICBvcHRpb25zID8gb3B0aW9ucy5pZGVudGlmaWVyUHJlZml4IDogdm9pZCAwLFxuICAgICAgICAgICAgb3B0aW9ucyA/IG9wdGlvbnMudW5zdGFibGVfZXh0ZXJuYWxSdW50aW1lU3JjIDogdm9pZCAwLFxuICAgICAgICAgICAgb3B0aW9ucyA/IG9wdGlvbnMuYm9vdHN0cmFwU2NyaXB0Q29udGVudCA6IHZvaWQgMCxcbiAgICAgICAgICAgIG9wdGlvbnMgPyBvcHRpb25zLmJvb3RzdHJhcFNjcmlwdHMgOiB2b2lkIDAsXG4gICAgICAgICAgICBvcHRpb25zID8gb3B0aW9ucy5ib290c3RyYXBNb2R1bGVzIDogdm9pZCAwXG4gICAgICAgICAgKSxcbiAgICAgICAgICByZXF1ZXN0ID0gY3JlYXRlUmVxdWVzdChcbiAgICAgICAgICAgIGNoaWxkcmVuLFxuICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICBjcmVhdGVSZW5kZXJTdGF0ZShcbiAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICAgIG9wdGlvbnMgPyBvcHRpb25zLm5vbmNlIDogdm9pZCAwLFxuICAgICAgICAgICAgICBvcHRpb25zID8gb3B0aW9ucy51bnN0YWJsZV9leHRlcm5hbFJ1bnRpbWVTcmMgOiB2b2lkIDAsXG4gICAgICAgICAgICAgIG9wdGlvbnMgPyBvcHRpb25zLmltcG9ydE1hcCA6IHZvaWQgMCxcbiAgICAgICAgICAgICAgb25IZWFkZXJzSW1wbCxcbiAgICAgICAgICAgICAgb3B0aW9ucyA/IG9wdGlvbnMubWF4SGVhZGVyc0xlbmd0aCA6IHZvaWQgMFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGNyZWF0ZVJvb3RGb3JtYXRDb250ZXh0KG9wdGlvbnMgPyBvcHRpb25zLm5hbWVzcGFjZVVSSSA6IHZvaWQgMCksXG4gICAgICAgICAgICBvcHRpb25zID8gb3B0aW9ucy5wcm9ncmVzc2l2ZUNodW5rU2l6ZSA6IHZvaWQgMCxcbiAgICAgICAgICAgIG9wdGlvbnMgPyBvcHRpb25zLm9uRXJyb3IgOiB2b2lkIDAsXG4gICAgICAgICAgICBvbkFsbFJlYWR5LFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYnl0ZXNcIixcbiAgICAgICAgICAgICAgICAgIHB1bGw6IGZ1bmN0aW9uIChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0Rmxvd2luZyhyZXF1ZXN0LCBjb250cm9sbGVyKTtcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5kZXN0aW5hdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGFib3J0KHJlcXVlc3QsIHJlYXNvbik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7IGhpZ2hXYXRlck1hcms6IDAgfVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBzdHJlYW0uYWxsUmVhZHkgPSBhbGxSZWFkeTtcbiAgICAgICAgICAgICAgcmVzb2x2ZShzdHJlYW0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICBhbGxSZWFkeS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25GYXRhbEVycm9yLFxuICAgICAgICAgICAgb3B0aW9ucyA/IG9wdGlvbnMub25Qb3N0cG9uZSA6IHZvaWQgMCxcbiAgICAgICAgICAgIG9wdGlvbnMgPyBvcHRpb25zLmZvcm1TdGF0ZSA6IHZvaWQgMFxuICAgICAgICAgICk7XG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuc2lnbmFsKSB7XG4gICAgICAgICAgdmFyIHNpZ25hbCA9IG9wdGlvbnMuc2lnbmFsO1xuICAgICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkgYWJvcnQocmVxdWVzdCwgc2lnbmFsLnJlYXNvbik7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGFib3J0KHJlcXVlc3QsIHNpZ25hbC5yZWFzb24pO1xuICAgICAgICAgICAgICBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGxpc3RlbmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhcnRXb3JrKHJlcXVlc3QpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBleHBvcnRzLnZlcnNpb24gPSBcIjE5LjAuMC1yYy02NWUwNmNiNy0yMDI0MTIxOFwiO1xuICB9KSgpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/cjs/react-dom-server.browser.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/server.browser.js":
/*!*********************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react-dom/server.browser.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nvar l, s;\nif (false) {} else {\n  l = __webpack_require__(/*! ./cjs/react-dom-server-legacy.browser.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/cjs/react-dom-server-legacy.browser.development.js\");\n  s = __webpack_require__(/*! ./cjs/react-dom-server.browser.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/cjs/react-dom-server.browser.development.js\");\n}\n\nexports.version = l.version;\nexports.renderToString = l.renderToString;\nexports.renderToStaticMarkup = l.renderToStaticMarkup;\nexports.renderToReadableStream = s.renderToReadableStream;\nif (s.resume) {\n  exports.resume = s.resume;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QtZG9tL3NlcnZlci5icm93c2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0EsSUFBSSxLQUFxQyxFQUFFLEVBRzFDLENBQUM7QUFDRixNQUFNLG1CQUFPLENBQUMsZ0xBQXNEO0FBQ3BFLE1BQU0sbUJBQU8sQ0FBQyxrS0FBK0M7QUFDN0Q7O0FBRUEsZUFBZTtBQUNmLHNCQUFzQjtBQUN0Qiw0QkFBNEI7QUFDNUIsOEJBQThCO0FBQzlCO0FBQ0EsRUFBRSxjQUFjO0FBQ2hCIiwic291cmNlcyI6WyIvVXNlcnMvd29uZGVybGFuZG1pdGNoL0Nhc2NhZGVQcm9qZWN0cy9Xb25kZXJWaXRlLWZyb250ZW5kL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QtZG9tL3NlcnZlci5icm93c2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGwsIHM7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBsID0gcmVxdWlyZSgnLi9janMvcmVhY3QtZG9tLXNlcnZlci1sZWdhY3kuYnJvd3Nlci5wcm9kdWN0aW9uLmpzJyk7XG4gIHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1kb20tc2VydmVyLmJyb3dzZXIucHJvZHVjdGlvbi5qcycpO1xufSBlbHNlIHtcbiAgbCA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRvbS1zZXJ2ZXItbGVnYWN5LmJyb3dzZXIuZGV2ZWxvcG1lbnQuanMnKTtcbiAgcyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRvbS1zZXJ2ZXIuYnJvd3Nlci5kZXZlbG9wbWVudC5qcycpO1xufVxuXG5leHBvcnRzLnZlcnNpb24gPSBsLnZlcnNpb247XG5leHBvcnRzLnJlbmRlclRvU3RyaW5nID0gbC5yZW5kZXJUb1N0cmluZztcbmV4cG9ydHMucmVuZGVyVG9TdGF0aWNNYXJrdXAgPSBsLnJlbmRlclRvU3RhdGljTWFya3VwO1xuZXhwb3J0cy5yZW5kZXJUb1JlYWRhYmxlU3RyZWFtID0gcy5yZW5kZXJUb1JlYWRhYmxlU3RyZWFtO1xuaWYgKHMucmVzdW1lKSB7XG4gIGV4cG9ydHMucmVzdW1lID0gcy5yZXN1bWU7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/server.browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function getComponentNameFromType(type) {\n      if (null == type) return null;\n      if (\"function\" === typeof type)\n        return type.$$typeof === REACT_CLIENT_REFERENCE$2\n          ? null\n          : type.displayName || type.name || null;\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n        case REACT_PORTAL_TYPE:\n          return \"Portal\";\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n      }\n      if (\"object\" === typeof type)\n        switch (\n          (\"number\" === typeof type.tag &&\n            console.error(\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n            ),\n          type.$$typeof)\n        ) {\n          case REACT_CONTEXT_TYPE:\n            return (type.displayName || \"Context\") + \".Provider\";\n          case REACT_CONSUMER_TYPE:\n            return (type._context.displayName || \"Context\") + \".Consumer\";\n          case REACT_FORWARD_REF_TYPE:\n            var innerType = type.render;\n            type = type.displayName;\n            type ||\n              ((type = innerType.displayName || innerType.name || \"\"),\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n            return type;\n          case REACT_MEMO_TYPE:\n            return (\n              (innerType = type.displayName || null),\n              null !== innerType\n                ? innerType\n                : getComponentNameFromType(type.type) || \"Memo\"\n            );\n          case REACT_LAZY_TYPE:\n            innerType = type._payload;\n            type = type._init;\n            try {\n              return getComponentNameFromType(type(innerType));\n            } catch (x) {}\n        }\n      return null;\n    }\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function checkKeyStringCoercion(value) {\n      try {\n        testStringCoercion(value);\n        var JSCompiler_inline_result = !1;\n      } catch (e) {\n        JSCompiler_inline_result = !0;\n      }\n      if (JSCompiler_inline_result) {\n        JSCompiler_inline_result = console;\n        var JSCompiler_temp_const = JSCompiler_inline_result.error;\n        var JSCompiler_inline_result$jscomp$0 =\n          (\"function\" === typeof Symbol &&\n            Symbol.toStringTag &&\n            value[Symbol.toStringTag]) ||\n          value.constructor.name ||\n          \"Object\";\n        JSCompiler_temp_const.call(\n          JSCompiler_inline_result,\n          \"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          JSCompiler_inline_result$jscomp$0\n        );\n        return testStringCoercion(value);\n      }\n    }\n    function disabledLog() {}\n    function disableLogs() {\n      if (0 === disabledDepth) {\n        prevLog = console.log;\n        prevInfo = console.info;\n        prevWarn = console.warn;\n        prevError = console.error;\n        prevGroup = console.group;\n        prevGroupCollapsed = console.groupCollapsed;\n        prevGroupEnd = console.groupEnd;\n        var props = {\n          configurable: !0,\n          enumerable: !0,\n          value: disabledLog,\n          writable: !0\n        };\n        Object.defineProperties(console, {\n          info: props,\n          log: props,\n          warn: props,\n          error: props,\n          group: props,\n          groupCollapsed: props,\n          groupEnd: props\n        });\n      }\n      disabledDepth++;\n    }\n    function reenableLogs() {\n      disabledDepth--;\n      if (0 === disabledDepth) {\n        var props = { configurable: !0, enumerable: !0, writable: !0 };\n        Object.defineProperties(console, {\n          log: assign({}, props, { value: prevLog }),\n          info: assign({}, props, { value: prevInfo }),\n          warn: assign({}, props, { value: prevWarn }),\n          error: assign({}, props, { value: prevError }),\n          group: assign({}, props, { value: prevGroup }),\n          groupCollapsed: assign({}, props, { value: prevGroupCollapsed }),\n          groupEnd: assign({}, props, { value: prevGroupEnd })\n        });\n      }\n      0 > disabledDepth &&\n        console.error(\n          \"disabledDepth fell below zero. This is a bug in React. Please file an issue.\"\n        );\n    }\n    function describeBuiltInComponentFrame(name) {\n      if (void 0 === prefix)\n        try {\n          throw Error();\n        } catch (x) {\n          var match = x.stack.trim().match(/\\n( *(at )?)/);\n          prefix = (match && match[1]) || \"\";\n          suffix =\n            -1 < x.stack.indexOf(\"\\n    at\")\n              ? \" (<anonymous>)\"\n              : -1 < x.stack.indexOf(\"@\")\n                ? \"@unknown:0:0\"\n                : \"\";\n        }\n      return \"\\n\" + prefix + name + suffix;\n    }\n    function describeNativeComponentFrame(fn, construct) {\n      if (!fn || reentry) return \"\";\n      var frame = componentFrameCache.get(fn);\n      if (void 0 !== frame) return frame;\n      reentry = !0;\n      frame = Error.prepareStackTrace;\n      Error.prepareStackTrace = void 0;\n      var previousDispatcher = null;\n      previousDispatcher = ReactSharedInternals.H;\n      ReactSharedInternals.H = null;\n      disableLogs();\n      try {\n        var RunInRootFrame = {\n          DetermineComponentFrameRoot: function () {\n            try {\n              if (construct) {\n                var Fake = function () {\n                  throw Error();\n                };\n                Object.defineProperty(Fake.prototype, \"props\", {\n                  set: function () {\n                    throw Error();\n                  }\n                });\n                if (\"object\" === typeof Reflect && Reflect.construct) {\n                  try {\n                    Reflect.construct(Fake, []);\n                  } catch (x) {\n                    var control = x;\n                  }\n                  Reflect.construct(fn, [], Fake);\n                } else {\n                  try {\n                    Fake.call();\n                  } catch (x$0) {\n                    control = x$0;\n                  }\n                  fn.call(Fake.prototype);\n                }\n              } else {\n                try {\n                  throw Error();\n                } catch (x$1) {\n                  control = x$1;\n                }\n                (Fake = fn()) &&\n                  \"function\" === typeof Fake.catch &&\n                  Fake.catch(function () {});\n              }\n            } catch (sample) {\n              if (sample && control && \"string\" === typeof sample.stack)\n                return [sample.stack, control.stack];\n            }\n            return [null, null];\n          }\n        };\n        RunInRootFrame.DetermineComponentFrameRoot.displayName =\n          \"DetermineComponentFrameRoot\";\n        var namePropDescriptor = Object.getOwnPropertyDescriptor(\n          RunInRootFrame.DetermineComponentFrameRoot,\n          \"name\"\n        );\n        namePropDescriptor &&\n          namePropDescriptor.configurable &&\n          Object.defineProperty(\n            RunInRootFrame.DetermineComponentFrameRoot,\n            \"name\",\n            { value: \"DetermineComponentFrameRoot\" }\n          );\n        var _RunInRootFrame$Deter =\n            RunInRootFrame.DetermineComponentFrameRoot(),\n          sampleStack = _RunInRootFrame$Deter[0],\n          controlStack = _RunInRootFrame$Deter[1];\n        if (sampleStack && controlStack) {\n          var sampleLines = sampleStack.split(\"\\n\"),\n            controlLines = controlStack.split(\"\\n\");\n          for (\n            _RunInRootFrame$Deter = namePropDescriptor = 0;\n            namePropDescriptor < sampleLines.length &&\n            !sampleLines[namePropDescriptor].includes(\n              \"DetermineComponentFrameRoot\"\n            );\n\n          )\n            namePropDescriptor++;\n          for (\n            ;\n            _RunInRootFrame$Deter < controlLines.length &&\n            !controlLines[_RunInRootFrame$Deter].includes(\n              \"DetermineComponentFrameRoot\"\n            );\n\n          )\n            _RunInRootFrame$Deter++;\n          if (\n            namePropDescriptor === sampleLines.length ||\n            _RunInRootFrame$Deter === controlLines.length\n          )\n            for (\n              namePropDescriptor = sampleLines.length - 1,\n                _RunInRootFrame$Deter = controlLines.length - 1;\n              1 <= namePropDescriptor &&\n              0 <= _RunInRootFrame$Deter &&\n              sampleLines[namePropDescriptor] !==\n                controlLines[_RunInRootFrame$Deter];\n\n            )\n              _RunInRootFrame$Deter--;\n          for (\n            ;\n            1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter;\n            namePropDescriptor--, _RunInRootFrame$Deter--\n          )\n            if (\n              sampleLines[namePropDescriptor] !==\n              controlLines[_RunInRootFrame$Deter]\n            ) {\n              if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {\n                do\n                  if (\n                    (namePropDescriptor--,\n                    _RunInRootFrame$Deter--,\n                    0 > _RunInRootFrame$Deter ||\n                      sampleLines[namePropDescriptor] !==\n                        controlLines[_RunInRootFrame$Deter])\n                  ) {\n                    var _frame =\n                      \"\\n\" +\n                      sampleLines[namePropDescriptor].replace(\n                        \" at new \",\n                        \" at \"\n                      );\n                    fn.displayName &&\n                      _frame.includes(\"<anonymous>\") &&\n                      (_frame = _frame.replace(\"<anonymous>\", fn.displayName));\n                    \"function\" === typeof fn &&\n                      componentFrameCache.set(fn, _frame);\n                    return _frame;\n                  }\n                while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);\n              }\n              break;\n            }\n        }\n      } finally {\n        (reentry = !1),\n          (ReactSharedInternals.H = previousDispatcher),\n          reenableLogs(),\n          (Error.prepareStackTrace = frame);\n      }\n      sampleLines = (sampleLines = fn ? fn.displayName || fn.name : \"\")\n        ? describeBuiltInComponentFrame(sampleLines)\n        : \"\";\n      \"function\" === typeof fn && componentFrameCache.set(fn, sampleLines);\n      return sampleLines;\n    }\n    function describeUnknownElementTypeFrameInDEV(type) {\n      if (null == type) return \"\";\n      if (\"function\" === typeof type) {\n        var prototype = type.prototype;\n        return describeNativeComponentFrame(\n          type,\n          !(!prototype || !prototype.isReactComponent)\n        );\n      }\n      if (\"string\" === typeof type) return describeBuiltInComponentFrame(type);\n      switch (type) {\n        case REACT_SUSPENSE_TYPE:\n          return describeBuiltInComponentFrame(\"Suspense\");\n        case REACT_SUSPENSE_LIST_TYPE:\n          return describeBuiltInComponentFrame(\"SuspenseList\");\n      }\n      if (\"object\" === typeof type)\n        switch (type.$$typeof) {\n          case REACT_FORWARD_REF_TYPE:\n            return (type = describeNativeComponentFrame(type.render, !1)), type;\n          case REACT_MEMO_TYPE:\n            return describeUnknownElementTypeFrameInDEV(type.type);\n          case REACT_LAZY_TYPE:\n            prototype = type._payload;\n            type = type._init;\n            try {\n              return describeUnknownElementTypeFrameInDEV(type(prototype));\n            } catch (x) {}\n        }\n      return \"\";\n    }\n    function getOwner() {\n      var dispatcher = ReactSharedInternals.A;\n      return null === dispatcher ? null : dispatcher.getOwner();\n    }\n    function hasValidKey(config) {\n      if (hasOwnProperty.call(config, \"key\")) {\n        var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n        if (getter && getter.isReactWarning) return !1;\n      }\n      return void 0 !== config.key;\n    }\n    function defineKeyPropWarningGetter(props, displayName) {\n      function warnAboutAccessingKey() {\n        specialPropKeyWarningShown ||\n          ((specialPropKeyWarningShown = !0),\n          console.error(\n            \"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)\",\n            displayName\n          ));\n      }\n      warnAboutAccessingKey.isReactWarning = !0;\n      Object.defineProperty(props, \"key\", {\n        get: warnAboutAccessingKey,\n        configurable: !0\n      });\n    }\n    function elementRefGetterWithDeprecationWarning() {\n      var componentName = getComponentNameFromType(this.type);\n      didWarnAboutElementRef[componentName] ||\n        ((didWarnAboutElementRef[componentName] = !0),\n        console.error(\n          \"Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.\"\n        ));\n      componentName = this.props.ref;\n      return void 0 !== componentName ? componentName : null;\n    }\n    function ReactElement(type, key, self, source, owner, props) {\n      self = props.ref;\n      type = {\n        $$typeof: REACT_ELEMENT_TYPE,\n        type: type,\n        key: key,\n        props: props,\n        _owner: owner\n      };\n      null !== (void 0 !== self ? self : null)\n        ? Object.defineProperty(type, \"ref\", {\n            enumerable: !1,\n            get: elementRefGetterWithDeprecationWarning\n          })\n        : Object.defineProperty(type, \"ref\", { enumerable: !1, value: null });\n      type._store = {};\n      Object.defineProperty(type._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: 0\n      });\n      Object.defineProperty(type, \"_debugInfo\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: null\n      });\n      Object.freeze && (Object.freeze(type.props), Object.freeze(type));\n      return type;\n    }\n    function jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self\n    ) {\n      if (\n        \"string\" === typeof type ||\n        \"function\" === typeof type ||\n        type === REACT_FRAGMENT_TYPE ||\n        type === REACT_PROFILER_TYPE ||\n        type === REACT_STRICT_MODE_TYPE ||\n        type === REACT_SUSPENSE_TYPE ||\n        type === REACT_SUSPENSE_LIST_TYPE ||\n        type === REACT_OFFSCREEN_TYPE ||\n        (\"object\" === typeof type &&\n          null !== type &&\n          (type.$$typeof === REACT_LAZY_TYPE ||\n            type.$$typeof === REACT_MEMO_TYPE ||\n            type.$$typeof === REACT_CONTEXT_TYPE ||\n            type.$$typeof === REACT_CONSUMER_TYPE ||\n            type.$$typeof === REACT_FORWARD_REF_TYPE ||\n            type.$$typeof === REACT_CLIENT_REFERENCE$1 ||\n            void 0 !== type.getModuleId))\n      ) {\n        var children = config.children;\n        if (void 0 !== children)\n          if (isStaticChildren)\n            if (isArrayImpl(children)) {\n              for (\n                isStaticChildren = 0;\n                isStaticChildren < children.length;\n                isStaticChildren++\n              )\n                validateChildKeys(children[isStaticChildren], type);\n              Object.freeze && Object.freeze(children);\n            } else\n              console.error(\n                \"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\"\n              );\n          else validateChildKeys(children, type);\n      } else {\n        children = \"\";\n        if (\n          void 0 === type ||\n          (\"object\" === typeof type &&\n            null !== type &&\n            0 === Object.keys(type).length)\n        )\n          children +=\n            \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\";\n        null === type\n          ? (isStaticChildren = \"null\")\n          : isArrayImpl(type)\n            ? (isStaticChildren = \"array\")\n            : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE\n              ? ((isStaticChildren =\n                  \"<\" +\n                  (getComponentNameFromType(type.type) || \"Unknown\") +\n                  \" />\"),\n                (children =\n                  \" Did you accidentally export a JSX literal instead of a component?\"))\n              : (isStaticChildren = typeof type);\n        console.error(\n          \"React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\",\n          isStaticChildren,\n          children\n        );\n      }\n      if (hasOwnProperty.call(config, \"key\")) {\n        children = getComponentNameFromType(type);\n        var keys = Object.keys(config).filter(function (k) {\n          return \"key\" !== k;\n        });\n        isStaticChildren =\n          0 < keys.length\n            ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\"\n            : \"{key: someKey}\";\n        didWarnAboutKeySpread[children + isStaticChildren] ||\n          ((keys =\n            0 < keys.length ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\"),\n          console.error(\n            'A props object containing a \"key\" prop is being spread into JSX:\\n  let props = %s;\\n  <%s {...props} />\\nReact keys must be passed directly to JSX without using spread:\\n  let props = %s;\\n  <%s key={someKey} {...props} />',\n            isStaticChildren,\n            children,\n            keys,\n            children\n          ),\n          (didWarnAboutKeySpread[children + isStaticChildren] = !0));\n      }\n      children = null;\n      void 0 !== maybeKey &&\n        (checkKeyStringCoercion(maybeKey), (children = \"\" + maybeKey));\n      hasValidKey(config) &&\n        (checkKeyStringCoercion(config.key), (children = \"\" + config.key));\n      if (\"key\" in config) {\n        maybeKey = {};\n        for (var propName in config)\n          \"key\" !== propName && (maybeKey[propName] = config[propName]);\n      } else maybeKey = config;\n      children &&\n        defineKeyPropWarningGetter(\n          maybeKey,\n          \"function\" === typeof type\n            ? type.displayName || type.name || \"Unknown\"\n            : type\n        );\n      return ReactElement(type, children, self, source, getOwner(), maybeKey);\n    }\n    function validateChildKeys(node, parentType) {\n      if (\n        \"object\" === typeof node &&\n        node &&\n        node.$$typeof !== REACT_CLIENT_REFERENCE\n      )\n        if (isArrayImpl(node))\n          for (var i = 0; i < node.length; i++) {\n            var child = node[i];\n            isValidElement(child) && validateExplicitKey(child, parentType);\n          }\n        else if (isValidElement(node))\n          node._store && (node._store.validated = 1);\n        else if (\n          (null === node || \"object\" !== typeof node\n            ? (i = null)\n            : ((i =\n                (MAYBE_ITERATOR_SYMBOL && node[MAYBE_ITERATOR_SYMBOL]) ||\n                node[\"@@iterator\"]),\n              (i = \"function\" === typeof i ? i : null)),\n          \"function\" === typeof i &&\n            i !== node.entries &&\n            ((i = i.call(node)), i !== node))\n        )\n          for (; !(node = i.next()).done; )\n            isValidElement(node.value) &&\n              validateExplicitKey(node.value, parentType);\n    }\n    function isValidElement(object) {\n      return (\n        \"object\" === typeof object &&\n        null !== object &&\n        object.$$typeof === REACT_ELEMENT_TYPE\n      );\n    }\n    function validateExplicitKey(element, parentType) {\n      if (\n        element._store &&\n        !element._store.validated &&\n        null == element.key &&\n        ((element._store.validated = 1),\n        (parentType = getCurrentComponentErrorInfo(parentType)),\n        !ownerHasKeyUseWarning[parentType])\n      ) {\n        ownerHasKeyUseWarning[parentType] = !0;\n        var childOwner = \"\";\n        element &&\n          null != element._owner &&\n          element._owner !== getOwner() &&\n          ((childOwner = null),\n          \"number\" === typeof element._owner.tag\n            ? (childOwner = getComponentNameFromType(element._owner.type))\n            : \"string\" === typeof element._owner.name &&\n              (childOwner = element._owner.name),\n          (childOwner = \" It was passed a child from \" + childOwner + \".\"));\n        var prevGetCurrentStack = ReactSharedInternals.getCurrentStack;\n        ReactSharedInternals.getCurrentStack = function () {\n          var stack = describeUnknownElementTypeFrameInDEV(element.type);\n          prevGetCurrentStack && (stack += prevGetCurrentStack() || \"\");\n          return stack;\n        };\n        console.error(\n          'Each child in a list should have a unique \"key\" prop.%s%s See https://react.dev/link/warning-keys for more information.',\n          parentType,\n          childOwner\n        );\n        ReactSharedInternals.getCurrentStack = prevGetCurrentStack;\n      }\n    }\n    function getCurrentComponentErrorInfo(parentType) {\n      var info = \"\",\n        owner = getOwner();\n      owner &&\n        (owner = getComponentNameFromType(owner.type)) &&\n        (info = \"\\n\\nCheck the render method of `\" + owner + \"`.\");\n      info ||\n        ((parentType = getComponentNameFromType(parentType)) &&\n          (info =\n            \"\\n\\nCheck the top-level render call using <\" + parentType + \">.\"));\n      return info;\n    }\n    var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"),\n      REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n    Symbol.for(\"react.provider\");\n    var REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\"),\n      MAYBE_ITERATOR_SYMBOL = Symbol.iterator,\n      REACT_CLIENT_REFERENCE$2 = Symbol.for(\"react.client.reference\"),\n      ReactSharedInternals =\n        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      assign = Object.assign,\n      REACT_CLIENT_REFERENCE$1 = Symbol.for(\"react.client.reference\"),\n      isArrayImpl = Array.isArray,\n      disabledDepth = 0,\n      prevLog,\n      prevInfo,\n      prevWarn,\n      prevError,\n      prevGroup,\n      prevGroupCollapsed,\n      prevGroupEnd;\n    disabledLog.__reactDisabledLog = !0;\n    var prefix,\n      suffix,\n      reentry = !1;\n    var componentFrameCache = new (\n      \"function\" === typeof WeakMap ? WeakMap : Map\n    )();\n    var REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n      specialPropKeyWarningShown;\n    var didWarnAboutElementRef = {};\n    var didWarnAboutKeySpread = {},\n      ownerHasKeyUseWarning = {};\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.jsxDEV = function (\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self\n    ) {\n      return jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self);\n    };\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYixLQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHdCQUF3QixXQUFXLGdCQUFnQjtBQUNuRCx5QkFBeUIsV0FBVyxpQkFBaUI7QUFDckQseUJBQXlCLFdBQVcsaUJBQWlCO0FBQ3JELDBCQUEwQixXQUFXLGtCQUFrQjtBQUN2RCwwQkFBMEIsV0FBVyxrQkFBa0I7QUFDdkQsbUNBQW1DLFdBQVcsMkJBQTJCO0FBQ3pFLDZCQUE2QixXQUFXLHFCQUFxQjtBQUM3RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsK0NBQStDLDZCQUE2QjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQkFBZ0IsZ0RBQWdEO0FBQ2hFLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQSxnQ0FBZ0Msa0NBQWtDLE9BQU87QUFDekU7QUFDQSxnR0FBZ0csU0FBUyxVQUFVLHNGQUFzRixhQUFhLFVBQVUsVUFBVTtBQUMxTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseUJBQXlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxzR0FBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSxJQUFJLGdCQUFnQjtBQUNwQixJQUFJLGNBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyIsInNvdXJjZXMiOlsiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvV29uZGVyVml0ZS1mcm9udGVuZC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViAmJlxuICAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB7XG4gICAgICBpZiAobnVsbCA9PSB0eXBlKSByZXR1cm4gbnVsbDtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICByZXR1cm4gdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQyXG4gICAgICAgICAgPyBudWxsXG4gICAgICAgICAgOiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKSByZXR1cm4gdHlwZTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiRnJhZ21lbnRcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJQb3J0YWxcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlByb2ZpbGVyXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdHJpY3RNb2RlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZVwiO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZUxpc3RcIjtcbiAgICAgIH1cbiAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgc3dpdGNoIChcbiAgICAgICAgICAoXCJudW1iZXJcIiA9PT0gdHlwZW9mIHR5cGUudGFnICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgdHlwZS4kJHR5cGVvZilcbiAgICAgICAgKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKHR5cGUuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCIpICsgXCIuUHJvdmlkZXJcIjtcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlNVTUVSX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKHR5cGUuX2NvbnRleHQuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCIpICsgXCIuQ29uc3VtZXJcIjtcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICB2YXIgaW5uZXJUeXBlID0gdHlwZS5yZW5kZXI7XG4gICAgICAgICAgICB0eXBlID0gdHlwZS5kaXNwbGF5TmFtZTtcbiAgICAgICAgICAgIHR5cGUgfHxcbiAgICAgICAgICAgICAgKCh0eXBlID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8IFwiXCIpLFxuICAgICAgICAgICAgICAodHlwZSA9IFwiXCIgIT09IHR5cGUgPyBcIkZvcndhcmRSZWYoXCIgKyB0eXBlICsgXCIpXCIgOiBcIkZvcndhcmRSZWZcIikpO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAoaW5uZXJUeXBlID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsKSxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gaW5uZXJUeXBlXG4gICAgICAgICAgICAgICAgPyBpbm5lclR5cGVcbiAgICAgICAgICAgICAgICA6IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8IFwiTWVtb1wiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgaW5uZXJUeXBlID0gdHlwZS5fcGF5bG9hZDtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLl9pbml0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKGlubmVyVHlwZSkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIFwiXCIgKyB2YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tLZXlTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICExO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMDtcbiAgICAgIH1cbiAgICAgIGlmIChKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQpIHtcbiAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gY29uc29sZTtcbiAgICAgICAgdmFyIEpTQ29tcGlsZXJfdGVtcF9jb25zdCA9IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdC5lcnJvcjtcbiAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMCA9XG4gICAgICAgICAgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFN5bWJvbCAmJlxuICAgICAgICAgICAgU3ltYm9sLnRvU3RyaW5nVGFnICYmXG4gICAgICAgICAgICB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddKSB8fFxuICAgICAgICAgIHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgfHxcbiAgICAgICAgICBcIk9iamVjdFwiO1xuICAgICAgICBKU0NvbXBpbGVyX3RlbXBfY29uc3QuY2FsbChcbiAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQsXG4gICAgICAgICAgXCJUaGUgcHJvdmlkZWQga2V5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLlwiLFxuICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuICAgIGZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICAgICAgaWYgKDAgPT09IGRpc2FibGVkRGVwdGgpIHtcbiAgICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgICAgcHJldldhcm4gPSBjb25zb2xlLndhcm47XG4gICAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICAgIHByZXZHcm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQ7XG4gICAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7XG4gICAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgICB3cml0YWJsZTogITBcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICAgIGxvZzogcHJvcHMsXG4gICAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICAgIGdyb3VwOiBwcm9wcyxcbiAgICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZGlzYWJsZWREZXB0aCsrO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gICAgICBkaXNhYmxlZERlcHRoLS07XG4gICAgICBpZiAoMCA9PT0gZGlzYWJsZWREZXB0aCkge1xuICAgICAgICB2YXIgcHJvcHMgPSB7IGNvbmZpZ3VyYWJsZTogITAsIGVudW1lcmFibGU6ICEwLCB3cml0YWJsZTogITAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICAgIGxvZzogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkxvZyB9KSxcbiAgICAgICAgICBpbmZvOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2SW5mbyB9KSxcbiAgICAgICAgICB3YXJuOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2V2FybiB9KSxcbiAgICAgICAgICBlcnJvcjogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkVycm9yIH0pLFxuICAgICAgICAgIGdyb3VwOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2R3JvdXAgfSksXG4gICAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZCB9KSxcbiAgICAgICAgICBncm91cEVuZDogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkdyb3VwRW5kIH0pXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgMCA+IGRpc2FibGVkRGVwdGggJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcImRpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSB7XG4gICAgICBpZiAodm9pZCAwID09PSBwcmVmaXgpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgICAgcHJlZml4ID0gKG1hdGNoICYmIG1hdGNoWzFdKSB8fCBcIlwiO1xuICAgICAgICAgIHN1ZmZpeCA9XG4gICAgICAgICAgICAtMSA8IHguc3RhY2suaW5kZXhPZihcIlxcbiAgICBhdFwiKVxuICAgICAgICAgICAgICA/IFwiICg8YW5vbnltb3VzPilcIlxuICAgICAgICAgICAgICA6IC0xIDwgeC5zdGFjay5pbmRleE9mKFwiQFwiKVxuICAgICAgICAgICAgICAgID8gXCJAdW5rbm93bjowOjBcIlxuICAgICAgICAgICAgICAgIDogXCJcIjtcbiAgICAgICAgfVxuICAgICAgcmV0dXJuIFwiXFxuXCIgKyBwcmVmaXggKyBuYW1lICsgc3VmZml4O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgICAgIGlmICghZm4gfHwgcmVlbnRyeSkgcmV0dXJuIFwiXCI7XG4gICAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG4gICAgICBpZiAodm9pZCAwICE9PSBmcmFtZSkgcmV0dXJuIGZyYW1lO1xuICAgICAgcmVlbnRyeSA9ICEwO1xuICAgICAgZnJhbWUgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTtcbiAgICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdm9pZCAwO1xuICAgICAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlciA9IG51bGw7XG4gICAgICBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IG51bGw7XG4gICAgICBkaXNhYmxlTG9ncygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIFJ1bkluUm9vdEZyYW1lID0ge1xuICAgICAgICAgIERldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKGNvbnN0cnVjdCkge1xuICAgICAgICAgICAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgXCJwcm9wc1wiLCB7XG4gICAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIFJlZmxlY3QgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRyb2wgPSB4O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoICh4JDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbCA9IHgkMDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoICh4JDEpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2wgPSB4JDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIChGYWtlID0gZm4oKSkgJiZcbiAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIEZha2UuY2F0Y2ggJiZcbiAgICAgICAgICAgICAgICAgIEZha2UuY2F0Y2goZnVuY3Rpb24gKCkge30pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAgICAgICAgICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIFwic3RyaW5nXCIgPT09IHR5cGVvZiBzYW1wbGUuc3RhY2spXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtzYW1wbGUuc3RhY2ssIGNvbnRyb2wuc3RhY2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtudWxsLCBudWxsXTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdC5kaXNwbGF5TmFtZSA9XG4gICAgICAgICAgXCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3RcIjtcbiAgICAgICAgdmFyIG5hbWVQcm9wRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoXG4gICAgICAgICAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LFxuICAgICAgICAgIFwibmFtZVwiXG4gICAgICAgICk7XG4gICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciAmJlxuICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvci5jb25maWd1cmFibGUgJiZcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgICAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsXG4gICAgICAgICAgICBcIm5hbWVcIixcbiAgICAgICAgICAgIHsgdmFsdWU6IFwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290XCIgfVxuICAgICAgICAgICk7XG4gICAgICAgIHZhciBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPVxuICAgICAgICAgICAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290KCksXG4gICAgICAgICAgc2FtcGxlU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMF0sXG4gICAgICAgICAgY29udHJvbFN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzFdO1xuICAgICAgICBpZiAoc2FtcGxlU3RhY2sgJiYgY29udHJvbFN0YWNrKSB7XG4gICAgICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlU3RhY2suc3BsaXQoXCJcXG5cIiksXG4gICAgICAgICAgICBjb250cm9sTGluZXMgPSBjb250cm9sU3RhY2suc3BsaXQoXCJcXG5cIik7XG4gICAgICAgICAgZm9yIChcbiAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlciA9IG5hbWVQcm9wRGVzY3JpcHRvciA9IDA7XG4gICAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IgPCBzYW1wbGVMaW5lcy5sZW5ndGggJiZcbiAgICAgICAgICAgICFzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdLmluY2x1ZGVzKFxuICAgICAgICAgICAgICBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgKVxuICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yKys7XG4gICAgICAgICAgZm9yIChcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlciA8IGNvbnRyb2xMaW5lcy5sZW5ndGggJiZcbiAgICAgICAgICAgICFjb250cm9sTGluZXNbX1J1bkluUm9vdEZyYW1lJERldGVyXS5pbmNsdWRlcyhcbiAgICAgICAgICAgICAgXCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3RcIlxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgIClcbiAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlcisrO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciA9PT0gc2FtcGxlTGluZXMubGVuZ3RoIHx8XG4gICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPT09IGNvbnRyb2xMaW5lcy5sZW5ndGhcbiAgICAgICAgICApXG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxLFxuICAgICAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlciA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAxIDw9IG5hbWVQcm9wRGVzY3JpcHRvciAmJlxuICAgICAgICAgICAgICAwIDw9IF9SdW5JblJvb3RGcmFtZSREZXRlciAmJlxuICAgICAgICAgICAgICBzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdICE9PVxuICAgICAgICAgICAgICAgIGNvbnRyb2xMaW5lc1tfUnVuSW5Sb290RnJhbWUkRGV0ZXJdO1xuXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlci0tO1xuICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICA7XG4gICAgICAgICAgICAxIDw9IG5hbWVQcm9wRGVzY3JpcHRvciAmJiAwIDw9IF9SdW5JblJvb3RGcmFtZSREZXRlcjtcbiAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvci0tLCBfUnVuSW5Sb290RnJhbWUkRGV0ZXItLVxuICAgICAgICAgIClcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgc2FtcGxlTGluZXNbbmFtZVByb3BEZXNjcmlwdG9yXSAhPT1cbiAgICAgICAgICAgICAgY29udHJvbExpbmVzW19SdW5JblJvb3RGcmFtZSREZXRlcl1cbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBpZiAoMSAhPT0gbmFtZVByb3BEZXNjcmlwdG9yIHx8IDEgIT09IF9SdW5JblJvb3RGcmFtZSREZXRlcikge1xuICAgICAgICAgICAgICAgIGRvXG4gICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIChuYW1lUHJvcERlc2NyaXB0b3ItLSxcbiAgICAgICAgICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyLS0sXG4gICAgICAgICAgICAgICAgICAgIDAgPiBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgfHxcbiAgICAgICAgICAgICAgICAgICAgICBzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdICE9PVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbExpbmVzW19SdW5JblJvb3RGcmFtZSREZXRlcl0pXG4gICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9XG4gICAgICAgICAgICAgICAgICAgICAgXCJcXG5cIiArXG4gICAgICAgICAgICAgICAgICAgICAgc2FtcGxlTGluZXNbbmFtZVByb3BEZXNjcmlwdG9yXS5yZXBsYWNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIgYXQgbmV3IFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIgYXQgXCJcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBmbi5kaXNwbGF5TmFtZSAmJlxuICAgICAgICAgICAgICAgICAgICAgIF9mcmFtZS5pbmNsdWRlcyhcIjxhbm9ueW1vdXM+XCIpICYmXG4gICAgICAgICAgICAgICAgICAgICAgKF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKFwiPGFub255bW91cz5cIiwgZm4uZGlzcGxheU5hbWUpKTtcbiAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZm4gJiZcbiAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoMSA8PSBuYW1lUHJvcERlc2NyaXB0b3IgJiYgMCA8PSBfUnVuSW5Sb290RnJhbWUkRGV0ZXIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICAocmVlbnRyeSA9ICExKSxcbiAgICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZpb3VzRGlzcGF0Y2hlciksXG4gICAgICAgICAgcmVlbmFibGVMb2dzKCksXG4gICAgICAgICAgKEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gZnJhbWUpO1xuICAgICAgfVxuICAgICAgc2FtcGxlTGluZXMgPSAoc2FtcGxlTGluZXMgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiBcIlwiKVxuICAgICAgICA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHNhbXBsZUxpbmVzKVxuICAgICAgICA6IFwiXCI7XG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBmbiAmJiBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc2FtcGxlTGluZXMpO1xuICAgICAgcmV0dXJuIHNhbXBsZUxpbmVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZSkge1xuICAgICAgaWYgKG51bGwgPT0gdHlwZSkgcmV0dXJuIFwiXCI7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZSkge1xuICAgICAgICB2YXIgcHJvdG90eXBlID0gdHlwZS5wcm90b3R5cGU7XG4gICAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgISghcHJvdG90eXBlIHx8ICFwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZSkgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoXCJTdXNwZW5zZVwiKTtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKFwiU3VzcGVuc2VMaXN0XCIpO1xuICAgICAgfVxuICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKHR5cGUgPSBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyLCAhMSkpLCB0eXBlO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUpO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgcHJvdG90eXBlID0gdHlwZS5fcGF5bG9hZDtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLl9pbml0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlKHByb3RvdHlwZSkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldE93bmVyKCkge1xuICAgICAgdmFyIGRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5BO1xuICAgICAgcmV0dXJuIG51bGwgPT09IGRpc3BhdGNoZXIgPyBudWxsIDogZGlzcGF0Y2hlci5nZXRPd25lcigpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgXCJrZXlcIikpIHtcbiAgICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCBcImtleVwiKS5nZXQ7XG4gICAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwICE9PSBjb25maWcua2V5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgICAgIGZ1bmN0aW9uIHdhcm5BYm91dEFjY2Vzc2luZ0tleSgpIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gfHxcbiAgICAgICAgICAoKHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gITApLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgdmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCBwcm9wLiAoaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9zcGVjaWFsLXByb3BzKVwiLFxuICAgICAgICAgICAgZGlzcGxheU5hbWVcbiAgICAgICAgICApKTtcbiAgICAgIH1cbiAgICAgIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9ICEwO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCBcImtleVwiLCB7XG4gICAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZWxlbWVudFJlZkdldHRlcldpdGhEZXByZWNhdGlvbldhcm5pbmcoKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0aGlzLnR5cGUpO1xuICAgICAgZGlkV2FybkFib3V0RWxlbWVudFJlZltjb21wb25lbnROYW1lXSB8fFxuICAgICAgICAoKGRpZFdhcm5BYm91dEVsZW1lbnRSZWZbY29tcG9uZW50TmFtZV0gPSAhMCksXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJBY2Nlc3NpbmcgZWxlbWVudC5yZWYgd2FzIHJlbW92ZWQgaW4gUmVhY3QgMTkuIHJlZiBpcyBub3cgYSByZWd1bGFyIHByb3AuIEl0IHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBKU1ggRWxlbWVudCB0eXBlIGluIGEgZnV0dXJlIHJlbGVhc2UuXCJcbiAgICAgICAgKSk7XG4gICAgICBjb21wb25lbnROYW1lID0gdGhpcy5wcm9wcy5yZWY7XG4gICAgICByZXR1cm4gdm9pZCAwICE9PSBjb21wb25lbnROYW1lID8gY29tcG9uZW50TmFtZSA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gICAgICBzZWxmID0gcHJvcHMucmVmO1xuICAgICAgdHlwZSA9IHtcbiAgICAgICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgX293bmVyOiBvd25lclxuICAgICAgfTtcbiAgICAgIG51bGwgIT09ICh2b2lkIDAgIT09IHNlbGYgPyBzZWxmIDogbnVsbClcbiAgICAgICAgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJyZWZcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgICAgICBnZXQ6IGVsZW1lbnRSZWZHZXR0ZXJXaXRoRGVwcmVjYXRpb25XYXJuaW5nXG4gICAgICAgICAgfSlcbiAgICAgICAgOiBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJyZWZcIiwgeyBlbnVtZXJhYmxlOiAhMSwgdmFsdWU6IG51bGwgfSk7XG4gICAgICB0eXBlLl9zdG9yZSA9IHt9O1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUuX3N0b3JlLCBcInZhbGlkYXRlZFwiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiAwXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcIl9kZWJ1Z0luZm9cIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZnJlZXplICYmIChPYmplY3QuZnJlZXplKHR5cGUucHJvcHMpLCBPYmplY3QuZnJlZXplKHR5cGUpKTtcbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBqc3hERVZJbXBsKFxuICAgICAgdHlwZSxcbiAgICAgIGNvbmZpZyxcbiAgICAgIG1heWJlS2V5LFxuICAgICAgaXNTdGF0aWNDaGlsZHJlbixcbiAgICAgIHNvdXJjZSxcbiAgICAgIHNlbGZcbiAgICApIHtcbiAgICAgIGlmIChcbiAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGUgfHxcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZSB8fFxuICAgICAgICB0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8XG4gICAgICAgIHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHxcbiAgICAgICAgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fFxuICAgICAgICB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8XG4gICAgICAgIHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fFxuICAgICAgICB0eXBlID09PSBSRUFDVF9PRkZTQ1JFRU5fVFlQRSB8fFxuICAgICAgICAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUgJiZcbiAgICAgICAgICBudWxsICE9PSB0eXBlICYmXG4gICAgICAgICAgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fFxuICAgICAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8XG4gICAgICAgICAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHxcbiAgICAgICAgICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlNVTUVSX1RZUEUgfHxcbiAgICAgICAgICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHxcbiAgICAgICAgICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSB8fFxuICAgICAgICAgICAgdm9pZCAwICE9PSB0eXBlLmdldE1vZHVsZUlkKSlcbiAgICAgICkge1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBjb25maWcuY2hpbGRyZW47XG4gICAgICAgIGlmICh2b2lkIDAgIT09IGNoaWxkcmVuKVxuICAgICAgICAgIGlmIChpc1N0YXRpY0NoaWxkcmVuKVxuICAgICAgICAgICAgaWYgKGlzQXJyYXlJbXBsKGNoaWxkcmVuKSkge1xuICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4gPSAwO1xuICAgICAgICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4gPCBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbisrXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbltpc1N0YXRpY0NoaWxkcmVuXSwgdHlwZSk7XG4gICAgICAgICAgICAgIE9iamVjdC5mcmVlemUgJiYgT2JqZWN0LmZyZWV6ZShjaGlsZHJlbik7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIlJlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuIFlvdSBhcmUgbGlrZWx5IGV4cGxpY2l0bHkgY2FsbGluZyBSZWFjdC5qc3hzIG9yIFJlYWN0LmpzeERFVi4gVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIGVsc2UgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW4sIHR5cGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hpbGRyZW4gPSBcIlwiO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgdm9pZCAwID09PSB0eXBlIHx8XG4gICAgICAgICAgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlICYmXG4gICAgICAgICAgICBudWxsICE9PSB0eXBlICYmXG4gICAgICAgICAgICAwID09PSBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGgpXG4gICAgICAgIClcbiAgICAgICAgICBjaGlsZHJlbiArPVxuICAgICAgICAgICAgXCIgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgICAgICBudWxsID09PSB0eXBlXG4gICAgICAgICAgPyAoaXNTdGF0aWNDaGlsZHJlbiA9IFwibnVsbFwiKVxuICAgICAgICAgIDogaXNBcnJheUltcGwodHlwZSlcbiAgICAgICAgICAgID8gKGlzU3RhdGljQ2hpbGRyZW4gPSBcImFycmF5XCIpXG4gICAgICAgICAgICA6IHZvaWQgMCAhPT0gdHlwZSAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEVcbiAgICAgICAgICAgICAgPyAoKGlzU3RhdGljQ2hpbGRyZW4gPVxuICAgICAgICAgICAgICAgICAgXCI8XCIgK1xuICAgICAgICAgICAgICAgICAgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8IFwiVW5rbm93blwiKSArXG4gICAgICAgICAgICAgICAgICBcIiAvPlwiKSxcbiAgICAgICAgICAgICAgICAoY2hpbGRyZW4gPVxuICAgICAgICAgICAgICAgICAgXCIgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD9cIikpXG4gICAgICAgICAgICAgIDogKGlzU3RhdGljQ2hpbGRyZW4gPSB0eXBlb2YgdHlwZSk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yIGJ1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXNcIixcbiAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuLFxuICAgICAgICAgIGNoaWxkcmVuXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIFwia2V5XCIpKSB7XG4gICAgICAgIGNoaWxkcmVuID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGNvbmZpZykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgcmV0dXJuIFwia2V5XCIgIT09IGs7XG4gICAgICAgIH0pO1xuICAgICAgICBpc1N0YXRpY0NoaWxkcmVuID1cbiAgICAgICAgICAwIDwga2V5cy5sZW5ndGhcbiAgICAgICAgICAgID8gXCJ7a2V5OiBzb21lS2V5LCBcIiArIGtleXMuam9pbihcIjogLi4uLCBcIikgKyBcIjogLi4ufVwiXG4gICAgICAgICAgICA6IFwie2tleTogc29tZUtleX1cIjtcbiAgICAgICAgZGlkV2FybkFib3V0S2V5U3ByZWFkW2NoaWxkcmVuICsgaXNTdGF0aWNDaGlsZHJlbl0gfHxcbiAgICAgICAgICAoKGtleXMgPVxuICAgICAgICAgICAgMCA8IGtleXMubGVuZ3RoID8gXCJ7XCIgKyBrZXlzLmpvaW4oXCI6IC4uLiwgXCIpICsgXCI6IC4uLn1cIiA6IFwie31cIiksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICdBIHByb3BzIG9iamVjdCBjb250YWluaW5nIGEgXCJrZXlcIiBwcm9wIGlzIGJlaW5nIHNwcmVhZCBpbnRvIEpTWDpcXG4gIGxldCBwcm9wcyA9ICVzO1xcbiAgPCVzIHsuLi5wcm9wc30gLz5cXG5SZWFjdCBrZXlzIG11c3QgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIEpTWCB3aXRob3V0IHVzaW5nIHNwcmVhZDpcXG4gIGxldCBwcm9wcyA9ICVzO1xcbiAgPCVzIGtleT17c29tZUtleX0gey4uLnByb3BzfSAvPicsXG4gICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuLFxuICAgICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAgICBrZXlzLFxuICAgICAgICAgICAgY2hpbGRyZW5cbiAgICAgICAgICApLFxuICAgICAgICAgIChkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY2hpbGRyZW4gKyBpc1N0YXRpY0NoaWxkcmVuXSA9ICEwKSk7XG4gICAgICB9XG4gICAgICBjaGlsZHJlbiA9IG51bGw7XG4gICAgICB2b2lkIDAgIT09IG1heWJlS2V5ICYmXG4gICAgICAgIChjaGVja0tleVN0cmluZ0NvZXJjaW9uKG1heWJlS2V5KSwgKGNoaWxkcmVuID0gXCJcIiArIG1heWJlS2V5KSk7XG4gICAgICBoYXNWYWxpZEtleShjb25maWcpICYmXG4gICAgICAgIChjaGVja0tleVN0cmluZ0NvZXJjaW9uKGNvbmZpZy5rZXkpLCAoY2hpbGRyZW4gPSBcIlwiICsgY29uZmlnLmtleSkpO1xuICAgICAgaWYgKFwia2V5XCIgaW4gY29uZmlnKSB7XG4gICAgICAgIG1heWJlS2V5ID0ge307XG4gICAgICAgIGZvciAodmFyIHByb3BOYW1lIGluIGNvbmZpZylcbiAgICAgICAgICBcImtleVwiICE9PSBwcm9wTmFtZSAmJiAobWF5YmVLZXlbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXSk7XG4gICAgICB9IGVsc2UgbWF5YmVLZXkgPSBjb25maWc7XG4gICAgICBjaGlsZHJlbiAmJlxuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihcbiAgICAgICAgICBtYXliZUtleSxcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlXG4gICAgICAgICAgICA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IFwiVW5rbm93blwiXG4gICAgICAgICAgICA6IHR5cGVcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwgY2hpbGRyZW4sIHNlbGYsIHNvdXJjZSwgZ2V0T3duZXIoKSwgbWF5YmVLZXkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gICAgICBpZiAoXG4gICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBub2RlICYmXG4gICAgICAgIG5vZGUgJiZcbiAgICAgICAgbm9kZS4kJHR5cGVvZiAhPT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRVxuICAgICAgKVxuICAgICAgICBpZiAoaXNBcnJheUltcGwobm9kZSkpXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuICAgICAgICAgICAgaXNWYWxpZEVsZW1lbnQoY2hpbGQpICYmIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpXG4gICAgICAgICAgbm9kZS5fc3RvcmUgJiYgKG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IDEpO1xuICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgICAobnVsbCA9PT0gbm9kZSB8fCBcIm9iamVjdFwiICE9PSB0eXBlb2Ygbm9kZVxuICAgICAgICAgICAgPyAoaSA9IG51bGwpXG4gICAgICAgICAgICA6ICgoaSA9XG4gICAgICAgICAgICAgICAgKE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBub2RlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0pIHx8XG4gICAgICAgICAgICAgICAgbm9kZVtcIkBAaXRlcmF0b3JcIl0pLFxuICAgICAgICAgICAgICAoaSA9IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGkgPyBpIDogbnVsbCkpLFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGkgJiZcbiAgICAgICAgICAgIGkgIT09IG5vZGUuZW50cmllcyAmJlxuICAgICAgICAgICAgKChpID0gaS5jYWxsKG5vZGUpKSwgaSAhPT0gbm9kZSkpXG4gICAgICAgIClcbiAgICAgICAgICBmb3IgKDsgIShub2RlID0gaS5uZXh0KCkpLmRvbmU7IClcbiAgICAgICAgICAgIGlzVmFsaWRFbGVtZW50KG5vZGUudmFsdWUpICYmXG4gICAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkobm9kZS52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG9iamVjdCAmJlxuICAgICAgICBudWxsICE9PSBvYmplY3QgJiZcbiAgICAgICAgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEVcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICAgICAgaWYgKFxuICAgICAgICBlbGVtZW50Ll9zdG9yZSAmJlxuICAgICAgICAhZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkICYmXG4gICAgICAgIG51bGwgPT0gZWxlbWVudC5rZXkgJiZcbiAgICAgICAgKChlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSAxKSxcbiAgICAgICAgKHBhcmVudFR5cGUgPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpKSxcbiAgICAgICAgIW93bmVySGFzS2V5VXNlV2FybmluZ1twYXJlbnRUeXBlXSlcbiAgICAgICkge1xuICAgICAgICBvd25lckhhc0tleVVzZVdhcm5pbmdbcGFyZW50VHlwZV0gPSAhMDtcbiAgICAgICAgdmFyIGNoaWxkT3duZXIgPSBcIlwiO1xuICAgICAgICBlbGVtZW50ICYmXG4gICAgICAgICAgbnVsbCAhPSBlbGVtZW50Ll9vd25lciAmJlxuICAgICAgICAgIGVsZW1lbnQuX293bmVyICE9PSBnZXRPd25lcigpICYmXG4gICAgICAgICAgKChjaGlsZE93bmVyID0gbnVsbCksXG4gICAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIGVsZW1lbnQuX293bmVyLnRhZ1xuICAgICAgICAgICAgPyAoY2hpbGRPd25lciA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShlbGVtZW50Ll9vd25lci50eXBlKSlcbiAgICAgICAgICAgIDogXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGVsZW1lbnQuX293bmVyLm5hbWUgJiZcbiAgICAgICAgICAgICAgKGNoaWxkT3duZXIgPSBlbGVtZW50Ll9vd25lci5uYW1lKSxcbiAgICAgICAgICAoY2hpbGRPd25lciA9IFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgY2hpbGRPd25lciArIFwiLlwiKSk7XG4gICAgICAgIHZhciBwcmV2R2V0Q3VycmVudFN0YWNrID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuZ2V0Q3VycmVudFN0YWNrO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSk7XG4gICAgICAgICAgcHJldkdldEN1cnJlbnRTdGFjayAmJiAoc3RhY2sgKz0gcHJldkdldEN1cnJlbnRTdGFjaygpIHx8IFwiXCIpO1xuICAgICAgICAgIHJldHVybiBzdGFjaztcbiAgICAgICAgfTtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAnRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLiVzJXMgU2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsXG4gICAgICAgICAgcGFyZW50VHlwZSxcbiAgICAgICAgICBjaGlsZE93bmVyXG4gICAgICAgICk7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjayA9IHByZXZHZXRDdXJyZW50U3RhY2s7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICAgICAgdmFyIGluZm8gPSBcIlwiLFxuICAgICAgICBvd25lciA9IGdldE93bmVyKCk7XG4gICAgICBvd25lciAmJlxuICAgICAgICAob3duZXIgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUob3duZXIudHlwZSkpICYmXG4gICAgICAgIChpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgXCIgKyBvd25lciArIFwiYC5cIik7XG4gICAgICBpbmZvIHx8XG4gICAgICAgICgocGFyZW50VHlwZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShwYXJlbnRUeXBlKSkgJiZcbiAgICAgICAgICAoaW5mbyA9XG4gICAgICAgICAgICBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50VHlwZSArIFwiPi5cIikpO1xuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuICAgIHZhciBSZWFjdCA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3RcIiksXG4gICAgICBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QudHJhbnNpdGlvbmFsLmVsZW1lbnRcIiksXG4gICAgICBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wb3J0YWxcIiksXG4gICAgICBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpLFxuICAgICAgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKSxcbiAgICAgIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvZmlsZXJcIik7XG4gICAgU3ltYm9sLmZvcihcInJlYWN0LnByb3ZpZGVyXCIpO1xuICAgIHZhciBSRUFDVF9DT05TVU1FUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnN1bWVyXCIpLFxuICAgICAgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIiksXG4gICAgICBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpLFxuICAgICAgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZVwiKSxcbiAgICAgIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZV9saXN0XCIpLFxuICAgICAgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIiksXG4gICAgICBSRUFDVF9MQVpZX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubGF6eVwiKSxcbiAgICAgIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0Lm9mZnNjcmVlblwiKSxcbiAgICAgIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcixcbiAgICAgIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMiA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpLFxuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPVxuICAgICAgICBSZWFjdC5fX0NMSUVOVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUsXG4gICAgICBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG4gICAgICBhc3NpZ24gPSBPYmplY3QuYXNzaWduLFxuICAgICAgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxID0gU3ltYm9sLmZvcihcInJlYWN0LmNsaWVudC5yZWZlcmVuY2VcIiksXG4gICAgICBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXksXG4gICAgICBkaXNhYmxlZERlcHRoID0gMCxcbiAgICAgIHByZXZMb2csXG4gICAgICBwcmV2SW5mbyxcbiAgICAgIHByZXZXYXJuLFxuICAgICAgcHJldkVycm9yLFxuICAgICAgcHJldkdyb3VwLFxuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkLFxuICAgICAgcHJldkdyb3VwRW5kO1xuICAgIGRpc2FibGVkTG9nLl9fcmVhY3REaXNhYmxlZExvZyA9ICEwO1xuICAgIHZhciBwcmVmaXgsXG4gICAgICBzdWZmaXgsXG4gICAgICByZWVudHJ5ID0gITE7XG4gICAgdmFyIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgKFxuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgV2Vha01hcCA/IFdlYWtNYXAgOiBNYXBcbiAgICApKCk7XG4gICAgdmFyIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UgPSBTeW1ib2wuZm9yKFwicmVhY3QuY2xpZW50LnJlZmVyZW5jZVwiKSxcbiAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xuICAgIHZhciBkaWRXYXJuQWJvdXRFbGVtZW50UmVmID0ge307XG4gICAgdmFyIGRpZFdhcm5BYm91dEtleVNwcmVhZCA9IHt9LFxuICAgICAgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG4gICAgZXhwb3J0cy5GcmFnbWVudCA9IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG4gICAgZXhwb3J0cy5qc3hERVYgPSBmdW5jdGlvbiAoXG4gICAgICB0eXBlLFxuICAgICAgY29uZmlnLFxuICAgICAgbWF5YmVLZXksXG4gICAgICBpc1N0YXRpY0NoaWxkcmVuLFxuICAgICAgc291cmNlLFxuICAgICAgc2VsZlxuICAgICkge1xuICAgICAgcmV0dXJuIGpzeERFVkltcGwodHlwZSwgY29uZmlnLCBtYXliZUtleSwgaXNTdGF0aWNDaGlsZHJlbiwgc291cmNlLCBzZWxmKTtcbiAgICB9O1xuICB9KSgpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL1dvbmRlclZpdGUtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5wcm9kdWN0aW9uLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/esm/wrapper.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@supabase/postgrest-js/dist/esm/wrapper.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PostgrestBuilder: () => (/* binding */ PostgrestBuilder),\n/* harmony export */   PostgrestClient: () => (/* binding */ PostgrestClient),\n/* harmony export */   PostgrestError: () => (/* binding */ PostgrestError),\n/* harmony export */   PostgrestFilterBuilder: () => (/* binding */ PostgrestFilterBuilder),\n/* harmony export */   PostgrestQueryBuilder: () => (/* binding */ PostgrestQueryBuilder),\n/* harmony export */   PostgrestTransformBuilder: () => (/* binding */ PostgrestTransformBuilder),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _cjs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cjs/index.js */ \"(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/index.js\");\n\nconst {\n  PostgrestClient,\n  PostgrestQueryBuilder,\n  PostgrestFilterBuilder,\n  PostgrestTransformBuilder,\n  PostgrestBuilder,\n  PostgrestError,\n} = _cjs_index_js__WEBPACK_IMPORTED_MODULE_0__\n\n\n\n// compatibility with CJS output\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  PostgrestClient,\n  PostgrestQueryBuilder,\n  PostgrestFilterBuilder,\n  PostgrestTransformBuilder,\n  PostgrestBuilder,\n  PostgrestError,\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL2Rpc3QvZXNtL3dyYXBwZXIubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLDBDQUFLOztBQVNSOztBQUVEO0FBQ0EsaUVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyIvVXNlcnMvd29uZGVybGFuZG1pdGNoL0Nhc2NhZGVQcm9qZWN0cy9Xb25kZXJWaXRlLWZyb250ZW5kL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL2Rpc3QvZXNtL3dyYXBwZXIubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBpbmRleCBmcm9tICcuLi9janMvaW5kZXguanMnXG5jb25zdCB7XG4gIFBvc3RncmVzdENsaWVudCxcbiAgUG9zdGdyZXN0UXVlcnlCdWlsZGVyLFxuICBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyLFxuICBQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyLFxuICBQb3N0Z3Jlc3RCdWlsZGVyLFxuICBQb3N0Z3Jlc3RFcnJvcixcbn0gPSBpbmRleFxuXG5leHBvcnQge1xuICBQb3N0Z3Jlc3RCdWlsZGVyLFxuICBQb3N0Z3Jlc3RDbGllbnQsXG4gIFBvc3RncmVzdEZpbHRlckJ1aWxkZXIsXG4gIFBvc3RncmVzdFF1ZXJ5QnVpbGRlcixcbiAgUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlcixcbiAgUG9zdGdyZXN0RXJyb3IsXG59XG5cbi8vIGNvbXBhdGliaWxpdHkgd2l0aCBDSlMgb3V0cHV0XG5leHBvcnQgZGVmYXVsdCB7XG4gIFBvc3RncmVzdENsaWVudCxcbiAgUG9zdGdyZXN0UXVlcnlCdWlsZGVyLFxuICBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyLFxuICBQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyLFxuICBQb3N0Z3Jlc3RCdWlsZGVyLFxuICBQb3N0Z3Jlc3RFcnJvcixcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/esm/wrapper.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/focusManager.js":
/*!************************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/modern/focusManager.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FocusManager: () => (/* binding */ FocusManager),\n/* harmony export */   focusManager: () => (/* binding */ focusManager)\n/* harmony export */ });\n/* harmony import */ var _subscribable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./subscribable.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/subscribable.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/utils.js\");\n// src/focusManager.ts\n\n\nvar FocusManager = class extends _subscribable_js__WEBPACK_IMPORTED_MODULE_0__.Subscribable {\n  #focused;\n  #cleanup;\n  #setup;\n  constructor() {\n    super();\n    this.#setup = (onFocus) => {\n      if (!_utils_js__WEBPACK_IMPORTED_MODULE_1__.isServer && window.addEventListener) {\n        const listener = () => onFocus();\n        window.addEventListener(\"visibilitychange\", listener, false);\n        return () => {\n          window.removeEventListener(\"visibilitychange\", listener);\n        };\n      }\n      return;\n    };\n  }\n  onSubscribe() {\n    if (!this.#cleanup) {\n      this.setEventListener(this.#setup);\n    }\n  }\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.#cleanup?.();\n      this.#cleanup = void 0;\n    }\n  }\n  setEventListener(setup) {\n    this.#setup = setup;\n    this.#cleanup?.();\n    this.#cleanup = setup((focused) => {\n      if (typeof focused === \"boolean\") {\n        this.setFocused(focused);\n      } else {\n        this.onFocus();\n      }\n    });\n  }\n  setFocused(focused) {\n    const changed = this.#focused !== focused;\n    if (changed) {\n      this.#focused = focused;\n      this.onFocus();\n    }\n  }\n  onFocus() {\n    const isFocused = this.isFocused();\n    this.listeners.forEach((listener) => {\n      listener(isFocused);\n    });\n  }\n  isFocused() {\n    if (typeof this.#focused === \"boolean\") {\n      return this.#focused;\n    }\n    return globalThis.document?.visibilityState !== \"hidden\";\n  }\n};\nvar focusManager = new FocusManager();\n\n//# sourceMappingURL=focusManager.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vZm9jdXNNYW5hZ2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNpRDtBQUNYO0FBQ3RDLGlDQUFpQywwREFBWTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLCtDQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUU7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvV29uZGVyVml0ZS1mcm9udGVuZC9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3F1ZXJ5LWNvcmUvYnVpbGQvbW9kZXJuL2ZvY3VzTWFuYWdlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvZm9jdXNNYW5hZ2VyLnRzXG5pbXBvcnQgeyBTdWJzY3JpYmFibGUgfSBmcm9tIFwiLi9zdWJzY3JpYmFibGUuanNcIjtcbmltcG9ydCB7IGlzU2VydmVyIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbnZhciBGb2N1c01hbmFnZXIgPSBjbGFzcyBleHRlbmRzIFN1YnNjcmliYWJsZSB7XG4gICNmb2N1c2VkO1xuICAjY2xlYW51cDtcbiAgI3NldHVwO1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuI3NldHVwID0gKG9uRm9jdXMpID0+IHtcbiAgICAgIGlmICghaXNTZXJ2ZXIgJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgY29uc3QgbGlzdGVuZXIgPSAoKSA9PiBvbkZvY3VzKCk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCBsaXN0ZW5lciwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCBsaXN0ZW5lcik7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfTtcbiAgfVxuICBvblN1YnNjcmliZSgpIHtcbiAgICBpZiAoIXRoaXMuI2NsZWFudXApIHtcbiAgICAgIHRoaXMuc2V0RXZlbnRMaXN0ZW5lcih0aGlzLiNzZXR1cCk7XG4gICAgfVxuICB9XG4gIG9uVW5zdWJzY3JpYmUoKSB7XG4gICAgaWYgKCF0aGlzLmhhc0xpc3RlbmVycygpKSB7XG4gICAgICB0aGlzLiNjbGVhbnVwPy4oKTtcbiAgICAgIHRoaXMuI2NsZWFudXAgPSB2b2lkIDA7XG4gICAgfVxuICB9XG4gIHNldEV2ZW50TGlzdGVuZXIoc2V0dXApIHtcbiAgICB0aGlzLiNzZXR1cCA9IHNldHVwO1xuICAgIHRoaXMuI2NsZWFudXA/LigpO1xuICAgIHRoaXMuI2NsZWFudXAgPSBzZXR1cCgoZm9jdXNlZCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBmb2N1c2VkID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICB0aGlzLnNldEZvY3VzZWQoZm9jdXNlZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9uRm9jdXMoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBzZXRGb2N1c2VkKGZvY3VzZWQpIHtcbiAgICBjb25zdCBjaGFuZ2VkID0gdGhpcy4jZm9jdXNlZCAhPT0gZm9jdXNlZDtcbiAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgdGhpcy4jZm9jdXNlZCA9IGZvY3VzZWQ7XG4gICAgICB0aGlzLm9uRm9jdXMoKTtcbiAgICB9XG4gIH1cbiAgb25Gb2N1cygpIHtcbiAgICBjb25zdCBpc0ZvY3VzZWQgPSB0aGlzLmlzRm9jdXNlZCgpO1xuICAgIHRoaXMubGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKSA9PiB7XG4gICAgICBsaXN0ZW5lcihpc0ZvY3VzZWQpO1xuICAgIH0pO1xuICB9XG4gIGlzRm9jdXNlZCgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuI2ZvY3VzZWQgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICByZXR1cm4gdGhpcy4jZm9jdXNlZDtcbiAgICB9XG4gICAgcmV0dXJuIGdsb2JhbFRoaXMuZG9jdW1lbnQ/LnZpc2liaWxpdHlTdGF0ZSAhPT0gXCJoaWRkZW5cIjtcbiAgfVxufTtcbnZhciBmb2N1c01hbmFnZXIgPSBuZXcgRm9jdXNNYW5hZ2VyKCk7XG5leHBvcnQge1xuICBGb2N1c01hbmFnZXIsXG4gIGZvY3VzTWFuYWdlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvY3VzTWFuYWdlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/focusManager.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/infiniteQueryBehavior.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/modern/infiniteQueryBehavior.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hasNextPage: () => (/* binding */ hasNextPage),\n/* harmony export */   hasPreviousPage: () => (/* binding */ hasPreviousPage),\n/* harmony export */   infiniteQueryBehavior: () => (/* binding */ infiniteQueryBehavior)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/utils.js\");\n// src/infiniteQueryBehavior.ts\n\nfunction infiniteQueryBehavior(pages) {\n  return {\n    onFetch: (context, query) => {\n      const options = context.options;\n      const direction = context.fetchOptions?.meta?.fetchMore?.direction;\n      const oldPages = context.state.data?.pages || [];\n      const oldPageParams = context.state.data?.pageParams || [];\n      let result = { pages: [], pageParams: [] };\n      let currentPage = 0;\n      const fetchFn = async () => {\n        let cancelled = false;\n        const addSignalProperty = (object) => {\n          Object.defineProperty(object, \"signal\", {\n            enumerable: true,\n            get: () => {\n              if (context.signal.aborted) {\n                cancelled = true;\n              } else {\n                context.signal.addEventListener(\"abort\", () => {\n                  cancelled = true;\n                });\n              }\n              return context.signal;\n            }\n          });\n        };\n        const queryFn = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureQueryFn)(context.options, context.fetchOptions);\n        const fetchPage = async (data, param, previous) => {\n          if (cancelled) {\n            return Promise.reject();\n          }\n          if (param == null && data.pages.length) {\n            return Promise.resolve(data);\n          }\n          const queryFnContext = {\n            queryKey: context.queryKey,\n            pageParam: param,\n            direction: previous ? \"backward\" : \"forward\",\n            meta: context.options.meta\n          };\n          addSignalProperty(queryFnContext);\n          const page = await queryFn(\n            queryFnContext\n          );\n          const { maxPages } = context.options;\n          const addTo = previous ? _utils_js__WEBPACK_IMPORTED_MODULE_0__.addToStart : _utils_js__WEBPACK_IMPORTED_MODULE_0__.addToEnd;\n          return {\n            pages: addTo(data.pages, page, maxPages),\n            pageParams: addTo(data.pageParams, param, maxPages)\n          };\n        };\n        if (direction && oldPages.length) {\n          const previous = direction === \"backward\";\n          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam;\n          const oldData = {\n            pages: oldPages,\n            pageParams: oldPageParams\n          };\n          const param = pageParamFn(options, oldData);\n          result = await fetchPage(oldData, param, previous);\n        } else {\n          const remainingPages = pages ?? oldPages.length;\n          do {\n            const param = currentPage === 0 ? oldPageParams[0] ?? options.initialPageParam : getNextPageParam(options, result);\n            if (currentPage > 0 && param == null) {\n              break;\n            }\n            result = await fetchPage(result, param);\n            currentPage++;\n          } while (currentPage < remainingPages);\n        }\n        return result;\n      };\n      if (context.options.persister) {\n        context.fetchFn = () => {\n          return context.options.persister?.(\n            fetchFn,\n            {\n              queryKey: context.queryKey,\n              meta: context.options.meta,\n              signal: context.signal\n            },\n            query\n          );\n        };\n      } else {\n        context.fetchFn = fetchFn;\n      }\n    }\n  };\n}\nfunction getNextPageParam(options, { pages, pageParams }) {\n  const lastIndex = pages.length - 1;\n  return pages.length > 0 ? options.getNextPageParam(\n    pages[lastIndex],\n    pages,\n    pageParams[lastIndex],\n    pageParams\n  ) : void 0;\n}\nfunction getPreviousPageParam(options, { pages, pageParams }) {\n  return pages.length > 0 ? options.getPreviousPageParam?.(pages[0], pages, pageParams[0], pageParams) : void 0;\n}\nfunction hasNextPage(options, data) {\n  if (!data)\n    return false;\n  return getNextPageParam(options, data) != null;\n}\nfunction hasPreviousPage(options, data) {\n  if (!data || !options.getPreviousPageParam)\n    return false;\n  return getPreviousPageParam(options, data) != null;\n}\n\n//# sourceMappingURL=infiniteQueryBehavior.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vaW5maW5pdGVRdWVyeUJlaGF2aW9yLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSx3QkFBd0Isd0RBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixXQUFXO0FBQzdCLG1DQUFtQyxpREFBVSxHQUFHLCtDQUFRO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG1CQUFtQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLG1CQUFtQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvd29uZGVybGFuZG1pdGNoL0Nhc2NhZGVQcm9qZWN0cy9Xb25kZXJWaXRlLWZyb250ZW5kL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vaW5maW5pdGVRdWVyeUJlaGF2aW9yLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9pbmZpbml0ZVF1ZXJ5QmVoYXZpb3IudHNcbmltcG9ydCB7IGFkZFRvRW5kLCBhZGRUb1N0YXJ0LCBlbnN1cmVRdWVyeUZuIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbmZ1bmN0aW9uIGluZmluaXRlUXVlcnlCZWhhdmlvcihwYWdlcykge1xuICByZXR1cm4ge1xuICAgIG9uRmV0Y2g6IChjb250ZXh0LCBxdWVyeSkgPT4ge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IGNvbnRleHQub3B0aW9ucztcbiAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IGNvbnRleHQuZmV0Y2hPcHRpb25zPy5tZXRhPy5mZXRjaE1vcmU/LmRpcmVjdGlvbjtcbiAgICAgIGNvbnN0IG9sZFBhZ2VzID0gY29udGV4dC5zdGF0ZS5kYXRhPy5wYWdlcyB8fCBbXTtcbiAgICAgIGNvbnN0IG9sZFBhZ2VQYXJhbXMgPSBjb250ZXh0LnN0YXRlLmRhdGE/LnBhZ2VQYXJhbXMgfHwgW107XG4gICAgICBsZXQgcmVzdWx0ID0geyBwYWdlczogW10sIHBhZ2VQYXJhbXM6IFtdIH07XG4gICAgICBsZXQgY3VycmVudFBhZ2UgPSAwO1xuICAgICAgY29uc3QgZmV0Y2hGbiA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBhZGRTaWduYWxQcm9wZXJ0eSA9IChvYmplY3QpID0+IHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBcInNpZ25hbFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiAoKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChjb250ZXh0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5zaWduYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHF1ZXJ5Rm4gPSBlbnN1cmVRdWVyeUZuKGNvbnRleHQub3B0aW9ucywgY29udGV4dC5mZXRjaE9wdGlvbnMpO1xuICAgICAgICBjb25zdCBmZXRjaFBhZ2UgPSBhc3luYyAoZGF0YSwgcGFyYW0sIHByZXZpb3VzKSA9PiB7XG4gICAgICAgICAgaWYgKGNhbmNlbGxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwYXJhbSA9PSBudWxsICYmIGRhdGEucGFnZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBxdWVyeUZuQ29udGV4dCA9IHtcbiAgICAgICAgICAgIHF1ZXJ5S2V5OiBjb250ZXh0LnF1ZXJ5S2V5LFxuICAgICAgICAgICAgcGFnZVBhcmFtOiBwYXJhbSxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogcHJldmlvdXMgPyBcImJhY2t3YXJkXCIgOiBcImZvcndhcmRcIixcbiAgICAgICAgICAgIG1ldGE6IGNvbnRleHQub3B0aW9ucy5tZXRhXG4gICAgICAgICAgfTtcbiAgICAgICAgICBhZGRTaWduYWxQcm9wZXJ0eShxdWVyeUZuQ29udGV4dCk7XG4gICAgICAgICAgY29uc3QgcGFnZSA9IGF3YWl0IHF1ZXJ5Rm4oXG4gICAgICAgICAgICBxdWVyeUZuQ29udGV4dFxuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3QgeyBtYXhQYWdlcyB9ID0gY29udGV4dC5vcHRpb25zO1xuICAgICAgICAgIGNvbnN0IGFkZFRvID0gcHJldmlvdXMgPyBhZGRUb1N0YXJ0IDogYWRkVG9FbmQ7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBhZ2VzOiBhZGRUbyhkYXRhLnBhZ2VzLCBwYWdlLCBtYXhQYWdlcyksXG4gICAgICAgICAgICBwYWdlUGFyYW1zOiBhZGRUbyhkYXRhLnBhZ2VQYXJhbXMsIHBhcmFtLCBtYXhQYWdlcylcbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICBpZiAoZGlyZWN0aW9uICYmIG9sZFBhZ2VzLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IHByZXZpb3VzID0gZGlyZWN0aW9uID09PSBcImJhY2t3YXJkXCI7XG4gICAgICAgICAgY29uc3QgcGFnZVBhcmFtRm4gPSBwcmV2aW91cyA/IGdldFByZXZpb3VzUGFnZVBhcmFtIDogZ2V0TmV4dFBhZ2VQYXJhbTtcbiAgICAgICAgICBjb25zdCBvbGREYXRhID0ge1xuICAgICAgICAgICAgcGFnZXM6IG9sZFBhZ2VzLFxuICAgICAgICAgICAgcGFnZVBhcmFtczogb2xkUGFnZVBhcmFtc1xuICAgICAgICAgIH07XG4gICAgICAgICAgY29uc3QgcGFyYW0gPSBwYWdlUGFyYW1GbihvcHRpb25zLCBvbGREYXRhKTtcbiAgICAgICAgICByZXN1bHQgPSBhd2FpdCBmZXRjaFBhZ2Uob2xkRGF0YSwgcGFyYW0sIHByZXZpb3VzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCByZW1haW5pbmdQYWdlcyA9IHBhZ2VzID8/IG9sZFBhZ2VzLmxlbmd0aDtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbSA9IGN1cnJlbnRQYWdlID09PSAwID8gb2xkUGFnZVBhcmFtc1swXSA/PyBvcHRpb25zLmluaXRpYWxQYWdlUGFyYW0gOiBnZXROZXh0UGFnZVBhcmFtKG9wdGlvbnMsIHJlc3VsdCk7XG4gICAgICAgICAgICBpZiAoY3VycmVudFBhZ2UgPiAwICYmIHBhcmFtID09IG51bGwpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSBhd2FpdCBmZXRjaFBhZ2UocmVzdWx0LCBwYXJhbSk7XG4gICAgICAgICAgICBjdXJyZW50UGFnZSsrO1xuICAgICAgICAgIH0gd2hpbGUgKGN1cnJlbnRQYWdlIDwgcmVtYWluaW5nUGFnZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgaWYgKGNvbnRleHQub3B0aW9ucy5wZXJzaXN0ZXIpIHtcbiAgICAgICAgY29udGV4dC5mZXRjaEZuID0gKCkgPT4ge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0Lm9wdGlvbnMucGVyc2lzdGVyPy4oXG4gICAgICAgICAgICBmZXRjaEZuLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBxdWVyeUtleTogY29udGV4dC5xdWVyeUtleSxcbiAgICAgICAgICAgICAgbWV0YTogY29udGV4dC5vcHRpb25zLm1ldGEsXG4gICAgICAgICAgICAgIHNpZ25hbDogY29udGV4dC5zaWduYWxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBxdWVyeVxuICAgICAgICAgICk7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0LmZldGNoRm4gPSBmZXRjaEZuO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGdldE5leHRQYWdlUGFyYW0ob3B0aW9ucywgeyBwYWdlcywgcGFnZVBhcmFtcyB9KSB7XG4gIGNvbnN0IGxhc3RJbmRleCA9IHBhZ2VzLmxlbmd0aCAtIDE7XG4gIHJldHVybiBwYWdlcy5sZW5ndGggPiAwID8gb3B0aW9ucy5nZXROZXh0UGFnZVBhcmFtKFxuICAgIHBhZ2VzW2xhc3RJbmRleF0sXG4gICAgcGFnZXMsXG4gICAgcGFnZVBhcmFtc1tsYXN0SW5kZXhdLFxuICAgIHBhZ2VQYXJhbXNcbiAgKSA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGdldFByZXZpb3VzUGFnZVBhcmFtKG9wdGlvbnMsIHsgcGFnZXMsIHBhZ2VQYXJhbXMgfSkge1xuICByZXR1cm4gcGFnZXMubGVuZ3RoID4gMCA/IG9wdGlvbnMuZ2V0UHJldmlvdXNQYWdlUGFyYW0/LihwYWdlc1swXSwgcGFnZXMsIHBhZ2VQYXJhbXNbMF0sIHBhZ2VQYXJhbXMpIDogdm9pZCAwO1xufVxuZnVuY3Rpb24gaGFzTmV4dFBhZ2Uob3B0aW9ucywgZGF0YSkge1xuICBpZiAoIWRhdGEpXG4gICAgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gZ2V0TmV4dFBhZ2VQYXJhbShvcHRpb25zLCBkYXRhKSAhPSBudWxsO1xufVxuZnVuY3Rpb24gaGFzUHJldmlvdXNQYWdlKG9wdGlvbnMsIGRhdGEpIHtcbiAgaWYgKCFkYXRhIHx8ICFvcHRpb25zLmdldFByZXZpb3VzUGFnZVBhcmFtKVxuICAgIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGdldFByZXZpb3VzUGFnZVBhcmFtKG9wdGlvbnMsIGRhdGEpICE9IG51bGw7XG59XG5leHBvcnQge1xuICBoYXNOZXh0UGFnZSxcbiAgaGFzUHJldmlvdXNQYWdlLFxuICBpbmZpbml0ZVF1ZXJ5QmVoYXZpb3Jcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmZpbml0ZVF1ZXJ5QmVoYXZpb3IuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/infiniteQueryBehavior.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/mutation.js":
/*!********************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/modern/mutation.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Mutation: () => (/* binding */ Mutation),\n/* harmony export */   getDefaultState: () => (/* binding */ getDefaultState)\n/* harmony export */ });\n/* harmony import */ var _notifyManager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./notifyManager.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/notifyManager.js\");\n/* harmony import */ var _removable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./removable.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/removable.js\");\n/* harmony import */ var _retryer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./retryer.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/retryer.js\");\n// src/mutation.ts\n\n\n\nvar Mutation = class extends _removable_js__WEBPACK_IMPORTED_MODULE_0__.Removable {\n  #observers;\n  #mutationCache;\n  #retryer;\n  constructor(config) {\n    super();\n    this.mutationId = config.mutationId;\n    this.#mutationCache = config.mutationCache;\n    this.#observers = [];\n    this.state = config.state || getDefaultState();\n    this.setOptions(config.options);\n    this.scheduleGc();\n  }\n  setOptions(options) {\n    this.options = options;\n    this.updateGcTime(this.options.gcTime);\n  }\n  get meta() {\n    return this.options.meta;\n  }\n  addObserver(observer) {\n    if (!this.#observers.includes(observer)) {\n      this.#observers.push(observer);\n      this.clearGcTimeout();\n      this.#mutationCache.notify({\n        type: \"observerAdded\",\n        mutation: this,\n        observer\n      });\n    }\n  }\n  removeObserver(observer) {\n    this.#observers = this.#observers.filter((x) => x !== observer);\n    this.scheduleGc();\n    this.#mutationCache.notify({\n      type: \"observerRemoved\",\n      mutation: this,\n      observer\n    });\n  }\n  optionalRemove() {\n    if (!this.#observers.length) {\n      if (this.state.status === \"pending\") {\n        this.scheduleGc();\n      } else {\n        this.#mutationCache.remove(this);\n      }\n    }\n  }\n  continue() {\n    return this.#retryer?.continue() ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before\n    this.execute(this.state.variables);\n  }\n  async execute(variables) {\n    this.#retryer = (0,_retryer_js__WEBPACK_IMPORTED_MODULE_1__.createRetryer)({\n      fn: () => {\n        if (!this.options.mutationFn) {\n          return Promise.reject(new Error(\"No mutationFn found\"));\n        }\n        return this.options.mutationFn(variables);\n      },\n      onFail: (failureCount, error) => {\n        this.#dispatch({ type: \"failed\", failureCount, error });\n      },\n      onPause: () => {\n        this.#dispatch({ type: \"pause\" });\n      },\n      onContinue: () => {\n        this.#dispatch({ type: \"continue\" });\n      },\n      retry: this.options.retry ?? 0,\n      retryDelay: this.options.retryDelay,\n      networkMode: this.options.networkMode,\n      canRun: () => this.#mutationCache.canRun(this)\n    });\n    const restored = this.state.status === \"pending\";\n    const isPaused = !this.#retryer.canStart();\n    try {\n      if (!restored) {\n        this.#dispatch({ type: \"pending\", variables, isPaused });\n        await this.#mutationCache.config.onMutate?.(\n          variables,\n          this\n        );\n        const context = await this.options.onMutate?.(variables);\n        if (context !== this.state.context) {\n          this.#dispatch({\n            type: \"pending\",\n            context,\n            variables,\n            isPaused\n          });\n        }\n      }\n      const data = await this.#retryer.start();\n      await this.#mutationCache.config.onSuccess?.(\n        data,\n        variables,\n        this.state.context,\n        this\n      );\n      await this.options.onSuccess?.(data, variables, this.state.context);\n      await this.#mutationCache.config.onSettled?.(\n        data,\n        null,\n        this.state.variables,\n        this.state.context,\n        this\n      );\n      await this.options.onSettled?.(data, null, variables, this.state.context);\n      this.#dispatch({ type: \"success\", data });\n      return data;\n    } catch (error) {\n      try {\n        await this.#mutationCache.config.onError?.(\n          error,\n          variables,\n          this.state.context,\n          this\n        );\n        await this.options.onError?.(\n          error,\n          variables,\n          this.state.context\n        );\n        await this.#mutationCache.config.onSettled?.(\n          void 0,\n          error,\n          this.state.variables,\n          this.state.context,\n          this\n        );\n        await this.options.onSettled?.(\n          void 0,\n          error,\n          variables,\n          this.state.context\n        );\n        throw error;\n      } finally {\n        this.#dispatch({ type: \"error\", error });\n      }\n    } finally {\n      this.#mutationCache.runNext(this);\n    }\n  }\n  #dispatch(action) {\n    const reducer = (state) => {\n      switch (action.type) {\n        case \"failed\":\n          return {\n            ...state,\n            failureCount: action.failureCount,\n            failureReason: action.error\n          };\n        case \"pause\":\n          return {\n            ...state,\n            isPaused: true\n          };\n        case \"continue\":\n          return {\n            ...state,\n            isPaused: false\n          };\n        case \"pending\":\n          return {\n            ...state,\n            context: action.context,\n            data: void 0,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            isPaused: action.isPaused,\n            status: \"pending\",\n            variables: action.variables,\n            submittedAt: Date.now()\n          };\n        case \"success\":\n          return {\n            ...state,\n            data: action.data,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            status: \"success\",\n            isPaused: false\n          };\n        case \"error\":\n          return {\n            ...state,\n            data: void 0,\n            error: action.error,\n            failureCount: state.failureCount + 1,\n            failureReason: action.error,\n            isPaused: false,\n            status: \"error\"\n          };\n      }\n    };\n    this.state = reducer(this.state);\n    _notifyManager_js__WEBPACK_IMPORTED_MODULE_2__.notifyManager.batch(() => {\n      this.#observers.forEach((observer) => {\n        observer.onMutationUpdate(action);\n      });\n      this.#mutationCache.notify({\n        mutation: this,\n        type: \"updated\",\n        action\n      });\n    });\n  }\n};\nfunction getDefaultState() {\n  return {\n    context: void 0,\n    data: void 0,\n    error: null,\n    failureCount: 0,\n    failureReason: null,\n    isPaused: false,\n    status: \"idle\",\n    variables: void 0,\n    submittedAt: 0\n  };\n}\n\n//# sourceMappingURL=mutation.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vbXV0YXRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNtRDtBQUNSO0FBQ0U7QUFDN0MsNkJBQTZCLG9EQUFTO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMERBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHlCQUF5QixxQ0FBcUM7QUFDOUQsT0FBTztBQUNQO0FBQ0EseUJBQXlCLGVBQWU7QUFDeEMsT0FBTztBQUNQO0FBQ0EseUJBQXlCLGtCQUFrQjtBQUMzQyxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsc0NBQXNDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHlCQUF5QixzQkFBc0I7QUFDL0M7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDREQUFhO0FBQ2pCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL1dvbmRlclZpdGUtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9xdWVyeS1jb3JlL2J1aWxkL21vZGVybi9tdXRhdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvbXV0YXRpb24udHNcbmltcG9ydCB7IG5vdGlmeU1hbmFnZXIgfSBmcm9tIFwiLi9ub3RpZnlNYW5hZ2VyLmpzXCI7XG5pbXBvcnQgeyBSZW1vdmFibGUgfSBmcm9tIFwiLi9yZW1vdmFibGUuanNcIjtcbmltcG9ydCB7IGNyZWF0ZVJldHJ5ZXIgfSBmcm9tIFwiLi9yZXRyeWVyLmpzXCI7XG52YXIgTXV0YXRpb24gPSBjbGFzcyBleHRlbmRzIFJlbW92YWJsZSB7XG4gICNvYnNlcnZlcnM7XG4gICNtdXRhdGlvbkNhY2hlO1xuICAjcmV0cnllcjtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm11dGF0aW9uSWQgPSBjb25maWcubXV0YXRpb25JZDtcbiAgICB0aGlzLiNtdXRhdGlvbkNhY2hlID0gY29uZmlnLm11dGF0aW9uQ2FjaGU7XG4gICAgdGhpcy4jb2JzZXJ2ZXJzID0gW107XG4gICAgdGhpcy5zdGF0ZSA9IGNvbmZpZy5zdGF0ZSB8fCBnZXREZWZhdWx0U3RhdGUoKTtcbiAgICB0aGlzLnNldE9wdGlvbnMoY29uZmlnLm9wdGlvbnMpO1xuICAgIHRoaXMuc2NoZWR1bGVHYygpO1xuICB9XG4gIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy51cGRhdGVHY1RpbWUodGhpcy5vcHRpb25zLmdjVGltZSk7XG4gIH1cbiAgZ2V0IG1ldGEoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5tZXRhO1xuICB9XG4gIGFkZE9ic2VydmVyKG9ic2VydmVyKSB7XG4gICAgaWYgKCF0aGlzLiNvYnNlcnZlcnMuaW5jbHVkZXMob2JzZXJ2ZXIpKSB7XG4gICAgICB0aGlzLiNvYnNlcnZlcnMucHVzaChvYnNlcnZlcik7XG4gICAgICB0aGlzLmNsZWFyR2NUaW1lb3V0KCk7XG4gICAgICB0aGlzLiNtdXRhdGlvbkNhY2hlLm5vdGlmeSh7XG4gICAgICAgIHR5cGU6IFwib2JzZXJ2ZXJBZGRlZFwiLFxuICAgICAgICBtdXRhdGlvbjogdGhpcyxcbiAgICAgICAgb2JzZXJ2ZXJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZW1vdmVPYnNlcnZlcihvYnNlcnZlcikge1xuICAgIHRoaXMuI29ic2VydmVycyA9IHRoaXMuI29ic2VydmVycy5maWx0ZXIoKHgpID0+IHggIT09IG9ic2VydmVyKTtcbiAgICB0aGlzLnNjaGVkdWxlR2MoKTtcbiAgICB0aGlzLiNtdXRhdGlvbkNhY2hlLm5vdGlmeSh7XG4gICAgICB0eXBlOiBcIm9ic2VydmVyUmVtb3ZlZFwiLFxuICAgICAgbXV0YXRpb246IHRoaXMsXG4gICAgICBvYnNlcnZlclxuICAgIH0pO1xuICB9XG4gIG9wdGlvbmFsUmVtb3ZlKCkge1xuICAgIGlmICghdGhpcy4jb2JzZXJ2ZXJzLmxlbmd0aCkge1xuICAgICAgaWYgKHRoaXMuc3RhdGUuc3RhdHVzID09PSBcInBlbmRpbmdcIikge1xuICAgICAgICB0aGlzLnNjaGVkdWxlR2MoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuI211dGF0aW9uQ2FjaGUucmVtb3ZlKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb250aW51ZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jcmV0cnllcj8uY29udGludWUoKSA/PyAvLyBjb250aW51aW5nIGEgbXV0YXRpb24gYXNzdW1lcyB0aGF0IHZhcmlhYmxlcyBhcmUgc2V0LCBtdXRhdGlvbiBtdXN0IGhhdmUgYmVlbiBkZWh5ZHJhdGVkIGJlZm9yZVxuICAgIHRoaXMuZXhlY3V0ZSh0aGlzLnN0YXRlLnZhcmlhYmxlcyk7XG4gIH1cbiAgYXN5bmMgZXhlY3V0ZSh2YXJpYWJsZXMpIHtcbiAgICB0aGlzLiNyZXRyeWVyID0gY3JlYXRlUmV0cnllcih7XG4gICAgICBmbjogKCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5tdXRhdGlvbkZuKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIk5vIG11dGF0aW9uRm4gZm91bmRcIikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMubXV0YXRpb25Gbih2YXJpYWJsZXMpO1xuICAgICAgfSxcbiAgICAgIG9uRmFpbDogKGZhaWx1cmVDb3VudCwgZXJyb3IpID0+IHtcbiAgICAgICAgdGhpcy4jZGlzcGF0Y2goeyB0eXBlOiBcImZhaWxlZFwiLCBmYWlsdXJlQ291bnQsIGVycm9yIH0pO1xuICAgICAgfSxcbiAgICAgIG9uUGF1c2U6ICgpID0+IHtcbiAgICAgICAgdGhpcy4jZGlzcGF0Y2goeyB0eXBlOiBcInBhdXNlXCIgfSk7XG4gICAgICB9LFxuICAgICAgb25Db250aW51ZTogKCkgPT4ge1xuICAgICAgICB0aGlzLiNkaXNwYXRjaCh7IHR5cGU6IFwiY29udGludWVcIiB9KTtcbiAgICAgIH0sXG4gICAgICByZXRyeTogdGhpcy5vcHRpb25zLnJldHJ5ID8/IDAsXG4gICAgICByZXRyeURlbGF5OiB0aGlzLm9wdGlvbnMucmV0cnlEZWxheSxcbiAgICAgIG5ldHdvcmtNb2RlOiB0aGlzLm9wdGlvbnMubmV0d29ya01vZGUsXG4gICAgICBjYW5SdW46ICgpID0+IHRoaXMuI211dGF0aW9uQ2FjaGUuY2FuUnVuKHRoaXMpXG4gICAgfSk7XG4gICAgY29uc3QgcmVzdG9yZWQgPSB0aGlzLnN0YXRlLnN0YXR1cyA9PT0gXCJwZW5kaW5nXCI7XG4gICAgY29uc3QgaXNQYXVzZWQgPSAhdGhpcy4jcmV0cnllci5jYW5TdGFydCgpO1xuICAgIHRyeSB7XG4gICAgICBpZiAoIXJlc3RvcmVkKSB7XG4gICAgICAgIHRoaXMuI2Rpc3BhdGNoKHsgdHlwZTogXCJwZW5kaW5nXCIsIHZhcmlhYmxlcywgaXNQYXVzZWQgfSk7XG4gICAgICAgIGF3YWl0IHRoaXMuI211dGF0aW9uQ2FjaGUuY29uZmlnLm9uTXV0YXRlPy4oXG4gICAgICAgICAgdmFyaWFibGVzLFxuICAgICAgICAgIHRoaXNcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IGF3YWl0IHRoaXMub3B0aW9ucy5vbk11dGF0ZT8uKHZhcmlhYmxlcyk7XG4gICAgICAgIGlmIChjb250ZXh0ICE9PSB0aGlzLnN0YXRlLmNvbnRleHQpIHtcbiAgICAgICAgICB0aGlzLiNkaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiBcInBlbmRpbmdcIixcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICB2YXJpYWJsZXMsXG4gICAgICAgICAgICBpc1BhdXNlZFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy4jcmV0cnllci5zdGFydCgpO1xuICAgICAgYXdhaXQgdGhpcy4jbXV0YXRpb25DYWNoZS5jb25maWcub25TdWNjZXNzPy4oXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHZhcmlhYmxlcyxcbiAgICAgICAgdGhpcy5zdGF0ZS5jb250ZXh0LFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgICAgYXdhaXQgdGhpcy5vcHRpb25zLm9uU3VjY2Vzcz8uKGRhdGEsIHZhcmlhYmxlcywgdGhpcy5zdGF0ZS5jb250ZXh0KTtcbiAgICAgIGF3YWl0IHRoaXMuI211dGF0aW9uQ2FjaGUuY29uZmlnLm9uU2V0dGxlZD8uKFxuICAgICAgICBkYXRhLFxuICAgICAgICBudWxsLFxuICAgICAgICB0aGlzLnN0YXRlLnZhcmlhYmxlcyxcbiAgICAgICAgdGhpcy5zdGF0ZS5jb250ZXh0LFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgICAgYXdhaXQgdGhpcy5vcHRpb25zLm9uU2V0dGxlZD8uKGRhdGEsIG51bGwsIHZhcmlhYmxlcywgdGhpcy5zdGF0ZS5jb250ZXh0KTtcbiAgICAgIHRoaXMuI2Rpc3BhdGNoKHsgdHlwZTogXCJzdWNjZXNzXCIsIGRhdGEgfSk7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy4jbXV0YXRpb25DYWNoZS5jb25maWcub25FcnJvcj8uKFxuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIHZhcmlhYmxlcyxcbiAgICAgICAgICB0aGlzLnN0YXRlLmNvbnRleHQsXG4gICAgICAgICAgdGhpc1xuICAgICAgICApO1xuICAgICAgICBhd2FpdCB0aGlzLm9wdGlvbnMub25FcnJvcj8uKFxuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIHZhcmlhYmxlcyxcbiAgICAgICAgICB0aGlzLnN0YXRlLmNvbnRleHRcbiAgICAgICAgKTtcbiAgICAgICAgYXdhaXQgdGhpcy4jbXV0YXRpb25DYWNoZS5jb25maWcub25TZXR0bGVkPy4oXG4gICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIHRoaXMuc3RhdGUudmFyaWFibGVzLFxuICAgICAgICAgIHRoaXMuc3RhdGUuY29udGV4dCxcbiAgICAgICAgICB0aGlzXG4gICAgICAgICk7XG4gICAgICAgIGF3YWl0IHRoaXMub3B0aW9ucy5vblNldHRsZWQ/LihcbiAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgdmFyaWFibGVzLFxuICAgICAgICAgIHRoaXMuc3RhdGUuY29udGV4dFxuICAgICAgICApO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMuI2Rpc3BhdGNoKHsgdHlwZTogXCJlcnJvclwiLCBlcnJvciB9KTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy4jbXV0YXRpb25DYWNoZS5ydW5OZXh0KHRoaXMpO1xuICAgIH1cbiAgfVxuICAjZGlzcGF0Y2goYWN0aW9uKSB7XG4gICAgY29uc3QgcmVkdWNlciA9IChzdGF0ZSkgPT4ge1xuICAgICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlIFwiZmFpbGVkXCI6XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgZmFpbHVyZUNvdW50OiBhY3Rpb24uZmFpbHVyZUNvdW50LFxuICAgICAgICAgICAgZmFpbHVyZVJlYXNvbjogYWN0aW9uLmVycm9yXG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcInBhdXNlXCI6XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgaXNQYXVzZWQ6IHRydWVcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFwiY29udGludWVcIjpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICBpc1BhdXNlZDogZmFsc2VcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFwicGVuZGluZ1wiOlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgIGNvbnRleHQ6IGFjdGlvbi5jb250ZXh0LFxuICAgICAgICAgICAgZGF0YTogdm9pZCAwLFxuICAgICAgICAgICAgZmFpbHVyZUNvdW50OiAwLFxuICAgICAgICAgICAgZmFpbHVyZVJlYXNvbjogbnVsbCxcbiAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgaXNQYXVzZWQ6IGFjdGlvbi5pc1BhdXNlZCxcbiAgICAgICAgICAgIHN0YXR1czogXCJwZW5kaW5nXCIsXG4gICAgICAgICAgICB2YXJpYWJsZXM6IGFjdGlvbi52YXJpYWJsZXMsXG4gICAgICAgICAgICBzdWJtaXR0ZWRBdDogRGF0ZS5ub3coKVxuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgXCJzdWNjZXNzXCI6XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgZGF0YTogYWN0aW9uLmRhdGEsXG4gICAgICAgICAgICBmYWlsdXJlQ291bnQ6IDAsXG4gICAgICAgICAgICBmYWlsdXJlUmVhc29uOiBudWxsLFxuICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICBzdGF0dXM6IFwic3VjY2Vzc1wiLFxuICAgICAgICAgICAgaXNQYXVzZWQ6IGZhbHNlXG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgZGF0YTogdm9pZCAwLFxuICAgICAgICAgICAgZXJyb3I6IGFjdGlvbi5lcnJvcixcbiAgICAgICAgICAgIGZhaWx1cmVDb3VudDogc3RhdGUuZmFpbHVyZUNvdW50ICsgMSxcbiAgICAgICAgICAgIGZhaWx1cmVSZWFzb246IGFjdGlvbi5lcnJvcixcbiAgICAgICAgICAgIGlzUGF1c2VkOiBmYWxzZSxcbiAgICAgICAgICAgIHN0YXR1czogXCJlcnJvclwiXG4gICAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuc3RhdGUgPSByZWR1Y2VyKHRoaXMuc3RhdGUpO1xuICAgIG5vdGlmeU1hbmFnZXIuYmF0Y2goKCkgPT4ge1xuICAgICAgdGhpcy4jb2JzZXJ2ZXJzLmZvckVhY2goKG9ic2VydmVyKSA9PiB7XG4gICAgICAgIG9ic2VydmVyLm9uTXV0YXRpb25VcGRhdGUoYWN0aW9uKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy4jbXV0YXRpb25DYWNoZS5ub3RpZnkoe1xuICAgICAgICBtdXRhdGlvbjogdGhpcyxcbiAgICAgICAgdHlwZTogXCJ1cGRhdGVkXCIsXG4gICAgICAgIGFjdGlvblxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn07XG5mdW5jdGlvbiBnZXREZWZhdWx0U3RhdGUoKSB7XG4gIHJldHVybiB7XG4gICAgY29udGV4dDogdm9pZCAwLFxuICAgIGRhdGE6IHZvaWQgMCxcbiAgICBlcnJvcjogbnVsbCxcbiAgICBmYWlsdXJlQ291bnQ6IDAsXG4gICAgZmFpbHVyZVJlYXNvbjogbnVsbCxcbiAgICBpc1BhdXNlZDogZmFsc2UsXG4gICAgc3RhdHVzOiBcImlkbGVcIixcbiAgICB2YXJpYWJsZXM6IHZvaWQgMCxcbiAgICBzdWJtaXR0ZWRBdDogMFxuICB9O1xufVxuZXhwb3J0IHtcbiAgTXV0YXRpb24sXG4gIGdldERlZmF1bHRTdGF0ZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW11dGF0aW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/mutation.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/mutationCache.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/modern/mutationCache.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MutationCache: () => (/* binding */ MutationCache)\n/* harmony export */ });\n/* harmony import */ var _notifyManager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./notifyManager.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/notifyManager.js\");\n/* harmony import */ var _mutation_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mutation.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/mutation.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/utils.js\");\n/* harmony import */ var _subscribable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./subscribable.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/subscribable.js\");\n// src/mutationCache.ts\n\n\n\n\nvar MutationCache = class extends _subscribable_js__WEBPACK_IMPORTED_MODULE_0__.Subscribable {\n  constructor(config = {}) {\n    super();\n    this.config = config;\n    this.#mutations = /* @__PURE__ */ new Map();\n    this.#mutationId = Date.now();\n  }\n  #mutations;\n  #mutationId;\n  build(client, options, state) {\n    const mutation = new _mutation_js__WEBPACK_IMPORTED_MODULE_1__.Mutation({\n      mutationCache: this,\n      mutationId: ++this.#mutationId,\n      options: client.defaultMutationOptions(options),\n      state\n    });\n    this.add(mutation);\n    return mutation;\n  }\n  add(mutation) {\n    const scope = scopeFor(mutation);\n    const mutations = this.#mutations.get(scope) ?? [];\n    mutations.push(mutation);\n    this.#mutations.set(scope, mutations);\n    this.notify({ type: \"added\", mutation });\n  }\n  remove(mutation) {\n    const scope = scopeFor(mutation);\n    if (this.#mutations.has(scope)) {\n      const mutations = this.#mutations.get(scope)?.filter((x) => x !== mutation);\n      if (mutations) {\n        if (mutations.length === 0) {\n          this.#mutations.delete(scope);\n        } else {\n          this.#mutations.set(scope, mutations);\n        }\n      }\n    }\n    this.notify({ type: \"removed\", mutation });\n  }\n  canRun(mutation) {\n    const firstPendingMutation = this.#mutations.get(scopeFor(mutation))?.find((m) => m.state.status === \"pending\");\n    return !firstPendingMutation || firstPendingMutation === mutation;\n  }\n  runNext(mutation) {\n    const foundMutation = this.#mutations.get(scopeFor(mutation))?.find((m) => m !== mutation && m.state.isPaused);\n    return foundMutation?.continue() ?? Promise.resolve();\n  }\n  clear() {\n    _notifyManager_js__WEBPACK_IMPORTED_MODULE_2__.notifyManager.batch(() => {\n      this.getAll().forEach((mutation) => {\n        this.remove(mutation);\n      });\n    });\n  }\n  getAll() {\n    return [...this.#mutations.values()].flat();\n  }\n  find(filters) {\n    const defaultedFilters = { exact: true, ...filters };\n    return this.getAll().find(\n      (mutation) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.matchMutation)(defaultedFilters, mutation)\n    );\n  }\n  findAll(filters = {}) {\n    return this.getAll().filter((mutation) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.matchMutation)(filters, mutation));\n  }\n  notify(event) {\n    _notifyManager_js__WEBPACK_IMPORTED_MODULE_2__.notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(event);\n      });\n    });\n  }\n  resumePausedMutations() {\n    const pausedMutations = this.getAll().filter((x) => x.state.isPaused);\n    return _notifyManager_js__WEBPACK_IMPORTED_MODULE_2__.notifyManager.batch(\n      () => Promise.all(\n        pausedMutations.map((mutation) => mutation.continue().catch(_utils_js__WEBPACK_IMPORTED_MODULE_3__.noop))\n      )\n    );\n  }\n};\nfunction scopeFor(mutation) {\n  return mutation.options.scope?.id ?? String(mutation.mutationId);\n}\n\n//# sourceMappingURL=mutationCache.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vbXV0YXRpb25DYWNoZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ21EO0FBQ1Y7QUFDUTtBQUNBO0FBQ2pELGtDQUFrQywwREFBWTtBQUM5Qyx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixrREFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHlCQUF5QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDJCQUEyQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNERBQWE7QUFDakI7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLG9CQUFvQix3REFBYTtBQUNqQztBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLDhDQUE4Qyx3REFBYTtBQUMzRDtBQUNBO0FBQ0EsSUFBSSw0REFBYTtBQUNqQjtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxXQUFXLDREQUFhO0FBQ3hCO0FBQ0Esb0VBQW9FLDJDQUFJO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0U7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvV29uZGVyVml0ZS1mcm9udGVuZC9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3F1ZXJ5LWNvcmUvYnVpbGQvbW9kZXJuL211dGF0aW9uQ2FjaGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL211dGF0aW9uQ2FjaGUudHNcbmltcG9ydCB7IG5vdGlmeU1hbmFnZXIgfSBmcm9tIFwiLi9ub3RpZnlNYW5hZ2VyLmpzXCI7XG5pbXBvcnQgeyBNdXRhdGlvbiB9IGZyb20gXCIuL211dGF0aW9uLmpzXCI7XG5pbXBvcnQgeyBtYXRjaE11dGF0aW9uLCBub29wIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbmltcG9ydCB7IFN1YnNjcmliYWJsZSB9IGZyb20gXCIuL3N1YnNjcmliYWJsZS5qc1wiO1xudmFyIE11dGF0aW9uQ2FjaGUgPSBjbGFzcyBleHRlbmRzIFN1YnNjcmliYWJsZSB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLiNtdXRhdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuI211dGF0aW9uSWQgPSBEYXRlLm5vdygpO1xuICB9XG4gICNtdXRhdGlvbnM7XG4gICNtdXRhdGlvbklkO1xuICBidWlsZChjbGllbnQsIG9wdGlvbnMsIHN0YXRlKSB7XG4gICAgY29uc3QgbXV0YXRpb24gPSBuZXcgTXV0YXRpb24oe1xuICAgICAgbXV0YXRpb25DYWNoZTogdGhpcyxcbiAgICAgIG11dGF0aW9uSWQ6ICsrdGhpcy4jbXV0YXRpb25JZCxcbiAgICAgIG9wdGlvbnM6IGNsaWVudC5kZWZhdWx0TXV0YXRpb25PcHRpb25zKG9wdGlvbnMpLFxuICAgICAgc3RhdGVcbiAgICB9KTtcbiAgICB0aGlzLmFkZChtdXRhdGlvbik7XG4gICAgcmV0dXJuIG11dGF0aW9uO1xuICB9XG4gIGFkZChtdXRhdGlvbikge1xuICAgIGNvbnN0IHNjb3BlID0gc2NvcGVGb3IobXV0YXRpb24pO1xuICAgIGNvbnN0IG11dGF0aW9ucyA9IHRoaXMuI211dGF0aW9ucy5nZXQoc2NvcGUpID8/IFtdO1xuICAgIG11dGF0aW9ucy5wdXNoKG11dGF0aW9uKTtcbiAgICB0aGlzLiNtdXRhdGlvbnMuc2V0KHNjb3BlLCBtdXRhdGlvbnMpO1xuICAgIHRoaXMubm90aWZ5KHsgdHlwZTogXCJhZGRlZFwiLCBtdXRhdGlvbiB9KTtcbiAgfVxuICByZW1vdmUobXV0YXRpb24pIHtcbiAgICBjb25zdCBzY29wZSA9IHNjb3BlRm9yKG11dGF0aW9uKTtcbiAgICBpZiAodGhpcy4jbXV0YXRpb25zLmhhcyhzY29wZSkpIHtcbiAgICAgIGNvbnN0IG11dGF0aW9ucyA9IHRoaXMuI211dGF0aW9ucy5nZXQoc2NvcGUpPy5maWx0ZXIoKHgpID0+IHggIT09IG11dGF0aW9uKTtcbiAgICAgIGlmIChtdXRhdGlvbnMpIHtcbiAgICAgICAgaWYgKG11dGF0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLiNtdXRhdGlvbnMuZGVsZXRlKHNjb3BlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLiNtdXRhdGlvbnMuc2V0KHNjb3BlLCBtdXRhdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubm90aWZ5KHsgdHlwZTogXCJyZW1vdmVkXCIsIG11dGF0aW9uIH0pO1xuICB9XG4gIGNhblJ1bihtdXRhdGlvbikge1xuICAgIGNvbnN0IGZpcnN0UGVuZGluZ011dGF0aW9uID0gdGhpcy4jbXV0YXRpb25zLmdldChzY29wZUZvcihtdXRhdGlvbikpPy5maW5kKChtKSA9PiBtLnN0YXRlLnN0YXR1cyA9PT0gXCJwZW5kaW5nXCIpO1xuICAgIHJldHVybiAhZmlyc3RQZW5kaW5nTXV0YXRpb24gfHwgZmlyc3RQZW5kaW5nTXV0YXRpb24gPT09IG11dGF0aW9uO1xuICB9XG4gIHJ1bk5leHQobXV0YXRpb24pIHtcbiAgICBjb25zdCBmb3VuZE11dGF0aW9uID0gdGhpcy4jbXV0YXRpb25zLmdldChzY29wZUZvcihtdXRhdGlvbikpPy5maW5kKChtKSA9PiBtICE9PSBtdXRhdGlvbiAmJiBtLnN0YXRlLmlzUGF1c2VkKTtcbiAgICByZXR1cm4gZm91bmRNdXRhdGlvbj8uY29udGludWUoKSA/PyBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuICBjbGVhcigpIHtcbiAgICBub3RpZnlNYW5hZ2VyLmJhdGNoKCgpID0+IHtcbiAgICAgIHRoaXMuZ2V0QWxsKCkuZm9yRWFjaCgobXV0YXRpb24pID0+IHtcbiAgICAgICAgdGhpcy5yZW1vdmUobXV0YXRpb24pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0QWxsKCkge1xuICAgIHJldHVybiBbLi4udGhpcy4jbXV0YXRpb25zLnZhbHVlcygpXS5mbGF0KCk7XG4gIH1cbiAgZmluZChmaWx0ZXJzKSB7XG4gICAgY29uc3QgZGVmYXVsdGVkRmlsdGVycyA9IHsgZXhhY3Q6IHRydWUsIC4uLmZpbHRlcnMgfTtcbiAgICByZXR1cm4gdGhpcy5nZXRBbGwoKS5maW5kKFxuICAgICAgKG11dGF0aW9uKSA9PiBtYXRjaE11dGF0aW9uKGRlZmF1bHRlZEZpbHRlcnMsIG11dGF0aW9uKVxuICAgICk7XG4gIH1cbiAgZmluZEFsbChmaWx0ZXJzID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBbGwoKS5maWx0ZXIoKG11dGF0aW9uKSA9PiBtYXRjaE11dGF0aW9uKGZpbHRlcnMsIG11dGF0aW9uKSk7XG4gIH1cbiAgbm90aWZ5KGV2ZW50KSB7XG4gICAgbm90aWZ5TWFuYWdlci5iYXRjaCgoKSA9PiB7XG4gICAgICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lcikgPT4ge1xuICAgICAgICBsaXN0ZW5lcihldmVudCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICByZXN1bWVQYXVzZWRNdXRhdGlvbnMoKSB7XG4gICAgY29uc3QgcGF1c2VkTXV0YXRpb25zID0gdGhpcy5nZXRBbGwoKS5maWx0ZXIoKHgpID0+IHguc3RhdGUuaXNQYXVzZWQpO1xuICAgIHJldHVybiBub3RpZnlNYW5hZ2VyLmJhdGNoKFxuICAgICAgKCkgPT4gUHJvbWlzZS5hbGwoXG4gICAgICAgIHBhdXNlZE11dGF0aW9ucy5tYXAoKG11dGF0aW9uKSA9PiBtdXRhdGlvbi5jb250aW51ZSgpLmNhdGNoKG5vb3ApKVxuICAgICAgKVxuICAgICk7XG4gIH1cbn07XG5mdW5jdGlvbiBzY29wZUZvcihtdXRhdGlvbikge1xuICByZXR1cm4gbXV0YXRpb24ub3B0aW9ucy5zY29wZT8uaWQgPz8gU3RyaW5nKG11dGF0aW9uLm11dGF0aW9uSWQpO1xufVxuZXhwb3J0IHtcbiAgTXV0YXRpb25DYWNoZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW11dGF0aW9uQ2FjaGUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/mutationCache.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/notifyManager.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/modern/notifyManager.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createNotifyManager: () => (/* binding */ createNotifyManager),\n/* harmony export */   notifyManager: () => (/* binding */ notifyManager)\n/* harmony export */ });\n// src/notifyManager.ts\nfunction createNotifyManager() {\n  let queue = [];\n  let transactions = 0;\n  let notifyFn = (callback) => {\n    callback();\n  };\n  let batchNotifyFn = (callback) => {\n    callback();\n  };\n  let scheduleFn = (cb) => setTimeout(cb, 0);\n  const schedule = (callback) => {\n    if (transactions) {\n      queue.push(callback);\n    } else {\n      scheduleFn(() => {\n        notifyFn(callback);\n      });\n    }\n  };\n  const flush = () => {\n    const originalQueue = queue;\n    queue = [];\n    if (originalQueue.length) {\n      scheduleFn(() => {\n        batchNotifyFn(() => {\n          originalQueue.forEach((callback) => {\n            notifyFn(callback);\n          });\n        });\n      });\n    }\n  };\n  return {\n    batch: (callback) => {\n      let result;\n      transactions++;\n      try {\n        result = callback();\n      } finally {\n        transactions--;\n        if (!transactions) {\n          flush();\n        }\n      }\n      return result;\n    },\n    /**\n     * All calls to the wrapped function will be batched.\n     */\n    batchCalls: (callback) => {\n      return (...args) => {\n        schedule(() => {\n          callback(...args);\n        });\n      };\n    },\n    schedule,\n    /**\n     * Use this method to set a custom notify function.\n     * This can be used to for example wrap notifications with `React.act` while running tests.\n     */\n    setNotifyFunction: (fn) => {\n      notifyFn = fn;\n    },\n    /**\n     * Use this method to set a custom function to batch notifications together into a single tick.\n     * By default React Query will use the batch function provided by ReactDOM or React Native.\n     */\n    setBatchNotifyFunction: (fn) => {\n      batchNotifyFn = fn;\n    },\n    setScheduler: (fn) => {\n      scheduleFn = fn;\n    }\n  };\n}\nvar notifyManager = createNotifyManager();\n\n//# sourceMappingURL=notifyManager.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vbm90aWZ5TWFuYWdlci5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvd29uZGVybGFuZG1pdGNoL0Nhc2NhZGVQcm9qZWN0cy9Xb25kZXJWaXRlLWZyb250ZW5kL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vbm90aWZ5TWFuYWdlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvbm90aWZ5TWFuYWdlci50c1xuZnVuY3Rpb24gY3JlYXRlTm90aWZ5TWFuYWdlcigpIHtcbiAgbGV0IHF1ZXVlID0gW107XG4gIGxldCB0cmFuc2FjdGlvbnMgPSAwO1xuICBsZXQgbm90aWZ5Rm4gPSAoY2FsbGJhY2spID0+IHtcbiAgICBjYWxsYmFjaygpO1xuICB9O1xuICBsZXQgYmF0Y2hOb3RpZnlGbiA9IChjYWxsYmFjaykgPT4ge1xuICAgIGNhbGxiYWNrKCk7XG4gIH07XG4gIGxldCBzY2hlZHVsZUZuID0gKGNiKSA9PiBzZXRUaW1lb3V0KGNiLCAwKTtcbiAgY29uc3Qgc2NoZWR1bGUgPSAoY2FsbGJhY2spID0+IHtcbiAgICBpZiAodHJhbnNhY3Rpb25zKSB7XG4gICAgICBxdWV1ZS5wdXNoKGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NoZWR1bGVGbigoKSA9PiB7XG4gICAgICAgIG5vdGlmeUZuKGNhbGxiYWNrKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgZmx1c2ggPSAoKSA9PiB7XG4gICAgY29uc3Qgb3JpZ2luYWxRdWV1ZSA9IHF1ZXVlO1xuICAgIHF1ZXVlID0gW107XG4gICAgaWYgKG9yaWdpbmFsUXVldWUubGVuZ3RoKSB7XG4gICAgICBzY2hlZHVsZUZuKCgpID0+IHtcbiAgICAgICAgYmF0Y2hOb3RpZnlGbigoKSA9PiB7XG4gICAgICAgICAgb3JpZ2luYWxRdWV1ZS5mb3JFYWNoKChjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgbm90aWZ5Rm4oY2FsbGJhY2spO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBiYXRjaDogKGNhbGxiYWNrKSA9PiB7XG4gICAgICBsZXQgcmVzdWx0O1xuICAgICAgdHJhbnNhY3Rpb25zKys7XG4gICAgICB0cnkge1xuICAgICAgICByZXN1bHQgPSBjYWxsYmFjaygpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJhbnNhY3Rpb25zLS07XG4gICAgICAgIGlmICghdHJhbnNhY3Rpb25zKSB7XG4gICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEFsbCBjYWxscyB0byB0aGUgd3JhcHBlZCBmdW5jdGlvbiB3aWxsIGJlIGJhdGNoZWQuXG4gICAgICovXG4gICAgYmF0Y2hDYWxsczogKGNhbGxiYWNrKSA9PiB7XG4gICAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgc2NoZWR1bGUoKCkgPT4ge1xuICAgICAgICAgIGNhbGxiYWNrKC4uLmFyZ3MpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfSxcbiAgICBzY2hlZHVsZSxcbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gc2V0IGEgY3VzdG9tIG5vdGlmeSBmdW5jdGlvbi5cbiAgICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGZvciBleGFtcGxlIHdyYXAgbm90aWZpY2F0aW9ucyB3aXRoIGBSZWFjdC5hY3RgIHdoaWxlIHJ1bm5pbmcgdGVzdHMuXG4gICAgICovXG4gICAgc2V0Tm90aWZ5RnVuY3Rpb246IChmbikgPT4ge1xuICAgICAgbm90aWZ5Rm4gPSBmbjtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBzZXQgYSBjdXN0b20gZnVuY3Rpb24gdG8gYmF0Y2ggbm90aWZpY2F0aW9ucyB0b2dldGhlciBpbnRvIGEgc2luZ2xlIHRpY2suXG4gICAgICogQnkgZGVmYXVsdCBSZWFjdCBRdWVyeSB3aWxsIHVzZSB0aGUgYmF0Y2ggZnVuY3Rpb24gcHJvdmlkZWQgYnkgUmVhY3RET00gb3IgUmVhY3QgTmF0aXZlLlxuICAgICAqL1xuICAgIHNldEJhdGNoTm90aWZ5RnVuY3Rpb246IChmbikgPT4ge1xuICAgICAgYmF0Y2hOb3RpZnlGbiA9IGZuO1xuICAgIH0sXG4gICAgc2V0U2NoZWR1bGVyOiAoZm4pID0+IHtcbiAgICAgIHNjaGVkdWxlRm4gPSBmbjtcbiAgICB9XG4gIH07XG59XG52YXIgbm90aWZ5TWFuYWdlciA9IGNyZWF0ZU5vdGlmeU1hbmFnZXIoKTtcbmV4cG9ydCB7XG4gIGNyZWF0ZU5vdGlmeU1hbmFnZXIsXG4gIG5vdGlmeU1hbmFnZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub3RpZnlNYW5hZ2VyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/notifyManager.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/onlineManager.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/modern/onlineManager.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OnlineManager: () => (/* binding */ OnlineManager),\n/* harmony export */   onlineManager: () => (/* binding */ onlineManager)\n/* harmony export */ });\n/* harmony import */ var _subscribable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./subscribable.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/subscribable.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/utils.js\");\n// src/onlineManager.ts\n\n\nvar OnlineManager = class extends _subscribable_js__WEBPACK_IMPORTED_MODULE_0__.Subscribable {\n  #online = true;\n  #cleanup;\n  #setup;\n  constructor() {\n    super();\n    this.#setup = (onOnline) => {\n      if (!_utils_js__WEBPACK_IMPORTED_MODULE_1__.isServer && window.addEventListener) {\n        const onlineListener = () => onOnline(true);\n        const offlineListener = () => onOnline(false);\n        window.addEventListener(\"online\", onlineListener, false);\n        window.addEventListener(\"offline\", offlineListener, false);\n        return () => {\n          window.removeEventListener(\"online\", onlineListener);\n          window.removeEventListener(\"offline\", offlineListener);\n        };\n      }\n      return;\n    };\n  }\n  onSubscribe() {\n    if (!this.#cleanup) {\n      this.setEventListener(this.#setup);\n    }\n  }\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.#cleanup?.();\n      this.#cleanup = void 0;\n    }\n  }\n  setEventListener(setup) {\n    this.#setup = setup;\n    this.#cleanup?.();\n    this.#cleanup = setup(this.setOnline.bind(this));\n  }\n  setOnline(online) {\n    const changed = this.#online !== online;\n    if (changed) {\n      this.#online = online;\n      this.listeners.forEach((listener) => {\n        listener(online);\n      });\n    }\n  }\n  isOnline() {\n    return this.#online;\n  }\n};\nvar onlineManager = new OnlineManager();\n\n//# sourceMappingURL=onlineManager.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vb25saW5lTWFuYWdlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDaUQ7QUFDWDtBQUN0QyxrQ0FBa0MsMERBQVk7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywrQ0FBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL1dvbmRlclZpdGUtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9xdWVyeS1jb3JlL2J1aWxkL21vZGVybi9vbmxpbmVNYW5hZ2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9vbmxpbmVNYW5hZ2VyLnRzXG5pbXBvcnQgeyBTdWJzY3JpYmFibGUgfSBmcm9tIFwiLi9zdWJzY3JpYmFibGUuanNcIjtcbmltcG9ydCB7IGlzU2VydmVyIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbnZhciBPbmxpbmVNYW5hZ2VyID0gY2xhc3MgZXh0ZW5kcyBTdWJzY3JpYmFibGUge1xuICAjb25saW5lID0gdHJ1ZTtcbiAgI2NsZWFudXA7XG4gICNzZXR1cDtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLiNzZXR1cCA9IChvbk9ubGluZSkgPT4ge1xuICAgICAgaWYgKCFpc1NlcnZlciAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBvbmxpbmVMaXN0ZW5lciA9ICgpID0+IG9uT25saW5lKHRydWUpO1xuICAgICAgICBjb25zdCBvZmZsaW5lTGlzdGVuZXIgPSAoKSA9PiBvbk9ubGluZShmYWxzZSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib25saW5lXCIsIG9ubGluZUxpc3RlbmVyLCBmYWxzZSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib2ZmbGluZVwiLCBvZmZsaW5lTGlzdGVuZXIsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm9ubGluZVwiLCBvbmxpbmVMaXN0ZW5lcik7XG4gICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJvZmZsaW5lXCIsIG9mZmxpbmVMaXN0ZW5lcik7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfTtcbiAgfVxuICBvblN1YnNjcmliZSgpIHtcbiAgICBpZiAoIXRoaXMuI2NsZWFudXApIHtcbiAgICAgIHRoaXMuc2V0RXZlbnRMaXN0ZW5lcih0aGlzLiNzZXR1cCk7XG4gICAgfVxuICB9XG4gIG9uVW5zdWJzY3JpYmUoKSB7XG4gICAgaWYgKCF0aGlzLmhhc0xpc3RlbmVycygpKSB7XG4gICAgICB0aGlzLiNjbGVhbnVwPy4oKTtcbiAgICAgIHRoaXMuI2NsZWFudXAgPSB2b2lkIDA7XG4gICAgfVxuICB9XG4gIHNldEV2ZW50TGlzdGVuZXIoc2V0dXApIHtcbiAgICB0aGlzLiNzZXR1cCA9IHNldHVwO1xuICAgIHRoaXMuI2NsZWFudXA/LigpO1xuICAgIHRoaXMuI2NsZWFudXAgPSBzZXR1cCh0aGlzLnNldE9ubGluZS5iaW5kKHRoaXMpKTtcbiAgfVxuICBzZXRPbmxpbmUob25saW5lKSB7XG4gICAgY29uc3QgY2hhbmdlZCA9IHRoaXMuI29ubGluZSAhPT0gb25saW5lO1xuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB0aGlzLiNvbmxpbmUgPSBvbmxpbmU7XG4gICAgICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lcikgPT4ge1xuICAgICAgICBsaXN0ZW5lcihvbmxpbmUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlzT25saW5lKCkge1xuICAgIHJldHVybiB0aGlzLiNvbmxpbmU7XG4gIH1cbn07XG52YXIgb25saW5lTWFuYWdlciA9IG5ldyBPbmxpbmVNYW5hZ2VyKCk7XG5leHBvcnQge1xuICBPbmxpbmVNYW5hZ2VyLFxuICBvbmxpbmVNYW5hZ2VyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b25saW5lTWFuYWdlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/onlineManager.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/query.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/modern/query.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Query: () => (/* binding */ Query),\n/* harmony export */   fetchState: () => (/* binding */ fetchState)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/utils.js\");\n/* harmony import */ var _notifyManager_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./notifyManager.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/notifyManager.js\");\n/* harmony import */ var _retryer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./retryer.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/retryer.js\");\n/* harmony import */ var _removable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./removable.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/removable.js\");\n// src/query.ts\n\n\n\n\nvar Query = class extends _removable_js__WEBPACK_IMPORTED_MODULE_0__.Removable {\n  #initialState;\n  #revertState;\n  #cache;\n  #retryer;\n  #defaultOptions;\n  #abortSignalConsumed;\n  constructor(config) {\n    super();\n    this.#abortSignalConsumed = false;\n    this.#defaultOptions = config.defaultOptions;\n    this.setOptions(config.options);\n    this.observers = [];\n    this.#cache = config.cache;\n    this.queryKey = config.queryKey;\n    this.queryHash = config.queryHash;\n    this.#initialState = getDefaultState(this.options);\n    this.state = config.state ?? this.#initialState;\n    this.scheduleGc();\n  }\n  get meta() {\n    return this.options.meta;\n  }\n  get promise() {\n    return this.#retryer?.promise;\n  }\n  setOptions(options) {\n    this.options = { ...this.#defaultOptions, ...options };\n    this.updateGcTime(this.options.gcTime);\n  }\n  optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === \"idle\") {\n      this.#cache.remove(this);\n    }\n  }\n  setData(newData, options) {\n    const data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.replaceData)(this.state.data, newData, this.options);\n    this.#dispatch({\n      data,\n      type: \"success\",\n      dataUpdatedAt: options?.updatedAt,\n      manual: options?.manual\n    });\n    return data;\n  }\n  setState(state, setStateOptions) {\n    this.#dispatch({ type: \"setState\", state, setStateOptions });\n  }\n  cancel(options) {\n    const promise = this.#retryer?.promise;\n    this.#retryer?.cancel(options);\n    return promise ? promise.then(_utils_js__WEBPACK_IMPORTED_MODULE_1__.noop).catch(_utils_js__WEBPACK_IMPORTED_MODULE_1__.noop) : Promise.resolve();\n  }\n  destroy() {\n    super.destroy();\n    this.cancel({ silent: true });\n  }\n  reset() {\n    this.destroy();\n    this.setState(this.#initialState);\n  }\n  isActive() {\n    return this.observers.some(\n      (observer) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.resolveEnabled)(observer.options.enabled, this) !== false\n    );\n  }\n  isDisabled() {\n    if (this.getObserversCount() > 0) {\n      return !this.isActive();\n    }\n    return this.options.queryFn === _utils_js__WEBPACK_IMPORTED_MODULE_1__.skipToken || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;\n  }\n  isStale() {\n    if (this.state.isInvalidated) {\n      return true;\n    }\n    if (this.getObserversCount() > 0) {\n      return this.observers.some(\n        (observer) => observer.getCurrentResult().isStale\n      );\n    }\n    return this.state.data === void 0;\n  }\n  isStaleByTime(staleTime = 0) {\n    return this.state.isInvalidated || this.state.data === void 0 || !(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.timeUntilStale)(this.state.dataUpdatedAt, staleTime);\n  }\n  onFocus() {\n    const observer = this.observers.find((x) => x.shouldFetchOnWindowFocus());\n    observer?.refetch({ cancelRefetch: false });\n    this.#retryer?.continue();\n  }\n  onOnline() {\n    const observer = this.observers.find((x) => x.shouldFetchOnReconnect());\n    observer?.refetch({ cancelRefetch: false });\n    this.#retryer?.continue();\n  }\n  addObserver(observer) {\n    if (!this.observers.includes(observer)) {\n      this.observers.push(observer);\n      this.clearGcTimeout();\n      this.#cache.notify({ type: \"observerAdded\", query: this, observer });\n    }\n  }\n  removeObserver(observer) {\n    if (this.observers.includes(observer)) {\n      this.observers = this.observers.filter((x) => x !== observer);\n      if (!this.observers.length) {\n        if (this.#retryer) {\n          if (this.#abortSignalConsumed) {\n            this.#retryer.cancel({ revert: true });\n          } else {\n            this.#retryer.cancelRetry();\n          }\n        }\n        this.scheduleGc();\n      }\n      this.#cache.notify({ type: \"observerRemoved\", query: this, observer });\n    }\n  }\n  getObserversCount() {\n    return this.observers.length;\n  }\n  invalidate() {\n    if (!this.state.isInvalidated) {\n      this.#dispatch({ type: \"invalidate\" });\n    }\n  }\n  fetch(options, fetchOptions) {\n    if (this.state.fetchStatus !== \"idle\") {\n      if (this.state.data !== void 0 && fetchOptions?.cancelRefetch) {\n        this.cancel({ silent: true });\n      } else if (this.#retryer) {\n        this.#retryer.continueRetry();\n        return this.#retryer.promise;\n      }\n    }\n    if (options) {\n      this.setOptions(options);\n    }\n    if (!this.options.queryFn) {\n      const observer = this.observers.find((x) => x.options.queryFn);\n      if (observer) {\n        this.setOptions(observer.options);\n      }\n    }\n    if (true) {\n      if (!Array.isArray(this.options.queryKey)) {\n        console.error(\n          `As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`\n        );\n      }\n    }\n    const abortController = new AbortController();\n    const addSignalProperty = (object) => {\n      Object.defineProperty(object, \"signal\", {\n        enumerable: true,\n        get: () => {\n          this.#abortSignalConsumed = true;\n          return abortController.signal;\n        }\n      });\n    };\n    const fetchFn = () => {\n      const queryFn = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureQueryFn)(this.options, fetchOptions);\n      const queryFnContext = {\n        queryKey: this.queryKey,\n        meta: this.meta\n      };\n      addSignalProperty(queryFnContext);\n      this.#abortSignalConsumed = false;\n      if (this.options.persister) {\n        return this.options.persister(\n          queryFn,\n          queryFnContext,\n          this\n        );\n      }\n      return queryFn(queryFnContext);\n    };\n    const context = {\n      fetchOptions,\n      options: this.options,\n      queryKey: this.queryKey,\n      state: this.state,\n      fetchFn\n    };\n    addSignalProperty(context);\n    this.options.behavior?.onFetch(\n      context,\n      this\n    );\n    this.#revertState = this.state;\n    if (this.state.fetchStatus === \"idle\" || this.state.fetchMeta !== context.fetchOptions?.meta) {\n      this.#dispatch({ type: \"fetch\", meta: context.fetchOptions?.meta });\n    }\n    const onError = (error) => {\n      if (!((0,_retryer_js__WEBPACK_IMPORTED_MODULE_2__.isCancelledError)(error) && error.silent)) {\n        this.#dispatch({\n          type: \"error\",\n          error\n        });\n      }\n      if (!(0,_retryer_js__WEBPACK_IMPORTED_MODULE_2__.isCancelledError)(error)) {\n        this.#cache.config.onError?.(\n          error,\n          this\n        );\n        this.#cache.config.onSettled?.(\n          this.state.data,\n          error,\n          this\n        );\n      }\n      this.scheduleGc();\n    };\n    this.#retryer = (0,_retryer_js__WEBPACK_IMPORTED_MODULE_2__.createRetryer)({\n      initialPromise: fetchOptions?.initialPromise,\n      fn: context.fetchFn,\n      abort: abortController.abort.bind(abortController),\n      onSuccess: (data) => {\n        if (data === void 0) {\n          if (true) {\n            console.error(\n              `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`\n            );\n          }\n          onError(new Error(`${this.queryHash} data is undefined`));\n          return;\n        }\n        try {\n          this.setData(data);\n        } catch (error) {\n          onError(error);\n          return;\n        }\n        this.#cache.config.onSuccess?.(data, this);\n        this.#cache.config.onSettled?.(\n          data,\n          this.state.error,\n          this\n        );\n        this.scheduleGc();\n      },\n      onError,\n      onFail: (failureCount, error) => {\n        this.#dispatch({ type: \"failed\", failureCount, error });\n      },\n      onPause: () => {\n        this.#dispatch({ type: \"pause\" });\n      },\n      onContinue: () => {\n        this.#dispatch({ type: \"continue\" });\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode,\n      canRun: () => true\n    });\n    return this.#retryer.start();\n  }\n  #dispatch(action) {\n    const reducer = (state) => {\n      switch (action.type) {\n        case \"failed\":\n          return {\n            ...state,\n            fetchFailureCount: action.failureCount,\n            fetchFailureReason: action.error\n          };\n        case \"pause\":\n          return {\n            ...state,\n            fetchStatus: \"paused\"\n          };\n        case \"continue\":\n          return {\n            ...state,\n            fetchStatus: \"fetching\"\n          };\n        case \"fetch\":\n          return {\n            ...state,\n            ...fetchState(state.data, this.options),\n            fetchMeta: action.meta ?? null\n          };\n        case \"success\":\n          return {\n            ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: \"success\",\n            ...!action.manual && {\n              fetchStatus: \"idle\",\n              fetchFailureCount: 0,\n              fetchFailureReason: null\n            }\n          };\n        case \"error\":\n          const error = action.error;\n          if ((0,_retryer_js__WEBPACK_IMPORTED_MODULE_2__.isCancelledError)(error) && error.revert && this.#revertState) {\n            return { ...this.#revertState, fetchStatus: \"idle\" };\n          }\n          return {\n            ...state,\n            error,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchFailureReason: error,\n            fetchStatus: \"idle\",\n            status: \"error\"\n          };\n        case \"invalidate\":\n          return {\n            ...state,\n            isInvalidated: true\n          };\n        case \"setState\":\n          return {\n            ...state,\n            ...action.state\n          };\n      }\n    };\n    this.state = reducer(this.state);\n    _notifyManager_js__WEBPACK_IMPORTED_MODULE_3__.notifyManager.batch(() => {\n      this.observers.forEach((observer) => {\n        observer.onQueryUpdate();\n      });\n      this.#cache.notify({ query: this, type: \"updated\", action });\n    });\n  }\n};\nfunction fetchState(data, options) {\n  return {\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchStatus: (0,_retryer_js__WEBPACK_IMPORTED_MODULE_2__.canFetch)(options.networkMode) ? \"fetching\" : \"paused\",\n    ...data === void 0 && {\n      error: null,\n      status: \"pending\"\n    }\n  };\n}\nfunction getDefaultState(options) {\n  const data = typeof options.initialData === \"function\" ? options.initialData() : options.initialData;\n  const hasData = data !== void 0;\n  const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === \"function\" ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? \"success\" : \"pending\",\n    fetchStatus: \"idle\"\n  };\n}\n\n//# sourceMappingURL=query.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vcXVlcnkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFRb0I7QUFDK0I7QUFDc0I7QUFDOUI7QUFDM0MsMEJBQTBCLG9EQUFTO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixzREFBVztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwwQ0FBMEM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsMkNBQUksUUFBUSwyQ0FBSTtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5REFBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsZ0RBQVM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UseURBQWM7QUFDcEY7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDhDQUE4QztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGNBQWM7QUFDakQsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0RBQWdEO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9CQUFvQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEMsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxJQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxzQkFBc0Isd0RBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpREFBaUQ7QUFDeEU7QUFDQTtBQUNBLFlBQVksNkRBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFdBQVcsNkRBQWdCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwREFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxJQUFxQztBQUNuRDtBQUNBLHVKQUF1SixlQUFlO0FBQ3RLO0FBQ0E7QUFDQSwrQkFBK0IsZ0JBQWdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSx5QkFBeUIscUNBQXFDO0FBQzlELE9BQU87QUFDUDtBQUNBLHlCQUF5QixlQUFlO0FBQ3hDLE9BQU87QUFDUDtBQUNBLHlCQUF5QixrQkFBa0I7QUFDM0MsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDZEQUFnQjtBQUM5QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw0REFBYTtBQUNqQjtBQUNBO0FBQ0EsT0FBTztBQUNQLDJCQUEyQixzQ0FBc0M7QUFDakUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixxREFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL1dvbmRlclZpdGUtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9xdWVyeS1jb3JlL2J1aWxkL21vZGVybi9xdWVyeS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvcXVlcnkudHNcbmltcG9ydCB7XG4gIGVuc3VyZVF1ZXJ5Rm4sXG4gIG5vb3AsXG4gIHJlcGxhY2VEYXRhLFxuICByZXNvbHZlRW5hYmxlZCxcbiAgc2tpcFRva2VuLFxuICB0aW1lVW50aWxTdGFsZVxufSBmcm9tIFwiLi91dGlscy5qc1wiO1xuaW1wb3J0IHsgbm90aWZ5TWFuYWdlciB9IGZyb20gXCIuL25vdGlmeU1hbmFnZXIuanNcIjtcbmltcG9ydCB7IGNhbkZldGNoLCBjcmVhdGVSZXRyeWVyLCBpc0NhbmNlbGxlZEVycm9yIH0gZnJvbSBcIi4vcmV0cnllci5qc1wiO1xuaW1wb3J0IHsgUmVtb3ZhYmxlIH0gZnJvbSBcIi4vcmVtb3ZhYmxlLmpzXCI7XG52YXIgUXVlcnkgPSBjbGFzcyBleHRlbmRzIFJlbW92YWJsZSB7XG4gICNpbml0aWFsU3RhdGU7XG4gICNyZXZlcnRTdGF0ZTtcbiAgI2NhY2hlO1xuICAjcmV0cnllcjtcbiAgI2RlZmF1bHRPcHRpb25zO1xuICAjYWJvcnRTaWduYWxDb25zdW1lZDtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLiNhYm9ydFNpZ25hbENvbnN1bWVkID0gZmFsc2U7XG4gICAgdGhpcy4jZGVmYXVsdE9wdGlvbnMgPSBjb25maWcuZGVmYXVsdE9wdGlvbnM7XG4gICAgdGhpcy5zZXRPcHRpb25zKGNvbmZpZy5vcHRpb25zKTtcbiAgICB0aGlzLm9ic2VydmVycyA9IFtdO1xuICAgIHRoaXMuI2NhY2hlID0gY29uZmlnLmNhY2hlO1xuICAgIHRoaXMucXVlcnlLZXkgPSBjb25maWcucXVlcnlLZXk7XG4gICAgdGhpcy5xdWVyeUhhc2ggPSBjb25maWcucXVlcnlIYXNoO1xuICAgIHRoaXMuI2luaXRpYWxTdGF0ZSA9IGdldERlZmF1bHRTdGF0ZSh0aGlzLm9wdGlvbnMpO1xuICAgIHRoaXMuc3RhdGUgPSBjb25maWcuc3RhdGUgPz8gdGhpcy4jaW5pdGlhbFN0YXRlO1xuICAgIHRoaXMuc2NoZWR1bGVHYygpO1xuICB9XG4gIGdldCBtZXRhKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMubWV0YTtcbiAgfVxuICBnZXQgcHJvbWlzZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jcmV0cnllcj8ucHJvbWlzZTtcbiAgfVxuICBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSB7IC4uLnRoaXMuI2RlZmF1bHRPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgdGhpcy51cGRhdGVHY1RpbWUodGhpcy5vcHRpb25zLmdjVGltZSk7XG4gIH1cbiAgb3B0aW9uYWxSZW1vdmUoKSB7XG4gICAgaWYgKCF0aGlzLm9ic2VydmVycy5sZW5ndGggJiYgdGhpcy5zdGF0ZS5mZXRjaFN0YXR1cyA9PT0gXCJpZGxlXCIpIHtcbiAgICAgIHRoaXMuI2NhY2hlLnJlbW92ZSh0aGlzKTtcbiAgICB9XG4gIH1cbiAgc2V0RGF0YShuZXdEYXRhLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZGF0YSA9IHJlcGxhY2VEYXRhKHRoaXMuc3RhdGUuZGF0YSwgbmV3RGF0YSwgdGhpcy5vcHRpb25zKTtcbiAgICB0aGlzLiNkaXNwYXRjaCh7XG4gICAgICBkYXRhLFxuICAgICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgICBkYXRhVXBkYXRlZEF0OiBvcHRpb25zPy51cGRhdGVkQXQsXG4gICAgICBtYW51YWw6IG9wdGlvbnM/Lm1hbnVhbFxuICAgIH0pO1xuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIHNldFN0YXRlKHN0YXRlLCBzZXRTdGF0ZU9wdGlvbnMpIHtcbiAgICB0aGlzLiNkaXNwYXRjaCh7IHR5cGU6IFwic2V0U3RhdGVcIiwgc3RhdGUsIHNldFN0YXRlT3B0aW9ucyB9KTtcbiAgfVxuICBjYW5jZWwob3B0aW9ucykge1xuICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLiNyZXRyeWVyPy5wcm9taXNlO1xuICAgIHRoaXMuI3JldHJ5ZXI/LmNhbmNlbChvcHRpb25zKTtcbiAgICByZXR1cm4gcHJvbWlzZSA/IHByb21pc2UudGhlbihub29wKS5jYXRjaChub29wKSA6IFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuY2FuY2VsKHsgc2lsZW50OiB0cnVlIH0pO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIHRoaXMuc2V0U3RhdGUodGhpcy4jaW5pdGlhbFN0YXRlKTtcbiAgfVxuICBpc0FjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5vYnNlcnZlcnMuc29tZShcbiAgICAgIChvYnNlcnZlcikgPT4gcmVzb2x2ZUVuYWJsZWQob2JzZXJ2ZXIub3B0aW9ucy5lbmFibGVkLCB0aGlzKSAhPT0gZmFsc2VcbiAgICApO1xuICB9XG4gIGlzRGlzYWJsZWQoKSB7XG4gICAgaWYgKHRoaXMuZ2V0T2JzZXJ2ZXJzQ291bnQoKSA+IDApIHtcbiAgICAgIHJldHVybiAhdGhpcy5pc0FjdGl2ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnF1ZXJ5Rm4gPT09IHNraXBUb2tlbiB8fCB0aGlzLnN0YXRlLmRhdGFVcGRhdGVDb3VudCArIHRoaXMuc3RhdGUuZXJyb3JVcGRhdGVDb3VudCA9PT0gMDtcbiAgfVxuICBpc1N0YWxlKCkge1xuICAgIGlmICh0aGlzLnN0YXRlLmlzSW52YWxpZGF0ZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5nZXRPYnNlcnZlcnNDb3VudCgpID4gMCkge1xuICAgICAgcmV0dXJuIHRoaXMub2JzZXJ2ZXJzLnNvbWUoXG4gICAgICAgIChvYnNlcnZlcikgPT4gb2JzZXJ2ZXIuZ2V0Q3VycmVudFJlc3VsdCgpLmlzU3RhbGVcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnN0YXRlLmRhdGEgPT09IHZvaWQgMDtcbiAgfVxuICBpc1N0YWxlQnlUaW1lKHN0YWxlVGltZSA9IDApIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5pc0ludmFsaWRhdGVkIHx8IHRoaXMuc3RhdGUuZGF0YSA9PT0gdm9pZCAwIHx8ICF0aW1lVW50aWxTdGFsZSh0aGlzLnN0YXRlLmRhdGFVcGRhdGVkQXQsIHN0YWxlVGltZSk7XG4gIH1cbiAgb25Gb2N1cygpIHtcbiAgICBjb25zdCBvYnNlcnZlciA9IHRoaXMub2JzZXJ2ZXJzLmZpbmQoKHgpID0+IHguc2hvdWxkRmV0Y2hPbldpbmRvd0ZvY3VzKCkpO1xuICAgIG9ic2VydmVyPy5yZWZldGNoKHsgY2FuY2VsUmVmZXRjaDogZmFsc2UgfSk7XG4gICAgdGhpcy4jcmV0cnllcj8uY29udGludWUoKTtcbiAgfVxuICBvbk9ubGluZSgpIHtcbiAgICBjb25zdCBvYnNlcnZlciA9IHRoaXMub2JzZXJ2ZXJzLmZpbmQoKHgpID0+IHguc2hvdWxkRmV0Y2hPblJlY29ubmVjdCgpKTtcbiAgICBvYnNlcnZlcj8ucmVmZXRjaCh7IGNhbmNlbFJlZmV0Y2g6IGZhbHNlIH0pO1xuICAgIHRoaXMuI3JldHJ5ZXI/LmNvbnRpbnVlKCk7XG4gIH1cbiAgYWRkT2JzZXJ2ZXIob2JzZXJ2ZXIpIHtcbiAgICBpZiAoIXRoaXMub2JzZXJ2ZXJzLmluY2x1ZGVzKG9ic2VydmVyKSkge1xuICAgICAgdGhpcy5vYnNlcnZlcnMucHVzaChvYnNlcnZlcik7XG4gICAgICB0aGlzLmNsZWFyR2NUaW1lb3V0KCk7XG4gICAgICB0aGlzLiNjYWNoZS5ub3RpZnkoeyB0eXBlOiBcIm9ic2VydmVyQWRkZWRcIiwgcXVlcnk6IHRoaXMsIG9ic2VydmVyIH0pO1xuICAgIH1cbiAgfVxuICByZW1vdmVPYnNlcnZlcihvYnNlcnZlcikge1xuICAgIGlmICh0aGlzLm9ic2VydmVycy5pbmNsdWRlcyhvYnNlcnZlcikpIHtcbiAgICAgIHRoaXMub2JzZXJ2ZXJzID0gdGhpcy5vYnNlcnZlcnMuZmlsdGVyKCh4KSA9PiB4ICE9PSBvYnNlcnZlcik7XG4gICAgICBpZiAoIXRoaXMub2JzZXJ2ZXJzLmxlbmd0aCkge1xuICAgICAgICBpZiAodGhpcy4jcmV0cnllcikge1xuICAgICAgICAgIGlmICh0aGlzLiNhYm9ydFNpZ25hbENvbnN1bWVkKSB7XG4gICAgICAgICAgICB0aGlzLiNyZXRyeWVyLmNhbmNlbCh7IHJldmVydDogdHJ1ZSB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4jcmV0cnllci5jYW5jZWxSZXRyeSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjaGVkdWxlR2MoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuI2NhY2hlLm5vdGlmeSh7IHR5cGU6IFwib2JzZXJ2ZXJSZW1vdmVkXCIsIHF1ZXJ5OiB0aGlzLCBvYnNlcnZlciB9KTtcbiAgICB9XG4gIH1cbiAgZ2V0T2JzZXJ2ZXJzQ291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMub2JzZXJ2ZXJzLmxlbmd0aDtcbiAgfVxuICBpbnZhbGlkYXRlKCkge1xuICAgIGlmICghdGhpcy5zdGF0ZS5pc0ludmFsaWRhdGVkKSB7XG4gICAgICB0aGlzLiNkaXNwYXRjaCh7IHR5cGU6IFwiaW52YWxpZGF0ZVwiIH0pO1xuICAgIH1cbiAgfVxuICBmZXRjaChvcHRpb25zLCBmZXRjaE9wdGlvbnMpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5mZXRjaFN0YXR1cyAhPT0gXCJpZGxlXCIpIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlLmRhdGEgIT09IHZvaWQgMCAmJiBmZXRjaE9wdGlvbnM/LmNhbmNlbFJlZmV0Y2gpIHtcbiAgICAgICAgdGhpcy5jYW5jZWwoeyBzaWxlbnQ6IHRydWUgfSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuI3JldHJ5ZXIpIHtcbiAgICAgICAgdGhpcy4jcmV0cnllci5jb250aW51ZVJldHJ5KCk7XG4gICAgICAgIHJldHVybiB0aGlzLiNyZXRyeWVyLnByb21pc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgfVxuICAgIGlmICghdGhpcy5vcHRpb25zLnF1ZXJ5Rm4pIHtcbiAgICAgIGNvbnN0IG9ic2VydmVyID0gdGhpcy5vYnNlcnZlcnMuZmluZCgoeCkgPT4geC5vcHRpb25zLnF1ZXJ5Rm4pO1xuICAgICAgaWYgKG9ic2VydmVyKSB7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9ucyhvYnNlcnZlci5vcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRoaXMub3B0aW9ucy5xdWVyeUtleSkpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBgQXMgb2YgdjQsIHF1ZXJ5S2V5IG5lZWRzIHRvIGJlIGFuIEFycmF5LiBJZiB5b3UgYXJlIHVzaW5nIGEgc3RyaW5nIGxpa2UgJ3JlcG9EYXRhJywgcGxlYXNlIGNoYW5nZSBpdCB0byBhbiBBcnJheSwgZS5nLiBbJ3JlcG9EYXRhJ11gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBhZGRTaWduYWxQcm9wZXJ0eSA9IChvYmplY3QpID0+IHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIFwic2lnbmFsXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiAoKSA9PiB7XG4gICAgICAgICAgdGhpcy4jYWJvcnRTaWduYWxDb25zdW1lZCA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIGFib3J0Q29udHJvbGxlci5zaWduYWw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgZmV0Y2hGbiA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHF1ZXJ5Rm4gPSBlbnN1cmVRdWVyeUZuKHRoaXMub3B0aW9ucywgZmV0Y2hPcHRpb25zKTtcbiAgICAgIGNvbnN0IHF1ZXJ5Rm5Db250ZXh0ID0ge1xuICAgICAgICBxdWVyeUtleTogdGhpcy5xdWVyeUtleSxcbiAgICAgICAgbWV0YTogdGhpcy5tZXRhXG4gICAgICB9O1xuICAgICAgYWRkU2lnbmFsUHJvcGVydHkocXVlcnlGbkNvbnRleHQpO1xuICAgICAgdGhpcy4jYWJvcnRTaWduYWxDb25zdW1lZCA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZXJzaXN0ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5wZXJzaXN0ZXIoXG4gICAgICAgICAgcXVlcnlGbixcbiAgICAgICAgICBxdWVyeUZuQ29udGV4dCxcbiAgICAgICAgICB0aGlzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcXVlcnlGbihxdWVyeUZuQ29udGV4dCk7XG4gICAgfTtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgZmV0Y2hPcHRpb25zLFxuICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zLFxuICAgICAgcXVlcnlLZXk6IHRoaXMucXVlcnlLZXksXG4gICAgICBzdGF0ZTogdGhpcy5zdGF0ZSxcbiAgICAgIGZldGNoRm5cbiAgICB9O1xuICAgIGFkZFNpZ25hbFByb3BlcnR5KGNvbnRleHQpO1xuICAgIHRoaXMub3B0aW9ucy5iZWhhdmlvcj8ub25GZXRjaChcbiAgICAgIGNvbnRleHQsXG4gICAgICB0aGlzXG4gICAgKTtcbiAgICB0aGlzLiNyZXZlcnRTdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHRoaXMuc3RhdGUuZmV0Y2hTdGF0dXMgPT09IFwiaWRsZVwiIHx8IHRoaXMuc3RhdGUuZmV0Y2hNZXRhICE9PSBjb250ZXh0LmZldGNoT3B0aW9ucz8ubWV0YSkge1xuICAgICAgdGhpcy4jZGlzcGF0Y2goeyB0eXBlOiBcImZldGNoXCIsIG1ldGE6IGNvbnRleHQuZmV0Y2hPcHRpb25zPy5tZXRhIH0pO1xuICAgIH1cbiAgICBjb25zdCBvbkVycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICBpZiAoIShpc0NhbmNlbGxlZEVycm9yKGVycm9yKSAmJiBlcnJvci5zaWxlbnQpKSB7XG4gICAgICAgIHRoaXMuI2Rpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgZXJyb3JcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoIWlzQ2FuY2VsbGVkRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHRoaXMuI2NhY2hlLmNvbmZpZy5vbkVycm9yPy4oXG4gICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgdGhpc1xuICAgICAgICApO1xuICAgICAgICB0aGlzLiNjYWNoZS5jb25maWcub25TZXR0bGVkPy4oXG4gICAgICAgICAgdGhpcy5zdGF0ZS5kYXRhLFxuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIHRoaXNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2NoZWR1bGVHYygpO1xuICAgIH07XG4gICAgdGhpcy4jcmV0cnllciA9IGNyZWF0ZVJldHJ5ZXIoe1xuICAgICAgaW5pdGlhbFByb21pc2U6IGZldGNoT3B0aW9ucz8uaW5pdGlhbFByb21pc2UsXG4gICAgICBmbjogY29udGV4dC5mZXRjaEZuLFxuICAgICAgYWJvcnQ6IGFib3J0Q29udHJvbGxlci5hYm9ydC5iaW5kKGFib3J0Q29udHJvbGxlciksXG4gICAgICBvblN1Y2Nlc3M6IChkYXRhKSA9PiB7XG4gICAgICAgIGlmIChkYXRhID09PSB2b2lkIDApIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBgUXVlcnkgZGF0YSBjYW5ub3QgYmUgdW5kZWZpbmVkLiBQbGVhc2UgbWFrZSBzdXJlIHRvIHJldHVybiBhIHZhbHVlIG90aGVyIHRoYW4gdW5kZWZpbmVkIGZyb20geW91ciBxdWVyeSBmdW5jdGlvbi4gQWZmZWN0ZWQgcXVlcnkga2V5OiAke3RoaXMucXVlcnlIYXNofWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9uRXJyb3IobmV3IEVycm9yKGAke3RoaXMucXVlcnlIYXNofSBkYXRhIGlzIHVuZGVmaW5lZGApKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLnNldERhdGEoZGF0YSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgb25FcnJvcihlcnJvcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2NhY2hlLmNvbmZpZy5vblN1Y2Nlc3M/LihkYXRhLCB0aGlzKTtcbiAgICAgICAgdGhpcy4jY2FjaGUuY29uZmlnLm9uU2V0dGxlZD8uKFxuICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgdGhpcy5zdGF0ZS5lcnJvcixcbiAgICAgICAgICB0aGlzXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVHYygpO1xuICAgICAgfSxcbiAgICAgIG9uRXJyb3IsXG4gICAgICBvbkZhaWw6IChmYWlsdXJlQ291bnQsIGVycm9yKSA9PiB7XG4gICAgICAgIHRoaXMuI2Rpc3BhdGNoKHsgdHlwZTogXCJmYWlsZWRcIiwgZmFpbHVyZUNvdW50LCBlcnJvciB9KTtcbiAgICAgIH0sXG4gICAgICBvblBhdXNlOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuI2Rpc3BhdGNoKHsgdHlwZTogXCJwYXVzZVwiIH0pO1xuICAgICAgfSxcbiAgICAgIG9uQ29udGludWU6ICgpID0+IHtcbiAgICAgICAgdGhpcy4jZGlzcGF0Y2goeyB0eXBlOiBcImNvbnRpbnVlXCIgfSk7XG4gICAgICB9LFxuICAgICAgcmV0cnk6IGNvbnRleHQub3B0aW9ucy5yZXRyeSxcbiAgICAgIHJldHJ5RGVsYXk6IGNvbnRleHQub3B0aW9ucy5yZXRyeURlbGF5LFxuICAgICAgbmV0d29ya01vZGU6IGNvbnRleHQub3B0aW9ucy5uZXR3b3JrTW9kZSxcbiAgICAgIGNhblJ1bjogKCkgPT4gdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLiNyZXRyeWVyLnN0YXJ0KCk7XG4gIH1cbiAgI2Rpc3BhdGNoKGFjdGlvbikge1xuICAgIGNvbnN0IHJlZHVjZXIgPSAoc3RhdGUpID0+IHtcbiAgICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcImZhaWxlZFwiOlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgIGZldGNoRmFpbHVyZUNvdW50OiBhY3Rpb24uZmFpbHVyZUNvdW50LFxuICAgICAgICAgICAgZmV0Y2hGYWlsdXJlUmVhc29uOiBhY3Rpb24uZXJyb3JcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFwicGF1c2VcIjpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICBmZXRjaFN0YXR1czogXCJwYXVzZWRcIlxuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgXCJjb250aW51ZVwiOlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgIGZldGNoU3RhdHVzOiBcImZldGNoaW5nXCJcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFwiZmV0Y2hcIjpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAuLi5mZXRjaFN0YXRlKHN0YXRlLmRhdGEsIHRoaXMub3B0aW9ucyksXG4gICAgICAgICAgICBmZXRjaE1ldGE6IGFjdGlvbi5tZXRhID8/IG51bGxcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFwic3VjY2Vzc1wiOlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgIGRhdGE6IGFjdGlvbi5kYXRhLFxuICAgICAgICAgICAgZGF0YVVwZGF0ZUNvdW50OiBzdGF0ZS5kYXRhVXBkYXRlQ291bnQgKyAxLFxuICAgICAgICAgICAgZGF0YVVwZGF0ZWRBdDogYWN0aW9uLmRhdGFVcGRhdGVkQXQgPz8gRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgaXNJbnZhbGlkYXRlZDogZmFsc2UsXG4gICAgICAgICAgICBzdGF0dXM6IFwic3VjY2Vzc1wiLFxuICAgICAgICAgICAgLi4uIWFjdGlvbi5tYW51YWwgJiYge1xuICAgICAgICAgICAgICBmZXRjaFN0YXR1czogXCJpZGxlXCIsXG4gICAgICAgICAgICAgIGZldGNoRmFpbHVyZUNvdW50OiAwLFxuICAgICAgICAgICAgICBmZXRjaEZhaWx1cmVSZWFzb246IG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICBjb25zdCBlcnJvciA9IGFjdGlvbi5lcnJvcjtcbiAgICAgICAgICBpZiAoaXNDYW5jZWxsZWRFcnJvcihlcnJvcikgJiYgZXJyb3IucmV2ZXJ0ICYmIHRoaXMuI3JldmVydFN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm4geyAuLi50aGlzLiNyZXZlcnRTdGF0ZSwgZmV0Y2hTdGF0dXM6IFwiaWRsZVwiIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgZXJyb3JVcGRhdGVDb3VudDogc3RhdGUuZXJyb3JVcGRhdGVDb3VudCArIDEsXG4gICAgICAgICAgICBlcnJvclVwZGF0ZWRBdDogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIGZldGNoRmFpbHVyZUNvdW50OiBzdGF0ZS5mZXRjaEZhaWx1cmVDb3VudCArIDEsXG4gICAgICAgICAgICBmZXRjaEZhaWx1cmVSZWFzb246IGVycm9yLFxuICAgICAgICAgICAgZmV0Y2hTdGF0dXM6IFwiaWRsZVwiLFxuICAgICAgICAgICAgc3RhdHVzOiBcImVycm9yXCJcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFwiaW52YWxpZGF0ZVwiOlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgIGlzSW52YWxpZGF0ZWQ6IHRydWVcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFwic2V0U3RhdGVcIjpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAuLi5hY3Rpb24uc3RhdGVcbiAgICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5zdGF0ZSA9IHJlZHVjZXIodGhpcy5zdGF0ZSk7XG4gICAgbm90aWZ5TWFuYWdlci5iYXRjaCgoKSA9PiB7XG4gICAgICB0aGlzLm9ic2VydmVycy5mb3JFYWNoKChvYnNlcnZlcikgPT4ge1xuICAgICAgICBvYnNlcnZlci5vblF1ZXJ5VXBkYXRlKCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuI2NhY2hlLm5vdGlmeSh7IHF1ZXJ5OiB0aGlzLCB0eXBlOiBcInVwZGF0ZWRcIiwgYWN0aW9uIH0pO1xuICAgIH0pO1xuICB9XG59O1xuZnVuY3Rpb24gZmV0Y2hTdGF0ZShkYXRhLCBvcHRpb25zKSB7XG4gIHJldHVybiB7XG4gICAgZmV0Y2hGYWlsdXJlQ291bnQ6IDAsXG4gICAgZmV0Y2hGYWlsdXJlUmVhc29uOiBudWxsLFxuICAgIGZldGNoU3RhdHVzOiBjYW5GZXRjaChvcHRpb25zLm5ldHdvcmtNb2RlKSA/IFwiZmV0Y2hpbmdcIiA6IFwicGF1c2VkXCIsXG4gICAgLi4uZGF0YSA9PT0gdm9pZCAwICYmIHtcbiAgICAgIGVycm9yOiBudWxsLFxuICAgICAgc3RhdHVzOiBcInBlbmRpbmdcIlxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGdldERlZmF1bHRTdGF0ZShvcHRpb25zKSB7XG4gIGNvbnN0IGRhdGEgPSB0eXBlb2Ygb3B0aW9ucy5pbml0aWFsRGF0YSA9PT0gXCJmdW5jdGlvblwiID8gb3B0aW9ucy5pbml0aWFsRGF0YSgpIDogb3B0aW9ucy5pbml0aWFsRGF0YTtcbiAgY29uc3QgaGFzRGF0YSA9IGRhdGEgIT09IHZvaWQgMDtcbiAgY29uc3QgaW5pdGlhbERhdGFVcGRhdGVkQXQgPSBoYXNEYXRhID8gdHlwZW9mIG9wdGlvbnMuaW5pdGlhbERhdGFVcGRhdGVkQXQgPT09IFwiZnVuY3Rpb25cIiA/IG9wdGlvbnMuaW5pdGlhbERhdGFVcGRhdGVkQXQoKSA6IG9wdGlvbnMuaW5pdGlhbERhdGFVcGRhdGVkQXQgOiAwO1xuICByZXR1cm4ge1xuICAgIGRhdGEsXG4gICAgZGF0YVVwZGF0ZUNvdW50OiAwLFxuICAgIGRhdGFVcGRhdGVkQXQ6IGhhc0RhdGEgPyBpbml0aWFsRGF0YVVwZGF0ZWRBdCA/PyBEYXRlLm5vdygpIDogMCxcbiAgICBlcnJvcjogbnVsbCxcbiAgICBlcnJvclVwZGF0ZUNvdW50OiAwLFxuICAgIGVycm9yVXBkYXRlZEF0OiAwLFxuICAgIGZldGNoRmFpbHVyZUNvdW50OiAwLFxuICAgIGZldGNoRmFpbHVyZVJlYXNvbjogbnVsbCxcbiAgICBmZXRjaE1ldGE6IG51bGwsXG4gICAgaXNJbnZhbGlkYXRlZDogZmFsc2UsXG4gICAgc3RhdHVzOiBoYXNEYXRhID8gXCJzdWNjZXNzXCIgOiBcInBlbmRpbmdcIixcbiAgICBmZXRjaFN0YXR1czogXCJpZGxlXCJcbiAgfTtcbn1cbmV4cG9ydCB7XG4gIFF1ZXJ5LFxuICBmZXRjaFN0YXRlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cXVlcnkuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/query.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/queryCache.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/modern/queryCache.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QueryCache: () => (/* binding */ QueryCache)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/utils.js\");\n/* harmony import */ var _query_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./query.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/query.js\");\n/* harmony import */ var _notifyManager_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./notifyManager.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/notifyManager.js\");\n/* harmony import */ var _subscribable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./subscribable.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/subscribable.js\");\n// src/queryCache.ts\n\n\n\n\nvar QueryCache = class extends _subscribable_js__WEBPACK_IMPORTED_MODULE_0__.Subscribable {\n  constructor(config = {}) {\n    super();\n    this.config = config;\n    this.#queries = /* @__PURE__ */ new Map();\n  }\n  #queries;\n  build(client, options, state) {\n    const queryKey = options.queryKey;\n    const queryHash = options.queryHash ?? (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashQueryKeyByOptions)(queryKey, options);\n    let query = this.get(queryHash);\n    if (!query) {\n      query = new _query_js__WEBPACK_IMPORTED_MODULE_2__.Query({\n        cache: this,\n        queryKey,\n        queryHash,\n        options: client.defaultQueryOptions(options),\n        state,\n        defaultOptions: client.getQueryDefaults(queryKey)\n      });\n      this.add(query);\n    }\n    return query;\n  }\n  add(query) {\n    if (!this.#queries.has(query.queryHash)) {\n      this.#queries.set(query.queryHash, query);\n      this.notify({\n        type: \"added\",\n        query\n      });\n    }\n  }\n  remove(query) {\n    const queryInMap = this.#queries.get(query.queryHash);\n    if (queryInMap) {\n      query.destroy();\n      if (queryInMap === query) {\n        this.#queries.delete(query.queryHash);\n      }\n      this.notify({ type: \"removed\", query });\n    }\n  }\n  clear() {\n    _notifyManager_js__WEBPACK_IMPORTED_MODULE_3__.notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        this.remove(query);\n      });\n    });\n  }\n  get(queryHash) {\n    return this.#queries.get(queryHash);\n  }\n  getAll() {\n    return [...this.#queries.values()];\n  }\n  find(filters) {\n    const defaultedFilters = { exact: true, ...filters };\n    return this.getAll().find(\n      (query) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.matchQuery)(defaultedFilters, query)\n    );\n  }\n  findAll(filters = {}) {\n    const queries = this.getAll();\n    return Object.keys(filters).length > 0 ? queries.filter((query) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.matchQuery)(filters, query)) : queries;\n  }\n  notify(event) {\n    _notifyManager_js__WEBPACK_IMPORTED_MODULE_3__.notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(event);\n      });\n    });\n  }\n  onFocus() {\n    _notifyManager_js__WEBPACK_IMPORTED_MODULE_3__.notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        query.onFocus();\n      });\n    });\n  }\n  onOnline() {\n    _notifyManager_js__WEBPACK_IMPORTED_MODULE_3__.notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        query.onOnline();\n      });\n    });\n  }\n};\n\n//# sourceMappingURL=queryCache.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vcXVlcnlDYWNoZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQytEO0FBQzVCO0FBQ2dCO0FBQ0Y7QUFDakQsK0JBQStCLDBEQUFZO0FBQzNDLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxnRUFBcUI7QUFDaEU7QUFDQTtBQUNBLGtCQUFrQiw0Q0FBSztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0E7QUFDQSxJQUFJLDREQUFhO0FBQ2pCO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSxpQkFBaUIscURBQVU7QUFDM0I7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHVFQUF1RSxxREFBVTtBQUNqRjtBQUNBO0FBQ0EsSUFBSSw0REFBYTtBQUNqQjtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSSw0REFBYTtBQUNqQjtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSSw0REFBYTtBQUNqQjtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBR0U7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvV29uZGVyVml0ZS1mcm9udGVuZC9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3F1ZXJ5LWNvcmUvYnVpbGQvbW9kZXJuL3F1ZXJ5Q2FjaGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3F1ZXJ5Q2FjaGUudHNcbmltcG9ydCB7IGhhc2hRdWVyeUtleUJ5T3B0aW9ucywgbWF0Y2hRdWVyeSB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBRdWVyeSB9IGZyb20gXCIuL3F1ZXJ5LmpzXCI7XG5pbXBvcnQgeyBub3RpZnlNYW5hZ2VyIH0gZnJvbSBcIi4vbm90aWZ5TWFuYWdlci5qc1wiO1xuaW1wb3J0IHsgU3Vic2NyaWJhYmxlIH0gZnJvbSBcIi4vc3Vic2NyaWJhYmxlLmpzXCI7XG52YXIgUXVlcnlDYWNoZSA9IGNsYXNzIGV4dGVuZHMgU3Vic2NyaWJhYmxlIHtcbiAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMuI3F1ZXJpZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gICNxdWVyaWVzO1xuICBidWlsZChjbGllbnQsIG9wdGlvbnMsIHN0YXRlKSB7XG4gICAgY29uc3QgcXVlcnlLZXkgPSBvcHRpb25zLnF1ZXJ5S2V5O1xuICAgIGNvbnN0IHF1ZXJ5SGFzaCA9IG9wdGlvbnMucXVlcnlIYXNoID8/IGhhc2hRdWVyeUtleUJ5T3B0aW9ucyhxdWVyeUtleSwgb3B0aW9ucyk7XG4gICAgbGV0IHF1ZXJ5ID0gdGhpcy5nZXQocXVlcnlIYXNoKTtcbiAgICBpZiAoIXF1ZXJ5KSB7XG4gICAgICBxdWVyeSA9IG5ldyBRdWVyeSh7XG4gICAgICAgIGNhY2hlOiB0aGlzLFxuICAgICAgICBxdWVyeUtleSxcbiAgICAgICAgcXVlcnlIYXNoLFxuICAgICAgICBvcHRpb25zOiBjbGllbnQuZGVmYXVsdFF1ZXJ5T3B0aW9ucyhvcHRpb25zKSxcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIGRlZmF1bHRPcHRpb25zOiBjbGllbnQuZ2V0UXVlcnlEZWZhdWx0cyhxdWVyeUtleSlcbiAgICAgIH0pO1xuICAgICAgdGhpcy5hZGQocXVlcnkpO1xuICAgIH1cbiAgICByZXR1cm4gcXVlcnk7XG4gIH1cbiAgYWRkKHF1ZXJ5KSB7XG4gICAgaWYgKCF0aGlzLiNxdWVyaWVzLmhhcyhxdWVyeS5xdWVyeUhhc2gpKSB7XG4gICAgICB0aGlzLiNxdWVyaWVzLnNldChxdWVyeS5xdWVyeUhhc2gsIHF1ZXJ5KTtcbiAgICAgIHRoaXMubm90aWZ5KHtcbiAgICAgICAgdHlwZTogXCJhZGRlZFwiLFxuICAgICAgICBxdWVyeVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJlbW92ZShxdWVyeSkge1xuICAgIGNvbnN0IHF1ZXJ5SW5NYXAgPSB0aGlzLiNxdWVyaWVzLmdldChxdWVyeS5xdWVyeUhhc2gpO1xuICAgIGlmIChxdWVyeUluTWFwKSB7XG4gICAgICBxdWVyeS5kZXN0cm95KCk7XG4gICAgICBpZiAocXVlcnlJbk1hcCA9PT0gcXVlcnkpIHtcbiAgICAgICAgdGhpcy4jcXVlcmllcy5kZWxldGUocXVlcnkucXVlcnlIYXNoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubm90aWZ5KHsgdHlwZTogXCJyZW1vdmVkXCIsIHF1ZXJ5IH0pO1xuICAgIH1cbiAgfVxuICBjbGVhcigpIHtcbiAgICBub3RpZnlNYW5hZ2VyLmJhdGNoKCgpID0+IHtcbiAgICAgIHRoaXMuZ2V0QWxsKCkuZm9yRWFjaCgocXVlcnkpID0+IHtcbiAgICAgICAgdGhpcy5yZW1vdmUocXVlcnkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0KHF1ZXJ5SGFzaCkge1xuICAgIHJldHVybiB0aGlzLiNxdWVyaWVzLmdldChxdWVyeUhhc2gpO1xuICB9XG4gIGdldEFsbCgpIHtcbiAgICByZXR1cm4gWy4uLnRoaXMuI3F1ZXJpZXMudmFsdWVzKCldO1xuICB9XG4gIGZpbmQoZmlsdGVycykge1xuICAgIGNvbnN0IGRlZmF1bHRlZEZpbHRlcnMgPSB7IGV4YWN0OiB0cnVlLCAuLi5maWx0ZXJzIH07XG4gICAgcmV0dXJuIHRoaXMuZ2V0QWxsKCkuZmluZChcbiAgICAgIChxdWVyeSkgPT4gbWF0Y2hRdWVyeShkZWZhdWx0ZWRGaWx0ZXJzLCBxdWVyeSlcbiAgICApO1xuICB9XG4gIGZpbmRBbGwoZmlsdGVycyA9IHt9KSB7XG4gICAgY29uc3QgcXVlcmllcyA9IHRoaXMuZ2V0QWxsKCk7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGZpbHRlcnMpLmxlbmd0aCA+IDAgPyBxdWVyaWVzLmZpbHRlcigocXVlcnkpID0+IG1hdGNoUXVlcnkoZmlsdGVycywgcXVlcnkpKSA6IHF1ZXJpZXM7XG4gIH1cbiAgbm90aWZ5KGV2ZW50KSB7XG4gICAgbm90aWZ5TWFuYWdlci5iYXRjaCgoKSA9PiB7XG4gICAgICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lcikgPT4ge1xuICAgICAgICBsaXN0ZW5lcihldmVudCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBvbkZvY3VzKCkge1xuICAgIG5vdGlmeU1hbmFnZXIuYmF0Y2goKCkgPT4ge1xuICAgICAgdGhpcy5nZXRBbGwoKS5mb3JFYWNoKChxdWVyeSkgPT4ge1xuICAgICAgICBxdWVyeS5vbkZvY3VzKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBvbk9ubGluZSgpIHtcbiAgICBub3RpZnlNYW5hZ2VyLmJhdGNoKCgpID0+IHtcbiAgICAgIHRoaXMuZ2V0QWxsKCkuZm9yRWFjaCgocXVlcnkpID0+IHtcbiAgICAgICAgcXVlcnkub25PbmxpbmUoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59O1xuZXhwb3J0IHtcbiAgUXVlcnlDYWNoZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXJ5Q2FjaGUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/queryCache.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/queryClient.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/modern/queryClient.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QueryClient: () => (/* binding */ QueryClient)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/utils.js\");\n/* harmony import */ var _queryCache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./queryCache.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/queryCache.js\");\n/* harmony import */ var _mutationCache_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mutationCache.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/mutationCache.js\");\n/* harmony import */ var _focusManager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./focusManager.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/focusManager.js\");\n/* harmony import */ var _onlineManager_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./onlineManager.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/onlineManager.js\");\n/* harmony import */ var _notifyManager_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./notifyManager.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/notifyManager.js\");\n/* harmony import */ var _infiniteQueryBehavior_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./infiniteQueryBehavior.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/infiniteQueryBehavior.js\");\n// src/queryClient.ts\n\n\n\n\n\n\n\nvar QueryClient = class {\n  #queryCache;\n  #mutationCache;\n  #defaultOptions;\n  #queryDefaults;\n  #mutationDefaults;\n  #mountCount;\n  #unsubscribeFocus;\n  #unsubscribeOnline;\n  constructor(config = {}) {\n    this.#queryCache = config.queryCache || new _queryCache_js__WEBPACK_IMPORTED_MODULE_0__.QueryCache();\n    this.#mutationCache = config.mutationCache || new _mutationCache_js__WEBPACK_IMPORTED_MODULE_1__.MutationCache();\n    this.#defaultOptions = config.defaultOptions || {};\n    this.#queryDefaults = /* @__PURE__ */ new Map();\n    this.#mutationDefaults = /* @__PURE__ */ new Map();\n    this.#mountCount = 0;\n  }\n  mount() {\n    this.#mountCount++;\n    if (this.#mountCount !== 1)\n      return;\n    this.#unsubscribeFocus = _focusManager_js__WEBPACK_IMPORTED_MODULE_2__.focusManager.subscribe(async (focused) => {\n      if (focused) {\n        await this.resumePausedMutations();\n        this.#queryCache.onFocus();\n      }\n    });\n    this.#unsubscribeOnline = _onlineManager_js__WEBPACK_IMPORTED_MODULE_3__.onlineManager.subscribe(async (online) => {\n      if (online) {\n        await this.resumePausedMutations();\n        this.#queryCache.onOnline();\n      }\n    });\n  }\n  unmount() {\n    this.#mountCount--;\n    if (this.#mountCount !== 0)\n      return;\n    this.#unsubscribeFocus?.();\n    this.#unsubscribeFocus = void 0;\n    this.#unsubscribeOnline?.();\n    this.#unsubscribeOnline = void 0;\n  }\n  isFetching(filters) {\n    return this.#queryCache.findAll({ ...filters, fetchStatus: \"fetching\" }).length;\n  }\n  isMutating(filters) {\n    return this.#mutationCache.findAll({ ...filters, status: \"pending\" }).length;\n  }\n  getQueryData(queryKey) {\n    const options = this.defaultQueryOptions({ queryKey });\n    return this.#queryCache.get(options.queryHash)?.state.data;\n  }\n  ensureQueryData(options) {\n    const cachedData = this.getQueryData(options.queryKey);\n    if (cachedData === void 0)\n      return this.fetchQuery(options);\n    else {\n      const defaultedOptions = this.defaultQueryOptions(options);\n      const query = this.#queryCache.build(this, defaultedOptions);\n      if (options.revalidateIfStale && query.isStaleByTime((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.resolveStaleTime)(defaultedOptions.staleTime, query))) {\n        void this.prefetchQuery(defaultedOptions);\n      }\n      return Promise.resolve(cachedData);\n    }\n  }\n  getQueriesData(filters) {\n    return this.#queryCache.findAll(filters).map(({ queryKey, state }) => {\n      const data = state.data;\n      return [queryKey, data];\n    });\n  }\n  setQueryData(queryKey, updater, options) {\n    const defaultedOptions = this.defaultQueryOptions({ queryKey });\n    const query = this.#queryCache.get(\n      defaultedOptions.queryHash\n    );\n    const prevData = query?.state.data;\n    const data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.functionalUpdate)(updater, prevData);\n    if (data === void 0) {\n      return void 0;\n    }\n    return this.#queryCache.build(this, defaultedOptions).setData(data, { ...options, manual: true });\n  }\n  setQueriesData(filters, updater, options) {\n    return _notifyManager_js__WEBPACK_IMPORTED_MODULE_5__.notifyManager.batch(\n      () => this.#queryCache.findAll(filters).map(({ queryKey }) => [\n        queryKey,\n        this.setQueryData(queryKey, updater, options)\n      ])\n    );\n  }\n  getQueryState(queryKey) {\n    const options = this.defaultQueryOptions({ queryKey });\n    return this.#queryCache.get(options.queryHash)?.state;\n  }\n  removeQueries(filters) {\n    const queryCache = this.#queryCache;\n    _notifyManager_js__WEBPACK_IMPORTED_MODULE_5__.notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        queryCache.remove(query);\n      });\n    });\n  }\n  resetQueries(filters, options) {\n    const queryCache = this.#queryCache;\n    const refetchFilters = {\n      type: \"active\",\n      ...filters\n    };\n    return _notifyManager_js__WEBPACK_IMPORTED_MODULE_5__.notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        query.reset();\n      });\n      return this.refetchQueries(refetchFilters, options);\n    });\n  }\n  cancelQueries(filters = {}, cancelOptions = {}) {\n    const defaultedCancelOptions = { revert: true, ...cancelOptions };\n    const promises = _notifyManager_js__WEBPACK_IMPORTED_MODULE_5__.notifyManager.batch(\n      () => this.#queryCache.findAll(filters).map((query) => query.cancel(defaultedCancelOptions))\n    );\n    return Promise.all(promises).then(_utils_js__WEBPACK_IMPORTED_MODULE_4__.noop).catch(_utils_js__WEBPACK_IMPORTED_MODULE_4__.noop);\n  }\n  invalidateQueries(filters = {}, options = {}) {\n    return _notifyManager_js__WEBPACK_IMPORTED_MODULE_5__.notifyManager.batch(() => {\n      this.#queryCache.findAll(filters).forEach((query) => {\n        query.invalidate();\n      });\n      if (filters.refetchType === \"none\") {\n        return Promise.resolve();\n      }\n      const refetchFilters = {\n        ...filters,\n        type: filters.refetchType ?? filters.type ?? \"active\"\n      };\n      return this.refetchQueries(refetchFilters, options);\n    });\n  }\n  refetchQueries(filters = {}, options) {\n    const fetchOptions = {\n      ...options,\n      cancelRefetch: options?.cancelRefetch ?? true\n    };\n    const promises = _notifyManager_js__WEBPACK_IMPORTED_MODULE_5__.notifyManager.batch(\n      () => this.#queryCache.findAll(filters).filter((query) => !query.isDisabled()).map((query) => {\n        let promise = query.fetch(void 0, fetchOptions);\n        if (!fetchOptions.throwOnError) {\n          promise = promise.catch(_utils_js__WEBPACK_IMPORTED_MODULE_4__.noop);\n        }\n        return query.state.fetchStatus === \"paused\" ? Promise.resolve() : promise;\n      })\n    );\n    return Promise.all(promises).then(_utils_js__WEBPACK_IMPORTED_MODULE_4__.noop);\n  }\n  fetchQuery(options) {\n    const defaultedOptions = this.defaultQueryOptions(options);\n    if (defaultedOptions.retry === void 0) {\n      defaultedOptions.retry = false;\n    }\n    const query = this.#queryCache.build(this, defaultedOptions);\n    return query.isStaleByTime(\n      (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.resolveStaleTime)(defaultedOptions.staleTime, query)\n    ) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);\n  }\n  prefetchQuery(options) {\n    return this.fetchQuery(options).then(_utils_js__WEBPACK_IMPORTED_MODULE_4__.noop).catch(_utils_js__WEBPACK_IMPORTED_MODULE_4__.noop);\n  }\n  fetchInfiniteQuery(options) {\n    options.behavior = (0,_infiniteQueryBehavior_js__WEBPACK_IMPORTED_MODULE_6__.infiniteQueryBehavior)(options.pages);\n    return this.fetchQuery(options);\n  }\n  prefetchInfiniteQuery(options) {\n    return this.fetchInfiniteQuery(options).then(_utils_js__WEBPACK_IMPORTED_MODULE_4__.noop).catch(_utils_js__WEBPACK_IMPORTED_MODULE_4__.noop);\n  }\n  ensureInfiniteQueryData(options) {\n    options.behavior = (0,_infiniteQueryBehavior_js__WEBPACK_IMPORTED_MODULE_6__.infiniteQueryBehavior)(options.pages);\n    return this.ensureQueryData(options);\n  }\n  resumePausedMutations() {\n    if (_onlineManager_js__WEBPACK_IMPORTED_MODULE_3__.onlineManager.isOnline()) {\n      return this.#mutationCache.resumePausedMutations();\n    }\n    return Promise.resolve();\n  }\n  getQueryCache() {\n    return this.#queryCache;\n  }\n  getMutationCache() {\n    return this.#mutationCache;\n  }\n  getDefaultOptions() {\n    return this.#defaultOptions;\n  }\n  setDefaultOptions(options) {\n    this.#defaultOptions = options;\n  }\n  setQueryDefaults(queryKey, options) {\n    this.#queryDefaults.set((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.hashKey)(queryKey), {\n      queryKey,\n      defaultOptions: options\n    });\n  }\n  getQueryDefaults(queryKey) {\n    const defaults = [...this.#queryDefaults.values()];\n    let result = {};\n    defaults.forEach((queryDefault) => {\n      if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.partialMatchKey)(queryKey, queryDefault.queryKey)) {\n        result = { ...result, ...queryDefault.defaultOptions };\n      }\n    });\n    return result;\n  }\n  setMutationDefaults(mutationKey, options) {\n    this.#mutationDefaults.set((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.hashKey)(mutationKey), {\n      mutationKey,\n      defaultOptions: options\n    });\n  }\n  getMutationDefaults(mutationKey) {\n    const defaults = [...this.#mutationDefaults.values()];\n    let result = {};\n    defaults.forEach((queryDefault) => {\n      if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.partialMatchKey)(mutationKey, queryDefault.mutationKey)) {\n        result = { ...result, ...queryDefault.defaultOptions };\n      }\n    });\n    return result;\n  }\n  defaultQueryOptions(options) {\n    if (options._defaulted) {\n      return options;\n    }\n    const defaultedOptions = {\n      ...this.#defaultOptions.queries,\n      ...this.getQueryDefaults(options.queryKey),\n      ...options,\n      _defaulted: true\n    };\n    if (!defaultedOptions.queryHash) {\n      defaultedOptions.queryHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.hashQueryKeyByOptions)(\n        defaultedOptions.queryKey,\n        defaultedOptions\n      );\n    }\n    if (defaultedOptions.refetchOnReconnect === void 0) {\n      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== \"always\";\n    }\n    if (defaultedOptions.throwOnError === void 0) {\n      defaultedOptions.throwOnError = !!defaultedOptions.suspense;\n    }\n    if (!defaultedOptions.networkMode && defaultedOptions.persister) {\n      defaultedOptions.networkMode = \"offlineFirst\";\n    }\n    if (defaultedOptions.enabled !== true && defaultedOptions.queryFn === _utils_js__WEBPACK_IMPORTED_MODULE_4__.skipToken) {\n      defaultedOptions.enabled = false;\n    }\n    return defaultedOptions;\n  }\n  defaultMutationOptions(options) {\n    if (options?._defaulted) {\n      return options;\n    }\n    return {\n      ...this.#defaultOptions.mutations,\n      ...options?.mutationKey && this.getMutationDefaults(options.mutationKey),\n      ...options,\n      _defaulted: true\n    };\n  }\n  clear() {\n    this.#queryCache.clear();\n    this.#mutationCache.clear();\n  }\n};\n\n//# sourceMappingURL=queryClient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vcXVlcnlDbGllbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQVNvQjtBQUN5QjtBQUNNO0FBQ0Y7QUFDRTtBQUNBO0FBQ2dCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixnREFBZ0Qsc0RBQVU7QUFDMUQsc0RBQXNELDREQUFhO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwwREFBWTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw4QkFBOEIsNERBQWE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxxQ0FBcUM7QUFDM0U7QUFDQTtBQUNBLHlDQUF5QywrQkFBK0I7QUFDeEU7QUFDQTtBQUNBLCtDQUErQyxVQUFVO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCwyREFBZ0I7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGlCQUFpQjtBQUNyRTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx3REFBd0QsVUFBVTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwyREFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLDBCQUEwQjtBQUNwRztBQUNBO0FBQ0EsV0FBVyw0REFBYTtBQUN4QixxREFBcUQsVUFBVTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsVUFBVTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNERBQWE7QUFDakI7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDREQUFhO0FBQ3hCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQSw0QkFBNEIsb0JBQW9CO0FBQ2hELHFDQUFxQztBQUNyQyxxQkFBcUIsNERBQWE7QUFDbEM7QUFDQTtBQUNBLHNDQUFzQywyQ0FBSSxRQUFRLDJDQUFJO0FBQ3REO0FBQ0EsZ0NBQWdDLGNBQWM7QUFDOUMsV0FBVyw0REFBYTtBQUN4QjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNERBQWE7QUFDbEM7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDJDQUFJO0FBQ3RDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxzQ0FBc0MsMkNBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sMkRBQWdCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QywyQ0FBSSxRQUFRLDJDQUFJO0FBQ3pEO0FBQ0E7QUFDQSx1QkFBdUIsZ0ZBQXFCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCwyQ0FBSSxRQUFRLDJDQUFJO0FBQ2pFO0FBQ0E7QUFDQSx1QkFBdUIsZ0ZBQXFCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNERBQWE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrREFBTztBQUNuQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDBEQUFlO0FBQ3pCLG1CQUFtQjtBQUNuQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isa0RBQU87QUFDdEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwwREFBZTtBQUN6QixtQkFBbUI7QUFDbkI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0VBQXFCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLGdEQUFTO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvd29uZGVybGFuZG1pdGNoL0Nhc2NhZGVQcm9qZWN0cy9Xb25kZXJWaXRlLWZyb250ZW5kL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vcXVlcnlDbGllbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3F1ZXJ5Q2xpZW50LnRzXG5pbXBvcnQge1xuICBmdW5jdGlvbmFsVXBkYXRlLFxuICBoYXNoS2V5LFxuICBoYXNoUXVlcnlLZXlCeU9wdGlvbnMsXG4gIG5vb3AsXG4gIHBhcnRpYWxNYXRjaEtleSxcbiAgcmVzb2x2ZVN0YWxlVGltZSxcbiAgc2tpcFRva2VuXG59IGZyb20gXCIuL3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBRdWVyeUNhY2hlIH0gZnJvbSBcIi4vcXVlcnlDYWNoZS5qc1wiO1xuaW1wb3J0IHsgTXV0YXRpb25DYWNoZSB9IGZyb20gXCIuL211dGF0aW9uQ2FjaGUuanNcIjtcbmltcG9ydCB7IGZvY3VzTWFuYWdlciB9IGZyb20gXCIuL2ZvY3VzTWFuYWdlci5qc1wiO1xuaW1wb3J0IHsgb25saW5lTWFuYWdlciB9IGZyb20gXCIuL29ubGluZU1hbmFnZXIuanNcIjtcbmltcG9ydCB7IG5vdGlmeU1hbmFnZXIgfSBmcm9tIFwiLi9ub3RpZnlNYW5hZ2VyLmpzXCI7XG5pbXBvcnQgeyBpbmZpbml0ZVF1ZXJ5QmVoYXZpb3IgfSBmcm9tIFwiLi9pbmZpbml0ZVF1ZXJ5QmVoYXZpb3IuanNcIjtcbnZhciBRdWVyeUNsaWVudCA9IGNsYXNzIHtcbiAgI3F1ZXJ5Q2FjaGU7XG4gICNtdXRhdGlvbkNhY2hlO1xuICAjZGVmYXVsdE9wdGlvbnM7XG4gICNxdWVyeURlZmF1bHRzO1xuICAjbXV0YXRpb25EZWZhdWx0cztcbiAgI21vdW50Q291bnQ7XG4gICN1bnN1YnNjcmliZUZvY3VzO1xuICAjdW5zdWJzY3JpYmVPbmxpbmU7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgdGhpcy4jcXVlcnlDYWNoZSA9IGNvbmZpZy5xdWVyeUNhY2hlIHx8IG5ldyBRdWVyeUNhY2hlKCk7XG4gICAgdGhpcy4jbXV0YXRpb25DYWNoZSA9IGNvbmZpZy5tdXRhdGlvbkNhY2hlIHx8IG5ldyBNdXRhdGlvbkNhY2hlKCk7XG4gICAgdGhpcy4jZGVmYXVsdE9wdGlvbnMgPSBjb25maWcuZGVmYXVsdE9wdGlvbnMgfHwge307XG4gICAgdGhpcy4jcXVlcnlEZWZhdWx0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy4jbXV0YXRpb25EZWZhdWx0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy4jbW91bnRDb3VudCA9IDA7XG4gIH1cbiAgbW91bnQoKSB7XG4gICAgdGhpcy4jbW91bnRDb3VudCsrO1xuICAgIGlmICh0aGlzLiNtb3VudENvdW50ICE9PSAxKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuI3Vuc3Vic2NyaWJlRm9jdXMgPSBmb2N1c01hbmFnZXIuc3Vic2NyaWJlKGFzeW5jIChmb2N1c2VkKSA9PiB7XG4gICAgICBpZiAoZm9jdXNlZCkge1xuICAgICAgICBhd2FpdCB0aGlzLnJlc3VtZVBhdXNlZE11dGF0aW9ucygpO1xuICAgICAgICB0aGlzLiNxdWVyeUNhY2hlLm9uRm9jdXMoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLiN1bnN1YnNjcmliZU9ubGluZSA9IG9ubGluZU1hbmFnZXIuc3Vic2NyaWJlKGFzeW5jIChvbmxpbmUpID0+IHtcbiAgICAgIGlmIChvbmxpbmUpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5yZXN1bWVQYXVzZWRNdXRhdGlvbnMoKTtcbiAgICAgICAgdGhpcy4jcXVlcnlDYWNoZS5vbk9ubGluZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHVubW91bnQoKSB7XG4gICAgdGhpcy4jbW91bnRDb3VudC0tO1xuICAgIGlmICh0aGlzLiNtb3VudENvdW50ICE9PSAwKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuI3Vuc3Vic2NyaWJlRm9jdXM/LigpO1xuICAgIHRoaXMuI3Vuc3Vic2NyaWJlRm9jdXMgPSB2b2lkIDA7XG4gICAgdGhpcy4jdW5zdWJzY3JpYmVPbmxpbmU/LigpO1xuICAgIHRoaXMuI3Vuc3Vic2NyaWJlT25saW5lID0gdm9pZCAwO1xuICB9XG4gIGlzRmV0Y2hpbmcoZmlsdGVycykge1xuICAgIHJldHVybiB0aGlzLiNxdWVyeUNhY2hlLmZpbmRBbGwoeyAuLi5maWx0ZXJzLCBmZXRjaFN0YXR1czogXCJmZXRjaGluZ1wiIH0pLmxlbmd0aDtcbiAgfVxuICBpc011dGF0aW5nKGZpbHRlcnMpIHtcbiAgICByZXR1cm4gdGhpcy4jbXV0YXRpb25DYWNoZS5maW5kQWxsKHsgLi4uZmlsdGVycywgc3RhdHVzOiBcInBlbmRpbmdcIiB9KS5sZW5ndGg7XG4gIH1cbiAgZ2V0UXVlcnlEYXRhKHF1ZXJ5S2V5KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuZGVmYXVsdFF1ZXJ5T3B0aW9ucyh7IHF1ZXJ5S2V5IH0pO1xuICAgIHJldHVybiB0aGlzLiNxdWVyeUNhY2hlLmdldChvcHRpb25zLnF1ZXJ5SGFzaCk/LnN0YXRlLmRhdGE7XG4gIH1cbiAgZW5zdXJlUXVlcnlEYXRhKG9wdGlvbnMpIHtcbiAgICBjb25zdCBjYWNoZWREYXRhID0gdGhpcy5nZXRRdWVyeURhdGEob3B0aW9ucy5xdWVyeUtleSk7XG4gICAgaWYgKGNhY2hlZERhdGEgPT09IHZvaWQgMClcbiAgICAgIHJldHVybiB0aGlzLmZldGNoUXVlcnkob3B0aW9ucyk7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBkZWZhdWx0ZWRPcHRpb25zID0gdGhpcy5kZWZhdWx0UXVlcnlPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgY29uc3QgcXVlcnkgPSB0aGlzLiNxdWVyeUNhY2hlLmJ1aWxkKHRoaXMsIGRlZmF1bHRlZE9wdGlvbnMpO1xuICAgICAgaWYgKG9wdGlvbnMucmV2YWxpZGF0ZUlmU3RhbGUgJiYgcXVlcnkuaXNTdGFsZUJ5VGltZShyZXNvbHZlU3RhbGVUaW1lKGRlZmF1bHRlZE9wdGlvbnMuc3RhbGVUaW1lLCBxdWVyeSkpKSB7XG4gICAgICAgIHZvaWQgdGhpcy5wcmVmZXRjaFF1ZXJ5KGRlZmF1bHRlZE9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjYWNoZWREYXRhKTtcbiAgICB9XG4gIH1cbiAgZ2V0UXVlcmllc0RhdGEoZmlsdGVycykge1xuICAgIHJldHVybiB0aGlzLiNxdWVyeUNhY2hlLmZpbmRBbGwoZmlsdGVycykubWFwKCh7IHF1ZXJ5S2V5LCBzdGF0ZSB9KSA9PiB7XG4gICAgICBjb25zdCBkYXRhID0gc3RhdGUuZGF0YTtcbiAgICAgIHJldHVybiBbcXVlcnlLZXksIGRhdGFdO1xuICAgIH0pO1xuICB9XG4gIHNldFF1ZXJ5RGF0YShxdWVyeUtleSwgdXBkYXRlciwgb3B0aW9ucykge1xuICAgIGNvbnN0IGRlZmF1bHRlZE9wdGlvbnMgPSB0aGlzLmRlZmF1bHRRdWVyeU9wdGlvbnMoeyBxdWVyeUtleSB9KTtcbiAgICBjb25zdCBxdWVyeSA9IHRoaXMuI3F1ZXJ5Q2FjaGUuZ2V0KFxuICAgICAgZGVmYXVsdGVkT3B0aW9ucy5xdWVyeUhhc2hcbiAgICApO1xuICAgIGNvbnN0IHByZXZEYXRhID0gcXVlcnk/LnN0YXRlLmRhdGE7XG4gICAgY29uc3QgZGF0YSA9IGZ1bmN0aW9uYWxVcGRhdGUodXBkYXRlciwgcHJldkRhdGEpO1xuICAgIGlmIChkYXRhID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiNxdWVyeUNhY2hlLmJ1aWxkKHRoaXMsIGRlZmF1bHRlZE9wdGlvbnMpLnNldERhdGEoZGF0YSwgeyAuLi5vcHRpb25zLCBtYW51YWw6IHRydWUgfSk7XG4gIH1cbiAgc2V0UXVlcmllc0RhdGEoZmlsdGVycywgdXBkYXRlciwgb3B0aW9ucykge1xuICAgIHJldHVybiBub3RpZnlNYW5hZ2VyLmJhdGNoKFxuICAgICAgKCkgPT4gdGhpcy4jcXVlcnlDYWNoZS5maW5kQWxsKGZpbHRlcnMpLm1hcCgoeyBxdWVyeUtleSB9KSA9PiBbXG4gICAgICAgIHF1ZXJ5S2V5LFxuICAgICAgICB0aGlzLnNldFF1ZXJ5RGF0YShxdWVyeUtleSwgdXBkYXRlciwgb3B0aW9ucylcbiAgICAgIF0pXG4gICAgKTtcbiAgfVxuICBnZXRRdWVyeVN0YXRlKHF1ZXJ5S2V5KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuZGVmYXVsdFF1ZXJ5T3B0aW9ucyh7IHF1ZXJ5S2V5IH0pO1xuICAgIHJldHVybiB0aGlzLiNxdWVyeUNhY2hlLmdldChvcHRpb25zLnF1ZXJ5SGFzaCk/LnN0YXRlO1xuICB9XG4gIHJlbW92ZVF1ZXJpZXMoZmlsdGVycykge1xuICAgIGNvbnN0IHF1ZXJ5Q2FjaGUgPSB0aGlzLiNxdWVyeUNhY2hlO1xuICAgIG5vdGlmeU1hbmFnZXIuYmF0Y2goKCkgPT4ge1xuICAgICAgcXVlcnlDYWNoZS5maW5kQWxsKGZpbHRlcnMpLmZvckVhY2goKHF1ZXJ5KSA9PiB7XG4gICAgICAgIHF1ZXJ5Q2FjaGUucmVtb3ZlKHF1ZXJ5KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHJlc2V0UXVlcmllcyhmaWx0ZXJzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcXVlcnlDYWNoZSA9IHRoaXMuI3F1ZXJ5Q2FjaGU7XG4gICAgY29uc3QgcmVmZXRjaEZpbHRlcnMgPSB7XG4gICAgICB0eXBlOiBcImFjdGl2ZVwiLFxuICAgICAgLi4uZmlsdGVyc1xuICAgIH07XG4gICAgcmV0dXJuIG5vdGlmeU1hbmFnZXIuYmF0Y2goKCkgPT4ge1xuICAgICAgcXVlcnlDYWNoZS5maW5kQWxsKGZpbHRlcnMpLmZvckVhY2goKHF1ZXJ5KSA9PiB7XG4gICAgICAgIHF1ZXJ5LnJlc2V0KCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzLnJlZmV0Y2hRdWVyaWVzKHJlZmV0Y2hGaWx0ZXJzLCBvcHRpb25zKTtcbiAgICB9KTtcbiAgfVxuICBjYW5jZWxRdWVyaWVzKGZpbHRlcnMgPSB7fSwgY2FuY2VsT3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgZGVmYXVsdGVkQ2FuY2VsT3B0aW9ucyA9IHsgcmV2ZXJ0OiB0cnVlLCAuLi5jYW5jZWxPcHRpb25zIH07XG4gICAgY29uc3QgcHJvbWlzZXMgPSBub3RpZnlNYW5hZ2VyLmJhdGNoKFxuICAgICAgKCkgPT4gdGhpcy4jcXVlcnlDYWNoZS5maW5kQWxsKGZpbHRlcnMpLm1hcCgocXVlcnkpID0+IHF1ZXJ5LmNhbmNlbChkZWZhdWx0ZWRDYW5jZWxPcHRpb25zKSlcbiAgICApO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihub29wKS5jYXRjaChub29wKTtcbiAgfVxuICBpbnZhbGlkYXRlUXVlcmllcyhmaWx0ZXJzID0ge30sIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBub3RpZnlNYW5hZ2VyLmJhdGNoKCgpID0+IHtcbiAgICAgIHRoaXMuI3F1ZXJ5Q2FjaGUuZmluZEFsbChmaWx0ZXJzKS5mb3JFYWNoKChxdWVyeSkgPT4ge1xuICAgICAgICBxdWVyeS5pbnZhbGlkYXRlKCk7XG4gICAgICB9KTtcbiAgICAgIGlmIChmaWx0ZXJzLnJlZmV0Y2hUeXBlID09PSBcIm5vbmVcIikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB9XG4gICAgICBjb25zdCByZWZldGNoRmlsdGVycyA9IHtcbiAgICAgICAgLi4uZmlsdGVycyxcbiAgICAgICAgdHlwZTogZmlsdGVycy5yZWZldGNoVHlwZSA/PyBmaWx0ZXJzLnR5cGUgPz8gXCJhY3RpdmVcIlxuICAgICAgfTtcbiAgICAgIHJldHVybiB0aGlzLnJlZmV0Y2hRdWVyaWVzKHJlZmV0Y2hGaWx0ZXJzLCBvcHRpb25zKTtcbiAgICB9KTtcbiAgfVxuICByZWZldGNoUXVlcmllcyhmaWx0ZXJzID0ge30sIG9wdGlvbnMpIHtcbiAgICBjb25zdCBmZXRjaE9wdGlvbnMgPSB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgY2FuY2VsUmVmZXRjaDogb3B0aW9ucz8uY2FuY2VsUmVmZXRjaCA/PyB0cnVlXG4gICAgfTtcbiAgICBjb25zdCBwcm9taXNlcyA9IG5vdGlmeU1hbmFnZXIuYmF0Y2goXG4gICAgICAoKSA9PiB0aGlzLiNxdWVyeUNhY2hlLmZpbmRBbGwoZmlsdGVycykuZmlsdGVyKChxdWVyeSkgPT4gIXF1ZXJ5LmlzRGlzYWJsZWQoKSkubWFwKChxdWVyeSkgPT4ge1xuICAgICAgICBsZXQgcHJvbWlzZSA9IHF1ZXJ5LmZldGNoKHZvaWQgMCwgZmV0Y2hPcHRpb25zKTtcbiAgICAgICAgaWYgKCFmZXRjaE9wdGlvbnMudGhyb3dPbkVycm9yKSB7XG4gICAgICAgICAgcHJvbWlzZSA9IHByb21pc2UuY2F0Y2gobm9vcCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHF1ZXJ5LnN0YXRlLmZldGNoU3RhdHVzID09PSBcInBhdXNlZFwiID8gUHJvbWlzZS5yZXNvbHZlKCkgOiBwcm9taXNlO1xuICAgICAgfSlcbiAgICApO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihub29wKTtcbiAgfVxuICBmZXRjaFF1ZXJ5KG9wdGlvbnMpIHtcbiAgICBjb25zdCBkZWZhdWx0ZWRPcHRpb25zID0gdGhpcy5kZWZhdWx0UXVlcnlPcHRpb25zKG9wdGlvbnMpO1xuICAgIGlmIChkZWZhdWx0ZWRPcHRpb25zLnJldHJ5ID09PSB2b2lkIDApIHtcbiAgICAgIGRlZmF1bHRlZE9wdGlvbnMucmV0cnkgPSBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgcXVlcnkgPSB0aGlzLiNxdWVyeUNhY2hlLmJ1aWxkKHRoaXMsIGRlZmF1bHRlZE9wdGlvbnMpO1xuICAgIHJldHVybiBxdWVyeS5pc1N0YWxlQnlUaW1lKFxuICAgICAgcmVzb2x2ZVN0YWxlVGltZShkZWZhdWx0ZWRPcHRpb25zLnN0YWxlVGltZSwgcXVlcnkpXG4gICAgKSA/IHF1ZXJ5LmZldGNoKGRlZmF1bHRlZE9wdGlvbnMpIDogUHJvbWlzZS5yZXNvbHZlKHF1ZXJ5LnN0YXRlLmRhdGEpO1xuICB9XG4gIHByZWZldGNoUXVlcnkob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmZldGNoUXVlcnkob3B0aW9ucykudGhlbihub29wKS5jYXRjaChub29wKTtcbiAgfVxuICBmZXRjaEluZmluaXRlUXVlcnkob3B0aW9ucykge1xuICAgIG9wdGlvbnMuYmVoYXZpb3IgPSBpbmZpbml0ZVF1ZXJ5QmVoYXZpb3Iob3B0aW9ucy5wYWdlcyk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hRdWVyeShvcHRpb25zKTtcbiAgfVxuICBwcmVmZXRjaEluZmluaXRlUXVlcnkob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmZldGNoSW5maW5pdGVRdWVyeShvcHRpb25zKS50aGVuKG5vb3ApLmNhdGNoKG5vb3ApO1xuICB9XG4gIGVuc3VyZUluZmluaXRlUXVlcnlEYXRhKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zLmJlaGF2aW9yID0gaW5maW5pdGVRdWVyeUJlaGF2aW9yKG9wdGlvbnMucGFnZXMpO1xuICAgIHJldHVybiB0aGlzLmVuc3VyZVF1ZXJ5RGF0YShvcHRpb25zKTtcbiAgfVxuICByZXN1bWVQYXVzZWRNdXRhdGlvbnMoKSB7XG4gICAgaWYgKG9ubGluZU1hbmFnZXIuaXNPbmxpbmUoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuI211dGF0aW9uQ2FjaGUucmVzdW1lUGF1c2VkTXV0YXRpb25zKCk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuICBnZXRRdWVyeUNhY2hlKCkge1xuICAgIHJldHVybiB0aGlzLiNxdWVyeUNhY2hlO1xuICB9XG4gIGdldE11dGF0aW9uQ2FjaGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI211dGF0aW9uQ2FjaGU7XG4gIH1cbiAgZ2V0RGVmYXVsdE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2RlZmF1bHRPcHRpb25zO1xuICB9XG4gIHNldERlZmF1bHRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICB0aGlzLiNkZWZhdWx0T3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cbiAgc2V0UXVlcnlEZWZhdWx0cyhxdWVyeUtleSwgb3B0aW9ucykge1xuICAgIHRoaXMuI3F1ZXJ5RGVmYXVsdHMuc2V0KGhhc2hLZXkocXVlcnlLZXkpLCB7XG4gICAgICBxdWVyeUtleSxcbiAgICAgIGRlZmF1bHRPcHRpb25zOiBvcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgZ2V0UXVlcnlEZWZhdWx0cyhxdWVyeUtleSkge1xuICAgIGNvbnN0IGRlZmF1bHRzID0gWy4uLnRoaXMuI3F1ZXJ5RGVmYXVsdHMudmFsdWVzKCldO1xuICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICBkZWZhdWx0cy5mb3JFYWNoKChxdWVyeURlZmF1bHQpID0+IHtcbiAgICAgIGlmIChwYXJ0aWFsTWF0Y2hLZXkocXVlcnlLZXksIHF1ZXJ5RGVmYXVsdC5xdWVyeUtleSkpIHtcbiAgICAgICAgcmVzdWx0ID0geyAuLi5yZXN1bHQsIC4uLnF1ZXJ5RGVmYXVsdC5kZWZhdWx0T3B0aW9ucyB9O1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgc2V0TXV0YXRpb25EZWZhdWx0cyhtdXRhdGlvbktleSwgb3B0aW9ucykge1xuICAgIHRoaXMuI211dGF0aW9uRGVmYXVsdHMuc2V0KGhhc2hLZXkobXV0YXRpb25LZXkpLCB7XG4gICAgICBtdXRhdGlvbktleSxcbiAgICAgIGRlZmF1bHRPcHRpb25zOiBvcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgZ2V0TXV0YXRpb25EZWZhdWx0cyhtdXRhdGlvbktleSkge1xuICAgIGNvbnN0IGRlZmF1bHRzID0gWy4uLnRoaXMuI211dGF0aW9uRGVmYXVsdHMudmFsdWVzKCldO1xuICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICBkZWZhdWx0cy5mb3JFYWNoKChxdWVyeURlZmF1bHQpID0+IHtcbiAgICAgIGlmIChwYXJ0aWFsTWF0Y2hLZXkobXV0YXRpb25LZXksIHF1ZXJ5RGVmYXVsdC5tdXRhdGlvbktleSkpIHtcbiAgICAgICAgcmVzdWx0ID0geyAuLi5yZXN1bHQsIC4uLnF1ZXJ5RGVmYXVsdC5kZWZhdWx0T3B0aW9ucyB9O1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZGVmYXVsdFF1ZXJ5T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuX2RlZmF1bHRlZCkge1xuICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuICAgIGNvbnN0IGRlZmF1bHRlZE9wdGlvbnMgPSB7XG4gICAgICAuLi50aGlzLiNkZWZhdWx0T3B0aW9ucy5xdWVyaWVzLFxuICAgICAgLi4udGhpcy5nZXRRdWVyeURlZmF1bHRzKG9wdGlvbnMucXVlcnlLZXkpLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIF9kZWZhdWx0ZWQ6IHRydWVcbiAgICB9O1xuICAgIGlmICghZGVmYXVsdGVkT3B0aW9ucy5xdWVyeUhhc2gpIHtcbiAgICAgIGRlZmF1bHRlZE9wdGlvbnMucXVlcnlIYXNoID0gaGFzaFF1ZXJ5S2V5QnlPcHRpb25zKFxuICAgICAgICBkZWZhdWx0ZWRPcHRpb25zLnF1ZXJ5S2V5LFxuICAgICAgICBkZWZhdWx0ZWRPcHRpb25zXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoZGVmYXVsdGVkT3B0aW9ucy5yZWZldGNoT25SZWNvbm5lY3QgPT09IHZvaWQgMCkge1xuICAgICAgZGVmYXVsdGVkT3B0aW9ucy5yZWZldGNoT25SZWNvbm5lY3QgPSBkZWZhdWx0ZWRPcHRpb25zLm5ldHdvcmtNb2RlICE9PSBcImFsd2F5c1wiO1xuICAgIH1cbiAgICBpZiAoZGVmYXVsdGVkT3B0aW9ucy50aHJvd09uRXJyb3IgPT09IHZvaWQgMCkge1xuICAgICAgZGVmYXVsdGVkT3B0aW9ucy50aHJvd09uRXJyb3IgPSAhIWRlZmF1bHRlZE9wdGlvbnMuc3VzcGVuc2U7XG4gICAgfVxuICAgIGlmICghZGVmYXVsdGVkT3B0aW9ucy5uZXR3b3JrTW9kZSAmJiBkZWZhdWx0ZWRPcHRpb25zLnBlcnNpc3Rlcikge1xuICAgICAgZGVmYXVsdGVkT3B0aW9ucy5uZXR3b3JrTW9kZSA9IFwib2ZmbGluZUZpcnN0XCI7XG4gICAgfVxuICAgIGlmIChkZWZhdWx0ZWRPcHRpb25zLmVuYWJsZWQgIT09IHRydWUgJiYgZGVmYXVsdGVkT3B0aW9ucy5xdWVyeUZuID09PSBza2lwVG9rZW4pIHtcbiAgICAgIGRlZmF1bHRlZE9wdGlvbnMuZW5hYmxlZCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdGVkT3B0aW9ucztcbiAgfVxuICBkZWZhdWx0TXV0YXRpb25PcHRpb25zKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucz8uX2RlZmF1bHRlZCkge1xuICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAuLi50aGlzLiNkZWZhdWx0T3B0aW9ucy5tdXRhdGlvbnMsXG4gICAgICAuLi5vcHRpb25zPy5tdXRhdGlvbktleSAmJiB0aGlzLmdldE11dGF0aW9uRGVmYXVsdHMob3B0aW9ucy5tdXRhdGlvbktleSksXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgX2RlZmF1bHRlZDogdHJ1ZVxuICAgIH07XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy4jcXVlcnlDYWNoZS5jbGVhcigpO1xuICAgIHRoaXMuI211dGF0aW9uQ2FjaGUuY2xlYXIoKTtcbiAgfVxufTtcbmV4cG9ydCB7XG4gIFF1ZXJ5Q2xpZW50XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cXVlcnlDbGllbnQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/queryClient.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/removable.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/modern/removable.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Removable: () => (/* binding */ Removable)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/utils.js\");\n// src/removable.ts\n\nvar Removable = class {\n  #gcTimeout;\n  destroy() {\n    this.clearGcTimeout();\n  }\n  scheduleGc() {\n    this.clearGcTimeout();\n    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isValidTimeout)(this.gcTime)) {\n      this.#gcTimeout = setTimeout(() => {\n        this.optionalRemove();\n      }, this.gcTime);\n    }\n  }\n  updateGcTime(newGcTime) {\n    this.gcTime = Math.max(\n      this.gcTime || 0,\n      newGcTime ?? (_utils_js__WEBPACK_IMPORTED_MODULE_0__.isServer ? Infinity : 5 * 60 * 1e3)\n    );\n  }\n  clearGcTimeout() {\n    if (this.#gcTimeout) {\n      clearTimeout(this.#gcTimeout);\n      this.#gcTimeout = void 0;\n    }\n  }\n};\n\n//# sourceMappingURL=removable.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vcmVtb3ZhYmxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlEQUFjO0FBQ3RCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwrQ0FBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvd29uZGVybGFuZG1pdGNoL0Nhc2NhZGVQcm9qZWN0cy9Xb25kZXJWaXRlLWZyb250ZW5kL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vcmVtb3ZhYmxlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9yZW1vdmFibGUudHNcbmltcG9ydCB7IGlzU2VydmVyLCBpc1ZhbGlkVGltZW91dCB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG52YXIgUmVtb3ZhYmxlID0gY2xhc3Mge1xuICAjZ2NUaW1lb3V0O1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuY2xlYXJHY1RpbWVvdXQoKTtcbiAgfVxuICBzY2hlZHVsZUdjKCkge1xuICAgIHRoaXMuY2xlYXJHY1RpbWVvdXQoKTtcbiAgICBpZiAoaXNWYWxpZFRpbWVvdXQodGhpcy5nY1RpbWUpKSB7XG4gICAgICB0aGlzLiNnY1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5vcHRpb25hbFJlbW92ZSgpO1xuICAgICAgfSwgdGhpcy5nY1RpbWUpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVHY1RpbWUobmV3R2NUaW1lKSB7XG4gICAgdGhpcy5nY1RpbWUgPSBNYXRoLm1heChcbiAgICAgIHRoaXMuZ2NUaW1lIHx8IDAsXG4gICAgICBuZXdHY1RpbWUgPz8gKGlzU2VydmVyID8gSW5maW5pdHkgOiA1ICogNjAgKiAxZTMpXG4gICAgKTtcbiAgfVxuICBjbGVhckdjVGltZW91dCgpIHtcbiAgICBpZiAodGhpcy4jZ2NUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy4jZ2NUaW1lb3V0KTtcbiAgICAgIHRoaXMuI2djVGltZW91dCA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbn07XG5leHBvcnQge1xuICBSZW1vdmFibGVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZW1vdmFibGUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/removable.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/retryer.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/modern/retryer.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CancelledError: () => (/* binding */ CancelledError),\n/* harmony export */   canFetch: () => (/* binding */ canFetch),\n/* harmony export */   createRetryer: () => (/* binding */ createRetryer),\n/* harmony export */   isCancelledError: () => (/* binding */ isCancelledError)\n/* harmony export */ });\n/* harmony import */ var _focusManager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./focusManager.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/focusManager.js\");\n/* harmony import */ var _onlineManager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./onlineManager.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/onlineManager.js\");\n/* harmony import */ var _thenable_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./thenable.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/thenable.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/utils.js\");\n// src/retryer.ts\n\n\n\n\nfunction defaultRetryDelay(failureCount) {\n  return Math.min(1e3 * 2 ** failureCount, 3e4);\n}\nfunction canFetch(networkMode) {\n  return (networkMode ?? \"online\") === \"online\" ? _onlineManager_js__WEBPACK_IMPORTED_MODULE_0__.onlineManager.isOnline() : true;\n}\nvar CancelledError = class extends Error {\n  constructor(options) {\n    super(\"CancelledError\");\n    this.revert = options?.revert;\n    this.silent = options?.silent;\n  }\n};\nfunction isCancelledError(value) {\n  return value instanceof CancelledError;\n}\nfunction createRetryer(config) {\n  let isRetryCancelled = false;\n  let failureCount = 0;\n  let isResolved = false;\n  let continueFn;\n  const thenable = (0,_thenable_js__WEBPACK_IMPORTED_MODULE_1__.pendingThenable)();\n  const cancel = (cancelOptions) => {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions));\n      config.abort?.();\n    }\n  };\n  const cancelRetry = () => {\n    isRetryCancelled = true;\n  };\n  const continueRetry = () => {\n    isRetryCancelled = false;\n  };\n  const canContinue = () => _focusManager_js__WEBPACK_IMPORTED_MODULE_2__.focusManager.isFocused() && (config.networkMode === \"always\" || _onlineManager_js__WEBPACK_IMPORTED_MODULE_0__.onlineManager.isOnline()) && config.canRun();\n  const canStart = () => canFetch(config.networkMode) && config.canRun();\n  const resolve = (value) => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onSuccess?.(value);\n      continueFn?.();\n      thenable.resolve(value);\n    }\n  };\n  const reject = (value) => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onError?.(value);\n      continueFn?.();\n      thenable.reject(value);\n    }\n  };\n  const pause = () => {\n    return new Promise((continueResolve) => {\n      continueFn = (value) => {\n        if (isResolved || canContinue()) {\n          continueResolve(value);\n        }\n      };\n      config.onPause?.();\n    }).then(() => {\n      continueFn = void 0;\n      if (!isResolved) {\n        config.onContinue?.();\n      }\n    });\n  };\n  const run = () => {\n    if (isResolved) {\n      return;\n    }\n    let promiseOrValue;\n    const initialPromise = failureCount === 0 ? config.initialPromise : void 0;\n    try {\n      promiseOrValue = initialPromise ?? config.fn();\n    } catch (error) {\n      promiseOrValue = Promise.reject(error);\n    }\n    Promise.resolve(promiseOrValue).then(resolve).catch((error) => {\n      if (isResolved) {\n        return;\n      }\n      const retry = config.retry ?? (_utils_js__WEBPACK_IMPORTED_MODULE_3__.isServer ? 0 : 3);\n      const retryDelay = config.retryDelay ?? defaultRetryDelay;\n      const delay = typeof retryDelay === \"function\" ? retryDelay(failureCount, error) : retryDelay;\n      const shouldRetry = retry === true || typeof retry === \"number\" && failureCount < retry || typeof retry === \"function\" && retry(failureCount, error);\n      if (isRetryCancelled || !shouldRetry) {\n        reject(error);\n        return;\n      }\n      failureCount++;\n      config.onFail?.(failureCount, error);\n      (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.sleep)(delay).then(() => {\n        return canContinue() ? void 0 : pause();\n      }).then(() => {\n        if (isRetryCancelled) {\n          reject(error);\n        } else {\n          run();\n        }\n      });\n    });\n  };\n  return {\n    promise: thenable,\n    cancel,\n    continue: () => {\n      continueFn?.();\n      return thenable;\n    },\n    cancelRetry,\n    continueRetry,\n    canStart,\n    start: () => {\n      if (canStart()) {\n        run();\n      } else {\n        pause().then(run);\n      }\n      return thenable;\n    }\n  };\n}\n\n//# sourceMappingURL=retryer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vcmV0cnllci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ2lEO0FBQ0U7QUFDSDtBQUNIO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELDREQUFhO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDZEQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwwREFBWSxvREFBb0QsNERBQWE7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQywrQ0FBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGdEQUFLO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUU7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvV29uZGVyVml0ZS1mcm9udGVuZC9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3F1ZXJ5LWNvcmUvYnVpbGQvbW9kZXJuL3JldHJ5ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3JldHJ5ZXIudHNcbmltcG9ydCB7IGZvY3VzTWFuYWdlciB9IGZyb20gXCIuL2ZvY3VzTWFuYWdlci5qc1wiO1xuaW1wb3J0IHsgb25saW5lTWFuYWdlciB9IGZyb20gXCIuL29ubGluZU1hbmFnZXIuanNcIjtcbmltcG9ydCB7IHBlbmRpbmdUaGVuYWJsZSB9IGZyb20gXCIuL3RoZW5hYmxlLmpzXCI7XG5pbXBvcnQgeyBpc1NlcnZlciwgc2xlZXAgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuZnVuY3Rpb24gZGVmYXVsdFJldHJ5RGVsYXkoZmFpbHVyZUNvdW50KSB7XG4gIHJldHVybiBNYXRoLm1pbigxZTMgKiAyICoqIGZhaWx1cmVDb3VudCwgM2U0KTtcbn1cbmZ1bmN0aW9uIGNhbkZldGNoKG5ldHdvcmtNb2RlKSB7XG4gIHJldHVybiAobmV0d29ya01vZGUgPz8gXCJvbmxpbmVcIikgPT09IFwib25saW5lXCIgPyBvbmxpbmVNYW5hZ2VyLmlzT25saW5lKCkgOiB0cnVlO1xufVxudmFyIENhbmNlbGxlZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihcIkNhbmNlbGxlZEVycm9yXCIpO1xuICAgIHRoaXMucmV2ZXJ0ID0gb3B0aW9ucz8ucmV2ZXJ0O1xuICAgIHRoaXMuc2lsZW50ID0gb3B0aW9ucz8uc2lsZW50O1xuICB9XG59O1xuZnVuY3Rpb24gaXNDYW5jZWxsZWRFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBDYW5jZWxsZWRFcnJvcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJldHJ5ZXIoY29uZmlnKSB7XG4gIGxldCBpc1JldHJ5Q2FuY2VsbGVkID0gZmFsc2U7XG4gIGxldCBmYWlsdXJlQ291bnQgPSAwO1xuICBsZXQgaXNSZXNvbHZlZCA9IGZhbHNlO1xuICBsZXQgY29udGludWVGbjtcbiAgY29uc3QgdGhlbmFibGUgPSBwZW5kaW5nVGhlbmFibGUoKTtcbiAgY29uc3QgY2FuY2VsID0gKGNhbmNlbE9wdGlvbnMpID0+IHtcbiAgICBpZiAoIWlzUmVzb2x2ZWQpIHtcbiAgICAgIHJlamVjdChuZXcgQ2FuY2VsbGVkRXJyb3IoY2FuY2VsT3B0aW9ucykpO1xuICAgICAgY29uZmlnLmFib3J0Py4oKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGNhbmNlbFJldHJ5ID0gKCkgPT4ge1xuICAgIGlzUmV0cnlDYW5jZWxsZWQgPSB0cnVlO1xuICB9O1xuICBjb25zdCBjb250aW51ZVJldHJ5ID0gKCkgPT4ge1xuICAgIGlzUmV0cnlDYW5jZWxsZWQgPSBmYWxzZTtcbiAgfTtcbiAgY29uc3QgY2FuQ29udGludWUgPSAoKSA9PiBmb2N1c01hbmFnZXIuaXNGb2N1c2VkKCkgJiYgKGNvbmZpZy5uZXR3b3JrTW9kZSA9PT0gXCJhbHdheXNcIiB8fCBvbmxpbmVNYW5hZ2VyLmlzT25saW5lKCkpICYmIGNvbmZpZy5jYW5SdW4oKTtcbiAgY29uc3QgY2FuU3RhcnQgPSAoKSA9PiBjYW5GZXRjaChjb25maWcubmV0d29ya01vZGUpICYmIGNvbmZpZy5jYW5SdW4oKTtcbiAgY29uc3QgcmVzb2x2ZSA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmICghaXNSZXNvbHZlZCkge1xuICAgICAgaXNSZXNvbHZlZCA9IHRydWU7XG4gICAgICBjb25maWcub25TdWNjZXNzPy4odmFsdWUpO1xuICAgICAgY29udGludWVGbj8uKCk7XG4gICAgICB0aGVuYWJsZS5yZXNvbHZlKHZhbHVlKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHJlamVjdCA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmICghaXNSZXNvbHZlZCkge1xuICAgICAgaXNSZXNvbHZlZCA9IHRydWU7XG4gICAgICBjb25maWcub25FcnJvcj8uKHZhbHVlKTtcbiAgICAgIGNvbnRpbnVlRm4/LigpO1xuICAgICAgdGhlbmFibGUucmVqZWN0KHZhbHVlKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHBhdXNlID0gKCkgPT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgoY29udGludWVSZXNvbHZlKSA9PiB7XG4gICAgICBjb250aW51ZUZuID0gKHZhbHVlKSA9PiB7XG4gICAgICAgIGlmIChpc1Jlc29sdmVkIHx8IGNhbkNvbnRpbnVlKCkpIHtcbiAgICAgICAgICBjb250aW51ZVJlc29sdmUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uZmlnLm9uUGF1c2U/LigpO1xuICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgY29udGludWVGbiA9IHZvaWQgMDtcbiAgICAgIGlmICghaXNSZXNvbHZlZCkge1xuICAgICAgICBjb25maWcub25Db250aW51ZT8uKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IHJ1biA9ICgpID0+IHtcbiAgICBpZiAoaXNSZXNvbHZlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgcHJvbWlzZU9yVmFsdWU7XG4gICAgY29uc3QgaW5pdGlhbFByb21pc2UgPSBmYWlsdXJlQ291bnQgPT09IDAgPyBjb25maWcuaW5pdGlhbFByb21pc2UgOiB2b2lkIDA7XG4gICAgdHJ5IHtcbiAgICAgIHByb21pc2VPclZhbHVlID0gaW5pdGlhbFByb21pc2UgPz8gY29uZmlnLmZuKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHByb21pc2VPclZhbHVlID0gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgIH1cbiAgICBQcm9taXNlLnJlc29sdmUocHJvbWlzZU9yVmFsdWUpLnRoZW4ocmVzb2x2ZSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICBpZiAoaXNSZXNvbHZlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCByZXRyeSA9IGNvbmZpZy5yZXRyeSA/PyAoaXNTZXJ2ZXIgPyAwIDogMyk7XG4gICAgICBjb25zdCByZXRyeURlbGF5ID0gY29uZmlnLnJldHJ5RGVsYXkgPz8gZGVmYXVsdFJldHJ5RGVsYXk7XG4gICAgICBjb25zdCBkZWxheSA9IHR5cGVvZiByZXRyeURlbGF5ID09PSBcImZ1bmN0aW9uXCIgPyByZXRyeURlbGF5KGZhaWx1cmVDb3VudCwgZXJyb3IpIDogcmV0cnlEZWxheTtcbiAgICAgIGNvbnN0IHNob3VsZFJldHJ5ID0gcmV0cnkgPT09IHRydWUgfHwgdHlwZW9mIHJldHJ5ID09PSBcIm51bWJlclwiICYmIGZhaWx1cmVDb3VudCA8IHJldHJ5IHx8IHR5cGVvZiByZXRyeSA9PT0gXCJmdW5jdGlvblwiICYmIHJldHJ5KGZhaWx1cmVDb3VudCwgZXJyb3IpO1xuICAgICAgaWYgKGlzUmV0cnlDYW5jZWxsZWQgfHwgIXNob3VsZFJldHJ5KSB7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZhaWx1cmVDb3VudCsrO1xuICAgICAgY29uZmlnLm9uRmFpbD8uKGZhaWx1cmVDb3VudCwgZXJyb3IpO1xuICAgICAgc2xlZXAoZGVsYXkpLnRoZW4oKCkgPT4ge1xuICAgICAgICByZXR1cm4gY2FuQ29udGludWUoKSA/IHZvaWQgMCA6IHBhdXNlKCk7XG4gICAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgICAgaWYgKGlzUmV0cnlDYW5jZWxsZWQpIHtcbiAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJ1bigpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBwcm9taXNlOiB0aGVuYWJsZSxcbiAgICBjYW5jZWwsXG4gICAgY29udGludWU6ICgpID0+IHtcbiAgICAgIGNvbnRpbnVlRm4/LigpO1xuICAgICAgcmV0dXJuIHRoZW5hYmxlO1xuICAgIH0sXG4gICAgY2FuY2VsUmV0cnksXG4gICAgY29udGludWVSZXRyeSxcbiAgICBjYW5TdGFydCxcbiAgICBzdGFydDogKCkgPT4ge1xuICAgICAgaWYgKGNhblN0YXJ0KCkpIHtcbiAgICAgICAgcnVuKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXVzZSgpLnRoZW4ocnVuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGVuYWJsZTtcbiAgICB9XG4gIH07XG59XG5leHBvcnQge1xuICBDYW5jZWxsZWRFcnJvcixcbiAgY2FuRmV0Y2gsXG4gIGNyZWF0ZVJldHJ5ZXIsXG4gIGlzQ2FuY2VsbGVkRXJyb3Jcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXRyeWVyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/retryer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/subscribable.js":
/*!************************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/modern/subscribable.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Subscribable: () => (/* binding */ Subscribable)\n/* harmony export */ });\n// src/subscribable.ts\nvar Subscribable = class {\n  constructor() {\n    this.listeners = /* @__PURE__ */ new Set();\n    this.subscribe = this.subscribe.bind(this);\n  }\n  subscribe(listener) {\n    this.listeners.add(listener);\n    this.onSubscribe();\n    return () => {\n      this.listeners.delete(listener);\n      this.onUnsubscribe();\n    };\n  }\n  hasListeners() {\n    return this.listeners.size > 0;\n  }\n  onSubscribe() {\n  }\n  onUnsubscribe() {\n  }\n};\n\n//# sourceMappingURL=subscribable.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vc3Vic2NyaWJhYmxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL1dvbmRlclZpdGUtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9xdWVyeS1jb3JlL2J1aWxkL21vZGVybi9zdWJzY3JpYmFibGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3N1YnNjcmliYWJsZS50c1xudmFyIFN1YnNjcmliYWJsZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMuc3Vic2NyaWJlID0gdGhpcy5zdWJzY3JpYmUuYmluZCh0aGlzKTtcbiAgfVxuICBzdWJzY3JpYmUobGlzdGVuZXIpIHtcbiAgICB0aGlzLmxpc3RlbmVycy5hZGQobGlzdGVuZXIpO1xuICAgIHRoaXMub25TdWJzY3JpYmUoKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdGhpcy5saXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICAgIHRoaXMub25VbnN1YnNjcmliZSgpO1xuICAgIH07XG4gIH1cbiAgaGFzTGlzdGVuZXJzKCkge1xuICAgIHJldHVybiB0aGlzLmxpc3RlbmVycy5zaXplID4gMDtcbiAgfVxuICBvblN1YnNjcmliZSgpIHtcbiAgfVxuICBvblVuc3Vic2NyaWJlKCkge1xuICB9XG59O1xuZXhwb3J0IHtcbiAgU3Vic2NyaWJhYmxlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3Vic2NyaWJhYmxlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/subscribable.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/thenable.js":
/*!********************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/modern/thenable.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   pendingThenable: () => (/* binding */ pendingThenable)\n/* harmony export */ });\n// src/thenable.ts\nfunction pendingThenable() {\n  let resolve;\n  let reject;\n  const thenable = new Promise((_resolve, _reject) => {\n    resolve = _resolve;\n    reject = _reject;\n  });\n  thenable.status = \"pending\";\n  thenable.catch(() => {\n  });\n  function finalize(data) {\n    Object.assign(thenable, data);\n    delete thenable.resolve;\n    delete thenable.reject;\n  }\n  thenable.resolve = (value) => {\n    finalize({\n      status: \"fulfilled\",\n      value\n    });\n    resolve(value);\n  };\n  thenable.reject = (reason) => {\n    finalize({\n      status: \"rejected\",\n      reason\n    });\n    reject(reason);\n  };\n  return thenable;\n}\n\n//# sourceMappingURL=thenable.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vdGhlbmFibGUuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUdFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL1dvbmRlclZpdGUtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9xdWVyeS1jb3JlL2J1aWxkL21vZGVybi90aGVuYWJsZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvdGhlbmFibGUudHNcbmZ1bmN0aW9uIHBlbmRpbmdUaGVuYWJsZSgpIHtcbiAgbGV0IHJlc29sdmU7XG4gIGxldCByZWplY3Q7XG4gIGNvbnN0IHRoZW5hYmxlID0gbmV3IFByb21pc2UoKF9yZXNvbHZlLCBfcmVqZWN0KSA9PiB7XG4gICAgcmVzb2x2ZSA9IF9yZXNvbHZlO1xuICAgIHJlamVjdCA9IF9yZWplY3Q7XG4gIH0pO1xuICB0aGVuYWJsZS5zdGF0dXMgPSBcInBlbmRpbmdcIjtcbiAgdGhlbmFibGUuY2F0Y2goKCkgPT4ge1xuICB9KTtcbiAgZnVuY3Rpb24gZmluYWxpemUoZGF0YSkge1xuICAgIE9iamVjdC5hc3NpZ24odGhlbmFibGUsIGRhdGEpO1xuICAgIGRlbGV0ZSB0aGVuYWJsZS5yZXNvbHZlO1xuICAgIGRlbGV0ZSB0aGVuYWJsZS5yZWplY3Q7XG4gIH1cbiAgdGhlbmFibGUucmVzb2x2ZSA9ICh2YWx1ZSkgPT4ge1xuICAgIGZpbmFsaXplKHtcbiAgICAgIHN0YXR1czogXCJmdWxmaWxsZWRcIixcbiAgICAgIHZhbHVlXG4gICAgfSk7XG4gICAgcmVzb2x2ZSh2YWx1ZSk7XG4gIH07XG4gIHRoZW5hYmxlLnJlamVjdCA9IChyZWFzb24pID0+IHtcbiAgICBmaW5hbGl6ZSh7XG4gICAgICBzdGF0dXM6IFwicmVqZWN0ZWRcIixcbiAgICAgIHJlYXNvblxuICAgIH0pO1xuICAgIHJlamVjdChyZWFzb24pO1xuICB9O1xuICByZXR1cm4gdGhlbmFibGU7XG59XG5leHBvcnQge1xuICBwZW5kaW5nVGhlbmFibGVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aGVuYWJsZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/thenable.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/utils.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/modern/utils.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addToEnd: () => (/* binding */ addToEnd),\n/* harmony export */   addToStart: () => (/* binding */ addToStart),\n/* harmony export */   ensureQueryFn: () => (/* binding */ ensureQueryFn),\n/* harmony export */   functionalUpdate: () => (/* binding */ functionalUpdate),\n/* harmony export */   hashKey: () => (/* binding */ hashKey),\n/* harmony export */   hashQueryKeyByOptions: () => (/* binding */ hashQueryKeyByOptions),\n/* harmony export */   isPlainArray: () => (/* binding */ isPlainArray),\n/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),\n/* harmony export */   isServer: () => (/* binding */ isServer),\n/* harmony export */   isValidTimeout: () => (/* binding */ isValidTimeout),\n/* harmony export */   keepPreviousData: () => (/* binding */ keepPreviousData),\n/* harmony export */   matchMutation: () => (/* binding */ matchMutation),\n/* harmony export */   matchQuery: () => (/* binding */ matchQuery),\n/* harmony export */   noop: () => (/* binding */ noop),\n/* harmony export */   partialMatchKey: () => (/* binding */ partialMatchKey),\n/* harmony export */   replaceData: () => (/* binding */ replaceData),\n/* harmony export */   replaceEqualDeep: () => (/* binding */ replaceEqualDeep),\n/* harmony export */   resolveEnabled: () => (/* binding */ resolveEnabled),\n/* harmony export */   resolveStaleTime: () => (/* binding */ resolveStaleTime),\n/* harmony export */   shallowEqualObjects: () => (/* binding */ shallowEqualObjects),\n/* harmony export */   skipToken: () => (/* binding */ skipToken),\n/* harmony export */   sleep: () => (/* binding */ sleep),\n/* harmony export */   timeUntilStale: () => (/* binding */ timeUntilStale)\n/* harmony export */ });\n// src/utils.ts\nvar isServer = typeof window === \"undefined\" || \"Deno\" in globalThis;\nfunction noop() {\n  return void 0;\n}\nfunction functionalUpdate(updater, input) {\n  return typeof updater === \"function\" ? updater(input) : updater;\n}\nfunction isValidTimeout(value) {\n  return typeof value === \"number\" && value >= 0 && value !== Infinity;\n}\nfunction timeUntilStale(updatedAt, staleTime) {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);\n}\nfunction resolveStaleTime(staleTime, query) {\n  return typeof staleTime === \"function\" ? staleTime(query) : staleTime;\n}\nfunction resolveEnabled(enabled, query) {\n  return typeof enabled === \"function\" ? enabled(query) : enabled;\n}\nfunction matchQuery(filters, query) {\n  const {\n    type = \"all\",\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale\n  } = filters;\n  if (queryKey) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false;\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false;\n    }\n  }\n  if (type !== \"all\") {\n    const isActive = query.isActive();\n    if (type === \"active\" && !isActive) {\n      return false;\n    }\n    if (type === \"inactive\" && isActive) {\n      return false;\n    }\n  }\n  if (typeof stale === \"boolean\" && query.isStale() !== stale) {\n    return false;\n  }\n  if (fetchStatus && fetchStatus !== query.state.fetchStatus) {\n    return false;\n  }\n  if (predicate && !predicate(query)) {\n    return false;\n  }\n  return true;\n}\nfunction matchMutation(filters, mutation) {\n  const { exact, status, predicate, mutationKey } = filters;\n  if (mutationKey) {\n    if (!mutation.options.mutationKey) {\n      return false;\n    }\n    if (exact) {\n      if (hashKey(mutation.options.mutationKey) !== hashKey(mutationKey)) {\n        return false;\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false;\n    }\n  }\n  if (status && mutation.state.status !== status) {\n    return false;\n  }\n  if (predicate && !predicate(mutation)) {\n    return false;\n  }\n  return true;\n}\nfunction hashQueryKeyByOptions(queryKey, options) {\n  const hashFn = options?.queryKeyHashFn || hashKey;\n  return hashFn(queryKey);\n}\nfunction hashKey(queryKey) {\n  return JSON.stringify(\n    queryKey,\n    (_, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key) => {\n      result[key] = val[key];\n      return result;\n    }, {}) : val\n  );\n}\nfunction partialMatchKey(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (typeof a !== typeof b) {\n    return false;\n  }\n  if (a && b && typeof a === \"object\" && typeof b === \"object\") {\n    return !Object.keys(b).some((key) => !partialMatchKey(a[key], b[key]));\n  }\n  return false;\n}\nfunction replaceEqualDeep(a, b) {\n  if (a === b) {\n    return a;\n  }\n  const array = isPlainArray(a) && isPlainArray(b);\n  if (array || isPlainObject(a) && isPlainObject(b)) {\n    const aItems = array ? a : Object.keys(a);\n    const aSize = aItems.length;\n    const bItems = array ? b : Object.keys(b);\n    const bSize = bItems.length;\n    const copy = array ? [] : {};\n    let equalItems = 0;\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i];\n      if ((!array && aItems.includes(key) || array) && a[key] === void 0 && b[key] === void 0) {\n        copy[key] = void 0;\n        equalItems++;\n      } else {\n        copy[key] = replaceEqualDeep(a[key], b[key]);\n        if (copy[key] === a[key] && a[key] !== void 0) {\n          equalItems++;\n        }\n      }\n    }\n    return aSize === bSize && equalItems === aSize ? a : copy;\n  }\n  return b;\n}\nfunction shallowEqualObjects(a, b) {\n  if (!b || Object.keys(a).length !== Object.keys(b).length) {\n    return false;\n  }\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction isPlainArray(value) {\n  return Array.isArray(value) && value.length === Object.keys(value).length;\n}\nfunction isPlainObject(o) {\n  if (!hasObjectPrototype(o)) {\n    return false;\n  }\n  const ctor = o.constructor;\n  if (ctor === void 0) {\n    return true;\n  }\n  const prot = ctor.prototype;\n  if (!hasObjectPrototype(prot)) {\n    return false;\n  }\n  if (!prot.hasOwnProperty(\"isPrototypeOf\")) {\n    return false;\n  }\n  if (Object.getPrototypeOf(o) !== Object.prototype) {\n    return false;\n  }\n  return true;\n}\nfunction hasObjectPrototype(o) {\n  return Object.prototype.toString.call(o) === \"[object Object]\";\n}\nfunction sleep(timeout) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, timeout);\n  });\n}\nfunction replaceData(prevData, data, options) {\n  if (typeof options.structuralSharing === \"function\") {\n    return options.structuralSharing(prevData, data);\n  } else if (options.structuralSharing !== false) {\n    if (true) {\n      try {\n        return replaceEqualDeep(prevData, data);\n      } catch (error) {\n        console.error(\n          `Structural sharing requires data to be JSON serializable. To fix this, turn off structuralSharing or return JSON-serializable data from your queryFn. [${options.queryHash}]: ${error}`\n        );\n      }\n    }\n    return replaceEqualDeep(prevData, data);\n  }\n  return data;\n}\nfunction keepPreviousData(previousData) {\n  return previousData;\n}\nfunction addToEnd(items, item, max = 0) {\n  const newItems = [...items, item];\n  return max && newItems.length > max ? newItems.slice(1) : newItems;\n}\nfunction addToStart(items, item, max = 0) {\n  const newItems = [item, ...items];\n  return max && newItems.length > max ? newItems.slice(0, -1) : newItems;\n}\nvar skipToken = Symbol();\nfunction ensureQueryFn(options, fetchOptions) {\n  if (true) {\n    if (options.queryFn === skipToken) {\n      console.error(\n        `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${options.queryHash}'`\n      );\n    }\n  }\n  if (!options.queryFn && fetchOptions?.initialPromise) {\n    return () => fetchOptions.initialPromise;\n  }\n  if (!options.queryFn || options.queryFn === skipToken) {\n    return () => Promise.reject(new Error(`Missing queryFn: '${options.queryHash}'`));\n  }\n  return options.queryFn;\n}\n\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsd0NBQXdDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osUUFBUSxJQUFxQztBQUM3QztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esb0tBQW9LLGtCQUFrQixLQUFLLE1BQU07QUFDak07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBLGlIQUFpSCxrQkFBa0I7QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Qsa0JBQWtCO0FBQ2pGO0FBQ0E7QUFDQTtBQXlCRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvd29uZGVybGFuZG1pdGNoL0Nhc2NhZGVQcm9qZWN0cy9Xb25kZXJWaXRlLWZyb250ZW5kL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3V0aWxzLnRzXG52YXIgaXNTZXJ2ZXIgPSB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiIHx8IFwiRGVub1wiIGluIGdsb2JhbFRoaXM7XG5mdW5jdGlvbiBub29wKCkge1xuICByZXR1cm4gdm9pZCAwO1xufVxuZnVuY3Rpb24gZnVuY3Rpb25hbFVwZGF0ZSh1cGRhdGVyLCBpbnB1dCkge1xuICByZXR1cm4gdHlwZW9mIHVwZGF0ZXIgPT09IFwiZnVuY3Rpb25cIiA/IHVwZGF0ZXIoaW5wdXQpIDogdXBkYXRlcjtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRUaW1lb3V0KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgJiYgdmFsdWUgPj0gMCAmJiB2YWx1ZSAhPT0gSW5maW5pdHk7XG59XG5mdW5jdGlvbiB0aW1lVW50aWxTdGFsZSh1cGRhdGVkQXQsIHN0YWxlVGltZSkge1xuICByZXR1cm4gTWF0aC5tYXgodXBkYXRlZEF0ICsgKHN0YWxlVGltZSB8fCAwKSAtIERhdGUubm93KCksIDApO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVN0YWxlVGltZShzdGFsZVRpbWUsIHF1ZXJ5KSB7XG4gIHJldHVybiB0eXBlb2Ygc3RhbGVUaW1lID09PSBcImZ1bmN0aW9uXCIgPyBzdGFsZVRpbWUocXVlcnkpIDogc3RhbGVUaW1lO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUVuYWJsZWQoZW5hYmxlZCwgcXVlcnkpIHtcbiAgcmV0dXJuIHR5cGVvZiBlbmFibGVkID09PSBcImZ1bmN0aW9uXCIgPyBlbmFibGVkKHF1ZXJ5KSA6IGVuYWJsZWQ7XG59XG5mdW5jdGlvbiBtYXRjaFF1ZXJ5KGZpbHRlcnMsIHF1ZXJ5KSB7XG4gIGNvbnN0IHtcbiAgICB0eXBlID0gXCJhbGxcIixcbiAgICBleGFjdCxcbiAgICBmZXRjaFN0YXR1cyxcbiAgICBwcmVkaWNhdGUsXG4gICAgcXVlcnlLZXksXG4gICAgc3RhbGVcbiAgfSA9IGZpbHRlcnM7XG4gIGlmIChxdWVyeUtleSkge1xuICAgIGlmIChleGFjdCkge1xuICAgICAgaWYgKHF1ZXJ5LnF1ZXJ5SGFzaCAhPT0gaGFzaFF1ZXJ5S2V5QnlPcHRpb25zKHF1ZXJ5S2V5LCBxdWVyeS5vcHRpb25zKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghcGFydGlhbE1hdGNoS2V5KHF1ZXJ5LnF1ZXJ5S2V5LCBxdWVyeUtleSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGUgIT09IFwiYWxsXCIpIHtcbiAgICBjb25zdCBpc0FjdGl2ZSA9IHF1ZXJ5LmlzQWN0aXZlKCk7XG4gICAgaWYgKHR5cGUgPT09IFwiYWN0aXZlXCIgJiYgIWlzQWN0aXZlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBcImluYWN0aXZlXCIgJiYgaXNBY3RpdmUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiBzdGFsZSA9PT0gXCJib29sZWFuXCIgJiYgcXVlcnkuaXNTdGFsZSgpICE9PSBzdGFsZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZmV0Y2hTdGF0dXMgJiYgZmV0Y2hTdGF0dXMgIT09IHF1ZXJ5LnN0YXRlLmZldGNoU3RhdHVzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChwcmVkaWNhdGUgJiYgIXByZWRpY2F0ZShxdWVyeSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBtYXRjaE11dGF0aW9uKGZpbHRlcnMsIG11dGF0aW9uKSB7XG4gIGNvbnN0IHsgZXhhY3QsIHN0YXR1cywgcHJlZGljYXRlLCBtdXRhdGlvbktleSB9ID0gZmlsdGVycztcbiAgaWYgKG11dGF0aW9uS2V5KSB7XG4gICAgaWYgKCFtdXRhdGlvbi5vcHRpb25zLm11dGF0aW9uS2V5KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChleGFjdCkge1xuICAgICAgaWYgKGhhc2hLZXkobXV0YXRpb24ub3B0aW9ucy5tdXRhdGlvbktleSkgIT09IGhhc2hLZXkobXV0YXRpb25LZXkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFwYXJ0aWFsTWF0Y2hLZXkobXV0YXRpb24ub3B0aW9ucy5tdXRhdGlvbktleSwgbXV0YXRpb25LZXkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmIChzdGF0dXMgJiYgbXV0YXRpb24uc3RhdGUuc3RhdHVzICE9PSBzdGF0dXMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHByZWRpY2F0ZSAmJiAhcHJlZGljYXRlKG11dGF0aW9uKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGhhc2hRdWVyeUtleUJ5T3B0aW9ucyhxdWVyeUtleSwgb3B0aW9ucykge1xuICBjb25zdCBoYXNoRm4gPSBvcHRpb25zPy5xdWVyeUtleUhhc2hGbiB8fCBoYXNoS2V5O1xuICByZXR1cm4gaGFzaEZuKHF1ZXJ5S2V5KTtcbn1cbmZ1bmN0aW9uIGhhc2hLZXkocXVlcnlLZXkpIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KFxuICAgIHF1ZXJ5S2V5LFxuICAgIChfLCB2YWwpID0+IGlzUGxhaW5PYmplY3QodmFsKSA/IE9iamVjdC5rZXlzKHZhbCkuc29ydCgpLnJlZHVjZSgocmVzdWx0LCBrZXkpID0+IHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsW2tleV07XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIHt9KSA6IHZhbFxuICApO1xufVxuZnVuY3Rpb24gcGFydGlhbE1hdGNoS2V5KGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodHlwZW9mIGEgIT09IHR5cGVvZiBiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChhICYmIGIgJiYgdHlwZW9mIGEgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGIgPT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gIU9iamVjdC5rZXlzKGIpLnNvbWUoKGtleSkgPT4gIXBhcnRpYWxNYXRjaEtleShhW2tleV0sIGJba2V5XSkpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VFcXVhbERlZXAoYSwgYikge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiBhO1xuICB9XG4gIGNvbnN0IGFycmF5ID0gaXNQbGFpbkFycmF5KGEpICYmIGlzUGxhaW5BcnJheShiKTtcbiAgaWYgKGFycmF5IHx8IGlzUGxhaW5PYmplY3QoYSkgJiYgaXNQbGFpbk9iamVjdChiKSkge1xuICAgIGNvbnN0IGFJdGVtcyA9IGFycmF5ID8gYSA6IE9iamVjdC5rZXlzKGEpO1xuICAgIGNvbnN0IGFTaXplID0gYUl0ZW1zLmxlbmd0aDtcbiAgICBjb25zdCBiSXRlbXMgPSBhcnJheSA/IGIgOiBPYmplY3Qua2V5cyhiKTtcbiAgICBjb25zdCBiU2l6ZSA9IGJJdGVtcy5sZW5ndGg7XG4gICAgY29uc3QgY29weSA9IGFycmF5ID8gW10gOiB7fTtcbiAgICBsZXQgZXF1YWxJdGVtcyA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiU2l6ZTsgaSsrKSB7XG4gICAgICBjb25zdCBrZXkgPSBhcnJheSA/IGkgOiBiSXRlbXNbaV07XG4gICAgICBpZiAoKCFhcnJheSAmJiBhSXRlbXMuaW5jbHVkZXMoa2V5KSB8fCBhcnJheSkgJiYgYVtrZXldID09PSB2b2lkIDAgJiYgYltrZXldID09PSB2b2lkIDApIHtcbiAgICAgICAgY29weVtrZXldID0gdm9pZCAwO1xuICAgICAgICBlcXVhbEl0ZW1zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb3B5W2tleV0gPSByZXBsYWNlRXF1YWxEZWVwKGFba2V5XSwgYltrZXldKTtcbiAgICAgICAgaWYgKGNvcHlba2V5XSA9PT0gYVtrZXldICYmIGFba2V5XSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgZXF1YWxJdGVtcysrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhU2l6ZSA9PT0gYlNpemUgJiYgZXF1YWxJdGVtcyA9PT0gYVNpemUgPyBhIDogY29weTtcbiAgfVxuICByZXR1cm4gYjtcbn1cbmZ1bmN0aW9uIHNoYWxsb3dFcXVhbE9iamVjdHMoYSwgYikge1xuICBpZiAoIWIgfHwgT2JqZWN0LmtleXMoYSkubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gYSkge1xuICAgIGlmIChhW2tleV0gIT09IGJba2V5XSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGlzUGxhaW5BcnJheSh2YWx1ZSkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoO1xufVxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvKSB7XG4gIGlmICghaGFzT2JqZWN0UHJvdG90eXBlKG8pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGN0b3IgPSBvLmNvbnN0cnVjdG9yO1xuICBpZiAoY3RvciA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgcHJvdCA9IGN0b3IucHJvdG90eXBlO1xuICBpZiAoIWhhc09iamVjdFByb3RvdHlwZShwcm90KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoIXByb3QuaGFzT3duUHJvcGVydHkoXCJpc1Byb3RvdHlwZU9mXCIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChPYmplY3QuZ2V0UHJvdG90eXBlT2YobykgIT09IE9iamVjdC5wcm90b3R5cGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBoYXNPYmplY3RQcm90b3R5cGUobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pID09PSBcIltvYmplY3QgT2JqZWN0XVwiO1xufVxuZnVuY3Rpb24gc2xlZXAodGltZW91dCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBzZXRUaW1lb3V0KHJlc29sdmUsIHRpbWVvdXQpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VEYXRhKHByZXZEYXRhLCBkYXRhLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5zdHJ1Y3R1cmFsU2hhcmluZyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMuc3RydWN0dXJhbFNoYXJpbmcocHJldkRhdGEsIGRhdGEpO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMuc3RydWN0dXJhbFNoYXJpbmcgIT09IGZhbHNlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHJlcGxhY2VFcXVhbERlZXAocHJldkRhdGEsIGRhdGEpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBgU3RydWN0dXJhbCBzaGFyaW5nIHJlcXVpcmVzIGRhdGEgdG8gYmUgSlNPTiBzZXJpYWxpemFibGUuIFRvIGZpeCB0aGlzLCB0dXJuIG9mZiBzdHJ1Y3R1cmFsU2hhcmluZyBvciByZXR1cm4gSlNPTi1zZXJpYWxpemFibGUgZGF0YSBmcm9tIHlvdXIgcXVlcnlGbi4gWyR7b3B0aW9ucy5xdWVyeUhhc2h9XTogJHtlcnJvcn1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXBsYWNlRXF1YWxEZWVwKHByZXZEYXRhLCBkYXRhKTtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cbmZ1bmN0aW9uIGtlZXBQcmV2aW91c0RhdGEocHJldmlvdXNEYXRhKSB7XG4gIHJldHVybiBwcmV2aW91c0RhdGE7XG59XG5mdW5jdGlvbiBhZGRUb0VuZChpdGVtcywgaXRlbSwgbWF4ID0gMCkge1xuICBjb25zdCBuZXdJdGVtcyA9IFsuLi5pdGVtcywgaXRlbV07XG4gIHJldHVybiBtYXggJiYgbmV3SXRlbXMubGVuZ3RoID4gbWF4ID8gbmV3SXRlbXMuc2xpY2UoMSkgOiBuZXdJdGVtcztcbn1cbmZ1bmN0aW9uIGFkZFRvU3RhcnQoaXRlbXMsIGl0ZW0sIG1heCA9IDApIHtcbiAgY29uc3QgbmV3SXRlbXMgPSBbaXRlbSwgLi4uaXRlbXNdO1xuICByZXR1cm4gbWF4ICYmIG5ld0l0ZW1zLmxlbmd0aCA+IG1heCA/IG5ld0l0ZW1zLnNsaWNlKDAsIC0xKSA6IG5ld0l0ZW1zO1xufVxudmFyIHNraXBUb2tlbiA9IFN5bWJvbCgpO1xuZnVuY3Rpb24gZW5zdXJlUXVlcnlGbihvcHRpb25zLCBmZXRjaE9wdGlvbnMpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmIChvcHRpb25zLnF1ZXJ5Rm4gPT09IHNraXBUb2tlbikge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgYEF0dGVtcHRlZCB0byBpbnZva2UgcXVlcnlGbiB3aGVuIHNldCB0byBza2lwVG9rZW4uIFRoaXMgaXMgbGlrZWx5IGEgY29uZmlndXJhdGlvbiBlcnJvci4gUXVlcnkgaGFzaDogJyR7b3B0aW9ucy5xdWVyeUhhc2h9J2BcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmICghb3B0aW9ucy5xdWVyeUZuICYmIGZldGNoT3B0aW9ucz8uaW5pdGlhbFByb21pc2UpIHtcbiAgICByZXR1cm4gKCkgPT4gZmV0Y2hPcHRpb25zLmluaXRpYWxQcm9taXNlO1xuICB9XG4gIGlmICghb3B0aW9ucy5xdWVyeUZuIHx8IG9wdGlvbnMucXVlcnlGbiA9PT0gc2tpcFRva2VuKSB7XG4gICAgcmV0dXJuICgpID0+IFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihgTWlzc2luZyBxdWVyeUZuOiAnJHtvcHRpb25zLnF1ZXJ5SGFzaH0nYCkpO1xuICB9XG4gIHJldHVybiBvcHRpb25zLnF1ZXJ5Rm47XG59XG5leHBvcnQge1xuICBhZGRUb0VuZCxcbiAgYWRkVG9TdGFydCxcbiAgZW5zdXJlUXVlcnlGbixcbiAgZnVuY3Rpb25hbFVwZGF0ZSxcbiAgaGFzaEtleSxcbiAgaGFzaFF1ZXJ5S2V5QnlPcHRpb25zLFxuICBpc1BsYWluQXJyYXksXG4gIGlzUGxhaW5PYmplY3QsXG4gIGlzU2VydmVyLFxuICBpc1ZhbGlkVGltZW91dCxcbiAga2VlcFByZXZpb3VzRGF0YSxcbiAgbWF0Y2hNdXRhdGlvbixcbiAgbWF0Y2hRdWVyeSxcbiAgbm9vcCxcbiAgcGFydGlhbE1hdGNoS2V5LFxuICByZXBsYWNlRGF0YSxcbiAgcmVwbGFjZUVxdWFsRGVlcCxcbiAgcmVzb2x2ZUVuYWJsZWQsXG4gIHJlc29sdmVTdGFsZVRpbWUsXG4gIHNoYWxsb3dFcXVhbE9iamVjdHMsXG4gIHNraXBUb2tlbixcbiAgc2xlZXAsXG4gIHRpbWVVbnRpbFN0YWxlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/QueryClientProvider.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@tanstack/react-query/build/modern/QueryClientProvider.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QueryClientContext: () => (/* binding */ QueryClientContext),\n/* harmony export */   QueryClientProvider: () => (/* binding */ QueryClientProvider),\n/* harmony export */   useQueryClient: () => (/* binding */ useQueryClient)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\n/* __next_internal_client_entry_do_not_use__ QueryClientContext,QueryClientProvider,useQueryClient auto */ var _s = $RefreshSig$(), _s1 = $RefreshSig$();\n// src/QueryClientProvider.tsx\n\n\nvar QueryClientContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(void 0);\nvar useQueryClient = (queryClient)=>{\n    _s();\n    const client = react__WEBPACK_IMPORTED_MODULE_0__.useContext(QueryClientContext);\n    if (queryClient) {\n        return queryClient;\n    }\n    if (!client) {\n        throw new Error(\"No QueryClient set, use QueryClientProvider to set one\");\n    }\n    return client;\n};\n_s(useQueryClient, \"6C1IqtdJdCPZ/voWsX/6r3Oc32M=\");\nvar QueryClientProvider = (param)=>{\n    let { client, children } = param;\n    _s1();\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect({\n        \"QueryClientProvider.useEffect\": ()=>{\n            client.mount();\n            return ({\n                \"QueryClientProvider.useEffect\": ()=>{\n                    client.unmount();\n                }\n            })[\"QueryClientProvider.useEffect\"];\n        }\n    }[\"QueryClientProvider.useEffect\"], [\n        client\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(QueryClientContext.Provider, {\n        value: client,\n        children\n    });\n};\n_s1(QueryClientProvider, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n_c = QueryClientProvider;\n //# sourceMappingURL=QueryClientProvider.js.map\nvar _c;\n$RefreshReg$(_c, \"QueryClientProvider\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcmVhY3QtcXVlcnkvYnVpbGQvbW9kZXJuL1F1ZXJ5Q2xpZW50UHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUN1QjtBQXVDbkI7QUFuQ0csSUFBTSxtQ0FBMkIsaURBQ3RDO0FBR0sscUJBQXVCLENBQUM7O0lBQzdCLE1BQU0sU0FBZSw4Q0FBVyxrQkFBa0I7SUFFbEQsSUFBSSxhQUFhO1FBQ2YsT0FBTztJQUNUO0lBRUEsSUFBSSxDQUFDLFFBQVE7UUFDWCxNQUFNLElBQUksTUFBTSx3REFBd0Q7SUFDMUU7SUFFQSxPQUFPO0FBQ1Q7R0FaYTtBQW1CTiwwQkFBNEI7UUFBQyxFQUNsQyxRQUNBLFVBQ0YsS0FBbUQ7O0lBQzNDO3lDQUFVO1lBQ2QsT0FBTyxNQUFNO1lBQ2I7aURBQU87b0JBQ0wsT0FBTyxRQUFRO2dCQUNqQjs7UUFDRjt3Q0FBRztRQUFDLE1BQU07S0FBQztJQUVYLE9BQ0UsdUVBQUMsbUJBQW1CLFVBQW5CO1FBQTRCLE9BQU87UUFDakM7SUFBQSxDQUNIO0FBRUo7O0tBaEJhIiwic291cmNlcyI6WyIvVXNlcnMvd29uZGVybGFuZG1pdGNoL3NyYy9RdWVyeUNsaWVudFByb3ZpZGVyLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0J1xuXG5pbXBvcnQgdHlwZSB7IFF1ZXJ5Q2xpZW50IH0gZnJvbSAnQHRhbnN0YWNrL3F1ZXJ5LWNvcmUnXG5cbmV4cG9ydCBjb25zdCBRdWVyeUNsaWVudENvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0PFF1ZXJ5Q2xpZW50IHwgdW5kZWZpbmVkPihcbiAgdW5kZWZpbmVkLFxuKVxuXG5leHBvcnQgY29uc3QgdXNlUXVlcnlDbGllbnQgPSAocXVlcnlDbGllbnQ/OiBRdWVyeUNsaWVudCkgPT4ge1xuICBjb25zdCBjbGllbnQgPSBSZWFjdC51c2VDb250ZXh0KFF1ZXJ5Q2xpZW50Q29udGV4dClcblxuICBpZiAocXVlcnlDbGllbnQpIHtcbiAgICByZXR1cm4gcXVlcnlDbGllbnRcbiAgfVxuXG4gIGlmICghY2xpZW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBRdWVyeUNsaWVudCBzZXQsIHVzZSBRdWVyeUNsaWVudFByb3ZpZGVyIHRvIHNldCBvbmUnKVxuICB9XG5cbiAgcmV0dXJuIGNsaWVudFxufVxuXG5leHBvcnQgdHlwZSBRdWVyeUNsaWVudFByb3ZpZGVyUHJvcHMgPSB7XG4gIGNsaWVudDogUXVlcnlDbGllbnRcbiAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGVcbn1cblxuZXhwb3J0IGNvbnN0IFF1ZXJ5Q2xpZW50UHJvdmlkZXIgPSAoe1xuICBjbGllbnQsXG4gIGNoaWxkcmVuLFxufTogUXVlcnlDbGllbnRQcm92aWRlclByb3BzKTogUmVhY3QuSlNYLkVsZW1lbnQgPT4ge1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNsaWVudC5tb3VudCgpXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNsaWVudC51bm1vdW50KClcbiAgICB9XG4gIH0sIFtjbGllbnRdKVxuXG4gIHJldHVybiAoXG4gICAgPFF1ZXJ5Q2xpZW50Q29udGV4dC5Qcm92aWRlciB2YWx1ZT17Y2xpZW50fT5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L1F1ZXJ5Q2xpZW50Q29udGV4dC5Qcm92aWRlcj5cbiAgKVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/QueryClientProvider.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/swr/dist/index.mjs":
/*!*****************************************!*\
  !*** ./node_modules/swr/dist/index.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SWRConfig: () => (/* binding */ SWRConfig),\n/* harmony export */   \"default\": () => (/* binding */ useSWR),\n/* harmony export */   mutate: () => (/* binding */ mutate),\n/* harmony export */   unstable_serialize: () => (/* binding */ unstable_serialize),\n/* harmony export */   useSWRConfig: () => (/* binding */ useSWRConfig)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\n\nvar noop = function () { };\n// Using noop() as the undefined value as undefined can possibly be replaced\n// by something else.  Prettier ignore and extra parentheses are necessary here\n// to ensure that tsc doesn't remove the __NOINLINE__ comment.\n// prettier-ignore\nvar UNDEFINED = ( /*#__NOINLINE__*/noop());\nvar OBJECT = Object;\nvar isUndefined = function (v) { return v === UNDEFINED; };\nvar isFunction = function (v) { return typeof v == 'function'; };\nvar mergeObjects = function (a, b) { return OBJECT.assign({}, a, b); };\nvar STR_UNDEFINED = 'undefined';\n// NOTE: Use function to guarantee it's re-evaluated between jsdom and node runtime for tests.\nvar hasWindow = function () { return typeof window != STR_UNDEFINED; };\nvar hasDocument = function () { return typeof document != STR_UNDEFINED; };\nvar hasRequestAnimationFrame = function () {\n    return hasWindow() && typeof window['requestAnimationFrame'] != STR_UNDEFINED;\n};\n\n// use WeakMap to store the object->key mapping\n// so the objects can be garbage collected.\n// WeakMap uses a hashtable under the hood, so the lookup\n// complexity is almost O(1).\nvar table = new WeakMap();\n// counter of the key\nvar counter = 0;\n// A stable hash implementation that supports:\n// - Fast and ensures unique hash properties\n// - Handles unserializable values\n// - Handles object key ordering\n// - Generates short results\n//\n// This is not a serialization function, and the result is not guaranteed to be\n// parsible.\nvar stableHash = function (arg) {\n    var type = typeof arg;\n    var constructor = arg && arg.constructor;\n    var isDate = constructor == Date;\n    var result;\n    var index;\n    if (OBJECT(arg) === arg && !isDate && constructor != RegExp) {\n        // Object/function, not null/date/regexp. Use WeakMap to store the id first.\n        // If it's already hashed, directly return the result.\n        result = table.get(arg);\n        if (result)\n            return result;\n        // Store the hash first for circular reference detection before entering the\n        // recursive `stableHash` calls.\n        // For other objects like set and map, we use this id directly as the hash.\n        result = ++counter + '~';\n        table.set(arg, result);\n        if (constructor == Array) {\n            // Array.\n            result = '@';\n            for (index = 0; index < arg.length; index++) {\n                result += stableHash(arg[index]) + ',';\n            }\n            table.set(arg, result);\n        }\n        if (constructor == OBJECT) {\n            // Object, sort keys.\n            result = '#';\n            var keys = OBJECT.keys(arg).sort();\n            while (!isUndefined((index = keys.pop()))) {\n                if (!isUndefined(arg[index])) {\n                    result += index + ':' + stableHash(arg[index]) + ',';\n                }\n            }\n            table.set(arg, result);\n        }\n    }\n    else {\n        result = isDate\n            ? arg.toJSON()\n            : type == 'symbol'\n                ? arg.toString()\n                : type == 'string'\n                    ? JSON.stringify(arg)\n                    : '' + arg;\n    }\n    return result;\n};\n\n/**\n * Due to bug https://bugs.chromium.org/p/chromium/issues/detail?id=678075,\n * it's not reliable to detect if the browser is currently online or offline\n * based on `navigator.onLine`.\n * As a work around, we always assume it's online on first load, and change\n * the status upon `online` or `offline` events.\n */\nvar online = true;\nvar isOnline = function () { return online; };\nvar hasWin = hasWindow();\nvar hasDoc = hasDocument();\n// For node and React Native, `add/removeEventListener` doesn't exist on window.\nvar onWindowEvent = hasWin && window.addEventListener\n    ? window.addEventListener.bind(window)\n    : noop;\nvar onDocumentEvent = hasDoc ? document.addEventListener.bind(document) : noop;\nvar offWindowEvent = hasWin && window.removeEventListener\n    ? window.removeEventListener.bind(window)\n    : noop;\nvar offDocumentEvent = hasDoc\n    ? document.removeEventListener.bind(document)\n    : noop;\nvar isVisible = function () {\n    var visibilityState = hasDoc && document.visibilityState;\n    return isUndefined(visibilityState) || visibilityState !== 'hidden';\n};\nvar initFocus = function (callback) {\n    // focus revalidate\n    onDocumentEvent('visibilitychange', callback);\n    onWindowEvent('focus', callback);\n    return function () {\n        offDocumentEvent('visibilitychange', callback);\n        offWindowEvent('focus', callback);\n    };\n};\nvar initReconnect = function (callback) {\n    // revalidate on reconnected\n    var onOnline = function () {\n        online = true;\n        callback();\n    };\n    // nothing to revalidate, just update the status\n    var onOffline = function () {\n        online = false;\n    };\n    onWindowEvent('online', onOnline);\n    onWindowEvent('offline', onOffline);\n    return function () {\n        offWindowEvent('online', onOnline);\n        offWindowEvent('offline', onOffline);\n    };\n};\nvar preset = {\n    isOnline: isOnline,\n    isVisible: isVisible\n};\nvar defaultConfigOptions = {\n    initFocus: initFocus,\n    initReconnect: initReconnect\n};\n\nvar IS_SERVER = !hasWindow() || 'Deno' in window;\n// Polyfill requestAnimationFrame\nvar rAF = function (f) {\n    return hasRequestAnimationFrame() ? window['requestAnimationFrame'](f) : setTimeout(f, 1);\n};\n// React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser.\nvar useIsomorphicLayoutEffect = IS_SERVER ? react__WEBPACK_IMPORTED_MODULE_0__.useEffect : react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect;\n// This assignment is to extend the Navigator type to use effectiveType.\nvar navigatorConnection = typeof navigator !== 'undefined' &&\n    navigator.connection;\n// Adjust the config based on slow connection status (<= 70Kbps).\nvar slowConnection = !IS_SERVER &&\n    navigatorConnection &&\n    (['slow-2g', '2g'].includes(navigatorConnection.effectiveType) ||\n        navigatorConnection.saveData);\n\nvar serialize = function (key) {\n    if (isFunction(key)) {\n        try {\n            key = key();\n        }\n        catch (err) {\n            // dependencies not ready\n            key = '';\n        }\n    }\n    var args = [].concat(key);\n    // If key is not falsy, or not an empty array, hash it.\n    key =\n        typeof key == 'string'\n            ? key\n            : (Array.isArray(key) ? key.length : key)\n                ? stableHash(key)\n                : '';\n    var infoKey = key ? '$swr$' + key : '';\n    return [key, args, infoKey];\n};\n\n// Global state used to deduplicate requests and store listeners\nvar SWRGlobalState = new WeakMap();\n\nvar FOCUS_EVENT = 0;\nvar RECONNECT_EVENT = 1;\nvar MUTATE_EVENT = 2;\n\nvar broadcastState = function (cache, key, data, error, isValidating, revalidate, broadcast) {\n    if (broadcast === void 0) { broadcast = true; }\n    var _a = SWRGlobalState.get(cache), EVENT_REVALIDATORS = _a[0], STATE_UPDATERS = _a[1], FETCH = _a[3];\n    var revalidators = EVENT_REVALIDATORS[key];\n    var updaters = STATE_UPDATERS[key];\n    // Cache was populated, update states of all hooks.\n    if (broadcast && updaters) {\n        for (var i = 0; i < updaters.length; ++i) {\n            updaters[i](data, error, isValidating);\n        }\n    }\n    // If we also need to revalidate, only do it for the first hook.\n    if (revalidate) {\n        // Invalidate the key by deleting the concurrent request markers so new\n        // requests will not be deduped.\n        delete FETCH[key];\n        if (revalidators && revalidators[0]) {\n            return revalidators[0](MUTATE_EVENT).then(function () {\n                return cache.get(key);\n            });\n        }\n    }\n    return cache.get(key);\n};\n\n// Global timestamp.\nvar __timestamp = 0;\nvar getTimestamp = function () { return ++__timestamp; };\n\nvar internalMutate = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return __awaiter(void 0, void 0, void 0, function () {\n        var cache, _key, _data, _opts, options, populateCache, revalidate, rollbackOnError, customOptimisticData, _a, key, keyInfo, _b, MUTATION, data, error, beforeMutationTs, hasCustomOptimisticData, rollbackData, optimisticData, res;\n        return __generator(this, function (_c) {\n            switch (_c.label) {\n                case 0:\n                    cache = args[0], _key = args[1], _data = args[2], _opts = args[3];\n                    options = typeof _opts === 'boolean' ? { revalidate: _opts } : _opts || {};\n                    populateCache = isUndefined(options.populateCache)\n                        ? true\n                        : options.populateCache;\n                    revalidate = options.revalidate !== false;\n                    rollbackOnError = options.rollbackOnError !== false;\n                    customOptimisticData = options.optimisticData;\n                    _a = serialize(_key), key = _a[0], keyInfo = _a[2];\n                    if (!key)\n                        return [2 /*return*/];\n                    _b = SWRGlobalState.get(cache), MUTATION = _b[2];\n                    // If there is no new data provided, revalidate the key with current state.\n                    if (args.length < 3) {\n                        // Revalidate and broadcast state.\n                        return [2 /*return*/, broadcastState(cache, key, cache.get(key), UNDEFINED, UNDEFINED, revalidate, true)];\n                    }\n                    data = _data;\n                    beforeMutationTs = getTimestamp();\n                    MUTATION[key] = [beforeMutationTs, 0];\n                    hasCustomOptimisticData = !isUndefined(customOptimisticData);\n                    rollbackData = cache.get(key);\n                    // Do optimistic data update.\n                    if (hasCustomOptimisticData) {\n                        optimisticData = isFunction(customOptimisticData)\n                            ? customOptimisticData(rollbackData)\n                            : customOptimisticData;\n                        cache.set(key, optimisticData);\n                        broadcastState(cache, key, optimisticData);\n                    }\n                    if (isFunction(data)) {\n                        // `data` is a function, call it passing current cache value.\n                        try {\n                            data = data(cache.get(key));\n                        }\n                        catch (err) {\n                            // If it throws an error synchronously, we shouldn't update the cache.\n                            error = err;\n                        }\n                    }\n                    if (!(data && isFunction(data.then))) return [3 /*break*/, 2];\n                    return [4 /*yield*/, data.catch(function (err) {\n                            error = err;\n                        })\n                        // Check if other mutations have occurred since we've started this mutation.\n                        // If there's a race we don't update cache or broadcast the change,\n                        // just return the data.\n                    ];\n                case 1:\n                    // This means that the mutation is async, we need to check timestamps to\n                    // avoid race conditions.\n                    data = _c.sent();\n                    // Check if other mutations have occurred since we've started this mutation.\n                    // If there's a race we don't update cache or broadcast the change,\n                    // just return the data.\n                    if (beforeMutationTs !== MUTATION[key][0]) {\n                        if (error)\n                            throw error;\n                        return [2 /*return*/, data];\n                    }\n                    else if (error && hasCustomOptimisticData && rollbackOnError) {\n                        // Rollback. Always populate the cache in this case but without\n                        // transforming the data.\n                        populateCache = true;\n                        data = rollbackData;\n                        cache.set(key, rollbackData);\n                    }\n                    _c.label = 2;\n                case 2:\n                    // If we should write back the cache after request.\n                    if (populateCache) {\n                        if (!error) {\n                            // Transform the result into data.\n                            if (isFunction(populateCache)) {\n                                data = populateCache(data, rollbackData);\n                            }\n                            // Only update cached data if there's no error. Data can be `undefined` here.\n                            cache.set(key, data);\n                        }\n                        // Always update or reset the error.\n                        cache.set(keyInfo, mergeObjects(cache.get(keyInfo), { error: error }));\n                    }\n                    // Reset the timestamp to mark the mutation has ended.\n                    MUTATION[key][1] = getTimestamp();\n                    return [4 /*yield*/, broadcastState(cache, key, data, error, UNDEFINED, revalidate, !!populateCache)\n                        // Throw error or return data\n                    ];\n                case 3:\n                    res = _c.sent();\n                    // Throw error or return data\n                    if (error)\n                        throw error;\n                    return [2 /*return*/, populateCache ? res : data];\n            }\n        });\n    });\n};\n\nvar revalidateAllKeys = function (revalidators, type) {\n    for (var key in revalidators) {\n        if (revalidators[key][0])\n            revalidators[key][0](type);\n    }\n};\nvar initCache = function (provider, options) {\n    // The global state for a specific provider will be used to deduplicate\n    // requests and store listeners. As well as a mutate function that bound to\n    // the cache.\n    // Provider's global state might be already initialized. Let's try to get the\n    // global state associated with the provider first.\n    if (!SWRGlobalState.has(provider)) {\n        var opts = mergeObjects(defaultConfigOptions, options);\n        // If there's no global state bound to the provider, create a new one with the\n        // new mutate function.\n        var EVENT_REVALIDATORS = {};\n        var mutate = internalMutate.bind(UNDEFINED, provider);\n        var unmount = noop;\n        // Update the state if it's new, or the provider has been extended.\n        SWRGlobalState.set(provider, [EVENT_REVALIDATORS, {}, {}, {}, mutate]);\n        // This is a new provider, we need to initialize it and setup DOM events\n        // listeners for `focus` and `reconnect` actions.\n        if (!IS_SERVER) {\n            // When listening to the native events for auto revalidations,\n            // we intentionally put a delay (setTimeout) here to make sure they are\n            // fired after immediate JavaScript executions, which can possibly be\n            // React's state updates.\n            // This avoids some unnecessary revalidations such as\n            // https://github.com/vercel/swr/issues/1680.\n            var releaseFocus_1 = opts.initFocus(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, FOCUS_EVENT)));\n            var releaseReconnect_1 = opts.initReconnect(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, RECONNECT_EVENT)));\n            unmount = function () {\n                releaseFocus_1 && releaseFocus_1();\n                releaseReconnect_1 && releaseReconnect_1();\n                // When un-mounting, we need to remove the cache provider from the state\n                // storage too because it's a side-effect. Otherwise when re-mounting we\n                // will not re-register those event listeners.\n                SWRGlobalState.delete(provider);\n            };\n        }\n        // We might want to inject an extra layer on top of `provider` in the future,\n        // such as key serialization, auto GC, etc.\n        // For now, it's just a `Map` interface without any modifications.\n        return [provider, mutate, unmount];\n    }\n    return [provider, SWRGlobalState.get(provider)[4]];\n};\n\n// error retry\nvar onErrorRetry = function (_, __, config, revalidate, opts) {\n    var maxRetryCount = config.errorRetryCount;\n    var currentRetryCount = opts.retryCount;\n    // Exponential backoff\n    var timeout = ~~((Math.random() + 0.5) *\n        (1 << (currentRetryCount < 8 ? currentRetryCount : 8))) * config.errorRetryInterval;\n    if (!isUndefined(maxRetryCount) && currentRetryCount > maxRetryCount) {\n        return;\n    }\n    setTimeout(revalidate, timeout, opts);\n};\n// Default cache provider\nvar _a = initCache(new Map()), cache = _a[0], mutate = _a[1];\n// Default config\nvar defaultConfig = mergeObjects({\n    // events\n    onLoadingSlow: noop,\n    onSuccess: noop,\n    onError: noop,\n    onErrorRetry: onErrorRetry,\n    onDiscarded: noop,\n    // switches\n    revalidateOnFocus: true,\n    revalidateOnReconnect: true,\n    revalidateIfStale: true,\n    shouldRetryOnError: true,\n    // timeouts\n    errorRetryInterval: slowConnection ? 10000 : 5000,\n    focusThrottleInterval: 5 * 1000,\n    dedupingInterval: 2 * 1000,\n    loadingTimeout: slowConnection ? 5000 : 3000,\n    // providers\n    compare: function (currentData, newData) {\n        return stableHash(currentData) == stableHash(newData);\n    },\n    isPaused: function () { return false; },\n    cache: cache,\n    mutate: mutate,\n    fallback: {}\n}, \n// use web preset by default\npreset);\n\nvar mergeConfigs = function (a, b) {\n    // Need to create a new object to avoid mutating the original here.\n    var v = mergeObjects(a, b);\n    // If two configs are provided, merge their `use` and `fallback` options.\n    if (b) {\n        var u1 = a.use, f1 = a.fallback;\n        var u2 = b.use, f2 = b.fallback;\n        if (u1 && u2) {\n            v.use = u1.concat(u2);\n        }\n        if (f1 && f2) {\n            v.fallback = mergeObjects(f1, f2);\n        }\n    }\n    return v;\n};\n\nvar SWRConfigContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({});\nvar SWRConfig$1 = function (props) {\n    var value = props.value;\n    // Extend parent context values and middleware.\n    var extendedConfig = mergeConfigs((0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SWRConfigContext), value);\n    // Should not use the inherited provider.\n    var provider = value && value.provider;\n    // Use a lazy initialized state to create the cache on first access.\n    var cacheContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(function () {\n        return provider\n            ? initCache(provider(extendedConfig.cache || cache), value)\n            : UNDEFINED;\n    })[0];\n    // Override the cache if a new provider is given.\n    if (cacheContext) {\n        extendedConfig.cache = cacheContext[0];\n        extendedConfig.mutate = cacheContext[1];\n    }\n    // Unsubscribe events.\n    useIsomorphicLayoutEffect(function () { return (cacheContext ? cacheContext[2] : UNDEFINED); }, []);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(SWRConfigContext.Provider, mergeObjects(props, {\n        value: extendedConfig\n    }));\n};\n\n/**\n * An implementation of state with dependency-tracking.\n */\nvar useStateWithDeps = function (state, unmountedRef) {\n    var rerender = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({})[1];\n    var stateRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(state);\n    // If a state property (data, error or isValidating) is accessed by the render\n    // function, we mark the property as a dependency so if it is updated again\n    // in the future, we trigger a rerender.\n    // This is also known as dependency-tracking.\n    var stateDependenciesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        data: false,\n        error: false,\n        isValidating: false\n    });\n    /**\n     * @param payload To change stateRef, pass the values explicitly to setState:\n     * @example\n     * ```js\n     * setState({\n     *   isValidating: false\n     *   data: newData // set data to newData\n     *   error: undefined // set error to undefined\n     * })\n     *\n     * setState({\n     *   isValidating: false\n     *   data: undefined // set data to undefined\n     *   error: err // set error to err\n     * })\n     * ```\n     */\n    var setState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function (payload) {\n        var shouldRerender = false;\n        var currentState = stateRef.current;\n        for (var _ in payload) {\n            var k = _;\n            // If the property has changed, update the state and mark rerender as\n            // needed.\n            if (currentState[k] !== payload[k]) {\n                currentState[k] = payload[k];\n                // If the property is accessed by the component, a rerender should be\n                // triggered.\n                if (stateDependenciesRef.current[k]) {\n                    shouldRerender = true;\n                }\n            }\n        }\n        if (shouldRerender && !unmountedRef.current) {\n            rerender({});\n        }\n    }, \n    // config.suspense isn't allowed to change during the lifecycle\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []);\n    // Always update the state reference.\n    useIsomorphicLayoutEffect(function () {\n        stateRef.current = state;\n    });\n    return [stateRef, stateDependenciesRef.current, setState];\n};\n\nvar normalize = function (args) {\n    return isFunction(args[1])\n        ? [args[0], args[1], args[2] || {}]\n        : [args[0], null, (args[1] === null ? args[2] : args[1]) || {}];\n};\n\nvar useSWRConfig = function () {\n    return mergeObjects(defaultConfig, (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SWRConfigContext));\n};\n\n// It's tricky to pass generic types as parameters, so we just directly override\n// the types here.\nvar withArgs = function (hook) {\n    return function useSWRArgs() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        // Get the default and inherited configuration.\n        var fallbackConfig = useSWRConfig();\n        // Normalize arguments.\n        var _a = normalize(args), key = _a[0], fn = _a[1], _config = _a[2];\n        // Merge configurations.\n        var config = mergeConfigs(fallbackConfig, _config);\n        // Apply middleware\n        var next = hook;\n        var use = config.use;\n        if (use) {\n            for (var i = use.length; i-- > 0;) {\n                next = use[i](next);\n            }\n        }\n        return next(key, fn || config.fetcher, config);\n    };\n};\n\n// Add a callback function to a list of keyed callback functions and return\n// the unsubscribe function.\nvar subscribeCallback = function (key, callbacks, callback) {\n    var keyedRevalidators = callbacks[key] || (callbacks[key] = []);\n    keyedRevalidators.push(callback);\n    return function () {\n        var index = keyedRevalidators.indexOf(callback);\n        if (index >= 0) {\n            // O(1): faster than splice\n            keyedRevalidators[index] = keyedRevalidators[keyedRevalidators.length - 1];\n            keyedRevalidators.pop();\n        }\n    };\n};\n\nvar WITH_DEDUPE = { dedupe: true };\nvar useSWRHandler = function (_key, fetcher, config) {\n    var cache = config.cache, compare = config.compare, fallbackData = config.fallbackData, suspense = config.suspense, revalidateOnMount = config.revalidateOnMount, refreshInterval = config.refreshInterval, refreshWhenHidden = config.refreshWhenHidden, refreshWhenOffline = config.refreshWhenOffline;\n    var _a = SWRGlobalState.get(cache), EVENT_REVALIDATORS = _a[0], STATE_UPDATERS = _a[1], MUTATION = _a[2], FETCH = _a[3];\n    // `key` is the identifier of the SWR `data` state, `keyInfo` holds extra\n    // states such as `error` and `isValidating` inside,\n    // all of them are derived from `_key`.\n    // `fnArgs` is an array of arguments parsed from the key, which will be passed\n    // to the fetcher.\n    var _b = serialize(_key), key = _b[0], fnArgs = _b[1], keyInfo = _b[2];\n    // If it's the initial render of this hook.\n    var initialMountedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    // If the hook is unmounted already. This will be used to prevent some effects\n    // to be called after unmounting.\n    var unmountedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    // Refs to keep the key and config.\n    var keyRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(key);\n    var fetcherRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(fetcher);\n    var configRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(config);\n    var getConfig = function () { return configRef.current; };\n    var isActive = function () { return getConfig().isVisible() && getConfig().isOnline(); };\n    var patchFetchInfo = function (info) {\n        return cache.set(keyInfo, mergeObjects(cache.get(keyInfo), info));\n    };\n    // Get the current state that SWR should return.\n    var cached = cache.get(key);\n    var fallback = isUndefined(fallbackData)\n        ? config.fallback[key]\n        : fallbackData;\n    var data = isUndefined(cached) ? fallback : cached;\n    var info = cache.get(keyInfo) || {};\n    var error = info.error;\n    var isInitialMount = !initialMountedRef.current;\n    // - Suspense mode and there's stale data for the initial render.\n    // - Not suspense mode and there is no fallback data and `revalidateIfStale` is enabled.\n    // - `revalidateIfStale` is enabled but `data` is not defined.\n    var shouldRevalidate = function () {\n        // If `revalidateOnMount` is set, we take the value directly.\n        if (isInitialMount && !isUndefined(revalidateOnMount))\n            return revalidateOnMount;\n        // If it's paused, we skip revalidation.\n        if (getConfig().isPaused())\n            return false;\n        // Under suspense mode, it will always fetch on render if there is no\n        // stale data so no need to revalidate immediately on mount again.\n        // If data exists, only revalidate if `revalidateIfStale` is true.\n        if (suspense)\n            return isUndefined(data) ? false : config.revalidateIfStale;\n        // If there is no stale data, we need to revalidate on mount;\n        // If `revalidateIfStale` is set to true, we will always revalidate.\n        return isUndefined(data) || config.revalidateIfStale;\n    };\n    // Resolve the current validating state.\n    var resolveValidating = function () {\n        if (!key || !fetcher)\n            return false;\n        if (info.isValidating)\n            return true;\n        // If it's not mounted yet and it should revalidate on mount, revalidate.\n        return isInitialMount && shouldRevalidate();\n    };\n    var isValidating = resolveValidating();\n    var _c = useStateWithDeps({\n        data: data,\n        error: error,\n        isValidating: isValidating\n    }, unmountedRef), stateRef = _c[0], stateDependencies = _c[1], setState = _c[2];\n    // The revalidation function is a carefully crafted wrapper of the original\n    // `fetcher`, to correctly handle the many edge cases.\n    var revalidate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function (revalidateOpts) { return __awaiter(void 0, void 0, void 0, function () {\n        var currentFetcher, newData, startAt, loading, opts, shouldStartNewRequest, isCurrentKeyMounted, cleanupState, newState, finishRequestAndUpdateState, mutationInfo, err_1;\n        var _a;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    currentFetcher = fetcherRef.current;\n                    if (!key ||\n                        !currentFetcher ||\n                        unmountedRef.current ||\n                        getConfig().isPaused()) {\n                        return [2 /*return*/, false];\n                    }\n                    loading = true;\n                    opts = revalidateOpts || {};\n                    shouldStartNewRequest = !FETCH[key] || !opts.dedupe;\n                    isCurrentKeyMounted = function () {\n                        return !unmountedRef.current &&\n                            key === keyRef.current &&\n                            initialMountedRef.current;\n                    };\n                    cleanupState = function () {\n                        // Check if it's still the same request before deleting.\n                        var requestInfo = FETCH[key];\n                        if (requestInfo && requestInfo[1] === startAt) {\n                            delete FETCH[key];\n                        }\n                    };\n                    newState = { isValidating: false };\n                    finishRequestAndUpdateState = function () {\n                        patchFetchInfo({ isValidating: false });\n                        // We can only set state if it's safe (still mounted with the same key).\n                        if (isCurrentKeyMounted()) {\n                            setState(newState);\n                        }\n                    };\n                    // Start fetching. Change the `isValidating` state, update the cache.\n                    patchFetchInfo({\n                        isValidating: true\n                    });\n                    setState({ isValidating: true });\n                    _b.label = 1;\n                case 1:\n                    _b.trys.push([1, 3, , 4]);\n                    if (shouldStartNewRequest) {\n                        // Tell all other hooks to change the `isValidating` state.\n                        broadcastState(cache, key, stateRef.current.data, stateRef.current.error, true);\n                        // If no cache being rendered currently (it shows a blank page),\n                        // we trigger the loading slow event.\n                        if (config.loadingTimeout && !cache.get(key)) {\n                            setTimeout(function () {\n                                if (loading && isCurrentKeyMounted()) {\n                                    getConfig().onLoadingSlow(key, config);\n                                }\n                            }, config.loadingTimeout);\n                        }\n                        // Start the request and save the timestamp.\n                        FETCH[key] = [currentFetcher.apply(void 0, fnArgs), getTimestamp()];\n                    }\n                    _a = FETCH[key], newData = _a[0], startAt = _a[1];\n                    return [4 /*yield*/, newData];\n                case 2:\n                    newData = _b.sent();\n                    if (shouldStartNewRequest) {\n                        // If the request isn't interrupted, clean it up after the\n                        // deduplication interval.\n                        setTimeout(cleanupState, config.dedupingInterval);\n                    }\n                    // If there're other ongoing request(s), started after the current one,\n                    // we need to ignore the current one to avoid possible race conditions:\n                    //   req1------------------>res1        (current one)\n                    //        req2---------------->res2\n                    // the request that fired later will always be kept.\n                    // The timestamp maybe be `undefined` or a number\n                    if (!FETCH[key] || FETCH[key][1] !== startAt) {\n                        if (shouldStartNewRequest) {\n                            if (isCurrentKeyMounted()) {\n                                getConfig().onDiscarded(key);\n                            }\n                        }\n                        return [2 /*return*/, false];\n                    }\n                    // Clear error.\n                    patchFetchInfo({\n                        error: UNDEFINED\n                    });\n                    newState.error = UNDEFINED;\n                    mutationInfo = MUTATION[key];\n                    if (!isUndefined(mutationInfo) &&\n                        // case 1\n                        (startAt <= mutationInfo[0] ||\n                            // case 2\n                            startAt <= mutationInfo[1] ||\n                            // case 3\n                            mutationInfo[1] === 0)) {\n                        finishRequestAndUpdateState();\n                        if (shouldStartNewRequest) {\n                            if (isCurrentKeyMounted()) {\n                                getConfig().onDiscarded(key);\n                            }\n                        }\n                        return [2 /*return*/, false];\n                    }\n                    // Deep compare with latest state to avoid extra re-renders.\n                    // For local state, compare and assign.\n                    if (!compare(stateRef.current.data, newData)) {\n                        newState.data = newData;\n                    }\n                    else {\n                        // data and newData are deeply equal\n                        // it should be safe to broadcast the stale data\n                        newState.data = stateRef.current.data;\n                        // At the end of this function, `brocastState` invokes the `onStateUpdate` function,\n                        // which takes care of avoiding the re-render\n                    }\n                    // For global state, it's possible that the key has changed.\n                    // https://github.com/vercel/swr/pull/1058\n                    if (!compare(cache.get(key), newData)) {\n                        cache.set(key, newData);\n                    }\n                    // Trigger the successful callback if it's the original request.\n                    if (shouldStartNewRequest) {\n                        if (isCurrentKeyMounted()) {\n                            getConfig().onSuccess(newData, key, config);\n                        }\n                    }\n                    return [3 /*break*/, 4];\n                case 3:\n                    err_1 = _b.sent();\n                    cleanupState();\n                    // Not paused, we continue handling the error. Otherwise discard it.\n                    if (!getConfig().isPaused()) {\n                        // Get a new error, don't use deep comparison for errors.\n                        patchFetchInfo({ error: err_1 });\n                        newState.error = err_1;\n                        // Error event and retry logic. Only for the actual request, not\n                        // deduped ones.\n                        if (shouldStartNewRequest && isCurrentKeyMounted()) {\n                            getConfig().onError(err_1, key, config);\n                            if ((typeof config.shouldRetryOnError === 'boolean' &&\n                                config.shouldRetryOnError) ||\n                                (isFunction(config.shouldRetryOnError) &&\n                                    config.shouldRetryOnError(err_1))) {\n                                // When retrying, dedupe is always enabled\n                                if (isActive()) {\n                                    // If it's active, stop. It will auto revalidate when refocusing\n                                    // or reconnecting.\n                                    getConfig().onErrorRetry(err_1, key, config, revalidate, {\n                                        retryCount: (opts.retryCount || 0) + 1,\n                                        dedupe: true\n                                    });\n                                }\n                            }\n                        }\n                    }\n                    return [3 /*break*/, 4];\n                case 4:\n                    // Mark loading as stopped.\n                    loading = false;\n                    // Update the current hook's state.\n                    finishRequestAndUpdateState();\n                    // Here is the source of the request, need to tell all other hooks to\n                    // update their states.\n                    if (isCurrentKeyMounted() && shouldStartNewRequest) {\n                        broadcastState(cache, key, newState.data, newState.error, false);\n                    }\n                    return [2 /*return*/, true];\n            }\n        });\n    }); }, \n    // `setState` is immutable, and `eventsCallback`, `fnArgs`, `keyInfo`,\n    // and `keyValidating` are depending on `key`, so we can exclude them from\n    // the deps array.\n    //\n    // FIXME:\n    // `fn` and `config` might be changed during the lifecycle,\n    // but they might be changed every render like this.\n    // `useSWR('key', () => fetch('/api/'), { suspense: true })`\n    // So we omit the values from the deps array\n    // even though it might cause unexpected behaviors.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [key]);\n    // Similar to the global mutate, but bound to the current cache and key.\n    // `cache` isn't allowed to change during the lifecycle.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    var boundMutate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    // By using `bind` we don't need to modify the size of the rest arguments.\n    // Due to https://github.com/microsoft/TypeScript/issues/37181, we have to\n    // cast it to any for now.\n    internalMutate.bind(UNDEFINED, cache, function () { return keyRef.current; }), \n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []);\n    // Always update fetcher and config refs.\n    useIsomorphicLayoutEffect(function () {\n        fetcherRef.current = fetcher;\n        configRef.current = config;\n    });\n    // After mounted or key changed.\n    useIsomorphicLayoutEffect(function () {\n        if (!key)\n            return;\n        var keyChanged = key !== keyRef.current;\n        var softRevalidate = revalidate.bind(UNDEFINED, WITH_DEDUPE);\n        // Expose state updater to global event listeners. So we can update hook's\n        // internal state from the outside.\n        var onStateUpdate = function (updatedData, updatedError, updatedIsValidating) {\n            setState(mergeObjects({\n                error: updatedError,\n                isValidating: updatedIsValidating\n            }, \n            // Since `setState` only shallowly compares states, we do a deep\n            // comparison here.\n            compare(stateRef.current.data, updatedData)\n                ? UNDEFINED\n                : {\n                    data: updatedData\n                }));\n        };\n        // Expose revalidators to global event listeners. So we can trigger\n        // revalidation from the outside.\n        var nextFocusRevalidatedAt = 0;\n        var onRevalidate = function (type) {\n            if (type == FOCUS_EVENT) {\n                var now = Date.now();\n                if (getConfig().revalidateOnFocus &&\n                    now > nextFocusRevalidatedAt &&\n                    isActive()) {\n                    nextFocusRevalidatedAt = now + getConfig().focusThrottleInterval;\n                    softRevalidate();\n                }\n            }\n            else if (type == RECONNECT_EVENT) {\n                if (getConfig().revalidateOnReconnect && isActive()) {\n                    softRevalidate();\n                }\n            }\n            else if (type == MUTATE_EVENT) {\n                return revalidate();\n            }\n            return;\n        };\n        var unsubUpdate = subscribeCallback(key, STATE_UPDATERS, onStateUpdate);\n        var unsubEvents = subscribeCallback(key, EVENT_REVALIDATORS, onRevalidate);\n        // Mark the component as mounted and update corresponding refs.\n        unmountedRef.current = false;\n        keyRef.current = key;\n        initialMountedRef.current = true;\n        // When `key` updates, reset the state to the initial value\n        // and trigger a rerender if necessary.\n        if (keyChanged) {\n            setState({\n                data: data,\n                error: error,\n                isValidating: isValidating\n            });\n        }\n        // Trigger a revalidation.\n        if (shouldRevalidate()) {\n            if (isUndefined(data) || IS_SERVER) {\n                // Revalidate immediately.\n                softRevalidate();\n            }\n            else {\n                // Delay the revalidate if we have data to return so we won't block\n                // rendering.\n                rAF(softRevalidate);\n            }\n        }\n        return function () {\n            // Mark it as unmounted.\n            unmountedRef.current = true;\n            unsubUpdate();\n            unsubEvents();\n        };\n    }, [key, revalidate]);\n    // Polling\n    useIsomorphicLayoutEffect(function () {\n        var timer;\n        function next() {\n            // Use the passed interval\n            // ...or invoke the function with the updated data to get the interval\n            var interval = isFunction(refreshInterval)\n                ? refreshInterval(data)\n                : refreshInterval;\n            // We only start next interval if `refreshInterval` is not 0, and:\n            // - `force` is true, which is the start of polling\n            // - or `timer` is not 0, which means the effect wasn't canceled\n            if (interval && timer !== -1) {\n                timer = setTimeout(execute, interval);\n            }\n        }\n        function execute() {\n            // Check if it's OK to execute:\n            // Only revalidate when the page is visible, online and not errored.\n            if (!stateRef.current.error &&\n                (refreshWhenHidden || getConfig().isVisible()) &&\n                (refreshWhenOffline || getConfig().isOnline())) {\n                revalidate(WITH_DEDUPE).then(next);\n            }\n            else {\n                // Schedule next interval to check again.\n                next();\n            }\n        }\n        next();\n        return function () {\n            if (timer) {\n                clearTimeout(timer);\n                timer = -1;\n            }\n        };\n    }, [refreshInterval, refreshWhenHidden, refreshWhenOffline, revalidate]);\n    // Display debug info in React DevTools.\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(data);\n    // In Suspense mode, we can't return the empty `data` state.\n    // If there is `error`, the `error` needs to be thrown to the error boundary.\n    // If there is no `error`, the `revalidation` promise needs to be thrown to\n    // the suspense boundary.\n    if (suspense && isUndefined(data) && key) {\n        // Always update fetcher and config refs even with the Suspense mode.\n        fetcherRef.current = fetcher;\n        configRef.current = config;\n        unmountedRef.current = false;\n        throw isUndefined(error) ? revalidate(WITH_DEDUPE) : error;\n    }\n    return {\n        mutate: boundMutate,\n        get data() {\n            stateDependencies.data = true;\n            return data;\n        },\n        get error() {\n            stateDependencies.error = true;\n            return error;\n        },\n        get isValidating() {\n            stateDependencies.isValidating = true;\n            return isValidating;\n        }\n    };\n};\nvar SWRConfig = OBJECT.defineProperty(SWRConfig$1, 'default', {\n    value: defaultConfig\n});\nvar unstable_serialize = function (key) { return serialize(key)[0]; };\nvar useSWR = withArgs(useSWRHandler);\n\n// useSWR\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zd3IvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQTJJOztBQUUzSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNkJBQTZCLDBCQUEwQixjQUFjLHFCQUFxQjtBQUN4RyxpQkFBaUIsb0RBQW9ELHFFQUFxRSxjQUFjO0FBQ3hKLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLG1DQUFtQyxTQUFTO0FBQzVDLG1DQUFtQyxXQUFXLFVBQVU7QUFDeEQsMENBQTBDLGNBQWM7QUFDeEQ7QUFDQSw4R0FBOEcsT0FBTztBQUNySCxpRkFBaUYsaUJBQWlCO0FBQ2xHLHlEQUF5RCxnQkFBZ0IsUUFBUTtBQUNqRiwrQ0FBK0MsZ0JBQWdCLGdCQUFnQjtBQUMvRTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsVUFBVSxZQUFZLGFBQWEsU0FBUyxVQUFVO0FBQ3RELG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsZ0NBQWdDO0FBQ2hDLHFDQUFxQyx1QkFBdUI7QUFDNUQ7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QixnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsb0JBQW9CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDRDQUFTLEdBQUcsa0RBQWU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELG9CQUFvQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSxjQUFjO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELElBQUksSUFBSTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw0QkFBNEIsZUFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsb0RBQWEsR0FBRztBQUN2QztBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsaURBQVU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLCtDQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsc0RBQXNEO0FBQ2xHLFdBQVcsb0RBQWE7QUFDeEI7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsK0NBQVEsR0FBRztBQUM5QixtQkFBbUIsNkNBQU07QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsNkNBQU07QUFDckM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsbUJBQW1CLGtEQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsc0VBQXNFO0FBQ3RFOztBQUVBO0FBQ0EsdUNBQXVDLGlEQUFVO0FBQ2pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxRQUFRO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw2Q0FBTTtBQUNsQztBQUNBO0FBQ0EsdUJBQXVCLDZDQUFNO0FBQzdCO0FBQ0EsaUJBQWlCLDZDQUFNO0FBQ3ZCLHFCQUFxQiw2Q0FBTTtBQUMzQixvQkFBb0IsNkNBQU07QUFDMUIsa0NBQWtDO0FBQ2xDLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHFCQUFxQixrREFBVyw2QkFBNkI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EseUNBQXlDLHFCQUFxQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLCtCQUErQixvQkFBb0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsY0FBYztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGdCQUFnQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrREFBVztBQUNqQztBQUNBO0FBQ0E7QUFDQSx3REFBd0Qsd0JBQXdCO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUksb0RBQWE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsMENBQTBDO0FBQzFDOztBQUVBOztBQUVrRiIsInNvdXJjZXMiOlsiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvV29uZGVyVml0ZS1mcm9udGVuZC9ub2RlX21vZHVsZXMvc3dyL2Rpc3QvaW5kZXgubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUVmZmVjdCwgdXNlTGF5b3V0RWZmZWN0LCBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VTdGF0ZSwgY3JlYXRlRWxlbWVudCwgdXNlUmVmLCB1c2VDYWxsYmFjaywgdXNlRGVidWdWYWx1ZSB9IGZyb20gJ3JlYWN0JztcblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XG5cbnZhciBub29wID0gZnVuY3Rpb24gKCkgeyB9O1xuLy8gVXNpbmcgbm9vcCgpIGFzIHRoZSB1bmRlZmluZWQgdmFsdWUgYXMgdW5kZWZpbmVkIGNhbiBwb3NzaWJseSBiZSByZXBsYWNlZFxuLy8gYnkgc29tZXRoaW5nIGVsc2UuICBQcmV0dGllciBpZ25vcmUgYW5kIGV4dHJhIHBhcmVudGhlc2VzIGFyZSBuZWNlc3NhcnkgaGVyZVxuLy8gdG8gZW5zdXJlIHRoYXQgdHNjIGRvZXNuJ3QgcmVtb3ZlIHRoZSBfX05PSU5MSU5FX18gY29tbWVudC5cbi8vIHByZXR0aWVyLWlnbm9yZVxudmFyIFVOREVGSU5FRCA9ICggLyojX19OT0lOTElORV9fKi9ub29wKCkpO1xudmFyIE9CSkVDVCA9IE9iamVjdDtcbnZhciBpc1VuZGVmaW5lZCA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiB2ID09PSBVTkRFRklORUQ7IH07XG52YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiB0eXBlb2YgdiA9PSAnZnVuY3Rpb24nOyB9O1xudmFyIG1lcmdlT2JqZWN0cyA9IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBPQkpFQ1QuYXNzaWduKHt9LCBhLCBiKTsgfTtcbnZhciBTVFJfVU5ERUZJTkVEID0gJ3VuZGVmaW5lZCc7XG4vLyBOT1RFOiBVc2UgZnVuY3Rpb24gdG8gZ3VhcmFudGVlIGl0J3MgcmUtZXZhbHVhdGVkIGJldHdlZW4ganNkb20gYW5kIG5vZGUgcnVudGltZSBmb3IgdGVzdHMuXG52YXIgaGFzV2luZG93ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPSBTVFJfVU5ERUZJTkVEOyB9O1xudmFyIGhhc0RvY3VtZW50ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZW9mIGRvY3VtZW50ICE9IFNUUl9VTkRFRklORUQ7IH07XG52YXIgaGFzUmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBoYXNXaW5kb3coKSAmJiB0eXBlb2Ygd2luZG93WydyZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXSAhPSBTVFJfVU5ERUZJTkVEO1xufTtcblxuLy8gdXNlIFdlYWtNYXAgdG8gc3RvcmUgdGhlIG9iamVjdC0+a2V5IG1hcHBpbmdcbi8vIHNvIHRoZSBvYmplY3RzIGNhbiBiZSBnYXJiYWdlIGNvbGxlY3RlZC5cbi8vIFdlYWtNYXAgdXNlcyBhIGhhc2h0YWJsZSB1bmRlciB0aGUgaG9vZCwgc28gdGhlIGxvb2t1cFxuLy8gY29tcGxleGl0eSBpcyBhbG1vc3QgTygxKS5cbnZhciB0YWJsZSA9IG5ldyBXZWFrTWFwKCk7XG4vLyBjb3VudGVyIG9mIHRoZSBrZXlcbnZhciBjb3VudGVyID0gMDtcbi8vIEEgc3RhYmxlIGhhc2ggaW1wbGVtZW50YXRpb24gdGhhdCBzdXBwb3J0czpcbi8vIC0gRmFzdCBhbmQgZW5zdXJlcyB1bmlxdWUgaGFzaCBwcm9wZXJ0aWVzXG4vLyAtIEhhbmRsZXMgdW5zZXJpYWxpemFibGUgdmFsdWVzXG4vLyAtIEhhbmRsZXMgb2JqZWN0IGtleSBvcmRlcmluZ1xuLy8gLSBHZW5lcmF0ZXMgc2hvcnQgcmVzdWx0c1xuLy9cbi8vIFRoaXMgaXMgbm90IGEgc2VyaWFsaXphdGlvbiBmdW5jdGlvbiwgYW5kIHRoZSByZXN1bHQgaXMgbm90IGd1YXJhbnRlZWQgdG8gYmVcbi8vIHBhcnNpYmxlLlxudmFyIHN0YWJsZUhhc2ggPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgYXJnO1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IGFyZyAmJiBhcmcuY29uc3RydWN0b3I7XG4gICAgdmFyIGlzRGF0ZSA9IGNvbnN0cnVjdG9yID09IERhdGU7XG4gICAgdmFyIHJlc3VsdDtcbiAgICB2YXIgaW5kZXg7XG4gICAgaWYgKE9CSkVDVChhcmcpID09PSBhcmcgJiYgIWlzRGF0ZSAmJiBjb25zdHJ1Y3RvciAhPSBSZWdFeHApIHtcbiAgICAgICAgLy8gT2JqZWN0L2Z1bmN0aW9uLCBub3QgbnVsbC9kYXRlL3JlZ2V4cC4gVXNlIFdlYWtNYXAgdG8gc3RvcmUgdGhlIGlkIGZpcnN0LlxuICAgICAgICAvLyBJZiBpdCdzIGFscmVhZHkgaGFzaGVkLCBkaXJlY3RseSByZXR1cm4gdGhlIHJlc3VsdC5cbiAgICAgICAgcmVzdWx0ID0gdGFibGUuZ2V0KGFyZyk7XG4gICAgICAgIGlmIChyZXN1bHQpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAvLyBTdG9yZSB0aGUgaGFzaCBmaXJzdCBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlIGRldGVjdGlvbiBiZWZvcmUgZW50ZXJpbmcgdGhlXG4gICAgICAgIC8vIHJlY3Vyc2l2ZSBgc3RhYmxlSGFzaGAgY2FsbHMuXG4gICAgICAgIC8vIEZvciBvdGhlciBvYmplY3RzIGxpa2Ugc2V0IGFuZCBtYXAsIHdlIHVzZSB0aGlzIGlkIGRpcmVjdGx5IGFzIHRoZSBoYXNoLlxuICAgICAgICByZXN1bHQgPSArK2NvdW50ZXIgKyAnfic7XG4gICAgICAgIHRhYmxlLnNldChhcmcsIHJlc3VsdCk7XG4gICAgICAgIGlmIChjb25zdHJ1Y3RvciA9PSBBcnJheSkge1xuICAgICAgICAgICAgLy8gQXJyYXkuXG4gICAgICAgICAgICByZXN1bHQgPSAnQCc7XG4gICAgICAgICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBhcmcubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHN0YWJsZUhhc2goYXJnW2luZGV4XSkgKyAnLCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YWJsZS5zZXQoYXJnLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25zdHJ1Y3RvciA9PSBPQkpFQ1QpIHtcbiAgICAgICAgICAgIC8vIE9iamVjdCwgc29ydCBrZXlzLlxuICAgICAgICAgICAgcmVzdWx0ID0gJyMnO1xuICAgICAgICAgICAgdmFyIGtleXMgPSBPQkpFQ1Qua2V5cyhhcmcpLnNvcnQoKTtcbiAgICAgICAgICAgIHdoaWxlICghaXNVbmRlZmluZWQoKGluZGV4ID0ga2V5cy5wb3AoKSkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChhcmdbaW5kZXhdKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gaW5kZXggKyAnOicgKyBzdGFibGVIYXNoKGFyZ1tpbmRleF0pICsgJywnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhYmxlLnNldChhcmcsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IGlzRGF0ZVxuICAgICAgICAgICAgPyBhcmcudG9KU09OKClcbiAgICAgICAgICAgIDogdHlwZSA9PSAnc3ltYm9sJ1xuICAgICAgICAgICAgICAgID8gYXJnLnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgICA6IHR5cGUgPT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgPyBKU09OLnN0cmluZ2lmeShhcmcpXG4gICAgICAgICAgICAgICAgICAgIDogJycgKyBhcmc7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIER1ZSB0byBidWcgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9Njc4MDc1LFxuICogaXQncyBub3QgcmVsaWFibGUgdG8gZGV0ZWN0IGlmIHRoZSBicm93c2VyIGlzIGN1cnJlbnRseSBvbmxpbmUgb3Igb2ZmbGluZVxuICogYmFzZWQgb24gYG5hdmlnYXRvci5vbkxpbmVgLlxuICogQXMgYSB3b3JrIGFyb3VuZCwgd2UgYWx3YXlzIGFzc3VtZSBpdCdzIG9ubGluZSBvbiBmaXJzdCBsb2FkLCBhbmQgY2hhbmdlXG4gKiB0aGUgc3RhdHVzIHVwb24gYG9ubGluZWAgb3IgYG9mZmxpbmVgIGV2ZW50cy5cbiAqL1xudmFyIG9ubGluZSA9IHRydWU7XG52YXIgaXNPbmxpbmUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBvbmxpbmU7IH07XG52YXIgaGFzV2luID0gaGFzV2luZG93KCk7XG52YXIgaGFzRG9jID0gaGFzRG9jdW1lbnQoKTtcbi8vIEZvciBub2RlIGFuZCBSZWFjdCBOYXRpdmUsIGBhZGQvcmVtb3ZlRXZlbnRMaXN0ZW5lcmAgZG9lc24ndCBleGlzdCBvbiB3aW5kb3cuXG52YXIgb25XaW5kb3dFdmVudCA9IGhhc1dpbiAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lclxuICAgID8gd2luZG93LmFkZEV2ZW50TGlzdGVuZXIuYmluZCh3aW5kb3cpXG4gICAgOiBub29wO1xudmFyIG9uRG9jdW1lbnRFdmVudCA9IGhhc0RvYyA/IGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIuYmluZChkb2N1bWVudCkgOiBub29wO1xudmFyIG9mZldpbmRvd0V2ZW50ID0gaGFzV2luICYmIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyXG4gICAgPyB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lci5iaW5kKHdpbmRvdylcbiAgICA6IG5vb3A7XG52YXIgb2ZmRG9jdW1lbnRFdmVudCA9IGhhc0RvY1xuICAgID8gZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lci5iaW5kKGRvY3VtZW50KVxuICAgIDogbm9vcDtcbnZhciBpc1Zpc2libGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZpc2liaWxpdHlTdGF0ZSA9IGhhc0RvYyAmJiBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGU7XG4gICAgcmV0dXJuIGlzVW5kZWZpbmVkKHZpc2liaWxpdHlTdGF0ZSkgfHwgdmlzaWJpbGl0eVN0YXRlICE9PSAnaGlkZGVuJztcbn07XG52YXIgaW5pdEZvY3VzID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgLy8gZm9jdXMgcmV2YWxpZGF0ZVxuICAgIG9uRG9jdW1lbnRFdmVudCgndmlzaWJpbGl0eWNoYW5nZScsIGNhbGxiYWNrKTtcbiAgICBvbldpbmRvd0V2ZW50KCdmb2N1cycsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBvZmZEb2N1bWVudEV2ZW50KCd2aXNpYmlsaXR5Y2hhbmdlJywgY2FsbGJhY2spO1xuICAgICAgICBvZmZXaW5kb3dFdmVudCgnZm9jdXMnLCBjYWxsYmFjayk7XG4gICAgfTtcbn07XG52YXIgaW5pdFJlY29ubmVjdCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIC8vIHJldmFsaWRhdGUgb24gcmVjb25uZWN0ZWRcbiAgICB2YXIgb25PbmxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9ubGluZSA9IHRydWU7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfTtcbiAgICAvLyBub3RoaW5nIHRvIHJldmFsaWRhdGUsIGp1c3QgdXBkYXRlIHRoZSBzdGF0dXNcbiAgICB2YXIgb25PZmZsaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBvbmxpbmUgPSBmYWxzZTtcbiAgICB9O1xuICAgIG9uV2luZG93RXZlbnQoJ29ubGluZScsIG9uT25saW5lKTtcbiAgICBvbldpbmRvd0V2ZW50KCdvZmZsaW5lJywgb25PZmZsaW5lKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBvZmZXaW5kb3dFdmVudCgnb25saW5lJywgb25PbmxpbmUpO1xuICAgICAgICBvZmZXaW5kb3dFdmVudCgnb2ZmbGluZScsIG9uT2ZmbGluZSk7XG4gICAgfTtcbn07XG52YXIgcHJlc2V0ID0ge1xuICAgIGlzT25saW5lOiBpc09ubGluZSxcbiAgICBpc1Zpc2libGU6IGlzVmlzaWJsZVxufTtcbnZhciBkZWZhdWx0Q29uZmlnT3B0aW9ucyA9IHtcbiAgICBpbml0Rm9jdXM6IGluaXRGb2N1cyxcbiAgICBpbml0UmVjb25uZWN0OiBpbml0UmVjb25uZWN0XG59O1xuXG52YXIgSVNfU0VSVkVSID0gIWhhc1dpbmRvdygpIHx8ICdEZW5vJyBpbiB3aW5kb3c7XG4vLyBQb2x5ZmlsbCByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbnZhciByQUYgPSBmdW5jdGlvbiAoZikge1xuICAgIHJldHVybiBoYXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKSA/IHdpbmRvd1sncmVxdWVzdEFuaW1hdGlvbkZyYW1lJ10oZikgOiBzZXRUaW1lb3V0KGYsIDEpO1xufTtcbi8vIFJlYWN0IGN1cnJlbnRseSB0aHJvd3MgYSB3YXJuaW5nIHdoZW4gdXNpbmcgdXNlTGF5b3V0RWZmZWN0IG9uIHRoZSBzZXJ2ZXIuXG4vLyBUbyBnZXQgYXJvdW5kIGl0LCB3ZSBjYW4gY29uZGl0aW9uYWxseSB1c2VFZmZlY3Qgb24gdGhlIHNlcnZlciAobm8tb3ApIGFuZFxuLy8gdXNlTGF5b3V0RWZmZWN0IGluIHRoZSBicm93c2VyLlxudmFyIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSBJU19TRVJWRVIgPyB1c2VFZmZlY3QgOiB1c2VMYXlvdXRFZmZlY3Q7XG4vLyBUaGlzIGFzc2lnbm1lbnQgaXMgdG8gZXh0ZW5kIHRoZSBOYXZpZ2F0b3IgdHlwZSB0byB1c2UgZWZmZWN0aXZlVHlwZS5cbnZhciBuYXZpZ2F0b3JDb25uZWN0aW9uID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICBuYXZpZ2F0b3IuY29ubmVjdGlvbjtcbi8vIEFkanVzdCB0aGUgY29uZmlnIGJhc2VkIG9uIHNsb3cgY29ubmVjdGlvbiBzdGF0dXMgKDw9IDcwS2JwcykuXG52YXIgc2xvd0Nvbm5lY3Rpb24gPSAhSVNfU0VSVkVSICYmXG4gICAgbmF2aWdhdG9yQ29ubmVjdGlvbiAmJlxuICAgIChbJ3Nsb3ctMmcnLCAnMmcnXS5pbmNsdWRlcyhuYXZpZ2F0b3JDb25uZWN0aW9uLmVmZmVjdGl2ZVR5cGUpIHx8XG4gICAgICAgIG5hdmlnYXRvckNvbm5lY3Rpb24uc2F2ZURhdGEpO1xuXG52YXIgc2VyaWFsaXplID0gZnVuY3Rpb24gKGtleSkge1xuICAgIGlmIChpc0Z1bmN0aW9uKGtleSkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGtleSA9IGtleSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIC8vIGRlcGVuZGVuY2llcyBub3QgcmVhZHlcbiAgICAgICAgICAgIGtleSA9ICcnO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBhcmdzID0gW10uY29uY2F0KGtleSk7XG4gICAgLy8gSWYga2V5IGlzIG5vdCBmYWxzeSwgb3Igbm90IGFuIGVtcHR5IGFycmF5LCBoYXNoIGl0LlxuICAgIGtleSA9XG4gICAgICAgIHR5cGVvZiBrZXkgPT0gJ3N0cmluZydcbiAgICAgICAgICAgID8ga2V5XG4gICAgICAgICAgICA6IChBcnJheS5pc0FycmF5KGtleSkgPyBrZXkubGVuZ3RoIDoga2V5KVxuICAgICAgICAgICAgICAgID8gc3RhYmxlSGFzaChrZXkpXG4gICAgICAgICAgICAgICAgOiAnJztcbiAgICB2YXIgaW5mb0tleSA9IGtleSA/ICckc3dyJCcgKyBrZXkgOiAnJztcbiAgICByZXR1cm4gW2tleSwgYXJncywgaW5mb0tleV07XG59O1xuXG4vLyBHbG9iYWwgc3RhdGUgdXNlZCB0byBkZWR1cGxpY2F0ZSByZXF1ZXN0cyBhbmQgc3RvcmUgbGlzdGVuZXJzXG52YXIgU1dSR2xvYmFsU3RhdGUgPSBuZXcgV2Vha01hcCgpO1xuXG52YXIgRk9DVVNfRVZFTlQgPSAwO1xudmFyIFJFQ09OTkVDVF9FVkVOVCA9IDE7XG52YXIgTVVUQVRFX0VWRU5UID0gMjtcblxudmFyIGJyb2FkY2FzdFN0YXRlID0gZnVuY3Rpb24gKGNhY2hlLCBrZXksIGRhdGEsIGVycm9yLCBpc1ZhbGlkYXRpbmcsIHJldmFsaWRhdGUsIGJyb2FkY2FzdCkge1xuICAgIGlmIChicm9hZGNhc3QgPT09IHZvaWQgMCkgeyBicm9hZGNhc3QgPSB0cnVlOyB9XG4gICAgdmFyIF9hID0gU1dSR2xvYmFsU3RhdGUuZ2V0KGNhY2hlKSwgRVZFTlRfUkVWQUxJREFUT1JTID0gX2FbMF0sIFNUQVRFX1VQREFURVJTID0gX2FbMV0sIEZFVENIID0gX2FbM107XG4gICAgdmFyIHJldmFsaWRhdG9ycyA9IEVWRU5UX1JFVkFMSURBVE9SU1trZXldO1xuICAgIHZhciB1cGRhdGVycyA9IFNUQVRFX1VQREFURVJTW2tleV07XG4gICAgLy8gQ2FjaGUgd2FzIHBvcHVsYXRlZCwgdXBkYXRlIHN0YXRlcyBvZiBhbGwgaG9va3MuXG4gICAgaWYgKGJyb2FkY2FzdCAmJiB1cGRhdGVycykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVwZGF0ZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB1cGRhdGVyc1tpXShkYXRhLCBlcnJvciwgaXNWYWxpZGF0aW5nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJZiB3ZSBhbHNvIG5lZWQgdG8gcmV2YWxpZGF0ZSwgb25seSBkbyBpdCBmb3IgdGhlIGZpcnN0IGhvb2suXG4gICAgaWYgKHJldmFsaWRhdGUpIHtcbiAgICAgICAgLy8gSW52YWxpZGF0ZSB0aGUga2V5IGJ5IGRlbGV0aW5nIHRoZSBjb25jdXJyZW50IHJlcXVlc3QgbWFya2VycyBzbyBuZXdcbiAgICAgICAgLy8gcmVxdWVzdHMgd2lsbCBub3QgYmUgZGVkdXBlZC5cbiAgICAgICAgZGVsZXRlIEZFVENIW2tleV07XG4gICAgICAgIGlmIChyZXZhbGlkYXRvcnMgJiYgcmV2YWxpZGF0b3JzWzBdKSB7XG4gICAgICAgICAgICByZXR1cm4gcmV2YWxpZGF0b3JzWzBdKE1VVEFURV9FVkVOVCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xufTtcblxuLy8gR2xvYmFsIHRpbWVzdGFtcC5cbnZhciBfX3RpbWVzdGFtcCA9IDA7XG52YXIgZ2V0VGltZXN0YW1wID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKytfX3RpbWVzdGFtcDsgfTtcblxudmFyIGludGVybmFsTXV0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNhY2hlLCBfa2V5LCBfZGF0YSwgX29wdHMsIG9wdGlvbnMsIHBvcHVsYXRlQ2FjaGUsIHJldmFsaWRhdGUsIHJvbGxiYWNrT25FcnJvciwgY3VzdG9tT3B0aW1pc3RpY0RhdGEsIF9hLCBrZXksIGtleUluZm8sIF9iLCBNVVRBVElPTiwgZGF0YSwgZXJyb3IsIGJlZm9yZU11dGF0aW9uVHMsIGhhc0N1c3RvbU9wdGltaXN0aWNEYXRhLCByb2xsYmFja0RhdGEsIG9wdGltaXN0aWNEYXRhLCByZXM7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2MubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlID0gYXJnc1swXSwgX2tleSA9IGFyZ3NbMV0sIF9kYXRhID0gYXJnc1syXSwgX29wdHMgPSBhcmdzWzNdO1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gdHlwZW9mIF9vcHRzID09PSAnYm9vbGVhbicgPyB7IHJldmFsaWRhdGU6IF9vcHRzIH0gOiBfb3B0cyB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgcG9wdWxhdGVDYWNoZSA9IGlzVW5kZWZpbmVkKG9wdGlvbnMucG9wdWxhdGVDYWNoZSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBvcHRpb25zLnBvcHVsYXRlQ2FjaGU7XG4gICAgICAgICAgICAgICAgICAgIHJldmFsaWRhdGUgPSBvcHRpb25zLnJldmFsaWRhdGUgIT09IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByb2xsYmFja09uRXJyb3IgPSBvcHRpb25zLnJvbGxiYWNrT25FcnJvciAhPT0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbU9wdGltaXN0aWNEYXRhID0gb3B0aW9ucy5vcHRpbWlzdGljRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgX2EgPSBzZXJpYWxpemUoX2tleSksIGtleSA9IF9hWzBdLCBrZXlJbmZvID0gX2FbMl07XG4gICAgICAgICAgICAgICAgICAgIGlmICgha2V5KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICBfYiA9IFNXUkdsb2JhbFN0YXRlLmdldChjYWNoZSksIE1VVEFUSU9OID0gX2JbMl07XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIG5ldyBkYXRhIHByb3ZpZGVkLCByZXZhbGlkYXRlIHRoZSBrZXkgd2l0aCBjdXJyZW50IHN0YXRlLlxuICAgICAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPCAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXZhbGlkYXRlIGFuZCBicm9hZGNhc3Qgc3RhdGUuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgYnJvYWRjYXN0U3RhdGUoY2FjaGUsIGtleSwgY2FjaGUuZ2V0KGtleSksIFVOREVGSU5FRCwgVU5ERUZJTkVELCByZXZhbGlkYXRlLCB0cnVlKV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IF9kYXRhO1xuICAgICAgICAgICAgICAgICAgICBiZWZvcmVNdXRhdGlvblRzID0gZ2V0VGltZXN0YW1wKCk7XG4gICAgICAgICAgICAgICAgICAgIE1VVEFUSU9OW2tleV0gPSBbYmVmb3JlTXV0YXRpb25UcywgMF07XG4gICAgICAgICAgICAgICAgICAgIGhhc0N1c3RvbU9wdGltaXN0aWNEYXRhID0gIWlzVW5kZWZpbmVkKGN1c3RvbU9wdGltaXN0aWNEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgcm9sbGJhY2tEYXRhID0gY2FjaGUuZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIERvIG9wdGltaXN0aWMgZGF0YSB1cGRhdGUuXG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNDdXN0b21PcHRpbWlzdGljRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW1pc3RpY0RhdGEgPSBpc0Z1bmN0aW9uKGN1c3RvbU9wdGltaXN0aWNEYXRhKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gY3VzdG9tT3B0aW1pc3RpY0RhdGEocm9sbGJhY2tEYXRhKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY3VzdG9tT3B0aW1pc3RpY0RhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5zZXQoa2V5LCBvcHRpbWlzdGljRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicm9hZGNhc3RTdGF0ZShjYWNoZSwga2V5LCBvcHRpbWlzdGljRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGBkYXRhYCBpcyBhIGZ1bmN0aW9uLCBjYWxsIGl0IHBhc3NpbmcgY3VycmVudCBjYWNoZSB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEoY2FjaGUuZ2V0KGtleSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGl0IHRocm93cyBhbiBlcnJvciBzeW5jaHJvbm91c2x5LCB3ZSBzaG91bGRuJ3QgdXBkYXRlIHRoZSBjYWNoZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIShkYXRhICYmIGlzRnVuY3Rpb24oZGF0YS50aGVuKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBkYXRhLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBvdGhlciBtdXRhdGlvbnMgaGF2ZSBvY2N1cnJlZCBzaW5jZSB3ZSd2ZSBzdGFydGVkIHRoaXMgbXV0YXRpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSdzIGEgcmFjZSB3ZSBkb24ndCB1cGRhdGUgY2FjaGUgb3IgYnJvYWRjYXN0IHRoZSBjaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBqdXN0IHJldHVybiB0aGUgZGF0YS5cbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgbWVhbnMgdGhhdCB0aGUgbXV0YXRpb24gaXMgYXN5bmMsIHdlIG5lZWQgdG8gY2hlY2sgdGltZXN0YW1wcyB0b1xuICAgICAgICAgICAgICAgICAgICAvLyBhdm9pZCByYWNlIGNvbmRpdGlvbnMuXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIG90aGVyIG11dGF0aW9ucyBoYXZlIG9jY3VycmVkIHNpbmNlIHdlJ3ZlIHN0YXJ0ZWQgdGhpcyBtdXRhdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBhIHJhY2Ugd2UgZG9uJ3QgdXBkYXRlIGNhY2hlIG9yIGJyb2FkY2FzdCB0aGUgY2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICAvLyBqdXN0IHJldHVybiB0aGUgZGF0YS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGJlZm9yZU11dGF0aW9uVHMgIT09IE1VVEFUSU9OW2tleV1bMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBkYXRhXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChlcnJvciAmJiBoYXNDdXN0b21PcHRpbWlzdGljRGF0YSAmJiByb2xsYmFja09uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJvbGxiYWNrLiBBbHdheXMgcG9wdWxhdGUgdGhlIGNhY2hlIGluIHRoaXMgY2FzZSBidXQgd2l0aG91dFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJhbnNmb3JtaW5nIHRoZSBkYXRhLlxuICAgICAgICAgICAgICAgICAgICAgICAgcG9wdWxhdGVDYWNoZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gcm9sbGJhY2tEYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUuc2V0KGtleSwgcm9sbGJhY2tEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDI7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBzaG91bGQgd3JpdGUgYmFjayB0aGUgY2FjaGUgYWZ0ZXIgcmVxdWVzdC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcHVsYXRlQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmFuc2Zvcm0gdGhlIHJlc3VsdCBpbnRvIGRhdGEuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24ocG9wdWxhdGVDYWNoZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHBvcHVsYXRlQ2FjaGUoZGF0YSwgcm9sbGJhY2tEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSB1cGRhdGUgY2FjaGVkIGRhdGEgaWYgdGhlcmUncyBubyBlcnJvci4gRGF0YSBjYW4gYmUgYHVuZGVmaW5lZGAgaGVyZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5zZXQoa2V5LCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsd2F5cyB1cGRhdGUgb3IgcmVzZXQgdGhlIGVycm9yLlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUuc2V0KGtleUluZm8sIG1lcmdlT2JqZWN0cyhjYWNoZS5nZXQoa2V5SW5mbyksIHsgZXJyb3I6IGVycm9yIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCB0aGUgdGltZXN0YW1wIHRvIG1hcmsgdGhlIG11dGF0aW9uIGhhcyBlbmRlZC5cbiAgICAgICAgICAgICAgICAgICAgTVVUQVRJT05ba2V5XVsxXSA9IGdldFRpbWVzdGFtcCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBicm9hZGNhc3RTdGF0ZShjYWNoZSwga2V5LCBkYXRhLCBlcnJvciwgVU5ERUZJTkVELCByZXZhbGlkYXRlLCAhIXBvcHVsYXRlQ2FjaGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaHJvdyBlcnJvciBvciByZXR1cm4gZGF0YVxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBUaHJvdyBlcnJvciBvciByZXR1cm4gZGF0YVxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHBvcHVsYXRlQ2FjaGUgPyByZXMgOiBkYXRhXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuXG52YXIgcmV2YWxpZGF0ZUFsbEtleXMgPSBmdW5jdGlvbiAocmV2YWxpZGF0b3JzLCB0eXBlKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHJldmFsaWRhdG9ycykge1xuICAgICAgICBpZiAocmV2YWxpZGF0b3JzW2tleV1bMF0pXG4gICAgICAgICAgICByZXZhbGlkYXRvcnNba2V5XVswXSh0eXBlKTtcbiAgICB9XG59O1xudmFyIGluaXRDYWNoZSA9IGZ1bmN0aW9uIChwcm92aWRlciwgb3B0aW9ucykge1xuICAgIC8vIFRoZSBnbG9iYWwgc3RhdGUgZm9yIGEgc3BlY2lmaWMgcHJvdmlkZXIgd2lsbCBiZSB1c2VkIHRvIGRlZHVwbGljYXRlXG4gICAgLy8gcmVxdWVzdHMgYW5kIHN0b3JlIGxpc3RlbmVycy4gQXMgd2VsbCBhcyBhIG11dGF0ZSBmdW5jdGlvbiB0aGF0IGJvdW5kIHRvXG4gICAgLy8gdGhlIGNhY2hlLlxuICAgIC8vIFByb3ZpZGVyJ3MgZ2xvYmFsIHN0YXRlIG1pZ2h0IGJlIGFscmVhZHkgaW5pdGlhbGl6ZWQuIExldCdzIHRyeSB0byBnZXQgdGhlXG4gICAgLy8gZ2xvYmFsIHN0YXRlIGFzc29jaWF0ZWQgd2l0aCB0aGUgcHJvdmlkZXIgZmlyc3QuXG4gICAgaWYgKCFTV1JHbG9iYWxTdGF0ZS5oYXMocHJvdmlkZXIpKSB7XG4gICAgICAgIHZhciBvcHRzID0gbWVyZ2VPYmplY3RzKGRlZmF1bHRDb25maWdPcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgLy8gSWYgdGhlcmUncyBubyBnbG9iYWwgc3RhdGUgYm91bmQgdG8gdGhlIHByb3ZpZGVyLCBjcmVhdGUgYSBuZXcgb25lIHdpdGggdGhlXG4gICAgICAgIC8vIG5ldyBtdXRhdGUgZnVuY3Rpb24uXG4gICAgICAgIHZhciBFVkVOVF9SRVZBTElEQVRPUlMgPSB7fTtcbiAgICAgICAgdmFyIG11dGF0ZSA9IGludGVybmFsTXV0YXRlLmJpbmQoVU5ERUZJTkVELCBwcm92aWRlcik7XG4gICAgICAgIHZhciB1bm1vdW50ID0gbm9vcDtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBzdGF0ZSBpZiBpdCdzIG5ldywgb3IgdGhlIHByb3ZpZGVyIGhhcyBiZWVuIGV4dGVuZGVkLlxuICAgICAgICBTV1JHbG9iYWxTdGF0ZS5zZXQocHJvdmlkZXIsIFtFVkVOVF9SRVZBTElEQVRPUlMsIHt9LCB7fSwge30sIG11dGF0ZV0pO1xuICAgICAgICAvLyBUaGlzIGlzIGEgbmV3IHByb3ZpZGVyLCB3ZSBuZWVkIHRvIGluaXRpYWxpemUgaXQgYW5kIHNldHVwIERPTSBldmVudHNcbiAgICAgICAgLy8gbGlzdGVuZXJzIGZvciBgZm9jdXNgIGFuZCBgcmVjb25uZWN0YCBhY3Rpb25zLlxuICAgICAgICBpZiAoIUlTX1NFUlZFUikge1xuICAgICAgICAgICAgLy8gV2hlbiBsaXN0ZW5pbmcgdG8gdGhlIG5hdGl2ZSBldmVudHMgZm9yIGF1dG8gcmV2YWxpZGF0aW9ucyxcbiAgICAgICAgICAgIC8vIHdlIGludGVudGlvbmFsbHkgcHV0IGEgZGVsYXkgKHNldFRpbWVvdXQpIGhlcmUgdG8gbWFrZSBzdXJlIHRoZXkgYXJlXG4gICAgICAgICAgICAvLyBmaXJlZCBhZnRlciBpbW1lZGlhdGUgSmF2YVNjcmlwdCBleGVjdXRpb25zLCB3aGljaCBjYW4gcG9zc2libHkgYmVcbiAgICAgICAgICAgIC8vIFJlYWN0J3Mgc3RhdGUgdXBkYXRlcy5cbiAgICAgICAgICAgIC8vIFRoaXMgYXZvaWRzIHNvbWUgdW5uZWNlc3NhcnkgcmV2YWxpZGF0aW9ucyBzdWNoIGFzXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL3N3ci9pc3N1ZXMvMTY4MC5cbiAgICAgICAgICAgIHZhciByZWxlYXNlRm9jdXNfMSA9IG9wdHMuaW5pdEZvY3VzKHNldFRpbWVvdXQuYmluZChVTkRFRklORUQsIHJldmFsaWRhdGVBbGxLZXlzLmJpbmQoVU5ERUZJTkVELCBFVkVOVF9SRVZBTElEQVRPUlMsIEZPQ1VTX0VWRU5UKSkpO1xuICAgICAgICAgICAgdmFyIHJlbGVhc2VSZWNvbm5lY3RfMSA9IG9wdHMuaW5pdFJlY29ubmVjdChzZXRUaW1lb3V0LmJpbmQoVU5ERUZJTkVELCByZXZhbGlkYXRlQWxsS2V5cy5iaW5kKFVOREVGSU5FRCwgRVZFTlRfUkVWQUxJREFUT1JTLCBSRUNPTk5FQ1RfRVZFTlQpKSk7XG4gICAgICAgICAgICB1bm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlbGVhc2VGb2N1c18xICYmIHJlbGVhc2VGb2N1c18xKCk7XG4gICAgICAgICAgICAgICAgcmVsZWFzZVJlY29ubmVjdF8xICYmIHJlbGVhc2VSZWNvbm5lY3RfMSgpO1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gdW4tbW91bnRpbmcsIHdlIG5lZWQgdG8gcmVtb3ZlIHRoZSBjYWNoZSBwcm92aWRlciBmcm9tIHRoZSBzdGF0ZVxuICAgICAgICAgICAgICAgIC8vIHN0b3JhZ2UgdG9vIGJlY2F1c2UgaXQncyBhIHNpZGUtZWZmZWN0LiBPdGhlcndpc2Ugd2hlbiByZS1tb3VudGluZyB3ZVxuICAgICAgICAgICAgICAgIC8vIHdpbGwgbm90IHJlLXJlZ2lzdGVyIHRob3NlIGV2ZW50IGxpc3RlbmVycy5cbiAgICAgICAgICAgICAgICBTV1JHbG9iYWxTdGF0ZS5kZWxldGUocHJvdmlkZXIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBtaWdodCB3YW50IHRvIGluamVjdCBhbiBleHRyYSBsYXllciBvbiB0b3Agb2YgYHByb3ZpZGVyYCBpbiB0aGUgZnV0dXJlLFxuICAgICAgICAvLyBzdWNoIGFzIGtleSBzZXJpYWxpemF0aW9uLCBhdXRvIEdDLCBldGMuXG4gICAgICAgIC8vIEZvciBub3csIGl0J3MganVzdCBhIGBNYXBgIGludGVyZmFjZSB3aXRob3V0IGFueSBtb2RpZmljYXRpb25zLlxuICAgICAgICByZXR1cm4gW3Byb3ZpZGVyLCBtdXRhdGUsIHVubW91bnRdO1xuICAgIH1cbiAgICByZXR1cm4gW3Byb3ZpZGVyLCBTV1JHbG9iYWxTdGF0ZS5nZXQocHJvdmlkZXIpWzRdXTtcbn07XG5cbi8vIGVycm9yIHJldHJ5XG52YXIgb25FcnJvclJldHJ5ID0gZnVuY3Rpb24gKF8sIF9fLCBjb25maWcsIHJldmFsaWRhdGUsIG9wdHMpIHtcbiAgICB2YXIgbWF4UmV0cnlDb3VudCA9IGNvbmZpZy5lcnJvclJldHJ5Q291bnQ7XG4gICAgdmFyIGN1cnJlbnRSZXRyeUNvdW50ID0gb3B0cy5yZXRyeUNvdW50O1xuICAgIC8vIEV4cG9uZW50aWFsIGJhY2tvZmZcbiAgICB2YXIgdGltZW91dCA9IH5+KChNYXRoLnJhbmRvbSgpICsgMC41KSAqXG4gICAgICAgICgxIDw8IChjdXJyZW50UmV0cnlDb3VudCA8IDggPyBjdXJyZW50UmV0cnlDb3VudCA6IDgpKSkgKiBjb25maWcuZXJyb3JSZXRyeUludGVydmFsO1xuICAgIGlmICghaXNVbmRlZmluZWQobWF4UmV0cnlDb3VudCkgJiYgY3VycmVudFJldHJ5Q291bnQgPiBtYXhSZXRyeUNvdW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2V0VGltZW91dChyZXZhbGlkYXRlLCB0aW1lb3V0LCBvcHRzKTtcbn07XG4vLyBEZWZhdWx0IGNhY2hlIHByb3ZpZGVyXG52YXIgX2EgPSBpbml0Q2FjaGUobmV3IE1hcCgpKSwgY2FjaGUgPSBfYVswXSwgbXV0YXRlID0gX2FbMV07XG4vLyBEZWZhdWx0IGNvbmZpZ1xudmFyIGRlZmF1bHRDb25maWcgPSBtZXJnZU9iamVjdHMoe1xuICAgIC8vIGV2ZW50c1xuICAgIG9uTG9hZGluZ1Nsb3c6IG5vb3AsXG4gICAgb25TdWNjZXNzOiBub29wLFxuICAgIG9uRXJyb3I6IG5vb3AsXG4gICAgb25FcnJvclJldHJ5OiBvbkVycm9yUmV0cnksXG4gICAgb25EaXNjYXJkZWQ6IG5vb3AsXG4gICAgLy8gc3dpdGNoZXNcbiAgICByZXZhbGlkYXRlT25Gb2N1czogdHJ1ZSxcbiAgICByZXZhbGlkYXRlT25SZWNvbm5lY3Q6IHRydWUsXG4gICAgcmV2YWxpZGF0ZUlmU3RhbGU6IHRydWUsXG4gICAgc2hvdWxkUmV0cnlPbkVycm9yOiB0cnVlLFxuICAgIC8vIHRpbWVvdXRzXG4gICAgZXJyb3JSZXRyeUludGVydmFsOiBzbG93Q29ubmVjdGlvbiA/IDEwMDAwIDogNTAwMCxcbiAgICBmb2N1c1Rocm90dGxlSW50ZXJ2YWw6IDUgKiAxMDAwLFxuICAgIGRlZHVwaW5nSW50ZXJ2YWw6IDIgKiAxMDAwLFxuICAgIGxvYWRpbmdUaW1lb3V0OiBzbG93Q29ubmVjdGlvbiA/IDUwMDAgOiAzMDAwLFxuICAgIC8vIHByb3ZpZGVyc1xuICAgIGNvbXBhcmU6IGZ1bmN0aW9uIChjdXJyZW50RGF0YSwgbmV3RGF0YSkge1xuICAgICAgICByZXR1cm4gc3RhYmxlSGFzaChjdXJyZW50RGF0YSkgPT0gc3RhYmxlSGFzaChuZXdEYXRhKTtcbiAgICB9LFxuICAgIGlzUGF1c2VkOiBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfSxcbiAgICBjYWNoZTogY2FjaGUsXG4gICAgbXV0YXRlOiBtdXRhdGUsXG4gICAgZmFsbGJhY2s6IHt9XG59LCBcbi8vIHVzZSB3ZWIgcHJlc2V0IGJ5IGRlZmF1bHRcbnByZXNldCk7XG5cbnZhciBtZXJnZUNvbmZpZ3MgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIC8vIE5lZWQgdG8gY3JlYXRlIGEgbmV3IG9iamVjdCB0byBhdm9pZCBtdXRhdGluZyB0aGUgb3JpZ2luYWwgaGVyZS5cbiAgICB2YXIgdiA9IG1lcmdlT2JqZWN0cyhhLCBiKTtcbiAgICAvLyBJZiB0d28gY29uZmlncyBhcmUgcHJvdmlkZWQsIG1lcmdlIHRoZWlyIGB1c2VgIGFuZCBgZmFsbGJhY2tgIG9wdGlvbnMuXG4gICAgaWYgKGIpIHtcbiAgICAgICAgdmFyIHUxID0gYS51c2UsIGYxID0gYS5mYWxsYmFjaztcbiAgICAgICAgdmFyIHUyID0gYi51c2UsIGYyID0gYi5mYWxsYmFjaztcbiAgICAgICAgaWYgKHUxICYmIHUyKSB7XG4gICAgICAgICAgICB2LnVzZSA9IHUxLmNvbmNhdCh1Mik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGYxICYmIGYyKSB7XG4gICAgICAgICAgICB2LmZhbGxiYWNrID0gbWVyZ2VPYmplY3RzKGYxLCBmMik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHY7XG59O1xuXG52YXIgU1dSQ29uZmlnQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoe30pO1xudmFyIFNXUkNvbmZpZyQxID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gICAgLy8gRXh0ZW5kIHBhcmVudCBjb250ZXh0IHZhbHVlcyBhbmQgbWlkZGxld2FyZS5cbiAgICB2YXIgZXh0ZW5kZWRDb25maWcgPSBtZXJnZUNvbmZpZ3ModXNlQ29udGV4dChTV1JDb25maWdDb250ZXh0KSwgdmFsdWUpO1xuICAgIC8vIFNob3VsZCBub3QgdXNlIHRoZSBpbmhlcml0ZWQgcHJvdmlkZXIuXG4gICAgdmFyIHByb3ZpZGVyID0gdmFsdWUgJiYgdmFsdWUucHJvdmlkZXI7XG4gICAgLy8gVXNlIGEgbGF6eSBpbml0aWFsaXplZCBzdGF0ZSB0byBjcmVhdGUgdGhlIGNhY2hlIG9uIGZpcnN0IGFjY2Vzcy5cbiAgICB2YXIgY2FjaGVDb250ZXh0ID0gdXNlU3RhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcHJvdmlkZXJcbiAgICAgICAgICAgID8gaW5pdENhY2hlKHByb3ZpZGVyKGV4dGVuZGVkQ29uZmlnLmNhY2hlIHx8IGNhY2hlKSwgdmFsdWUpXG4gICAgICAgICAgICA6IFVOREVGSU5FRDtcbiAgICB9KVswXTtcbiAgICAvLyBPdmVycmlkZSB0aGUgY2FjaGUgaWYgYSBuZXcgcHJvdmlkZXIgaXMgZ2l2ZW4uXG4gICAgaWYgKGNhY2hlQ29udGV4dCkge1xuICAgICAgICBleHRlbmRlZENvbmZpZy5jYWNoZSA9IGNhY2hlQ29udGV4dFswXTtcbiAgICAgICAgZXh0ZW5kZWRDb25maWcubXV0YXRlID0gY2FjaGVDb250ZXh0WzFdO1xuICAgIH1cbiAgICAvLyBVbnN1YnNjcmliZSBldmVudHMuXG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7IHJldHVybiAoY2FjaGVDb250ZXh0ID8gY2FjaGVDb250ZXh0WzJdIDogVU5ERUZJTkVEKTsgfSwgW10pO1xuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KFNXUkNvbmZpZ0NvbnRleHQuUHJvdmlkZXIsIG1lcmdlT2JqZWN0cyhwcm9wcywge1xuICAgICAgICB2YWx1ZTogZXh0ZW5kZWRDb25maWdcbiAgICB9KSk7XG59O1xuXG4vKipcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIHN0YXRlIHdpdGggZGVwZW5kZW5jeS10cmFja2luZy5cbiAqL1xudmFyIHVzZVN0YXRlV2l0aERlcHMgPSBmdW5jdGlvbiAoc3RhdGUsIHVubW91bnRlZFJlZikge1xuICAgIHZhciByZXJlbmRlciA9IHVzZVN0YXRlKHt9KVsxXTtcbiAgICB2YXIgc3RhdGVSZWYgPSB1c2VSZWYoc3RhdGUpO1xuICAgIC8vIElmIGEgc3RhdGUgcHJvcGVydHkgKGRhdGEsIGVycm9yIG9yIGlzVmFsaWRhdGluZykgaXMgYWNjZXNzZWQgYnkgdGhlIHJlbmRlclxuICAgIC8vIGZ1bmN0aW9uLCB3ZSBtYXJrIHRoZSBwcm9wZXJ0eSBhcyBhIGRlcGVuZGVuY3kgc28gaWYgaXQgaXMgdXBkYXRlZCBhZ2FpblxuICAgIC8vIGluIHRoZSBmdXR1cmUsIHdlIHRyaWdnZXIgYSByZXJlbmRlci5cbiAgICAvLyBUaGlzIGlzIGFsc28ga25vd24gYXMgZGVwZW5kZW5jeS10cmFja2luZy5cbiAgICB2YXIgc3RhdGVEZXBlbmRlbmNpZXNSZWYgPSB1c2VSZWYoe1xuICAgICAgICBkYXRhOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGZhbHNlLFxuICAgICAgICBpc1ZhbGlkYXRpbmc6IGZhbHNlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHBheWxvYWQgVG8gY2hhbmdlIHN0YXRlUmVmLCBwYXNzIHRoZSB2YWx1ZXMgZXhwbGljaXRseSB0byBzZXRTdGF0ZTpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogc2V0U3RhdGUoe1xuICAgICAqICAgaXNWYWxpZGF0aW5nOiBmYWxzZVxuICAgICAqICAgZGF0YTogbmV3RGF0YSAvLyBzZXQgZGF0YSB0byBuZXdEYXRhXG4gICAgICogICBlcnJvcjogdW5kZWZpbmVkIC8vIHNldCBlcnJvciB0byB1bmRlZmluZWRcbiAgICAgKiB9KVxuICAgICAqXG4gICAgICogc2V0U3RhdGUoe1xuICAgICAqICAgaXNWYWxpZGF0aW5nOiBmYWxzZVxuICAgICAqICAgZGF0YTogdW5kZWZpbmVkIC8vIHNldCBkYXRhIHRvIHVuZGVmaW5lZFxuICAgICAqICAgZXJyb3I6IGVyciAvLyBzZXQgZXJyb3IgdG8gZXJyXG4gICAgICogfSlcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICB2YXIgc2V0U3RhdGUgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgICB2YXIgc2hvdWxkUmVyZW5kZXIgPSBmYWxzZTtcbiAgICAgICAgdmFyIGN1cnJlbnRTdGF0ZSA9IHN0YXRlUmVmLmN1cnJlbnQ7XG4gICAgICAgIGZvciAodmFyIF8gaW4gcGF5bG9hZCkge1xuICAgICAgICAgICAgdmFyIGsgPSBfO1xuICAgICAgICAgICAgLy8gSWYgdGhlIHByb3BlcnR5IGhhcyBjaGFuZ2VkLCB1cGRhdGUgdGhlIHN0YXRlIGFuZCBtYXJrIHJlcmVuZGVyIGFzXG4gICAgICAgICAgICAvLyBuZWVkZWQuXG4gICAgICAgICAgICBpZiAoY3VycmVudFN0YXRlW2tdICE9PSBwYXlsb2FkW2tdKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFN0YXRlW2tdID0gcGF5bG9hZFtrXTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcHJvcGVydHkgaXMgYWNjZXNzZWQgYnkgdGhlIGNvbXBvbmVudCwgYSByZXJlbmRlciBzaG91bGQgYmVcbiAgICAgICAgICAgICAgICAvLyB0cmlnZ2VyZWQuXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlRGVwZW5kZW5jaWVzUmVmLmN1cnJlbnRba10pIHtcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkUmVyZW5kZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkUmVyZW5kZXIgJiYgIXVubW91bnRlZFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICByZXJlbmRlcih7fSk7XG4gICAgICAgIH1cbiAgICB9LCBcbiAgICAvLyBjb25maWcuc3VzcGVuc2UgaXNuJ3QgYWxsb3dlZCB0byBjaGFuZ2UgZHVyaW5nIHRoZSBsaWZlY3ljbGVcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgW10pO1xuICAgIC8vIEFsd2F5cyB1cGRhdGUgdGhlIHN0YXRlIHJlZmVyZW5jZS5cbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3RhdGVSZWYuY3VycmVudCA9IHN0YXRlO1xuICAgIH0pO1xuICAgIHJldHVybiBbc3RhdGVSZWYsIHN0YXRlRGVwZW5kZW5jaWVzUmVmLmN1cnJlbnQsIHNldFN0YXRlXTtcbn07XG5cbnZhciBub3JtYWxpemUgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHJldHVybiBpc0Z1bmN0aW9uKGFyZ3NbMV0pXG4gICAgICAgID8gW2FyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0gfHwge31dXG4gICAgICAgIDogW2FyZ3NbMF0sIG51bGwsIChhcmdzWzFdID09PSBudWxsID8gYXJnc1syXSA6IGFyZ3NbMV0pIHx8IHt9XTtcbn07XG5cbnZhciB1c2VTV1JDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG1lcmdlT2JqZWN0cyhkZWZhdWx0Q29uZmlnLCB1c2VDb250ZXh0KFNXUkNvbmZpZ0NvbnRleHQpKTtcbn07XG5cbi8vIEl0J3MgdHJpY2t5IHRvIHBhc3MgZ2VuZXJpYyB0eXBlcyBhcyBwYXJhbWV0ZXJzLCBzbyB3ZSBqdXN0IGRpcmVjdGx5IG92ZXJyaWRlXG4vLyB0aGUgdHlwZXMgaGVyZS5cbnZhciB3aXRoQXJncyA9IGZ1bmN0aW9uIChob29rKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVzZVNXUkFyZ3MoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IHRoZSBkZWZhdWx0IGFuZCBpbmhlcml0ZWQgY29uZmlndXJhdGlvbi5cbiAgICAgICAgdmFyIGZhbGxiYWNrQ29uZmlnID0gdXNlU1dSQ29uZmlnKCk7XG4gICAgICAgIC8vIE5vcm1hbGl6ZSBhcmd1bWVudHMuXG4gICAgICAgIHZhciBfYSA9IG5vcm1hbGl6ZShhcmdzKSwga2V5ID0gX2FbMF0sIGZuID0gX2FbMV0sIF9jb25maWcgPSBfYVsyXTtcbiAgICAgICAgLy8gTWVyZ2UgY29uZmlndXJhdGlvbnMuXG4gICAgICAgIHZhciBjb25maWcgPSBtZXJnZUNvbmZpZ3MoZmFsbGJhY2tDb25maWcsIF9jb25maWcpO1xuICAgICAgICAvLyBBcHBseSBtaWRkbGV3YXJlXG4gICAgICAgIHZhciBuZXh0ID0gaG9vaztcbiAgICAgICAgdmFyIHVzZSA9IGNvbmZpZy51c2U7XG4gICAgICAgIGlmICh1c2UpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSB1c2UubGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgICAgICAgICAgIG5leHQgPSB1c2VbaV0obmV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5leHQoa2V5LCBmbiB8fCBjb25maWcuZmV0Y2hlciwgY29uZmlnKTtcbiAgICB9O1xufTtcblxuLy8gQWRkIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYSBsaXN0IG9mIGtleWVkIGNhbGxiYWNrIGZ1bmN0aW9ucyBhbmQgcmV0dXJuXG4vLyB0aGUgdW5zdWJzY3JpYmUgZnVuY3Rpb24uXG52YXIgc3Vic2NyaWJlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoa2V5LCBjYWxsYmFja3MsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGtleWVkUmV2YWxpZGF0b3JzID0gY2FsbGJhY2tzW2tleV0gfHwgKGNhbGxiYWNrc1trZXldID0gW10pO1xuICAgIGtleWVkUmV2YWxpZGF0b3JzLnB1c2goY2FsbGJhY2spO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGtleWVkUmV2YWxpZGF0b3JzLmluZGV4T2YoY2FsbGJhY2spO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgLy8gTygxKTogZmFzdGVyIHRoYW4gc3BsaWNlXG4gICAgICAgICAgICBrZXllZFJldmFsaWRhdG9yc1tpbmRleF0gPSBrZXllZFJldmFsaWRhdG9yc1trZXllZFJldmFsaWRhdG9ycy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGtleWVkUmV2YWxpZGF0b3JzLnBvcCgpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cbnZhciBXSVRIX0RFRFVQRSA9IHsgZGVkdXBlOiB0cnVlIH07XG52YXIgdXNlU1dSSGFuZGxlciA9IGZ1bmN0aW9uIChfa2V5LCBmZXRjaGVyLCBjb25maWcpIHtcbiAgICB2YXIgY2FjaGUgPSBjb25maWcuY2FjaGUsIGNvbXBhcmUgPSBjb25maWcuY29tcGFyZSwgZmFsbGJhY2tEYXRhID0gY29uZmlnLmZhbGxiYWNrRGF0YSwgc3VzcGVuc2UgPSBjb25maWcuc3VzcGVuc2UsIHJldmFsaWRhdGVPbk1vdW50ID0gY29uZmlnLnJldmFsaWRhdGVPbk1vdW50LCByZWZyZXNoSW50ZXJ2YWwgPSBjb25maWcucmVmcmVzaEludGVydmFsLCByZWZyZXNoV2hlbkhpZGRlbiA9IGNvbmZpZy5yZWZyZXNoV2hlbkhpZGRlbiwgcmVmcmVzaFdoZW5PZmZsaW5lID0gY29uZmlnLnJlZnJlc2hXaGVuT2ZmbGluZTtcbiAgICB2YXIgX2EgPSBTV1JHbG9iYWxTdGF0ZS5nZXQoY2FjaGUpLCBFVkVOVF9SRVZBTElEQVRPUlMgPSBfYVswXSwgU1RBVEVfVVBEQVRFUlMgPSBfYVsxXSwgTVVUQVRJT04gPSBfYVsyXSwgRkVUQ0ggPSBfYVszXTtcbiAgICAvLyBga2V5YCBpcyB0aGUgaWRlbnRpZmllciBvZiB0aGUgU1dSIGBkYXRhYCBzdGF0ZSwgYGtleUluZm9gIGhvbGRzIGV4dHJhXG4gICAgLy8gc3RhdGVzIHN1Y2ggYXMgYGVycm9yYCBhbmQgYGlzVmFsaWRhdGluZ2AgaW5zaWRlLFxuICAgIC8vIGFsbCBvZiB0aGVtIGFyZSBkZXJpdmVkIGZyb20gYF9rZXlgLlxuICAgIC8vIGBmbkFyZ3NgIGlzIGFuIGFycmF5IG9mIGFyZ3VtZW50cyBwYXJzZWQgZnJvbSB0aGUga2V5LCB3aGljaCB3aWxsIGJlIHBhc3NlZFxuICAgIC8vIHRvIHRoZSBmZXRjaGVyLlxuICAgIHZhciBfYiA9IHNlcmlhbGl6ZShfa2V5KSwga2V5ID0gX2JbMF0sIGZuQXJncyA9IF9iWzFdLCBrZXlJbmZvID0gX2JbMl07XG4gICAgLy8gSWYgaXQncyB0aGUgaW5pdGlhbCByZW5kZXIgb2YgdGhpcyBob29rLlxuICAgIHZhciBpbml0aWFsTW91bnRlZFJlZiA9IHVzZVJlZihmYWxzZSk7XG4gICAgLy8gSWYgdGhlIGhvb2sgaXMgdW5tb3VudGVkIGFscmVhZHkuIFRoaXMgd2lsbCBiZSB1c2VkIHRvIHByZXZlbnQgc29tZSBlZmZlY3RzXG4gICAgLy8gdG8gYmUgY2FsbGVkIGFmdGVyIHVubW91bnRpbmcuXG4gICAgdmFyIHVubW91bnRlZFJlZiA9IHVzZVJlZihmYWxzZSk7XG4gICAgLy8gUmVmcyB0byBrZWVwIHRoZSBrZXkgYW5kIGNvbmZpZy5cbiAgICB2YXIga2V5UmVmID0gdXNlUmVmKGtleSk7XG4gICAgdmFyIGZldGNoZXJSZWYgPSB1c2VSZWYoZmV0Y2hlcik7XG4gICAgdmFyIGNvbmZpZ1JlZiA9IHVzZVJlZihjb25maWcpO1xuICAgIHZhciBnZXRDb25maWcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25maWdSZWYuY3VycmVudDsgfTtcbiAgICB2YXIgaXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBnZXRDb25maWcoKS5pc1Zpc2libGUoKSAmJiBnZXRDb25maWcoKS5pc09ubGluZSgpOyB9O1xuICAgIHZhciBwYXRjaEZldGNoSW5mbyA9IGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgICAgIHJldHVybiBjYWNoZS5zZXQoa2V5SW5mbywgbWVyZ2VPYmplY3RzKGNhY2hlLmdldChrZXlJbmZvKSwgaW5mbykpO1xuICAgIH07XG4gICAgLy8gR2V0IHRoZSBjdXJyZW50IHN0YXRlIHRoYXQgU1dSIHNob3VsZCByZXR1cm4uXG4gICAgdmFyIGNhY2hlZCA9IGNhY2hlLmdldChrZXkpO1xuICAgIHZhciBmYWxsYmFjayA9IGlzVW5kZWZpbmVkKGZhbGxiYWNrRGF0YSlcbiAgICAgICAgPyBjb25maWcuZmFsbGJhY2tba2V5XVxuICAgICAgICA6IGZhbGxiYWNrRGF0YTtcbiAgICB2YXIgZGF0YSA9IGlzVW5kZWZpbmVkKGNhY2hlZCkgPyBmYWxsYmFjayA6IGNhY2hlZDtcbiAgICB2YXIgaW5mbyA9IGNhY2hlLmdldChrZXlJbmZvKSB8fCB7fTtcbiAgICB2YXIgZXJyb3IgPSBpbmZvLmVycm9yO1xuICAgIHZhciBpc0luaXRpYWxNb3VudCA9ICFpbml0aWFsTW91bnRlZFJlZi5jdXJyZW50O1xuICAgIC8vIC0gU3VzcGVuc2UgbW9kZSBhbmQgdGhlcmUncyBzdGFsZSBkYXRhIGZvciB0aGUgaW5pdGlhbCByZW5kZXIuXG4gICAgLy8gLSBOb3Qgc3VzcGVuc2UgbW9kZSBhbmQgdGhlcmUgaXMgbm8gZmFsbGJhY2sgZGF0YSBhbmQgYHJldmFsaWRhdGVJZlN0YWxlYCBpcyBlbmFibGVkLlxuICAgIC8vIC0gYHJldmFsaWRhdGVJZlN0YWxlYCBpcyBlbmFibGVkIGJ1dCBgZGF0YWAgaXMgbm90IGRlZmluZWQuXG4gICAgdmFyIHNob3VsZFJldmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIElmIGByZXZhbGlkYXRlT25Nb3VudGAgaXMgc2V0LCB3ZSB0YWtlIHRoZSB2YWx1ZSBkaXJlY3RseS5cbiAgICAgICAgaWYgKGlzSW5pdGlhbE1vdW50ICYmICFpc1VuZGVmaW5lZChyZXZhbGlkYXRlT25Nb3VudCkpXG4gICAgICAgICAgICByZXR1cm4gcmV2YWxpZGF0ZU9uTW91bnQ7XG4gICAgICAgIC8vIElmIGl0J3MgcGF1c2VkLCB3ZSBza2lwIHJldmFsaWRhdGlvbi5cbiAgICAgICAgaWYgKGdldENvbmZpZygpLmlzUGF1c2VkKCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIFVuZGVyIHN1c3BlbnNlIG1vZGUsIGl0IHdpbGwgYWx3YXlzIGZldGNoIG9uIHJlbmRlciBpZiB0aGVyZSBpcyBub1xuICAgICAgICAvLyBzdGFsZSBkYXRhIHNvIG5vIG5lZWQgdG8gcmV2YWxpZGF0ZSBpbW1lZGlhdGVseSBvbiBtb3VudCBhZ2Fpbi5cbiAgICAgICAgLy8gSWYgZGF0YSBleGlzdHMsIG9ubHkgcmV2YWxpZGF0ZSBpZiBgcmV2YWxpZGF0ZUlmU3RhbGVgIGlzIHRydWUuXG4gICAgICAgIGlmIChzdXNwZW5zZSlcbiAgICAgICAgICAgIHJldHVybiBpc1VuZGVmaW5lZChkYXRhKSA/IGZhbHNlIDogY29uZmlnLnJldmFsaWRhdGVJZlN0YWxlO1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBzdGFsZSBkYXRhLCB3ZSBuZWVkIHRvIHJldmFsaWRhdGUgb24gbW91bnQ7XG4gICAgICAgIC8vIElmIGByZXZhbGlkYXRlSWZTdGFsZWAgaXMgc2V0IHRvIHRydWUsIHdlIHdpbGwgYWx3YXlzIHJldmFsaWRhdGUuXG4gICAgICAgIHJldHVybiBpc1VuZGVmaW5lZChkYXRhKSB8fCBjb25maWcucmV2YWxpZGF0ZUlmU3RhbGU7XG4gICAgfTtcbiAgICAvLyBSZXNvbHZlIHRoZSBjdXJyZW50IHZhbGlkYXRpbmcgc3RhdGUuXG4gICAgdmFyIHJlc29sdmVWYWxpZGF0aW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWtleSB8fCAhZmV0Y2hlcilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGluZm8uaXNWYWxpZGF0aW5nKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIElmIGl0J3Mgbm90IG1vdW50ZWQgeWV0IGFuZCBpdCBzaG91bGQgcmV2YWxpZGF0ZSBvbiBtb3VudCwgcmV2YWxpZGF0ZS5cbiAgICAgICAgcmV0dXJuIGlzSW5pdGlhbE1vdW50ICYmIHNob3VsZFJldmFsaWRhdGUoKTtcbiAgICB9O1xuICAgIHZhciBpc1ZhbGlkYXRpbmcgPSByZXNvbHZlVmFsaWRhdGluZygpO1xuICAgIHZhciBfYyA9IHVzZVN0YXRlV2l0aERlcHMoe1xuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgIGlzVmFsaWRhdGluZzogaXNWYWxpZGF0aW5nXG4gICAgfSwgdW5tb3VudGVkUmVmKSwgc3RhdGVSZWYgPSBfY1swXSwgc3RhdGVEZXBlbmRlbmNpZXMgPSBfY1sxXSwgc2V0U3RhdGUgPSBfY1syXTtcbiAgICAvLyBUaGUgcmV2YWxpZGF0aW9uIGZ1bmN0aW9uIGlzIGEgY2FyZWZ1bGx5IGNyYWZ0ZWQgd3JhcHBlciBvZiB0aGUgb3JpZ2luYWxcbiAgICAvLyBgZmV0Y2hlcmAsIHRvIGNvcnJlY3RseSBoYW5kbGUgdGhlIG1hbnkgZWRnZSBjYXNlcy5cbiAgICB2YXIgcmV2YWxpZGF0ZSA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChyZXZhbGlkYXRlT3B0cykgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRGZXRjaGVyLCBuZXdEYXRhLCBzdGFydEF0LCBsb2FkaW5nLCBvcHRzLCBzaG91bGRTdGFydE5ld1JlcXVlc3QsIGlzQ3VycmVudEtleU1vdW50ZWQsIGNsZWFudXBTdGF0ZSwgbmV3U3RhdGUsIGZpbmlzaFJlcXVlc3RBbmRVcGRhdGVTdGF0ZSwgbXV0YXRpb25JbmZvLCBlcnJfMTtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RmV0Y2hlciA9IGZldGNoZXJSZWYuY3VycmVudDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFrZXkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICFjdXJyZW50RmV0Y2hlciB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdW5tb3VudGVkUmVmLmN1cnJlbnQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldENvbmZpZygpLmlzUGF1c2VkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBmYWxzZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG9wdHMgPSByZXZhbGlkYXRlT3B0cyB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkU3RhcnROZXdSZXF1ZXN0ID0gIUZFVENIW2tleV0gfHwgIW9wdHMuZGVkdXBlO1xuICAgICAgICAgICAgICAgICAgICBpc0N1cnJlbnRLZXlNb3VudGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICF1bm1vdW50ZWRSZWYuY3VycmVudCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9PT0ga2V5UmVmLmN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsTW91bnRlZFJlZi5jdXJyZW50O1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjbGVhbnVwU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBpdCdzIHN0aWxsIHRoZSBzYW1lIHJlcXVlc3QgYmVmb3JlIGRlbGV0aW5nLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcXVlc3RJbmZvID0gRkVUQ0hba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0SW5mbyAmJiByZXF1ZXN0SW5mb1sxXSA9PT0gc3RhcnRBdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBGRVRDSFtrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IHsgaXNWYWxpZGF0aW5nOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgICAgICBmaW5pc2hSZXF1ZXN0QW5kVXBkYXRlU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRjaEZldGNoSW5mbyh7IGlzVmFsaWRhdGluZzogZmFsc2UgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBjYW4gb25seSBzZXQgc3RhdGUgaWYgaXQncyBzYWZlIChzdGlsbCBtb3VudGVkIHdpdGggdGhlIHNhbWUga2V5KS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0N1cnJlbnRLZXlNb3VudGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRTdGF0ZShuZXdTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIC8vIFN0YXJ0IGZldGNoaW5nLiBDaGFuZ2UgdGhlIGBpc1ZhbGlkYXRpbmdgIHN0YXRlLCB1cGRhdGUgdGhlIGNhY2hlLlxuICAgICAgICAgICAgICAgICAgICBwYXRjaEZldGNoSW5mbyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkYXRpbmc6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNldFN0YXRlKHsgaXNWYWxpZGF0aW5nOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBfYi50cnlzLnB1c2goWzEsIDMsICwgNF0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU3RhcnROZXdSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUZWxsIGFsbCBvdGhlciBob29rcyB0byBjaGFuZ2UgdGhlIGBpc1ZhbGlkYXRpbmdgIHN0YXRlLlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJvYWRjYXN0U3RhdGUoY2FjaGUsIGtleSwgc3RhdGVSZWYuY3VycmVudC5kYXRhLCBzdGF0ZVJlZi5jdXJyZW50LmVycm9yLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIG5vIGNhY2hlIGJlaW5nIHJlbmRlcmVkIGN1cnJlbnRseSAoaXQgc2hvd3MgYSBibGFuayBwYWdlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIHRyaWdnZXIgdGhlIGxvYWRpbmcgc2xvdyBldmVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maWcubG9hZGluZ1RpbWVvdXQgJiYgIWNhY2hlLmdldChrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2FkaW5nICYmIGlzQ3VycmVudEtleU1vdW50ZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q29uZmlnKCkub25Mb2FkaW5nU2xvdyhrZXksIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBjb25maWcubG9hZGluZ1RpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RhcnQgdGhlIHJlcXVlc3QgYW5kIHNhdmUgdGhlIHRpbWVzdGFtcC5cbiAgICAgICAgICAgICAgICAgICAgICAgIEZFVENIW2tleV0gPSBbY3VycmVudEZldGNoZXIuYXBwbHkodm9pZCAwLCBmbkFyZ3MpLCBnZXRUaW1lc3RhbXAoKV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX2EgPSBGRVRDSFtrZXldLCBuZXdEYXRhID0gX2FbMF0sIHN0YXJ0QXQgPSBfYVsxXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgbmV3RGF0YV07XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBuZXdEYXRhID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU3RhcnROZXdSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcmVxdWVzdCBpc24ndCBpbnRlcnJ1cHRlZCwgY2xlYW4gaXQgdXAgYWZ0ZXIgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkZWR1cGxpY2F0aW9uIGludGVydmFsLlxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChjbGVhbnVwU3RhdGUsIGNvbmZpZy5kZWR1cGluZ0ludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSdyZSBvdGhlciBvbmdvaW5nIHJlcXVlc3QocyksIHN0YXJ0ZWQgYWZ0ZXIgdGhlIGN1cnJlbnQgb25lLFxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGlnbm9yZSB0aGUgY3VycmVudCBvbmUgdG8gYXZvaWQgcG9zc2libGUgcmFjZSBjb25kaXRpb25zOlxuICAgICAgICAgICAgICAgICAgICAvLyAgIHJlcTEtLS0tLS0tLS0tLS0tLS0tLS0+cmVzMSAgICAgICAgKGN1cnJlbnQgb25lKVxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgcmVxMi0tLS0tLS0tLS0tLS0tLS0+cmVzMlxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcmVxdWVzdCB0aGF0IGZpcmVkIGxhdGVyIHdpbGwgYWx3YXlzIGJlIGtlcHQuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSB0aW1lc3RhbXAgbWF5YmUgYmUgYHVuZGVmaW5lZGAgb3IgYSBudW1iZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFGRVRDSFtrZXldIHx8IEZFVENIW2tleV1bMV0gIT09IHN0YXJ0QXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRTdGFydE5ld1JlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNDdXJyZW50S2V5TW91bnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldENvbmZpZygpLm9uRGlzY2FyZGVkKGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZhbHNlXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBDbGVhciBlcnJvci5cbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hGZXRjaEluZm8oe1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IFVOREVGSU5FRFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgbmV3U3RhdGUuZXJyb3IgPSBVTkRFRklORUQ7XG4gICAgICAgICAgICAgICAgICAgIG11dGF0aW9uSW5mbyA9IE1VVEFUSU9OW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQobXV0YXRpb25JbmZvKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAxXG4gICAgICAgICAgICAgICAgICAgICAgICAoc3RhcnRBdCA8PSBtdXRhdGlvbkluZm9bMF0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlIDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydEF0IDw9IG11dGF0aW9uSW5mb1sxXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgM1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0aW9uSW5mb1sxXSA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaFJlcXVlc3RBbmRVcGRhdGVTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZFN0YXJ0TmV3UmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0N1cnJlbnRLZXlNb3VudGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q29uZmlnKCkub25EaXNjYXJkZWQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZmFsc2VdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIERlZXAgY29tcGFyZSB3aXRoIGxhdGVzdCBzdGF0ZSB0byBhdm9pZCBleHRyYSByZS1yZW5kZXJzLlxuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgbG9jYWwgc3RhdGUsIGNvbXBhcmUgYW5kIGFzc2lnbi5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb21wYXJlKHN0YXRlUmVmLmN1cnJlbnQuZGF0YSwgbmV3RGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlLmRhdGEgPSBuZXdEYXRhO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGF0YSBhbmQgbmV3RGF0YSBhcmUgZGVlcGx5IGVxdWFsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCBzaG91bGQgYmUgc2FmZSB0byBicm9hZGNhc3QgdGhlIHN0YWxlIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlLmRhdGEgPSBzdGF0ZVJlZi5jdXJyZW50LmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBdCB0aGUgZW5kIG9mIHRoaXMgZnVuY3Rpb24sIGBicm9jYXN0U3RhdGVgIGludm9rZXMgdGhlIGBvblN0YXRlVXBkYXRlYCBmdW5jdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoaWNoIHRha2VzIGNhcmUgb2YgYXZvaWRpbmcgdGhlIHJlLXJlbmRlclxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBnbG9iYWwgc3RhdGUsIGl0J3MgcG9zc2libGUgdGhhdCB0aGUga2V5IGhhcyBjaGFuZ2VkLlxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL3N3ci9wdWxsLzEwNThcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb21wYXJlKGNhY2hlLmdldChrZXkpLCBuZXdEYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUuc2V0KGtleSwgbmV3RGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gVHJpZ2dlciB0aGUgc3VjY2Vzc2Z1bCBjYWxsYmFjayBpZiBpdCdzIHRoZSBvcmlnaW5hbCByZXF1ZXN0LlxuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU3RhcnROZXdSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNDdXJyZW50S2V5TW91bnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q29uZmlnKCkub25TdWNjZXNzKG5ld0RhdGEsIGtleSwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIGVycl8xID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBjbGVhbnVwU3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90IHBhdXNlZCwgd2UgY29udGludWUgaGFuZGxpbmcgdGhlIGVycm9yLiBPdGhlcndpc2UgZGlzY2FyZCBpdC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFnZXRDb25maWcoKS5pc1BhdXNlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgYSBuZXcgZXJyb3IsIGRvbid0IHVzZSBkZWVwIGNvbXBhcmlzb24gZm9yIGVycm9ycy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoRmV0Y2hJbmZvKHsgZXJyb3I6IGVycl8xIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3U3RhdGUuZXJyb3IgPSBlcnJfMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVycm9yIGV2ZW50IGFuZCByZXRyeSBsb2dpYy4gT25seSBmb3IgdGhlIGFjdHVhbCByZXF1ZXN0LCBub3RcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlZHVwZWQgb25lcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRTdGFydE5ld1JlcXVlc3QgJiYgaXNDdXJyZW50S2V5TW91bnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q29uZmlnKCkub25FcnJvcihlcnJfMSwga2V5LCBjb25maWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodHlwZW9mIGNvbmZpZy5zaG91bGRSZXRyeU9uRXJyb3IgPT09ICdib29sZWFuJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuc2hvdWxkUmV0cnlPbkVycm9yKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaXNGdW5jdGlvbihjb25maWcuc2hvdWxkUmV0cnlPbkVycm9yKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLnNob3VsZFJldHJ5T25FcnJvcihlcnJfMSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gcmV0cnlpbmcsIGRlZHVwZSBpcyBhbHdheXMgZW5hYmxlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNBY3RpdmUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgaXQncyBhY3RpdmUsIHN0b3AuIEl0IHdpbGwgYXV0byByZXZhbGlkYXRlIHdoZW4gcmVmb2N1c2luZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3IgcmVjb25uZWN0aW5nLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q29uZmlnKCkub25FcnJvclJldHJ5KGVycl8xLCBrZXksIGNvbmZpZywgcmV2YWxpZGF0ZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHJ5Q291bnQ6IChvcHRzLnJldHJ5Q291bnQgfHwgMCkgKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZHVwZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAvLyBNYXJrIGxvYWRpbmcgYXMgc3RvcHBlZC5cbiAgICAgICAgICAgICAgICAgICAgbG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGN1cnJlbnQgaG9vaydzIHN0YXRlLlxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hSZXF1ZXN0QW5kVXBkYXRlU3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSGVyZSBpcyB0aGUgc291cmNlIG9mIHRoZSByZXF1ZXN0LCBuZWVkIHRvIHRlbGwgYWxsIG90aGVyIGhvb2tzIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGVpciBzdGF0ZXMuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0N1cnJlbnRLZXlNb3VudGVkKCkgJiYgc2hvdWxkU3RhcnROZXdSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicm9hZGNhc3RTdGF0ZShjYWNoZSwga2V5LCBuZXdTdGF0ZS5kYXRhLCBuZXdTdGF0ZS5lcnJvciwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0cnVlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7IH0sIFxuICAgIC8vIGBzZXRTdGF0ZWAgaXMgaW1tdXRhYmxlLCBhbmQgYGV2ZW50c0NhbGxiYWNrYCwgYGZuQXJnc2AsIGBrZXlJbmZvYCxcbiAgICAvLyBhbmQgYGtleVZhbGlkYXRpbmdgIGFyZSBkZXBlbmRpbmcgb24gYGtleWAsIHNvIHdlIGNhbiBleGNsdWRlIHRoZW0gZnJvbVxuICAgIC8vIHRoZSBkZXBzIGFycmF5LlxuICAgIC8vXG4gICAgLy8gRklYTUU6XG4gICAgLy8gYGZuYCBhbmQgYGNvbmZpZ2AgbWlnaHQgYmUgY2hhbmdlZCBkdXJpbmcgdGhlIGxpZmVjeWNsZSxcbiAgICAvLyBidXQgdGhleSBtaWdodCBiZSBjaGFuZ2VkIGV2ZXJ5IHJlbmRlciBsaWtlIHRoaXMuXG4gICAgLy8gYHVzZVNXUigna2V5JywgKCkgPT4gZmV0Y2goJy9hcGkvJyksIHsgc3VzcGVuc2U6IHRydWUgfSlgXG4gICAgLy8gU28gd2Ugb21pdCB0aGUgdmFsdWVzIGZyb20gdGhlIGRlcHMgYXJyYXlcbiAgICAvLyBldmVuIHRob3VnaCBpdCBtaWdodCBjYXVzZSB1bmV4cGVjdGVkIGJlaGF2aW9ycy5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgW2tleV0pO1xuICAgIC8vIFNpbWlsYXIgdG8gdGhlIGdsb2JhbCBtdXRhdGUsIGJ1dCBib3VuZCB0byB0aGUgY3VycmVudCBjYWNoZSBhbmQga2V5LlxuICAgIC8vIGBjYWNoZWAgaXNuJ3QgYWxsb3dlZCB0byBjaGFuZ2UgZHVyaW5nIHRoZSBsaWZlY3ljbGUuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIHZhciBib3VuZE11dGF0ZSA9IHVzZUNhbGxiYWNrKFxuICAgIC8vIEJ5IHVzaW5nIGBiaW5kYCB3ZSBkb24ndCBuZWVkIHRvIG1vZGlmeSB0aGUgc2l6ZSBvZiB0aGUgcmVzdCBhcmd1bWVudHMuXG4gICAgLy8gRHVlIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMzcxODEsIHdlIGhhdmUgdG9cbiAgICAvLyBjYXN0IGl0IHRvIGFueSBmb3Igbm93LlxuICAgIGludGVybmFsTXV0YXRlLmJpbmQoVU5ERUZJTkVELCBjYWNoZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4ga2V5UmVmLmN1cnJlbnQ7IH0pLCBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgW10pO1xuICAgIC8vIEFsd2F5cyB1cGRhdGUgZmV0Y2hlciBhbmQgY29uZmlnIHJlZnMuXG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZldGNoZXJSZWYuY3VycmVudCA9IGZldGNoZXI7XG4gICAgICAgIGNvbmZpZ1JlZi5jdXJyZW50ID0gY29uZmlnO1xuICAgIH0pO1xuICAgIC8vIEFmdGVyIG1vdW50ZWQgb3Iga2V5IGNoYW5nZWQuXG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICgha2V5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIga2V5Q2hhbmdlZCA9IGtleSAhPT0ga2V5UmVmLmN1cnJlbnQ7XG4gICAgICAgIHZhciBzb2Z0UmV2YWxpZGF0ZSA9IHJldmFsaWRhdGUuYmluZChVTkRFRklORUQsIFdJVEhfREVEVVBFKTtcbiAgICAgICAgLy8gRXhwb3NlIHN0YXRlIHVwZGF0ZXIgdG8gZ2xvYmFsIGV2ZW50IGxpc3RlbmVycy4gU28gd2UgY2FuIHVwZGF0ZSBob29rJ3NcbiAgICAgICAgLy8gaW50ZXJuYWwgc3RhdGUgZnJvbSB0aGUgb3V0c2lkZS5cbiAgICAgICAgdmFyIG9uU3RhdGVVcGRhdGUgPSBmdW5jdGlvbiAodXBkYXRlZERhdGEsIHVwZGF0ZWRFcnJvciwgdXBkYXRlZElzVmFsaWRhdGluZykge1xuICAgICAgICAgICAgc2V0U3RhdGUobWVyZ2VPYmplY3RzKHtcbiAgICAgICAgICAgICAgICBlcnJvcjogdXBkYXRlZEVycm9yLFxuICAgICAgICAgICAgICAgIGlzVmFsaWRhdGluZzogdXBkYXRlZElzVmFsaWRhdGluZ1xuICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAvLyBTaW5jZSBgc2V0U3RhdGVgIG9ubHkgc2hhbGxvd2x5IGNvbXBhcmVzIHN0YXRlcywgd2UgZG8gYSBkZWVwXG4gICAgICAgICAgICAvLyBjb21wYXJpc29uIGhlcmUuXG4gICAgICAgICAgICBjb21wYXJlKHN0YXRlUmVmLmN1cnJlbnQuZGF0YSwgdXBkYXRlZERhdGEpXG4gICAgICAgICAgICAgICAgPyBVTkRFRklORURcbiAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogdXBkYXRlZERhdGFcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIEV4cG9zZSByZXZhbGlkYXRvcnMgdG8gZ2xvYmFsIGV2ZW50IGxpc3RlbmVycy4gU28gd2UgY2FuIHRyaWdnZXJcbiAgICAgICAgLy8gcmV2YWxpZGF0aW9uIGZyb20gdGhlIG91dHNpZGUuXG4gICAgICAgIHZhciBuZXh0Rm9jdXNSZXZhbGlkYXRlZEF0ID0gMDtcbiAgICAgICAgdmFyIG9uUmV2YWxpZGF0ZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PSBGT0NVU19FVkVOVCkge1xuICAgICAgICAgICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIGlmIChnZXRDb25maWcoKS5yZXZhbGlkYXRlT25Gb2N1cyAmJlxuICAgICAgICAgICAgICAgICAgICBub3cgPiBuZXh0Rm9jdXNSZXZhbGlkYXRlZEF0ICYmXG4gICAgICAgICAgICAgICAgICAgIGlzQWN0aXZlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dEZvY3VzUmV2YWxpZGF0ZWRBdCA9IG5vdyArIGdldENvbmZpZygpLmZvY3VzVGhyb3R0bGVJbnRlcnZhbDtcbiAgICAgICAgICAgICAgICAgICAgc29mdFJldmFsaWRhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09IFJFQ09OTkVDVF9FVkVOVCkge1xuICAgICAgICAgICAgICAgIGlmIChnZXRDb25maWcoKS5yZXZhbGlkYXRlT25SZWNvbm5lY3QgJiYgaXNBY3RpdmUoKSkge1xuICAgICAgICAgICAgICAgICAgICBzb2Z0UmV2YWxpZGF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gTVVUQVRFX0VWRU5UKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldmFsaWRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHVuc3ViVXBkYXRlID0gc3Vic2NyaWJlQ2FsbGJhY2soa2V5LCBTVEFURV9VUERBVEVSUywgb25TdGF0ZVVwZGF0ZSk7XG4gICAgICAgIHZhciB1bnN1YkV2ZW50cyA9IHN1YnNjcmliZUNhbGxiYWNrKGtleSwgRVZFTlRfUkVWQUxJREFUT1JTLCBvblJldmFsaWRhdGUpO1xuICAgICAgICAvLyBNYXJrIHRoZSBjb21wb25lbnQgYXMgbW91bnRlZCBhbmQgdXBkYXRlIGNvcnJlc3BvbmRpbmcgcmVmcy5cbiAgICAgICAgdW5tb3VudGVkUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAga2V5UmVmLmN1cnJlbnQgPSBrZXk7XG4gICAgICAgIGluaXRpYWxNb3VudGVkUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAvLyBXaGVuIGBrZXlgIHVwZGF0ZXMsIHJlc2V0IHRoZSBzdGF0ZSB0byB0aGUgaW5pdGlhbCB2YWx1ZVxuICAgICAgICAvLyBhbmQgdHJpZ2dlciBhIHJlcmVuZGVyIGlmIG5lY2Vzc2FyeS5cbiAgICAgICAgaWYgKGtleUNoYW5nZWQpIHtcbiAgICAgICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICBpc1ZhbGlkYXRpbmc6IGlzVmFsaWRhdGluZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHJpZ2dlciBhIHJldmFsaWRhdGlvbi5cbiAgICAgICAgaWYgKHNob3VsZFJldmFsaWRhdGUoKSkge1xuICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGRhdGEpIHx8IElTX1NFUlZFUikge1xuICAgICAgICAgICAgICAgIC8vIFJldmFsaWRhdGUgaW1tZWRpYXRlbHkuXG4gICAgICAgICAgICAgICAgc29mdFJldmFsaWRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIERlbGF5IHRoZSByZXZhbGlkYXRlIGlmIHdlIGhhdmUgZGF0YSB0byByZXR1cm4gc28gd2Ugd29uJ3QgYmxvY2tcbiAgICAgICAgICAgICAgICAvLyByZW5kZXJpbmcuXG4gICAgICAgICAgICAgICAgckFGKHNvZnRSZXZhbGlkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gTWFyayBpdCBhcyB1bm1vdW50ZWQuXG4gICAgICAgICAgICB1bm1vdW50ZWRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgICAgICB1bnN1YlVwZGF0ZSgpO1xuICAgICAgICAgICAgdW5zdWJFdmVudHMoKTtcbiAgICAgICAgfTtcbiAgICB9LCBba2V5LCByZXZhbGlkYXRlXSk7XG4gICAgLy8gUG9sbGluZ1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGltZXI7XG4gICAgICAgIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgICAvLyBVc2UgdGhlIHBhc3NlZCBpbnRlcnZhbFxuICAgICAgICAgICAgLy8gLi4ub3IgaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSB1cGRhdGVkIGRhdGEgdG8gZ2V0IHRoZSBpbnRlcnZhbFxuICAgICAgICAgICAgdmFyIGludGVydmFsID0gaXNGdW5jdGlvbihyZWZyZXNoSW50ZXJ2YWwpXG4gICAgICAgICAgICAgICAgPyByZWZyZXNoSW50ZXJ2YWwoZGF0YSlcbiAgICAgICAgICAgICAgICA6IHJlZnJlc2hJbnRlcnZhbDtcbiAgICAgICAgICAgIC8vIFdlIG9ubHkgc3RhcnQgbmV4dCBpbnRlcnZhbCBpZiBgcmVmcmVzaEludGVydmFsYCBpcyBub3QgMCwgYW5kOlxuICAgICAgICAgICAgLy8gLSBgZm9yY2VgIGlzIHRydWUsIHdoaWNoIGlzIHRoZSBzdGFydCBvZiBwb2xsaW5nXG4gICAgICAgICAgICAvLyAtIG9yIGB0aW1lcmAgaXMgbm90IDAsIHdoaWNoIG1lYW5zIHRoZSBlZmZlY3Qgd2Fzbid0IGNhbmNlbGVkXG4gICAgICAgICAgICBpZiAoaW50ZXJ2YWwgJiYgdGltZXIgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGV4ZWN1dGUsIGludGVydmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBleGVjdXRlKCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXQncyBPSyB0byBleGVjdXRlOlxuICAgICAgICAgICAgLy8gT25seSByZXZhbGlkYXRlIHdoZW4gdGhlIHBhZ2UgaXMgdmlzaWJsZSwgb25saW5lIGFuZCBub3QgZXJyb3JlZC5cbiAgICAgICAgICAgIGlmICghc3RhdGVSZWYuY3VycmVudC5lcnJvciAmJlxuICAgICAgICAgICAgICAgIChyZWZyZXNoV2hlbkhpZGRlbiB8fCBnZXRDb25maWcoKS5pc1Zpc2libGUoKSkgJiZcbiAgICAgICAgICAgICAgICAocmVmcmVzaFdoZW5PZmZsaW5lIHx8IGdldENvbmZpZygpLmlzT25saW5lKCkpKSB7XG4gICAgICAgICAgICAgICAgcmV2YWxpZGF0ZShXSVRIX0RFRFVQRSkudGhlbihuZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFNjaGVkdWxlIG5leHQgaW50ZXJ2YWwgdG8gY2hlY2sgYWdhaW4uXG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5leHQoKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aW1lcikge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICAgICAgdGltZXIgPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LCBbcmVmcmVzaEludGVydmFsLCByZWZyZXNoV2hlbkhpZGRlbiwgcmVmcmVzaFdoZW5PZmZsaW5lLCByZXZhbGlkYXRlXSk7XG4gICAgLy8gRGlzcGxheSBkZWJ1ZyBpbmZvIGluIFJlYWN0IERldlRvb2xzLlxuICAgIHVzZURlYnVnVmFsdWUoZGF0YSk7XG4gICAgLy8gSW4gU3VzcGVuc2UgbW9kZSwgd2UgY2FuJ3QgcmV0dXJuIHRoZSBlbXB0eSBgZGF0YWAgc3RhdGUuXG4gICAgLy8gSWYgdGhlcmUgaXMgYGVycm9yYCwgdGhlIGBlcnJvcmAgbmVlZHMgdG8gYmUgdGhyb3duIHRvIHRoZSBlcnJvciBib3VuZGFyeS5cbiAgICAvLyBJZiB0aGVyZSBpcyBubyBgZXJyb3JgLCB0aGUgYHJldmFsaWRhdGlvbmAgcHJvbWlzZSBuZWVkcyB0byBiZSB0aHJvd24gdG9cbiAgICAvLyB0aGUgc3VzcGVuc2UgYm91bmRhcnkuXG4gICAgaWYgKHN1c3BlbnNlICYmIGlzVW5kZWZpbmVkKGRhdGEpICYmIGtleSkge1xuICAgICAgICAvLyBBbHdheXMgdXBkYXRlIGZldGNoZXIgYW5kIGNvbmZpZyByZWZzIGV2ZW4gd2l0aCB0aGUgU3VzcGVuc2UgbW9kZS5cbiAgICAgICAgZmV0Y2hlclJlZi5jdXJyZW50ID0gZmV0Y2hlcjtcbiAgICAgICAgY29uZmlnUmVmLmN1cnJlbnQgPSBjb25maWc7XG4gICAgICAgIHVubW91bnRlZFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIHRocm93IGlzVW5kZWZpbmVkKGVycm9yKSA/IHJldmFsaWRhdGUoV0lUSF9ERURVUEUpIDogZXJyb3I7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIG11dGF0ZTogYm91bmRNdXRhdGUsXG4gICAgICAgIGdldCBkYXRhKCkge1xuICAgICAgICAgICAgc3RhdGVEZXBlbmRlbmNpZXMuZGF0YSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGVycm9yKCkge1xuICAgICAgICAgICAgc3RhdGVEZXBlbmRlbmNpZXMuZXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgaXNWYWxpZGF0aW5nKCkge1xuICAgICAgICAgICAgc3RhdGVEZXBlbmRlbmNpZXMuaXNWYWxpZGF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBpc1ZhbGlkYXRpbmc7XG4gICAgICAgIH1cbiAgICB9O1xufTtcbnZhciBTV1JDb25maWcgPSBPQkpFQ1QuZGVmaW5lUHJvcGVydHkoU1dSQ29uZmlnJDEsICdkZWZhdWx0Jywge1xuICAgIHZhbHVlOiBkZWZhdWx0Q29uZmlnXG59KTtcbnZhciB1bnN0YWJsZV9zZXJpYWxpemUgPSBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBzZXJpYWxpemUoa2V5KVswXTsgfTtcbnZhciB1c2VTV1IgPSB3aXRoQXJncyh1c2VTV1JIYW5kbGVyKTtcblxuLy8gdXNlU1dSXG5cbmV4cG9ydCB7IFNXUkNvbmZpZywgdXNlU1dSIGFzIGRlZmF1bHQsIG11dGF0ZSwgdW5zdGFibGVfc2VyaWFsaXplLCB1c2VTV1JDb25maWcgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/swr/dist/index.mjs\n"));

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["main-app"], () => (__webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fwonderlandmitch%2FCascadeProjects%2FWonderVite-frontend%2Fapp%2Fglobals.css%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fwonderlandmitch%2FCascadeProjects%2FWonderVite-frontend%2Fsrc%2Fcomponents%2Fplasmic%2FPlasmicWrapper.tsx%22%2C%22ids%22%3A%5B%22PlasmicWrapper%22%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fwonderlandmitch%2FCascadeProjects%2FWonderVite-frontend%2Fsrc%2Fcontexts%2FSettingsContext.tsx%22%2C%22ids%22%3A%5B%22SettingsProvider%22%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fwonderlandmitch%2FCascadeProjects%2FWonderVite-frontend%2Fsrc%2Fproviders%2FAuthProvider.tsx%22%2C%22ids%22%3A%5B%22AuthProvider%22%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fwonderlandmitch%2FCascadeProjects%2FWonderVite-frontend%2Fsrc%2Fproviders%2FQueryProvider.tsx%22%2C%22ids%22%3A%5B%22QueryProvider%22%5D%7D&server=false!")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);