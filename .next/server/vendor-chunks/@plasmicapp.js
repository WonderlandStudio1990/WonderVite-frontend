/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@plasmicapp";
exports.ids = ["vendor-chunks/@plasmicapp"];
exports.modules = {

/***/ "(ssr)/./node_modules/@plasmicapp/data-sources-context/dist/index.esm.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@plasmicapp/data-sources-context/dist/index.esm.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PlasmicDataSourceContextProvider: () => (/* binding */ PlasmicDataSourceContextProvider),\n/* harmony export */   useCurrentUser: () => (/* binding */ useCurrentUser),\n/* harmony export */   usePlasmicDataSourceContext: () => (/* binding */ usePlasmicDataSourceContext)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* __next_internal_client_entry_do_not_use__ PlasmicDataSourceContextProvider,useCurrentUser,usePlasmicDataSourceContext auto */ // src/index.tsx\n\nvar PlasmicDataSourceContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext(void 0);\nfunction usePlasmicDataSourceContext() {\n    return react__WEBPACK_IMPORTED_MODULE_0___default().useContext(PlasmicDataSourceContext);\n}\nfunction useCurrentUser() {\n    var _a;\n    const ctx = usePlasmicDataSourceContext();\n    return (_a = ctx == null ? void 0 : ctx.user) != null ? _a : {\n        isLoggedIn: false\n    };\n}\nvar PlasmicDataSourceContextProvider = PlasmicDataSourceContext.Provider;\n //# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBsYXNtaWNhcHAvZGF0YS1zb3VyY2VzLWNvbnRleHQvZGlzdC9pbmRleC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWtCO0FBZ0JsQixJQUFNLHlDQUEyQiwwREFBTSxDQUVyQyxNQUFTO0FBRUosU0FBUyw4QkFBOEI7SUFDNUMsT0FBTyx1REFBTSxDQUFXLHdCQUF3QjtBQUNsRDtBQUVPLFNBQVMsaUJBQWlCO0lBeEJqQztJQXlCRSxNQUFNLE1BQU0sNEJBQTRCO0lBQ3hDLFFBQ0UsZ0NBQUssU0FBTCxZQUFhO1FBQ1gsWUFBWTtJQUNkO0FBRUo7QUFFTyxJQUFNLG1DQUNYLHlCQUF5QiIsInNvdXJjZXMiOlsiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvc3JjL2luZGV4LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFBsYXNtaWNEYXRhU291cmNlQ29udGV4dFZhbHVlIHtcbiAgdXNlckF1dGhUb2tlbj86IHN0cmluZyB8IG51bGw7XG4gIGlzVXNlckxvYWRpbmc/OiBib29sZWFuO1xuICBhdXRoUmVkaXJlY3RVcmk/OiBzdHJpbmc7XG4gIHVzZXI/OiB7XG4gICAgZW1haWw6IHN0cmluZztcbiAgICBwcm9wZXJ0aWVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiB8IG51bGw7XG4gICAgcm9sZUlkOiBzdHJpbmc7XG4gICAgcm9sZU5hbWU6IHN0cmluZztcbiAgICByb2xlSWRzOiBzdHJpbmdbXTtcbiAgICByb2xlTmFtZXM6IHN0cmluZ1tdO1xuICB9IHwgbnVsbDtcbn1cblxuY29uc3QgUGxhc21pY0RhdGFTb3VyY2VDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dDxcbiAgUGxhc21pY0RhdGFTb3VyY2VDb250ZXh0VmFsdWUgfCB1bmRlZmluZWRcbj4odW5kZWZpbmVkKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVBsYXNtaWNEYXRhU291cmNlQ29udGV4dCgpIHtcbiAgcmV0dXJuIFJlYWN0LnVzZUNvbnRleHQoUGxhc21pY0RhdGFTb3VyY2VDb250ZXh0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUN1cnJlbnRVc2VyKCkge1xuICBjb25zdCBjdHggPSB1c2VQbGFzbWljRGF0YVNvdXJjZUNvbnRleHQoKTtcbiAgcmV0dXJuIChcbiAgICBjdHg/LnVzZXIgPz8ge1xuICAgICAgaXNMb2dnZWRJbjogZmFsc2UsXG4gICAgfVxuICApO1xufVxuXG5leHBvcnQgY29uc3QgUGxhc21pY0RhdGFTb3VyY2VDb250ZXh0UHJvdmlkZXIgPVxuICBQbGFzbWljRGF0YVNvdXJjZUNvbnRleHQuUHJvdmlkZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@plasmicapp/data-sources-context/dist/index.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@plasmicapp/host/dist/host.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/@plasmicapp/host/dist/host.esm.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DataContext: () => (/* binding */ DataContext),\n/* harmony export */   DataCtxReader: () => (/* binding */ DataCtxReader),\n/* harmony export */   DataProvider: () => (/* binding */ DataProvider),\n/* harmony export */   GlobalActionsContext: () => (/* binding */ GlobalActionsContext),\n/* harmony export */   GlobalActionsProvider: () => (/* binding */ GlobalActionsProvider),\n/* harmony export */   PageParamsProvider: () => (/* binding */ PageParamsProvider),\n/* harmony export */   PlasmicCanvasContext: () => (/* binding */ PlasmicCanvasContext),\n/* harmony export */   PlasmicCanvasHost: () => (/* binding */ PlasmicCanvasHost),\n/* harmony export */   PlasmicLinkProvider: () => (/* binding */ PlasmicLinkProvider),\n/* harmony export */   PlasmicTranslatorContext: () => (/* binding */ PlasmicTranslatorContext),\n/* harmony export */   applySelector: () => (/* binding */ applySelector),\n/* harmony export */   mkMetaName: () => (/* binding */ mkMetaName),\n/* harmony export */   mkMetaValue: () => (/* binding */ mkMetaValue),\n/* harmony export */   registerComponent: () => (/* binding */ registerComponent),\n/* harmony export */   registerFunction: () => (/* binding */ registerFunction),\n/* harmony export */   registerGlobalContext: () => (/* binding */ registerGlobalContext),\n/* harmony export */   registerToken: () => (/* binding */ registerToken),\n/* harmony export */   registerTrait: () => (/* binding */ registerTrait),\n/* harmony export */   repeatedElement: () => (/* binding */ repeatedElement),\n/* harmony export */   stateHelpersKeys: () => (/* binding */ stateHelpersKeys),\n/* harmony export */   unstable_registerFetcher: () => (/* binding */ registerFetcher),\n/* harmony export */   useDataEnv: () => (/* binding */ useDataEnv),\n/* harmony export */   useGlobalActions: () => (/* binding */ useGlobalActions),\n/* harmony export */   usePlasmicCanvasComponentInfo: () => (/* binding */ usePlasmicCanvasComponentInfo),\n/* harmony export */   usePlasmicCanvasContext: () => (/* binding */ usePlasmicCanvasContext),\n/* harmony export */   usePlasmicLink: () => (/* binding */ usePlasmicLink),\n/* harmony export */   usePlasmicLinkMaybe: () => (/* binding */ usePlasmicLinkMaybe),\n/* harmony export */   usePlasmicTranslator: () => (/* binding */ usePlasmicTranslator),\n/* harmony export */   useSelector: () => (/* binding */ useSelector),\n/* harmony export */   useSelectors: () => (/* binding */ useSelectors)\n/* harmony export */ });\n/* harmony import */ var _plasmicapp_query__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @plasmicapp/query */ \"(ssr)/./node_modules/@plasmicapp/query/dist/index.esm.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_2__);\n/* __next_internal_client_entry_do_not_use__ DataContext,DataCtxReader,DataProvider,GlobalActionsContext,GlobalActionsProvider,PageParamsProvider,PlasmicCanvasContext,PlasmicCanvasHost,PlasmicLinkProvider,PlasmicTranslatorContext,applySelector,mkMetaName,mkMetaValue,registerComponent,registerFunction,registerGlobalContext,registerToken,registerTrait,repeatedElement,stateHelpersKeys,unstable_registerFetcher,useDataEnv,useGlobalActions,usePlasmicCanvasComponentInfo,usePlasmicCanvasContext,usePlasmicLink,usePlasmicLinkMaybe,usePlasmicTranslator,useSelector,useSelectors auto */ \n\n\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ /* global Reflect, Promise, SuppressedError, Symbol */ var extendStatics = function(d, b) {\n    extendStatics = Object.setPrototypeOf || ({\n        __proto__: []\n    }) instanceof Array && function(d, b) {\n        d.__proto__ = b;\n    } || function(d, b) {\n        for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n};\nfunction __extends(d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n        this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nvar __assign = function() {\n    __assign = Object.assign || function __assign(t) {\n        for(var s, i = 1, n = arguments.length; i < n; i++){\n            s = arguments[i];\n            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\ntypeof SuppressedError === \"function\" ? SuppressedError : function(error, suppressed, message) {\n    var e = new Error(message);\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\nfunction isString(x) {\n    return typeof x === \"string\";\n}\nfunction ensure(x, msg) {\n    if (msg === void 0) {\n        msg = \"\";\n    }\n    if (x === null || x === undefined) {\n        debugger;\n        msg = (isString(msg) ? msg : msg()) || \"\";\n        throw new Error(\"Value must not be undefined or null\".concat(msg ? \"- \".concat(msg) : \"\"));\n    } else {\n        return x;\n    }\n}\nfunction useForceUpdate() {\n    var _a = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0), setTick = _a[1];\n    var update = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"useForceUpdate.useCallback[update]\": function() {\n            setTick({\n                \"useForceUpdate.useCallback[update]\": function(tick) {\n                    return tick + 1;\n                }\n            }[\"useForceUpdate.useCallback[update]\"]);\n        }\n    }[\"useForceUpdate.useCallback[update]\"], []);\n    return update;\n}\nif (globalThis.__PlasmicHostVersion == null) {\n    globalThis.__PlasmicHostVersion = \"3\";\n}\nvar rootChangeListeners = [];\nvar PlasmicRootNodeWrapper = /** @class */ function() {\n    function PlasmicRootNodeWrapper(value) {\n        var _this = this;\n        this.value = value;\n        this.set = function(val) {\n            _this.value = val;\n            rootChangeListeners.forEach(function(f) {\n                return f();\n            });\n        };\n        this.get = function() {\n            return _this.value;\n        };\n    }\n    return PlasmicRootNodeWrapper;\n}();\nvar plasmicRootNode = new PlasmicRootNodeWrapper(null);\nfunction getHashParams() {\n    return new URLSearchParams(location.hash.replace(/^#/, \"?\"));\n}\nfunction getPlasmicOrigin() {\n    var params = getHashParams();\n    return ensure(params.get(\"origin\"), \"Missing information from Plasmic window.\");\n}\nfunction getStudioHash() {\n    var hashParams = getHashParams();\n    if (hashParams.has(\"studioHash\")) {\n        return hashParams.get(\"studioHash\");\n    }\n    var urlParams = new URL(location.href).searchParams;\n    return urlParams.get(\"studio-hash\");\n}\nfunction renderStudioIntoIframe() {\n    var script = document.createElement(\"script\");\n    var plasmicOrigin = getPlasmicOrigin();\n    var hash = getStudioHash();\n    script.src = \"\".concat(plasmicOrigin, \"/static/js/studio\").concat(hash ? \".\".concat(hash, \".js\") : \".js\");\n    document.body.appendChild(script);\n}\nvar renderCount = 0;\nfunction setPlasmicRootNode(node) {\n    // Keep track of renderCount, which we use as key to ErrorBoundary, so\n    // we can reset the error on each render\n    renderCount++;\n    plasmicRootNode.set(node);\n}\n/**\n * React context to detect whether the component is rendered on Plasmic editor.\n * If not, return false.\n * If so, return an object with more information about the component\n */ var PlasmicCanvasContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createContext(false);\nvar usePlasmicCanvasContext = function() {\n    return react__WEBPACK_IMPORTED_MODULE_1__.useContext(PlasmicCanvasContext);\n};\nfunction _PlasmicCanvasHost() {\n    var _a, _b;\n    // If window.parent is null, then this is a window whose containing iframe\n    // has been detached from the DOM (for the top window, window.parent === window).\n    // In that case, we shouldn't do anything.  If window.parent is null, by the way,\n    // location.hash will also be null.\n    var isFrameAttached = !!window.parent;\n    var isCanvas = !!((_a = location.hash) === null || _a === void 0 ? void 0 : _a.match(/\\bcanvas=true\\b/));\n    var isLive = !!((_b = location.hash) === null || _b === void 0 ? void 0 : _b.match(/\\blive=true\\b/)) || !isFrameAttached;\n    var shouldRenderStudio = isFrameAttached && !document.querySelector(\"#plasmic-studio-tag\") && !isCanvas && !isLive;\n    var forceUpdate = useForceUpdate();\n    react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect({\n        \"_PlasmicCanvasHost.useLayoutEffect\": function() {\n            rootChangeListeners.push(forceUpdate);\n            return ({\n                \"_PlasmicCanvasHost.useLayoutEffect\": function() {\n                    var index = rootChangeListeners.indexOf(forceUpdate);\n                    if (index >= 0) {\n                        rootChangeListeners.splice(index, 1);\n                    }\n                }\n            })[\"_PlasmicCanvasHost.useLayoutEffect\"];\n        }\n    }[\"_PlasmicCanvasHost.useLayoutEffect\"], [\n        forceUpdate\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect({\n        \"_PlasmicCanvasHost.useEffect\": function() {\n            if (shouldRenderStudio && isFrameAttached && window.parent !== window) {\n                renderStudioIntoIframe();\n            }\n        }\n    }[\"_PlasmicCanvasHost.useEffect\"], [\n        shouldRenderStudio,\n        isFrameAttached\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect({\n        \"_PlasmicCanvasHost.useEffect\": function() {\n            if (!shouldRenderStudio && !document.querySelector(\"#getlibs\") && isLive) {\n                var scriptElt = document.createElement(\"script\");\n                scriptElt.id = \"getlibs\";\n                scriptElt.src = getPlasmicOrigin() + \"/static/js/getlibs.js\";\n                scriptElt.async = false;\n                scriptElt.onload = ({\n                    \"_PlasmicCanvasHost.useEffect\": function() {\n                        var _a, _b;\n                        (_b = (_a = window).__GetlibsReadyResolver) === null || _b === void 0 ? void 0 : _b.call(_a);\n                    }\n                })[\"_PlasmicCanvasHost.useEffect\"];\n                document.head.append(scriptElt);\n            }\n        }\n    }[\"_PlasmicCanvasHost.useEffect\"], [\n        shouldRenderStudio\n    ]);\n    var _c = react__WEBPACK_IMPORTED_MODULE_1__.useState({\n        \"_PlasmicCanvasHost.useState[_c]\": function() {\n            return deriveCanvasContextValue();\n        }\n    }[\"_PlasmicCanvasHost.useState[_c]\"]), canvasContextValue = _c[0], setCanvasContextValue = _c[1];\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect({\n        \"_PlasmicCanvasHost.useEffect\": function() {\n            if (isCanvas) {\n                var listener_1 = {\n                    \"_PlasmicCanvasHost.useEffect.listener_1\": function() {\n                        setCanvasContextValue(deriveCanvasContextValue());\n                    }\n                }[\"_PlasmicCanvasHost.useEffect.listener_1\"];\n                window.addEventListener(\"hashchange\", listener_1);\n                return ({\n                    \"_PlasmicCanvasHost.useEffect\": function() {\n                        return window.removeEventListener(\"hashchange\", listener_1);\n                    }\n                })[\"_PlasmicCanvasHost.useEffect\"];\n            }\n            return undefined;\n        }\n    }[\"_PlasmicCanvasHost.useEffect\"], [\n        isCanvas\n    ]);\n    if (!isFrameAttached) {\n        return null;\n    }\n    if (isCanvas || isLive) {\n        var appDiv = document.querySelector(\"#plasmic-app.__wab_user-body\");\n        if (!appDiv) {\n            appDiv = document.createElement(\"div\");\n            appDiv.id = \"plasmic-app\";\n            appDiv.classList.add(\"__wab_user-body\");\n            document.body.prepend(appDiv);\n        }\n        return /*#__PURE__*/ react_dom__WEBPACK_IMPORTED_MODULE_2__.createPortal(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(ErrorBoundary, {\n            key: \"\".concat(renderCount)\n        }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(PlasmicCanvasContext.Provider, {\n            value: canvasContextValue\n        }, plasmicRootNode.get())), appDiv, \"plasmic-app\");\n    }\n    if (shouldRenderStudio && window.parent === window) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"iframe\", {\n            src: \"https://docs.plasmic.app/app-content/app-host-ready#appHostUrl=\".concat(encodeURIComponent(location.href)),\n            style: {\n                width: \"100vw\",\n                height: \"100vh\",\n                border: \"none\",\n                position: \"fixed\",\n                top: 0,\n                left: 0,\n                zIndex: 99999999\n            }\n        });\n    }\n    return null;\n}\nvar PlasmicCanvasHost = function(props) {\n    var enableWebpackHmr = props.enableWebpackHmr;\n    var _a = react__WEBPACK_IMPORTED_MODULE_1__.useState(null), node = _a[0], setNode = _a[1];\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect({\n        \"PlasmicCanvasHost.useEffect\": function() {\n            setNode(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(_PlasmicCanvasHost, null));\n        }\n    }[\"PlasmicCanvasHost.useEffect\"], []);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, !enableWebpackHmr && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(DisableWebpackHmr, null), node);\n};\nvar renderErrorListeners = [];\nfunction registerRenderErrorListener(listener) {\n    renderErrorListeners.push(listener);\n    return function() {\n        var index = renderErrorListeners.indexOf(listener);\n        if (index >= 0) {\n            renderErrorListeners.splice(index, 1);\n        }\n    };\n}\nvar ErrorBoundary = /** @class */ function(_super) {\n    __extends(ErrorBoundary, _super);\n    function ErrorBoundary(props) {\n        var _this = _super.call(this, props) || this;\n        _this.state = {};\n        return _this;\n    }\n    ErrorBoundary.getDerivedStateFromError = function(error) {\n        return {\n            error: error\n        };\n    };\n    ErrorBoundary.prototype.componentDidCatch = function(error) {\n        renderErrorListeners.forEach(function(listener) {\n            return listener(error);\n        });\n    };\n    ErrorBoundary.prototype.render = function() {\n        if (this.state.error) {\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", null, \"Error: \", \"\".concat(this.state.error.message));\n        } else {\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, this.props.children);\n        }\n    };\n    return ErrorBoundary;\n}(react__WEBPACK_IMPORTED_MODULE_1__.Component);\nfunction DisableWebpackHmr() {\n    if (false) {}\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"script\", {\n        type: \"text/javascript\",\n        dangerouslySetInnerHTML: {\n            __html: \"\\n      if (typeof window !== \\\"undefined\\\") {\\n        const RealEventSource = window.EventSource;\\n        window.EventSource = function(url, config) {\\n          if (/[^a-zA-Z]hmr($|[^a-zA-Z])/.test(url)) {\\n            console.warn(\\\"Plasmic: disabled EventSource request for\\\", url);\\n            return {\\n              onerror() {}, onmessage() {}, onopen() {}, close() {}\\n            };\\n          } else {\\n            return new RealEventSource(url, config);\\n          }\\n        }\\n      }\\n      \"\n        }\n    });\n}\nfunction deriveCanvasContextValue() {\n    var _a;\n    var hash = window.location.hash;\n    if (hash && hash.length > 0) {\n        // create URLsearchParams skipping the initial # character\n        var params = new URLSearchParams(hash.substring(1));\n        if (params.get(\"canvas\") === \"true\") {\n            var globalVariants = params.get(\"globalVariants\");\n            return {\n                componentName: (_a = params.get(\"componentName\")) !== null && _a !== void 0 ? _a : null,\n                globalVariants: globalVariants ? JSON.parse(globalVariants) : {},\n                interactive: params.get(\"interactive\") === \"true\"\n            };\n        }\n    }\n    return false;\n}\nvar INTERNAL_CC_CANVAS_SELECTION_PROP = \"__plasmic_selection_prop__\";\nfunction usePlasmicCanvasComponentInfo(props) {\n    return react__WEBPACK_IMPORTED_MODULE_1__.useMemo({\n        \"usePlasmicCanvasComponentInfo.useMemo\": function() {\n            // Inside Plasmic Studio, code components will receive an additional prop\n            // that contains selection information for that specific code component.\n            // This hook will return that selection information which is useful for\n            // changing the behavior of the code component when it is selected, making\n            // it easier to interact with code components and slots that aren't always\n            // visible in the canvas. (e.g. automatically opening a modal when it's selected)\n            var selectionInfo = props === null || props === void 0 ? void 0 : props[INTERNAL_CC_CANVAS_SELECTION_PROP];\n            if (selectionInfo) {\n                return {\n                    isSelected: selectionInfo.isSelected,\n                    selectedSlotName: selectionInfo.selectedSlotName\n                };\n            }\n            return null;\n        }\n    }[\"usePlasmicCanvasComponentInfo.useMemo\"], [\n        props\n    ]);\n}\nvar tuple = function() {\n    var args = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        args[_i] = arguments[_i];\n    }\n    return args;\n};\nvar DataContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nfunction mkMetaName(name) {\n    return \"__plasmic_meta_\".concat(name);\n}\nfunction mkMetaValue(meta) {\n    return meta;\n}\nfunction applySelector(rawData, selector) {\n    if (!selector) {\n        return undefined;\n    }\n    var curData = rawData;\n    for(var _i = 0, _a = selector.split(\".\"); _i < _a.length; _i++){\n        var key = _a[_i];\n        curData = curData === null || curData === void 0 ? void 0 : curData[key];\n    }\n    return curData;\n}\nfunction useSelector(selector) {\n    var rawData = useDataEnv();\n    return applySelector(rawData, selector);\n}\nfunction useSelectors(selectors) {\n    if (selectors === void 0) {\n        selectors = {};\n    }\n    var rawData = useDataEnv();\n    return Object.fromEntries(Object.entries(selectors).filter(function(_a) {\n        var key = _a[0], selector = _a[1];\n        return !!key && !!selector;\n    }).map(function(_a) {\n        var key = _a[0], selector = _a[1];\n        return tuple(key, applySelector(rawData, selector));\n    }));\n}\nfunction useDataEnv() {\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(DataContext);\n}\nfunction DataProvider(_a) {\n    var _b;\n    var _c;\n    var name = _a.name, data = _a.data, hidden = _a.hidden, advanced = _a.advanced, label = _a.label, children = _a.children;\n    var existingEnv = (_c = useDataEnv()) !== null && _c !== void 0 ? _c : {};\n    if (!name) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement((react__WEBPACK_IMPORTED_MODULE_1___default().Fragment), null, children);\n    } else {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(DataContext.Provider, {\n            value: __assign(__assign({}, existingEnv), (_b = {}, _b[name] = data, _b[mkMetaName(name)] = mkMetaValue({\n                hidden: hidden,\n                advanced: advanced,\n                label: label\n            }), _b))\n        }, children);\n    }\n}\n/**\n * This transforms `{ \"...slug\": \"a/b/c\" }` into `{ \"slug\": [\"a\", \"b\", \"c\"] }.\n */ function fixCatchallParams(params) {\n    var newParams = {};\n    for(var _i = 0, _a = Object.entries(params); _i < _a.length; _i++){\n        var _b = _a[_i], key = _b[0], value = _b[1];\n        if (!value) {\n            continue;\n        }\n        if (key.startsWith(\"...\")) {\n            newParams[key.slice(3)] = typeof value === \"string\" ? value.replace(/^\\/|\\/$/g, \"\").split(\"/\") : value;\n        } else {\n            newParams[key] = value;\n        }\n    }\n    return newParams;\n}\nfunction mkPathFromRouteAndParams(route, params) {\n    if (!params) {\n        return route;\n    }\n    var path = route;\n    for(var _i = 0, _a = Object.entries(params); _i < _a.length; _i++){\n        var _b = _a[_i], key = _b[0], value = _b[1];\n        if (typeof value === \"string\") {\n            path = path.replace(\"[\".concat(key, \"]\"), value);\n        } else if (Array.isArray(value)) {\n            if (path.includes(\"[[...\".concat(key, \"]]\"))) {\n                path = path.replace(\"[[...\".concat(key, \"]]\"), value.join(\"/\"));\n            } else if (path.includes(\"[...\".concat(key, \"]\"))) {\n                path = path.replace(\"[...\".concat(key, \"]\"), value.join(\"/\"));\n            }\n        }\n    }\n    return path;\n}\nfunction PageParamsProvider(_a) {\n    var children = _a.children, route = _a.route, deprecatedRoute = _a.path, _b = _a.params, params = _b === void 0 ? {} : _b, _c = _a.query, query = _c === void 0 ? {} : _c;\n    route = route !== null && route !== void 0 ? route : deprecatedRoute;\n    params = fixCatchallParams(params);\n    var $ctx = useDataEnv() || {};\n    var path = route ? mkPathFromRouteAndParams(route, params) : undefined;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(DataProvider, {\n        name: \"pageRoute\",\n        data: route,\n        label: \"Page route\",\n        advanced: true\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(DataProvider, {\n        name: \"pagePath\",\n        data: path,\n        label: \"Page path\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(DataProvider, {\n        name: \"params\",\n        data: __assign(__assign({}, $ctx.params), params),\n        label: \"Page URL path params\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(DataProvider, {\n        name: \"query\",\n        data: __assign(__assign({}, $ctx.query), query),\n        label: \"Page URL query params\"\n    }, children))));\n}\nfunction DataCtxReader(_a) {\n    var children = _a.children;\n    var $ctx = useDataEnv();\n    return children($ctx);\n}\nvar root$7 = globalThis;\nroot$7.__PlasmicFetcherRegistry = [];\nfunction registerFetcher(fetcher, meta) {\n    root$7.__PlasmicFetcherRegistry.push({\n        fetcher: fetcher,\n        meta: meta\n    });\n}\nvar GlobalActionsContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createContext(undefined);\nfunction GlobalActionsProvider(props) {\n    var contextName = props.contextName, children = props.children, actions = props.actions;\n    var existingActions = useGlobalActions();\n    var namespacedActions = react__WEBPACK_IMPORTED_MODULE_1___default().useMemo({\n        \"GlobalActionsProvider.useMemo[namespacedActions]\": function() {\n            return Object.fromEntries(Object.entries(actions).map({\n                \"GlobalActionsProvider.useMemo[namespacedActions]\": function(_a) {\n                    var key = _a[0], val = _a[1];\n                    return [\n                        \"\".concat(contextName, \".\").concat(key),\n                        val\n                    ];\n                }\n            }[\"GlobalActionsProvider.useMemo[namespacedActions]\"]));\n        }\n    }[\"GlobalActionsProvider.useMemo[namespacedActions]\"], [\n        contextName,\n        actions\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(GlobalActionsContext.Provider, {\n        value: __assign(__assign({}, existingActions), namespacedActions)\n    }, children);\n}\nfunction useGlobalActions() {\n    var _a;\n    return (_a = react__WEBPACK_IMPORTED_MODULE_1___default().useContext(GlobalActionsContext)) !== null && _a !== void 0 ? _a : {};\n}\nvar PlasmicLinkContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createContext(undefined);\nfunction usePlasmicLinkMaybe() {\n    return react__WEBPACK_IMPORTED_MODULE_1___default().useContext(PlasmicLinkContext);\n}\nvar AnchorLink = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef(function AnchorLink(props, ref) {\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"a\", __assign({}, props, {\n        ref: ref\n    }));\n});\nfunction usePlasmicLink() {\n    var Link = react__WEBPACK_IMPORTED_MODULE_1___default().useContext(PlasmicLinkContext);\n    if (Link) {\n        return Link;\n    } else {\n        return AnchorLink;\n    }\n}\nfunction PlasmicLinkProvider(props) {\n    var Link = props.Link, children = props.children;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(PlasmicLinkContext.Provider, {\n        value: Link\n    }, children);\n}\nvar root$6 = globalThis;\n// A compile-time error will occur if a new field is added to the StateHelper\n// interface but not included in the keys array of state helper.\nvar stateHelpersKeys = [\n    \"initFunc\",\n    \"onChangeArgsToValue\",\n    \"onMutate\"\n];\nif (root$6.__PlasmicComponentRegistry == null) {\n    root$6.__PlasmicComponentRegistry = [];\n}\nfunction registerComponent(component, meta) {\n    // Check for duplicates\n    if (root$6.__PlasmicComponentRegistry.some(function(r) {\n        return r.component === component && r.meta.name === meta.name;\n    })) {\n        return;\n    }\n    root$6.__PlasmicComponentRegistry.push({\n        component: component,\n        meta: meta\n    });\n}\nvar root$5 = globalThis;\nif (root$5.__PlasmicFunctionsRegistry == null) {\n    root$5.__PlasmicFunctionsRegistry = [];\n}\nfunction registerFunction(fn, meta) {\n    // Check for duplicates\n    if (root$5.__PlasmicFunctionsRegistry.some(function(r) {\n        return r.function === fn && r.meta.name === meta.name && r.meta.namespace == meta.namespace;\n    })) {\n        return;\n    }\n    root$5.__PlasmicFunctionsRegistry.push({\n        function: fn,\n        meta: meta\n    });\n}\nvar root$4 = globalThis;\nif (root$4.__PlasmicContextRegistry == null) {\n    root$4.__PlasmicContextRegistry = [];\n}\nfunction registerGlobalContext(component, meta) {\n    // Check for duplicates\n    if (root$4.__PlasmicContextRegistry.some(function(r) {\n        return r.component === component && r.meta.name === meta.name;\n    })) {\n        return;\n    }\n    root$4.__PlasmicContextRegistry.push({\n        component: component,\n        meta: meta\n    });\n}\nvar root$3 = globalThis;\nif (root$3.__PlasmicTokenRegistry == null) {\n    root$3.__PlasmicTokenRegistry = [];\n}\nfunction registerToken(token) {\n    root$3.__PlasmicTokenRegistry.push(token);\n}\nvar root$2 = globalThis;\nif (root$2.__PlasmicTraitRegistry == null) {\n    root$2.__PlasmicTraitRegistry = [];\n}\nfunction registerTrait(trait, meta) {\n    root$2.__PlasmicTraitRegistry.push({\n        trait: trait,\n        meta: meta\n    });\n}\nvar _a$1, _b;\nfunction repeatedElement(index, elt) {\n    return repeatedElementFn(index, elt);\n}\nvar repeatedElementFn = function(index, elt) {\n    if (Array.isArray(elt)) {\n        return elt.map(function(v) {\n            return repeatedElementFn(index, v);\n        });\n    }\n    if (elt && /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.isValidElement)(elt) && typeof elt !== \"string\") {\n        return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.cloneElement)(elt);\n    }\n    return elt;\n};\nvar root$1 = globalThis;\nvar setRepeatedElementFn = (_b = (_a$1 = root$1 === null || root$1 === void 0 ? void 0 : root$1.__Sub) === null || _a$1 === void 0 ? void 0 : _a$1.setRepeatedElementFn) !== null && _b !== void 0 ? _b : function(fn) {\n    repeatedElementFn = fn;\n};\nvar PlasmicTranslatorContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createContext(undefined);\nfunction usePlasmicTranslator() {\n    var _t = react__WEBPACK_IMPORTED_MODULE_1___default().useContext(PlasmicTranslatorContext);\n    var translator = _t ? typeof _t === \"function\" ? _t : _t.translator : undefined;\n    return translator;\n}\nvar hostModule = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    DataContext: DataContext,\n    DataCtxReader: DataCtxReader,\n    DataProvider: DataProvider,\n    GlobalActionsContext: GlobalActionsContext,\n    GlobalActionsProvider: GlobalActionsProvider,\n    PageParamsProvider: PageParamsProvider,\n    PlasmicCanvasContext: PlasmicCanvasContext,\n    PlasmicCanvasHost: PlasmicCanvasHost,\n    PlasmicLinkProvider: PlasmicLinkProvider,\n    PlasmicTranslatorContext: PlasmicTranslatorContext,\n    applySelector: applySelector,\n    mkMetaName: mkMetaName,\n    mkMetaValue: mkMetaValue,\n    registerComponent: registerComponent,\n    registerFunction: registerFunction,\n    registerGlobalContext: registerGlobalContext,\n    registerToken: registerToken,\n    registerTrait: registerTrait,\n    repeatedElement: repeatedElement,\n    stateHelpersKeys: stateHelpersKeys,\n    unstable_registerFetcher: registerFetcher,\n    useDataEnv: useDataEnv,\n    useGlobalActions: useGlobalActions,\n    usePlasmicCanvasComponentInfo: usePlasmicCanvasComponentInfo,\n    usePlasmicCanvasContext: usePlasmicCanvasContext,\n    usePlasmicLink: usePlasmicLink,\n    usePlasmicLinkMaybe: usePlasmicLinkMaybe,\n    usePlasmicTranslator: usePlasmicTranslator,\n    useSelector: useSelector,\n    useSelectors: useSelectors\n});\nvar hostVersion = \"1.0.208\";\nvar _a;\nvar root = globalThis;\nif (root.__Sub == null) {\n    // Creating a side effect here by logging, so that vite won't\n    // ignore this block for whatever reason. Hiding this for now\n    // as users are complaining; will have to check if this has\n    // been fixed with vite.\n    // console.log(\"Plasmic: Setting up app host dependencies\");\n    root.__Sub = __assign({\n        React: react__WEBPACK_IMPORTED_MODULE_1__,\n        ReactDOM: react_dom__WEBPACK_IMPORTED_MODULE_2__,\n        PlasmicQuery: _plasmicapp_query__WEBPACK_IMPORTED_MODULE_0__,\n        hostModule: hostModule,\n        hostVersion: hostVersion,\n        hostUtils: {\n            setPlasmicRootNode: setPlasmicRootNode,\n            registerRenderErrorListener: registerRenderErrorListener,\n            setRepeatedElementFn: setRepeatedElementFn\n        },\n        // For backwards compatibility:\n        setPlasmicRootNode: setPlasmicRootNode,\n        registerRenderErrorListener: registerRenderErrorListener,\n        setRepeatedElementFn: setRepeatedElementFn\n    }, hostModule);\n} else {\n    console.warn(\"Encountered likely duplicate host version: \".concat(root.__Sub.hostVersion, \" vs \").concat(hostVersion));\n    root.__Sub.duplicateHostVersions = (_a = root.__Sub.duplicateHostVersions) !== null && _a !== void 0 ? _a : [];\n    root.__Sub.duplicateHostVersions.push(hostVersion);\n}\n //# sourceMappingURL=host.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBsYXNtaWNhcHAvaG9zdC9kaXN0L2hvc3QuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLFNBQVMsUUFBUSxDQUFDLENBQU07SUFDdEIsT0FBTyxPQUFPLENBQUMsS0FBSyxRQUFRLENBQUM7QUFDL0IsQ0FBQztBQUllLGVBQU0sQ0FBSSxDQUF1QixFQUFFLEdBQW1CO0lBQW5CO1FBQUEsR0FBbUI7SUFBQTtJQUNwRSxJQUFJLENBQUMsS0FBSyxJQUFJLElBQUksQ0FBQyxLQUFLLFNBQVMsRUFBRTtRQUNqQyxRQUFTO1FBQ1QsR0FBRyxHQUFHLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUUsSUFBSyxFQUFFLENBQUM7UUFDMUMsTUFBTSxJQUFJLEtBQUssQ0FDYixxQ0FBc0MsV0FBRyxHQUFHLElBQUssV0FBRyxDQUFFLEdBQUcsRUFBRSxDQUFFLENBQzlELENBQUM7SUFDSCxPQUFNO1FBQ0wsT0FBTyxDQUFDLENBQUM7SUFDVjtBQUNIO0FDZGMsU0FBVSxjQUFjO0lBQzlCLFNBQWMsK0NBQVEsQ0FBQyxDQUFDLENBQUMsRUFBdEIsT0FBTyxRQUFlLENBQUM7SUFDaEMsSUFBTSxNQUFNLEdBQUcsa0RBQVc7OENBQUM7WUFDekIsT0FBTztzREFBQyxTQUFDLElBQUksRUFBSztvQkFBQSxXQUFJLEdBQUcsQ0FBQztnQkFBQTs7U0FDM0I7NkNBQUUsRUFBRSxDQUFDLENBQUM7SUFDUCxPQUFPLE1BQU0sQ0FBQztBQUNoQjtBQ0dBLElBQUssVUFBa0IsQ0FBQyxvQkFBb0IsSUFBSSxJQUFJLEVBQUU7SUFDbkQsVUFBa0IsQ0FBQyxvQkFBb0IsR0FBRyxHQUFHLENBQUM7QUFDaEQ7QUFFRCxJQUFNLG1CQUFtQixHQUFtQixFQUFFLENB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MkI7UUFDM0Isb0JBQW9CO0lBQUEsR0FDakIsVUFBVSxDQUNkLENBQUM7QUFDSCxPQUFNO0lBQ0wsT0FBTyxDQUFDLElBQUksQ0FDVixxREFBOEMsSUFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLGlCQUFPLFdBQVcsQ0FBRSxDQUN6RixDQUFDO0lBQ0YsSUFBSSxDQUFDLEtBQUssQ0FBQyxxQkFBcUIsR0FBRyxVQUFJLENBQUMsS0FBSyxDQUFDLDJCQUFxQiw2QkFBSSxFQUFFLENBQUM7SUFDMUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7QUFDcEQiLCJzb3VyY2VzIjpbIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL3NyYy9sYW5nLXV0aWxzLnRzIiwiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvc3JjL3VzZUZvcmNlVXBkYXRlLnRzIiwiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvc3JjL2NhbnZhcy1ob3N0LnRzeCIsIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL3NyYy9jb21tb24udHMiLCIvVXNlcnMvd29uZGVybGFuZG1pdGNoL0Nhc2NhZGVQcm9qZWN0cy9zcmMvZGF0YS50c3giLCIvVXNlcnMvd29uZGVybGFuZG1pdGNoL0Nhc2NhZGVQcm9qZWN0cy9zcmMvZmV0Y2hlci50cyIsIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL3NyYy9nbG9iYWwtYWN0aW9ucy50c3giLCIvVXNlcnMvd29uZGVybGFuZG1pdGNoL0Nhc2NhZGVQcm9qZWN0cy9zcmMvbGluay50c3giLCIvVXNlcnMvd29uZGVybGFuZG1pdGNoL0Nhc2NhZGVQcm9qZWN0cy9zcmMvcmVnaXN0ZXJDb21wb25lbnQudHMiLCIvVXNlcnMvd29uZGVybGFuZG1pdGNoL0Nhc2NhZGVQcm9qZWN0cy9zcmMvcmVnaXN0ZXJGdW5jdGlvbi50cyIsIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL3NyYy9yZWdpc3Rlckdsb2JhbENvbnRleHQudHMiLCIvVXNlcnMvd29uZGVybGFuZG1pdGNoL0Nhc2NhZGVQcm9qZWN0cy9zcmMvcmVnaXN0ZXJUb2tlbi50cyIsIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL3NyYy9yZWdpc3RlclRyYWl0LnRzIiwiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvc3JjL3JlcGVhdGVkRWxlbWVudC50cyIsIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL3NyYy90cmFuc2xhdGlvbi50c3giLCIvVXNlcnMvd29uZGVybGFuZG1pdGNoL0Nhc2NhZGVQcm9qZWN0cy9zcmMvdmVyc2lvbi50cyIsIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL3NyYy9pbmRleC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBpc1N0cmluZyh4OiBhbnkpOiB4IGlzIHN0cmluZyB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gXCJzdHJpbmdcIjtcbn1cblxudHlwZSBTdHJpbmdHZW4gPSBzdHJpbmcgfCAoKCkgPT4gc3RyaW5nKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZTxUPih4OiBUIHwgbnVsbCB8IHVuZGVmaW5lZCwgbXNnOiBTdHJpbmdHZW4gPSBcIlwiKTogVCB7XG4gIGlmICh4ID09PSBudWxsIHx8IHggPT09IHVuZGVmaW5lZCkge1xuICAgIGRlYnVnZ2VyO1xuICAgIG1zZyA9IChpc1N0cmluZyhtc2cpID8gbXNnIDogbXNnKCkpIHx8IFwiXCI7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFZhbHVlIG11c3Qgbm90IGJlIHVuZGVmaW5lZCBvciBudWxsJHttc2cgPyBgLSAke21zZ31gIDogXCJcIn1gXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geDtcbiAgfVxufVxuIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHVzZUZvcmNlVXBkYXRlKCkge1xuICBjb25zdCBbLCBzZXRUaWNrXSA9IHVzZVN0YXRlKDApO1xuICBjb25zdCB1cGRhdGUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgc2V0VGljaygodGljaykgPT4gdGljayArIDEpO1xuICB9LCBbXSk7XG4gIHJldHVybiB1cGRhdGU7XG59XG4iLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCAqIGFzIFJlYWN0RE9NIGZyb20gXCJyZWFjdC1kb21cIjtcbmltcG9ydCB7IGVuc3VyZSB9IGZyb20gXCIuL2xhbmctdXRpbHNcIjtcbmltcG9ydCB1c2VGb3JjZVVwZGF0ZSBmcm9tIFwiLi91c2VGb3JjZVVwZGF0ZVwiO1xuXG5kZWNsYXJlIGdsb2JhbCB7XG4gIGludGVyZmFjZSBXaW5kb3cge1xuICAgIF9fUGxhc21pY0hvc3RWZXJzaW9uOiBzdHJpbmc7XG4gIH1cbn1cblxuaWYgKChnbG9iYWxUaGlzIGFzIGFueSkuX19QbGFzbWljSG9zdFZlcnNpb24gPT0gbnVsbCkge1xuICAoZ2xvYmFsVGhpcyBhcyBhbnkpLl9fUGxhc21pY0hvc3RWZXJzaW9uID0gXCIzXCI7XG59XG5cbmNvbnN0IHJvb3RDaGFuZ2VMaXN0ZW5lcnM6ICgoKSA9PiB2b2lkKVtdID0gW107XG5jbGFzcyBQbGFzbWljUm9vdE5vZGVXcmFwcGVyIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSB2YWx1ZTogbnVsbCB8IFJlYWN0LlJlYWN0RWxlbWVudCkge31cbiAgc2V0ID0gKHZhbDogbnVsbCB8IFJlYWN0LlJlYWN0RWxlbWVudCkgPT4ge1xuICAgIHRoaXMudmFsdWUgPSB2YWw7XG4gICAgcm9vdENoYW5nZUxpc3RlbmVycy5mb3JFYWNoKChmKSA9PiBmKCkpO1xuICB9O1xuICBnZXQgPSAoKSA9PiB0aGlzLnZhbHVlO1xufVxuXG5jb25zdCBwbGFzbWljUm9vdE5vZGUgPSBuZXcgUGxhc21pY1Jvb3ROb2RlV3JhcHBlcihudWxsKTtcblxuZnVuY3Rpb24gZ2V0SGFzaFBhcmFtcygpIHtcbiAgcmV0dXJuIG5ldyBVUkxTZWFyY2hQYXJhbXMobG9jYXRpb24uaGFzaC5yZXBsYWNlKC9eIy8sIFwiP1wiKSk7XG59XG5cbmZ1bmN0aW9uIGdldFBsYXNtaWNPcmlnaW4oKSB7XG4gIGNvbnN0IHBhcmFtcyA9IGdldEhhc2hQYXJhbXMoKTtcbiAgcmV0dXJuIGVuc3VyZShcbiAgICBwYXJhbXMuZ2V0KFwib3JpZ2luXCIpLFxuICAgIFwiTWlzc2luZyBpbmZvcm1hdGlvbiBmcm9tIFBsYXNtaWMgd2luZG93LlwiXG4gICk7XG59XG5cbmZ1bmN0aW9uIGdldFN0dWRpb0hhc2goKSB7XG4gIGNvbnN0IGhhc2hQYXJhbXMgPSBnZXRIYXNoUGFyYW1zKCk7XG4gIGlmIChoYXNoUGFyYW1zLmhhcyhcInN0dWRpb0hhc2hcIikpIHtcbiAgICByZXR1cm4gaGFzaFBhcmFtcy5nZXQoXCJzdHVkaW9IYXNoXCIpO1xuICB9XG4gIGNvbnN0IHVybFBhcmFtcyA9IG5ldyBVUkwobG9jYXRpb24uaHJlZikuc2VhcmNoUGFyYW1zO1xuICByZXR1cm4gdXJsUGFyYW1zLmdldChcInN0dWRpby1oYXNoXCIpO1xufVxuXG5mdW5jdGlvbiByZW5kZXJTdHVkaW9JbnRvSWZyYW1lKCkge1xuICBjb25zdCBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICBjb25zdCBwbGFzbWljT3JpZ2luID0gZ2V0UGxhc21pY09yaWdpbigpO1xuICBjb25zdCBoYXNoID0gZ2V0U3R1ZGlvSGFzaCgpO1xuICBzY3JpcHQuc3JjID0gYCR7cGxhc21pY09yaWdpbn0vc3RhdGljL2pzL3N0dWRpbyR7XG4gICAgaGFzaCA/IGAuJHtoYXNofS5qc2AgOiBgLmpzYFxuICB9YDtcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzY3JpcHQpO1xufVxuXG5sZXQgcmVuZGVyQ291bnQgPSAwO1xuZXhwb3J0IGZ1bmN0aW9uIHNldFBsYXNtaWNSb290Tm9kZShub2RlOiBSZWFjdC5SZWFjdEVsZW1lbnQgfCBudWxsKSB7XG4gIC8vIEtlZXAgdHJhY2sgb2YgcmVuZGVyQ291bnQsIHdoaWNoIHdlIHVzZSBhcyBrZXkgdG8gRXJyb3JCb3VuZGFyeSwgc29cbiAgLy8gd2UgY2FuIHJlc2V0IHRoZSBlcnJvciBvbiBlYWNoIHJlbmRlclxuICByZW5kZXJDb3VudCsrO1xuICBwbGFzbWljUm9vdE5vZGUuc2V0KG5vZGUpO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBsYXNtaWNDYW52YXNDb250ZXh0VmFsdWUge1xuICBjb21wb25lbnROYW1lOiBzdHJpbmcgfCBudWxsO1xuICBnbG9iYWxWYXJpYW50czogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbiAgaW50ZXJhY3RpdmU/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIFJlYWN0IGNvbnRleHQgdG8gZGV0ZWN0IHdoZXRoZXIgdGhlIGNvbXBvbmVudCBpcyByZW5kZXJlZCBvbiBQbGFzbWljIGVkaXRvci5cbiAqIElmIG5vdCwgcmV0dXJuIGZhbHNlLlxuICogSWYgc28sIHJldHVybiBhbiBvYmplY3Qgd2l0aCBtb3JlIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjb21wb25lbnRcbiAqL1xuZXhwb3J0IGNvbnN0IFBsYXNtaWNDYW52YXNDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dDxcbiAgUGxhc21pY0NhbnZhc0NvbnRleHRWYWx1ZSB8IGZhbHNlXG4+KGZhbHNlKTtcbmV4cG9ydCBjb25zdCB1c2VQbGFzbWljQ2FudmFzQ29udGV4dCA9ICgpID0+XG4gIFJlYWN0LnVzZUNvbnRleHQoUGxhc21pY0NhbnZhc0NvbnRleHQpO1xuXG5mdW5jdGlvbiBfUGxhc21pY0NhbnZhc0hvc3QoKSB7XG4gIC8vIElmIHdpbmRvdy5wYXJlbnQgaXMgbnVsbCwgdGhlbiB0aGlzIGlzIGEgd2luZG93IHdob3NlIGNvbnRhaW5pbmcgaWZyYW1lXG4gIC8vIGhhcyBiZWVuIGRldGFjaGVkIGZyb20gdGhlIERPTSAoZm9yIHRoZSB0b3Agd2luZG93LCB3aW5kb3cucGFyZW50ID09PSB3aW5kb3cpLlxuICAvLyBJbiB0aGF0IGNhc2UsIHdlIHNob3VsZG4ndCBkbyBhbnl0aGluZy4gIElmIHdpbmRvdy5wYXJlbnQgaXMgbnVsbCwgYnkgdGhlIHdheSxcbiAgLy8gbG9jYXRpb24uaGFzaCB3aWxsIGFsc28gYmUgbnVsbC5cbiAgY29uc3QgaXNGcmFtZUF0dGFjaGVkID0gISF3aW5kb3cucGFyZW50O1xuICBjb25zdCBpc0NhbnZhcyA9ICEhbG9jYXRpb24uaGFzaD8ubWF0Y2goL1xcYmNhbnZhcz10cnVlXFxiLyk7XG4gIGNvbnN0IGlzTGl2ZSA9ICEhbG9jYXRpb24uaGFzaD8ubWF0Y2goL1xcYmxpdmU9dHJ1ZVxcYi8pIHx8ICFpc0ZyYW1lQXR0YWNoZWQ7XG4gIGNvbnN0IHNob3VsZFJlbmRlclN0dWRpbyA9XG4gICAgaXNGcmFtZUF0dGFjaGVkICYmXG4gICAgIWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjcGxhc21pYy1zdHVkaW8tdGFnXCIpICYmXG4gICAgIWlzQ2FudmFzICYmXG4gICAgIWlzTGl2ZTtcbiAgY29uc3QgZm9yY2VVcGRhdGUgPSB1c2VGb3JjZVVwZGF0ZSgpO1xuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIHJvb3RDaGFuZ2VMaXN0ZW5lcnMucHVzaChmb3JjZVVwZGF0ZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNvbnN0IGluZGV4ID0gcm9vdENoYW5nZUxpc3RlbmVycy5pbmRleE9mKGZvcmNlVXBkYXRlKTtcbiAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgIHJvb3RDaGFuZ2VMaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbZm9yY2VVcGRhdGVdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoc2hvdWxkUmVuZGVyU3R1ZGlvICYmIGlzRnJhbWVBdHRhY2hlZCAmJiB3aW5kb3cucGFyZW50ICE9PSB3aW5kb3cpIHtcbiAgICAgIHJlbmRlclN0dWRpb0ludG9JZnJhbWUoKTtcbiAgICB9XG4gIH0sIFtzaG91bGRSZW5kZXJTdHVkaW8sIGlzRnJhbWVBdHRhY2hlZF0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghc2hvdWxkUmVuZGVyU3R1ZGlvICYmICFkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2dldGxpYnNcIikgJiYgaXNMaXZlKSB7XG4gICAgICBjb25zdCBzY3JpcHRFbHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgc2NyaXB0RWx0LmlkID0gXCJnZXRsaWJzXCI7XG4gICAgICBzY3JpcHRFbHQuc3JjID0gZ2V0UGxhc21pY09yaWdpbigpICsgXCIvc3RhdGljL2pzL2dldGxpYnMuanNcIjtcbiAgICAgIHNjcmlwdEVsdC5hc3luYyA9IGZhbHNlO1xuICAgICAgc2NyaXB0RWx0Lm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgKHdpbmRvdyBhcyBhbnkpLl9fR2V0bGlic1JlYWR5UmVzb2x2ZXI/LigpO1xuICAgICAgfTtcbiAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kKHNjcmlwdEVsdCk7XG4gICAgfVxuICB9LCBbc2hvdWxkUmVuZGVyU3R1ZGlvXSk7XG5cbiAgY29uc3QgW2NhbnZhc0NvbnRleHRWYWx1ZSwgc2V0Q2FudmFzQ29udGV4dFZhbHVlXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+XG4gICAgZGVyaXZlQ2FudmFzQ29udGV4dFZhbHVlKClcbiAgKTtcblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpc0NhbnZhcykge1xuICAgICAgY29uc3QgbGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICAgIHNldENhbnZhc0NvbnRleHRWYWx1ZShkZXJpdmVDYW52YXNDb250ZXh0VmFsdWUoKSk7XG4gICAgICB9O1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJoYXNoY2hhbmdlXCIsIGxpc3RlbmVyKTtcbiAgICAgIHJldHVybiAoKSA9PiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImhhc2hjaGFuZ2VcIiwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9LCBbaXNDYW52YXNdKTtcbiAgaWYgKCFpc0ZyYW1lQXR0YWNoZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoaXNDYW52YXMgfHwgaXNMaXZlKSB7XG4gICAgbGV0IGFwcERpdiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjcGxhc21pYy1hcHAuX193YWJfdXNlci1ib2R5XCIpO1xuICAgIGlmICghYXBwRGl2KSB7XG4gICAgICBhcHBEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgYXBwRGl2LmlkID0gXCJwbGFzbWljLWFwcFwiO1xuICAgICAgYXBwRGl2LmNsYXNzTGlzdC5hZGQoXCJfX3dhYl91c2VyLWJvZHlcIik7XG4gICAgICBkb2N1bWVudC5ib2R5LnByZXBlbmQoYXBwRGl2KTtcbiAgICB9XG4gICAgcmV0dXJuIFJlYWN0RE9NLmNyZWF0ZVBvcnRhbChcbiAgICAgIDxFcnJvckJvdW5kYXJ5IGtleT17YCR7cmVuZGVyQ291bnR9YH0+XG4gICAgICAgIDxQbGFzbWljQ2FudmFzQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17Y2FudmFzQ29udGV4dFZhbHVlfT5cbiAgICAgICAgICB7cGxhc21pY1Jvb3ROb2RlLmdldCgpfVxuICAgICAgICA8L1BsYXNtaWNDYW52YXNDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgPC9FcnJvckJvdW5kYXJ5PixcbiAgICAgIGFwcERpdixcbiAgICAgIFwicGxhc21pYy1hcHBcIlxuICAgICk7XG4gIH1cbiAgaWYgKHNob3VsZFJlbmRlclN0dWRpbyAmJiB3aW5kb3cucGFyZW50ID09PSB3aW5kb3cpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGlmcmFtZVxuICAgICAgICBzcmM9e2BodHRwczovL2RvY3MucGxhc21pYy5hcHAvYXBwLWNvbnRlbnQvYXBwLWhvc3QtcmVhZHkjYXBwSG9zdFVybD0ke2VuY29kZVVSSUNvbXBvbmVudChcbiAgICAgICAgICBsb2NhdGlvbi5ocmVmXG4gICAgICAgICl9YH1cbiAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICB3aWR0aDogXCIxMDB2d1wiLFxuICAgICAgICAgIGhlaWdodDogXCIxMDB2aFwiLFxuICAgICAgICAgIGJvcmRlcjogXCJub25lXCIsXG4gICAgICAgICAgcG9zaXRpb246IFwiZml4ZWRcIixcbiAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICB6SW5kZXg6IDk5OTk5OTk5LFxuICAgICAgICB9fVxuICAgICAgPjwvaWZyYW1lPlxuICAgICk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmludGVyZmFjZSBQbGFzbWljQ2FudmFzSG9zdFByb3BzIHtcbiAgLyoqXG4gICAqIFdlYnBhY2sgaG1yIHVzZXMgRXZlbnRTb3VyY2UgdG9cdGxpc3RlbiB0byBob3QgcmVsb2FkcywgYnV0IHRoYXRcbiAgICogcmVzdWx0c2luIGEgcGVyc2lzdGVudFx0Y29ubmVjdGlvbiBmcm9tXHRlYWNoIHdpbmRvdy4gIEluIFBsYXNtaWNcbiAgICogU3R1ZGlvLCBpZiBhIHByb2plY3QgaXMgY29uZmlndXJlZCB0byB1c2UgYXBwLWhvc3Rpbmcgd2l0aCBhXG4gICAqIG5leHRqcyBvciBnYXRzYnkgc2VydmVyIHJ1bm5pbmcgaW4gZGV2IG1vZGUsIGVhY2ggYXJ0Ym9hcmQgd2lsbFxuICAgKiBiZSBob2xkaW5nIGEgcGVyc2lzdGVudCBjb25uZWN0aW9uIHRvIHRoZSBkZXYgc2VydmVyLlxuICAgKiBCZWNhdXNlIGJyb3dzZXJzXHRoYXZlIGEgbGltaXQgdG9cdGhvdyBtYW55IGNvbm5lY3Rpb25zIGNhblxuICAgKiBiZSBoZWxkXHRhdCBhIHRpbWUgYnkgZG9tYWluLCB0aGlzIG1lYW5zXHRhZnRlciBYXHRhcnRib2FyZHMsIG5ld1xuICAgKiBhcnRib2FyZHMgd2lsbCBmcmVlemUgYW5kIG5vdCBsb2FkLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCA8UGxhc21pY0NhbnZhc0hvc3QgLz4gd2lsbCBnbG9iYWxseSBtdXRhdGVcbiAgICogd2luZG93LkV2ZW50U291cmNlIHRvIGF2b2lkIHVzaW5nIEV2ZW50U291cmNlIGZvciBITVIsIHdoaWNoIHlvdVxuICAgKiB0eXBpY2FsbHkgZG9uJ3QgbmVlZCBmb3IgeW91ciBjdXN0b20gaG9zdCBwYWdlLiAgSWYgeW91IGRvIHN0aWxsXG4gICAqIHdhbnQgdG8gcmV0YWluIEhSTSwgdGhlbiB5b3VjIGFuIHBhc3MgZW5hYmxlV2VicGFja0htcj17dHJ1ZX0uXG4gICAqL1xuICBlbmFibGVXZWJwYWNrSG1yPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNvbnN0IFBsYXNtaWNDYW52YXNIb3N0OiBSZWFjdC5GdW5jdGlvbkNvbXBvbmVudDxcbiAgUGxhc21pY0NhbnZhc0hvc3RQcm9wc1xuPiA9IChwcm9wcykgPT4ge1xuICBjb25zdCB7IGVuYWJsZVdlYnBhY2tIbXIgfSA9IHByb3BzO1xuICBjb25zdCBbbm9kZSwgc2V0Tm9kZV0gPSBSZWFjdC51c2VTdGF0ZTxSZWFjdC5SZWFjdEVsZW1lbnQ8YW55LCBhbnk+IHwgbnVsbD4oXG4gICAgbnVsbFxuICApO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHNldE5vZGUoPF9QbGFzbWljQ2FudmFzSG9zdCAvPik7XG4gIH0sIFtdKTtcbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAgeyFlbmFibGVXZWJwYWNrSG1yICYmIDxEaXNhYmxlV2VicGFja0htciAvPn1cbiAgICAgIHtub2RlfVxuICAgIDwvPlxuICApO1xufTtcblxudHlwZSBSZW5kZXJFcnJvckxpc3RlbmVyID0gKGVycjogRXJyb3IpID0+IHZvaWQ7XG5jb25zdCByZW5kZXJFcnJvckxpc3RlbmVyczogUmVuZGVyRXJyb3JMaXN0ZW5lcltdID0gW107XG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJSZW5kZXJFcnJvckxpc3RlbmVyKGxpc3RlbmVyOiBSZW5kZXJFcnJvckxpc3RlbmVyKSB7XG4gIHJlbmRlckVycm9yTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGNvbnN0IGluZGV4ID0gcmVuZGVyRXJyb3JMaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHJlbmRlckVycm9yTGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICB9O1xufVxuXG5pbnRlcmZhY2UgRXJyb3JCb3VuZGFyeVByb3BzIHtcbiAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGU7XG59XG5cbmludGVyZmFjZSBFcnJvckJvdW5kYXJ5U3RhdGUge1xuICBlcnJvcj86IEVycm9yO1xufVxuXG5jbGFzcyBFcnJvckJvdW5kYXJ5IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFxuICBFcnJvckJvdW5kYXJ5UHJvcHMsXG4gIEVycm9yQm91bmRhcnlTdGF0ZVxuPiB7XG4gIGNvbnN0cnVjdG9yKHByb3BzOiBFcnJvckJvdW5kYXJ5UHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5zdGF0ZSA9IHt9O1xuICB9XG5cbiAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihlcnJvcjogRXJyb3IpIHtcbiAgICByZXR1cm4geyBlcnJvciB9O1xuICB9XG5cbiAgY29tcG9uZW50RGlkQ2F0Y2goZXJyb3I6IEVycm9yKSB7XG4gICAgcmVuZGVyRXJyb3JMaXN0ZW5lcnMuZm9yRWFjaCgobGlzdGVuZXIpID0+IGxpc3RlbmVyKGVycm9yKSk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuZXJyb3IpIHtcbiAgICAgIHJldHVybiA8ZGl2PkVycm9yOiB7YCR7dGhpcy5zdGF0ZS5lcnJvci5tZXNzYWdlfWB9PC9kaXY+O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gPD57dGhpcy5wcm9wcy5jaGlsZHJlbn08Lz47XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIERpc2FibGVXZWJwYWNrSG1yKCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIChcbiAgICA8c2NyaXB0XG4gICAgICB0eXBlPVwidGV4dC9qYXZhc2NyaXB0XCJcbiAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MPXt7XG4gICAgICAgIF9faHRtbDogYFxuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgY29uc3QgUmVhbEV2ZW50U291cmNlID0gd2luZG93LkV2ZW50U291cmNlO1xuICAgICAgICB3aW5kb3cuRXZlbnRTb3VyY2UgPSBmdW5jdGlvbih1cmwsIGNvbmZpZykge1xuICAgICAgICAgIGlmICgvW15hLXpBLVpdaG1yKCR8W15hLXpBLVpdKS8udGVzdCh1cmwpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJQbGFzbWljOiBkaXNhYmxlZCBFdmVudFNvdXJjZSByZXF1ZXN0IGZvclwiLCB1cmwpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgb25lcnJvcigpIHt9LCBvbm1lc3NhZ2UoKSB7fSwgb25vcGVuKCkge30sIGNsb3NlKCkge31cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVhbEV2ZW50U291cmNlKHVybCwgY29uZmlnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGAsXG4gICAgICB9fVxuICAgID48L3NjcmlwdD5cbiAgKTtcbn1cblxuZnVuY3Rpb24gZGVyaXZlQ2FudmFzQ29udGV4dFZhbHVlKCk6IFBsYXNtaWNDYW52YXNDb250ZXh0VmFsdWUgfCBmYWxzZSB7XG4gIGNvbnN0IGhhc2ggPSB3aW5kb3cubG9jYXRpb24uaGFzaDtcbiAgaWYgKGhhc2ggJiYgaGFzaC5sZW5ndGggPiAwKSB7XG4gICAgLy8gY3JlYXRlIFVSTHNlYXJjaFBhcmFtcyBza2lwcGluZyB0aGUgaW5pdGlhbCAjIGNoYXJhY3RlclxuICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoaGFzaC5zdWJzdHJpbmcoMSkpO1xuICAgIGlmIChwYXJhbXMuZ2V0KFwiY2FudmFzXCIpID09PSBcInRydWVcIikge1xuICAgICAgY29uc3QgZ2xvYmFsVmFyaWFudHMgPSBwYXJhbXMuZ2V0KFwiZ2xvYmFsVmFyaWFudHNcIik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb21wb25lbnROYW1lOiBwYXJhbXMuZ2V0KFwiY29tcG9uZW50TmFtZVwiKSA/PyBudWxsLFxuICAgICAgICBnbG9iYWxWYXJpYW50czogZ2xvYmFsVmFyaWFudHMgPyBKU09OLnBhcnNlKGdsb2JhbFZhcmlhbnRzKSA6IHt9LFxuICAgICAgICBpbnRlcmFjdGl2ZTogcGFyYW1zLmdldChcImludGVyYWN0aXZlXCIpID09PSBcInRydWVcIixcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuY29uc3QgSU5URVJOQUxfQ0NfQ0FOVkFTX1NFTEVDVElPTl9QUk9QID0gXCJfX3BsYXNtaWNfc2VsZWN0aW9uX3Byb3BfX1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlUGxhc21pY0NhbnZhc0NvbXBvbmVudEluZm8ocHJvcHM6IGFueSkge1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgLy8gSW5zaWRlIFBsYXNtaWMgU3R1ZGlvLCBjb2RlIGNvbXBvbmVudHMgd2lsbCByZWNlaXZlIGFuIGFkZGl0aW9uYWwgcHJvcFxuICAgIC8vIHRoYXQgY29udGFpbnMgc2VsZWN0aW9uIGluZm9ybWF0aW9uIGZvciB0aGF0IHNwZWNpZmljIGNvZGUgY29tcG9uZW50LlxuICAgIC8vIFRoaXMgaG9vayB3aWxsIHJldHVybiB0aGF0IHNlbGVjdGlvbiBpbmZvcm1hdGlvbiB3aGljaCBpcyB1c2VmdWwgZm9yXG4gICAgLy8gY2hhbmdpbmcgdGhlIGJlaGF2aW9yIG9mIHRoZSBjb2RlIGNvbXBvbmVudCB3aGVuIGl0IGlzIHNlbGVjdGVkLCBtYWtpbmdcbiAgICAvLyBpdCBlYXNpZXIgdG8gaW50ZXJhY3Qgd2l0aCBjb2RlIGNvbXBvbmVudHMgYW5kIHNsb3RzIHRoYXQgYXJlbid0IGFsd2F5c1xuICAgIC8vIHZpc2libGUgaW4gdGhlIGNhbnZhcy4gKGUuZy4gYXV0b21hdGljYWxseSBvcGVuaW5nIGEgbW9kYWwgd2hlbiBpdCdzIHNlbGVjdGVkKVxuICAgIGNvbnN0IHNlbGVjdGlvbkluZm8gPSBwcm9wcz8uW0lOVEVSTkFMX0NDX0NBTlZBU19TRUxFQ1RJT05fUFJPUF07XG4gICAgaWYgKHNlbGVjdGlvbkluZm8pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzU2VsZWN0ZWQ6IHNlbGVjdGlvbkluZm8uaXNTZWxlY3RlZCBhcyBib29sZWFuLFxuICAgICAgICBzZWxlY3RlZFNsb3ROYW1lOiBzZWxlY3Rpb25JbmZvLnNlbGVjdGVkU2xvdE5hbWUgYXMgc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sIFtwcm9wc10pO1xufVxuIiwiZXhwb3J0IGNvbnN0IHR1cGxlID0gPFQgZXh0ZW5kcyBhbnlbXT4oLi4uYXJnczogVCk6IFQgPT4gYXJncztcbiIsImltcG9ydCBSZWFjdCwge1xuICBjcmVhdGVDb250ZXh0LFxuICBSZWFjdEVsZW1lbnQsXG4gIFJlYWN0Tm9kZSxcbiAgdXNlQ29udGV4dCxcbn0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB0dXBsZSB9IGZyb20gXCIuL2NvbW1vblwiO1xuXG5leHBvcnQgdHlwZSBEYXRhRGljdCA9IFJlY29yZDxzdHJpbmcsIGFueT47XG5cbmV4cG9ydCBjb25zdCBEYXRhQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8RGF0YURpY3QgfCB1bmRlZmluZWQ+KHVuZGVmaW5lZCk7XG5cbmV4cG9ydCB0eXBlIERhdGFNZXRhID0ge1xuICBhZHZhbmNlZD86IGJvb2xlYW47XG4gIGhpZGRlbj86IGJvb2xlYW47XG4gIGxhYmVsPzogc3RyaW5nO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIG1rTWV0YU5hbWUobmFtZTogc3RyaW5nKSB7XG4gIHJldHVybiBgX19wbGFzbWljX21ldGFfJHtuYW1lfWA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBta01ldGFWYWx1ZShtZXRhOiBQYXJ0aWFsPERhdGFNZXRhPik6IERhdGFNZXRhIHtcbiAgcmV0dXJuIG1ldGE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVNlbGVjdG9yKFxuICByYXdEYXRhOiBEYXRhRGljdCB8IHVuZGVmaW5lZCxcbiAgc2VsZWN0b3I6IHN0cmluZyB8IHVuZGVmaW5lZFxuKTogYW55IHtcbiAgaWYgKCFzZWxlY3Rvcikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgbGV0IGN1ckRhdGEgPSByYXdEYXRhO1xuICBmb3IgKGNvbnN0IGtleSBvZiBzZWxlY3Rvci5zcGxpdChcIi5cIikpIHtcbiAgICBjdXJEYXRhID0gY3VyRGF0YT8uW2tleV07XG4gIH1cbiAgcmV0dXJuIGN1ckRhdGE7XG59XG5cbmV4cG9ydCB0eXBlIFNlbGVjdG9yRGljdCA9IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IHVuZGVmaW5lZD47XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VTZWxlY3RvcihzZWxlY3Rvcjogc3RyaW5nIHwgdW5kZWZpbmVkKTogYW55IHtcbiAgY29uc3QgcmF3RGF0YSA9IHVzZURhdGFFbnYoKTtcbiAgcmV0dXJuIGFwcGx5U2VsZWN0b3IocmF3RGF0YSwgc2VsZWN0b3IpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlU2VsZWN0b3JzKHNlbGVjdG9yczogU2VsZWN0b3JEaWN0ID0ge30pOiBhbnkge1xuICBjb25zdCByYXdEYXRhID0gdXNlRGF0YUVudigpO1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIE9iamVjdC5lbnRyaWVzKHNlbGVjdG9ycylcbiAgICAgIC5maWx0ZXIoKFtrZXksIHNlbGVjdG9yXSkgPT4gISFrZXkgJiYgISFzZWxlY3RvcilcbiAgICAgIC5tYXAoKFtrZXksIHNlbGVjdG9yXSkgPT4gdHVwbGUoa2V5LCBhcHBseVNlbGVjdG9yKHJhd0RhdGEsIHNlbGVjdG9yKSkpXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VEYXRhRW52KCkge1xuICByZXR1cm4gdXNlQ29udGV4dChEYXRhQ29udGV4dCk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF0YVByb3ZpZGVyUHJvcHMge1xuICAvKipcbiAgICogS2V5IHRvIHNldCBpbiBkYXRhIGNvbnRleHQuXG4gICAqL1xuICBuYW1lPzogc3RyaW5nO1xuICAvKipcbiAgICogVmFsdWUgdG8gc2V0IGZvciBgbmFtZWAgaW4gZGF0YSBjb250ZXh0LlxuICAgKi9cbiAgZGF0YT86IGFueTtcbiAgLyoqXG4gICAqIElmIHRydWUsIGhpZGUgdGhpcyBpdGVtIGluIHN0dWRpbyBkYXRhIHBpY2tlci5cbiAgICovXG4gIGhpZGRlbj86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBJZiB0cnVlLCBtYXJrIHRoaXMgaXRlbSBhcyBhZHZhbmNlZCBpbiBzdHVkaW8uXG4gICAqL1xuICBhZHZhbmNlZD86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBMYWJlbCB0byBiZSBzaG93biBpbiB0aGUgc3R1ZGlvIGRhdGEgcGlja2VyIGZvciBlYXNpZXIgbmF2aWdhdGlvbiAoZGF0YSBiaW5kaW5nKS5cbiAgICovXG4gIGxhYmVsPzogc3RyaW5nO1xuICBjaGlsZHJlbj86IFJlYWN0Tm9kZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIERhdGFQcm92aWRlcih7XG4gIG5hbWUsXG4gIGRhdGEsXG4gIGhpZGRlbixcbiAgYWR2YW5jZWQsXG4gIGxhYmVsLFxuICBjaGlsZHJlbixcbn06IERhdGFQcm92aWRlclByb3BzKSB7XG4gIGNvbnN0IGV4aXN0aW5nRW52ID0gdXNlRGF0YUVudigpID8/IHt9O1xuICBpZiAoIW5hbWUpIHtcbiAgICByZXR1cm4gPD57Y2hpbGRyZW59PC8+O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAoXG4gICAgICA8RGF0YUNvbnRleHQuUHJvdmlkZXJcbiAgICAgICAgdmFsdWU9e3tcbiAgICAgICAgICAuLi5leGlzdGluZ0VudixcbiAgICAgICAgICBbbmFtZV06IGRhdGEsXG4gICAgICAgICAgW21rTWV0YU5hbWUobmFtZSldOiBta01ldGFWYWx1ZSh7IGhpZGRlbiwgYWR2YW5jZWQsIGxhYmVsIH0pLFxuICAgICAgICB9fVxuICAgICAgPlxuICAgICAgICB7Y2hpbGRyZW59XG4gICAgICA8L0RhdGFDb250ZXh0LlByb3ZpZGVyPlxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIHRyYW5zZm9ybXMgYHsgXCIuLi5zbHVnXCI6IFwiYS9iL2NcIiB9YCBpbnRvIGB7IFwic2x1Z1wiOiBbXCJhXCIsIFwiYlwiLCBcImNcIl0gfS5cbiAqL1xuZnVuY3Rpb24gZml4Q2F0Y2hhbGxQYXJhbXMoXG4gIHBhcmFtczogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgc3RyaW5nW10gfCB1bmRlZmluZWQ+XG4pIHtcbiAgY29uc3QgbmV3UGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBzdHJpbmdbXT4gPSB7fTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocGFyYW1zKSkge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoXCIuLi5cIikpIHtcbiAgICAgIG5ld1BhcmFtc1trZXkuc2xpY2UoMyldID1cbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgPyB2YWx1ZS5yZXBsYWNlKC9eXFwvfFxcLyQvZywgXCJcIikuc3BsaXQoXCIvXCIpXG4gICAgICAgICAgOiB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3UGFyYW1zW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ld1BhcmFtcztcbn1cblxuZnVuY3Rpb24gbWtQYXRoRnJvbVJvdXRlQW5kUGFyYW1zKFxuICByb3V0ZTogc3RyaW5nLFxuICBwYXJhbXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IHN0cmluZ1tdIHwgdW5kZWZpbmVkPlxuKSB7XG4gIGlmICghcGFyYW1zKSB7XG4gICAgcmV0dXJuIHJvdXRlO1xuICB9XG4gIGxldCBwYXRoID0gcm91dGU7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHBhcmFtcykpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKGBbJHtrZXl9XWAsIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBpZiAocGF0aC5pbmNsdWRlcyhgW1suLi4ke2tleX1dXWApKSB7XG4gICAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoYFtbLi4uJHtrZXl9XV1gLCB2YWx1ZS5qb2luKFwiL1wiKSk7XG4gICAgICB9IGVsc2UgaWYgKHBhdGguaW5jbHVkZXMoYFsuLi4ke2tleX1dYCkpIHtcbiAgICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZShgWy4uLiR7a2V5fV1gLCB2YWx1ZS5qb2luKFwiL1wiKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXRoO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBhZ2VQYXJhbXNQcm92aWRlclByb3BzIHtcbiAgY2hpbGRyZW4/OiBSZWFjdE5vZGU7XG5cbiAgLyoqXG4gICAqIFBhZ2Ugcm91dGUgd2l0aG91dCBwYXJhbXMgc3Vic3RpdHV0ZWQgKGUuZy4gL3Byb2R1Y3RzL1tzbHVnXSkuXG4gICAqL1xuICByb3V0ZT86IHN0cmluZztcblxuICAvKipcbiAgICogUGFnZSBwYXJhbXMgKGUuZy4geyBzbHVnOiBcImphY2tldFwiIH0pXG4gICAqL1xuICBwYXJhbXM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBzdHJpbmdbXSB8IHVuZGVmaW5lZD47XG5cbiAgLyoqXG4gICAqIFBhZ2UgcXVlcnkgcGFyYW1zIChlLmcuIHsgcTogXCJzZWFyY2ggdGVybVwiIH0pXG4gICAqL1xuICBxdWVyeT86IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IHN0cmluZ1tdIHwgdW5kZWZpbmVkPjtcblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGByb3V0ZWAgaW5zdGVhZC5cbiAgICovXG4gIHBhdGg/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBQYWdlUGFyYW1zUHJvdmlkZXIoe1xuICBjaGlsZHJlbixcbiAgcm91dGUsXG4gIHBhdGg6IGRlcHJlY2F0ZWRSb3V0ZSxcbiAgcGFyYW1zID0ge30sXG4gIHF1ZXJ5ID0ge30sXG59OiBQYWdlUGFyYW1zUHJvdmlkZXJQcm9wcykge1xuICByb3V0ZSA9IHJvdXRlID8/IGRlcHJlY2F0ZWRSb3V0ZTtcbiAgcGFyYW1zID0gZml4Q2F0Y2hhbGxQYXJhbXMocGFyYW1zKTtcbiAgY29uc3QgJGN0eCA9IHVzZURhdGFFbnYoKSB8fCB7fTtcbiAgY29uc3QgcGF0aCA9IHJvdXRlID8gbWtQYXRoRnJvbVJvdXRlQW5kUGFyYW1zKHJvdXRlLCBwYXJhbXMpIDogdW5kZWZpbmVkO1xuICByZXR1cm4gKFxuICAgIDxEYXRhUHJvdmlkZXJcbiAgICAgIG5hbWU9e1wicGFnZVJvdXRlXCJ9XG4gICAgICBkYXRhPXtyb3V0ZX1cbiAgICAgIGxhYmVsPXtcIlBhZ2Ugcm91dGVcIn1cbiAgICAgIGFkdmFuY2VkPXt0cnVlfVxuICAgID5cbiAgICAgIDxEYXRhUHJvdmlkZXIgbmFtZT17XCJwYWdlUGF0aFwifSBkYXRhPXtwYXRofSBsYWJlbD17XCJQYWdlIHBhdGhcIn0+XG4gICAgICAgIDxEYXRhUHJvdmlkZXJcbiAgICAgICAgICBuYW1lPXtcInBhcmFtc1wifVxuICAgICAgICAgIGRhdGE9e3sgLi4uJGN0eC5wYXJhbXMsIC4uLnBhcmFtcyB9fVxuICAgICAgICAgIGxhYmVsPXtcIlBhZ2UgVVJMIHBhdGggcGFyYW1zXCJ9XG4gICAgICAgID5cbiAgICAgICAgICA8RGF0YVByb3ZpZGVyXG4gICAgICAgICAgICBuYW1lPXtcInF1ZXJ5XCJ9XG4gICAgICAgICAgICBkYXRhPXt7IC4uLiRjdHgucXVlcnksIC4uLnF1ZXJ5IH19XG4gICAgICAgICAgICBsYWJlbD17XCJQYWdlIFVSTCBxdWVyeSBwYXJhbXNcIn1cbiAgICAgICAgICA+XG4gICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgICAgPC9EYXRhUHJvdmlkZXI+XG4gICAgICAgIDwvRGF0YVByb3ZpZGVyPlxuICAgICAgPC9EYXRhUHJvdmlkZXI+XG4gICAgPC9EYXRhUHJvdmlkZXI+XG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBEYXRhQ3R4UmVhZGVyKHtcbiAgY2hpbGRyZW4sXG59OiB7XG4gIGNoaWxkcmVuOiAoJGN0eDogRGF0YURpY3QgfCB1bmRlZmluZWQpID0+IFJlYWN0Tm9kZTtcbn0pIHtcbiAgY29uc3QgJGN0eCA9IHVzZURhdGFFbnYoKTtcbiAgcmV0dXJuIGNoaWxkcmVuKCRjdHgpIGFzIFJlYWN0RWxlbWVudCB8IG51bGw7XG59XG4iLCJpbXBvcnQgeyBQcmltaXRpdmVUeXBlIH0gZnJvbSBcIi4vcHJvcC10eXBlc1wiO1xuXG5jb25zdCByb290ID0gZ2xvYmFsVGhpcyBhcyBhbnk7XG5cbmV4cG9ydCB0eXBlIEZldGNoZXIgPSAoLi4uYXJnczogYW55W10pID0+IFByb21pc2U8YW55PjtcblxuZXhwb3J0IGludGVyZmFjZSBGZXRjaGVyTWV0YSB7XG4gIC8qKlxuICAgKiBBbnkgdW5pcXVlIGlkZW50aWZ5aW5nIHN0cmluZyBmb3IgdGhpcyBmZXRjaGVyLlxuICAgKi9cbiAgbmFtZTogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIFN0dWRpby11c2VyLWZyaWVuZGx5IGRpc3BsYXkgbmFtZS5cbiAgICovXG4gIGRpc3BsYXlOYW1lPzogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIHN5bWJvbCB0byBpbXBvcnQgZnJvbSB0aGUgaW1wb3J0UGF0aC5cbiAgICovXG4gIGltcG9ydE5hbWU/OiBzdHJpbmc7XG4gIGFyZ3M6IHsgbmFtZTogc3RyaW5nOyB0eXBlOiBQcmltaXRpdmVUeXBlIH1bXTtcbiAgcmV0dXJuczogUHJpbWl0aXZlVHlwZTtcbiAgLyoqXG4gICAqIEVpdGhlciB0aGUgcGF0aCB0byB0aGUgZmV0Y2hlciByZWxhdGl2ZSB0byBgcm9vdERpcmAgb3IgdGhlIG5wbVxuICAgKiBwYWNrYWdlIG5hbWVcbiAgICovXG4gIGltcG9ydFBhdGg6IHN0cmluZztcbiAgLyoqXG4gICAqIFdoZXRoZXIgaXQncyBhIGRlZmF1bHQgZXhwb3J0IG9yIG5hbWVkIGV4cG9ydFxuICAgKi9cbiAgaXNEZWZhdWx0RXhwb3J0PzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGZXRjaGVyUmVnaXN0cmF0aW9uIHtcbiAgZmV0Y2hlcjogRmV0Y2hlcjtcbiAgbWV0YTogRmV0Y2hlck1ldGE7XG59XG5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgaW50ZXJmYWNlIFdpbmRvdyB7XG4gICAgX19QbGFzbWljRmV0Y2hlclJlZ2lzdHJ5OiBGZXRjaGVyUmVnaXN0cmF0aW9uW107XG4gIH1cbn1cblxucm9vdC5fX1BsYXNtaWNGZXRjaGVyUmVnaXN0cnkgPSBbXTtcblxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyRmV0Y2hlcihmZXRjaGVyOiBGZXRjaGVyLCBtZXRhOiBGZXRjaGVyTWV0YSkge1xuICByb290Ll9fUGxhc21pY0ZldGNoZXJSZWdpc3RyeS5wdXNoKHsgZmV0Y2hlciwgbWV0YSB9KTtcbn1cbiIsImltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcblxuZXhwb3J0IHR5cGUgR2xvYmFsQWN0aW9uRGljdCA9IFJlY29yZDxzdHJpbmcsIEZ1bmN0aW9uPjtcblxuZXhwb3J0IGNvbnN0IEdsb2JhbEFjdGlvbnNDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dDxcbiAgR2xvYmFsQWN0aW9uRGljdCB8IHVuZGVmaW5lZFxuPih1bmRlZmluZWQpO1xuXG5leHBvcnQgZnVuY3Rpb24gR2xvYmFsQWN0aW9uc1Byb3ZpZGVyKHByb3BzOiB7XG4gIGNvbnRleHROYW1lOiBzdHJpbmc7XG4gIGNoaWxkcmVuPzogUmVhY3QuUmVhY3ROb2RlO1xuICBhY3Rpb25zOiBHbG9iYWxBY3Rpb25EaWN0O1xufSkge1xuICBjb25zdCB7IGNvbnRleHROYW1lLCBjaGlsZHJlbiwgYWN0aW9ucyB9ID0gcHJvcHM7XG4gIGNvbnN0IGV4aXN0aW5nQWN0aW9ucyA9IHVzZUdsb2JhbEFjdGlvbnMoKTtcbiAgY29uc3QgbmFtZXNwYWNlZEFjdGlvbnMgPSBSZWFjdC51c2VNZW1vKFxuICAgICgpID0+XG4gICAgICBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGFjdGlvbnMpLm1hcCgoW2tleSwgdmFsXSkgPT4gW1xuICAgICAgICAgIGAke2NvbnRleHROYW1lfS4ke2tleX1gLFxuICAgICAgICAgIHZhbCxcbiAgICAgICAgXSlcbiAgICAgICksXG4gICAgW2NvbnRleHROYW1lLCBhY3Rpb25zXVxuICApO1xuICByZXR1cm4gKFxuICAgIDxHbG9iYWxBY3Rpb25zQ29udGV4dC5Qcm92aWRlclxuICAgICAgdmFsdWU9e3tcbiAgICAgICAgLi4uZXhpc3RpbmdBY3Rpb25zLFxuICAgICAgICAuLi5uYW1lc3BhY2VkQWN0aW9ucyxcbiAgICAgIH19XG4gICAgPlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvR2xvYmFsQWN0aW9uc0NvbnRleHQuUHJvdmlkZXI+XG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VHbG9iYWxBY3Rpb25zKCkge1xuICByZXR1cm4gUmVhY3QudXNlQ29udGV4dChHbG9iYWxBY3Rpb25zQ29udGV4dCkgPz8ge307XG59XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5cbmNvbnN0IFBsYXNtaWNMaW5rQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8XG4gIFJlYWN0LkNvbXBvbmVudFR5cGU8YW55PiB8IHVuZGVmaW5lZFxuPih1bmRlZmluZWQpO1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlUGxhc21pY0xpbmtNYXliZSgpOlxuICB8IFJlYWN0LkNvbXBvbmVudFR5cGU8UmVhY3QuQ29tcG9uZW50UHJvcHM8XCJhXCI+PlxuICB8IHVuZGVmaW5lZCB7XG4gIHJldHVybiBSZWFjdC51c2VDb250ZXh0KFBsYXNtaWNMaW5rQ29udGV4dCk7XG59XG5cbmNvbnN0IEFuY2hvckxpbmsgPSBSZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIEFuY2hvckxpbmsoXG4gIHByb3BzOiBSZWFjdC5Db21wb25lbnRQcm9wczxcImFcIj4sXG4gIHJlZjogUmVhY3QuUmVmPEhUTUxBbmNob3JFbGVtZW50PlxuKSB7XG4gIHJldHVybiA8YSB7Li4ucHJvcHN9IHJlZj17cmVmfSAvPjtcbn0pO1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlUGxhc21pY0xpbmsoKTogUmVhY3QuQ29tcG9uZW50VHlwZTxcbiAgUmVhY3QuQ29tcG9uZW50UHJvcHM8XCJhXCI+XG4+IHtcbiAgY29uc3QgTGluayA9IFJlYWN0LnVzZUNvbnRleHQoUGxhc21pY0xpbmtDb250ZXh0KTtcbiAgaWYgKExpbmspIHtcbiAgICByZXR1cm4gTGluaztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gQW5jaG9yTGluayBhcyBSZWFjdC5Db21wb25lbnRUeXBlPFJlYWN0LkNvbXBvbmVudFByb3BzPFwiYVwiPj47XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFBsYXNtaWNMaW5rUHJvdmlkZXIocHJvcHM6IHtcbiAgTGluazogUmVhY3QuQ29tcG9uZW50VHlwZTxhbnk+IHwgdW5kZWZpbmVkO1xuICBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZTtcbn0pIHtcbiAgY29uc3QgeyBMaW5rLCBjaGlsZHJlbiB9ID0gcHJvcHM7XG4gIHJldHVybiAoXG4gICAgPFBsYXNtaWNMaW5rQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17TGlua30+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9QbGFzbWljTGlua0NvbnRleHQuUHJvdmlkZXI+XG4gICk7XG59XG4iLCJpbXBvcnQgeyBDb2RlQ29tcG9uZW50RWxlbWVudCwgQ1NTUHJvcGVydGllcyB9IGZyb20gXCIuL2VsZW1lbnQtdHlwZXNcIjtcbmltcG9ydCB7XG4gIENvbnRleHREZXBlbmRlbnRDb25maWcsXG4gIEluZmVyRGF0YVR5cGUsXG4gIFByb2plY3REYXRhLFxuICBQcm9wVHlwZSxcbiAgUmVzdHJpY3RQcm9wVHlwZSxcbiAgU3R1ZGlvT3BzLFxufSBmcm9tIFwiLi9wcm9wLXR5cGVzXCI7XG5pbXBvcnQgeyBUdXBsZVVuaW9uIH0gZnJvbSBcIi4vdHlwZS11dGlsc1wiO1xuZXhwb3J0IHR5cGUgKiBmcm9tIFwiLi9wcm9wLXR5cGVzXCI7XG5cbmNvbnN0IHJvb3QgPSBnbG9iYWxUaGlzIGFzIGFueTtcblxuZXhwb3J0IGludGVyZmFjZSBBY3Rpb25Qcm9wczxQPiB7XG4gIGNvbXBvbmVudFByb3BzOiBQO1xuICAvKipcbiAgICogYGNvbnRleHREYXRhYCBjYW4gYmUgYG51bGxgIGlmIHRoZSBwcm9wIGNvbnRyb2xzIGFyZSByZW5kZXJpbmcgYmVmb3JlXG4gICAqIHRoZSBjb21wb25lbnQgaW5zdGFuY2UgaXRzZWxmIChpdCB3aWxsIHJlLXJlbmRlciBvbmNlIHRoZSBjb21wb25lbnRcbiAgICogY2FsbHMgYHNldENvbnRyb2xDb250ZXh0RGF0YWApXG4gICAqL1xuICBjb250ZXh0RGF0YTogSW5mZXJEYXRhVHlwZTxQPiB8IG51bGw7XG4gIC8qKlxuICAgKiBPcGVyYXRpb25zIGF2YWlsYWJsZSB0byB0aGUgZWRpdG9yIHRoYXQgYWxsb3cgbW9kaWZ5aW5nIHRoZSBlbnRpcmUgY29tcG9uZW50LlxuICAgKi9cbiAgc3R1ZGlvT3BzOiBTdHVkaW9PcHM7XG4gIC8qKlxuICAgKiBNZXRhZGF0YSBmcm9tIHRoZSBzdHVkaW8gcHJvamVjdC5cbiAgICovXG4gIHByb2plY3REYXRhOiBQcm9qZWN0RGF0YTtcbiAgLyoqXG4gICAqIFRoZSBkb2N1bWVudCB0aGF0IHRoZSBjb21wb25lbnQgd2lsbCBiZSByZW5kZXJlZCBpbnRvOyBpbnN0ZWFkIG9mIHVzaW5nXG4gICAqIGBkb2N1bWVudGAgZGlyZWN0bHkgKGZvciwgc2F5LCBgZG9jdW1lbnQucXVlcnlTZWxlY3RvcigpYCBldGMuKSwgeW91XG4gICAqIHNob3VsZCB1c2UgdGhpcyBpbnN0ZWFkLlxuICAgKi9cbiAgc3R1ZGlvRG9jdW1lbnQ6IHR5cGVvZiBkb2N1bWVudDtcbn1cblxuZXhwb3J0IHR5cGUgQWN0aW9uPFA+ID1cbiAgfCB7XG4gICAgICB0eXBlOiBcImJ1dHRvbi1hY3Rpb25cIjtcbiAgICAgIGxhYmVsOiBzdHJpbmc7XG4gICAgICBvbkNsaWNrOiAocHJvcHM6IEFjdGlvblByb3BzPFA+KSA9PiB2b2lkO1xuICAgICAgaGlkZGVuPzogQ29udGV4dERlcGVuZGVudENvbmZpZzxQLCBib29sZWFuPjtcbiAgICB9XG4gIHwge1xuICAgICAgdHlwZTogXCJjdXN0b20tYWN0aW9uXCI7XG4gICAgICBjb250cm9sOiBSZWFjdC5Db21wb25lbnRUeXBlPEFjdGlvblByb3BzPFA+PjtcbiAgICAgIGhpZGRlbj86IENvbnRleHREZXBlbmRlbnRDb25maWc8UCwgYm9vbGVhbj47XG4gICAgfTtcblxudHlwZSBEaXN0cmlidXRlZEtleU9mPFQ+ID0gVCBleHRlbmRzIGFueSA/IGtleW9mIFQgOiBuZXZlcjtcblxuaW50ZXJmYWNlIENvbXBvbmVudFRlbXBsYXRlPFA+XG4gIGV4dGVuZHMgT21pdDxDb2RlQ29tcG9uZW50RWxlbWVudDxQPiwgXCJ0eXBlXCIgfCBcIm5hbWVcIj4ge1xuICAvKipcbiAgICogQSBwcmV2aWV3IHBpY3R1cmUgZm9yIHRoZSB0ZW1wbGF0ZS5cbiAgICovXG4gIHByZXZpZXdJbWc/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29tcG9uZW50VGVtcGxhdGVzPFA+IHtcbiAgW25hbWU6IHN0cmluZ106IENvbXBvbmVudFRlbXBsYXRlPFA+O1xufVxuXG5leHBvcnQgdHlwZSBTdGF0ZVNwZWM8UD4gPSB7XG4gIG9uQ2hhbmdlUHJvcDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBJZiB0cnVlLCB3aWxsIGhpZGUgdGhlIHN0YXRlIG9uIHN0dWRpby5cbiAgICovXG4gIGhpZGRlbj86IENvbnRleHREZXBlbmRlbnRDb25maWc8UCwgYm9vbGVhbj47XG5cbiAgLyoqXG4gICAqIElmIHRydWUsIHdpbGwgaGlkZSB0aGUgc3RhdGUgaW4gYSBjb2xsYXBzZWQgc2VjdGlvbjsgZ29vZCBmb3Igc3RhdGVzIHRoYXRcbiAgICogc2hvdWxkIG5vdCB1c3VhbGx5IGJlIHVzZWQuXG4gICAqL1xuICBhZHZhbmNlZD86IENvbnRleHREZXBlbmRlbnRDb25maWc8UCwgYm9vbGVhbj47XG59ICYgKFxuICB8IHtcbiAgICAgIHR5cGU6IFwicmVhZG9ubHlcIjtcbiAgICAgIHZhcmlhYmxlVHlwZTogXCJ0ZXh0XCI7XG4gICAgICBpbml0VmFsPzogc3RyaW5nO1xuICAgIH1cbiAgfCB7XG4gICAgICB0eXBlOiBcInJlYWRvbmx5XCI7XG4gICAgICB2YXJpYWJsZVR5cGU6IFwibnVtYmVyXCI7XG4gICAgICBpbml0VmFsPzogbnVtYmVyO1xuICAgIH1cbiAgfCB7XG4gICAgICB0eXBlOiBcInJlYWRvbmx5XCI7XG4gICAgICB2YXJpYWJsZVR5cGU6IFwiYm9vbGVhblwiO1xuICAgICAgaW5pdFZhbD86IGJvb2xlYW47XG4gICAgfVxuICB8IHtcbiAgICAgIHR5cGU6IFwicmVhZG9ubHlcIjtcbiAgICAgIHZhcmlhYmxlVHlwZTogXCJhcnJheVwiO1xuICAgICAgaW5pdFZhbD86IGFueVtdO1xuICAgIH1cbiAgfCB7XG4gICAgICB0eXBlOiBcInJlYWRvbmx5XCI7XG4gICAgICB2YXJpYWJsZVR5cGU6IFwib2JqZWN0XCI7XG4gICAgICBpbml0VmFsPzogb2JqZWN0O1xuICAgIH1cbiAgfCB7XG4gICAgICB0eXBlOiBcInJlYWRvbmx5XCI7XG4gICAgICB2YXJpYWJsZVR5cGU6IFwiZGF0ZVN0cmluZ1wiO1xuICAgICAgaW5pdFZhbD86IHN0cmluZztcbiAgICB9XG4gIHwge1xuICAgICAgdHlwZTogXCJyZWFkb25seVwiO1xuICAgICAgdmFyaWFibGVUeXBlOiBcImRhdGVSYW5nZVN0cmluZ3NcIjtcbiAgICAgIGluaXRWYWw/OiBbc3RyaW5nLCBzdHJpbmddO1xuICAgIH1cbiAgfCB7XG4gICAgICB0eXBlOiBcIndyaXRhYmxlXCI7XG4gICAgICB2YXJpYWJsZVR5cGU6XG4gICAgICAgIHwgXCJ0ZXh0XCJcbiAgICAgICAgfCBcIm51bWJlclwiXG4gICAgICAgIHwgXCJib29sZWFuXCJcbiAgICAgICAgfCBcImFycmF5XCJcbiAgICAgICAgfCBcIm9iamVjdFwiXG4gICAgICAgIHwgXCJkYXRlU3RyaW5nXCJcbiAgICAgICAgfCBcImRhdGVSYW5nZVN0cmluZ3NcIjtcbiAgICAgIHZhbHVlUHJvcDogc3RyaW5nO1xuICAgIH1cbik7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RhdGVIZWxwZXJzPFAsIFQ+IHtcbiAgaW5pdEZ1bmM/OiAoJHByb3BzOiBQKSA9PiBUO1xuICBvbkNoYW5nZUFyZ3NUb1ZhbHVlPzogKC4uLmFyZ3M6IGFueSkgPT4gVDtcbiAgb25NdXRhdGU/OiAoc3RhdGVWYWx1ZTogVCwgJHJlZjogYW55KSA9PiB2b2lkO1xufVxuXG4vLyBBIGNvbXBpbGUtdGltZSBlcnJvciB3aWxsIG9jY3VyIGlmIGEgbmV3IGZpZWxkIGlzIGFkZGVkIHRvIHRoZSBTdGF0ZUhlbHBlclxuLy8gaW50ZXJmYWNlIGJ1dCBub3QgaW5jbHVkZWQgaW4gdGhlIGtleXMgYXJyYXkgb2Ygc3RhdGUgaGVscGVyLlxuZXhwb3J0IGNvbnN0IHN0YXRlSGVscGVyc0tleXM6IFR1cGxlVW5pb248a2V5b2YgU3RhdGVIZWxwZXJzPGFueSwgYW55Pj4gPSBbXG4gIFwiaW5pdEZ1bmNcIixcbiAgXCJvbkNoYW5nZUFyZ3NUb1ZhbHVlXCIsXG4gIFwib25NdXRhdGVcIixcbl07XG5cbmV4cG9ydCB0eXBlIENvbXBvbmVudEhlbHBlcnM8UD4gPSB7XG4gIHN0YXRlczogUmVjb3JkPHN0cmluZywgU3RhdGVIZWxwZXJzPFAsIGFueT4+O1xufTtcblxuZXhwb3J0IHR5cGUgRXh0ZXJuYWxDb21wb25lbnRIZWxwZXJzPFA+ID0ge1xuICBoZWxwZXJzOiBDb21wb25lbnRIZWxwZXJzPFA+O1xuICBpbXBvcnRQYXRoOiBzdHJpbmc7XG59ICYgKFxuICB8IHtcbiAgICAgIGltcG9ydE5hbWU6IHN0cmluZztcbiAgICB9XG4gIHwge1xuICAgICAgaXNEZWZhdWx0RXhwb3J0OiB0cnVlO1xuICAgIH1cbik7XG5cbmV4cG9ydCB0eXBlIFN0eWxlU2VjdGlvbiA9XG4gIHwgXCJ2aXNpYmlsaXR5XCJcbiAgfCBcInR5cG9ncmFwaHlcIlxuICB8IFwic2l6aW5nXCJcbiAgfCBcInNwYWNpbmdcIlxuICB8IFwiYmFja2dyb3VuZFwiXG4gIHwgXCJ0cmFuc2Zvcm1cIlxuICB8IFwidHJhbnNpdGlvbnNcIlxuICB8IFwibGF5b3V0XCJcbiAgfCBcIm92ZXJmbG93XCJcbiAgfCBcImJvcmRlclwiXG4gIHwgXCJzaGFkb3dzXCJcbiAgfCBcImVmZmVjdHNcIjtcblxuZXhwb3J0IGludGVyZmFjZSBDb2RlQ29tcG9uZW50TWV0YTxQPiB7XG4gIC8qKlxuICAgKiBBbnkgdW5pcXVlIHN0cmluZyBuYW1lIHVzZWQgdG8gaWRlbnRpZnkgdGhhdCBjb21wb25lbnQuIEVhY2ggY29tcG9uZW50XG4gICAqIHNob3VsZCBiZSByZWdpc3RlcmVkIHdpdGggYSBkaWZmZXJlbnQgYG1ldGEubmFtZWAsIGV2ZW4gaWYgdGhleSBoYXZlIHRoZVxuICAgKiBzYW1lIG5hbWUgaW4gdGhlIGNvZGUuXG4gICAqL1xuICBuYW1lOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgbmFtZSB0byBiZSBkaXNwbGF5ZWQgZm9yIHRoZSBjb21wb25lbnQgaW4gU3R1ZGlvLiBPcHRpb25hbDogaWYgbm90XG4gICAqIHNwZWNpZmllZCwgYG1ldGEubmFtZWAgaXMgdXNlZC5cbiAgICovXG4gIGRpc3BsYXlOYW1lPzogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBjb21wb25lbnQgdG8gYmUgc2hvd24gaW4gU3R1ZGlvLlxuICAgKi9cbiAgZGVzY3JpcHRpb24/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBBIHNwZWNpZmljIHNlY3Rpb24gdG8gd2hpY2ggdGhlIGNvbXBvbmVudCBzaG91bGQgYmUgZGlzcGxheWVkIGluIFN0dWRpby4gQnkgZGVmYXVsdCwgdGhlIGNvbXBvbmVudCB3aWxsIGJlIGRpc3BsYXllZCBpbiB0aGUgXCJDdXN0b20gQ29tcG9uZW50c1wiIHNlY3Rpb24uXG4gICAqIEEgbmV3IHNlY3Rpb24gd2lsbCBiZSBjcmVhdGVkIHRvIGRpc3BsYXkgdGhlIGNvbXBvbmVudHMgd2l0aCB0aGUgc2FtZSBgc2VjdGlvbmAgdmFsdWUuXG4gICAqL1xuICBzZWN0aW9uPzogc3RyaW5nO1xuICAvKipcbiAgICogQSBsaW5rIHRvIGFuIGltYWdlIHRoYXQgd2lsbCBiZSBkaXNwbGF5ZWQgYXMgYSB0aHVtYm5haWwgb2YgdGhlIGNvbXBvbmVudCBpbiB0aGUgU3R1ZGlvLCBpZiB0aGUgY29tcG9uZW50IGhhcyBhIGBzZWN0aW9uYCBzcGVjaWZpZWQuXG4gICAqL1xuICB0aHVtYm5haWxVcmw/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgamF2YXNjcmlwdCBuYW1lIHRvIGJlIHVzZWQgd2hlbiBnZW5lcmF0aW5nIGNvZGUuIE9wdGlvbmFsOiBpZiBub3RcbiAgICogcHJvdmlkZWQsIGBtZXRhLm5hbWVgIGlzIHVzZWQuXG4gICAqL1xuICBpbXBvcnROYW1lPzogc3RyaW5nO1xuICAvKipcbiAgICogQW4gb2JqZWN0IGRlc2NyaWJpbmcgdGhlIGNvbXBvbmVudCBwcm9wZXJ0aWVzIHRvIGJlIHVzZWQgaW4gU3R1ZGlvLlxuICAgKiBGb3IgZWFjaCBgcHJvcGAsIHRoZXJlIHNob3VsZCBiZSBhbiBlbnRyeSBgbWV0YS5wcm9wc1twcm9wXWAgZGVzY3JpYmluZ1xuICAgKiBpdHMgdHlwZS5cbiAgICovXG4gIHByb3BzOiB7IFtwcm9wIGluIERpc3RyaWJ1dGVkS2V5T2Y8UD5dPzogUmVzdHJpY3RQcm9wVHlwZTxQW3Byb3BdLCBQPiB9ICYge1xuICAgIFtwcm9wOiBzdHJpbmddOiBQcm9wVHlwZTxQPjtcbiAgfTtcbiAgLyoqXG4gICAqIEFuIG9iamVjdCBkZXNjcmliaW5nIHRoZSBjb21wb25lbnQgc3RhdGVzIHRvIGJlIHVzZWQgaW4gU3R1ZGlvLlxuICAgKi9cbiAgc3RhdGVzPzogUmVjb3JkPHN0cmluZywgU3RhdGVTcGVjPFA+PjtcbiAgLyoqXG4gICAqIEFuIG9iamVjdCBkZXNjcmliaW5nIHRoZSBjb21wb25lbnRzIGhlbHBlcnMgdG8gYmUgdXNlZCBpbiBTdHVkaW8uXG4gICAqICAgMS4gc3RhdGVzIGhlbHBlcnM6IEVhY2ggc3RhdGUgY2FuIHJlY2VpdmUgYW4gXCJpbml0RnVuY1wiIHByb3AgdG8gaW5pdGlhbGl6ZVxuICAgKiAgICAgIHRoZSBpbXBsaWNpdCBzdGF0ZSBpbiBTdHVkaW8sIGFuZCBhbiBcIm9uQ2hhbmdlQXJnc1RvVmFsdWVcIiBwcm9wIHRvXG4gICAqICAgICAgdHJhbnNmb3JtIHRoZSBldmVudCBoYW5kbGVyIGFyZ3VtZW50cyBpbnRvIGEgdmFsdWVcbiAgICovXG4gIGNvbXBvbmVudEhlbHBlcnM/OiBFeHRlcm5hbENvbXBvbmVudEhlbHBlcnM8UD47XG4gIC8qKlxuICAgKiBBbiBhcnJheSBkZXNjcmliaW5nIHRoZSBjb21wb25lbnQgYWN0aW9ucyB0byBiZSB1c2VkIGluIFN0dWRpby5cbiAgICovXG4gIGFjdGlvbnM/OiBBY3Rpb248UD5bXTtcbiAgLyoqXG4gICAqIFdoZXRoZXIgc3R5bGUgc2VjdGlvbnMgc2hvdWxkIGJlIHNob3duIGluIFN0dWRpby4gRm9yIHN0eWxlcyB0byB3b3JrLCB0aGVcbiAgICogY29tcG9uZW50IG11c3QgYWNjZXB0IGEgYGNsYXNzTmFtZWAgcHJvcC4gSWYgdW5zZXQsIGRlZmF1bHRzIHRvIGFsbCBzdHlsZXMuXG4gICAqIFNldCB0byBgZmFsc2VgIGlmIHRoaXMgY29tcG9uZW50IGNhbm5vdCBiZSBzdHlsZWQgKGZvciBleGFtcGxlLCBpZiBpdCBkb2Vzbid0XG4gICAqIHJlbmRlciBhbnkgRE9NIGVsZW1lbnRzKS5cbiAgICovXG4gIHN0eWxlU2VjdGlvbnM/OiBTdHlsZVNlY3Rpb25bXSB8IGJvb2xlYW47XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBlbGVtZW50IGNhbiBiZSByZXBlYXRlZCBpbiBTdHVkaW8uIElmIHVuc2V0LCBkZWZhdWx0cyB0byB0cnVlLlxuICAgKi9cbiAgaXNSZXBlYXRhYmxlPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIFRoZSBwYXRoIHRvIGJlIHVzZWQgd2hlbiBpbXBvcnRpbmcgdGhlIGNvbXBvbmVudCBpbiB0aGUgZ2VuZXJhdGVkIGNvZGUuXG4gICAqIEl0IGNhbiBiZSB0aGUgbmFtZSBvZiB0aGUgcGFja2FnZSB0aGF0IGNvbnRhaW5zIHRoZSBjb21wb25lbnQsIG9yIHRoZSBwYXRoXG4gICAqIHRvIHRoZSBmaWxlIGluIHRoZSBwcm9qZWN0IChyZWxhdGl2ZSB0byB0aGUgcm9vdCBkaXJlY3RvcnkpLlxuICAgKi9cbiAgaW1wb3J0UGF0aDogc3RyaW5nO1xuICAvKipcbiAgICogIFdoZXRoZXIgdGhlIGNvbXBvbmVudCBpcyB0aGUgZGVmYXVsdCBleHBvcnQgZnJvbSB0aGF0IHBhdGguIE9wdGlvbmFsOiBpZlxuICAgKiBub3Qgc3BlY2lmaWVkLCBpdCdzIGNvbnNpZGVyZWQgYGZhbHNlYC5cbiAgICovXG4gIGlzRGVmYXVsdEV4cG9ydD86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBUaGUgcHJvcCB0aGF0IGV4cGVjdHMgdGhlIENTUyBjbGFzc2VzIHdpdGggc3R5bGVzIHRvIGJlIGFwcGxpZWQgdG8gdGhlXG4gICAqIGNvbXBvbmVudC4gT3B0aW9uYWw6IGlmIG5vdCBzcGVjaWZpZWQsIFBsYXNtaWMgd2lsbCBleHBlY3QgaXQgdG8gYmVcbiAgICogYGNsYXNzTmFtZWAuIE5vdGljZSB0aGF0IGlmIHRoZSBjb21wb25lbnQgZG9lcyBub3QgYWNjZXB0IENTUyBjbGFzc2VzLCB0aGVcbiAgICogY29tcG9uZW50IHdpbGwgbm90IGJlIGFibGUgdG8gcmVjZWl2ZSBzdHlsZXMgZnJvbSB0aGUgU3R1ZGlvLlxuICAgKi9cbiAgY2xhc3NOYW1lUHJvcD86IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSBwcm9wIHRoYXQgcmVjZWl2ZXMgYW5kIGZvcndhcmRzIGEgUmVhY3QgYHJlZmAuIFBsYXNtaWMgb25seSB1c2VzIGByZWZgXG4gICAqIHRvIGludGVyYWN0IHdpdGggY29tcG9uZW50cywgc28gaXQncyBub3QgdXNlZCBpbiB0aGUgZ2VuZXJhdGVkIGNvZGUuXG4gICAqIE9wdGlvbmFsOiBJZiBub3QgcHJvdmlkZWQsIHRoZSB1c3VhbCBgcmVmYCBpcyB1c2VkLlxuICAgKi9cbiAgcmVmUHJvcD86IHN0cmluZztcbiAgLyoqXG4gICAqIERlZmF1bHQgc3R5bGVzIHRvIHN0YXJ0IHdpdGggd2hlbiBpbnN0YW50aWF0aW5nIHRoZSBjb21wb25lbnQgaW4gUGxhc21pYy5cbiAgICovXG4gIGRlZmF1bHRTdHlsZXM/OiBDU1NQcm9wZXJ0aWVzO1xuICAvKipcbiAgICogQ29tcG9uZW50IHRlbXBsYXRlcyB0byBzdGFydCB3aXRoIG9uIFBsYXNtaWMuXG4gICAqL1xuICB0ZW1wbGF0ZXM/OiBDb21wb25lbnRUZW1wbGF0ZXM8UD47XG4gIC8qKlxuICAgKiBSZWdpc3RlcmVkIG5hbWUgb2YgcGFyZW50IGNvbXBvbmVudCwgdXNlZCBmb3IgZ3JvdXBpbmcgcmVsYXRlZCBjb21wb25lbnRzLlxuICAgKi9cbiAgcGFyZW50Q29tcG9uZW50TmFtZT86IHN0cmluZztcbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIGNvbXBvbmVudCBjYW4gYmUgdXNlZCBhcyBhbiBhdHRhY2htZW50IHRvIGFuIGVsZW1lbnQuXG4gICAqL1xuICBpc0F0dGFjaG1lbnQ/OiBib29sZWFuO1xuICAvKipcbiAgICogV2hldGhlciB0aGUgY29tcG9uZW50IHByb3ZpZGVzIGRhdGEgdG8gaXRzIHNsb3RzIHVzaW5nIERhdGFQcm92aWRlci5cbiAgICovXG4gIHByb3ZpZGVzRGF0YT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIElmIHNwZWNpZmllZCwgdGhlbiBGaWdtYSBjb21wb25lbnRzIHdpdGggdGhlIHNwZWNpZmllZCBuYW1lcyB3aWxsIGJlIG1hcHBlZFxuICAgKiB0byB0aGlzIGNvbXBvbmVudCB3aGVuIHlvdSBwYXN0ZSBGaWdtYSBjb250ZW50IGludG8gUGxhc21pY1xuICAgKi9cbiAgZmlnbWFNYXBwaW5ncz86IHtcbiAgICBmaWdtYUNvbXBvbmVudE5hbWU6IHN0cmluZztcbiAgfVtdO1xuXG4gIC8qKlxuICAgKiBJZiBzcGVjaWZpZWQsIHRoZW4gRmlnbWEgY29tcG9uZW50cyB3aWxsIGhhdmUgdGhlaXIgcHJvcGVydGllcyB0cmFuc2Zvcm1lZFxuICAgKiBiZWZvcmUgYmVpbmcgYXBwbGllZCB0byB0aGlzIGNvbXBvbmVudC4gVGhpcyBpcyB1c2VmdWwgZm9yIHRyYW5zZm9ybWluZyBGaWdtYVxuICAgKiBwcm9wZXJ0aWVzIHRvIHRoZSBmb3JtYXQgZXhwZWN0ZWQgYnkgdGhlIGNvbXBvbmVudC5cbiAgICovXG4gIGZpZ21hUHJvcHNUcmFuc2Zvcm0/OiAoXG4gICAgcHJvcHM6IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4+XG4gICkgPT4gUmVjb3JkPFxuICAgIHN0cmluZyxcbiAgICBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgbnVsbCB8IHVua25vd25bXSB8IFJlY29yZDxzdHJpbmcsIHVua25vd24+XG4gID47XG5cbiAgLyoqXG4gICAqIElmIHRydWUsIHdoZW4gYW4gaW5zdGFuY2Ugb2YgdGhpcyBjb21wb25lbnQgaXMgYWRkZWQsIHRoZSBlbGVtZW50XG4gICAqIHdpbGwgYWx3YXlzIGJlIG5hbWVkIGJ5IHRoZSBuYW1lIG9mIHRoaXMgY29tcG9uZW50LlxuICAgKi9cbiAgYWx3YXlzQXV0b05hbWU/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBJZiB0cnVlLCB0aGVuIHdvbid0IGJlIGxpc3RlZCBpbiB0aGUgaW5zZXJ0IG1lbnUgZm9yIGNvbnRlbnQgY3JlYXRvcnMuXG4gICAqL1xuICBoaWRlRnJvbUNvbnRlbnRDcmVhdG9ycz86IGJvb2xlYW47XG5cbiAgcmVmQWN0aW9ucz86IFJlY29yZDxzdHJpbmcsIFJlZkFjdGlvblJlZ2lzdHJhdGlvbjxQPj47XG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsIGZ1bmN0aW9uIHRoYXQgdGFrZXMgaW4gY29tcG9uZW50IHByb3BzIGFuZCBjb250ZXh0LCBhbmQgcmV0dXJuc1xuICAgKiBhIHN0cmluZyB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgbGFiZWxpbmcgdGhpcyBlbGVtZW50IGluIHRoZSBPdXRsaW5lIHBhbmVsXG4gICAqIG9uIHRoZSBsZWZ0IG9mIHRoZSBTdHVkaW8uICBUaGlzIG1ha2VzIGl0IGVhc3kgdG8gaWRlbnRpZnkgYW4gZWxlbWVudCB3aGVuXG4gICAqIGxvb2tpbmcgYXQgdGhlIHRyZWUuXG4gICAqL1xuICB0cmVlTGFiZWw/OiBDb250ZXh0RGVwZW5kZW50Q29uZmlnPFAsIHN0cmluZz47XG5cbiAgLyoqXG4gICAqIFRoZSB2YWx1ZSBvZiB0aGUgQ1NTIGRpc3BsYXkgcHJvcGVydHkgdXNlZCBieSB0aGlzIGNvbXBvbmVudC5cbiAgICogUGxhc21pYyBwYXNzZXMgaW4gYSBjbGFzcyBuYW1lIHByb3AgdG8gY29tcG9uZW50cyB0byBsZXQgdXNlcnMgc3R5bGUgdGhlbSxcbiAgICogYnV0IG5vcm1hbGx5IHRoaXMgZG9lcyBub3QgaW5jbHVkZSBsYXlvdXQgcHJvcGVydGllcyBsaWtlIGRpc3BsYXkuXG4gICAqIEhvd2V2ZXIsIGlmIHRoZSB1c2VyIGhhcyBzZXQgdGhlIGNvbXBvbmVudHMgdmlzaWJpbGl0eSB0byBiZSB2aXNpYmxlXG4gICAqIChmb3IgaW5zdGFuY2UsIGluIHRoZSBiYXNlIHZhcmlhbnQgaXQgd2FzIHNldCB0byBub3QgdmlzaWJsZSBpZSBkaXNwbGF5IG5vbmUsXG4gICAqIGJ1dCBpbiBhIHZhcmlhbnQgaXQncyBvdmVycmlkZGVuIHRvIGJlIHZpc2libGUpLCB0aGVuIFBsYXNtaWMgbmVlZHMgdG8ga25vd1xuICAgKiB3aGF0IGRpc3BsYXkgcHJvcGVydHkgdG8gc2V0LlxuICAgKiBEZWZhdWx0cyB0byBcImZsZXhcIi5cbiAgICovXG4gIGRlZmF1bHREaXNwbGF5Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBXaGVuIHRydWUsIHdoZW4geW91IGNsaWNrIGZvciB0aGUgZmlyc3QgdGltZSBhbnl3aGVyZSBpbiB0aGUgY29tcG9uZW50IGluY2x1ZGluZyBpdHMgc2xvdHMsIHRoZSBjb21wb25lbnQgaXRzZWxmIGlzXG4gICAqIHNlbGVjdGVkLCBtYWtpbmcgaXQgZWFzaWVyIHRvIHNlbGVjdCB0aGUgY29tcG9uZW50IGluc3RlYWQgb2Ygc2xvdCBjb250ZW50cy4gU28gZm9yIGluc3RhbmNlLCBzZXR0aW5nIHRoaXMgb24gYVxuICAgKiBCdXR0b24gZW5zdXJlcyB0aGF0IGNsaWNraW5nIG9uIHRoZSBCdXR0b27igJlzIHRleHQgd2lsbCBzdGlsbCBzZWxlY3QgdGhlIEJ1dHRvbiBhbmQgbm90IHRoZSB0ZXh0IGVsZW1lbnQgaW4gaXRzXG4gICAqIHNsb3QuIENsaWNraW5nIGFnYWluIHdpbGwgZGVlcC1zZWxlY3QgdGhlIHNsb3QgY29udGVudC5cbiAgICovXG4gIHRyYXBzRm9jdXM/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBBbiBvYmplY3QgcmVnaXN0ZXJpbmcgY29kZSBjb21wb25lbnQncyB2YXJpYW50cyB0aGF0IHNob3VsZCBiZSBhbGxvd2VkIGluIFN0dWRpbywgd2hlbiB0aGUgY29tcG9uZW50IGlzXG4gICAqIHVzZWQgYXMgdGhlIHJvb3Qgb2YgYSBTdHVkaW8gY29tcG9uZW50LlxuICAgKi9cbiAgdmFyaWFudHM/OiBSZWNvcmQ8XG4gICAgc3RyaW5nLFxuICAgIHtcbiAgICAgIGNzc1NlbGVjdG9yOiBzdHJpbmc7XG4gICAgICBkaXNwbGF5TmFtZTogc3RyaW5nO1xuICAgIH1cbiAgPjtcbn1cblxuZXhwb3J0IHR5cGUgQ29kZUNvbXBvbmVudE1vZGUgPVxuICB8IFwiYWR2YW5jZWRcIlxuICB8IFwic2ltcGxpZmllZFwiXG4gIHwgXCJkYXRhYmFzZS1zY2hlbWEtZHJpdmVuXCI7XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgdXNlIENvZGVDb21wb25lbnRNZXRhIGluc3RlYWRcbiAqL1xuZXhwb3J0IHR5cGUgQ29tcG9uZW50TWV0YTxQPiA9IENvZGVDb21wb25lbnRNZXRhPFA+O1xuXG5leHBvcnQgaW50ZXJmYWNlIEZ1bmN0aW9uUGFyYW08UD4ge1xuICBuYW1lOiBzdHJpbmc7XG4gIGRpc3BsYXlOYW1lPzogc3RyaW5nO1xuICB0eXBlOiBQcm9wVHlwZTxQPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZWZBY3Rpb25SZWdpc3RyYXRpb248UD4ge1xuICBkaXNwbGF5TmFtZT86IHN0cmluZztcbiAgZGVzY3JpcHRpb24/OiBzdHJpbmc7XG4gIGFyZ1R5cGVzOiBGdW5jdGlvblBhcmFtPFA+W107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29tcG9uZW50UmVnaXN0cmF0aW9uIHtcbiAgY29tcG9uZW50OiBSZWFjdC5Db21wb25lbnRUeXBlPGFueT47XG4gIG1ldGE6IENvZGVDb21wb25lbnRNZXRhPGFueT47XG59XG5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgaW50ZXJmYWNlIFdpbmRvdyB7XG4gICAgX19QbGFzbWljQ29tcG9uZW50UmVnaXN0cnk6IENvbXBvbmVudFJlZ2lzdHJhdGlvbltdO1xuICB9XG59XG5cbmlmIChyb290Ll9fUGxhc21pY0NvbXBvbmVudFJlZ2lzdHJ5ID09IG51bGwpIHtcbiAgcm9vdC5fX1BsYXNtaWNDb21wb25lbnRSZWdpc3RyeSA9IFtdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZWdpc3RlckNvbXBvbmVudDxUIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50VHlwZTxhbnk+PihcbiAgY29tcG9uZW50OiBULFxuICBtZXRhOiBDb2RlQ29tcG9uZW50TWV0YTxSZWFjdC5Db21wb25lbnRQcm9wczxUPj5cbikge1xuICAvLyBDaGVjayBmb3IgZHVwbGljYXRlc1xuICBpZiAoXG4gICAgcm9vdC5fX1BsYXNtaWNDb21wb25lbnRSZWdpc3RyeS5zb21lKFxuICAgICAgKHI6IENvbXBvbmVudFJlZ2lzdHJhdGlvbikgPT5cbiAgICAgICAgci5jb21wb25lbnQgPT09IGNvbXBvbmVudCAmJiByLm1ldGEubmFtZSA9PT0gbWV0YS5uYW1lXG4gICAgKVxuICApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcm9vdC5fX1BsYXNtaWNDb21wb25lbnRSZWdpc3RyeS5wdXNoKHsgY29tcG9uZW50LCBtZXRhIH0pO1xufVxuIiwiY29uc3Qgcm9vdCA9IGdsb2JhbFRoaXMgYXMgYW55O1xuXG5leHBvcnQgdHlwZSBTdHJpbmdUeXBlPFQgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmc+ID0gXCJzdHJpbmdcIiB8IGAnJHtUfSdgO1xuXG5leHBvcnQgdHlwZSBOdW1iZXJUeXBlPFQgZXh0ZW5kcyBudW1iZXIgPSBudW1iZXI+ID1cbiAgfCBcIm51bWJlclwiXG4gIHwgYCR7bnVtYmVyIGV4dGVuZHMgVCA/IG51bWJlciA6IFR9YDtcblxuZXhwb3J0IHR5cGUgQm9vbGVhblR5cGU8VCBleHRlbmRzIGJvb2xlYW4gPSBib29sZWFuPiA9XG4gIHwgXCJib29sZWFuXCJcbiAgfCBgJHtib29sZWFuIGV4dGVuZHMgVCA/IGJvb2xlYW4gOiBUfWA7XG5cbmV4cG9ydCB0eXBlIE51bGxUeXBlID0gXCJudWxsXCI7XG5cbmV4cG9ydCB0eXBlIFVuZGVmaW5lZFR5cGUgPSBcInVuZGVmaW5lZFwiO1xuXG5leHBvcnQgdHlwZSBBcnJheVR5cGUgPSBcImFycmF5XCI7XG5cbmV4cG9ydCB0eXBlIE9iamVjdFR5cGUgPSBcIm9iamVjdFwiO1xuXG5leHBvcnQgdHlwZSBBbnlUeXBlID0gXCJhbnlcIjtcblxuZXhwb3J0IHR5cGUgVm9pZFR5cGUgPSBcInZvaWRcIjtcblxuZXhwb3J0IHR5cGUgUmVzdHJpY3RlZFR5cGU8VD4gPSBUIGV4dGVuZHMgc3RyaW5nXG4gID8gU3RyaW5nVHlwZTxUPlxuICA6IFQgZXh0ZW5kcyBudW1iZXJcbiAgPyBOdW1iZXJUeXBlPFQ+XG4gIDogVCBleHRlbmRzIGJvb2xlYW5cbiAgPyBCb29sZWFuVHlwZTxUPlxuICA6IFQgZXh0ZW5kcyBudWxsXG4gID8gTnVsbFR5cGVcbiAgOiBUIGV4dGVuZHMgdW5kZWZpbmVkXG4gID8gVW5kZWZpbmVkVHlwZVxuICA6IFQgZXh0ZW5kcyBBcnJheTxhbnk+XG4gID8gQXJyYXlUeXBlXG4gIDogVCBleHRlbmRzIG9iamVjdFxuICA/IE9iamVjdFR5cGVcbiAgOiBBbnlUeXBlO1xuXG5leHBvcnQgdHlwZSBPclR5cGU8VD4gPSBSZXN0cmljdGVkVHlwZTxUPltdO1xuXG5leHBvcnQgdHlwZSBQYXJhbVR5cGU8VD4gPSBBbnlUeXBlIHwgUmVzdHJpY3RlZFR5cGU8VD4gfCBPclR5cGU8VD47XG5cbmV4cG9ydCBpbnRlcmZhY2UgQmFzZVBhcmFtPFQ+IHtcbiAgbmFtZTogc3RyaW5nO1xuICB0eXBlPzogUGFyYW1UeXBlPFQ+O1xuICBkZXNjcmlwdGlvbj86IHN0cmluZztcbiAgaXNPcHRpb25hbD86IGJvb2xlYW47XG4gIGlzUmVzdFBhcmFtPzogYm9vbGVhbjtcbn1cblxuLy8gUGFyYW0gbmFtZSBhbmQgb3B0aW9uYWxseSBwYXJhbSB0eXBlXG5leHBvcnQgaW50ZXJmYWNlIFJlcXVpcmVkUGFyYW08VD4gZXh0ZW5kcyBCYXNlUGFyYW08VD4ge1xuICBpc09wdGlvbmFsPzogZmFsc2U7XG4gIGlzUmVzdFBhcmFtZXRlcj86IGZhbHNlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE9wdGlvbmFsUGFyYW08VD4gZXh0ZW5kcyBCYXNlUGFyYW08VCB8IHVuZGVmaW5lZD4ge1xuICBpc1Jlc3RQYXJhbWV0ZXI/OiBmYWxzZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZXN0UGFyYW08VD4gZXh0ZW5kcyBCYXNlUGFyYW08VD4ge1xuICBpc09wdGlvbmFsPzogZmFsc2U7XG4gIGlzUmVzdFBhcmFtZXRlcjogdHJ1ZTtcbn1cblxuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzA2ODQwMzAvcmVtb3ZlLWFsbC1vcHRpb25hbC1pdGVtcy1mcm9tLWEtdHVwbGUtdHlwZVxudHlwZSBSZXF1aXJlZFBhcmFtczxcbiAgVCBleHRlbmRzIGFueVtdLFxuICBVIGV4dGVuZHMgYW55W10gPSBbXVxuPiA9IFBhcnRpYWw8VD4gZXh0ZW5kcyBUXG4gID8gVVxuICA6IFQgZXh0ZW5kcyBbaW5mZXIgRiwgLi4uaW5mZXIgUl1cbiAgPyBSZXF1aXJlZFBhcmFtczxSLCBbLi4uVSwgRl0+XG4gIDogVTtcblxudHlwZSBPcHRpb25hbFBhcmFtczxUIGV4dGVuZHMgYW55W10+ID0gVCBleHRlbmRzIFtcbiAgLi4uUmVxdWlyZWRQYXJhbXM8VD4sXG4gIC4uLmluZmVyIFJcbl1cbiAgPyBbLi4uUl1cbiAgOiBbXTtcblxudHlwZSBIYW5kbGVSZXF1aXJlZFBhcmFtczxQIGV4dGVuZHMgYW55W10+ID0gUCBleHRlbmRzIFtpbmZlciBILCAuLi5pbmZlciBUXVxuICA/IFtzdHJpbmcgfCBSZXF1aXJlZFBhcmFtPEg+LCAuLi5IYW5kbGVSZXF1aXJlZFBhcmFtczxUPl1cbiAgOiBbXTtcblxudHlwZSBIYW5kbGVPcHRpb25hbFBhcmFtczxQIGV4dGVuZHMgYW55W10+ID0gUCBleHRlbmRzIFtpbmZlciBILCAuLi5pbmZlciBUXVxuICA/IFtdIHwgW3N0cmluZyB8IE9wdGlvbmFsUGFyYW08SCB8IHVuZGVmaW5lZD4sIC4uLkhhbmRsZU9wdGlvbmFsUGFyYW1zPFQ+XVxuICA6IFAgZXh0ZW5kcyBbXVxuICA/IFtdXG4gIDogUCBleHRlbmRzIEFycmF5PGluZmVyIFQ+XG4gID8gW10gfCBbUmVzdFBhcmFtPFRbXT5dXG4gIDogW107XG5cbmV4cG9ydCB0eXBlIEhhbmRsZVBhcmFtczxQIGV4dGVuZHMgYW55W10+ID0gW1xuICAuLi5IYW5kbGVSZXF1aXJlZFBhcmFtczxSZXF1aXJlZFBhcmFtczxQPj4sXG4gIC4uLkhhbmRsZU9wdGlvbmFsUGFyYW1zPFJlcXVpcmVkPE9wdGlvbmFsUGFyYW1zPFA+Pj5cbl07XG5cbmV4cG9ydCB0eXBlIEhhbmRsZVJldHVyblR5cGU8VD4gPSBWb2lkVHlwZSB8IFBhcmFtVHlwZTxUPjtcblxuZXhwb3J0IGludGVyZmFjZSBDdXN0b21GdW5jdGlvbk1ldGE8RiBleHRlbmRzICguLi5hcmdzOiBhbnlbXSkgPT4gYW55PiB7XG4gIC8qKlxuICAgKiBUaGUgamF2YXNjcmlwdCBuYW1lIG9mIHRoZSBmdW5jdGlvbi4gTm90aWNlIGl0IG11c3QgYmUgdW5pcXVlIGFjcm9zcyBhbGxcbiAgICogb3RoZXIgZnVuY3Rpb25zIGFuZCBmdW5jdGlvbiBuYW1lc3BhY2VzLiBJZiB0d28gZnVuY3Rpb25zIGhhdmUgdGhlIHNhbWVcbiAgICogbmFtZSwgdGhleSBzaG91bGQgYmUgcmVnaXN0ZXJlZCB3aXRoIGRpZmZlcmVudCBgbWV0YS5uYW1lc3BhY2VgLlxuICAgKi9cbiAgbmFtZTogc3RyaW5nO1xuICAvKipcbiAgICogQSBuYW1lc3BhY2UgZm9yIG9yZ2FuaXppbmcgZ3JvdXBzIG9mIGZ1bmN0aW9ucy4gSXQncyBhbHNvIHVzZWQgdG8gaGFuZGxlXG4gICAqIGZ1bmN0aW9uIG5hbWUgY29sbGlzaW9ucy4gSWYgYSBmdW5jdGlvbiBoYXMgYSBuYW1lc3BhY2UsIGl0IHdpbGwgYmUgdXNlZFxuICAgKiB3aGVuZXZlciBhY2Nlc3NpbmcgdGhlIGZ1bmN0aW9uLlxuICAgKi9cbiAgbmFtZXNwYWNlPzogc3RyaW5nO1xuICAvKipcbiAgICogRG9jdW1lbnRhdGlvbiBmb3IgdGhlIHJlZ2lzdGVyZWQgZnVuY3Rpb24uXG4gICAqL1xuICBkZXNjcmlwdGlvbj86IHN0cmluZztcbiAgLyoqXG4gICAqIEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGxpc3Qgb2YgcGFyYW1ldGVycyBuYW1lcyB0aGUgZnVuY3Rpb24gdGFrZXMuXG4gICAqIE9wdGlvbmFsbHkgdGhleSBjYW4gYWxzbyBiZSByZWdpc3RlcmVkIHdpdGggdGhlIGV4cGVjdGVkIHBhcmFtIHR5cGVzLlxuICAgKi9cbiAgcGFyYW1zPzogSGFuZGxlUGFyYW1zPFBhcmFtZXRlcnM8Rj4+O1xuICAvKipcbiAgICogUmV0dXJuIHZhbHVlIGluZm9ybWF0aW9uLlxuICAgKi9cbiAgcmV0dXJuVmFsdWU/OiB7XG4gICAgLyoqXG4gICAgICogVGhlIGZ1bmN0aW9uIHJldHVybiB0eXBlLlxuICAgICAqL1xuICAgIHR5cGU/OiBIYW5kbGVSZXR1cm5UeXBlPFJldHVyblR5cGU8Rj4+O1xuICAgIC8qKlxuICAgICAqIFRoZSBmdW5jdGlvbiByZXR1cm4gdmFsdWUgZGVzY3JpcHRpb24uXG4gICAgICovXG4gICAgZGVzY3JpcHRpb24/OiBzdHJpbmc7XG4gIH07XG4gIC8qKlxuICAgKiBUeXBlc2NyaXB0IGZ1bmN0aW9uIGRlY2xhcmF0aW9uLiBJZiBzcGVjaWZpZWQsIGl0IGlnbm9yZXMgdGhlIHR5cGVzXG4gICAqIHByb3ZpZGVkIGJ5IGBwYXJhbXNgIGFuZCBgcmV0dXJuVmFsdWVgLlxuICAgKi9cbiAgdHlwZXNjcmlwdERlY2xhcmF0aW9uPzogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIHBhdGggdG8gYmUgdXNlZCB3aGVuIGltcG9ydGluZyB0aGUgZnVuY3Rpb24gaW4gdGhlIGdlbmVyYXRlZCBjb2RlLlxuICAgKiBJdCBjYW4gYmUgdGhlIG5hbWUgb2YgdGhlIHBhY2thZ2UgdGhhdCBjb250YWlucyB0aGUgZnVuY3Rpb24sIG9yIHRoZSBwYXRoXG4gICAqIHRvIHRoZSBmaWxlIGluIHRoZSBwcm9qZWN0IChyZWxhdGl2ZSB0byB0aGUgcm9vdCBkaXJlY3RvcnkpLlxuICAgKi9cbiAgaW1wb3J0UGF0aDogc3RyaW5nO1xuICAvKipcbiAgICogV2hldGhlciB0aGUgZnVuY3Rpb24gaXMgdGhlIGRlZmF1bHQgZXhwb3J0IGZyb20gdGhhdCBwYXRoLiBPcHRpb25hbDogaWZcbiAgICogbm90IHNwZWNpZmllZCwgaXQncyBjb25zaWRlcmVkIGBmYWxzZWAuXG4gICAqL1xuICBpc0RlZmF1bHRFeHBvcnQ/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEN1c3RvbUZ1bmN0aW9uUmVnaXN0cmF0aW9uIHtcbiAgZnVuY3Rpb246ICguLi5hcmdzOiBhbnlbXSkgPT4gYW55O1xuICBtZXRhOiBDdXN0b21GdW5jdGlvbk1ldGE8YW55Pjtcbn1cblxuZGVjbGFyZSBnbG9iYWwge1xuICBpbnRlcmZhY2UgV2luZG93IHtcbiAgICBfX1BsYXNtaWNGdW5jdGlvbnNSZWdpc3RyeTogQ3VzdG9tRnVuY3Rpb25SZWdpc3RyYXRpb25bXTtcbiAgfVxufVxuXG5pZiAocm9vdC5fX1BsYXNtaWNGdW5jdGlvbnNSZWdpc3RyeSA9PSBudWxsKSB7XG4gIHJvb3QuX19QbGFzbWljRnVuY3Rpb25zUmVnaXN0cnkgPSBbXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVnaXN0ZXJGdW5jdGlvbjxGIGV4dGVuZHMgKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnk+KFxuICBmbjogRixcbiAgbWV0YTogQ3VzdG9tRnVuY3Rpb25NZXRhPEY+XG4pIHtcbiAgLy8gQ2hlY2sgZm9yIGR1cGxpY2F0ZXNcbiAgaWYgKFxuICAgIHJvb3QuX19QbGFzbWljRnVuY3Rpb25zUmVnaXN0cnkuc29tZShcbiAgICAgIChyOiBDdXN0b21GdW5jdGlvblJlZ2lzdHJhdGlvbikgPT5cbiAgICAgICAgci5mdW5jdGlvbiA9PT0gZm4gJiZcbiAgICAgICAgci5tZXRhLm5hbWUgPT09IG1ldGEubmFtZSAmJlxuICAgICAgICByLm1ldGEubmFtZXNwYWNlID09IG1ldGEubmFtZXNwYWNlXG4gICAgKVxuICApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcm9vdC5fX1BsYXNtaWNGdW5jdGlvbnNSZWdpc3RyeS5wdXNoKHsgZnVuY3Rpb246IGZuLCBtZXRhIH0pO1xufVxuIiwiaW1wb3J0IHtcbiAgQm9vbGVhblR5cGUsXG4gIENob2ljZVR5cGUsXG4gIEN1c3RvbVR5cGUsXG4gIERhdGFTb3VyY2VUeXBlLFxuICBKU09OTGlrZVR5cGUsXG4gIE51bWJlclR5cGUsXG4gIFN0cmluZ1R5cGUsXG59IGZyb20gXCIuL3Byb3AtdHlwZXNcIjtcbmltcG9ydCB7IEZ1bmN0aW9uUGFyYW0gfSBmcm9tIFwiLi9yZWdpc3RlckNvbXBvbmVudFwiO1xuXG5jb25zdCByb290ID0gZ2xvYmFsVGhpcyBhcyBhbnk7XG5cbi8vIFVzaW5nIGp1c3QgYSBzdWJzZXQgb2YgdHlwZXMgZnJvbSBwcm9wLXR5cGVzXG5leHBvcnQgdHlwZSBQcm9wVHlwZTxQPiA9XG4gIHwgU3RyaW5nVHlwZTxQPlxuICB8IEJvb2xlYW5UeXBlPFA+XG4gIHwgTnVtYmVyVHlwZTxQPlxuICB8IEpTT05MaWtlVHlwZTxQPlxuICB8IENob2ljZVR5cGU8UD5cbiAgfCBEYXRhU291cmNlVHlwZTxQPlxuICB8IEN1c3RvbVR5cGU8UD47XG5cbnR5cGUgUmVzdHJpY3RQcm9wVHlwZTxULCBQPiA9IFQgZXh0ZW5kcyBzdHJpbmdcbiAgPyBTdHJpbmdUeXBlPFA+IHwgQ2hvaWNlVHlwZTxQPiB8IEpTT05MaWtlVHlwZTxQPiB8IEN1c3RvbVR5cGU8UD5cbiAgOiBUIGV4dGVuZHMgYm9vbGVhblxuICA/IEJvb2xlYW5UeXBlPFA+IHwgSlNPTkxpa2VUeXBlPFA+IHwgQ3VzdG9tVHlwZTxQPlxuICA6IFQgZXh0ZW5kcyBudW1iZXJcbiAgPyBOdW1iZXJUeXBlPFA+IHwgSlNPTkxpa2VUeXBlPFA+IHwgQ3VzdG9tVHlwZTxQPlxuICA6IFByb3BUeXBlPFA+O1xuXG50eXBlIERpc3RyaWJ1dGVkS2V5T2Y8VD4gPSBUIGV4dGVuZHMgYW55ID8ga2V5b2YgVCA6IG5ldmVyO1xuXG5leHBvcnQgaW50ZXJmYWNlIEdsb2JhbENvbnRleHRNZXRhPFA+IHtcbiAgLyoqXG4gICAqIEFueSB1bmlxdWUgc3RyaW5nIG5hbWUgdXNlZCB0byBpZGVudGlmeSB0aGF0IGNvbnRleHQuIEVhY2ggY29udGV4dFxuICAgKiBzaG91bGQgYmUgcmVnaXN0ZXJlZCB3aXRoIGEgZGlmZmVyZW50IGBtZXRhLm5hbWVgLCBldmVuIGlmIHRoZXkgaGF2ZSB0aGVcbiAgICogc2FtZSBuYW1lIGluIHRoZSBjb2RlLlxuICAgKi9cbiAgbmFtZTogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIG5hbWUgdG8gYmUgZGlzcGxheWVkIGZvciB0aGUgY29udGV4dCBpbiBTdHVkaW8uIE9wdGlvbmFsOiBpZiBub3RcbiAgICogc3BlY2lmaWVkLCBgbWV0YS5uYW1lYCBpcyB1c2VkLlxuICAgKi9cbiAgZGlzcGxheU5hbWU/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgZGVzY3JpcHRpb24gb2YgdGhlIGNvbnRleHQgdG8gYmUgc2hvd24gaW4gU3R1ZGlvLlxuICAgKi9cbiAgZGVzY3JpcHRpb24/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgamF2YXNjcmlwdCBuYW1lIHRvIGJlIHVzZWQgd2hlbiBnZW5lcmF0aW5nIGNvZGUuIE9wdGlvbmFsOiBpZiBub3RcbiAgICogcHJvdmlkZWQsIGBtZXRhLm5hbWVgIGlzIHVzZWQuXG4gICAqL1xuICBpbXBvcnROYW1lPzogc3RyaW5nO1xuICAvKipcbiAgICogQW4gb2JqZWN0IGRlc2NyaWJpbmcgdGhlIGNvbnRleHQgcHJvcGVydGllcyB0byBiZSB1c2VkIGluIFN0dWRpby5cbiAgICogRm9yIGVhY2ggYHByb3BgLCB0aGVyZSBzaG91bGQgYmUgYW4gZW50cnkgYG1ldGEucHJvcHNbcHJvcF1gIGRlc2NyaWJpbmdcbiAgICogaXRzIHR5cGUuXG4gICAqL1xuICBwcm9wczogeyBbcHJvcCBpbiBEaXN0cmlidXRlZEtleU9mPFA+XT86IFJlc3RyaWN0UHJvcFR5cGU8UFtwcm9wXSwgUD4gfSAmIHtcbiAgICBbcHJvcDogc3RyaW5nXTogUHJvcFR5cGU8UD47XG4gIH07XG4gIC8qKlxuICAgKiBUaGUgcGF0aCB0byBiZSB1c2VkIHdoZW4gaW1wb3J0aW5nIHRoZSBjb250ZXh0IGluIHRoZSBnZW5lcmF0ZWQgY29kZS5cbiAgICogSXQgY2FuIGJlIHRoZSBuYW1lIG9mIHRoZSBwYWNrYWdlIHRoYXQgY29udGFpbnMgdGhlIGNvbnRleHQsIG9yIHRoZSBwYXRoXG4gICAqIHRvIHRoZSBmaWxlIGluIHRoZSBwcm9qZWN0IChyZWxhdGl2ZSB0byB0aGUgcm9vdCBkaXJlY3RvcnkpLlxuICAgKi9cbiAgaW1wb3J0UGF0aDogc3RyaW5nO1xuICAvKipcbiAgICogIFdoZXRoZXIgdGhlIGNvbnRleHQgaXMgdGhlIGRlZmF1bHQgZXhwb3J0IGZyb20gdGhhdCBwYXRoLiBPcHRpb25hbDogaWZcbiAgICogbm90IHNwZWNpZmllZCwgaXQncyBjb25zaWRlcmVkIGBmYWxzZWAuXG4gICAqL1xuICBpc0RlZmF1bHRFeHBvcnQ/OiBib29sZWFuO1xuICAvKipcbiAgICogVGhlIHByb3AgdGhhdCByZWNlaXZlcyBhbmQgZm9yd2FyZHMgYSBSZWFjdCBgcmVmYC4gUGxhc21pYyBvbmx5IHVzZXMgYHJlZmBcbiAgICogdG8gaW50ZXJhY3Qgd2l0aCBjb21wb25lbnRzLCBzbyBpdCdzIG5vdCB1c2VkIGluIHRoZSBnZW5lcmF0ZWQgY29kZS5cbiAgICogT3B0aW9uYWw6IElmIG5vdCBwcm92aWRlZCwgdGhlIHVzdWFsIGByZWZgIGlzIHVzZWQuXG4gICAqL1xuICByZWZQcm9wPzogc3RyaW5nO1xuICAvKipcbiAgICogV2hldGhlciB0aGUgZ2xvYmFsIGNvbnRleHQgcHJvdmlkZXMgZGF0YSB0byBpdHMgY2hpbGRyZW4gdXNpbmcgRGF0YVByb3ZpZGVyLlxuICAgKi9cbiAgcHJvdmlkZXNEYXRhPzogYm9vbGVhbjtcblxuICBnbG9iYWxBY3Rpb25zPzogUmVjb3JkPHN0cmluZywgR2xvYmFsQWN0aW9uUmVnaXN0cmF0aW9uPFA+Pjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHbG9iYWxDb250ZXh0UmVnaXN0cmF0aW9uIHtcbiAgY29tcG9uZW50OiBSZWFjdC5Db21wb25lbnRUeXBlPGFueT47XG4gIG1ldGE6IEdsb2JhbENvbnRleHRNZXRhPGFueT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2xvYmFsQWN0aW9uUmVnaXN0cmF0aW9uPFA+IHtcbiAgZGlzcGxheU5hbWU/OiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuICBwYXJhbWV0ZXJzOiBGdW5jdGlvblBhcmFtPFA+W107XG59XG5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgaW50ZXJmYWNlIFdpbmRvdyB7XG4gICAgX19QbGFzbWljQ29udGV4dFJlZ2lzdHJ5OiBHbG9iYWxDb250ZXh0UmVnaXN0cmF0aW9uW107XG4gIH1cbn1cblxuaWYgKHJvb3QuX19QbGFzbWljQ29udGV4dFJlZ2lzdHJ5ID09IG51bGwpIHtcbiAgcm9vdC5fX1BsYXNtaWNDb250ZXh0UmVnaXN0cnkgPSBbXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVnaXN0ZXJHbG9iYWxDb250ZXh0PFxuICBUIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50VHlwZTxhbnk+XG4+KGNvbXBvbmVudDogVCwgbWV0YTogR2xvYmFsQ29udGV4dE1ldGE8UmVhY3QuQ29tcG9uZW50UHJvcHM8VD4+KSB7XG4gIC8vIENoZWNrIGZvciBkdXBsaWNhdGVzXG4gIGlmIChcbiAgICByb290Ll9fUGxhc21pY0NvbnRleHRSZWdpc3RyeS5zb21lKFxuICAgICAgKHI6IEdsb2JhbENvbnRleHRSZWdpc3RyYXRpb24pID0+XG4gICAgICAgIHIuY29tcG9uZW50ID09PSBjb21wb25lbnQgJiYgci5tZXRhLm5hbWUgPT09IG1ldGEubmFtZVxuICAgIClcbiAgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJvb3QuX19QbGFzbWljQ29udGV4dFJlZ2lzdHJ5LnB1c2goeyBjb21wb25lbnQsIG1ldGEgfSk7XG59XG4iLCJleHBvcnQgdHlwZSBUb2tlblR5cGUgPVxuICB8IFwiY29sb3JcIlxuICB8IFwic3BhY2luZ1wiXG4gIHwgXCJmb250LWZhbWlseVwiXG4gIHwgXCJmb250LXNpemVcIlxuICB8IFwibGluZS1oZWlnaHRcIlxuICB8IFwib3BhY2l0eVwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRva2VuUmVnaXN0cmF0aW9uIHtcbiAgLyoqXG4gICAqIE5hbWUgZm9yIHRoaXMgdG9rZW47IHNob3VsZCBiZSBzdGFibGUgYWNyb3NzIHVwZGF0ZXNcbiAgICovXG4gIG5hbWU6IHN0cmluZztcbiAgLyoqXG4gICAqIFZhbHVlIGZvciB0aGUgdG9rZW4sIHdoaWNoIGNhbiBlaXRoZXIgYmUgYSB2YWxpZCBjc3MgdmFsdWUgb3IgYSBjc3MgcmVmZXJlbmNlXG4gICAqIHRvIGEgY3NzIHZhcmlhYmxlIHByb3ZpZGVkIGJ5IHlvdXIgaG9zdCBhcHAsIGxpa2UgYHZhcigtLW15LXRva2VuKWBcbiAgICovXG4gIHZhbHVlOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUeXBlIG9mIHRva2VuXG4gICAqL1xuICB0eXBlOiBUb2tlblR5cGU7XG4gIC8qKlxuICAgKiBPcHRpb25hbCBkaXNwbGF5IG5hbWUgdG8gdXNlIGZvciB0aGlzIHRva2VuLCBpZiB5b3UnZCBsaWtlIHRvIHVzZSBhIGZyaWVuZGxpZXJcbiAgICogbmFtZSB0byBkaXNwbGF5IHRvIFN0dWRpbyB1c2Vyc1xuICAgKi9cbiAgZGlzcGxheU5hbWU/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBCeSBkZWZhdWx0LCBpZiB0aGlzIHRva2VuIGlzIGEgY3NzIHZhcmlhYmxlIHJlZmVyZW5jZSBsaWtlIGB2YXIoLS1teS10b2tlbilgLFxuICAgKiB0aGVuIGl0IGlzIGFzc3VtZWQgdGhhdCBgLS1teS10b2tlbmAgaXMgZGVmaW5lZCBvbiBgOnJvb3RgLiAgSWYgaXQgaXMgZGVmaW5lZFxuICAgKiBpbiBhbm90aGVyIGVsZW1lbnQsIHRoZW4geW91IGNhbiBwYXNzIGluIGEgc2VsZWN0b3IgZm9yIHRoYXQgZWxlbWVudCxcbiAgICogbGlrZSBgLnRoZW1lUm9vdGAuXG4gICAqL1xuICBzZWxlY3Rvcj86IHN0cmluZztcbn1cblxuZGVjbGFyZSBnbG9iYWwge1xuICBpbnRlcmZhY2UgV2luZG93IHtcbiAgICBfX1BsYXNtaWNUb2tlblJlZ2lzdHJ5OiBUb2tlblJlZ2lzdHJhdGlvbltdO1xuICB9XG59XG5cbmNvbnN0IHJvb3QgPSBnbG9iYWxUaGlzIGFzIGFueTtcblxuaWYgKHJvb3QuX19QbGFzbWljVG9rZW5SZWdpc3RyeSA9PSBudWxsKSB7XG4gIHJvb3QuX19QbGFzbWljVG9rZW5SZWdpc3RyeSA9IFtdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZWdpc3RlclRva2VuKHRva2VuOiBUb2tlblJlZ2lzdHJhdGlvbikge1xuICByb290Ll9fUGxhc21pY1Rva2VuUmVnaXN0cnkucHVzaCh0b2tlbik7XG59XG4iLCJjb25zdCByb290ID0gZ2xvYmFsVGhpcyBhcyBhbnk7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQmFzaWNUcmFpdCB7XG4gIGxhYmVsPzogc3RyaW5nO1xuICB0eXBlOiBcInRleHRcIiB8IFwibnVtYmVyXCIgfCBcImJvb2xlYW5cIjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDaG9pY2VUcmFpdCB7XG4gIGxhYmVsPzogc3RyaW5nO1xuICB0eXBlOiBcImNob2ljZVwiO1xuICBvcHRpb25zOiBzdHJpbmdbXTtcbn1cblxuZXhwb3J0IHR5cGUgVHJhaXRNZXRhID0gQmFzaWNUcmFpdCB8IENob2ljZVRyYWl0O1xuXG5leHBvcnQgaW50ZXJmYWNlIFRyYWl0UmVnaXN0cmF0aW9uIHtcbiAgdHJhaXQ6IHN0cmluZztcbiAgbWV0YTogVHJhaXRNZXRhO1xufVxuXG5kZWNsYXJlIGdsb2JhbCB7XG4gIGludGVyZmFjZSBXaW5kb3cge1xuICAgIF9fUGxhc21pY1RyYWl0UmVnaXN0cnk6IFRyYWl0UmVnaXN0cmF0aW9uW107XG4gIH1cbn1cblxuaWYgKHJvb3QuX19QbGFzbWljVHJhaXRSZWdpc3RyeSA9PSBudWxsKSB7XG4gIHJvb3QuX19QbGFzbWljVHJhaXRSZWdpc3RyeSA9IFtdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZWdpc3RlclRyYWl0KHRyYWl0OiBzdHJpbmcsIG1ldGE6IFRyYWl0TWV0YSkge1xuICByb290Ll9fUGxhc21pY1RyYWl0UmVnaXN0cnkucHVzaCh7XG4gICAgdHJhaXQsXG4gICAgbWV0YSxcbiAgfSk7XG59XG4iLCJpbXBvcnQgeyBjbG9uZUVsZW1lbnQsIGlzVmFsaWRFbGVtZW50IH0gZnJvbSBcInJlYWN0XCI7XG5cbi8qKlxuICogQWxsb3dzIGVsZW1lbnRzIHRvIGJlIHJlcGVhdGVkIGluIFBsYXNtaWMgU3R1ZGlvLlxuICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgY29weSAoc3RhcnRpbmcgYXQgMCkuXG4gKiBAcGFyYW0gZWx0IHRoZSBSZWFjdCBlbGVtZW50IHRvIGJlIHJlcGVhdGVkIChvciBhbiBhcnJheSBvZiBzdWNoKS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVwZWF0ZWRFbGVtZW50PFQ+KGluZGV4OiBudW1iZXIsIGVsdDogVCk6IFQ7XG4vKipcbiAqIEFsbG93cyBlbGVtZW50cyB0byBiZSByZXBlYXRlZCBpbiBQbGFzbWljIFN0dWRpby5cbiAqIEBwYXJhbSBpc1ByaW1hcnkgc2hvdWxkIGJlIHRydWUgZm9yIGF0IG1vc3Qgb25lIGluc3RhbmNlIG9mIHRoZSBlbGVtZW50LCBhbmRcbiAqIGluZGljYXRlcyB3aGljaCBjb3B5IG9mIHRoZSBlbGVtZW50IHdpbGwgYmUgaGlnaGxpZ2h0ZWQgd2hlbiB0aGUgZWxlbWVudCBpc1xuICogc2VsZWN0ZWQgaW4gU3R1ZGlvLlxuICogQHBhcmFtIGVsdCB0aGUgUmVhY3QgZWxlbWVudCB0byBiZSByZXBlYXRlZCAob3IgYW4gYXJyYXkgb2Ygc3VjaCkuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlcGVhdGVkRWxlbWVudDxUPihpc1ByaW1hcnk6IGJvb2xlYW4sIGVsdDogVCk6IFQ7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZXBlYXRlZEVsZW1lbnQ8VD4oaW5kZXg6IGJvb2xlYW4gfCBudW1iZXIsIGVsdDogVCk6IFQge1xuICByZXR1cm4gcmVwZWF0ZWRFbGVtZW50Rm4oaW5kZXggYXMgYW55LCBlbHQpO1xufVxuXG5sZXQgcmVwZWF0ZWRFbGVtZW50Rm46IHR5cGVvZiByZXBlYXRlZEVsZW1lbnQgPSAoXG4gIGluZGV4OiBib29sZWFuIHwgbnVtYmVyLFxuICBlbHQ6IGFueVxuKSA9PiB7XG4gIGlmIChBcnJheS5pc0FycmF5KGVsdCkpIHtcbiAgICByZXR1cm4gZWx0Lm1hcCgodikgPT4gcmVwZWF0ZWRFbGVtZW50Rm4oaW5kZXggYXMgYW55LCB2KSkgYXMgYW55O1xuICB9XG4gIGlmIChlbHQgJiYgaXNWYWxpZEVsZW1lbnQoZWx0KSAmJiB0eXBlb2YgZWx0ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGNsb25lRWxlbWVudChlbHQpIGFzIGFueTtcbiAgfVxuICByZXR1cm4gZWx0O1xufTtcblxuY29uc3Qgcm9vdCA9IGdsb2JhbFRoaXMgYXMgYW55O1xuZXhwb3J0IGNvbnN0IHNldFJlcGVhdGVkRWxlbWVudEZuOiAoZm46IHR5cGVvZiByZXBlYXRlZEVsZW1lbnQpID0+IHZvaWQgPVxuICByb290Py5fX1N1Yj8uc2V0UmVwZWF0ZWRFbGVtZW50Rm4gPz9cbiAgZnVuY3Rpb24gKGZuOiB0eXBlb2YgcmVwZWF0ZWRFbGVtZW50KSB7XG4gICAgcmVwZWF0ZWRFbGVtZW50Rm4gPSBmbjtcbiAgfTtcbiIsImltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcblxuZXhwb3J0IHR5cGUgUGxhc21pY1RyYW5zbGF0b3IgPSAoXG4gIHN0cjogc3RyaW5nLFxuICBvcHRzPzoge1xuICAgIGNvbXBvbmVudHM/OiB7XG4gICAgICBba2V5OiBzdHJpbmddOiBSZWFjdC5SZWFjdEVsZW1lbnQ7XG4gICAgfTtcbiAgfVxuKSA9PiBSZWFjdC5SZWFjdE5vZGU7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGxhc21pY0kxOE5Db250ZXh0VmFsdWUge1xuICB0cmFuc2xhdG9yPzogUGxhc21pY1RyYW5zbGF0b3I7XG4gIHRhZ1ByZWZpeD86IHN0cmluZztcbn1cblxuZXhwb3J0IGNvbnN0IFBsYXNtaWNUcmFuc2xhdG9yQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8XG4gIFBsYXNtaWNJMThOQ29udGV4dFZhbHVlIHwgUGxhc21pY1RyYW5zbGF0b3IgfCB1bmRlZmluZWRcbj4odW5kZWZpbmVkKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVBsYXNtaWNUcmFuc2xhdG9yKCkge1xuICBjb25zdCBfdCA9IFJlYWN0LnVzZUNvbnRleHQoUGxhc21pY1RyYW5zbGF0b3JDb250ZXh0KTtcbiAgY29uc3QgdHJhbnNsYXRvciA9IF90XG4gICAgPyB0eXBlb2YgX3QgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgPyBfdFxuICAgICAgOiBfdC50cmFuc2xhdG9yXG4gICAgOiB1bmRlZmluZWQ7XG4gIHJldHVybiB0cmFuc2xhdG9yO1xufVxuIiwiZXhwb3J0IGNvbnN0IGhvc3RWZXJzaW9uID0gXCIxLjAuMjA4XCI7XG4iLCJpbXBvcnQgKiBhcyBQbGFzbWljUXVlcnkgZnJvbSBcIkBwbGFzbWljYXBwL3F1ZXJ5XCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCAqIGFzIFJlYWN0RE9NIGZyb20gXCJyZWFjdC1kb21cIjtcbmltcG9ydCB7IHJlZ2lzdGVyUmVuZGVyRXJyb3JMaXN0ZW5lciwgc2V0UGxhc21pY1Jvb3ROb2RlIH0gZnJvbSBcIi4vY2FudmFzLWhvc3RcIjtcbmltcG9ydCAqIGFzIGhvc3RNb2R1bGUgZnJvbSBcIi4vZXhwb3J0c1wiO1xuaW1wb3J0IHsgc2V0UmVwZWF0ZWRFbGVtZW50Rm4gfSBmcm9tIFwiLi9yZXBlYXRlZEVsZW1lbnRcIjtcbi8vIHZlcnNpb24udHMgaXMgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgYnkgYHlhcm4gYnVpbGRgIGFuZCBub3QgY29tbWl0dGVkLlxuaW1wb3J0IHsgaG9zdFZlcnNpb24gfSBmcm9tIFwiLi92ZXJzaW9uXCI7XG5cbi8vIEFsbCBleHBvcnRzIG11c3QgY29tZSBmcm9tIFwiLi9leHBvcnRzXCJcbmV4cG9ydCAqIGZyb20gXCIuL2V4cG9ydHNcIjtcblxuY29uc3Qgcm9vdCA9IGdsb2JhbFRoaXMgYXMgYW55O1xuXG5pZiAocm9vdC5fX1N1YiA9PSBudWxsKSB7XG4gIC8vIENyZWF0aW5nIGEgc2lkZSBlZmZlY3QgaGVyZSBieSBsb2dnaW5nLCBzbyB0aGF0IHZpdGUgd29uJ3RcbiAgLy8gaWdub3JlIHRoaXMgYmxvY2sgZm9yIHdoYXRldmVyIHJlYXNvbi4gSGlkaW5nIHRoaXMgZm9yIG5vd1xuICAvLyBhcyB1c2VycyBhcmUgY29tcGxhaW5pbmc7IHdpbGwgaGF2ZSB0byBjaGVjayBpZiB0aGlzIGhhc1xuICAvLyBiZWVuIGZpeGVkIHdpdGggdml0ZS5cbiAgLy8gY29uc29sZS5sb2coXCJQbGFzbWljOiBTZXR0aW5nIHVwIGFwcCBob3N0IGRlcGVuZGVuY2llc1wiKTtcbiAgcm9vdC5fX1N1YiA9IHtcbiAgICBSZWFjdCxcbiAgICBSZWFjdERPTSxcbiAgICBQbGFzbWljUXVlcnksXG4gICAgaG9zdE1vZHVsZSxcbiAgICBob3N0VmVyc2lvbixcbiAgICBob3N0VXRpbHM6IHtcbiAgICAgIHNldFBsYXNtaWNSb290Tm9kZSxcbiAgICAgIHJlZ2lzdGVyUmVuZGVyRXJyb3JMaXN0ZW5lcixcbiAgICAgIHNldFJlcGVhdGVkRWxlbWVudEZuLFxuICAgIH0sXG5cbiAgICAvLyBGb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHk6XG4gICAgc2V0UGxhc21pY1Jvb3ROb2RlLFxuICAgIHJlZ2lzdGVyUmVuZGVyRXJyb3JMaXN0ZW5lcixcbiAgICBzZXRSZXBlYXRlZEVsZW1lbnRGbixcbiAgICAuLi5ob3N0TW9kdWxlLFxuICB9O1xufSBlbHNlIHtcbiAgY29uc29sZS53YXJuKFxuICAgIGBFbmNvdW50ZXJlZCBsaWtlbHkgZHVwbGljYXRlIGhvc3QgdmVyc2lvbjogJHtyb290Ll9fU3ViLmhvc3RWZXJzaW9ufSB2cyAke2hvc3RWZXJzaW9ufWBcbiAgKTtcbiAgcm9vdC5fX1N1Yi5kdXBsaWNhdGVIb3N0VmVyc2lvbnMgPSByb290Ll9fU3ViLmR1cGxpY2F0ZUhvc3RWZXJzaW9ucyA/PyBbXTtcbiAgcm9vdC5fX1N1Yi5kdXBsaWNhdGVIb3N0VmVyc2lvbnMucHVzaChob3N0VmVyc2lvbik7XG59XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJyb290Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@plasmicapp/host/dist/host.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@plasmicapp/isomorphic-unfetch/dist/server.js":
/*!********************************************************************!*\
  !*** ./node_modules/@plasmicapp/isomorphic-unfetch/dist/server.js ***!
  \********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __getOwnPropNames = Object.getOwnPropertyNames;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\n\n// node_modules/node-fetch-cjs/dist/index.js\nvar require_dist = __commonJS({\n  \"node_modules/node-fetch-cjs/dist/index.js\"(exports2) {\n    var __create = Object.create;\n    var __defProp = Object.defineProperty;\n    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n    var __getOwnPropNames2 = Object.getOwnPropertyNames;\n    var __getProtoOf = Object.getPrototypeOf;\n    var __hasOwnProp = Object.prototype.hasOwnProperty;\n    var __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\n    var __esm = (fn, res) => function __init() {\n      return fn && (res = (0, fn[Object.keys(fn)[0]])(fn = 0)), res;\n    };\n    var __commonJS2 = (cb, mod) => function __require() {\n      return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n    };\n    var __export = (target, all) => {\n      __markAsModule(target);\n      for (var name in all)\n        __defProp(target, name, { get: all[name], enumerable: true });\n    };\n    var __reExport = (target, module22, desc) => {\n      if (module22 && typeof module22 === \"object\" || typeof module22 === \"function\") {\n        for (let key of __getOwnPropNames2(module22))\n          if (!__hasOwnProp.call(target, key) && key !== \"default\")\n            __defProp(target, key, { get: () => module22[key], enumerable: !(desc = __getOwnPropDesc(module22, key)) || desc.enumerable });\n      }\n      return target;\n    };\n    var __toModule = (module22) => {\n      return __reExport(__markAsModule(__defProp(module22 != null ? __create(__getProtoOf(module22)) : {}, \"default\", module22 && module22.__esModule && \"default\" in module22 ? { get: () => module22.default, enumerable: true } : { value: module22, enumerable: true })), module22);\n    };\n    var require_ponyfill_es2018 = __commonJS2({\n      \"node_modules/web-streams-polyfill/dist/ponyfill.es2018.js\"(exports3, module22) {\n        (function(global2, factory) {\n          typeof exports3 === \"object\" && typeof module22 !== \"undefined\" ? factory(exports3) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (0);\n        })(exports3, function(exports22) {\n          \"use strict\";\n          const SymbolPolyfill = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? Symbol : (description) => `Symbol(${description})`;\n          function noop2() {\n            return void 0;\n          }\n          function getGlobals() {\n            if (typeof self !== \"undefined\") {\n              return self;\n            } else if (typeof window !== \"undefined\") {\n              return window;\n            } else if (typeof global !== \"undefined\") {\n              return global;\n            }\n            return void 0;\n          }\n          const globals = getGlobals();\n          function typeIsObject(x2) {\n            return typeof x2 === \"object\" && x2 !== null || typeof x2 === \"function\";\n          }\n          const rethrowAssertionErrorRejection = noop2;\n          const originalPromise = Promise;\n          const originalPromiseThen = Promise.prototype.then;\n          const originalPromiseResolve = Promise.resolve.bind(originalPromise);\n          const originalPromiseReject = Promise.reject.bind(originalPromise);\n          function newPromise(executor) {\n            return new originalPromise(executor);\n          }\n          function promiseResolvedWith(value) {\n            return originalPromiseResolve(value);\n          }\n          function promiseRejectedWith(reason) {\n            return originalPromiseReject(reason);\n          }\n          function PerformPromiseThen(promise, onFulfilled, onRejected) {\n            return originalPromiseThen.call(promise, onFulfilled, onRejected);\n          }\n          function uponPromise(promise, onFulfilled, onRejected) {\n            PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), void 0, rethrowAssertionErrorRejection);\n          }\n          function uponFulfillment(promise, onFulfilled) {\n            uponPromise(promise, onFulfilled);\n          }\n          function uponRejection(promise, onRejected) {\n            uponPromise(promise, void 0, onRejected);\n          }\n          function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {\n            return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);\n          }\n          function setPromiseIsHandledToTrue(promise) {\n            PerformPromiseThen(promise, void 0, rethrowAssertionErrorRejection);\n          }\n          const queueMicrotask = (() => {\n            const globalQueueMicrotask = globals && globals.queueMicrotask;\n            if (typeof globalQueueMicrotask === \"function\") {\n              return globalQueueMicrotask;\n            }\n            const resolvedPromise = promiseResolvedWith(void 0);\n            return (fn) => PerformPromiseThen(resolvedPromise, fn);\n          })();\n          function reflectCall(F2, V, args) {\n            if (typeof F2 !== \"function\") {\n              throw new TypeError(\"Argument is not a function\");\n            }\n            return Function.prototype.apply.call(F2, V, args);\n          }\n          function promiseCall(F2, V, args) {\n            try {\n              return promiseResolvedWith(reflectCall(F2, V, args));\n            } catch (value) {\n              return promiseRejectedWith(value);\n            }\n          }\n          const QUEUE_MAX_ARRAY_SIZE = 16384;\n          class SimpleQueue {\n            constructor() {\n              this._cursor = 0;\n              this._size = 0;\n              this._front = {\n                _elements: [],\n                _next: void 0\n              };\n              this._back = this._front;\n              this._cursor = 0;\n              this._size = 0;\n            }\n            get length() {\n              return this._size;\n            }\n            push(element) {\n              const oldBack = this._back;\n              let newBack = oldBack;\n              if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {\n                newBack = {\n                  _elements: [],\n                  _next: void 0\n                };\n              }\n              oldBack._elements.push(element);\n              if (newBack !== oldBack) {\n                this._back = newBack;\n                oldBack._next = newBack;\n              }\n              ++this._size;\n            }\n            shift() {\n              const oldFront = this._front;\n              let newFront = oldFront;\n              const oldCursor = this._cursor;\n              let newCursor = oldCursor + 1;\n              const elements = oldFront._elements;\n              const element = elements[oldCursor];\n              if (newCursor === QUEUE_MAX_ARRAY_SIZE) {\n                newFront = oldFront._next;\n                newCursor = 0;\n              }\n              --this._size;\n              this._cursor = newCursor;\n              if (oldFront !== newFront) {\n                this._front = newFront;\n              }\n              elements[oldCursor] = void 0;\n              return element;\n            }\n            forEach(callback) {\n              let i2 = this._cursor;\n              let node = this._front;\n              let elements = node._elements;\n              while (i2 !== elements.length || node._next !== void 0) {\n                if (i2 === elements.length) {\n                  node = node._next;\n                  elements = node._elements;\n                  i2 = 0;\n                  if (elements.length === 0) {\n                    break;\n                  }\n                }\n                callback(elements[i2]);\n                ++i2;\n              }\n            }\n            peek() {\n              const front = this._front;\n              const cursor = this._cursor;\n              return front._elements[cursor];\n            }\n          }\n          function ReadableStreamReaderGenericInitialize(reader, stream) {\n            reader._ownerReadableStream = stream;\n            stream._reader = reader;\n            if (stream._state === \"readable\") {\n              defaultReaderClosedPromiseInitialize(reader);\n            } else if (stream._state === \"closed\") {\n              defaultReaderClosedPromiseInitializeAsResolved(reader);\n            } else {\n              defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);\n            }\n          }\n          function ReadableStreamReaderGenericCancel(reader, reason) {\n            const stream = reader._ownerReadableStream;\n            return ReadableStreamCancel(stream, reason);\n          }\n          function ReadableStreamReaderGenericRelease(reader) {\n            if (reader._ownerReadableStream._state === \"readable\") {\n              defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n            } else {\n              defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n            }\n            reader._ownerReadableStream._reader = void 0;\n            reader._ownerReadableStream = void 0;\n          }\n          function readerLockException(name) {\n            return new TypeError(\"Cannot \" + name + \" a stream using a released reader\");\n          }\n          function defaultReaderClosedPromiseInitialize(reader) {\n            reader._closedPromise = newPromise((resolve, reject) => {\n              reader._closedPromise_resolve = resolve;\n              reader._closedPromise_reject = reject;\n            });\n          }\n          function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {\n            defaultReaderClosedPromiseInitialize(reader);\n            defaultReaderClosedPromiseReject(reader, reason);\n          }\n          function defaultReaderClosedPromiseInitializeAsResolved(reader) {\n            defaultReaderClosedPromiseInitialize(reader);\n            defaultReaderClosedPromiseResolve(reader);\n          }\n          function defaultReaderClosedPromiseReject(reader, reason) {\n            if (reader._closedPromise_reject === void 0) {\n              return;\n            }\n            setPromiseIsHandledToTrue(reader._closedPromise);\n            reader._closedPromise_reject(reason);\n            reader._closedPromise_resolve = void 0;\n            reader._closedPromise_reject = void 0;\n          }\n          function defaultReaderClosedPromiseResetToRejected(reader, reason) {\n            defaultReaderClosedPromiseInitializeAsRejected(reader, reason);\n          }\n          function defaultReaderClosedPromiseResolve(reader) {\n            if (reader._closedPromise_resolve === void 0) {\n              return;\n            }\n            reader._closedPromise_resolve(void 0);\n            reader._closedPromise_resolve = void 0;\n            reader._closedPromise_reject = void 0;\n          }\n          const AbortSteps = SymbolPolyfill(\"[[AbortSteps]]\");\n          const ErrorSteps = SymbolPolyfill(\"[[ErrorSteps]]\");\n          const CancelSteps = SymbolPolyfill(\"[[CancelSteps]]\");\n          const PullSteps = SymbolPolyfill(\"[[PullSteps]]\");\n          const NumberIsFinite = Number.isFinite || function(x2) {\n            return typeof x2 === \"number\" && isFinite(x2);\n          };\n          const MathTrunc = Math.trunc || function(v) {\n            return v < 0 ? Math.ceil(v) : Math.floor(v);\n          };\n          function isDictionary(x2) {\n            return typeof x2 === \"object\" || typeof x2 === \"function\";\n          }\n          function assertDictionary(obj, context) {\n            if (obj !== void 0 && !isDictionary(obj)) {\n              throw new TypeError(`${context} is not an object.`);\n            }\n          }\n          function assertFunction(x2, context) {\n            if (typeof x2 !== \"function\") {\n              throw new TypeError(`${context} is not a function.`);\n            }\n          }\n          function isObject(x2) {\n            return typeof x2 === \"object\" && x2 !== null || typeof x2 === \"function\";\n          }\n          function assertObject(x2, context) {\n            if (!isObject(x2)) {\n              throw new TypeError(`${context} is not an object.`);\n            }\n          }\n          function assertRequiredArgument(x2, position, context) {\n            if (x2 === void 0) {\n              throw new TypeError(`Parameter ${position} is required in '${context}'.`);\n            }\n          }\n          function assertRequiredField(x2, field, context) {\n            if (x2 === void 0) {\n              throw new TypeError(`${field} is required in '${context}'.`);\n            }\n          }\n          function convertUnrestrictedDouble(value) {\n            return Number(value);\n          }\n          function censorNegativeZero(x2) {\n            return x2 === 0 ? 0 : x2;\n          }\n          function integerPart(x2) {\n            return censorNegativeZero(MathTrunc(x2));\n          }\n          function convertUnsignedLongLongWithEnforceRange(value, context) {\n            const lowerBound = 0;\n            const upperBound = Number.MAX_SAFE_INTEGER;\n            let x2 = Number(value);\n            x2 = censorNegativeZero(x2);\n            if (!NumberIsFinite(x2)) {\n              throw new TypeError(`${context} is not a finite number`);\n            }\n            x2 = integerPart(x2);\n            if (x2 < lowerBound || x2 > upperBound) {\n              throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);\n            }\n            if (!NumberIsFinite(x2) || x2 === 0) {\n              return 0;\n            }\n            return x2;\n          }\n          function assertReadableStream(x2, context) {\n            if (!IsReadableStream(x2)) {\n              throw new TypeError(`${context} is not a ReadableStream.`);\n            }\n          }\n          function AcquireReadableStreamDefaultReader(stream) {\n            return new ReadableStreamDefaultReader(stream);\n          }\n          function ReadableStreamAddReadRequest(stream, readRequest) {\n            stream._reader._readRequests.push(readRequest);\n          }\n          function ReadableStreamFulfillReadRequest(stream, chunk, done) {\n            const reader = stream._reader;\n            const readRequest = reader._readRequests.shift();\n            if (done) {\n              readRequest._closeSteps();\n            } else {\n              readRequest._chunkSteps(chunk);\n            }\n          }\n          function ReadableStreamGetNumReadRequests(stream) {\n            return stream._reader._readRequests.length;\n          }\n          function ReadableStreamHasDefaultReader(stream) {\n            const reader = stream._reader;\n            if (reader === void 0) {\n              return false;\n            }\n            if (!IsReadableStreamDefaultReader(reader)) {\n              return false;\n            }\n            return true;\n          }\n          class ReadableStreamDefaultReader {\n            constructor(stream) {\n              assertRequiredArgument(stream, 1, \"ReadableStreamDefaultReader\");\n              assertReadableStream(stream, \"First parameter\");\n              if (IsReadableStreamLocked(stream)) {\n                throw new TypeError(\"This stream has already been locked for exclusive reading by another reader\");\n              }\n              ReadableStreamReaderGenericInitialize(this, stream);\n              this._readRequests = new SimpleQueue();\n            }\n            get closed() {\n              if (!IsReadableStreamDefaultReader(this)) {\n                return promiseRejectedWith(defaultReaderBrandCheckException(\"closed\"));\n              }\n              return this._closedPromise;\n            }\n            cancel(reason = void 0) {\n              if (!IsReadableStreamDefaultReader(this)) {\n                return promiseRejectedWith(defaultReaderBrandCheckException(\"cancel\"));\n              }\n              if (this._ownerReadableStream === void 0) {\n                return promiseRejectedWith(readerLockException(\"cancel\"));\n              }\n              return ReadableStreamReaderGenericCancel(this, reason);\n            }\n            read() {\n              if (!IsReadableStreamDefaultReader(this)) {\n                return promiseRejectedWith(defaultReaderBrandCheckException(\"read\"));\n              }\n              if (this._ownerReadableStream === void 0) {\n                return promiseRejectedWith(readerLockException(\"read from\"));\n              }\n              let resolvePromise;\n              let rejectPromise;\n              const promise = newPromise((resolve, reject) => {\n                resolvePromise = resolve;\n                rejectPromise = reject;\n              });\n              const readRequest = {\n                _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),\n                _closeSteps: () => resolvePromise({ value: void 0, done: true }),\n                _errorSteps: (e2) => rejectPromise(e2)\n              };\n              ReadableStreamDefaultReaderRead(this, readRequest);\n              return promise;\n            }\n            releaseLock() {\n              if (!IsReadableStreamDefaultReader(this)) {\n                throw defaultReaderBrandCheckException(\"releaseLock\");\n              }\n              if (this._ownerReadableStream === void 0) {\n                return;\n              }\n              if (this._readRequests.length > 0) {\n                throw new TypeError(\"Tried to release a reader lock when that reader has pending read() calls un-settled\");\n              }\n              ReadableStreamReaderGenericRelease(this);\n            }\n          }\n          Object.defineProperties(ReadableStreamDefaultReader.prototype, {\n            cancel: { enumerable: true },\n            read: { enumerable: true },\n            releaseLock: { enumerable: true },\n            closed: { enumerable: true }\n          });\n          if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n            Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {\n              value: \"ReadableStreamDefaultReader\",\n              configurable: true\n            });\n          }\n          function IsReadableStreamDefaultReader(x2) {\n            if (!typeIsObject(x2)) {\n              return false;\n            }\n            if (!Object.prototype.hasOwnProperty.call(x2, \"_readRequests\")) {\n              return false;\n            }\n            return x2 instanceof ReadableStreamDefaultReader;\n          }\n          function ReadableStreamDefaultReaderRead(reader, readRequest) {\n            const stream = reader._ownerReadableStream;\n            stream._disturbed = true;\n            if (stream._state === \"closed\") {\n              readRequest._closeSteps();\n            } else if (stream._state === \"errored\") {\n              readRequest._errorSteps(stream._storedError);\n            } else {\n              stream._readableStreamController[PullSteps](readRequest);\n            }\n          }\n          function defaultReaderBrandCheckException(name) {\n            return new TypeError(`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);\n          }\n          const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {\n          }).prototype);\n          class ReadableStreamAsyncIteratorImpl {\n            constructor(reader, preventCancel) {\n              this._ongoingPromise = void 0;\n              this._isFinished = false;\n              this._reader = reader;\n              this._preventCancel = preventCancel;\n            }\n            next() {\n              const nextSteps = () => this._nextSteps();\n              this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps();\n              return this._ongoingPromise;\n            }\n            return(value) {\n              const returnSteps = () => this._returnSteps(value);\n              return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();\n            }\n            _nextSteps() {\n              if (this._isFinished) {\n                return Promise.resolve({ value: void 0, done: true });\n              }\n              const reader = this._reader;\n              if (reader._ownerReadableStream === void 0) {\n                return promiseRejectedWith(readerLockException(\"iterate\"));\n              }\n              let resolvePromise;\n              let rejectPromise;\n              const promise = newPromise((resolve, reject) => {\n                resolvePromise = resolve;\n                rejectPromise = reject;\n              });\n              const readRequest = {\n                _chunkSteps: (chunk) => {\n                  this._ongoingPromise = void 0;\n                  queueMicrotask(() => resolvePromise({ value: chunk, done: false }));\n                },\n                _closeSteps: () => {\n                  this._ongoingPromise = void 0;\n                  this._isFinished = true;\n                  ReadableStreamReaderGenericRelease(reader);\n                  resolvePromise({ value: void 0, done: true });\n                },\n                _errorSteps: (reason) => {\n                  this._ongoingPromise = void 0;\n                  this._isFinished = true;\n                  ReadableStreamReaderGenericRelease(reader);\n                  rejectPromise(reason);\n                }\n              };\n              ReadableStreamDefaultReaderRead(reader, readRequest);\n              return promise;\n            }\n            _returnSteps(value) {\n              if (this._isFinished) {\n                return Promise.resolve({ value, done: true });\n              }\n              this._isFinished = true;\n              const reader = this._reader;\n              if (reader._ownerReadableStream === void 0) {\n                return promiseRejectedWith(readerLockException(\"finish iterating\"));\n              }\n              if (!this._preventCancel) {\n                const result = ReadableStreamReaderGenericCancel(reader, value);\n                ReadableStreamReaderGenericRelease(reader);\n                return transformPromiseWith(result, () => ({ value, done: true }));\n              }\n              ReadableStreamReaderGenericRelease(reader);\n              return promiseResolvedWith({ value, done: true });\n            }\n          }\n          const ReadableStreamAsyncIteratorPrototype = {\n            next() {\n              if (!IsReadableStreamAsyncIterator(this)) {\n                return promiseRejectedWith(streamAsyncIteratorBrandCheckException(\"next\"));\n              }\n              return this._asyncIteratorImpl.next();\n            },\n            return(value) {\n              if (!IsReadableStreamAsyncIterator(this)) {\n                return promiseRejectedWith(streamAsyncIteratorBrandCheckException(\"return\"));\n              }\n              return this._asyncIteratorImpl.return(value);\n            }\n          };\n          if (AsyncIteratorPrototype !== void 0) {\n            Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);\n          }\n          function AcquireReadableStreamAsyncIterator(stream, preventCancel) {\n            const reader = AcquireReadableStreamDefaultReader(stream);\n            const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);\n            const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);\n            iterator._asyncIteratorImpl = impl;\n            return iterator;\n          }\n          function IsReadableStreamAsyncIterator(x2) {\n            if (!typeIsObject(x2)) {\n              return false;\n            }\n            if (!Object.prototype.hasOwnProperty.call(x2, \"_asyncIteratorImpl\")) {\n              return false;\n            }\n            try {\n              return x2._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;\n            } catch (_a) {\n              return false;\n            }\n          }\n          function streamAsyncIteratorBrandCheckException(name) {\n            return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);\n          }\n          const NumberIsNaN = Number.isNaN || function(x2) {\n            return x2 !== x2;\n          };\n          function CreateArrayFromList(elements) {\n            return elements.slice();\n          }\n          function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {\n            new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);\n          }\n          function TransferArrayBuffer(O) {\n            return O;\n          }\n          function IsDetachedBuffer(O) {\n            return false;\n          }\n          function ArrayBufferSlice(buffer, begin, end) {\n            if (buffer.slice) {\n              return buffer.slice(begin, end);\n            }\n            const length = end - begin;\n            const slice = new ArrayBuffer(length);\n            CopyDataBlockBytes(slice, 0, buffer, begin, length);\n            return slice;\n          }\n          function IsNonNegativeNumber(v) {\n            if (typeof v !== \"number\") {\n              return false;\n            }\n            if (NumberIsNaN(v)) {\n              return false;\n            }\n            if (v < 0) {\n              return false;\n            }\n            return true;\n          }\n          function CloneAsUint8Array(O) {\n            const buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);\n            return new Uint8Array(buffer);\n          }\n          function DequeueValue(container) {\n            const pair = container._queue.shift();\n            container._queueTotalSize -= pair.size;\n            if (container._queueTotalSize < 0) {\n              container._queueTotalSize = 0;\n            }\n            return pair.value;\n          }\n          function EnqueueValueWithSize(container, value, size) {\n            if (!IsNonNegativeNumber(size) || size === Infinity) {\n              throw new RangeError(\"Size must be a finite, non-NaN, non-negative number.\");\n            }\n            container._queue.push({ value, size });\n            container._queueTotalSize += size;\n          }\n          function PeekQueueValue(container) {\n            const pair = container._queue.peek();\n            return pair.value;\n          }\n          function ResetQueue(container) {\n            container._queue = new SimpleQueue();\n            container._queueTotalSize = 0;\n          }\n          class ReadableStreamBYOBRequest {\n            constructor() {\n              throw new TypeError(\"Illegal constructor\");\n            }\n            get view() {\n              if (!IsReadableStreamBYOBRequest(this)) {\n                throw byobRequestBrandCheckException(\"view\");\n              }\n              return this._view;\n            }\n            respond(bytesWritten) {\n              if (!IsReadableStreamBYOBRequest(this)) {\n                throw byobRequestBrandCheckException(\"respond\");\n              }\n              assertRequiredArgument(bytesWritten, 1, \"respond\");\n              bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, \"First parameter\");\n              if (this._associatedReadableByteStreamController === void 0) {\n                throw new TypeError(\"This BYOB request has been invalidated\");\n              }\n              if (IsDetachedBuffer(this._view.buffer))\n                ;\n              ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);\n            }\n            respondWithNewView(view) {\n              if (!IsReadableStreamBYOBRequest(this)) {\n                throw byobRequestBrandCheckException(\"respondWithNewView\");\n              }\n              assertRequiredArgument(view, 1, \"respondWithNewView\");\n              if (!ArrayBuffer.isView(view)) {\n                throw new TypeError(\"You can only respond with array buffer views\");\n              }\n              if (this._associatedReadableByteStreamController === void 0) {\n                throw new TypeError(\"This BYOB request has been invalidated\");\n              }\n              if (IsDetachedBuffer(view.buffer))\n                ;\n              ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);\n            }\n          }\n          Object.defineProperties(ReadableStreamBYOBRequest.prototype, {\n            respond: { enumerable: true },\n            respondWithNewView: { enumerable: true },\n            view: { enumerable: true }\n          });\n          if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n            Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {\n              value: \"ReadableStreamBYOBRequest\",\n              configurable: true\n            });\n          }\n          class ReadableByteStreamController {\n            constructor() {\n              throw new TypeError(\"Illegal constructor\");\n            }\n            get byobRequest() {\n              if (!IsReadableByteStreamController(this)) {\n                throw byteStreamControllerBrandCheckException(\"byobRequest\");\n              }\n              return ReadableByteStreamControllerGetBYOBRequest(this);\n            }\n            get desiredSize() {\n              if (!IsReadableByteStreamController(this)) {\n                throw byteStreamControllerBrandCheckException(\"desiredSize\");\n              }\n              return ReadableByteStreamControllerGetDesiredSize(this);\n            }\n            close() {\n              if (!IsReadableByteStreamController(this)) {\n                throw byteStreamControllerBrandCheckException(\"close\");\n              }\n              if (this._closeRequested) {\n                throw new TypeError(\"The stream has already been closed; do not close it again!\");\n              }\n              const state = this._controlledReadableByteStream._state;\n              if (state !== \"readable\") {\n                throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);\n              }\n              ReadableByteStreamControllerClose(this);\n            }\n            enqueue(chunk) {\n              if (!IsReadableByteStreamController(this)) {\n                throw byteStreamControllerBrandCheckException(\"enqueue\");\n              }\n              assertRequiredArgument(chunk, 1, \"enqueue\");\n              if (!ArrayBuffer.isView(chunk)) {\n                throw new TypeError(\"chunk must be an array buffer view\");\n              }\n              if (chunk.byteLength === 0) {\n                throw new TypeError(\"chunk must have non-zero byteLength\");\n              }\n              if (chunk.buffer.byteLength === 0) {\n                throw new TypeError(`chunk's buffer must have non-zero byteLength`);\n              }\n              if (this._closeRequested) {\n                throw new TypeError(\"stream is closed or draining\");\n              }\n              const state = this._controlledReadableByteStream._state;\n              if (state !== \"readable\") {\n                throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);\n              }\n              ReadableByteStreamControllerEnqueue(this, chunk);\n            }\n            error(e2 = void 0) {\n              if (!IsReadableByteStreamController(this)) {\n                throw byteStreamControllerBrandCheckException(\"error\");\n              }\n              ReadableByteStreamControllerError(this, e2);\n            }\n            [CancelSteps](reason) {\n              ReadableByteStreamControllerClearPendingPullIntos(this);\n              ResetQueue(this);\n              const result = this._cancelAlgorithm(reason);\n              ReadableByteStreamControllerClearAlgorithms(this);\n              return result;\n            }\n            [PullSteps](readRequest) {\n              const stream = this._controlledReadableByteStream;\n              if (this._queueTotalSize > 0) {\n                const entry = this._queue.shift();\n                this._queueTotalSize -= entry.byteLength;\n                ReadableByteStreamControllerHandleQueueDrain(this);\n                const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);\n                readRequest._chunkSteps(view);\n                return;\n              }\n              const autoAllocateChunkSize = this._autoAllocateChunkSize;\n              if (autoAllocateChunkSize !== void 0) {\n                let buffer;\n                try {\n                  buffer = new ArrayBuffer(autoAllocateChunkSize);\n                } catch (bufferE) {\n                  readRequest._errorSteps(bufferE);\n                  return;\n                }\n                const pullIntoDescriptor = {\n                  buffer,\n                  bufferByteLength: autoAllocateChunkSize,\n                  byteOffset: 0,\n                  byteLength: autoAllocateChunkSize,\n                  bytesFilled: 0,\n                  elementSize: 1,\n                  viewConstructor: Uint8Array,\n                  readerType: \"default\"\n                };\n                this._pendingPullIntos.push(pullIntoDescriptor);\n              }\n              ReadableStreamAddReadRequest(stream, readRequest);\n              ReadableByteStreamControllerCallPullIfNeeded(this);\n            }\n          }\n          Object.defineProperties(ReadableByteStreamController.prototype, {\n            close: { enumerable: true },\n            enqueue: { enumerable: true },\n            error: { enumerable: true },\n            byobRequest: { enumerable: true },\n            desiredSize: { enumerable: true }\n          });\n          if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n            Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {\n              value: \"ReadableByteStreamController\",\n              configurable: true\n            });\n          }\n          function IsReadableByteStreamController(x2) {\n            if (!typeIsObject(x2)) {\n              return false;\n            }\n            if (!Object.prototype.hasOwnProperty.call(x2, \"_controlledReadableByteStream\")) {\n              return false;\n            }\n            return x2 instanceof ReadableByteStreamController;\n          }\n          function IsReadableStreamBYOBRequest(x2) {\n            if (!typeIsObject(x2)) {\n              return false;\n            }\n            if (!Object.prototype.hasOwnProperty.call(x2, \"_associatedReadableByteStreamController\")) {\n              return false;\n            }\n            return x2 instanceof ReadableStreamBYOBRequest;\n          }\n          function ReadableByteStreamControllerCallPullIfNeeded(controller) {\n            const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);\n            if (!shouldPull) {\n              return;\n            }\n            if (controller._pulling) {\n              controller._pullAgain = true;\n              return;\n            }\n            controller._pulling = true;\n            const pullPromise = controller._pullAlgorithm();\n            uponPromise(pullPromise, () => {\n              controller._pulling = false;\n              if (controller._pullAgain) {\n                controller._pullAgain = false;\n                ReadableByteStreamControllerCallPullIfNeeded(controller);\n              }\n            }, (e2) => {\n              ReadableByteStreamControllerError(controller, e2);\n            });\n          }\n          function ReadableByteStreamControllerClearPendingPullIntos(controller) {\n            ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n            controller._pendingPullIntos = new SimpleQueue();\n          }\n          function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {\n            let done = false;\n            if (stream._state === \"closed\") {\n              done = true;\n            }\n            const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n            if (pullIntoDescriptor.readerType === \"default\") {\n              ReadableStreamFulfillReadRequest(stream, filledView, done);\n            } else {\n              ReadableStreamFulfillReadIntoRequest(stream, filledView, done);\n            }\n          }\n          function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {\n            const bytesFilled = pullIntoDescriptor.bytesFilled;\n            const elementSize = pullIntoDescriptor.elementSize;\n            return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);\n          }\n          function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {\n            controller._queue.push({ buffer, byteOffset, byteLength });\n            controller._queueTotalSize += byteLength;\n          }\n          function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {\n            const elementSize = pullIntoDescriptor.elementSize;\n            const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;\n            const maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);\n            const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;\n            const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;\n            let totalBytesToCopyRemaining = maxBytesToCopy;\n            let ready = false;\n            if (maxAlignedBytes > currentAlignedBytes) {\n              totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;\n              ready = true;\n            }\n            const queue = controller._queue;\n            while (totalBytesToCopyRemaining > 0) {\n              const headOfQueue = queue.peek();\n              const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);\n              const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n              CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);\n              if (headOfQueue.byteLength === bytesToCopy) {\n                queue.shift();\n              } else {\n                headOfQueue.byteOffset += bytesToCopy;\n                headOfQueue.byteLength -= bytesToCopy;\n              }\n              controller._queueTotalSize -= bytesToCopy;\n              ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);\n              totalBytesToCopyRemaining -= bytesToCopy;\n            }\n            return ready;\n          }\n          function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {\n            pullIntoDescriptor.bytesFilled += size;\n          }\n          function ReadableByteStreamControllerHandleQueueDrain(controller) {\n            if (controller._queueTotalSize === 0 && controller._closeRequested) {\n              ReadableByteStreamControllerClearAlgorithms(controller);\n              ReadableStreamClose(controller._controlledReadableByteStream);\n            } else {\n              ReadableByteStreamControllerCallPullIfNeeded(controller);\n            }\n          }\n          function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {\n            if (controller._byobRequest === null) {\n              return;\n            }\n            controller._byobRequest._associatedReadableByteStreamController = void 0;\n            controller._byobRequest._view = null;\n            controller._byobRequest = null;\n          }\n          function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {\n            while (controller._pendingPullIntos.length > 0) {\n              if (controller._queueTotalSize === 0) {\n                return;\n              }\n              const pullIntoDescriptor = controller._pendingPullIntos.peek();\n              if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n                ReadableByteStreamControllerShiftPendingPullInto(controller);\n                ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n              }\n            }\n          }\n          function ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {\n            const stream = controller._controlledReadableByteStream;\n            let elementSize = 1;\n            if (view.constructor !== DataView) {\n              elementSize = view.constructor.BYTES_PER_ELEMENT;\n            }\n            const ctor = view.constructor;\n            const buffer = TransferArrayBuffer(view.buffer);\n            const pullIntoDescriptor = {\n              buffer,\n              bufferByteLength: buffer.byteLength,\n              byteOffset: view.byteOffset,\n              byteLength: view.byteLength,\n              bytesFilled: 0,\n              elementSize,\n              viewConstructor: ctor,\n              readerType: \"byob\"\n            };\n            if (controller._pendingPullIntos.length > 0) {\n              controller._pendingPullIntos.push(pullIntoDescriptor);\n              ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n              return;\n            }\n            if (stream._state === \"closed\") {\n              const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);\n              readIntoRequest._closeSteps(emptyView);\n              return;\n            }\n            if (controller._queueTotalSize > 0) {\n              if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n                const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n                ReadableByteStreamControllerHandleQueueDrain(controller);\n                readIntoRequest._chunkSteps(filledView);\n                return;\n              }\n              if (controller._closeRequested) {\n                const e2 = new TypeError(\"Insufficient bytes to fill elements in the given buffer\");\n                ReadableByteStreamControllerError(controller, e2);\n                readIntoRequest._errorSteps(e2);\n                return;\n              }\n            }\n            controller._pendingPullIntos.push(pullIntoDescriptor);\n            ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n            ReadableByteStreamControllerCallPullIfNeeded(controller);\n          }\n          function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {\n            const stream = controller._controlledReadableByteStream;\n            if (ReadableStreamHasBYOBReader(stream)) {\n              while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n                const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);\n                ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);\n              }\n            }\n          }\n          function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {\n            ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);\n            if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {\n              return;\n            }\n            ReadableByteStreamControllerShiftPendingPullInto(controller);\n            const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;\n            if (remainderSize > 0) {\n              const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n              const remainder = ArrayBufferSlice(pullIntoDescriptor.buffer, end - remainderSize, end);\n              ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);\n            }\n            pullIntoDescriptor.bytesFilled -= remainderSize;\n            ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n            ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n          }\n          function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {\n            const firstDescriptor = controller._pendingPullIntos.peek();\n            ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n            const state = controller._controlledReadableByteStream._state;\n            if (state === \"closed\") {\n              ReadableByteStreamControllerRespondInClosedState(controller);\n            } else {\n              ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);\n            }\n            ReadableByteStreamControllerCallPullIfNeeded(controller);\n          }\n          function ReadableByteStreamControllerShiftPendingPullInto(controller) {\n            const descriptor = controller._pendingPullIntos.shift();\n            return descriptor;\n          }\n          function ReadableByteStreamControllerShouldCallPull(controller) {\n            const stream = controller._controlledReadableByteStream;\n            if (stream._state !== \"readable\") {\n              return false;\n            }\n            if (controller._closeRequested) {\n              return false;\n            }\n            if (!controller._started) {\n              return false;\n            }\n            if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n              return true;\n            }\n            if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n              return true;\n            }\n            const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);\n            if (desiredSize > 0) {\n              return true;\n            }\n            return false;\n          }\n          function ReadableByteStreamControllerClearAlgorithms(controller) {\n            controller._pullAlgorithm = void 0;\n            controller._cancelAlgorithm = void 0;\n          }\n          function ReadableByteStreamControllerClose(controller) {\n            const stream = controller._controlledReadableByteStream;\n            if (controller._closeRequested || stream._state !== \"readable\") {\n              return;\n            }\n            if (controller._queueTotalSize > 0) {\n              controller._closeRequested = true;\n              return;\n            }\n            if (controller._pendingPullIntos.length > 0) {\n              const firstPendingPullInto = controller._pendingPullIntos.peek();\n              if (firstPendingPullInto.bytesFilled > 0) {\n                const e2 = new TypeError(\"Insufficient bytes to fill elements in the given buffer\");\n                ReadableByteStreamControllerError(controller, e2);\n                throw e2;\n              }\n            }\n            ReadableByteStreamControllerClearAlgorithms(controller);\n            ReadableStreamClose(stream);\n          }\n          function ReadableByteStreamControllerEnqueue(controller, chunk) {\n            const stream = controller._controlledReadableByteStream;\n            if (controller._closeRequested || stream._state !== \"readable\") {\n              return;\n            }\n            const buffer = chunk.buffer;\n            const byteOffset = chunk.byteOffset;\n            const byteLength = chunk.byteLength;\n            const transferredBuffer = TransferArrayBuffer(buffer);\n            if (controller._pendingPullIntos.length > 0) {\n              const firstPendingPullInto = controller._pendingPullIntos.peek();\n              if (IsDetachedBuffer(firstPendingPullInto.buffer))\n                ;\n              firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);\n            }\n            ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n            if (ReadableStreamHasDefaultReader(stream)) {\n              if (ReadableStreamGetNumReadRequests(stream) === 0) {\n                ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n              } else {\n                if (controller._pendingPullIntos.length > 0) {\n                  ReadableByteStreamControllerShiftPendingPullInto(controller);\n                }\n                const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);\n                ReadableStreamFulfillReadRequest(stream, transferredView, false);\n              }\n            } else if (ReadableStreamHasBYOBReader(stream)) {\n              ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n              ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n            } else {\n              ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n            }\n            ReadableByteStreamControllerCallPullIfNeeded(controller);\n          }\n          function ReadableByteStreamControllerError(controller, e2) {\n            const stream = controller._controlledReadableByteStream;\n            if (stream._state !== \"readable\") {\n              return;\n            }\n            ReadableByteStreamControllerClearPendingPullIntos(controller);\n            ResetQueue(controller);\n            ReadableByteStreamControllerClearAlgorithms(controller);\n            ReadableStreamError(stream, e2);\n          }\n          function ReadableByteStreamControllerGetBYOBRequest(controller) {\n            if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {\n              const firstDescriptor = controller._pendingPullIntos.peek();\n              const view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);\n              const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);\n              SetUpReadableStreamBYOBRequest(byobRequest, controller, view);\n              controller._byobRequest = byobRequest;\n            }\n            return controller._byobRequest;\n          }\n          function ReadableByteStreamControllerGetDesiredSize(controller) {\n            const state = controller._controlledReadableByteStream._state;\n            if (state === \"errored\") {\n              return null;\n            }\n            if (state === \"closed\") {\n              return 0;\n            }\n            return controller._strategyHWM - controller._queueTotalSize;\n          }\n          function ReadableByteStreamControllerRespond(controller, bytesWritten) {\n            const firstDescriptor = controller._pendingPullIntos.peek();\n            const state = controller._controlledReadableByteStream._state;\n            if (state === \"closed\") {\n              if (bytesWritten !== 0) {\n                throw new TypeError(\"bytesWritten must be 0 when calling respond() on a closed stream\");\n              }\n            } else {\n              if (bytesWritten === 0) {\n                throw new TypeError(\"bytesWritten must be greater than 0 when calling respond() on a readable stream\");\n              }\n              if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {\n                throw new RangeError(\"bytesWritten out of range\");\n              }\n            }\n            firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);\n            ReadableByteStreamControllerRespondInternal(controller, bytesWritten);\n          }\n          function ReadableByteStreamControllerRespondWithNewView(controller, view) {\n            const firstDescriptor = controller._pendingPullIntos.peek();\n            const state = controller._controlledReadableByteStream._state;\n            if (state === \"closed\") {\n              if (view.byteLength !== 0) {\n                throw new TypeError(\"The view's length must be 0 when calling respondWithNewView() on a closed stream\");\n              }\n            } else {\n              if (view.byteLength === 0) {\n                throw new TypeError(\"The view's length must be greater than 0 when calling respondWithNewView() on a readable stream\");\n              }\n            }\n            if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {\n              throw new RangeError(\"The region specified by view does not match byobRequest\");\n            }\n            if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {\n              throw new RangeError(\"The buffer of view has different capacity than byobRequest\");\n            }\n            if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {\n              throw new RangeError(\"The region specified by view is larger than byobRequest\");\n            }\n            const viewByteLength = view.byteLength;\n            firstDescriptor.buffer = TransferArrayBuffer(view.buffer);\n            ReadableByteStreamControllerRespondInternal(controller, viewByteLength);\n          }\n          function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {\n            controller._controlledReadableByteStream = stream;\n            controller._pullAgain = false;\n            controller._pulling = false;\n            controller._byobRequest = null;\n            controller._queue = controller._queueTotalSize = void 0;\n            ResetQueue(controller);\n            controller._closeRequested = false;\n            controller._started = false;\n            controller._strategyHWM = highWaterMark;\n            controller._pullAlgorithm = pullAlgorithm;\n            controller._cancelAlgorithm = cancelAlgorithm;\n            controller._autoAllocateChunkSize = autoAllocateChunkSize;\n            controller._pendingPullIntos = new SimpleQueue();\n            stream._readableStreamController = controller;\n            const startResult = startAlgorithm();\n            uponPromise(promiseResolvedWith(startResult), () => {\n              controller._started = true;\n              ReadableByteStreamControllerCallPullIfNeeded(controller);\n            }, (r22) => {\n              ReadableByteStreamControllerError(controller, r22);\n            });\n          }\n          function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {\n            const controller = Object.create(ReadableByteStreamController.prototype);\n            let startAlgorithm = () => void 0;\n            let pullAlgorithm = () => promiseResolvedWith(void 0);\n            let cancelAlgorithm = () => promiseResolvedWith(void 0);\n            if (underlyingByteSource.start !== void 0) {\n              startAlgorithm = () => underlyingByteSource.start(controller);\n            }\n            if (underlyingByteSource.pull !== void 0) {\n              pullAlgorithm = () => underlyingByteSource.pull(controller);\n            }\n            if (underlyingByteSource.cancel !== void 0) {\n              cancelAlgorithm = (reason) => underlyingByteSource.cancel(reason);\n            }\n            const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;\n            if (autoAllocateChunkSize === 0) {\n              throw new TypeError(\"autoAllocateChunkSize must be greater than 0\");\n            }\n            SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);\n          }\n          function SetUpReadableStreamBYOBRequest(request, controller, view) {\n            request._associatedReadableByteStreamController = controller;\n            request._view = view;\n          }\n          function byobRequestBrandCheckException(name) {\n            return new TypeError(`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);\n          }\n          function byteStreamControllerBrandCheckException(name) {\n            return new TypeError(`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);\n          }\n          function AcquireReadableStreamBYOBReader(stream) {\n            return new ReadableStreamBYOBReader(stream);\n          }\n          function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {\n            stream._reader._readIntoRequests.push(readIntoRequest);\n          }\n          function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {\n            const reader = stream._reader;\n            const readIntoRequest = reader._readIntoRequests.shift();\n            if (done) {\n              readIntoRequest._closeSteps(chunk);\n            } else {\n              readIntoRequest._chunkSteps(chunk);\n            }\n          }\n          function ReadableStreamGetNumReadIntoRequests(stream) {\n            return stream._reader._readIntoRequests.length;\n          }\n          function ReadableStreamHasBYOBReader(stream) {\n            const reader = stream._reader;\n            if (reader === void 0) {\n              return false;\n            }\n            if (!IsReadableStreamBYOBReader(reader)) {\n              return false;\n            }\n            return true;\n          }\n          class ReadableStreamBYOBReader {\n            constructor(stream) {\n              assertRequiredArgument(stream, 1, \"ReadableStreamBYOBReader\");\n              assertReadableStream(stream, \"First parameter\");\n              if (IsReadableStreamLocked(stream)) {\n                throw new TypeError(\"This stream has already been locked for exclusive reading by another reader\");\n              }\n              if (!IsReadableByteStreamController(stream._readableStreamController)) {\n                throw new TypeError(\"Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source\");\n              }\n              ReadableStreamReaderGenericInitialize(this, stream);\n              this._readIntoRequests = new SimpleQueue();\n            }\n            get closed() {\n              if (!IsReadableStreamBYOBReader(this)) {\n                return promiseRejectedWith(byobReaderBrandCheckException(\"closed\"));\n              }\n              return this._closedPromise;\n            }\n            cancel(reason = void 0) {\n              if (!IsReadableStreamBYOBReader(this)) {\n                return promiseRejectedWith(byobReaderBrandCheckException(\"cancel\"));\n              }\n              if (this._ownerReadableStream === void 0) {\n                return promiseRejectedWith(readerLockException(\"cancel\"));\n              }\n              return ReadableStreamReaderGenericCancel(this, reason);\n            }\n            read(view) {\n              if (!IsReadableStreamBYOBReader(this)) {\n                return promiseRejectedWith(byobReaderBrandCheckException(\"read\"));\n              }\n              if (!ArrayBuffer.isView(view)) {\n                return promiseRejectedWith(new TypeError(\"view must be an array buffer view\"));\n              }\n              if (view.byteLength === 0) {\n                return promiseRejectedWith(new TypeError(\"view must have non-zero byteLength\"));\n              }\n              if (view.buffer.byteLength === 0) {\n                return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));\n              }\n              if (IsDetachedBuffer(view.buffer))\n                ;\n              if (this._ownerReadableStream === void 0) {\n                return promiseRejectedWith(readerLockException(\"read from\"));\n              }\n              let resolvePromise;\n              let rejectPromise;\n              const promise = newPromise((resolve, reject) => {\n                resolvePromise = resolve;\n                rejectPromise = reject;\n              });\n              const readIntoRequest = {\n                _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),\n                _closeSteps: (chunk) => resolvePromise({ value: chunk, done: true }),\n                _errorSteps: (e2) => rejectPromise(e2)\n              };\n              ReadableStreamBYOBReaderRead(this, view, readIntoRequest);\n              return promise;\n            }\n            releaseLock() {\n              if (!IsReadableStreamBYOBReader(this)) {\n                throw byobReaderBrandCheckException(\"releaseLock\");\n              }\n              if (this._ownerReadableStream === void 0) {\n                return;\n              }\n              if (this._readIntoRequests.length > 0) {\n                throw new TypeError(\"Tried to release a reader lock when that reader has pending read() calls un-settled\");\n              }\n              ReadableStreamReaderGenericRelease(this);\n            }\n          }\n          Object.defineProperties(ReadableStreamBYOBReader.prototype, {\n            cancel: { enumerable: true },\n            read: { enumerable: true },\n            releaseLock: { enumerable: true },\n            closed: { enumerable: true }\n          });\n          if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n            Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {\n              value: \"ReadableStreamBYOBReader\",\n              configurable: true\n            });\n          }\n          function IsReadableStreamBYOBReader(x2) {\n            if (!typeIsObject(x2)) {\n              return false;\n            }\n            if (!Object.prototype.hasOwnProperty.call(x2, \"_readIntoRequests\")) {\n              return false;\n            }\n            return x2 instanceof ReadableStreamBYOBReader;\n          }\n          function ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {\n            const stream = reader._ownerReadableStream;\n            stream._disturbed = true;\n            if (stream._state === \"errored\") {\n              readIntoRequest._errorSteps(stream._storedError);\n            } else {\n              ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);\n            }\n          }\n          function byobReaderBrandCheckException(name) {\n            return new TypeError(`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);\n          }\n          function ExtractHighWaterMark(strategy, defaultHWM) {\n            const { highWaterMark } = strategy;\n            if (highWaterMark === void 0) {\n              return defaultHWM;\n            }\n            if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {\n              throw new RangeError(\"Invalid highWaterMark\");\n            }\n            return highWaterMark;\n          }\n          function ExtractSizeAlgorithm(strategy) {\n            const { size } = strategy;\n            if (!size) {\n              return () => 1;\n            }\n            return size;\n          }\n          function convertQueuingStrategy(init, context) {\n            assertDictionary(init, context);\n            const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;\n            const size = init === null || init === void 0 ? void 0 : init.size;\n            return {\n              highWaterMark: highWaterMark === void 0 ? void 0 : convertUnrestrictedDouble(highWaterMark),\n              size: size === void 0 ? void 0 : convertQueuingStrategySize(size, `${context} has member 'size' that`)\n            };\n          }\n          function convertQueuingStrategySize(fn, context) {\n            assertFunction(fn, context);\n            return (chunk) => convertUnrestrictedDouble(fn(chunk));\n          }\n          function convertUnderlyingSink(original, context) {\n            assertDictionary(original, context);\n            const abort = original === null || original === void 0 ? void 0 : original.abort;\n            const close = original === null || original === void 0 ? void 0 : original.close;\n            const start = original === null || original === void 0 ? void 0 : original.start;\n            const type = original === null || original === void 0 ? void 0 : original.type;\n            const write = original === null || original === void 0 ? void 0 : original.write;\n            return {\n              abort: abort === void 0 ? void 0 : convertUnderlyingSinkAbortCallback(abort, original, `${context} has member 'abort' that`),\n              close: close === void 0 ? void 0 : convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),\n              start: start === void 0 ? void 0 : convertUnderlyingSinkStartCallback(start, original, `${context} has member 'start' that`),\n              write: write === void 0 ? void 0 : convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),\n              type\n            };\n          }\n          function convertUnderlyingSinkAbortCallback(fn, original, context) {\n            assertFunction(fn, context);\n            return (reason) => promiseCall(fn, original, [reason]);\n          }\n          function convertUnderlyingSinkCloseCallback(fn, original, context) {\n            assertFunction(fn, context);\n            return () => promiseCall(fn, original, []);\n          }\n          function convertUnderlyingSinkStartCallback(fn, original, context) {\n            assertFunction(fn, context);\n            return (controller) => reflectCall(fn, original, [controller]);\n          }\n          function convertUnderlyingSinkWriteCallback(fn, original, context) {\n            assertFunction(fn, context);\n            return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);\n          }\n          function assertWritableStream(x2, context) {\n            if (!IsWritableStream(x2)) {\n              throw new TypeError(`${context} is not a WritableStream.`);\n            }\n          }\n          function isAbortSignal2(value) {\n            if (typeof value !== \"object\" || value === null) {\n              return false;\n            }\n            try {\n              return typeof value.aborted === \"boolean\";\n            } catch (_a) {\n              return false;\n            }\n          }\n          const supportsAbortController = typeof AbortController === \"function\";\n          function createAbortController() {\n            if (supportsAbortController) {\n              return new AbortController();\n            }\n            return void 0;\n          }\n          class WritableStream {\n            constructor(rawUnderlyingSink = {}, rawStrategy = {}) {\n              if (rawUnderlyingSink === void 0) {\n                rawUnderlyingSink = null;\n              } else {\n                assertObject(rawUnderlyingSink, \"First parameter\");\n              }\n              const strategy = convertQueuingStrategy(rawStrategy, \"Second parameter\");\n              const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, \"First parameter\");\n              InitializeWritableStream(this);\n              const type = underlyingSink.type;\n              if (type !== void 0) {\n                throw new RangeError(\"Invalid type is specified\");\n              }\n              const sizeAlgorithm = ExtractSizeAlgorithm(strategy);\n              const highWaterMark = ExtractHighWaterMark(strategy, 1);\n              SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);\n            }\n            get locked() {\n              if (!IsWritableStream(this)) {\n                throw streamBrandCheckException$2(\"locked\");\n              }\n              return IsWritableStreamLocked(this);\n            }\n            abort(reason = void 0) {\n              if (!IsWritableStream(this)) {\n                return promiseRejectedWith(streamBrandCheckException$2(\"abort\"));\n              }\n              if (IsWritableStreamLocked(this)) {\n                return promiseRejectedWith(new TypeError(\"Cannot abort a stream that already has a writer\"));\n              }\n              return WritableStreamAbort(this, reason);\n            }\n            close() {\n              if (!IsWritableStream(this)) {\n                return promiseRejectedWith(streamBrandCheckException$2(\"close\"));\n              }\n              if (IsWritableStreamLocked(this)) {\n                return promiseRejectedWith(new TypeError(\"Cannot close a stream that already has a writer\"));\n              }\n              if (WritableStreamCloseQueuedOrInFlight(this)) {\n                return promiseRejectedWith(new TypeError(\"Cannot close an already-closing stream\"));\n              }\n              return WritableStreamClose(this);\n            }\n            getWriter() {\n              if (!IsWritableStream(this)) {\n                throw streamBrandCheckException$2(\"getWriter\");\n              }\n              return AcquireWritableStreamDefaultWriter(this);\n            }\n          }\n          Object.defineProperties(WritableStream.prototype, {\n            abort: { enumerable: true },\n            close: { enumerable: true },\n            getWriter: { enumerable: true },\n            locked: { enumerable: true }\n          });\n          if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n            Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {\n              value: \"WritableStream\",\n              configurable: true\n            });\n          }\n          function AcquireWritableStreamDefaultWriter(stream) {\n            return new WritableStreamDefaultWriter(stream);\n          }\n          function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {\n            const stream = Object.create(WritableStream.prototype);\n            InitializeWritableStream(stream);\n            const controller = Object.create(WritableStreamDefaultController.prototype);\n            SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n            return stream;\n          }\n          function InitializeWritableStream(stream) {\n            stream._state = \"writable\";\n            stream._storedError = void 0;\n            stream._writer = void 0;\n            stream._writableStreamController = void 0;\n            stream._writeRequests = new SimpleQueue();\n            stream._inFlightWriteRequest = void 0;\n            stream._closeRequest = void 0;\n            stream._inFlightCloseRequest = void 0;\n            stream._pendingAbortRequest = void 0;\n            stream._backpressure = false;\n          }\n          function IsWritableStream(x2) {\n            if (!typeIsObject(x2)) {\n              return false;\n            }\n            if (!Object.prototype.hasOwnProperty.call(x2, \"_writableStreamController\")) {\n              return false;\n            }\n            return x2 instanceof WritableStream;\n          }\n          function IsWritableStreamLocked(stream) {\n            if (stream._writer === void 0) {\n              return false;\n            }\n            return true;\n          }\n          function WritableStreamAbort(stream, reason) {\n            var _a;\n            if (stream._state === \"closed\" || stream._state === \"errored\") {\n              return promiseResolvedWith(void 0);\n            }\n            stream._writableStreamController._abortReason = reason;\n            (_a = stream._writableStreamController._abortController) === null || _a === void 0 ? void 0 : _a.abort();\n            const state = stream._state;\n            if (state === \"closed\" || state === \"errored\") {\n              return promiseResolvedWith(void 0);\n            }\n            if (stream._pendingAbortRequest !== void 0) {\n              return stream._pendingAbortRequest._promise;\n            }\n            let wasAlreadyErroring = false;\n            if (state === \"erroring\") {\n              wasAlreadyErroring = true;\n              reason = void 0;\n            }\n            const promise = newPromise((resolve, reject) => {\n              stream._pendingAbortRequest = {\n                _promise: void 0,\n                _resolve: resolve,\n                _reject: reject,\n                _reason: reason,\n                _wasAlreadyErroring: wasAlreadyErroring\n              };\n            });\n            stream._pendingAbortRequest._promise = promise;\n            if (!wasAlreadyErroring) {\n              WritableStreamStartErroring(stream, reason);\n            }\n            return promise;\n          }\n          function WritableStreamClose(stream) {\n            const state = stream._state;\n            if (state === \"closed\" || state === \"errored\") {\n              return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));\n            }\n            const promise = newPromise((resolve, reject) => {\n              const closeRequest = {\n                _resolve: resolve,\n                _reject: reject\n              };\n              stream._closeRequest = closeRequest;\n            });\n            const writer = stream._writer;\n            if (writer !== void 0 && stream._backpressure && state === \"writable\") {\n              defaultWriterReadyPromiseResolve(writer);\n            }\n            WritableStreamDefaultControllerClose(stream._writableStreamController);\n            return promise;\n          }\n          function WritableStreamAddWriteRequest(stream) {\n            const promise = newPromise((resolve, reject) => {\n              const writeRequest = {\n                _resolve: resolve,\n                _reject: reject\n              };\n              stream._writeRequests.push(writeRequest);\n            });\n            return promise;\n          }\n          function WritableStreamDealWithRejection(stream, error) {\n            const state = stream._state;\n            if (state === \"writable\") {\n              WritableStreamStartErroring(stream, error);\n              return;\n            }\n            WritableStreamFinishErroring(stream);\n          }\n          function WritableStreamStartErroring(stream, reason) {\n            const controller = stream._writableStreamController;\n            stream._state = \"erroring\";\n            stream._storedError = reason;\n            const writer = stream._writer;\n            if (writer !== void 0) {\n              WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);\n            }\n            if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {\n              WritableStreamFinishErroring(stream);\n            }\n          }\n          function WritableStreamFinishErroring(stream) {\n            stream._state = \"errored\";\n            stream._writableStreamController[ErrorSteps]();\n            const storedError = stream._storedError;\n            stream._writeRequests.forEach((writeRequest) => {\n              writeRequest._reject(storedError);\n            });\n            stream._writeRequests = new SimpleQueue();\n            if (stream._pendingAbortRequest === void 0) {\n              WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n              return;\n            }\n            const abortRequest = stream._pendingAbortRequest;\n            stream._pendingAbortRequest = void 0;\n            if (abortRequest._wasAlreadyErroring) {\n              abortRequest._reject(storedError);\n              WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n              return;\n            }\n            const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);\n            uponPromise(promise, () => {\n              abortRequest._resolve();\n              WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n            }, (reason) => {\n              abortRequest._reject(reason);\n              WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n            });\n          }\n          function WritableStreamFinishInFlightWrite(stream) {\n            stream._inFlightWriteRequest._resolve(void 0);\n            stream._inFlightWriteRequest = void 0;\n          }\n          function WritableStreamFinishInFlightWriteWithError(stream, error) {\n            stream._inFlightWriteRequest._reject(error);\n            stream._inFlightWriteRequest = void 0;\n            WritableStreamDealWithRejection(stream, error);\n          }\n          function WritableStreamFinishInFlightClose(stream) {\n            stream._inFlightCloseRequest._resolve(void 0);\n            stream._inFlightCloseRequest = void 0;\n            const state = stream._state;\n            if (state === \"erroring\") {\n              stream._storedError = void 0;\n              if (stream._pendingAbortRequest !== void 0) {\n                stream._pendingAbortRequest._resolve();\n                stream._pendingAbortRequest = void 0;\n              }\n            }\n            stream._state = \"closed\";\n            const writer = stream._writer;\n            if (writer !== void 0) {\n              defaultWriterClosedPromiseResolve(writer);\n            }\n          }\n          function WritableStreamFinishInFlightCloseWithError(stream, error) {\n            stream._inFlightCloseRequest._reject(error);\n            stream._inFlightCloseRequest = void 0;\n            if (stream._pendingAbortRequest !== void 0) {\n              stream._pendingAbortRequest._reject(error);\n              stream._pendingAbortRequest = void 0;\n            }\n            WritableStreamDealWithRejection(stream, error);\n          }\n          function WritableStreamCloseQueuedOrInFlight(stream) {\n            if (stream._closeRequest === void 0 && stream._inFlightCloseRequest === void 0) {\n              return false;\n            }\n            return true;\n          }\n          function WritableStreamHasOperationMarkedInFlight(stream) {\n            if (stream._inFlightWriteRequest === void 0 && stream._inFlightCloseRequest === void 0) {\n              return false;\n            }\n            return true;\n          }\n          function WritableStreamMarkCloseRequestInFlight(stream) {\n            stream._inFlightCloseRequest = stream._closeRequest;\n            stream._closeRequest = void 0;\n          }\n          function WritableStreamMarkFirstWriteRequestInFlight(stream) {\n            stream._inFlightWriteRequest = stream._writeRequests.shift();\n          }\n          function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {\n            if (stream._closeRequest !== void 0) {\n              stream._closeRequest._reject(stream._storedError);\n              stream._closeRequest = void 0;\n            }\n            const writer = stream._writer;\n            if (writer !== void 0) {\n              defaultWriterClosedPromiseReject(writer, stream._storedError);\n            }\n          }\n          function WritableStreamUpdateBackpressure(stream, backpressure) {\n            const writer = stream._writer;\n            if (writer !== void 0 && backpressure !== stream._backpressure) {\n              if (backpressure) {\n                defaultWriterReadyPromiseReset(writer);\n              } else {\n                defaultWriterReadyPromiseResolve(writer);\n              }\n            }\n            stream._backpressure = backpressure;\n          }\n          class WritableStreamDefaultWriter {\n            constructor(stream) {\n              assertRequiredArgument(stream, 1, \"WritableStreamDefaultWriter\");\n              assertWritableStream(stream, \"First parameter\");\n              if (IsWritableStreamLocked(stream)) {\n                throw new TypeError(\"This stream has already been locked for exclusive writing by another writer\");\n              }\n              this._ownerWritableStream = stream;\n              stream._writer = this;\n              const state = stream._state;\n              if (state === \"writable\") {\n                if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {\n                  defaultWriterReadyPromiseInitialize(this);\n                } else {\n                  defaultWriterReadyPromiseInitializeAsResolved(this);\n                }\n                defaultWriterClosedPromiseInitialize(this);\n              } else if (state === \"erroring\") {\n                defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);\n                defaultWriterClosedPromiseInitialize(this);\n              } else if (state === \"closed\") {\n                defaultWriterReadyPromiseInitializeAsResolved(this);\n                defaultWriterClosedPromiseInitializeAsResolved(this);\n              } else {\n                const storedError = stream._storedError;\n                defaultWriterReadyPromiseInitializeAsRejected(this, storedError);\n                defaultWriterClosedPromiseInitializeAsRejected(this, storedError);\n              }\n            }\n            get closed() {\n              if (!IsWritableStreamDefaultWriter(this)) {\n                return promiseRejectedWith(defaultWriterBrandCheckException(\"closed\"));\n              }\n              return this._closedPromise;\n            }\n            get desiredSize() {\n              if (!IsWritableStreamDefaultWriter(this)) {\n                throw defaultWriterBrandCheckException(\"desiredSize\");\n              }\n              if (this._ownerWritableStream === void 0) {\n                throw defaultWriterLockException(\"desiredSize\");\n              }\n              return WritableStreamDefaultWriterGetDesiredSize(this);\n            }\n            get ready() {\n              if (!IsWritableStreamDefaultWriter(this)) {\n                return promiseRejectedWith(defaultWriterBrandCheckException(\"ready\"));\n              }\n              return this._readyPromise;\n            }\n            abort(reason = void 0) {\n              if (!IsWritableStreamDefaultWriter(this)) {\n                return promiseRejectedWith(defaultWriterBrandCheckException(\"abort\"));\n              }\n              if (this._ownerWritableStream === void 0) {\n                return promiseRejectedWith(defaultWriterLockException(\"abort\"));\n              }\n              return WritableStreamDefaultWriterAbort(this, reason);\n            }\n            close() {\n              if (!IsWritableStreamDefaultWriter(this)) {\n                return promiseRejectedWith(defaultWriterBrandCheckException(\"close\"));\n              }\n              const stream = this._ownerWritableStream;\n              if (stream === void 0) {\n                return promiseRejectedWith(defaultWriterLockException(\"close\"));\n              }\n              if (WritableStreamCloseQueuedOrInFlight(stream)) {\n                return promiseRejectedWith(new TypeError(\"Cannot close an already-closing stream\"));\n              }\n              return WritableStreamDefaultWriterClose(this);\n            }\n            releaseLock() {\n              if (!IsWritableStreamDefaultWriter(this)) {\n                throw defaultWriterBrandCheckException(\"releaseLock\");\n              }\n              const stream = this._ownerWritableStream;\n              if (stream === void 0) {\n                return;\n              }\n              WritableStreamDefaultWriterRelease(this);\n            }\n            write(chunk = void 0) {\n              if (!IsWritableStreamDefaultWriter(this)) {\n                return promiseRejectedWith(defaultWriterBrandCheckException(\"write\"));\n              }\n              if (this._ownerWritableStream === void 0) {\n                return promiseRejectedWith(defaultWriterLockException(\"write to\"));\n              }\n              return WritableStreamDefaultWriterWrite(this, chunk);\n            }\n          }\n          Object.defineProperties(WritableStreamDefaultWriter.prototype, {\n            abort: { enumerable: true },\n            close: { enumerable: true },\n            releaseLock: { enumerable: true },\n            write: { enumerable: true },\n            closed: { enumerable: true },\n            desiredSize: { enumerable: true },\n            ready: { enumerable: true }\n          });\n          if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n            Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {\n              value: \"WritableStreamDefaultWriter\",\n              configurable: true\n            });\n          }\n          function IsWritableStreamDefaultWriter(x2) {\n            if (!typeIsObject(x2)) {\n              return false;\n            }\n            if (!Object.prototype.hasOwnProperty.call(x2, \"_ownerWritableStream\")) {\n              return false;\n            }\n            return x2 instanceof WritableStreamDefaultWriter;\n          }\n          function WritableStreamDefaultWriterAbort(writer, reason) {\n            const stream = writer._ownerWritableStream;\n            return WritableStreamAbort(stream, reason);\n          }\n          function WritableStreamDefaultWriterClose(writer) {\n            const stream = writer._ownerWritableStream;\n            return WritableStreamClose(stream);\n          }\n          function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {\n            const stream = writer._ownerWritableStream;\n            const state = stream._state;\n            if (WritableStreamCloseQueuedOrInFlight(stream) || state === \"closed\") {\n              return promiseResolvedWith(void 0);\n            }\n            if (state === \"errored\") {\n              return promiseRejectedWith(stream._storedError);\n            }\n            return WritableStreamDefaultWriterClose(writer);\n          }\n          function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {\n            if (writer._closedPromiseState === \"pending\") {\n              defaultWriterClosedPromiseReject(writer, error);\n            } else {\n              defaultWriterClosedPromiseResetToRejected(writer, error);\n            }\n          }\n          function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {\n            if (writer._readyPromiseState === \"pending\") {\n              defaultWriterReadyPromiseReject(writer, error);\n            } else {\n              defaultWriterReadyPromiseResetToRejected(writer, error);\n            }\n          }\n          function WritableStreamDefaultWriterGetDesiredSize(writer) {\n            const stream = writer._ownerWritableStream;\n            const state = stream._state;\n            if (state === \"errored\" || state === \"erroring\") {\n              return null;\n            }\n            if (state === \"closed\") {\n              return 0;\n            }\n            return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);\n          }\n          function WritableStreamDefaultWriterRelease(writer) {\n            const stream = writer._ownerWritableStream;\n            const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);\n            WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);\n            WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);\n            stream._writer = void 0;\n            writer._ownerWritableStream = void 0;\n          }\n          function WritableStreamDefaultWriterWrite(writer, chunk) {\n            const stream = writer._ownerWritableStream;\n            const controller = stream._writableStreamController;\n            const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);\n            if (stream !== writer._ownerWritableStream) {\n              return promiseRejectedWith(defaultWriterLockException(\"write to\"));\n            }\n            const state = stream._state;\n            if (state === \"errored\") {\n              return promiseRejectedWith(stream._storedError);\n            }\n            if (WritableStreamCloseQueuedOrInFlight(stream) || state === \"closed\") {\n              return promiseRejectedWith(new TypeError(\"The stream is closing or closed and cannot be written to\"));\n            }\n            if (state === \"erroring\") {\n              return promiseRejectedWith(stream._storedError);\n            }\n            const promise = WritableStreamAddWriteRequest(stream);\n            WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);\n            return promise;\n          }\n          const closeSentinel = {};\n          class WritableStreamDefaultController {\n            constructor() {\n              throw new TypeError(\"Illegal constructor\");\n            }\n            get abortReason() {\n              if (!IsWritableStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException$2(\"abortReason\");\n              }\n              return this._abortReason;\n            }\n            get signal() {\n              if (!IsWritableStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException$2(\"signal\");\n              }\n              if (this._abortController === void 0) {\n                throw new TypeError(\"WritableStreamDefaultController.prototype.signal is not supported\");\n              }\n              return this._abortController.signal;\n            }\n            error(e2 = void 0) {\n              if (!IsWritableStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException$2(\"error\");\n              }\n              const state = this._controlledWritableStream._state;\n              if (state !== \"writable\") {\n                return;\n              }\n              WritableStreamDefaultControllerError(this, e2);\n            }\n            [AbortSteps](reason) {\n              const result = this._abortAlgorithm(reason);\n              WritableStreamDefaultControllerClearAlgorithms(this);\n              return result;\n            }\n            [ErrorSteps]() {\n              ResetQueue(this);\n            }\n          }\n          Object.defineProperties(WritableStreamDefaultController.prototype, {\n            abortReason: { enumerable: true },\n            signal: { enumerable: true },\n            error: { enumerable: true }\n          });\n          if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n            Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n              value: \"WritableStreamDefaultController\",\n              configurable: true\n            });\n          }\n          function IsWritableStreamDefaultController(x2) {\n            if (!typeIsObject(x2)) {\n              return false;\n            }\n            if (!Object.prototype.hasOwnProperty.call(x2, \"_controlledWritableStream\")) {\n              return false;\n            }\n            return x2 instanceof WritableStreamDefaultController;\n          }\n          function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {\n            controller._controlledWritableStream = stream;\n            stream._writableStreamController = controller;\n            controller._queue = void 0;\n            controller._queueTotalSize = void 0;\n            ResetQueue(controller);\n            controller._abortReason = void 0;\n            controller._abortController = createAbortController();\n            controller._started = false;\n            controller._strategySizeAlgorithm = sizeAlgorithm;\n            controller._strategyHWM = highWaterMark;\n            controller._writeAlgorithm = writeAlgorithm;\n            controller._closeAlgorithm = closeAlgorithm;\n            controller._abortAlgorithm = abortAlgorithm;\n            const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n            WritableStreamUpdateBackpressure(stream, backpressure);\n            const startResult = startAlgorithm();\n            const startPromise = promiseResolvedWith(startResult);\n            uponPromise(startPromise, () => {\n              controller._started = true;\n              WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n            }, (r22) => {\n              controller._started = true;\n              WritableStreamDealWithRejection(stream, r22);\n            });\n          }\n          function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {\n            const controller = Object.create(WritableStreamDefaultController.prototype);\n            let startAlgorithm = () => void 0;\n            let writeAlgorithm = () => promiseResolvedWith(void 0);\n            let closeAlgorithm = () => promiseResolvedWith(void 0);\n            let abortAlgorithm = () => promiseResolvedWith(void 0);\n            if (underlyingSink.start !== void 0) {\n              startAlgorithm = () => underlyingSink.start(controller);\n            }\n            if (underlyingSink.write !== void 0) {\n              writeAlgorithm = (chunk) => underlyingSink.write(chunk, controller);\n            }\n            if (underlyingSink.close !== void 0) {\n              closeAlgorithm = () => underlyingSink.close();\n            }\n            if (underlyingSink.abort !== void 0) {\n              abortAlgorithm = (reason) => underlyingSink.abort(reason);\n            }\n            SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n          }\n          function WritableStreamDefaultControllerClearAlgorithms(controller) {\n            controller._writeAlgorithm = void 0;\n            controller._closeAlgorithm = void 0;\n            controller._abortAlgorithm = void 0;\n            controller._strategySizeAlgorithm = void 0;\n          }\n          function WritableStreamDefaultControllerClose(controller) {\n            EnqueueValueWithSize(controller, closeSentinel, 0);\n            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n          }\n          function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {\n            try {\n              return controller._strategySizeAlgorithm(chunk);\n            } catch (chunkSizeE) {\n              WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);\n              return 1;\n            }\n          }\n          function WritableStreamDefaultControllerGetDesiredSize(controller) {\n            return controller._strategyHWM - controller._queueTotalSize;\n          }\n          function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {\n            try {\n              EnqueueValueWithSize(controller, chunk, chunkSize);\n            } catch (enqueueE) {\n              WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);\n              return;\n            }\n            const stream = controller._controlledWritableStream;\n            if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === \"writable\") {\n              const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n              WritableStreamUpdateBackpressure(stream, backpressure);\n            }\n            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n          }\n          function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {\n            const stream = controller._controlledWritableStream;\n            if (!controller._started) {\n              return;\n            }\n            if (stream._inFlightWriteRequest !== void 0) {\n              return;\n            }\n            const state = stream._state;\n            if (state === \"erroring\") {\n              WritableStreamFinishErroring(stream);\n              return;\n            }\n            if (controller._queue.length === 0) {\n              return;\n            }\n            const value = PeekQueueValue(controller);\n            if (value === closeSentinel) {\n              WritableStreamDefaultControllerProcessClose(controller);\n            } else {\n              WritableStreamDefaultControllerProcessWrite(controller, value);\n            }\n          }\n          function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {\n            if (controller._controlledWritableStream._state === \"writable\") {\n              WritableStreamDefaultControllerError(controller, error);\n            }\n          }\n          function WritableStreamDefaultControllerProcessClose(controller) {\n            const stream = controller._controlledWritableStream;\n            WritableStreamMarkCloseRequestInFlight(stream);\n            DequeueValue(controller);\n            const sinkClosePromise = controller._closeAlgorithm();\n            WritableStreamDefaultControllerClearAlgorithms(controller);\n            uponPromise(sinkClosePromise, () => {\n              WritableStreamFinishInFlightClose(stream);\n            }, (reason) => {\n              WritableStreamFinishInFlightCloseWithError(stream, reason);\n            });\n          }\n          function WritableStreamDefaultControllerProcessWrite(controller, chunk) {\n            const stream = controller._controlledWritableStream;\n            WritableStreamMarkFirstWriteRequestInFlight(stream);\n            const sinkWritePromise = controller._writeAlgorithm(chunk);\n            uponPromise(sinkWritePromise, () => {\n              WritableStreamFinishInFlightWrite(stream);\n              const state = stream._state;\n              DequeueValue(controller);\n              if (!WritableStreamCloseQueuedOrInFlight(stream) && state === \"writable\") {\n                const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n                WritableStreamUpdateBackpressure(stream, backpressure);\n              }\n              WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n            }, (reason) => {\n              if (stream._state === \"writable\") {\n                WritableStreamDefaultControllerClearAlgorithms(controller);\n              }\n              WritableStreamFinishInFlightWriteWithError(stream, reason);\n            });\n          }\n          function WritableStreamDefaultControllerGetBackpressure(controller) {\n            const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);\n            return desiredSize <= 0;\n          }\n          function WritableStreamDefaultControllerError(controller, error) {\n            const stream = controller._controlledWritableStream;\n            WritableStreamDefaultControllerClearAlgorithms(controller);\n            WritableStreamStartErroring(stream, error);\n          }\n          function streamBrandCheckException$2(name) {\n            return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);\n          }\n          function defaultControllerBrandCheckException$2(name) {\n            return new TypeError(`WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`);\n          }\n          function defaultWriterBrandCheckException(name) {\n            return new TypeError(`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);\n          }\n          function defaultWriterLockException(name) {\n            return new TypeError(\"Cannot \" + name + \" a stream using a released writer\");\n          }\n          function defaultWriterClosedPromiseInitialize(writer) {\n            writer._closedPromise = newPromise((resolve, reject) => {\n              writer._closedPromise_resolve = resolve;\n              writer._closedPromise_reject = reject;\n              writer._closedPromiseState = \"pending\";\n            });\n          }\n          function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {\n            defaultWriterClosedPromiseInitialize(writer);\n            defaultWriterClosedPromiseReject(writer, reason);\n          }\n          function defaultWriterClosedPromiseInitializeAsResolved(writer) {\n            defaultWriterClosedPromiseInitialize(writer);\n            defaultWriterClosedPromiseResolve(writer);\n          }\n          function defaultWriterClosedPromiseReject(writer, reason) {\n            if (writer._closedPromise_reject === void 0) {\n              return;\n            }\n            setPromiseIsHandledToTrue(writer._closedPromise);\n            writer._closedPromise_reject(reason);\n            writer._closedPromise_resolve = void 0;\n            writer._closedPromise_reject = void 0;\n            writer._closedPromiseState = \"rejected\";\n          }\n          function defaultWriterClosedPromiseResetToRejected(writer, reason) {\n            defaultWriterClosedPromiseInitializeAsRejected(writer, reason);\n          }\n          function defaultWriterClosedPromiseResolve(writer) {\n            if (writer._closedPromise_resolve === void 0) {\n              return;\n            }\n            writer._closedPromise_resolve(void 0);\n            writer._closedPromise_resolve = void 0;\n            writer._closedPromise_reject = void 0;\n            writer._closedPromiseState = \"resolved\";\n          }\n          function defaultWriterReadyPromiseInitialize(writer) {\n            writer._readyPromise = newPromise((resolve, reject) => {\n              writer._readyPromise_resolve = resolve;\n              writer._readyPromise_reject = reject;\n            });\n            writer._readyPromiseState = \"pending\";\n          }\n          function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {\n            defaultWriterReadyPromiseInitialize(writer);\n            defaultWriterReadyPromiseReject(writer, reason);\n          }\n          function defaultWriterReadyPromiseInitializeAsResolved(writer) {\n            defaultWriterReadyPromiseInitialize(writer);\n            defaultWriterReadyPromiseResolve(writer);\n          }\n          function defaultWriterReadyPromiseReject(writer, reason) {\n            if (writer._readyPromise_reject === void 0) {\n              return;\n            }\n            setPromiseIsHandledToTrue(writer._readyPromise);\n            writer._readyPromise_reject(reason);\n            writer._readyPromise_resolve = void 0;\n            writer._readyPromise_reject = void 0;\n            writer._readyPromiseState = \"rejected\";\n          }\n          function defaultWriterReadyPromiseReset(writer) {\n            defaultWriterReadyPromiseInitialize(writer);\n          }\n          function defaultWriterReadyPromiseResetToRejected(writer, reason) {\n            defaultWriterReadyPromiseInitializeAsRejected(writer, reason);\n          }\n          function defaultWriterReadyPromiseResolve(writer) {\n            if (writer._readyPromise_resolve === void 0) {\n              return;\n            }\n            writer._readyPromise_resolve(void 0);\n            writer._readyPromise_resolve = void 0;\n            writer._readyPromise_reject = void 0;\n            writer._readyPromiseState = \"fulfilled\";\n          }\n          const NativeDOMException = typeof DOMException !== \"undefined\" ? DOMException : void 0;\n          function isDOMExceptionConstructor(ctor) {\n            if (!(typeof ctor === \"function\" || typeof ctor === \"object\")) {\n              return false;\n            }\n            try {\n              new ctor();\n              return true;\n            } catch (_a) {\n              return false;\n            }\n          }\n          function createDOMExceptionPolyfill() {\n            const ctor = function DOMException3(message, name) {\n              this.message = message || \"\";\n              this.name = name || \"Error\";\n              if (Error.captureStackTrace) {\n                Error.captureStackTrace(this, this.constructor);\n              }\n            };\n            ctor.prototype = Object.create(Error.prototype);\n            Object.defineProperty(ctor.prototype, \"constructor\", { value: ctor, writable: true, configurable: true });\n            return ctor;\n          }\n          const DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();\n          function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {\n            const reader = AcquireReadableStreamDefaultReader(source);\n            const writer = AcquireWritableStreamDefaultWriter(dest);\n            source._disturbed = true;\n            let shuttingDown = false;\n            let currentWrite = promiseResolvedWith(void 0);\n            return newPromise((resolve, reject) => {\n              let abortAlgorithm;\n              if (signal !== void 0) {\n                abortAlgorithm = () => {\n                  const error = new DOMException$1(\"Aborted\", \"AbortError\");\n                  const actions = [];\n                  if (!preventAbort) {\n                    actions.push(() => {\n                      if (dest._state === \"writable\") {\n                        return WritableStreamAbort(dest, error);\n                      }\n                      return promiseResolvedWith(void 0);\n                    });\n                  }\n                  if (!preventCancel) {\n                    actions.push(() => {\n                      if (source._state === \"readable\") {\n                        return ReadableStreamCancel(source, error);\n                      }\n                      return promiseResolvedWith(void 0);\n                    });\n                  }\n                  shutdownWithAction(() => Promise.all(actions.map((action) => action())), true, error);\n                };\n                if (signal.aborted) {\n                  abortAlgorithm();\n                  return;\n                }\n                signal.addEventListener(\"abort\", abortAlgorithm);\n              }\n              function pipeLoop() {\n                return newPromise((resolveLoop, rejectLoop) => {\n                  function next(done) {\n                    if (done) {\n                      resolveLoop();\n                    } else {\n                      PerformPromiseThen(pipeStep(), next, rejectLoop);\n                    }\n                  }\n                  next(false);\n                });\n              }\n              function pipeStep() {\n                if (shuttingDown) {\n                  return promiseResolvedWith(true);\n                }\n                return PerformPromiseThen(writer._readyPromise, () => {\n                  return newPromise((resolveRead, rejectRead) => {\n                    ReadableStreamDefaultReaderRead(reader, {\n                      _chunkSteps: (chunk) => {\n                        currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), void 0, noop2);\n                        resolveRead(false);\n                      },\n                      _closeSteps: () => resolveRead(true),\n                      _errorSteps: rejectRead\n                    });\n                  });\n                });\n              }\n              isOrBecomesErrored(source, reader._closedPromise, (storedError) => {\n                if (!preventAbort) {\n                  shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);\n                } else {\n                  shutdown(true, storedError);\n                }\n              });\n              isOrBecomesErrored(dest, writer._closedPromise, (storedError) => {\n                if (!preventCancel) {\n                  shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);\n                } else {\n                  shutdown(true, storedError);\n                }\n              });\n              isOrBecomesClosed(source, reader._closedPromise, () => {\n                if (!preventClose) {\n                  shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));\n                } else {\n                  shutdown();\n                }\n              });\n              if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === \"closed\") {\n                const destClosed = new TypeError(\"the destination writable stream closed before all data could be piped to it\");\n                if (!preventCancel) {\n                  shutdownWithAction(() => ReadableStreamCancel(source, destClosed), true, destClosed);\n                } else {\n                  shutdown(true, destClosed);\n                }\n              }\n              setPromiseIsHandledToTrue(pipeLoop());\n              function waitForWritesToFinish() {\n                const oldCurrentWrite = currentWrite;\n                return PerformPromiseThen(currentWrite, () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : void 0);\n              }\n              function isOrBecomesErrored(stream, promise, action) {\n                if (stream._state === \"errored\") {\n                  action(stream._storedError);\n                } else {\n                  uponRejection(promise, action);\n                }\n              }\n              function isOrBecomesClosed(stream, promise, action) {\n                if (stream._state === \"closed\") {\n                  action();\n                } else {\n                  uponFulfillment(promise, action);\n                }\n              }\n              function shutdownWithAction(action, originalIsError, originalError) {\n                if (shuttingDown) {\n                  return;\n                }\n                shuttingDown = true;\n                if (dest._state === \"writable\" && !WritableStreamCloseQueuedOrInFlight(dest)) {\n                  uponFulfillment(waitForWritesToFinish(), doTheRest);\n                } else {\n                  doTheRest();\n                }\n                function doTheRest() {\n                  uponPromise(action(), () => finalize(originalIsError, originalError), (newError) => finalize(true, newError));\n                }\n              }\n              function shutdown(isError, error) {\n                if (shuttingDown) {\n                  return;\n                }\n                shuttingDown = true;\n                if (dest._state === \"writable\" && !WritableStreamCloseQueuedOrInFlight(dest)) {\n                  uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error));\n                } else {\n                  finalize(isError, error);\n                }\n              }\n              function finalize(isError, error) {\n                WritableStreamDefaultWriterRelease(writer);\n                ReadableStreamReaderGenericRelease(reader);\n                if (signal !== void 0) {\n                  signal.removeEventListener(\"abort\", abortAlgorithm);\n                }\n                if (isError) {\n                  reject(error);\n                } else {\n                  resolve(void 0);\n                }\n              }\n            });\n          }\n          class ReadableStreamDefaultController {\n            constructor() {\n              throw new TypeError(\"Illegal constructor\");\n            }\n            get desiredSize() {\n              if (!IsReadableStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException$1(\"desiredSize\");\n              }\n              return ReadableStreamDefaultControllerGetDesiredSize(this);\n            }\n            close() {\n              if (!IsReadableStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException$1(\"close\");\n              }\n              if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {\n                throw new TypeError(\"The stream is not in a state that permits close\");\n              }\n              ReadableStreamDefaultControllerClose(this);\n            }\n            enqueue(chunk = void 0) {\n              if (!IsReadableStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException$1(\"enqueue\");\n              }\n              if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {\n                throw new TypeError(\"The stream is not in a state that permits enqueue\");\n              }\n              return ReadableStreamDefaultControllerEnqueue(this, chunk);\n            }\n            error(e2 = void 0) {\n              if (!IsReadableStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException$1(\"error\");\n              }\n              ReadableStreamDefaultControllerError(this, e2);\n            }\n            [CancelSteps](reason) {\n              ResetQueue(this);\n              const result = this._cancelAlgorithm(reason);\n              ReadableStreamDefaultControllerClearAlgorithms(this);\n              return result;\n            }\n            [PullSteps](readRequest) {\n              const stream = this._controlledReadableStream;\n              if (this._queue.length > 0) {\n                const chunk = DequeueValue(this);\n                if (this._closeRequested && this._queue.length === 0) {\n                  ReadableStreamDefaultControllerClearAlgorithms(this);\n                  ReadableStreamClose(stream);\n                } else {\n                  ReadableStreamDefaultControllerCallPullIfNeeded(this);\n                }\n                readRequest._chunkSteps(chunk);\n              } else {\n                ReadableStreamAddReadRequest(stream, readRequest);\n                ReadableStreamDefaultControllerCallPullIfNeeded(this);\n              }\n            }\n          }\n          Object.defineProperties(ReadableStreamDefaultController.prototype, {\n            close: { enumerable: true },\n            enqueue: { enumerable: true },\n            error: { enumerable: true },\n            desiredSize: { enumerable: true }\n          });\n          if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n            Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n              value: \"ReadableStreamDefaultController\",\n              configurable: true\n            });\n          }\n          function IsReadableStreamDefaultController(x2) {\n            if (!typeIsObject(x2)) {\n              return false;\n            }\n            if (!Object.prototype.hasOwnProperty.call(x2, \"_controlledReadableStream\")) {\n              return false;\n            }\n            return x2 instanceof ReadableStreamDefaultController;\n          }\n          function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {\n            const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);\n            if (!shouldPull) {\n              return;\n            }\n            if (controller._pulling) {\n              controller._pullAgain = true;\n              return;\n            }\n            controller._pulling = true;\n            const pullPromise = controller._pullAlgorithm();\n            uponPromise(pullPromise, () => {\n              controller._pulling = false;\n              if (controller._pullAgain) {\n                controller._pullAgain = false;\n                ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n              }\n            }, (e2) => {\n              ReadableStreamDefaultControllerError(controller, e2);\n            });\n          }\n          function ReadableStreamDefaultControllerShouldCallPull(controller) {\n            const stream = controller._controlledReadableStream;\n            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n              return false;\n            }\n            if (!controller._started) {\n              return false;\n            }\n            if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n              return true;\n            }\n            const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);\n            if (desiredSize > 0) {\n              return true;\n            }\n            return false;\n          }\n          function ReadableStreamDefaultControllerClearAlgorithms(controller) {\n            controller._pullAlgorithm = void 0;\n            controller._cancelAlgorithm = void 0;\n            controller._strategySizeAlgorithm = void 0;\n          }\n          function ReadableStreamDefaultControllerClose(controller) {\n            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n              return;\n            }\n            const stream = controller._controlledReadableStream;\n            controller._closeRequested = true;\n            if (controller._queue.length === 0) {\n              ReadableStreamDefaultControllerClearAlgorithms(controller);\n              ReadableStreamClose(stream);\n            }\n          }\n          function ReadableStreamDefaultControllerEnqueue(controller, chunk) {\n            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n              return;\n            }\n            const stream = controller._controlledReadableStream;\n            if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n              ReadableStreamFulfillReadRequest(stream, chunk, false);\n            } else {\n              let chunkSize;\n              try {\n                chunkSize = controller._strategySizeAlgorithm(chunk);\n              } catch (chunkSizeE) {\n                ReadableStreamDefaultControllerError(controller, chunkSizeE);\n                throw chunkSizeE;\n              }\n              try {\n                EnqueueValueWithSize(controller, chunk, chunkSize);\n              } catch (enqueueE) {\n                ReadableStreamDefaultControllerError(controller, enqueueE);\n                throw enqueueE;\n              }\n            }\n            ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n          }\n          function ReadableStreamDefaultControllerError(controller, e2) {\n            const stream = controller._controlledReadableStream;\n            if (stream._state !== \"readable\") {\n              return;\n            }\n            ResetQueue(controller);\n            ReadableStreamDefaultControllerClearAlgorithms(controller);\n            ReadableStreamError(stream, e2);\n          }\n          function ReadableStreamDefaultControllerGetDesiredSize(controller) {\n            const state = controller._controlledReadableStream._state;\n            if (state === \"errored\") {\n              return null;\n            }\n            if (state === \"closed\") {\n              return 0;\n            }\n            return controller._strategyHWM - controller._queueTotalSize;\n          }\n          function ReadableStreamDefaultControllerHasBackpressure(controller) {\n            if (ReadableStreamDefaultControllerShouldCallPull(controller)) {\n              return false;\n            }\n            return true;\n          }\n          function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {\n            const state = controller._controlledReadableStream._state;\n            if (!controller._closeRequested && state === \"readable\") {\n              return true;\n            }\n            return false;\n          }\n          function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {\n            controller._controlledReadableStream = stream;\n            controller._queue = void 0;\n            controller._queueTotalSize = void 0;\n            ResetQueue(controller);\n            controller._started = false;\n            controller._closeRequested = false;\n            controller._pullAgain = false;\n            controller._pulling = false;\n            controller._strategySizeAlgorithm = sizeAlgorithm;\n            controller._strategyHWM = highWaterMark;\n            controller._pullAlgorithm = pullAlgorithm;\n            controller._cancelAlgorithm = cancelAlgorithm;\n            stream._readableStreamController = controller;\n            const startResult = startAlgorithm();\n            uponPromise(promiseResolvedWith(startResult), () => {\n              controller._started = true;\n              ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n            }, (r22) => {\n              ReadableStreamDefaultControllerError(controller, r22);\n            });\n          }\n          function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {\n            const controller = Object.create(ReadableStreamDefaultController.prototype);\n            let startAlgorithm = () => void 0;\n            let pullAlgorithm = () => promiseResolvedWith(void 0);\n            let cancelAlgorithm = () => promiseResolvedWith(void 0);\n            if (underlyingSource.start !== void 0) {\n              startAlgorithm = () => underlyingSource.start(controller);\n            }\n            if (underlyingSource.pull !== void 0) {\n              pullAlgorithm = () => underlyingSource.pull(controller);\n            }\n            if (underlyingSource.cancel !== void 0) {\n              cancelAlgorithm = (reason) => underlyingSource.cancel(reason);\n            }\n            SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);\n          }\n          function defaultControllerBrandCheckException$1(name) {\n            return new TypeError(`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);\n          }\n          function ReadableStreamTee(stream, cloneForBranch2) {\n            if (IsReadableByteStreamController(stream._readableStreamController)) {\n              return ReadableByteStreamTee(stream);\n            }\n            return ReadableStreamDefaultTee(stream);\n          }\n          function ReadableStreamDefaultTee(stream, cloneForBranch2) {\n            const reader = AcquireReadableStreamDefaultReader(stream);\n            let reading = false;\n            let readAgain = false;\n            let canceled1 = false;\n            let canceled2 = false;\n            let reason1;\n            let reason2;\n            let branch1;\n            let branch2;\n            let resolveCancelPromise;\n            const cancelPromise = newPromise((resolve) => {\n              resolveCancelPromise = resolve;\n            });\n            function pullAlgorithm() {\n              if (reading) {\n                readAgain = true;\n                return promiseResolvedWith(void 0);\n              }\n              reading = true;\n              const readRequest = {\n                _chunkSteps: (chunk) => {\n                  queueMicrotask(() => {\n                    readAgain = false;\n                    const chunk1 = chunk;\n                    const chunk2 = chunk;\n                    if (!canceled1) {\n                      ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);\n                    }\n                    if (!canceled2) {\n                      ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);\n                    }\n                    reading = false;\n                    if (readAgain) {\n                      pullAlgorithm();\n                    }\n                  });\n                },\n                _closeSteps: () => {\n                  reading = false;\n                  if (!canceled1) {\n                    ReadableStreamDefaultControllerClose(branch1._readableStreamController);\n                  }\n                  if (!canceled2) {\n                    ReadableStreamDefaultControllerClose(branch2._readableStreamController);\n                  }\n                  if (!canceled1 || !canceled2) {\n                    resolveCancelPromise(void 0);\n                  }\n                },\n                _errorSteps: () => {\n                  reading = false;\n                }\n              };\n              ReadableStreamDefaultReaderRead(reader, readRequest);\n              return promiseResolvedWith(void 0);\n            }\n            function cancel1Algorithm(reason) {\n              canceled1 = true;\n              reason1 = reason;\n              if (canceled2) {\n                const compositeReason = CreateArrayFromList([reason1, reason2]);\n                const cancelResult = ReadableStreamCancel(stream, compositeReason);\n                resolveCancelPromise(cancelResult);\n              }\n              return cancelPromise;\n            }\n            function cancel2Algorithm(reason) {\n              canceled2 = true;\n              reason2 = reason;\n              if (canceled1) {\n                const compositeReason = CreateArrayFromList([reason1, reason2]);\n                const cancelResult = ReadableStreamCancel(stream, compositeReason);\n                resolveCancelPromise(cancelResult);\n              }\n              return cancelPromise;\n            }\n            function startAlgorithm() {\n            }\n            branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);\n            branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);\n            uponRejection(reader._closedPromise, (r22) => {\n              ReadableStreamDefaultControllerError(branch1._readableStreamController, r22);\n              ReadableStreamDefaultControllerError(branch2._readableStreamController, r22);\n              if (!canceled1 || !canceled2) {\n                resolveCancelPromise(void 0);\n              }\n            });\n            return [branch1, branch2];\n          }\n          function ReadableByteStreamTee(stream) {\n            let reader = AcquireReadableStreamDefaultReader(stream);\n            let reading = false;\n            let readAgainForBranch1 = false;\n            let readAgainForBranch2 = false;\n            let canceled1 = false;\n            let canceled2 = false;\n            let reason1;\n            let reason2;\n            let branch1;\n            let branch2;\n            let resolveCancelPromise;\n            const cancelPromise = newPromise((resolve) => {\n              resolveCancelPromise = resolve;\n            });\n            function forwardReaderError(thisReader) {\n              uponRejection(thisReader._closedPromise, (r22) => {\n                if (thisReader !== reader) {\n                  return;\n                }\n                ReadableByteStreamControllerError(branch1._readableStreamController, r22);\n                ReadableByteStreamControllerError(branch2._readableStreamController, r22);\n                if (!canceled1 || !canceled2) {\n                  resolveCancelPromise(void 0);\n                }\n              });\n            }\n            function pullWithDefaultReader() {\n              if (IsReadableStreamBYOBReader(reader)) {\n                ReadableStreamReaderGenericRelease(reader);\n                reader = AcquireReadableStreamDefaultReader(stream);\n                forwardReaderError(reader);\n              }\n              const readRequest = {\n                _chunkSteps: (chunk) => {\n                  queueMicrotask(() => {\n                    readAgainForBranch1 = false;\n                    readAgainForBranch2 = false;\n                    const chunk1 = chunk;\n                    let chunk2 = chunk;\n                    if (!canceled1 && !canceled2) {\n                      try {\n                        chunk2 = CloneAsUint8Array(chunk);\n                      } catch (cloneE) {\n                        ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);\n                        ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);\n                        resolveCancelPromise(ReadableStreamCancel(stream, cloneE));\n                        return;\n                      }\n                    }\n                    if (!canceled1) {\n                      ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);\n                    }\n                    if (!canceled2) {\n                      ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);\n                    }\n                    reading = false;\n                    if (readAgainForBranch1) {\n                      pull1Algorithm();\n                    } else if (readAgainForBranch2) {\n                      pull2Algorithm();\n                    }\n                  });\n                },\n                _closeSteps: () => {\n                  reading = false;\n                  if (!canceled1) {\n                    ReadableByteStreamControllerClose(branch1._readableStreamController);\n                  }\n                  if (!canceled2) {\n                    ReadableByteStreamControllerClose(branch2._readableStreamController);\n                  }\n                  if (branch1._readableStreamController._pendingPullIntos.length > 0) {\n                    ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);\n                  }\n                  if (branch2._readableStreamController._pendingPullIntos.length > 0) {\n                    ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);\n                  }\n                  if (!canceled1 || !canceled2) {\n                    resolveCancelPromise(void 0);\n                  }\n                },\n                _errorSteps: () => {\n                  reading = false;\n                }\n              };\n              ReadableStreamDefaultReaderRead(reader, readRequest);\n            }\n            function pullWithBYOBReader(view, forBranch2) {\n              if (IsReadableStreamDefaultReader(reader)) {\n                ReadableStreamReaderGenericRelease(reader);\n                reader = AcquireReadableStreamBYOBReader(stream);\n                forwardReaderError(reader);\n              }\n              const byobBranch = forBranch2 ? branch2 : branch1;\n              const otherBranch = forBranch2 ? branch1 : branch2;\n              const readIntoRequest = {\n                _chunkSteps: (chunk) => {\n                  queueMicrotask(() => {\n                    readAgainForBranch1 = false;\n                    readAgainForBranch2 = false;\n                    const byobCanceled = forBranch2 ? canceled2 : canceled1;\n                    const otherCanceled = forBranch2 ? canceled1 : canceled2;\n                    if (!otherCanceled) {\n                      let clonedChunk;\n                      try {\n                        clonedChunk = CloneAsUint8Array(chunk);\n                      } catch (cloneE) {\n                        ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);\n                        ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);\n                        resolveCancelPromise(ReadableStreamCancel(stream, cloneE));\n                        return;\n                      }\n                      if (!byobCanceled) {\n                        ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n                      }\n                      ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);\n                    } else if (!byobCanceled) {\n                      ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n                    }\n                    reading = false;\n                    if (readAgainForBranch1) {\n                      pull1Algorithm();\n                    } else if (readAgainForBranch2) {\n                      pull2Algorithm();\n                    }\n                  });\n                },\n                _closeSteps: (chunk) => {\n                  reading = false;\n                  const byobCanceled = forBranch2 ? canceled2 : canceled1;\n                  const otherCanceled = forBranch2 ? canceled1 : canceled2;\n                  if (!byobCanceled) {\n                    ReadableByteStreamControllerClose(byobBranch._readableStreamController);\n                  }\n                  if (!otherCanceled) {\n                    ReadableByteStreamControllerClose(otherBranch._readableStreamController);\n                  }\n                  if (chunk !== void 0) {\n                    if (!byobCanceled) {\n                      ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n                    }\n                    if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {\n                      ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);\n                    }\n                  }\n                  if (!byobCanceled || !otherCanceled) {\n                    resolveCancelPromise(void 0);\n                  }\n                },\n                _errorSteps: () => {\n                  reading = false;\n                }\n              };\n              ReadableStreamBYOBReaderRead(reader, view, readIntoRequest);\n            }\n            function pull1Algorithm() {\n              if (reading) {\n                readAgainForBranch1 = true;\n                return promiseResolvedWith(void 0);\n              }\n              reading = true;\n              const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);\n              if (byobRequest === null) {\n                pullWithDefaultReader();\n              } else {\n                pullWithBYOBReader(byobRequest._view, false);\n              }\n              return promiseResolvedWith(void 0);\n            }\n            function pull2Algorithm() {\n              if (reading) {\n                readAgainForBranch2 = true;\n                return promiseResolvedWith(void 0);\n              }\n              reading = true;\n              const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);\n              if (byobRequest === null) {\n                pullWithDefaultReader();\n              } else {\n                pullWithBYOBReader(byobRequest._view, true);\n              }\n              return promiseResolvedWith(void 0);\n            }\n            function cancel1Algorithm(reason) {\n              canceled1 = true;\n              reason1 = reason;\n              if (canceled2) {\n                const compositeReason = CreateArrayFromList([reason1, reason2]);\n                const cancelResult = ReadableStreamCancel(stream, compositeReason);\n                resolveCancelPromise(cancelResult);\n              }\n              return cancelPromise;\n            }\n            function cancel2Algorithm(reason) {\n              canceled2 = true;\n              reason2 = reason;\n              if (canceled1) {\n                const compositeReason = CreateArrayFromList([reason1, reason2]);\n                const cancelResult = ReadableStreamCancel(stream, compositeReason);\n                resolveCancelPromise(cancelResult);\n              }\n              return cancelPromise;\n            }\n            function startAlgorithm() {\n              return;\n            }\n            branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);\n            branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);\n            forwardReaderError(reader);\n            return [branch1, branch2];\n          }\n          function convertUnderlyingDefaultOrByteSource(source, context) {\n            assertDictionary(source, context);\n            const original = source;\n            const autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;\n            const cancel = original === null || original === void 0 ? void 0 : original.cancel;\n            const pull = original === null || original === void 0 ? void 0 : original.pull;\n            const start = original === null || original === void 0 ? void 0 : original.start;\n            const type = original === null || original === void 0 ? void 0 : original.type;\n            return {\n              autoAllocateChunkSize: autoAllocateChunkSize === void 0 ? void 0 : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context} has member 'autoAllocateChunkSize' that`),\n              cancel: cancel === void 0 ? void 0 : convertUnderlyingSourceCancelCallback(cancel, original, `${context} has member 'cancel' that`),\n              pull: pull === void 0 ? void 0 : convertUnderlyingSourcePullCallback(pull, original, `${context} has member 'pull' that`),\n              start: start === void 0 ? void 0 : convertUnderlyingSourceStartCallback(start, original, `${context} has member 'start' that`),\n              type: type === void 0 ? void 0 : convertReadableStreamType(type, `${context} has member 'type' that`)\n            };\n          }\n          function convertUnderlyingSourceCancelCallback(fn, original, context) {\n            assertFunction(fn, context);\n            return (reason) => promiseCall(fn, original, [reason]);\n          }\n          function convertUnderlyingSourcePullCallback(fn, original, context) {\n            assertFunction(fn, context);\n            return (controller) => promiseCall(fn, original, [controller]);\n          }\n          function convertUnderlyingSourceStartCallback(fn, original, context) {\n            assertFunction(fn, context);\n            return (controller) => reflectCall(fn, original, [controller]);\n          }\n          function convertReadableStreamType(type, context) {\n            type = `${type}`;\n            if (type !== \"bytes\") {\n              throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);\n            }\n            return type;\n          }\n          function convertReaderOptions(options, context) {\n            assertDictionary(options, context);\n            const mode = options === null || options === void 0 ? void 0 : options.mode;\n            return {\n              mode: mode === void 0 ? void 0 : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)\n            };\n          }\n          function convertReadableStreamReaderMode(mode, context) {\n            mode = `${mode}`;\n            if (mode !== \"byob\") {\n              throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);\n            }\n            return mode;\n          }\n          function convertIteratorOptions(options, context) {\n            assertDictionary(options, context);\n            const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;\n            return { preventCancel: Boolean(preventCancel) };\n          }\n          function convertPipeOptions(options, context) {\n            assertDictionary(options, context);\n            const preventAbort = options === null || options === void 0 ? void 0 : options.preventAbort;\n            const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;\n            const preventClose = options === null || options === void 0 ? void 0 : options.preventClose;\n            const signal = options === null || options === void 0 ? void 0 : options.signal;\n            if (signal !== void 0) {\n              assertAbortSignal(signal, `${context} has member 'signal' that`);\n            }\n            return {\n              preventAbort: Boolean(preventAbort),\n              preventCancel: Boolean(preventCancel),\n              preventClose: Boolean(preventClose),\n              signal\n            };\n          }\n          function assertAbortSignal(signal, context) {\n            if (!isAbortSignal2(signal)) {\n              throw new TypeError(`${context} is not an AbortSignal.`);\n            }\n          }\n          function convertReadableWritablePair(pair, context) {\n            assertDictionary(pair, context);\n            const readable = pair === null || pair === void 0 ? void 0 : pair.readable;\n            assertRequiredField(readable, \"readable\", \"ReadableWritablePair\");\n            assertReadableStream(readable, `${context} has member 'readable' that`);\n            const writable = pair === null || pair === void 0 ? void 0 : pair.writable;\n            assertRequiredField(writable, \"writable\", \"ReadableWritablePair\");\n            assertWritableStream(writable, `${context} has member 'writable' that`);\n            return { readable, writable };\n          }\n          class ReadableStream2 {\n            constructor(rawUnderlyingSource = {}, rawStrategy = {}) {\n              if (rawUnderlyingSource === void 0) {\n                rawUnderlyingSource = null;\n              } else {\n                assertObject(rawUnderlyingSource, \"First parameter\");\n              }\n              const strategy = convertQueuingStrategy(rawStrategy, \"Second parameter\");\n              const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, \"First parameter\");\n              InitializeReadableStream(this);\n              if (underlyingSource.type === \"bytes\") {\n                if (strategy.size !== void 0) {\n                  throw new RangeError(\"The strategy for a byte stream cannot have a size function\");\n                }\n                const highWaterMark = ExtractHighWaterMark(strategy, 0);\n                SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);\n              } else {\n                const sizeAlgorithm = ExtractSizeAlgorithm(strategy);\n                const highWaterMark = ExtractHighWaterMark(strategy, 1);\n                SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);\n              }\n            }\n            get locked() {\n              if (!IsReadableStream(this)) {\n                throw streamBrandCheckException$1(\"locked\");\n              }\n              return IsReadableStreamLocked(this);\n            }\n            cancel(reason = void 0) {\n              if (!IsReadableStream(this)) {\n                return promiseRejectedWith(streamBrandCheckException$1(\"cancel\"));\n              }\n              if (IsReadableStreamLocked(this)) {\n                return promiseRejectedWith(new TypeError(\"Cannot cancel a stream that already has a reader\"));\n              }\n              return ReadableStreamCancel(this, reason);\n            }\n            getReader(rawOptions = void 0) {\n              if (!IsReadableStream(this)) {\n                throw streamBrandCheckException$1(\"getReader\");\n              }\n              const options = convertReaderOptions(rawOptions, \"First parameter\");\n              if (options.mode === void 0) {\n                return AcquireReadableStreamDefaultReader(this);\n              }\n              return AcquireReadableStreamBYOBReader(this);\n            }\n            pipeThrough(rawTransform, rawOptions = {}) {\n              if (!IsReadableStream(this)) {\n                throw streamBrandCheckException$1(\"pipeThrough\");\n              }\n              assertRequiredArgument(rawTransform, 1, \"pipeThrough\");\n              const transform = convertReadableWritablePair(rawTransform, \"First parameter\");\n              const options = convertPipeOptions(rawOptions, \"Second parameter\");\n              if (IsReadableStreamLocked(this)) {\n                throw new TypeError(\"ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream\");\n              }\n              if (IsWritableStreamLocked(transform.writable)) {\n                throw new TypeError(\"ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream\");\n              }\n              const promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);\n              setPromiseIsHandledToTrue(promise);\n              return transform.readable;\n            }\n            pipeTo(destination, rawOptions = {}) {\n              if (!IsReadableStream(this)) {\n                return promiseRejectedWith(streamBrandCheckException$1(\"pipeTo\"));\n              }\n              if (destination === void 0) {\n                return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);\n              }\n              if (!IsWritableStream(destination)) {\n                return promiseRejectedWith(new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`));\n              }\n              let options;\n              try {\n                options = convertPipeOptions(rawOptions, \"Second parameter\");\n              } catch (e2) {\n                return promiseRejectedWith(e2);\n              }\n              if (IsReadableStreamLocked(this)) {\n                return promiseRejectedWith(new TypeError(\"ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream\"));\n              }\n              if (IsWritableStreamLocked(destination)) {\n                return promiseRejectedWith(new TypeError(\"ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream\"));\n              }\n              return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);\n            }\n            tee() {\n              if (!IsReadableStream(this)) {\n                throw streamBrandCheckException$1(\"tee\");\n              }\n              const branches = ReadableStreamTee(this);\n              return CreateArrayFromList(branches);\n            }\n            values(rawOptions = void 0) {\n              if (!IsReadableStream(this)) {\n                throw streamBrandCheckException$1(\"values\");\n              }\n              const options = convertIteratorOptions(rawOptions, \"First parameter\");\n              return AcquireReadableStreamAsyncIterator(this, options.preventCancel);\n            }\n          }\n          Object.defineProperties(ReadableStream2.prototype, {\n            cancel: { enumerable: true },\n            getReader: { enumerable: true },\n            pipeThrough: { enumerable: true },\n            pipeTo: { enumerable: true },\n            tee: { enumerable: true },\n            values: { enumerable: true },\n            locked: { enumerable: true }\n          });\n          if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n            Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.toStringTag, {\n              value: \"ReadableStream\",\n              configurable: true\n            });\n          }\n          if (typeof SymbolPolyfill.asyncIterator === \"symbol\") {\n            Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.asyncIterator, {\n              value: ReadableStream2.prototype.values,\n              writable: true,\n              configurable: true\n            });\n          }\n          function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {\n            const stream = Object.create(ReadableStream2.prototype);\n            InitializeReadableStream(stream);\n            const controller = Object.create(ReadableStreamDefaultController.prototype);\n            SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);\n            return stream;\n          }\n          function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {\n            const stream = Object.create(ReadableStream2.prototype);\n            InitializeReadableStream(stream);\n            const controller = Object.create(ReadableByteStreamController.prototype);\n            SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, void 0);\n            return stream;\n          }\n          function InitializeReadableStream(stream) {\n            stream._state = \"readable\";\n            stream._reader = void 0;\n            stream._storedError = void 0;\n            stream._disturbed = false;\n          }\n          function IsReadableStream(x2) {\n            if (!typeIsObject(x2)) {\n              return false;\n            }\n            if (!Object.prototype.hasOwnProperty.call(x2, \"_readableStreamController\")) {\n              return false;\n            }\n            return x2 instanceof ReadableStream2;\n          }\n          function IsReadableStreamLocked(stream) {\n            if (stream._reader === void 0) {\n              return false;\n            }\n            return true;\n          }\n          function ReadableStreamCancel(stream, reason) {\n            stream._disturbed = true;\n            if (stream._state === \"closed\") {\n              return promiseResolvedWith(void 0);\n            }\n            if (stream._state === \"errored\") {\n              return promiseRejectedWith(stream._storedError);\n            }\n            ReadableStreamClose(stream);\n            const reader = stream._reader;\n            if (reader !== void 0 && IsReadableStreamBYOBReader(reader)) {\n              reader._readIntoRequests.forEach((readIntoRequest) => {\n                readIntoRequest._closeSteps(void 0);\n              });\n              reader._readIntoRequests = new SimpleQueue();\n            }\n            const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);\n            return transformPromiseWith(sourceCancelPromise, noop2);\n          }\n          function ReadableStreamClose(stream) {\n            stream._state = \"closed\";\n            const reader = stream._reader;\n            if (reader === void 0) {\n              return;\n            }\n            defaultReaderClosedPromiseResolve(reader);\n            if (IsReadableStreamDefaultReader(reader)) {\n              reader._readRequests.forEach((readRequest) => {\n                readRequest._closeSteps();\n              });\n              reader._readRequests = new SimpleQueue();\n            }\n          }\n          function ReadableStreamError(stream, e2) {\n            stream._state = \"errored\";\n            stream._storedError = e2;\n            const reader = stream._reader;\n            if (reader === void 0) {\n              return;\n            }\n            defaultReaderClosedPromiseReject(reader, e2);\n            if (IsReadableStreamDefaultReader(reader)) {\n              reader._readRequests.forEach((readRequest) => {\n                readRequest._errorSteps(e2);\n              });\n              reader._readRequests = new SimpleQueue();\n            } else {\n              reader._readIntoRequests.forEach((readIntoRequest) => {\n                readIntoRequest._errorSteps(e2);\n              });\n              reader._readIntoRequests = new SimpleQueue();\n            }\n          }\n          function streamBrandCheckException$1(name) {\n            return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);\n          }\n          function convertQueuingStrategyInit(init, context) {\n            assertDictionary(init, context);\n            const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;\n            assertRequiredField(highWaterMark, \"highWaterMark\", \"QueuingStrategyInit\");\n            return {\n              highWaterMark: convertUnrestrictedDouble(highWaterMark)\n            };\n          }\n          const byteLengthSizeFunction = (chunk) => {\n            return chunk.byteLength;\n          };\n          try {\n            Object.defineProperty(byteLengthSizeFunction, \"name\", {\n              value: \"size\",\n              configurable: true\n            });\n          } catch (_a) {\n          }\n          class ByteLengthQueuingStrategy {\n            constructor(options) {\n              assertRequiredArgument(options, 1, \"ByteLengthQueuingStrategy\");\n              options = convertQueuingStrategyInit(options, \"First parameter\");\n              this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;\n            }\n            get highWaterMark() {\n              if (!IsByteLengthQueuingStrategy(this)) {\n                throw byteLengthBrandCheckException(\"highWaterMark\");\n              }\n              return this._byteLengthQueuingStrategyHighWaterMark;\n            }\n            get size() {\n              if (!IsByteLengthQueuingStrategy(this)) {\n                throw byteLengthBrandCheckException(\"size\");\n              }\n              return byteLengthSizeFunction;\n            }\n          }\n          Object.defineProperties(ByteLengthQueuingStrategy.prototype, {\n            highWaterMark: { enumerable: true },\n            size: { enumerable: true }\n          });\n          if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n            Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {\n              value: \"ByteLengthQueuingStrategy\",\n              configurable: true\n            });\n          }\n          function byteLengthBrandCheckException(name) {\n            return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);\n          }\n          function IsByteLengthQueuingStrategy(x2) {\n            if (!typeIsObject(x2)) {\n              return false;\n            }\n            if (!Object.prototype.hasOwnProperty.call(x2, \"_byteLengthQueuingStrategyHighWaterMark\")) {\n              return false;\n            }\n            return x2 instanceof ByteLengthQueuingStrategy;\n          }\n          const countSizeFunction = () => {\n            return 1;\n          };\n          try {\n            Object.defineProperty(countSizeFunction, \"name\", {\n              value: \"size\",\n              configurable: true\n            });\n          } catch (_a) {\n          }\n          class CountQueuingStrategy {\n            constructor(options) {\n              assertRequiredArgument(options, 1, \"CountQueuingStrategy\");\n              options = convertQueuingStrategyInit(options, \"First parameter\");\n              this._countQueuingStrategyHighWaterMark = options.highWaterMark;\n            }\n            get highWaterMark() {\n              if (!IsCountQueuingStrategy(this)) {\n                throw countBrandCheckException(\"highWaterMark\");\n              }\n              return this._countQueuingStrategyHighWaterMark;\n            }\n            get size() {\n              if (!IsCountQueuingStrategy(this)) {\n                throw countBrandCheckException(\"size\");\n              }\n              return countSizeFunction;\n            }\n          }\n          Object.defineProperties(CountQueuingStrategy.prototype, {\n            highWaterMark: { enumerable: true },\n            size: { enumerable: true }\n          });\n          if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n            Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {\n              value: \"CountQueuingStrategy\",\n              configurable: true\n            });\n          }\n          function countBrandCheckException(name) {\n            return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);\n          }\n          function IsCountQueuingStrategy(x2) {\n            if (!typeIsObject(x2)) {\n              return false;\n            }\n            if (!Object.prototype.hasOwnProperty.call(x2, \"_countQueuingStrategyHighWaterMark\")) {\n              return false;\n            }\n            return x2 instanceof CountQueuingStrategy;\n          }\n          function convertTransformer(original, context) {\n            assertDictionary(original, context);\n            const flush = original === null || original === void 0 ? void 0 : original.flush;\n            const readableType = original === null || original === void 0 ? void 0 : original.readableType;\n            const start = original === null || original === void 0 ? void 0 : original.start;\n            const transform = original === null || original === void 0 ? void 0 : original.transform;\n            const writableType = original === null || original === void 0 ? void 0 : original.writableType;\n            return {\n              flush: flush === void 0 ? void 0 : convertTransformerFlushCallback(flush, original, `${context} has member 'flush' that`),\n              readableType,\n              start: start === void 0 ? void 0 : convertTransformerStartCallback(start, original, `${context} has member 'start' that`),\n              transform: transform === void 0 ? void 0 : convertTransformerTransformCallback(transform, original, `${context} has member 'transform' that`),\n              writableType\n            };\n          }\n          function convertTransformerFlushCallback(fn, original, context) {\n            assertFunction(fn, context);\n            return (controller) => promiseCall(fn, original, [controller]);\n          }\n          function convertTransformerStartCallback(fn, original, context) {\n            assertFunction(fn, context);\n            return (controller) => reflectCall(fn, original, [controller]);\n          }\n          function convertTransformerTransformCallback(fn, original, context) {\n            assertFunction(fn, context);\n            return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);\n          }\n          class TransformStream {\n            constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}) {\n              if (rawTransformer === void 0) {\n                rawTransformer = null;\n              }\n              const writableStrategy = convertQueuingStrategy(rawWritableStrategy, \"Second parameter\");\n              const readableStrategy = convertQueuingStrategy(rawReadableStrategy, \"Third parameter\");\n              const transformer = convertTransformer(rawTransformer, \"First parameter\");\n              if (transformer.readableType !== void 0) {\n                throw new RangeError(\"Invalid readableType specified\");\n              }\n              if (transformer.writableType !== void 0) {\n                throw new RangeError(\"Invalid writableType specified\");\n              }\n              const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);\n              const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);\n              const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);\n              const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);\n              let startPromise_resolve;\n              const startPromise = newPromise((resolve) => {\n                startPromise_resolve = resolve;\n              });\n              InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n              SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);\n              if (transformer.start !== void 0) {\n                startPromise_resolve(transformer.start(this._transformStreamController));\n              } else {\n                startPromise_resolve(void 0);\n              }\n            }\n            get readable() {\n              if (!IsTransformStream(this)) {\n                throw streamBrandCheckException(\"readable\");\n              }\n              return this._readable;\n            }\n            get writable() {\n              if (!IsTransformStream(this)) {\n                throw streamBrandCheckException(\"writable\");\n              }\n              return this._writable;\n            }\n          }\n          Object.defineProperties(TransformStream.prototype, {\n            readable: { enumerable: true },\n            writable: { enumerable: true }\n          });\n          if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n            Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {\n              value: \"TransformStream\",\n              configurable: true\n            });\n          }\n          function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {\n            function startAlgorithm() {\n              return startPromise;\n            }\n            function writeAlgorithm(chunk) {\n              return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);\n            }\n            function abortAlgorithm(reason) {\n              return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);\n            }\n            function closeAlgorithm() {\n              return TransformStreamDefaultSinkCloseAlgorithm(stream);\n            }\n            stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);\n            function pullAlgorithm() {\n              return TransformStreamDefaultSourcePullAlgorithm(stream);\n            }\n            function cancelAlgorithm(reason) {\n              TransformStreamErrorWritableAndUnblockWrite(stream, reason);\n              return promiseResolvedWith(void 0);\n            }\n            stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n            stream._backpressure = void 0;\n            stream._backpressureChangePromise = void 0;\n            stream._backpressureChangePromise_resolve = void 0;\n            TransformStreamSetBackpressure(stream, true);\n            stream._transformStreamController = void 0;\n          }\n          function IsTransformStream(x2) {\n            if (!typeIsObject(x2)) {\n              return false;\n            }\n            if (!Object.prototype.hasOwnProperty.call(x2, \"_transformStreamController\")) {\n              return false;\n            }\n            return x2 instanceof TransformStream;\n          }\n          function TransformStreamError(stream, e2) {\n            ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e2);\n            TransformStreamErrorWritableAndUnblockWrite(stream, e2);\n          }\n          function TransformStreamErrorWritableAndUnblockWrite(stream, e2) {\n            TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);\n            WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e2);\n            if (stream._backpressure) {\n              TransformStreamSetBackpressure(stream, false);\n            }\n          }\n          function TransformStreamSetBackpressure(stream, backpressure) {\n            if (stream._backpressureChangePromise !== void 0) {\n              stream._backpressureChangePromise_resolve();\n            }\n            stream._backpressureChangePromise = newPromise((resolve) => {\n              stream._backpressureChangePromise_resolve = resolve;\n            });\n            stream._backpressure = backpressure;\n          }\n          class TransformStreamDefaultController {\n            constructor() {\n              throw new TypeError(\"Illegal constructor\");\n            }\n            get desiredSize() {\n              if (!IsTransformStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException(\"desiredSize\");\n              }\n              const readableController = this._controlledTransformStream._readable._readableStreamController;\n              return ReadableStreamDefaultControllerGetDesiredSize(readableController);\n            }\n            enqueue(chunk = void 0) {\n              if (!IsTransformStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException(\"enqueue\");\n              }\n              TransformStreamDefaultControllerEnqueue(this, chunk);\n            }\n            error(reason = void 0) {\n              if (!IsTransformStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException(\"error\");\n              }\n              TransformStreamDefaultControllerError(this, reason);\n            }\n            terminate() {\n              if (!IsTransformStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException(\"terminate\");\n              }\n              TransformStreamDefaultControllerTerminate(this);\n            }\n          }\n          Object.defineProperties(TransformStreamDefaultController.prototype, {\n            enqueue: { enumerable: true },\n            error: { enumerable: true },\n            terminate: { enumerable: true },\n            desiredSize: { enumerable: true }\n          });\n          if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n            Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n              value: \"TransformStreamDefaultController\",\n              configurable: true\n            });\n          }\n          function IsTransformStreamDefaultController(x2) {\n            if (!typeIsObject(x2)) {\n              return false;\n            }\n            if (!Object.prototype.hasOwnProperty.call(x2, \"_controlledTransformStream\")) {\n              return false;\n            }\n            return x2 instanceof TransformStreamDefaultController;\n          }\n          function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {\n            controller._controlledTransformStream = stream;\n            stream._transformStreamController = controller;\n            controller._transformAlgorithm = transformAlgorithm;\n            controller._flushAlgorithm = flushAlgorithm;\n          }\n          function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {\n            const controller = Object.create(TransformStreamDefaultController.prototype);\n            let transformAlgorithm = (chunk) => {\n              try {\n                TransformStreamDefaultControllerEnqueue(controller, chunk);\n                return promiseResolvedWith(void 0);\n              } catch (transformResultE) {\n                return promiseRejectedWith(transformResultE);\n              }\n            };\n            let flushAlgorithm = () => promiseResolvedWith(void 0);\n            if (transformer.transform !== void 0) {\n              transformAlgorithm = (chunk) => transformer.transform(chunk, controller);\n            }\n            if (transformer.flush !== void 0) {\n              flushAlgorithm = () => transformer.flush(controller);\n            }\n            SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);\n          }\n          function TransformStreamDefaultControllerClearAlgorithms(controller) {\n            controller._transformAlgorithm = void 0;\n            controller._flushAlgorithm = void 0;\n          }\n          function TransformStreamDefaultControllerEnqueue(controller, chunk) {\n            const stream = controller._controlledTransformStream;\n            const readableController = stream._readable._readableStreamController;\n            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {\n              throw new TypeError(\"Readable side is not in a state that permits enqueue\");\n            }\n            try {\n              ReadableStreamDefaultControllerEnqueue(readableController, chunk);\n            } catch (e2) {\n              TransformStreamErrorWritableAndUnblockWrite(stream, e2);\n              throw stream._readable._storedError;\n            }\n            const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);\n            if (backpressure !== stream._backpressure) {\n              TransformStreamSetBackpressure(stream, true);\n            }\n          }\n          function TransformStreamDefaultControllerError(controller, e2) {\n            TransformStreamError(controller._controlledTransformStream, e2);\n          }\n          function TransformStreamDefaultControllerPerformTransform(controller, chunk) {\n            const transformPromise = controller._transformAlgorithm(chunk);\n            return transformPromiseWith(transformPromise, void 0, (r22) => {\n              TransformStreamError(controller._controlledTransformStream, r22);\n              throw r22;\n            });\n          }\n          function TransformStreamDefaultControllerTerminate(controller) {\n            const stream = controller._controlledTransformStream;\n            const readableController = stream._readable._readableStreamController;\n            ReadableStreamDefaultControllerClose(readableController);\n            const error = new TypeError(\"TransformStream terminated\");\n            TransformStreamErrorWritableAndUnblockWrite(stream, error);\n          }\n          function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {\n            const controller = stream._transformStreamController;\n            if (stream._backpressure) {\n              const backpressureChangePromise = stream._backpressureChangePromise;\n              return transformPromiseWith(backpressureChangePromise, () => {\n                const writable = stream._writable;\n                const state = writable._state;\n                if (state === \"erroring\") {\n                  throw writable._storedError;\n                }\n                return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n              });\n            }\n            return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n          }\n          function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {\n            TransformStreamError(stream, reason);\n            return promiseResolvedWith(void 0);\n          }\n          function TransformStreamDefaultSinkCloseAlgorithm(stream) {\n            const readable = stream._readable;\n            const controller = stream._transformStreamController;\n            const flushPromise = controller._flushAlgorithm();\n            TransformStreamDefaultControllerClearAlgorithms(controller);\n            return transformPromiseWith(flushPromise, () => {\n              if (readable._state === \"errored\") {\n                throw readable._storedError;\n              }\n              ReadableStreamDefaultControllerClose(readable._readableStreamController);\n            }, (r22) => {\n              TransformStreamError(stream, r22);\n              throw readable._storedError;\n            });\n          }\n          function TransformStreamDefaultSourcePullAlgorithm(stream) {\n            TransformStreamSetBackpressure(stream, false);\n            return stream._backpressureChangePromise;\n          }\n          function defaultControllerBrandCheckException(name) {\n            return new TypeError(`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);\n          }\n          function streamBrandCheckException(name) {\n            return new TypeError(`TransformStream.prototype.${name} can only be used on a TransformStream`);\n          }\n          exports22.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;\n          exports22.CountQueuingStrategy = CountQueuingStrategy;\n          exports22.ReadableByteStreamController = ReadableByteStreamController;\n          exports22.ReadableStream = ReadableStream2;\n          exports22.ReadableStreamBYOBReader = ReadableStreamBYOBReader;\n          exports22.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;\n          exports22.ReadableStreamDefaultController = ReadableStreamDefaultController;\n          exports22.ReadableStreamDefaultReader = ReadableStreamDefaultReader;\n          exports22.TransformStream = TransformStream;\n          exports22.TransformStreamDefaultController = TransformStreamDefaultController;\n          exports22.WritableStream = WritableStream;\n          exports22.WritableStreamDefaultController = WritableStreamDefaultController;\n          exports22.WritableStreamDefaultWriter = WritableStreamDefaultWriter;\n          Object.defineProperty(exports22, \"__esModule\", { value: true });\n        });\n      }\n    });\n    var require_streams = __commonJS2({\n      \"node_modules/fetch-blob/streams.cjs\"() {\n        var POOL_SIZE2 = 65536;\n        if (!globalThis.ReadableStream) {\n          try {\n            const process2 = __webpack_require__(/*! process */ \"process\");\n            const { emitWarning } = process2;\n            try {\n              process2.emitWarning = () => {\n              };\n              Object.assign(globalThis, __webpack_require__(/*! stream/web */ \"stream/web\"));\n              process2.emitWarning = emitWarning;\n            } catch (error) {\n              process2.emitWarning = emitWarning;\n              throw error;\n            }\n          } catch (error) {\n            Object.assign(globalThis, require_ponyfill_es2018());\n          }\n        }\n        try {\n          const { Blob: Blob3 } = __webpack_require__(/*! buffer */ \"buffer\");\n          if (Blob3 && !Blob3.prototype.stream) {\n            Blob3.prototype.stream = function name(params) {\n              let position = 0;\n              const blob = this;\n              return new ReadableStream({\n                type: \"bytes\",\n                async pull(ctrl) {\n                  const chunk = blob.slice(position, Math.min(blob.size, position + POOL_SIZE2));\n                  const buffer = await chunk.arrayBuffer();\n                  position += buffer.byteLength;\n                  ctrl.enqueue(new Uint8Array(buffer));\n                  if (position === blob.size) {\n                    ctrl.close();\n                  }\n                }\n              });\n            };\n          }\n        } catch (error) {\n        }\n      }\n    });\n    async function* toIterator(parts, clone2 = true) {\n      for (const part of parts) {\n        if (\"stream\" in part) {\n          yield* part.stream();\n        } else if (ArrayBuffer.isView(part)) {\n          if (clone2) {\n            let position = part.byteOffset;\n            const end = part.byteOffset + part.byteLength;\n            while (position !== end) {\n              const size = Math.min(end - position, POOL_SIZE);\n              const chunk = part.buffer.slice(position, position + size);\n              position += chunk.byteLength;\n              yield new Uint8Array(chunk);\n            }\n          } else {\n            yield part;\n          }\n        } else {\n          let position = 0, b = part;\n          while (position !== b.size) {\n            const chunk = b.slice(position, Math.min(b.size, position + POOL_SIZE));\n            const buffer = await chunk.arrayBuffer();\n            position += buffer.byteLength;\n            yield new Uint8Array(buffer);\n          }\n        }\n      }\n    }\n    var import_streams;\n    var POOL_SIZE;\n    var _Blob;\n    var Blob2;\n    var fetch_blob_default;\n    var init_fetch_blob = __esm({\n      \"node_modules/fetch-blob/index.js\"() {\n        import_streams = __toModule(require_streams());\n        POOL_SIZE = 65536;\n        _Blob = class Blob3 {\n          #parts = [];\n          #type = \"\";\n          #size = 0;\n          #endings = \"transparent\";\n          constructor(blobParts = [], options = {}) {\n            if (typeof blobParts !== \"object\" || blobParts === null) {\n              throw new TypeError(\"Failed to construct 'Blob': The provided value cannot be converted to a sequence.\");\n            }\n            if (typeof blobParts[Symbol.iterator] !== \"function\") {\n              throw new TypeError(\"Failed to construct 'Blob': The object must have a callable @@iterator property.\");\n            }\n            if (typeof options !== \"object\" && typeof options !== \"function\") {\n              throw new TypeError(\"Failed to construct 'Blob': parameter 2 cannot convert to dictionary.\");\n            }\n            if (options === null)\n              options = {};\n            const encoder = new TextEncoder();\n            for (const element of blobParts) {\n              let part;\n              if (ArrayBuffer.isView(element)) {\n                part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength));\n              } else if (element instanceof ArrayBuffer) {\n                part = new Uint8Array(element.slice(0));\n              } else if (element instanceof Blob3) {\n                part = element;\n              } else {\n                part = encoder.encode(`${element}`);\n              }\n              this.#size += ArrayBuffer.isView(part) ? part.byteLength : part.size;\n              this.#parts.push(part);\n            }\n            this.#endings = `${options.endings === void 0 ? \"transparent\" : options.endings}`;\n            const type = options.type === void 0 ? \"\" : String(options.type);\n            this.#type = /^[\\x20-\\x7E]*$/.test(type) ? type : \"\";\n          }\n          get size() {\n            return this.#size;\n          }\n          get type() {\n            return this.#type;\n          }\n          async text() {\n            const decoder = new TextDecoder();\n            let str = \"\";\n            for await (const part of toIterator(this.#parts, false)) {\n              str += decoder.decode(part, { stream: true });\n            }\n            str += decoder.decode();\n            return str;\n          }\n          async arrayBuffer() {\n            const data = new Uint8Array(this.size);\n            let offset = 0;\n            for await (const chunk of toIterator(this.#parts, false)) {\n              data.set(chunk, offset);\n              offset += chunk.length;\n            }\n            return data.buffer;\n          }\n          stream() {\n            const it = toIterator(this.#parts, true);\n            return new globalThis.ReadableStream({\n              type: \"bytes\",\n              async pull(ctrl) {\n                const chunk = await it.next();\n                chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value);\n              },\n              async cancel() {\n                await it.return();\n              }\n            });\n          }\n          slice(start = 0, end = this.size, type = \"\") {\n            const { size } = this;\n            let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);\n            let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);\n            const span = Math.max(relativeEnd - relativeStart, 0);\n            const parts = this.#parts;\n            const blobParts = [];\n            let added = 0;\n            for (const part of parts) {\n              if (added >= span) {\n                break;\n              }\n              const size2 = ArrayBuffer.isView(part) ? part.byteLength : part.size;\n              if (relativeStart && size2 <= relativeStart) {\n                relativeStart -= size2;\n                relativeEnd -= size2;\n              } else {\n                let chunk;\n                if (ArrayBuffer.isView(part)) {\n                  chunk = part.subarray(relativeStart, Math.min(size2, relativeEnd));\n                  added += chunk.byteLength;\n                } else {\n                  chunk = part.slice(relativeStart, Math.min(size2, relativeEnd));\n                  added += chunk.size;\n                }\n                relativeEnd -= size2;\n                blobParts.push(chunk);\n                relativeStart = 0;\n              }\n            }\n            const blob = new Blob3([], { type: String(type).toLowerCase() });\n            blob.#size = span;\n            blob.#parts = blobParts;\n            return blob;\n          }\n          get [Symbol.toStringTag]() {\n            return \"Blob\";\n          }\n          static [Symbol.hasInstance](object) {\n            return object && typeof object === \"object\" && typeof object.constructor === \"function\" && (typeof object.stream === \"function\" || typeof object.arrayBuffer === \"function\") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);\n          }\n        };\n        Object.defineProperties(_Blob.prototype, {\n          size: { enumerable: true },\n          type: { enumerable: true },\n          slice: { enumerable: true }\n        });\n        Blob2 = _Blob;\n        fetch_blob_default = Blob2;\n      }\n    });\n    var _File;\n    var File2;\n    var file_default;\n    var init_file = __esm({\n      \"node_modules/fetch-blob/file.js\"() {\n        init_fetch_blob();\n        _File = class File extends fetch_blob_default {\n          #lastModified = 0;\n          #name = \"\";\n          constructor(fileBits, fileName, options = {}) {\n            if (arguments.length < 2) {\n              throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`);\n            }\n            super(fileBits, options);\n            if (options === null)\n              options = {};\n            const lastModified = options.lastModified === void 0 ? Date.now() : Number(options.lastModified);\n            if (!Number.isNaN(lastModified)) {\n              this.#lastModified = lastModified;\n            }\n            this.#name = String(fileName);\n          }\n          get name() {\n            return this.#name;\n          }\n          get lastModified() {\n            return this.#lastModified;\n          }\n          get [Symbol.toStringTag]() {\n            return \"File\";\n          }\n          static [Symbol.hasInstance](object) {\n            return !!object && object instanceof fetch_blob_default && /^(File)$/.test(object[Symbol.toStringTag]);\n          }\n        };\n        File2 = _File;\n        file_default = File2;\n      }\n    });\n    function formDataToBlob(F2, B = fetch_blob_default) {\n      var b = `${r2()}${r2()}`.replace(/\\./g, \"\").slice(-28).padStart(32, \"-\"), c = [], p = `--${b}\\r\nContent-Disposition: form-data; name=\"`;\n      F2.forEach((v, n) => typeof v == \"string\" ? c.push(p + e(n) + `\"\\r\n\\r\n${v.replace(/\\r(?!\\n)|(?<!\\r)\\n/g, \"\\r\\n\")}\\r\n`) : c.push(p + e(n) + `\"; filename=\"${e(v.name, 1)}\"\\r\nContent-Type: ${v.type || \"application/octet-stream\"}\\r\n\\r\n`, v, \"\\r\\n\"));\n      c.push(`--${b}--`);\n      return new B(c, { type: \"multipart/form-data; boundary=\" + b });\n    }\n    var t;\n    var i;\n    var h;\n    var r2;\n    var m;\n    var f;\n    var e;\n    var x;\n    var FormData;\n    var init_esm_min = __esm({\n      \"node_modules/formdata-polyfill/esm.min.js\"() {\n        init_fetch_blob();\n        init_file();\n        ({ toStringTag: t, iterator: i, hasInstance: h } = Symbol);\n        r2 = Math.random;\n        m = \"append,set,get,getAll,delete,keys,values,entries,forEach,constructor\".split(\",\");\n        f = (a, b, c) => (a += \"\", /^(Blob|File)$/.test(b && b[t]) ? [(c = c !== void 0 ? c + \"\" : b[t] == \"File\" ? b.name : \"blob\", a), b.name !== c || b[t] == \"blob\" ? new file_default([b], c, b) : b] : [a, b + \"\"]);\n        e = (c, f3) => (f3 ? c : c.replace(/\\r?\\n|\\r/g, \"\\r\\n\")).replace(/\\n/g, \"%0A\").replace(/\\r/g, \"%0D\").replace(/\"/g, \"%22\");\n        x = (n, a, e2) => {\n          if (a.length < e2) {\n            throw new TypeError(`Failed to execute '${n}' on 'FormData': ${e2} arguments required, but only ${a.length} present.`);\n          }\n        };\n        FormData = class FormData2 {\n          #d = [];\n          constructor(...a) {\n            if (a.length)\n              throw new TypeError(`Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.`);\n          }\n          get [t]() {\n            return \"FormData\";\n          }\n          [i]() {\n            return this.entries();\n          }\n          static [h](o) {\n            return o && typeof o === \"object\" && o[t] === \"FormData\" && !m.some((m2) => typeof o[m2] != \"function\");\n          }\n          append(...a) {\n            x(\"append\", arguments, 2);\n            this.#d.push(f(...a));\n          }\n          delete(a) {\n            x(\"delete\", arguments, 1);\n            a += \"\";\n            this.#d = this.#d.filter(([b]) => b !== a);\n          }\n          get(a) {\n            x(\"get\", arguments, 1);\n            a += \"\";\n            for (var b = this.#d, l = b.length, c = 0; c < l; c++)\n              if (b[c][0] === a)\n                return b[c][1];\n            return null;\n          }\n          getAll(a, b) {\n            x(\"getAll\", arguments, 1);\n            b = [];\n            a += \"\";\n            this.#d.forEach((c) => c[0] === a && b.push(c[1]));\n            return b;\n          }\n          has(a) {\n            x(\"has\", arguments, 1);\n            a += \"\";\n            return this.#d.some((b) => b[0] === a);\n          }\n          forEach(a, b) {\n            x(\"forEach\", arguments, 1);\n            for (var [c, d] of this)\n              a.call(b, d, c, this);\n          }\n          set(...a) {\n            x(\"set\", arguments, 2);\n            var b = [], c = true;\n            a = f(...a);\n            this.#d.forEach((d) => {\n              d[0] === a[0] ? c && (c = !b.push(a)) : b.push(d);\n            });\n            c && b.push(a);\n            this.#d = b;\n          }\n          *entries() {\n            yield* this.#d;\n          }\n          *keys() {\n            for (var [a] of this)\n              yield a;\n          }\n          *values() {\n            for (var [, a] of this)\n              yield a;\n          }\n        };\n      }\n    });\n    var require_node_domexception = __commonJS2({\n      \"node_modules/node-domexception/index.js\"(exports3, module22) {\n        if (!globalThis.DOMException) {\n          try {\n            const { MessageChannel } = __webpack_require__(/*! worker_threads */ \"worker_threads\"), port = new MessageChannel().port1, ab = new ArrayBuffer();\n            port.postMessage(ab, [ab, ab]);\n          } catch (err) {\n            err.constructor.name === \"DOMException\" && (globalThis.DOMException = err.constructor);\n          }\n        }\n        module22.exports = globalThis.DOMException;\n      }\n    });\n    var import_node_fs;\n    var import_node_path;\n    var import_node_domexception;\n    var stat;\n    var blobFromSync;\n    var blobFrom;\n    var fileFrom;\n    var fileFromSync;\n    var fromBlob;\n    var fromFile;\n    var BlobDataItem;\n    var init_from = __esm({\n      \"node_modules/fetch-blob/from.js\"() {\n        import_node_fs = __toModule(__webpack_require__(/*! fs */ \"fs\"));\n        import_node_path = __toModule(__webpack_require__(/*! path */ \"path\"));\n        import_node_domexception = __toModule(require_node_domexception());\n        init_file();\n        init_fetch_blob();\n        ({ stat } = import_node_fs.promises);\n        blobFromSync = (path, type) => fromBlob((0, import_node_fs.statSync)(path), path, type);\n        blobFrom = (path, type) => stat(path).then((stat2) => fromBlob(stat2, path, type));\n        fileFrom = (path, type) => stat(path).then((stat2) => fromFile(stat2, path, type));\n        fileFromSync = (path, type) => fromFile((0, import_node_fs.statSync)(path), path, type);\n        fromBlob = (stat2, path, type = \"\") => new fetch_blob_default([new BlobDataItem({\n          path,\n          size: stat2.size,\n          lastModified: stat2.mtimeMs,\n          start: 0\n        })], { type });\n        fromFile = (stat2, path, type = \"\") => new file_default([new BlobDataItem({\n          path,\n          size: stat2.size,\n          lastModified: stat2.mtimeMs,\n          start: 0\n        })], (0, import_node_path.basename)(path), { type, lastModified: stat2.mtimeMs });\n        BlobDataItem = class {\n          #path;\n          #start;\n          constructor(options) {\n            this.#path = options.path;\n            this.#start = options.start;\n            this.size = options.size;\n            this.lastModified = options.lastModified;\n          }\n          slice(start, end) {\n            return new BlobDataItem({\n              path: this.#path,\n              lastModified: this.lastModified,\n              size: end - start,\n              start: this.#start + start\n            });\n          }\n          async *stream() {\n            const { mtimeMs } = await stat(this.#path);\n            if (mtimeMs > this.lastModified) {\n              throw new import_node_domexception.default(\"The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.\", \"NotReadableError\");\n            }\n            yield* (0, import_node_fs.createReadStream)(this.#path, {\n              start: this.#start,\n              end: this.#start + this.size - 1\n            });\n          }\n          get [Symbol.toStringTag]() {\n            return \"Blob\";\n          }\n        };\n      }\n    });\n    var multipart_parser_exports = {};\n    __export(multipart_parser_exports, {\n      toFormData: () => toFormData\n    });\n    function _fileName(headerValue) {\n      const m2 = headerValue.match(/\\bfilename=(\"(.*?)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))($|;\\s)/i);\n      if (!m2) {\n        return;\n      }\n      const match = m2[2] || m2[3] || \"\";\n      let filename = match.slice(match.lastIndexOf(\"\\\\\") + 1);\n      filename = filename.replace(/%22/g, '\"');\n      filename = filename.replace(/&#(\\d{4});/g, (m3, code) => {\n        return String.fromCharCode(code);\n      });\n      return filename;\n    }\n    async function toFormData(Body2, ct) {\n      if (!/multipart/i.test(ct)) {\n        throw new TypeError(\"Failed to fetch\");\n      }\n      const m2 = ct.match(/boundary=(?:\"([^\"]+)\"|([^;]+))/i);\n      if (!m2) {\n        throw new TypeError(\"no or bad content-type header, no multipart boundary\");\n      }\n      const parser = new MultipartParser(m2[1] || m2[2]);\n      let headerField;\n      let headerValue;\n      let entryValue;\n      let entryName;\n      let contentType;\n      let filename;\n      const entryChunks = [];\n      const formData = new FormData();\n      const onPartData = (ui8a) => {\n        entryValue += decoder.decode(ui8a, { stream: true });\n      };\n      const appendToFile = (ui8a) => {\n        entryChunks.push(ui8a);\n      };\n      const appendFileToFormData = () => {\n        const file = new file_default(entryChunks, filename, { type: contentType });\n        formData.append(entryName, file);\n      };\n      const appendEntryToFormData = () => {\n        formData.append(entryName, entryValue);\n      };\n      const decoder = new TextDecoder(\"utf-8\");\n      decoder.decode();\n      parser.onPartBegin = function() {\n        parser.onPartData = onPartData;\n        parser.onPartEnd = appendEntryToFormData;\n        headerField = \"\";\n        headerValue = \"\";\n        entryValue = \"\";\n        entryName = \"\";\n        contentType = \"\";\n        filename = null;\n        entryChunks.length = 0;\n      };\n      parser.onHeaderField = function(ui8a) {\n        headerField += decoder.decode(ui8a, { stream: true });\n      };\n      parser.onHeaderValue = function(ui8a) {\n        headerValue += decoder.decode(ui8a, { stream: true });\n      };\n      parser.onHeaderEnd = function() {\n        headerValue += decoder.decode();\n        headerField = headerField.toLowerCase();\n        if (headerField === \"content-disposition\") {\n          const m3 = headerValue.match(/\\bname=(\"([^\"]*)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))/i);\n          if (m3) {\n            entryName = m3[2] || m3[3] || \"\";\n          }\n          filename = _fileName(headerValue);\n          if (filename) {\n            parser.onPartData = appendToFile;\n            parser.onPartEnd = appendFileToFormData;\n          }\n        } else if (headerField === \"content-type\") {\n          contentType = headerValue;\n        }\n        headerValue = \"\";\n        headerField = \"\";\n      };\n      for await (const chunk of Body2) {\n        parser.write(chunk);\n      }\n      parser.end();\n      return formData;\n    }\n    var s;\n    var S;\n    var f2;\n    var F;\n    var LF;\n    var CR;\n    var SPACE;\n    var HYPHEN;\n    var COLON;\n    var A;\n    var Z;\n    var lower;\n    var noop;\n    var MultipartParser;\n    var init_multipart_parser = __esm({\n      \"node_modules/node-fetch/src/utils/multipart-parser.js\"() {\n        init_from();\n        init_esm_min();\n        s = 0;\n        S = {\n          START_BOUNDARY: s++,\n          HEADER_FIELD_START: s++,\n          HEADER_FIELD: s++,\n          HEADER_VALUE_START: s++,\n          HEADER_VALUE: s++,\n          HEADER_VALUE_ALMOST_DONE: s++,\n          HEADERS_ALMOST_DONE: s++,\n          PART_DATA_START: s++,\n          PART_DATA: s++,\n          END: s++\n        };\n        f2 = 1;\n        F = {\n          PART_BOUNDARY: f2,\n          LAST_BOUNDARY: f2 *= 2\n        };\n        LF = 10;\n        CR = 13;\n        SPACE = 32;\n        HYPHEN = 45;\n        COLON = 58;\n        A = 97;\n        Z = 122;\n        lower = (c) => c | 32;\n        noop = () => {\n        };\n        MultipartParser = class {\n          constructor(boundary) {\n            this.index = 0;\n            this.flags = 0;\n            this.onHeaderEnd = noop;\n            this.onHeaderField = noop;\n            this.onHeadersEnd = noop;\n            this.onHeaderValue = noop;\n            this.onPartBegin = noop;\n            this.onPartData = noop;\n            this.onPartEnd = noop;\n            this.boundaryChars = {};\n            boundary = \"\\r\\n--\" + boundary;\n            const ui8a = new Uint8Array(boundary.length);\n            for (let i2 = 0; i2 < boundary.length; i2++) {\n              ui8a[i2] = boundary.charCodeAt(i2);\n              this.boundaryChars[ui8a[i2]] = true;\n            }\n            this.boundary = ui8a;\n            this.lookbehind = new Uint8Array(this.boundary.length + 8);\n            this.state = S.START_BOUNDARY;\n          }\n          write(data) {\n            let i2 = 0;\n            const length_ = data.length;\n            let previousIndex = this.index;\n            let { lookbehind, boundary, boundaryChars, index, state, flags } = this;\n            const boundaryLength = this.boundary.length;\n            const boundaryEnd = boundaryLength - 1;\n            const bufferLength = data.length;\n            let c;\n            let cl;\n            const mark = (name) => {\n              this[name + \"Mark\"] = i2;\n            };\n            const clear = (name) => {\n              delete this[name + \"Mark\"];\n            };\n            const callback = (callbackSymbol, start, end, ui8a) => {\n              if (start === void 0 || start !== end) {\n                this[callbackSymbol](ui8a && ui8a.subarray(start, end));\n              }\n            };\n            const dataCallback = (name, clear2) => {\n              const markSymbol = name + \"Mark\";\n              if (!(markSymbol in this)) {\n                return;\n              }\n              if (clear2) {\n                callback(name, this[markSymbol], i2, data);\n                delete this[markSymbol];\n              } else {\n                callback(name, this[markSymbol], data.length, data);\n                this[markSymbol] = 0;\n              }\n            };\n            for (i2 = 0; i2 < length_; i2++) {\n              c = data[i2];\n              switch (state) {\n                case S.START_BOUNDARY:\n                  if (index === boundary.length - 2) {\n                    if (c === HYPHEN) {\n                      flags |= F.LAST_BOUNDARY;\n                    } else if (c !== CR) {\n                      return;\n                    }\n                    index++;\n                    break;\n                  } else if (index - 1 === boundary.length - 2) {\n                    if (flags & F.LAST_BOUNDARY && c === HYPHEN) {\n                      state = S.END;\n                      flags = 0;\n                    } else if (!(flags & F.LAST_BOUNDARY) && c === LF) {\n                      index = 0;\n                      callback(\"onPartBegin\");\n                      state = S.HEADER_FIELD_START;\n                    } else {\n                      return;\n                    }\n                    break;\n                  }\n                  if (c !== boundary[index + 2]) {\n                    index = -2;\n                  }\n                  if (c === boundary[index + 2]) {\n                    index++;\n                  }\n                  break;\n                case S.HEADER_FIELD_START:\n                  state = S.HEADER_FIELD;\n                  mark(\"onHeaderField\");\n                  index = 0;\n                case S.HEADER_FIELD:\n                  if (c === CR) {\n                    clear(\"onHeaderField\");\n                    state = S.HEADERS_ALMOST_DONE;\n                    break;\n                  }\n                  index++;\n                  if (c === HYPHEN) {\n                    break;\n                  }\n                  if (c === COLON) {\n                    if (index === 1) {\n                      return;\n                    }\n                    dataCallback(\"onHeaderField\", true);\n                    state = S.HEADER_VALUE_START;\n                    break;\n                  }\n                  cl = lower(c);\n                  if (cl < A || cl > Z) {\n                    return;\n                  }\n                  break;\n                case S.HEADER_VALUE_START:\n                  if (c === SPACE) {\n                    break;\n                  }\n                  mark(\"onHeaderValue\");\n                  state = S.HEADER_VALUE;\n                case S.HEADER_VALUE:\n                  if (c === CR) {\n                    dataCallback(\"onHeaderValue\", true);\n                    callback(\"onHeaderEnd\");\n                    state = S.HEADER_VALUE_ALMOST_DONE;\n                  }\n                  break;\n                case S.HEADER_VALUE_ALMOST_DONE:\n                  if (c !== LF) {\n                    return;\n                  }\n                  state = S.HEADER_FIELD_START;\n                  break;\n                case S.HEADERS_ALMOST_DONE:\n                  if (c !== LF) {\n                    return;\n                  }\n                  callback(\"onHeadersEnd\");\n                  state = S.PART_DATA_START;\n                  break;\n                case S.PART_DATA_START:\n                  state = S.PART_DATA;\n                  mark(\"onPartData\");\n                case S.PART_DATA:\n                  previousIndex = index;\n                  if (index === 0) {\n                    i2 += boundaryEnd;\n                    while (i2 < bufferLength && !(data[i2] in boundaryChars)) {\n                      i2 += boundaryLength;\n                    }\n                    i2 -= boundaryEnd;\n                    c = data[i2];\n                  }\n                  if (index < boundary.length) {\n                    if (boundary[index] === c) {\n                      if (index === 0) {\n                        dataCallback(\"onPartData\", true);\n                      }\n                      index++;\n                    } else {\n                      index = 0;\n                    }\n                  } else if (index === boundary.length) {\n                    index++;\n                    if (c === CR) {\n                      flags |= F.PART_BOUNDARY;\n                    } else if (c === HYPHEN) {\n                      flags |= F.LAST_BOUNDARY;\n                    } else {\n                      index = 0;\n                    }\n                  } else if (index - 1 === boundary.length) {\n                    if (flags & F.PART_BOUNDARY) {\n                      index = 0;\n                      if (c === LF) {\n                        flags &= ~F.PART_BOUNDARY;\n                        callback(\"onPartEnd\");\n                        callback(\"onPartBegin\");\n                        state = S.HEADER_FIELD_START;\n                        break;\n                      }\n                    } else if (flags & F.LAST_BOUNDARY) {\n                      if (c === HYPHEN) {\n                        callback(\"onPartEnd\");\n                        state = S.END;\n                        flags = 0;\n                      } else {\n                        index = 0;\n                      }\n                    } else {\n                      index = 0;\n                    }\n                  }\n                  if (index > 0) {\n                    lookbehind[index - 1] = c;\n                  } else if (previousIndex > 0) {\n                    const _lookbehind = new Uint8Array(lookbehind.buffer, lookbehind.byteOffset, lookbehind.byteLength);\n                    callback(\"onPartData\", 0, previousIndex, _lookbehind);\n                    previousIndex = 0;\n                    mark(\"onPartData\");\n                    i2--;\n                  }\n                  break;\n                case S.END:\n                  break;\n                default:\n                  throw new Error(`Unexpected state entered: ${state}`);\n              }\n            }\n            dataCallback(\"onHeaderField\");\n            dataCallback(\"onHeaderValue\");\n            dataCallback(\"onPartData\");\n            this.index = index;\n            this.state = state;\n            this.flags = flags;\n          }\n          end() {\n            if (this.state === S.HEADER_FIELD_START && this.index === 0 || this.state === S.PART_DATA && this.index === this.boundary.length) {\n              this.onPartEnd();\n            } else if (this.state !== S.END) {\n              throw new Error(\"MultipartParser.end(): stream ended unexpectedly\");\n            }\n          }\n        };\n      }\n    });\n    __export(exports2, {\n      AbortError: () => AbortError,\n      Blob: () => Blob2,\n      FetchError: () => FetchError,\n      File: () => file_default,\n      FormData: () => FormData,\n      Headers: () => Headers,\n      Request: () => Request,\n      Response: () => Response,\n      blobFrom: () => blobFrom,\n      blobFromSync: () => blobFromSync,\n      default: () => fetch,\n      fileFrom: () => fileFrom,\n      fileFromSync: () => fileFromSync,\n      isRedirect: () => isRedirect\n    });\n    var import_node_http2 = __toModule(__webpack_require__(/*! http */ \"http\"));\n    var import_node_https = __toModule(__webpack_require__(/*! https */ \"https\"));\n    var import_node_zlib = __toModule(__webpack_require__(/*! zlib */ \"zlib\"));\n    var import_node_stream2 = __toModule(__webpack_require__(/*! stream */ \"stream\"));\n    var import_node_buffer2 = __toModule(__webpack_require__(/*! buffer */ \"buffer\"));\n    function dataUriToBuffer(uri) {\n      if (!/^data:/i.test(uri)) {\n        throw new TypeError('`uri` does not appear to be a Data URI (must begin with \"data:\")');\n      }\n      uri = uri.replace(/\\r?\\n/g, \"\");\n      const firstComma = uri.indexOf(\",\");\n      if (firstComma === -1 || firstComma <= 4) {\n        throw new TypeError(\"malformed data: URI\");\n      }\n      const meta = uri.substring(5, firstComma).split(\";\");\n      let charset = \"\";\n      let base64 = false;\n      const type = meta[0] || \"text/plain\";\n      let typeFull = type;\n      for (let i2 = 1; i2 < meta.length; i2++) {\n        if (meta[i2] === \"base64\") {\n          base64 = true;\n        } else if (meta[i2]) {\n          typeFull += `;${meta[i2]}`;\n          if (meta[i2].indexOf(\"charset=\") === 0) {\n            charset = meta[i2].substring(8);\n          }\n        }\n      }\n      if (!meta[0] && !charset.length) {\n        typeFull += \";charset=US-ASCII\";\n        charset = \"US-ASCII\";\n      }\n      const encoding = base64 ? \"base64\" : \"ascii\";\n      const data = unescape(uri.substring(firstComma + 1));\n      const buffer = Buffer.from(data, encoding);\n      buffer.type = type;\n      buffer.typeFull = typeFull;\n      buffer.charset = charset;\n      return buffer;\n    }\n    var dist_default = dataUriToBuffer;\n    var import_node_stream = __toModule(__webpack_require__(/*! stream */ \"stream\"));\n    var import_node_util = __toModule(__webpack_require__(/*! util */ \"util\"));\n    var import_node_buffer = __toModule(__webpack_require__(/*! buffer */ \"buffer\"));\n    init_fetch_blob();\n    init_esm_min();\n    var FetchBaseError = class extends Error {\n      constructor(message, type) {\n        super(message);\n        Error.captureStackTrace(this, this.constructor);\n        this.type = type;\n      }\n      get name() {\n        return this.constructor.name;\n      }\n      get [Symbol.toStringTag]() {\n        return this.constructor.name;\n      }\n    };\n    var FetchError = class extends FetchBaseError {\n      constructor(message, type, systemError) {\n        super(message, type);\n        if (systemError) {\n          this.code = this.errno = systemError.code;\n          this.erroredSysCall = systemError.syscall;\n        }\n      }\n    };\n    var NAME = Symbol.toStringTag;\n    var isURLSearchParameters = (object) => {\n      return typeof object === \"object\" && typeof object.append === \"function\" && typeof object.delete === \"function\" && typeof object.get === \"function\" && typeof object.getAll === \"function\" && typeof object.has === \"function\" && typeof object.set === \"function\" && typeof object.sort === \"function\" && object[NAME] === \"URLSearchParams\";\n    };\n    var isBlob = (object) => {\n      return object && typeof object === \"object\" && typeof object.arrayBuffer === \"function\" && typeof object.type === \"string\" && typeof object.stream === \"function\" && typeof object.constructor === \"function\" && /^(Blob|File)$/.test(object[NAME]);\n    };\n    var isAbortSignal = (object) => {\n      return typeof object === \"object\" && (object[NAME] === \"AbortSignal\" || object[NAME] === \"EventTarget\");\n    };\n    var isDomainOrSubdomain = (destination, original) => {\n      const orig = new URL(original).hostname;\n      const dest = new URL(destination).hostname;\n      return orig === dest || orig.endsWith(`.${dest}`);\n    };\n    var isSameProtocol = (destination, original) => {\n      const orig = new URL(original).protocol;\n      const dest = new URL(destination).protocol;\n      return orig === dest;\n    };\n    var pipeline = (0, import_node_util.promisify)(import_node_stream.default.pipeline);\n    var INTERNALS = Symbol(\"Body internals\");\n    var Body = class {\n      constructor(body, {\n        size = 0\n      } = {}) {\n        let boundary = null;\n        if (body === null) {\n          body = null;\n        } else if (isURLSearchParameters(body)) {\n          body = import_node_buffer.Buffer.from(body.toString());\n        } else if (isBlob(body)) {\n        } else if (import_node_buffer.Buffer.isBuffer(body)) {\n        } else if (import_node_util.types.isAnyArrayBuffer(body)) {\n          body = import_node_buffer.Buffer.from(body);\n        } else if (ArrayBuffer.isView(body)) {\n          body = import_node_buffer.Buffer.from(body.buffer, body.byteOffset, body.byteLength);\n        } else if (body instanceof import_node_stream.default) {\n        } else if (body instanceof FormData) {\n          body = formDataToBlob(body);\n          boundary = body.type.split(\"=\")[1];\n        } else {\n          body = import_node_buffer.Buffer.from(String(body));\n        }\n        let stream = body;\n        if (import_node_buffer.Buffer.isBuffer(body)) {\n          stream = import_node_stream.default.Readable.from(body);\n        } else if (isBlob(body)) {\n          stream = import_node_stream.default.Readable.from(body.stream());\n        }\n        this[INTERNALS] = {\n          body,\n          stream,\n          boundary,\n          disturbed: false,\n          error: null\n        };\n        this.size = size;\n        if (body instanceof import_node_stream.default) {\n          body.on(\"error\", (error_) => {\n            const error = error_ instanceof FetchBaseError ? error_ : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, \"system\", error_);\n            this[INTERNALS].error = error;\n          });\n        }\n      }\n      get body() {\n        return this[INTERNALS].stream;\n      }\n      get bodyUsed() {\n        return this[INTERNALS].disturbed;\n      }\n      async arrayBuffer() {\n        const { buffer, byteOffset, byteLength } = await consumeBody(this);\n        return buffer.slice(byteOffset, byteOffset + byteLength);\n      }\n      async formData() {\n        const ct = this.headers.get(\"content-type\");\n        if (ct.startsWith(\"application/x-www-form-urlencoded\")) {\n          const formData = new FormData();\n          const parameters = new URLSearchParams(await this.text());\n          for (const [name, value] of parameters) {\n            formData.append(name, value);\n          }\n          return formData;\n        }\n        const { toFormData: toFormData2 } = await Promise.resolve().then(() => (init_multipart_parser(), multipart_parser_exports));\n        return toFormData2(this.body, ct);\n      }\n      async blob() {\n        const ct = this.headers && this.headers.get(\"content-type\") || this[INTERNALS].body && this[INTERNALS].body.type || \"\";\n        const buf = await this.arrayBuffer();\n        return new fetch_blob_default([buf], {\n          type: ct\n        });\n      }\n      async json() {\n        const text = await this.text();\n        return JSON.parse(text);\n      }\n      async text() {\n        const buffer = await consumeBody(this);\n        return new TextDecoder().decode(buffer);\n      }\n      buffer() {\n        return consumeBody(this);\n      }\n    };\n    Body.prototype.buffer = (0, import_node_util.deprecate)(Body.prototype.buffer, \"Please use 'response.arrayBuffer()' instead of 'response.buffer()'\", \"node-fetch#buffer\");\n    Object.defineProperties(Body.prototype, {\n      body: { enumerable: true },\n      bodyUsed: { enumerable: true },\n      arrayBuffer: { enumerable: true },\n      blob: { enumerable: true },\n      json: { enumerable: true },\n      text: { enumerable: true },\n      data: { get: (0, import_node_util.deprecate)(() => {\n      }, \"data doesn't exist, use json(), text(), arrayBuffer(), or body instead\", \"https://github.com/node-fetch/node-fetch/issues/1000 (response)\") }\n    });\n    async function consumeBody(data) {\n      if (data[INTERNALS].disturbed) {\n        throw new TypeError(`body used already for: ${data.url}`);\n      }\n      data[INTERNALS].disturbed = true;\n      if (data[INTERNALS].error) {\n        throw data[INTERNALS].error;\n      }\n      const { body } = data;\n      if (body === null) {\n        return import_node_buffer.Buffer.alloc(0);\n      }\n      if (!(body instanceof import_node_stream.default)) {\n        return import_node_buffer.Buffer.alloc(0);\n      }\n      const accum = [];\n      let accumBytes = 0;\n      try {\n        for await (const chunk of body) {\n          if (data.size > 0 && accumBytes + chunk.length > data.size) {\n            const error = new FetchError(`content size at ${data.url} over limit: ${data.size}`, \"max-size\");\n            body.destroy(error);\n            throw error;\n          }\n          accumBytes += chunk.length;\n          accum.push(chunk);\n        }\n      } catch (error) {\n        const error_ = error instanceof FetchBaseError ? error : new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error.message}`, \"system\", error);\n        throw error_;\n      }\n      if (body.readableEnded === true || body._readableState.ended === true) {\n        try {\n          if (accum.every((c) => typeof c === \"string\")) {\n            return import_node_buffer.Buffer.from(accum.join(\"\"));\n          }\n          return import_node_buffer.Buffer.concat(accum, accumBytes);\n        } catch (error) {\n          throw new FetchError(`Could not create Buffer from response body for ${data.url}: ${error.message}`, \"system\", error);\n        }\n      } else {\n        throw new FetchError(`Premature close of server response while trying to fetch ${data.url}`);\n      }\n    }\n    var clone = (instance, highWaterMark) => {\n      let p1;\n      let p2;\n      let { body } = instance[INTERNALS];\n      if (instance.bodyUsed) {\n        throw new Error(\"cannot clone body after it is used\");\n      }\n      if (body instanceof import_node_stream.default && typeof body.getBoundary !== \"function\") {\n        p1 = new import_node_stream.PassThrough({ highWaterMark });\n        p2 = new import_node_stream.PassThrough({ highWaterMark });\n        body.pipe(p1);\n        body.pipe(p2);\n        instance[INTERNALS].stream = p1;\n        body = p2;\n      }\n      return body;\n    };\n    var getNonSpecFormDataBoundary = (0, import_node_util.deprecate)((body) => body.getBoundary(), \"form-data doesn't follow the spec and requires special treatment. Use alternative package\", \"https://github.com/node-fetch/node-fetch/issues/1167\");\n    var extractContentType = (body, request) => {\n      if (body === null) {\n        return null;\n      }\n      if (typeof body === \"string\") {\n        return \"text/plain;charset=UTF-8\";\n      }\n      if (isURLSearchParameters(body)) {\n        return \"application/x-www-form-urlencoded;charset=UTF-8\";\n      }\n      if (isBlob(body)) {\n        return body.type || null;\n      }\n      if (import_node_buffer.Buffer.isBuffer(body) || import_node_util.types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {\n        return null;\n      }\n      if (body instanceof FormData) {\n        return `multipart/form-data; boundary=${request[INTERNALS].boundary}`;\n      }\n      if (body && typeof body.getBoundary === \"function\") {\n        return `multipart/form-data;boundary=${getNonSpecFormDataBoundary(body)}`;\n      }\n      if (body instanceof import_node_stream.default) {\n        return null;\n      }\n      return \"text/plain;charset=UTF-8\";\n    };\n    var getTotalBytes = (request) => {\n      const { body } = request[INTERNALS];\n      if (body === null) {\n        return 0;\n      }\n      if (isBlob(body)) {\n        return body.size;\n      }\n      if (import_node_buffer.Buffer.isBuffer(body)) {\n        return body.length;\n      }\n      if (body && typeof body.getLengthSync === \"function\") {\n        return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;\n      }\n      return null;\n    };\n    var writeToStream = async (dest, { body }) => {\n      if (body === null) {\n        dest.end();\n      } else {\n        await pipeline(body, dest);\n      }\n    };\n    var import_node_util2 = __toModule(__webpack_require__(/*! util */ \"util\"));\n    var import_node_http = __toModule(__webpack_require__(/*! http */ \"http\"));\n    var validateHeaderName = typeof import_node_http.default.validateHeaderName === \"function\" ? import_node_http.default.validateHeaderName : (name) => {\n      if (!/^[\\^`\\-\\w!#$%&'*+.|~]+$/.test(name)) {\n        const error = new TypeError(`Header name must be a valid HTTP token [${name}]`);\n        Object.defineProperty(error, \"code\", { value: \"ERR_INVALID_HTTP_TOKEN\" });\n        throw error;\n      }\n    };\n    var validateHeaderValue = typeof import_node_http.default.validateHeaderValue === \"function\" ? import_node_http.default.validateHeaderValue : (name, value) => {\n      if (/[^\\t\\u0020-\\u007E\\u0080-\\u00FF]/.test(value)) {\n        const error = new TypeError(`Invalid character in header content [\"${name}\"]`);\n        Object.defineProperty(error, \"code\", { value: \"ERR_INVALID_CHAR\" });\n        throw error;\n      }\n    };\n    var Headers = class extends URLSearchParams {\n      constructor(init) {\n        let result = [];\n        if (init instanceof Headers) {\n          const raw = init.raw();\n          for (const [name, values] of Object.entries(raw)) {\n            result.push(...values.map((value) => [name, value]));\n          }\n        } else if (init == null) {\n        } else if (typeof init === \"object\" && !import_node_util2.types.isBoxedPrimitive(init)) {\n          const method = init[Symbol.iterator];\n          if (method == null) {\n            result.push(...Object.entries(init));\n          } else {\n            if (typeof method !== \"function\") {\n              throw new TypeError(\"Header pairs must be iterable\");\n            }\n            result = [...init].map((pair) => {\n              if (typeof pair !== \"object\" || import_node_util2.types.isBoxedPrimitive(pair)) {\n                throw new TypeError(\"Each header pair must be an iterable object\");\n              }\n              return [...pair];\n            }).map((pair) => {\n              if (pair.length !== 2) {\n                throw new TypeError(\"Each header pair must be a name/value tuple\");\n              }\n              return [...pair];\n            });\n          }\n        } else {\n          throw new TypeError(\"Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)\");\n        }\n        result = result.length > 0 ? result.map(([name, value]) => {\n          validateHeaderName(name);\n          validateHeaderValue(name, String(value));\n          return [String(name).toLowerCase(), String(value)];\n        }) : void 0;\n        super(result);\n        return new Proxy(this, {\n          get(target, p, receiver) {\n            switch (p) {\n              case \"append\":\n              case \"set\":\n                return (name, value) => {\n                  validateHeaderName(name);\n                  validateHeaderValue(name, String(value));\n                  return URLSearchParams.prototype[p].call(target, String(name).toLowerCase(), String(value));\n                };\n              case \"delete\":\n              case \"has\":\n              case \"getAll\":\n                return (name) => {\n                  validateHeaderName(name);\n                  return URLSearchParams.prototype[p].call(target, String(name).toLowerCase());\n                };\n              case \"keys\":\n                return () => {\n                  target.sort();\n                  return new Set(URLSearchParams.prototype.keys.call(target)).keys();\n                };\n              default:\n                return Reflect.get(target, p, receiver);\n            }\n          }\n        });\n      }\n      get [Symbol.toStringTag]() {\n        return this.constructor.name;\n      }\n      toString() {\n        return Object.prototype.toString.call(this);\n      }\n      get(name) {\n        const values = this.getAll(name);\n        if (values.length === 0) {\n          return null;\n        }\n        let value = values.join(\", \");\n        if (/^content-encoding$/i.test(name)) {\n          value = value.toLowerCase();\n        }\n        return value;\n      }\n      forEach(callback, thisArg = void 0) {\n        for (const name of this.keys()) {\n          Reflect.apply(callback, thisArg, [this.get(name), name, this]);\n        }\n      }\n      *values() {\n        for (const name of this.keys()) {\n          yield this.get(name);\n        }\n      }\n      *entries() {\n        for (const name of this.keys()) {\n          yield [name, this.get(name)];\n        }\n      }\n      [Symbol.iterator]() {\n        return this.entries();\n      }\n      raw() {\n        return [...this.keys()].reduce((result, key) => {\n          result[key] = this.getAll(key);\n          return result;\n        }, {});\n      }\n      [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n        return [...this.keys()].reduce((result, key) => {\n          const values = this.getAll(key);\n          if (key === \"host\") {\n            result[key] = values[0];\n          } else {\n            result[key] = values.length > 1 ? values : values[0];\n          }\n          return result;\n        }, {});\n      }\n    };\n    Object.defineProperties(Headers.prototype, [\"get\", \"entries\", \"forEach\", \"values\"].reduce((result, property) => {\n      result[property] = { enumerable: true };\n      return result;\n    }, {}));\n    function fromRawHeaders(headers = []) {\n      return new Headers(headers.reduce((result, value, index, array) => {\n        if (index % 2 === 0) {\n          result.push(array.slice(index, index + 2));\n        }\n        return result;\n      }, []).filter(([name, value]) => {\n        try {\n          validateHeaderName(name);\n          validateHeaderValue(name, String(value));\n          return true;\n        } catch {\n          return false;\n        }\n      }));\n    }\n    var redirectStatus = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);\n    var isRedirect = (code) => {\n      return redirectStatus.has(code);\n    };\n    var INTERNALS2 = Symbol(\"Response internals\");\n    var Response = class extends Body {\n      constructor(body = null, options = {}) {\n        super(body, options);\n        const status = options.status != null ? options.status : 200;\n        const headers = new Headers(options.headers);\n        if (body !== null && !headers.has(\"Content-Type\")) {\n          const contentType = extractContentType(body, this);\n          if (contentType) {\n            headers.append(\"Content-Type\", contentType);\n          }\n        }\n        this[INTERNALS2] = {\n          type: \"default\",\n          url: options.url,\n          status,\n          statusText: options.statusText || \"\",\n          headers,\n          counter: options.counter,\n          highWaterMark: options.highWaterMark\n        };\n      }\n      get type() {\n        return this[INTERNALS2].type;\n      }\n      get url() {\n        return this[INTERNALS2].url || \"\";\n      }\n      get status() {\n        return this[INTERNALS2].status;\n      }\n      get ok() {\n        return this[INTERNALS2].status >= 200 && this[INTERNALS2].status < 300;\n      }\n      get redirected() {\n        return this[INTERNALS2].counter > 0;\n      }\n      get statusText() {\n        return this[INTERNALS2].statusText;\n      }\n      get headers() {\n        return this[INTERNALS2].headers;\n      }\n      get highWaterMark() {\n        return this[INTERNALS2].highWaterMark;\n      }\n      clone() {\n        return new Response(clone(this, this.highWaterMark), {\n          type: this.type,\n          url: this.url,\n          status: this.status,\n          statusText: this.statusText,\n          headers: this.headers,\n          ok: this.ok,\n          redirected: this.redirected,\n          size: this.size,\n          highWaterMark: this.highWaterMark\n        });\n      }\n      static redirect(url, status = 302) {\n        if (!isRedirect(status)) {\n          throw new RangeError('Failed to execute \"redirect\" on \"response\": Invalid status code');\n        }\n        return new Response(null, {\n          headers: {\n            location: new URL(url).toString()\n          },\n          status\n        });\n      }\n      static error() {\n        const response = new Response(null, { status: 0, statusText: \"\" });\n        response[INTERNALS2].type = \"error\";\n        return response;\n      }\n      static json(data = void 0, init = {}) {\n        const body = JSON.stringify(data);\n        if (body === void 0) {\n          throw new TypeError(\"data is not JSON serializable\");\n        }\n        const headers = new Headers(init && init.headers);\n        if (!headers.has(\"content-type\")) {\n          headers.set(\"content-type\", \"application/json\");\n        }\n        return new Response(body, {\n          ...init,\n          headers\n        });\n      }\n      get [Symbol.toStringTag]() {\n        return \"Response\";\n      }\n    };\n    Object.defineProperties(Response.prototype, {\n      type: { enumerable: true },\n      url: { enumerable: true },\n      status: { enumerable: true },\n      ok: { enumerable: true },\n      redirected: { enumerable: true },\n      statusText: { enumerable: true },\n      headers: { enumerable: true },\n      clone: { enumerable: true }\n    });\n    var import_node_url = __toModule(__webpack_require__(/*! url */ \"url\"));\n    var import_node_util3 = __toModule(__webpack_require__(/*! util */ \"util\"));\n    var getSearch = (parsedURL) => {\n      if (parsedURL.search) {\n        return parsedURL.search;\n      }\n      const lastOffset = parsedURL.href.length - 1;\n      const hash = parsedURL.hash || (parsedURL.href[lastOffset] === \"#\" ? \"#\" : \"\");\n      return parsedURL.href[lastOffset - hash.length] === \"?\" ? \"?\" : \"\";\n    };\n    var import_node_net = __toModule(__webpack_require__(/*! net */ \"net\"));\n    function stripURLForUseAsAReferrer(url, originOnly = false) {\n      if (url == null) {\n        return \"no-referrer\";\n      }\n      url = new URL(url);\n      if (/^(about|blob|data):$/.test(url.protocol)) {\n        return \"no-referrer\";\n      }\n      url.username = \"\";\n      url.password = \"\";\n      url.hash = \"\";\n      if (originOnly) {\n        url.pathname = \"\";\n        url.search = \"\";\n      }\n      return url;\n    }\n    var ReferrerPolicy = /* @__PURE__ */ new Set([\n      \"\",\n      \"no-referrer\",\n      \"no-referrer-when-downgrade\",\n      \"same-origin\",\n      \"origin\",\n      \"strict-origin\",\n      \"origin-when-cross-origin\",\n      \"strict-origin-when-cross-origin\",\n      \"unsafe-url\"\n    ]);\n    var DEFAULT_REFERRER_POLICY = \"strict-origin-when-cross-origin\";\n    function validateReferrerPolicy(referrerPolicy) {\n      if (!ReferrerPolicy.has(referrerPolicy)) {\n        throw new TypeError(`Invalid referrerPolicy: ${referrerPolicy}`);\n      }\n      return referrerPolicy;\n    }\n    function isOriginPotentiallyTrustworthy(url) {\n      if (/^(http|ws)s:$/.test(url.protocol)) {\n        return true;\n      }\n      const hostIp = url.host.replace(/(^\\[)|(]$)/g, \"\");\n      const hostIPVersion = (0, import_node_net.isIP)(hostIp);\n      if (hostIPVersion === 4 && /^127\\./.test(hostIp)) {\n        return true;\n      }\n      if (hostIPVersion === 6 && /^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(hostIp)) {\n        return true;\n      }\n      if (url.host === \"localhost\" || url.host.endsWith(\".localhost\")) {\n        return false;\n      }\n      if (url.protocol === \"file:\") {\n        return true;\n      }\n      return false;\n    }\n    function isUrlPotentiallyTrustworthy(url) {\n      if (/^about:(blank|srcdoc)$/.test(url)) {\n        return true;\n      }\n      if (url.protocol === \"data:\") {\n        return true;\n      }\n      if (/^(blob|filesystem):$/.test(url.protocol)) {\n        return true;\n      }\n      return isOriginPotentiallyTrustworthy(url);\n    }\n    function determineRequestsReferrer(request, { referrerURLCallback, referrerOriginCallback } = {}) {\n      if (request.referrer === \"no-referrer\" || request.referrerPolicy === \"\") {\n        return null;\n      }\n      const policy = request.referrerPolicy;\n      if (request.referrer === \"about:client\") {\n        return \"no-referrer\";\n      }\n      const referrerSource = request.referrer;\n      let referrerURL = stripURLForUseAsAReferrer(referrerSource);\n      let referrerOrigin = stripURLForUseAsAReferrer(referrerSource, true);\n      if (referrerURL.toString().length > 4096) {\n        referrerURL = referrerOrigin;\n      }\n      if (referrerURLCallback) {\n        referrerURL = referrerURLCallback(referrerURL);\n      }\n      if (referrerOriginCallback) {\n        referrerOrigin = referrerOriginCallback(referrerOrigin);\n      }\n      const currentURL = new URL(request.url);\n      switch (policy) {\n        case \"no-referrer\":\n          return \"no-referrer\";\n        case \"origin\":\n          return referrerOrigin;\n        case \"unsafe-url\":\n          return referrerURL;\n        case \"strict-origin\":\n          if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {\n            return \"no-referrer\";\n          }\n          return referrerOrigin.toString();\n        case \"strict-origin-when-cross-origin\":\n          if (referrerURL.origin === currentURL.origin) {\n            return referrerURL;\n          }\n          if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {\n            return \"no-referrer\";\n          }\n          return referrerOrigin;\n        case \"same-origin\":\n          if (referrerURL.origin === currentURL.origin) {\n            return referrerURL;\n          }\n          return \"no-referrer\";\n        case \"origin-when-cross-origin\":\n          if (referrerURL.origin === currentURL.origin) {\n            return referrerURL;\n          }\n          return referrerOrigin;\n        case \"no-referrer-when-downgrade\":\n          if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {\n            return \"no-referrer\";\n          }\n          return referrerURL;\n        default:\n          throw new TypeError(`Invalid referrerPolicy: ${policy}`);\n      }\n    }\n    function parseReferrerPolicyFromHeader(headers) {\n      const policyTokens = (headers.get(\"referrer-policy\") || \"\").split(/[,\\s]+/);\n      let policy = \"\";\n      for (const token of policyTokens) {\n        if (token && ReferrerPolicy.has(token)) {\n          policy = token;\n        }\n      }\n      return policy;\n    }\n    var INTERNALS3 = Symbol(\"Request internals\");\n    var isRequest = (object) => {\n      return typeof object === \"object\" && typeof object[INTERNALS3] === \"object\";\n    };\n    var doBadDataWarn = (0, import_node_util3.deprecate)(() => {\n    }, \".data is not a valid RequestInit property, use .body instead\", \"https://github.com/node-fetch/node-fetch/issues/1000 (request)\");\n    var Request = class extends Body {\n      constructor(input, init = {}) {\n        let parsedURL;\n        if (isRequest(input)) {\n          parsedURL = new URL(input.url);\n        } else {\n          parsedURL = new URL(input);\n          input = {};\n        }\n        if (parsedURL.username !== \"\" || parsedURL.password !== \"\") {\n          throw new TypeError(`${parsedURL} is an url with embedded credentials.`);\n        }\n        let method = init.method || input.method || \"GET\";\n        if (/^(delete|get|head|options|post|put)$/i.test(method)) {\n          method = method.toUpperCase();\n        }\n        if (!isRequest(init) && \"data\" in init) {\n          doBadDataWarn();\n        }\n        if ((init.body != null || isRequest(input) && input.body !== null) && (method === \"GET\" || method === \"HEAD\")) {\n          throw new TypeError(\"Request with GET/HEAD method cannot have body\");\n        }\n        const inputBody = init.body ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;\n        super(inputBody, {\n          size: init.size || input.size || 0\n        });\n        const headers = new Headers(init.headers || input.headers || {});\n        if (inputBody !== null && !headers.has(\"Content-Type\")) {\n          const contentType = extractContentType(inputBody, this);\n          if (contentType) {\n            headers.set(\"Content-Type\", contentType);\n          }\n        }\n        let signal = isRequest(input) ? input.signal : null;\n        if (\"signal\" in init) {\n          signal = init.signal;\n        }\n        if (signal != null && !isAbortSignal(signal)) {\n          throw new TypeError(\"Expected signal to be an instanceof AbortSignal or EventTarget\");\n        }\n        let referrer = init.referrer == null ? input.referrer : init.referrer;\n        if (referrer === \"\") {\n          referrer = \"no-referrer\";\n        } else if (referrer) {\n          const parsedReferrer = new URL(referrer);\n          referrer = /^about:(\\/\\/)?client$/.test(parsedReferrer) ? \"client\" : parsedReferrer;\n        } else {\n          referrer = void 0;\n        }\n        this[INTERNALS3] = {\n          method,\n          redirect: init.redirect || input.redirect || \"follow\",\n          headers,\n          parsedURL,\n          signal,\n          referrer\n        };\n        this.follow = init.follow === void 0 ? input.follow === void 0 ? 20 : input.follow : init.follow;\n        this.compress = init.compress === void 0 ? input.compress === void 0 ? true : input.compress : init.compress;\n        this.counter = init.counter || input.counter || 0;\n        this.agent = init.agent || input.agent;\n        this.highWaterMark = init.highWaterMark || input.highWaterMark || 16384;\n        this.insecureHTTPParser = init.insecureHTTPParser || input.insecureHTTPParser || false;\n        this.referrerPolicy = init.referrerPolicy || input.referrerPolicy || \"\";\n      }\n      get method() {\n        return this[INTERNALS3].method;\n      }\n      get url() {\n        return (0, import_node_url.format)(this[INTERNALS3].parsedURL);\n      }\n      get headers() {\n        return this[INTERNALS3].headers;\n      }\n      get redirect() {\n        return this[INTERNALS3].redirect;\n      }\n      get signal() {\n        return this[INTERNALS3].signal;\n      }\n      get referrer() {\n        if (this[INTERNALS3].referrer === \"no-referrer\") {\n          return \"\";\n        }\n        if (this[INTERNALS3].referrer === \"client\") {\n          return \"about:client\";\n        }\n        if (this[INTERNALS3].referrer) {\n          return this[INTERNALS3].referrer.toString();\n        }\n        return void 0;\n      }\n      get referrerPolicy() {\n        return this[INTERNALS3].referrerPolicy;\n      }\n      set referrerPolicy(referrerPolicy) {\n        this[INTERNALS3].referrerPolicy = validateReferrerPolicy(referrerPolicy);\n      }\n      clone() {\n        return new Request(this);\n      }\n      get [Symbol.toStringTag]() {\n        return \"Request\";\n      }\n    };\n    Object.defineProperties(Request.prototype, {\n      method: { enumerable: true },\n      url: { enumerable: true },\n      headers: { enumerable: true },\n      redirect: { enumerable: true },\n      clone: { enumerable: true },\n      signal: { enumerable: true },\n      referrer: { enumerable: true },\n      referrerPolicy: { enumerable: true }\n    });\n    var getNodeRequestOptions = (request) => {\n      const { parsedURL } = request[INTERNALS3];\n      const headers = new Headers(request[INTERNALS3].headers);\n      if (!headers.has(\"Accept\")) {\n        headers.set(\"Accept\", \"*/*\");\n      }\n      let contentLengthValue = null;\n      if (request.body === null && /^(post|put)$/i.test(request.method)) {\n        contentLengthValue = \"0\";\n      }\n      if (request.body !== null) {\n        const totalBytes = getTotalBytes(request);\n        if (typeof totalBytes === \"number\" && !Number.isNaN(totalBytes)) {\n          contentLengthValue = String(totalBytes);\n        }\n      }\n      if (contentLengthValue) {\n        headers.set(\"Content-Length\", contentLengthValue);\n      }\n      if (request.referrerPolicy === \"\") {\n        request.referrerPolicy = DEFAULT_REFERRER_POLICY;\n      }\n      if (request.referrer && request.referrer !== \"no-referrer\") {\n        request[INTERNALS3].referrer = determineRequestsReferrer(request);\n      } else {\n        request[INTERNALS3].referrer = \"no-referrer\";\n      }\n      if (request[INTERNALS3].referrer instanceof URL) {\n        headers.set(\"Referer\", request.referrer);\n      }\n      if (!headers.has(\"User-Agent\")) {\n        headers.set(\"User-Agent\", \"node-fetch\");\n      }\n      if (request.compress && !headers.has(\"Accept-Encoding\")) {\n        headers.set(\"Accept-Encoding\", \"gzip, deflate, br\");\n      }\n      let { agent } = request;\n      if (typeof agent === \"function\") {\n        agent = agent(parsedURL);\n      }\n      const search = getSearch(parsedURL);\n      const options = {\n        path: parsedURL.pathname + search,\n        method: request.method,\n        headers: headers[Symbol.for(\"nodejs.util.inspect.custom\")](),\n        insecureHTTPParser: request.insecureHTTPParser,\n        agent\n      };\n      return {\n        parsedURL,\n        options\n      };\n    };\n    var AbortError = class extends FetchBaseError {\n      constructor(message, type = \"aborted\") {\n        super(message, type);\n      }\n    };\n    init_esm_min();\n    init_from();\n    var supportedSchemas = /* @__PURE__ */ new Set([\"data:\", \"http:\", \"https:\"]);\n    async function fetch(url, options_) {\n      return new Promise((resolve, reject) => {\n        const request = new Request(url, options_);\n        const { parsedURL, options } = getNodeRequestOptions(request);\n        if (!supportedSchemas.has(parsedURL.protocol)) {\n          throw new TypeError(`node-fetch cannot load ${url}. URL scheme \"${parsedURL.protocol.replace(/:$/, \"\")}\" is not supported.`);\n        }\n        if (parsedURL.protocol === \"data:\") {\n          const data = dist_default(request.url);\n          const response2 = new Response(data, { headers: { \"Content-Type\": data.typeFull } });\n          resolve(response2);\n          return;\n        }\n        const send = (parsedURL.protocol === \"https:\" ? import_node_https.default : import_node_http2.default).request;\n        const { signal } = request;\n        let response = null;\n        const abort = () => {\n          const error = new AbortError(\"The operation was aborted.\");\n          reject(error);\n          if (request.body && request.body instanceof import_node_stream2.default.Readable) {\n            request.body.destroy(error);\n          }\n          if (!response || !response.body) {\n            return;\n          }\n          response.body.emit(\"error\", error);\n        };\n        if (signal && signal.aborted) {\n          abort();\n          return;\n        }\n        const abortAndFinalize = () => {\n          abort();\n          finalize();\n        };\n        const request_ = send(parsedURL.toString(), options);\n        if (signal) {\n          signal.addEventListener(\"abort\", abortAndFinalize);\n        }\n        const finalize = () => {\n          request_.abort();\n          if (signal) {\n            signal.removeEventListener(\"abort\", abortAndFinalize);\n          }\n        };\n        request_.on(\"error\", (error) => {\n          reject(new FetchError(`request to ${request.url} failed, reason: ${error.message}`, \"system\", error));\n          finalize();\n        });\n        fixResponseChunkedTransferBadEnding(request_, (error) => {\n          if (response && response.body) {\n            response.body.destroy(error);\n          }\n        });\n        if (process.version < \"v14\") {\n          request_.on(\"socket\", (s2) => {\n            let endedWithEventsCount;\n            s2.prependListener(\"end\", () => {\n              endedWithEventsCount = s2._eventsCount;\n            });\n            s2.prependListener(\"close\", (hadError) => {\n              if (response && endedWithEventsCount < s2._eventsCount && !hadError) {\n                const error = new Error(\"Premature close\");\n                error.code = \"ERR_STREAM_PREMATURE_CLOSE\";\n                response.body.emit(\"error\", error);\n              }\n            });\n          });\n        }\n        request_.on(\"response\", (response_) => {\n          request_.setTimeout(0);\n          const headers = fromRawHeaders(response_.rawHeaders);\n          if (isRedirect(response_.statusCode)) {\n            const location = headers.get(\"Location\");\n            let locationURL = null;\n            try {\n              locationURL = location === null ? null : new URL(location, request.url);\n            } catch {\n              if (request.redirect !== \"manual\") {\n                reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, \"invalid-redirect\"));\n                finalize();\n                return;\n              }\n            }\n            switch (request.redirect) {\n              case \"error\":\n                reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, \"no-redirect\"));\n                finalize();\n                return;\n              case \"manual\":\n                break;\n              case \"follow\": {\n                if (locationURL === null) {\n                  break;\n                }\n                if (request.counter >= request.follow) {\n                  reject(new FetchError(`maximum redirect reached at: ${request.url}`, \"max-redirect\"));\n                  finalize();\n                  return;\n                }\n                const requestOptions = {\n                  headers: new Headers(request.headers),\n                  follow: request.follow,\n                  counter: request.counter + 1,\n                  agent: request.agent,\n                  compress: request.compress,\n                  method: request.method,\n                  body: clone(request),\n                  signal: request.signal,\n                  size: request.size,\n                  referrer: request.referrer,\n                  referrerPolicy: request.referrerPolicy\n                };\n                if (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {\n                  for (const name of [\"authorization\", \"www-authenticate\", \"cookie\", \"cookie2\"]) {\n                    requestOptions.headers.delete(name);\n                  }\n                }\n                if (response_.statusCode !== 303 && request.body && options_.body instanceof import_node_stream2.default.Readable) {\n                  reject(new FetchError(\"Cannot follow redirect with body being a readable stream\", \"unsupported-redirect\"));\n                  finalize();\n                  return;\n                }\n                if (response_.statusCode === 303 || (response_.statusCode === 301 || response_.statusCode === 302) && request.method === \"POST\") {\n                  requestOptions.method = \"GET\";\n                  requestOptions.body = void 0;\n                  requestOptions.headers.delete(\"content-length\");\n                }\n                const responseReferrerPolicy = parseReferrerPolicyFromHeader(headers);\n                if (responseReferrerPolicy) {\n                  requestOptions.referrerPolicy = responseReferrerPolicy;\n                }\n                resolve(fetch(new Request(locationURL, requestOptions)));\n                finalize();\n                return;\n              }\n              default:\n                return reject(new TypeError(`Redirect option '${request.redirect}' is not a valid value of RequestRedirect`));\n            }\n          }\n          if (signal) {\n            response_.once(\"end\", () => {\n              signal.removeEventListener(\"abort\", abortAndFinalize);\n            });\n          }\n          let body = (0, import_node_stream2.pipeline)(response_, new import_node_stream2.PassThrough(), (error) => {\n            if (error) {\n              reject(error);\n            }\n          });\n          if (process.version < \"v12.10\") {\n            response_.on(\"aborted\", abortAndFinalize);\n          }\n          const responseOptions = {\n            url: request.url,\n            status: response_.statusCode,\n            statusText: response_.statusMessage,\n            headers,\n            size: request.size,\n            counter: request.counter,\n            highWaterMark: request.highWaterMark\n          };\n          const codings = headers.get(\"Content-Encoding\");\n          if (!request.compress || request.method === \"HEAD\" || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {\n            response = new Response(body, responseOptions);\n            resolve(response);\n            return;\n          }\n          const zlibOptions = {\n            flush: import_node_zlib.default.Z_SYNC_FLUSH,\n            finishFlush: import_node_zlib.default.Z_SYNC_FLUSH\n          };\n          if (codings === \"gzip\" || codings === \"x-gzip\") {\n            body = (0, import_node_stream2.pipeline)(body, import_node_zlib.default.createGunzip(zlibOptions), (error) => {\n              if (error) {\n                reject(error);\n              }\n            });\n            response = new Response(body, responseOptions);\n            resolve(response);\n            return;\n          }\n          if (codings === \"deflate\" || codings === \"x-deflate\") {\n            const raw = (0, import_node_stream2.pipeline)(response_, new import_node_stream2.PassThrough(), (error) => {\n              if (error) {\n                reject(error);\n              }\n            });\n            raw.once(\"data\", (chunk) => {\n              if ((chunk[0] & 15) === 8) {\n                body = (0, import_node_stream2.pipeline)(body, import_node_zlib.default.createInflate(), (error) => {\n                  if (error) {\n                    reject(error);\n                  }\n                });\n              } else {\n                body = (0, import_node_stream2.pipeline)(body, import_node_zlib.default.createInflateRaw(), (error) => {\n                  if (error) {\n                    reject(error);\n                  }\n                });\n              }\n              response = new Response(body, responseOptions);\n              resolve(response);\n            });\n            raw.once(\"end\", () => {\n              if (!response) {\n                response = new Response(body, responseOptions);\n                resolve(response);\n              }\n            });\n            return;\n          }\n          if (codings === \"br\") {\n            body = (0, import_node_stream2.pipeline)(body, import_node_zlib.default.createBrotliDecompress(), (error) => {\n              if (error) {\n                reject(error);\n              }\n            });\n            response = new Response(body, responseOptions);\n            resolve(response);\n            return;\n          }\n          response = new Response(body, responseOptions);\n          resolve(response);\n        });\n        writeToStream(request_, request).catch(reject);\n      });\n    }\n    function fixResponseChunkedTransferBadEnding(request, errorCallback) {\n      const LAST_CHUNK = import_node_buffer2.Buffer.from(\"0\\r\\n\\r\\n\");\n      let isChunkedTransfer = false;\n      let properLastChunkReceived = false;\n      let previousChunk;\n      request.on(\"response\", (response) => {\n        const { headers } = response;\n        isChunkedTransfer = headers[\"transfer-encoding\"] === \"chunked\" && !headers[\"content-length\"];\n      });\n      request.on(\"socket\", (socket) => {\n        const onSocketClose = () => {\n          if (isChunkedTransfer && !properLastChunkReceived) {\n            const error = new Error(\"Premature close\");\n            error.code = \"ERR_STREAM_PREMATURE_CLOSE\";\n            errorCallback(error);\n          }\n        };\n        const onData = (buf) => {\n          properLastChunkReceived = import_node_buffer2.Buffer.compare(buf.slice(-5), LAST_CHUNK) === 0;\n          if (!properLastChunkReceived && previousChunk) {\n            if (buf.length < 5) {\n              properLastChunkReceived = import_node_buffer2.Buffer.compare(\n                import_node_buffer2.Buffer.from([...previousChunk.slice(-5), ...buf]).slice(-5),\n                LAST_CHUNK\n              ) === 0;\n            }\n          }\n          previousChunk = buf;\n        };\n        socket.prependListener(\"close\", onSocketClose);\n        socket.on(\"data\", onData);\n        request.on(\"close\", () => {\n          socket.removeListener(\"close\", onSocketClose);\n          socket.removeListener(\"data\", onData);\n        });\n      });\n    }\n    init_fetch_blob();\n    init_esm_min();\n  }\n});\n\n// server.js\nfunction r(m) {\n  return m && m.default || m;\n}\nmodule.exports = function(url, opts) {\n  return r(require_dist())(String(url).replace(/^\\/\\//g, \"https://\"), opts);\n};\n/*! Bundled license information:\n\nnode-fetch-cjs/dist/index.js:\n  (*! fetch-blob. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> *)\n  (*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> *)\n  (*! node-domexception. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> *)\n*/\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBsYXNtaWNhcHAvaXNvbW9ycGhpYy11bmZldGNoL2Rpc3Qvc2VydmVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSwyREFBMkQsYUFBYTtBQUN4RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsYUFBYTtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxhQUFhO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGtDQUFrQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG9HQUFvRztBQUN6STtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlHQUF5RywwRUFBMEUsZ0RBQWdELElBQUksbUNBQW1DO0FBQzFRO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHLEtBQTBDLEdBQUcsaUNBQU8sQ0FBQyxPQUFTLENBQUMsb0NBQUUsT0FBTztBQUFBO0FBQUE7QUFBQSxrR0FBQyxJQUFJLENBQW9IO0FBQ2pTLFNBQVM7QUFDVDtBQUNBLDJJQUEySSxZQUFZO0FBQ3ZKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFNBQVM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsU0FBUztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUEr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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLE1BQU07QUFDOUU7QUFDQTtBQUNBLDJFQUEyRSxNQUFNO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxPQUFPO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsa0JBQWtCO0FBQ3ZDLHFCQUFxQixrQkFBa0I7QUFDdkMsMkJBQTJCLGtCQUFrQjtBQUM3QyxxQkFBcUIsa0JBQWtCO0FBQ3ZDLHNCQUFzQixrQkFBa0I7QUFDeEMsMkJBQTJCLGtCQUFrQjtBQUM3QyxxQkFBcUI7QUFDckIsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0JBQWtCO0FBQzdDLHNCQUFzQixrQkFBa0I7QUFDeEMscUJBQXFCO0FBQ3JCLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELE1BQU07QUFDbkU7QUFDQTtBQUNBLDhFQUE4RSxNQUFNO0FBQ3BGO0FBQ0E7QUFDQSwwRUFBMEUsTUFBTTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLE1BQU07QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNC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Q0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsTUFBTTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsdUNBQXVDLG1CQUFPLENBQUMsa0JBQU07QUFDckQsdUNBQXVDLG1CQUFPLENBQUMsb0JBQU87QUFDdEQsc0NBQXNDLG1CQUFPLENBQUMsa0JBQU07QUFDcEQseUNBQXlDLG1CQUFPLENBQUMsc0JBQVE7QUFDekQseUNBQXlDLG1CQUFPLENBQUMsc0JBQVE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0EsVUFBVTtBQUNWLHdCQUF3QixFQUFFLFNBQVM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsbUJBQU8sQ0FBQyxzQkFBUTtBQUN4RCxzQ0FBc0MsbUJBQU8sQ0FBQyxrQkFBTTtBQUNwRCx3Q0FBd0MsbUJBQU8sQ0FBQyxzQkFBUTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxLQUFLO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLElBQUk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1YsVUFBVTtBQUNWLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVixVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9JQUFvSSxTQUFTLElBQUksZUFBZTtBQUNoSztBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUNBQWlDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwQkFBMEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxrQkFBa0I7QUFDaEMsa0JBQWtCLGtCQUFrQjtBQUNwQyxxQkFBcUIsa0JBQWtCO0FBQ3ZDLGNBQWMsa0JBQWtCO0FBQ2hDLGNBQWMsa0JBQWtCO0FBQ2hDLGNBQWMsa0JBQWtCO0FBQ2hDLGNBQWM7QUFDZCxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxzREFBc0QsU0FBUztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsVUFBVSxjQUFjLFVBQVU7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLCtIQUErSCxTQUFTLElBQUksY0FBYztBQUMxSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGlGQUFpRixTQUFTLElBQUksY0FBYztBQUM1RztBQUNBLFFBQVE7QUFDUix5RkFBeUYsU0FBUztBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGVBQWU7QUFDakUsa0RBQWtELGVBQWU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFdBQVcsNEJBQTRCO0FBQzVFO0FBQ0E7QUFDQSxvQ0FBb0MsV0FBVyxpQ0FBaUM7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLE1BQU07QUFDN0M7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsbUJBQU8sQ0FBQyxrQkFBTTtBQUNyRCxzQ0FBc0MsbUJBQU8sQ0FBQyxrQkFBTTtBQUNwRDtBQUNBO0FBQ0EsK0VBQStFLEtBQUs7QUFDcEYsK0NBQStDLGlDQUFpQztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLEtBQUs7QUFDbEYsK0NBQStDLDJCQUEyQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw4Q0FBOEMsMkJBQTJCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsa0JBQWtCO0FBQ2hDLGFBQWEsa0JBQWtCO0FBQy9CLGdCQUFnQixrQkFBa0I7QUFDbEMsWUFBWSxrQkFBa0I7QUFDOUIsb0JBQW9CLGtCQUFrQjtBQUN0QyxvQkFBb0Isa0JBQWtCO0FBQ3RDLGlCQUFpQixrQkFBa0I7QUFDbkMsZUFBZTtBQUNmLEtBQUs7QUFDTCxxQ0FBcUMsbUJBQU8sQ0FBQyxnQkFBSztBQUNsRCx1Q0FBdUMsbUJBQU8sQ0FBQyxrQkFBTTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG1CQUFPLENBQUMsZ0JBQUs7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsZUFBZTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsRUFBRSxXQUFXLElBQUk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsOENBQThDLElBQUk7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxPQUFPO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFdBQVc7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvV29uZGVyVml0ZS1mcm9udGVuZC9ub2RlX21vZHVsZXMvQHBsYXNtaWNhcHAvaXNvbW9ycGhpYy11bmZldGNoL2Rpc3Qvc2VydmVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fY29tbW9uSlMgPSAoY2IsIG1vZCkgPT4gZnVuY3Rpb24gX19yZXF1aXJlKCkge1xuICByZXR1cm4gbW9kIHx8ICgwLCBjYltfX2dldE93blByb3BOYW1lcyhjYilbMF1dKSgobW9kID0geyBleHBvcnRzOiB7fSB9KS5leHBvcnRzLCBtb2QpLCBtb2QuZXhwb3J0cztcbn07XG5cbi8vIG5vZGVfbW9kdWxlcy9ub2RlLWZldGNoLWNqcy9kaXN0L2luZGV4LmpzXG52YXIgcmVxdWlyZV9kaXN0ID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL25vZGUtZmV0Y2gtY2pzL2Rpc3QvaW5kZXguanNcIihleHBvcnRzMikge1xuICAgIHZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG4gICAgdmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbiAgICB2YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICAgdmFyIF9fZ2V0T3duUHJvcE5hbWVzMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xuICAgIHZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gICAgdmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gICAgdmFyIF9fbWFya0FzTW9kdWxlID0gKHRhcmdldCkgPT4gX19kZWZQcm9wKHRhcmdldCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4gICAgdmFyIF9fZXNtID0gKGZuLCByZXMpID0+IGZ1bmN0aW9uIF9faW5pdCgpIHtcbiAgICAgIHJldHVybiBmbiAmJiAocmVzID0gKDAsIGZuW09iamVjdC5rZXlzKGZuKVswXV0pKGZuID0gMCkpLCByZXM7XG4gICAgfTtcbiAgICB2YXIgX19jb21tb25KUzIgPSAoY2IsIG1vZCkgPT4gZnVuY3Rpb24gX19yZXF1aXJlKCkge1xuICAgICAgcmV0dXJuIG1vZCB8fCAoMCwgY2JbT2JqZWN0LmtleXMoY2IpWzBdXSkoKG1vZCA9IHsgZXhwb3J0czoge30gfSkuZXhwb3J0cywgbW9kKSwgbW9kLmV4cG9ydHM7XG4gICAgfTtcbiAgICB2YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgICAgIF9fbWFya0FzTW9kdWxlKHRhcmdldCk7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICAgICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbiAgICB9O1xuICAgIHZhciBfX3JlRXhwb3J0ID0gKHRhcmdldCwgbW9kdWxlMjIsIGRlc2MpID0+IHtcbiAgICAgIGlmIChtb2R1bGUyMiAmJiB0eXBlb2YgbW9kdWxlMjIgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG1vZHVsZTIyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzMihtb2R1bGUyMikpXG4gICAgICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0YXJnZXQsIGtleSkgJiYga2V5ICE9PSBcImRlZmF1bHRcIilcbiAgICAgICAgICAgIF9fZGVmUHJvcCh0YXJnZXQsIGtleSwgeyBnZXQ6ICgpID0+IG1vZHVsZTIyW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MobW9kdWxlMjIsIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfTtcbiAgICB2YXIgX190b01vZHVsZSA9IChtb2R1bGUyMikgPT4ge1xuICAgICAgcmV0dXJuIF9fcmVFeHBvcnQoX19tYXJrQXNNb2R1bGUoX19kZWZQcm9wKG1vZHVsZTIyICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kdWxlMjIpKSA6IHt9LCBcImRlZmF1bHRcIiwgbW9kdWxlMjIgJiYgbW9kdWxlMjIuX19lc01vZHVsZSAmJiBcImRlZmF1bHRcIiBpbiBtb2R1bGUyMiA/IHsgZ2V0OiAoKSA9PiBtb2R1bGUyMi5kZWZhdWx0LCBlbnVtZXJhYmxlOiB0cnVlIH0gOiB7IHZhbHVlOiBtb2R1bGUyMiwgZW51bWVyYWJsZTogdHJ1ZSB9KSksIG1vZHVsZTIyKTtcbiAgICB9O1xuICAgIHZhciByZXF1aXJlX3BvbnlmaWxsX2VzMjAxOCA9IF9fY29tbW9uSlMyKHtcbiAgICAgIFwibm9kZV9tb2R1bGVzL3dlYi1zdHJlYW1zLXBvbHlmaWxsL2Rpc3QvcG9ueWZpbGwuZXMyMDE4LmpzXCIoZXhwb3J0czMsIG1vZHVsZTIyKSB7XG4gICAgICAgIChmdW5jdGlvbihnbG9iYWwyLCBmYWN0b3J5KSB7XG4gICAgICAgICAgdHlwZW9mIGV4cG9ydHMzID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUyMiAhPT0gXCJ1bmRlZmluZWRcIiA/IGZhY3RvcnkoZXhwb3J0czMpIDogdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoW1wiZXhwb3J0c1wiXSwgZmFjdG9yeSkgOiAoZ2xvYmFsMiA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsVGhpcyA6IGdsb2JhbDIgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwyLldlYlN0cmVhbXNQb2x5ZmlsbCA9IHt9KSk7XG4gICAgICAgIH0pKGV4cG9ydHMzLCBmdW5jdGlvbihleHBvcnRzMjIpIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICBjb25zdCBTeW1ib2xQb2x5ZmlsbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gU3ltYm9sIDogKGRlc2NyaXB0aW9uKSA9PiBgU3ltYm9sKCR7ZGVzY3JpcHRpb259KWA7XG4gICAgICAgICAgZnVuY3Rpb24gbm9vcDIoKSB7XG4gICAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBnZXRHbG9iYWxzKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdsb2JhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGdsb2JhbHMgPSBnZXRHbG9iYWxzKCk7XG4gICAgICAgICAgZnVuY3Rpb24gdHlwZUlzT2JqZWN0KHgyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHgyID09PSBcIm9iamVjdFwiICYmIHgyICE9PSBudWxsIHx8IHR5cGVvZiB4MiA9PT0gXCJmdW5jdGlvblwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCByZXRocm93QXNzZXJ0aW9uRXJyb3JSZWplY3Rpb24gPSBub29wMjtcbiAgICAgICAgICBjb25zdCBvcmlnaW5hbFByb21pc2UgPSBQcm9taXNlO1xuICAgICAgICAgIGNvbnN0IG9yaWdpbmFsUHJvbWlzZVRoZW4gPSBQcm9taXNlLnByb3RvdHlwZS50aGVuO1xuICAgICAgICAgIGNvbnN0IG9yaWdpbmFsUHJvbWlzZVJlc29sdmUgPSBQcm9taXNlLnJlc29sdmUuYmluZChvcmlnaW5hbFByb21pc2UpO1xuICAgICAgICAgIGNvbnN0IG9yaWdpbmFsUHJvbWlzZVJlamVjdCA9IFByb21pc2UucmVqZWN0LmJpbmQob3JpZ2luYWxQcm9taXNlKTtcbiAgICAgICAgICBmdW5jdGlvbiBuZXdQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IG9yaWdpbmFsUHJvbWlzZShleGVjdXRvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIHByb21pc2VSZXNvbHZlZFdpdGgodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbFByb21pc2VSZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gcHJvbWlzZVJlamVjdGVkV2l0aChyZWFzb24pIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbFByb21pc2VSZWplY3QocmVhc29uKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gUGVyZm9ybVByb21pc2VUaGVuKHByb21pc2UsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxQcm9taXNlVGhlbi5jYWxsKHByb21pc2UsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gdXBvblByb21pc2UocHJvbWlzZSwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgICAgIFBlcmZvcm1Qcm9taXNlVGhlbihQZXJmb3JtUHJvbWlzZVRoZW4ocHJvbWlzZSwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpLCB2b2lkIDAsIHJldGhyb3dBc3NlcnRpb25FcnJvclJlamVjdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIHVwb25GdWxmaWxsbWVudChwcm9taXNlLCBvbkZ1bGZpbGxlZCkge1xuICAgICAgICAgICAgdXBvblByb21pc2UocHJvbWlzZSwgb25GdWxmaWxsZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiB1cG9uUmVqZWN0aW9uKHByb21pc2UsIG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgICAgIHVwb25Qcm9taXNlKHByb21pc2UsIHZvaWQgMCwgb25SZWplY3RlZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIHRyYW5zZm9ybVByb21pc2VXaXRoKHByb21pc2UsIGZ1bGZpbGxtZW50SGFuZGxlciwgcmVqZWN0aW9uSGFuZGxlcikge1xuICAgICAgICAgICAgcmV0dXJuIFBlcmZvcm1Qcm9taXNlVGhlbihwcm9taXNlLCBmdWxmaWxsbWVudEhhbmRsZXIsIHJlamVjdGlvbkhhbmRsZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBzZXRQcm9taXNlSXNIYW5kbGVkVG9UcnVlKHByb21pc2UpIHtcbiAgICAgICAgICAgIFBlcmZvcm1Qcm9taXNlVGhlbihwcm9taXNlLCB2b2lkIDAsIHJldGhyb3dBc3NlcnRpb25FcnJvclJlamVjdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHF1ZXVlTWljcm90YXNrID0gKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGdsb2JhbFF1ZXVlTWljcm90YXNrID0gZ2xvYmFscyAmJiBnbG9iYWxzLnF1ZXVlTWljcm90YXNrO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBnbG9iYWxRdWV1ZU1pY3JvdGFzayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBnbG9iYWxRdWV1ZU1pY3JvdGFzaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkUHJvbWlzZSA9IHByb21pc2VSZXNvbHZlZFdpdGgodm9pZCAwKTtcbiAgICAgICAgICAgIHJldHVybiAoZm4pID0+IFBlcmZvcm1Qcm9taXNlVGhlbihyZXNvbHZlZFByb21pc2UsIGZuKTtcbiAgICAgICAgICB9KSgpO1xuICAgICAgICAgIGZ1bmN0aW9uIHJlZmxlY3RDYWxsKEYyLCBWLCBhcmdzKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIEYyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50IGlzIG5vdCBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKEYyLCBWLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gcHJvbWlzZUNhbGwoRjIsIFYsIGFyZ3MpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHJlZmxlY3RDYWxsKEYyLCBWLCBhcmdzKSk7XG4gICAgICAgICAgICB9IGNhdGNoICh2YWx1ZSkge1xuICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IFFVRVVFX01BWF9BUlJBWV9TSVpFID0gMTYzODQ7XG4gICAgICAgICAgY2xhc3MgU2ltcGxlUXVldWUge1xuICAgICAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2N1cnNvciA9IDA7XG4gICAgICAgICAgICAgIHRoaXMuX3NpemUgPSAwO1xuICAgICAgICAgICAgICB0aGlzLl9mcm9udCA9IHtcbiAgICAgICAgICAgICAgICBfZWxlbWVudHM6IFtdLFxuICAgICAgICAgICAgICAgIF9uZXh0OiB2b2lkIDBcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgdGhpcy5fYmFjayA9IHRoaXMuX2Zyb250O1xuICAgICAgICAgICAgICB0aGlzLl9jdXJzb3IgPSAwO1xuICAgICAgICAgICAgICB0aGlzLl9zaXplID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHVzaChlbGVtZW50KSB7XG4gICAgICAgICAgICAgIGNvbnN0IG9sZEJhY2sgPSB0aGlzLl9iYWNrO1xuICAgICAgICAgICAgICBsZXQgbmV3QmFjayA9IG9sZEJhY2s7XG4gICAgICAgICAgICAgIGlmIChvbGRCYWNrLl9lbGVtZW50cy5sZW5ndGggPT09IFFVRVVFX01BWF9BUlJBWV9TSVpFIC0gMSkge1xuICAgICAgICAgICAgICAgIG5ld0JhY2sgPSB7XG4gICAgICAgICAgICAgICAgICBfZWxlbWVudHM6IFtdLFxuICAgICAgICAgICAgICAgICAgX25leHQ6IHZvaWQgMFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb2xkQmFjay5fZWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgICAgaWYgKG5ld0JhY2sgIT09IG9sZEJhY2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9iYWNrID0gbmV3QmFjaztcbiAgICAgICAgICAgICAgICBvbGRCYWNrLl9uZXh0ID0gbmV3QmFjaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICArK3RoaXMuX3NpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaGlmdCgpIHtcbiAgICAgICAgICAgICAgY29uc3Qgb2xkRnJvbnQgPSB0aGlzLl9mcm9udDtcbiAgICAgICAgICAgICAgbGV0IG5ld0Zyb250ID0gb2xkRnJvbnQ7XG4gICAgICAgICAgICAgIGNvbnN0IG9sZEN1cnNvciA9IHRoaXMuX2N1cnNvcjtcbiAgICAgICAgICAgICAgbGV0IG5ld0N1cnNvciA9IG9sZEN1cnNvciArIDE7XG4gICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRzID0gb2xkRnJvbnQuX2VsZW1lbnRzO1xuICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbb2xkQ3Vyc29yXTtcbiAgICAgICAgICAgICAgaWYgKG5ld0N1cnNvciA9PT0gUVVFVUVfTUFYX0FSUkFZX1NJWkUpIHtcbiAgICAgICAgICAgICAgICBuZXdGcm9udCA9IG9sZEZyb250Ll9uZXh0O1xuICAgICAgICAgICAgICAgIG5ld0N1cnNvciA9IDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLS10aGlzLl9zaXplO1xuICAgICAgICAgICAgICB0aGlzLl9jdXJzb3IgPSBuZXdDdXJzb3I7XG4gICAgICAgICAgICAgIGlmIChvbGRGcm9udCAhPT0gbmV3RnJvbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mcm9udCA9IG5ld0Zyb250O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsZW1lbnRzW29sZEN1cnNvcl0gPSB2b2lkIDA7XG4gICAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yRWFjaChjYWxsYmFjaykge1xuICAgICAgICAgICAgICBsZXQgaTIgPSB0aGlzLl9jdXJzb3I7XG4gICAgICAgICAgICAgIGxldCBub2RlID0gdGhpcy5fZnJvbnQ7XG4gICAgICAgICAgICAgIGxldCBlbGVtZW50cyA9IG5vZGUuX2VsZW1lbnRzO1xuICAgICAgICAgICAgICB3aGlsZSAoaTIgIT09IGVsZW1lbnRzLmxlbmd0aCB8fCBub2RlLl9uZXh0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICBpZiAoaTIgPT09IGVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuX25leHQ7XG4gICAgICAgICAgICAgICAgICBlbGVtZW50cyA9IG5vZGUuX2VsZW1lbnRzO1xuICAgICAgICAgICAgICAgICAgaTIgPSAwO1xuICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZWxlbWVudHNbaTJdKTtcbiAgICAgICAgICAgICAgICArK2kyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwZWVrKCkge1xuICAgICAgICAgICAgICBjb25zdCBmcm9udCA9IHRoaXMuX2Zyb250O1xuICAgICAgICAgICAgICBjb25zdCBjdXJzb3IgPSB0aGlzLl9jdXJzb3I7XG4gICAgICAgICAgICAgIHJldHVybiBmcm9udC5fZWxlbWVudHNbY3Vyc29yXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljSW5pdGlhbGl6ZShyZWFkZXIsIHN0cmVhbSkge1xuICAgICAgICAgICAgcmVhZGVyLl9vd25lclJlYWRhYmxlU3RyZWFtID0gc3RyZWFtO1xuICAgICAgICAgICAgc3RyZWFtLl9yZWFkZXIgPSByZWFkZXI7XG4gICAgICAgICAgICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gXCJyZWFkYWJsZVwiKSB7XG4gICAgICAgICAgICAgIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZShyZWFkZXIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJlYW0uX3N0YXRlID09PSBcImNsb3NlZFwiKSB7XG4gICAgICAgICAgICAgIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQocmVhZGVyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQocmVhZGVyLCBzdHJlYW0uX3N0b3JlZEVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljQ2FuY2VsKHJlYWRlciwgcmVhc29uKSB7XG4gICAgICAgICAgICBjb25zdCBzdHJlYW0gPSByZWFkZXIuX293bmVyUmVhZGFibGVTdHJlYW07XG4gICAgICAgICAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1DYW5jZWwoc3RyZWFtLCByZWFzb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHJlYWRlcikge1xuICAgICAgICAgICAgaWYgKHJlYWRlci5fb3duZXJSZWFkYWJsZVN0cmVhbS5fc3RhdGUgPT09IFwicmVhZGFibGVcIikge1xuICAgICAgICAgICAgICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlamVjdChyZWFkZXIsIG5ldyBUeXBlRXJyb3IoYFJlYWRlciB3YXMgcmVsZWFzZWQgYW5kIGNhbiBubyBsb25nZXIgYmUgdXNlZCB0byBtb25pdG9yIHRoZSBzdHJlYW0ncyBjbG9zZWRuZXNzYCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZXNldFRvUmVqZWN0ZWQocmVhZGVyLCBuZXcgVHlwZUVycm9yKGBSZWFkZXIgd2FzIHJlbGVhc2VkIGFuZCBjYW4gbm8gbG9uZ2VyIGJlIHVzZWQgdG8gbW9uaXRvciB0aGUgc3RyZWFtJ3MgY2xvc2VkbmVzc2ApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYWRlci5fb3duZXJSZWFkYWJsZVN0cmVhbS5fcmVhZGVyID0gdm9pZCAwO1xuICAgICAgICAgICAgcmVhZGVyLl9vd25lclJlYWRhYmxlU3RyZWFtID0gdm9pZCAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiByZWFkZXJMb2NrRXhjZXB0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IFwiICsgbmFtZSArIFwiIGEgc3RyZWFtIHVzaW5nIGEgcmVsZWFzZWQgcmVhZGVyXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemUocmVhZGVyKSB7XG4gICAgICAgICAgICByZWFkZXIuX2Nsb3NlZFByb21pc2UgPSBuZXdQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgcmVhZGVyLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgICByZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQocmVhZGVyLCByZWFzb24pIHtcbiAgICAgICAgICAgIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZShyZWFkZXIpO1xuICAgICAgICAgICAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZWplY3QocmVhZGVyLCByZWFzb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1Jlc29sdmVkKHJlYWRlcikge1xuICAgICAgICAgICAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VJbml0aWFsaXplKHJlYWRlcik7XG4gICAgICAgICAgICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlc29sdmUocmVhZGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZWplY3QocmVhZGVyLCByZWFzb24pIHtcbiAgICAgICAgICAgIGlmIChyZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0UHJvbWlzZUlzSGFuZGxlZFRvVHJ1ZShyZWFkZXIuX2Nsb3NlZFByb21pc2UpO1xuICAgICAgICAgICAgcmVhZGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdChyZWFzb24pO1xuICAgICAgICAgICAgcmVhZGVyLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUgPSB2b2lkIDA7XG4gICAgICAgICAgICByZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0ID0gdm9pZCAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlc2V0VG9SZWplY3RlZChyZWFkZXIsIHJlYXNvbikge1xuICAgICAgICAgICAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZWplY3RlZChyZWFkZXIsIHJlYXNvbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVzb2x2ZShyZWFkZXIpIHtcbiAgICAgICAgICAgIGlmIChyZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYWRlci5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlKHZvaWQgMCk7XG4gICAgICAgICAgICByZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIHJlYWRlci5fY2xvc2VkUHJvbWlzZV9yZWplY3QgPSB2b2lkIDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IEFib3J0U3RlcHMgPSBTeW1ib2xQb2x5ZmlsbChcIltbQWJvcnRTdGVwc11dXCIpO1xuICAgICAgICAgIGNvbnN0IEVycm9yU3RlcHMgPSBTeW1ib2xQb2x5ZmlsbChcIltbRXJyb3JTdGVwc11dXCIpO1xuICAgICAgICAgIGNvbnN0IENhbmNlbFN0ZXBzID0gU3ltYm9sUG9seWZpbGwoXCJbW0NhbmNlbFN0ZXBzXV1cIik7XG4gICAgICAgICAgY29uc3QgUHVsbFN0ZXBzID0gU3ltYm9sUG9seWZpbGwoXCJbW1B1bGxTdGVwc11dXCIpO1xuICAgICAgICAgIGNvbnN0IE51bWJlcklzRmluaXRlID0gTnVtYmVyLmlzRmluaXRlIHx8IGZ1bmN0aW9uKHgyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHgyID09PSBcIm51bWJlclwiICYmIGlzRmluaXRlKHgyKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IE1hdGhUcnVuYyA9IE1hdGgudHJ1bmMgfHwgZnVuY3Rpb24odikge1xuICAgICAgICAgICAgcmV0dXJuIHYgPCAwID8gTWF0aC5jZWlsKHYpIDogTWF0aC5mbG9vcih2KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGZ1bmN0aW9uIGlzRGljdGlvbmFyeSh4Mikge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB4MiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgeDIgPT09IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gYXNzZXJ0RGljdGlvbmFyeShvYmosIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGlmIChvYmogIT09IHZvaWQgMCAmJiAhaXNEaWN0aW9uYXJ5KG9iaikpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtjb250ZXh0fSBpcyBub3QgYW4gb2JqZWN0LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBhc3NlcnRGdW5jdGlvbih4MiwgY29udGV4dCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB4MiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7Y29udGV4dH0gaXMgbm90IGEgZnVuY3Rpb24uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIGlzT2JqZWN0KHgyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHgyID09PSBcIm9iamVjdFwiICYmIHgyICE9PSBudWxsIHx8IHR5cGVvZiB4MiA9PT0gXCJmdW5jdGlvblwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBhc3NlcnRPYmplY3QoeDIsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGlmICghaXNPYmplY3QoeDIpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7Y29udGV4dH0gaXMgbm90IGFuIG9iamVjdC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gYXNzZXJ0UmVxdWlyZWRBcmd1bWVudCh4MiwgcG9zaXRpb24sIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGlmICh4MiA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFBhcmFtZXRlciAke3Bvc2l0aW9ufSBpcyByZXF1aXJlZCBpbiAnJHtjb250ZXh0fScuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIGFzc2VydFJlcXVpcmVkRmllbGQoeDIsIGZpZWxkLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBpZiAoeDIgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2ZpZWxkfSBpcyByZXF1aXJlZCBpbiAnJHtjb250ZXh0fScuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIGNvbnZlcnRVbnJlc3RyaWN0ZWREb3VibGUodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBjZW5zb3JOZWdhdGl2ZVplcm8oeDIpIHtcbiAgICAgICAgICAgIHJldHVybiB4MiA9PT0gMCA/IDAgOiB4MjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gaW50ZWdlclBhcnQoeDIpIHtcbiAgICAgICAgICAgIHJldHVybiBjZW5zb3JOZWdhdGl2ZVplcm8oTWF0aFRydW5jKHgyKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIGNvbnZlcnRVbnNpZ25lZExvbmdMb25nV2l0aEVuZm9yY2VSYW5nZSh2YWx1ZSwgY29udGV4dCkge1xuICAgICAgICAgICAgY29uc3QgbG93ZXJCb3VuZCA9IDA7XG4gICAgICAgICAgICBjb25zdCB1cHBlckJvdW5kID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgICAgICAgICBsZXQgeDIgPSBOdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgeDIgPSBjZW5zb3JOZWdhdGl2ZVplcm8oeDIpO1xuICAgICAgICAgICAgaWYgKCFOdW1iZXJJc0Zpbml0ZSh4MikpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtjb250ZXh0fSBpcyBub3QgYSBmaW5pdGUgbnVtYmVyYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4MiA9IGludGVnZXJQYXJ0KHgyKTtcbiAgICAgICAgICAgIGlmICh4MiA8IGxvd2VyQm91bmQgfHwgeDIgPiB1cHBlckJvdW5kKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7Y29udGV4dH0gaXMgb3V0c2lkZSB0aGUgYWNjZXB0ZWQgcmFuZ2Ugb2YgJHtsb3dlckJvdW5kfSB0byAke3VwcGVyQm91bmR9LCBpbmNsdXNpdmVgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghTnVtYmVySXNGaW5pdGUoeDIpIHx8IHgyID09PSAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHgyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBhc3NlcnRSZWFkYWJsZVN0cmVhbSh4MiwgY29udGV4dCkge1xuICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtKHgyKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2NvbnRleHR9IGlzIG5vdCBhIFJlYWRhYmxlU3RyZWFtLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBBY3F1aXJlUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHN0cmVhbSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIoc3RyZWFtKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1BZGRSZWFkUmVxdWVzdChzdHJlYW0sIHJlYWRSZXF1ZXN0KSB7XG4gICAgICAgICAgICBzdHJlYW0uX3JlYWRlci5fcmVhZFJlcXVlc3RzLnB1c2gocmVhZFJlcXVlc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUZ1bGZpbGxSZWFkUmVxdWVzdChzdHJlYW0sIGNodW5rLCBkb25lKSB7XG4gICAgICAgICAgICBjb25zdCByZWFkZXIgPSBzdHJlYW0uX3JlYWRlcjtcbiAgICAgICAgICAgIGNvbnN0IHJlYWRSZXF1ZXN0ID0gcmVhZGVyLl9yZWFkUmVxdWVzdHMuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgIHJlYWRSZXF1ZXN0Ll9jbG9zZVN0ZXBzKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWFkUmVxdWVzdC5fY2h1bmtTdGVwcyhjaHVuayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZFJlcXVlc3RzKHN0cmVhbSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmVhbS5fcmVhZGVyLl9yZWFkUmVxdWVzdHMubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUhhc0RlZmF1bHRSZWFkZXIoc3RyZWFtKSB7XG4gICAgICAgICAgICBjb25zdCByZWFkZXIgPSBzdHJlYW0uX3JlYWRlcjtcbiAgICAgICAgICAgIGlmIChyZWFkZXIgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHJlYWRlcikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNsYXNzIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlciB7XG4gICAgICAgICAgICBjb25zdHJ1Y3RvcihzdHJlYW0pIHtcbiAgICAgICAgICAgICAgYXNzZXJ0UmVxdWlyZWRBcmd1bWVudChzdHJlYW0sIDEsIFwiUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyXCIpO1xuICAgICAgICAgICAgICBhc3NlcnRSZWFkYWJsZVN0cmVhbShzdHJlYW0sIFwiRmlyc3QgcGFyYW1ldGVyXCIpO1xuICAgICAgICAgICAgICBpZiAoSXNSZWFkYWJsZVN0cmVhbUxvY2tlZChzdHJlYW0pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoaXMgc3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gbG9ja2VkIGZvciBleGNsdXNpdmUgcmVhZGluZyBieSBhbm90aGVyIHJlYWRlclwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNJbml0aWFsaXplKHRoaXMsIHN0cmVhbSk7XG4gICAgICAgICAgICAgIHRoaXMuX3JlYWRSZXF1ZXN0cyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2V0IGNsb3NlZCgpIHtcbiAgICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcih0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uKFwiY2xvc2VkXCIpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2xvc2VkUHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbmNlbChyZWFzb24gPSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcih0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uKFwiY2FuY2VsXCIpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodGhpcy5fb3duZXJSZWFkYWJsZVN0cmVhbSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgocmVhZGVyTG9ja0V4Y2VwdGlvbihcImNhbmNlbFwiKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY0NhbmNlbCh0aGlzLCByZWFzb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVhZCgpIHtcbiAgICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcih0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uKFwicmVhZFwiKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHRoaXMuX293bmVyUmVhZGFibGVTdHJlYW0gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHJlYWRlckxvY2tFeGNlcHRpb24oXCJyZWFkIGZyb21cIikpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxldCByZXNvbHZlUHJvbWlzZTtcbiAgICAgICAgICAgICAgbGV0IHJlamVjdFByb21pc2U7XG4gICAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXdQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlUHJvbWlzZSA9IHJlc29sdmU7XG4gICAgICAgICAgICAgICAgcmVqZWN0UHJvbWlzZSA9IHJlamVjdDtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGNvbnN0IHJlYWRSZXF1ZXN0ID0ge1xuICAgICAgICAgICAgICAgIF9jaHVua1N0ZXBzOiAoY2h1bmspID0+IHJlc29sdmVQcm9taXNlKHsgdmFsdWU6IGNodW5rLCBkb25lOiBmYWxzZSB9KSxcbiAgICAgICAgICAgICAgICBfY2xvc2VTdGVwczogKCkgPT4gcmVzb2x2ZVByb21pc2UoeyB2YWx1ZTogdm9pZCAwLCBkb25lOiB0cnVlIH0pLFxuICAgICAgICAgICAgICAgIF9lcnJvclN0ZXBzOiAoZTIpID0+IHJlamVjdFByb21pc2UoZTIpXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlclJlYWQodGhpcywgcmVhZFJlcXVlc3QpO1xuICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlbGVhc2VMb2NrKCkge1xuICAgICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZGVmYXVsdFJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24oXCJyZWxlYXNlTG9ja1wiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodGhpcy5fb3duZXJSZWFkYWJsZVN0cmVhbSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9yZWFkUmVxdWVzdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJUcmllZCB0byByZWxlYXNlIGEgcmVhZGVyIGxvY2sgd2hlbiB0aGF0IHJlYWRlciBoYXMgcGVuZGluZyByZWFkKCkgY2FsbHMgdW4tc2V0dGxlZFwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIucHJvdG90eXBlLCB7XG4gICAgICAgICAgICBjYW5jZWw6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICAgICAgcmVhZDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgICAgICByZWxlYXNlTG9jazogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgICAgICBjbG9zZWQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZyA9PT0gXCJzeW1ib2xcIikge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlci5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBcIlJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlclwiLFxuICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcih4Mikge1xuICAgICAgICAgICAgaWYgKCF0eXBlSXNPYmplY3QoeDIpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgyLCBcIl9yZWFkUmVxdWVzdHNcIikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHgyIGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJSZWFkKHJlYWRlciwgcmVhZFJlcXVlc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IHJlYWRlci5fb3duZXJSZWFkYWJsZVN0cmVhbTtcbiAgICAgICAgICAgIHN0cmVhbS5fZGlzdHVyYmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChzdHJlYW0uX3N0YXRlID09PSBcImNsb3NlZFwiKSB7XG4gICAgICAgICAgICAgIHJlYWRSZXF1ZXN0Ll9jbG9zZVN0ZXBzKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5fc3RhdGUgPT09IFwiZXJyb3JlZFwiKSB7XG4gICAgICAgICAgICAgIHJlYWRSZXF1ZXN0Ll9lcnJvclN0ZXBzKHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RyZWFtLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXJbUHVsbFN0ZXBzXShyZWFkUmVxdWVzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIGRlZmF1bHRSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKGBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBBc3luY0l0ZXJhdG9yUHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKE9iamVjdC5nZXRQcm90b3R5cGVPZihhc3luYyBmdW5jdGlvbiogKCkge1xuICAgICAgICAgIH0pLnByb3RvdHlwZSk7XG4gICAgICAgICAgY2xhc3MgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9ySW1wbCB7XG4gICAgICAgICAgICBjb25zdHJ1Y3RvcihyZWFkZXIsIHByZXZlbnRDYW5jZWwpIHtcbiAgICAgICAgICAgICAgdGhpcy5fb25nb2luZ1Byb21pc2UgPSB2b2lkIDA7XG4gICAgICAgICAgICAgIHRoaXMuX2lzRmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgdGhpcy5fcmVhZGVyID0gcmVhZGVyO1xuICAgICAgICAgICAgICB0aGlzLl9wcmV2ZW50Q2FuY2VsID0gcHJldmVudENhbmNlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHQoKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG5leHRTdGVwcyA9ICgpID0+IHRoaXMuX25leHRTdGVwcygpO1xuICAgICAgICAgICAgICB0aGlzLl9vbmdvaW5nUHJvbWlzZSA9IHRoaXMuX29uZ29pbmdQcm9taXNlID8gdHJhbnNmb3JtUHJvbWlzZVdpdGgodGhpcy5fb25nb2luZ1Byb21pc2UsIG5leHRTdGVwcywgbmV4dFN0ZXBzKSA6IG5leHRTdGVwcygpO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fb25nb2luZ1Byb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4odmFsdWUpIHtcbiAgICAgICAgICAgICAgY29uc3QgcmV0dXJuU3RlcHMgPSAoKSA9PiB0aGlzLl9yZXR1cm5TdGVwcyh2YWx1ZSk7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9vbmdvaW5nUHJvbWlzZSA/IHRyYW5zZm9ybVByb21pc2VXaXRoKHRoaXMuX29uZ29pbmdQcm9taXNlLCByZXR1cm5TdGVwcywgcmV0dXJuU3RlcHMpIDogcmV0dXJuU3RlcHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9uZXh0U3RlcHMoKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9pc0ZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IHZhbHVlOiB2b2lkIDAsIGRvbmU6IHRydWUgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgcmVhZGVyID0gdGhpcy5fcmVhZGVyO1xuICAgICAgICAgICAgICBpZiAocmVhZGVyLl9vd25lclJlYWRhYmxlU3RyZWFtID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChyZWFkZXJMb2NrRXhjZXB0aW9uKFwiaXRlcmF0ZVwiKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGV0IHJlc29sdmVQcm9taXNlO1xuICAgICAgICAgICAgICBsZXQgcmVqZWN0UHJvbWlzZTtcbiAgICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ld1Byb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgICAgICByZWplY3RQcm9taXNlID0gcmVqZWN0O1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY29uc3QgcmVhZFJlcXVlc3QgPSB7XG4gICAgICAgICAgICAgICAgX2NodW5rU3RlcHM6IChjaHVuaykgPT4ge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fb25nb2luZ1Byb21pc2UgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiByZXNvbHZlUHJvbWlzZSh7IHZhbHVlOiBjaHVuaywgZG9uZTogZmFsc2UgfSkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgX2Nsb3NlU3RlcHM6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX29uZ29pbmdQcm9taXNlID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgdGhpcy5faXNGaW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHJlYWRlcik7XG4gICAgICAgICAgICAgICAgICByZXNvbHZlUHJvbWlzZSh7IHZhbHVlOiB2b2lkIDAsIGRvbmU6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBfZXJyb3JTdGVwczogKHJlYXNvbikgPT4ge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fb25nb2luZ1Byb21pc2UgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9pc0ZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UocmVhZGVyKTtcbiAgICAgICAgICAgICAgICAgIHJlamVjdFByb21pc2UocmVhc29uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlclJlYWQocmVhZGVyLCByZWFkUmVxdWVzdCk7XG4gICAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3JldHVyblN0ZXBzKHZhbHVlKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9pc0ZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IHZhbHVlLCBkb25lOiB0cnVlIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuX2lzRmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICBjb25zdCByZWFkZXIgPSB0aGlzLl9yZWFkZXI7XG4gICAgICAgICAgICAgIGlmIChyZWFkZXIuX293bmVyUmVhZGFibGVTdHJlYW0gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHJlYWRlckxvY2tFeGNlcHRpb24oXCJmaW5pc2ggaXRlcmF0aW5nXCIpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIXRoaXMuX3ByZXZlbnRDYW5jZWwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNDYW5jZWwocmVhZGVyLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZShyZWFkZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1Qcm9taXNlV2l0aChyZXN1bHQsICgpID0+ICh7IHZhbHVlLCBkb25lOiB0cnVlIH0pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHJlYWRlcik7XG4gICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHsgdmFsdWUsIGRvbmU6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvclByb3RvdHlwZSA9IHtcbiAgICAgICAgICAgIG5leHQoKSB7XG4gICAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IodGhpcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChzdHJlYW1Bc3luY0l0ZXJhdG9yQnJhbmRDaGVja0V4Y2VwdGlvbihcIm5leHRcIikpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hc3luY0l0ZXJhdG9ySW1wbC5uZXh0KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmV0dXJuKHZhbHVlKSB7XG4gICAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IodGhpcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChzdHJlYW1Bc3luY0l0ZXJhdG9yQnJhbmRDaGVja0V4Y2VwdGlvbihcInJldHVyblwiKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FzeW5jSXRlcmF0b3JJbXBsLnJldHVybih2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAoQXN5bmNJdGVyYXRvclByb3RvdHlwZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yUHJvdG90eXBlLCBBc3luY0l0ZXJhdG9yUHJvdG90eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gQWNxdWlyZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcihzdHJlYW0sIHByZXZlbnRDYW5jZWwpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IEFjcXVpcmVSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIoc3RyZWFtKTtcbiAgICAgICAgICAgIGNvbnN0IGltcGwgPSBuZXcgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9ySW1wbChyZWFkZXIsIHByZXZlbnRDYW5jZWwpO1xuICAgICAgICAgICAgY29uc3QgaXRlcmF0b3IgPSBPYmplY3QuY3JlYXRlKFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvclByb3RvdHlwZSk7XG4gICAgICAgICAgICBpdGVyYXRvci5fYXN5bmNJdGVyYXRvckltcGwgPSBpbXBsO1xuICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBJc1JlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcih4Mikge1xuICAgICAgICAgICAgaWYgKCF0eXBlSXNPYmplY3QoeDIpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgyLCBcIl9hc3luY0l0ZXJhdG9ySW1wbFwiKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4geDIuX2FzeW5jSXRlcmF0b3JJbXBsIGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9ySW1wbDtcbiAgICAgICAgICAgIH0gY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gc3RyZWFtQXN5bmNJdGVyYXRvckJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoYFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvci4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBSZWFkYWJsZVN0ZWFtQXN5bmNJdGVyYXRvcmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBOdW1iZXJJc05hTiA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbih4Mikge1xuICAgICAgICAgICAgcmV0dXJuIHgyICE9PSB4MjtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGZ1bmN0aW9uIENyZWF0ZUFycmF5RnJvbUxpc3QoZWxlbWVudHMpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50cy5zbGljZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBDb3B5RGF0YUJsb2NrQnl0ZXMoZGVzdCwgZGVzdE9mZnNldCwgc3JjLCBzcmNPZmZzZXQsIG4pIHtcbiAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KGRlc3QpLnNldChuZXcgVWludDhBcnJheShzcmMsIHNyY09mZnNldCwgbiksIGRlc3RPZmZzZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBUcmFuc2ZlckFycmF5QnVmZmVyKE8pIHtcbiAgICAgICAgICAgIHJldHVybiBPO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBJc0RldGFjaGVkQnVmZmVyKE8pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gQXJyYXlCdWZmZXJTbGljZShidWZmZXIsIGJlZ2luLCBlbmQpIHtcbiAgICAgICAgICAgIGlmIChidWZmZXIuc2xpY2UpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5zbGljZShiZWdpbiwgZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IGVuZCAtIGJlZ2luO1xuICAgICAgICAgICAgY29uc3Qgc2xpY2UgPSBuZXcgQXJyYXlCdWZmZXIobGVuZ3RoKTtcbiAgICAgICAgICAgIENvcHlEYXRhQmxvY2tCeXRlcyhzbGljZSwgMCwgYnVmZmVyLCBiZWdpbiwgbGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiBzbGljZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gSXNOb25OZWdhdGl2ZU51bWJlcih2KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHYgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE51bWJlcklzTmFOKHYpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2IDwgMCkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gQ2xvbmVBc1VpbnQ4QXJyYXkoTykge1xuICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gQXJyYXlCdWZmZXJTbGljZShPLmJ1ZmZlciwgTy5ieXRlT2Zmc2V0LCBPLmJ5dGVPZmZzZXQgKyBPLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIERlcXVldWVWYWx1ZShjb250YWluZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhaXIgPSBjb250YWluZXIuX3F1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICBjb250YWluZXIuX3F1ZXVlVG90YWxTaXplIC09IHBhaXIuc2l6ZTtcbiAgICAgICAgICAgIGlmIChjb250YWluZXIuX3F1ZXVlVG90YWxTaXplIDwgMCkge1xuICAgICAgICAgICAgICBjb250YWluZXIuX3F1ZXVlVG90YWxTaXplID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYWlyLnZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBFbnF1ZXVlVmFsdWVXaXRoU2l6ZShjb250YWluZXIsIHZhbHVlLCBzaXplKSB7XG4gICAgICAgICAgICBpZiAoIUlzTm9uTmVnYXRpdmVOdW1iZXIoc2l6ZSkgfHwgc2l6ZSA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJTaXplIG11c3QgYmUgYSBmaW5pdGUsIG5vbi1OYU4sIG5vbi1uZWdhdGl2ZSBudW1iZXIuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGFpbmVyLl9xdWV1ZS5wdXNoKHsgdmFsdWUsIHNpemUgfSk7XG4gICAgICAgICAgICBjb250YWluZXIuX3F1ZXVlVG90YWxTaXplICs9IHNpemU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFBlZWtRdWV1ZVZhbHVlKGNvbnRhaW5lcikge1xuICAgICAgICAgICAgY29uc3QgcGFpciA9IGNvbnRhaW5lci5fcXVldWUucGVlaygpO1xuICAgICAgICAgICAgcmV0dXJuIHBhaXIudmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFJlc2V0UXVldWUoY29udGFpbmVyKSB7XG4gICAgICAgICAgICBjb250YWluZXIuX3F1ZXVlID0gbmV3IFNpbXBsZVF1ZXVlKCk7XG4gICAgICAgICAgICBjb250YWluZXIuX3F1ZXVlVG90YWxTaXplID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2xhc3MgUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCB7XG4gICAgICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgY29uc3RydWN0b3JcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZXQgdmlldygpIHtcbiAgICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBieW9iUmVxdWVzdEJyYW5kQ2hlY2tFeGNlcHRpb24oXCJ2aWV3XCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl92aWV3O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzcG9uZChieXRlc1dyaXR0ZW4pIHtcbiAgICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBieW9iUmVxdWVzdEJyYW5kQ2hlY2tFeGNlcHRpb24oXCJyZXNwb25kXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGFzc2VydFJlcXVpcmVkQXJndW1lbnQoYnl0ZXNXcml0dGVuLCAxLCBcInJlc3BvbmRcIik7XG4gICAgICAgICAgICAgIGJ5dGVzV3JpdHRlbiA9IGNvbnZlcnRVbnNpZ25lZExvbmdMb25nV2l0aEVuZm9yY2VSYW5nZShieXRlc1dyaXR0ZW4sIFwiRmlyc3QgcGFyYW1ldGVyXCIpO1xuICAgICAgICAgICAgICBpZiAodGhpcy5fYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGlzIEJZT0IgcmVxdWVzdCBoYXMgYmVlbiBpbnZhbGlkYXRlZFwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoSXNEZXRhY2hlZEJ1ZmZlcih0aGlzLl92aWV3LmJ1ZmZlcikpXG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZCh0aGlzLl9hc3NvY2lhdGVkUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciwgYnl0ZXNXcml0dGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3BvbmRXaXRoTmV3Vmlldyh2aWV3KSB7XG4gICAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0KHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYnlvYlJlcXVlc3RCcmFuZENoZWNrRXhjZXB0aW9uKFwicmVzcG9uZFdpdGhOZXdWaWV3XCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGFzc2VydFJlcXVpcmVkQXJndW1lbnQodmlldywgMSwgXCJyZXNwb25kV2l0aE5ld1ZpZXdcIik7XG4gICAgICAgICAgICAgIGlmICghQXJyYXlCdWZmZXIuaXNWaWV3KHZpZXcpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIllvdSBjYW4gb25seSByZXNwb25kIHdpdGggYXJyYXkgYnVmZmVyIHZpZXdzXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9hc3NvY2lhdGVkUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoaXMgQllPQiByZXF1ZXN0IGhhcyBiZWVuIGludmFsaWRhdGVkXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChJc0RldGFjaGVkQnVmZmVyKHZpZXcuYnVmZmVyKSlcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kV2l0aE5ld1ZpZXcodGhpcy5fYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIsIHZpZXcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0LnByb3RvdHlwZSwge1xuICAgICAgICAgICAgcmVzcG9uZDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgICAgICByZXNwb25kV2l0aE5ld1ZpZXc6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICAgICAgdmlldzogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAodHlwZW9mIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnID09PSBcInN5bWJvbFwiKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdC5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBcIlJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3RcIixcbiAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2xhc3MgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciB7XG4gICAgICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgY29uc3RydWN0b3JcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZXQgYnlvYlJlcXVlc3QoKSB7XG4gICAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYnl0ZVN0cmVhbUNvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKFwiYnlvYlJlcXVlc3RcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJHZXRCWU9CUmVxdWVzdCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdldCBkZXNpcmVkU2l6ZSgpIHtcbiAgICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBieXRlU3RyZWFtQ29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oXCJkZXNpcmVkU2l6ZVwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckdldERlc2lyZWRTaXplKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xvc2UoKSB7XG4gICAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYnl0ZVN0cmVhbUNvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKFwiY2xvc2VcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHRoaXMuX2Nsb3NlUmVxdWVzdGVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBzdHJlYW0gaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQ7IGRvIG5vdCBjbG9zZSBpdCBhZ2FpbiFcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtLl9zdGF0ZTtcbiAgICAgICAgICAgICAgaWYgKHN0YXRlICE9PSBcInJlYWRhYmxlXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgc3RyZWFtIChpbiAke3N0YXRlfSBzdGF0ZSkgaXMgbm90IGluIHRoZSByZWFkYWJsZSBzdGF0ZSBhbmQgY2Fubm90IGJlIGNsb3NlZGApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbG9zZSh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVucXVldWUoY2h1bmspIHtcbiAgICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBieXRlU3RyZWFtQ29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oXCJlbnF1ZXVlXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGFzc2VydFJlcXVpcmVkQXJndW1lbnQoY2h1bmssIDEsIFwiZW5xdWV1ZVwiKTtcbiAgICAgICAgICAgICAgaWYgKCFBcnJheUJ1ZmZlci5pc1ZpZXcoY2h1bmspKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNodW5rIG11c3QgYmUgYW4gYXJyYXkgYnVmZmVyIHZpZXdcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGNodW5rLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2h1bmsgbXVzdCBoYXZlIG5vbi16ZXJvIGJ5dGVMZW5ndGhcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGNodW5rLmJ1ZmZlci5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgY2h1bmsncyBidWZmZXIgbXVzdCBoYXZlIG5vbi16ZXJvIGJ5dGVMZW5ndGhgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodGhpcy5fY2xvc2VSZXF1ZXN0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwic3RyZWFtIGlzIGNsb3NlZCBvciBkcmFpbmluZ1wiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0uX3N0YXRlO1xuICAgICAgICAgICAgICBpZiAoc3RhdGUgIT09IFwicmVhZGFibGVcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBzdHJlYW0gKGluICR7c3RhdGV9IHN0YXRlKSBpcyBub3QgaW4gdGhlIHJlYWRhYmxlIHN0YXRlIGFuZCBjYW5ub3QgYmUgZW5xdWV1ZWQgdG9gKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZSh0aGlzLCBjaHVuayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcnJvcihlMiA9IHZvaWQgMCkge1xuICAgICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcih0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGJ5dGVTdHJlYW1Db250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbihcImVycm9yXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcih0aGlzLCBlMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBbQ2FuY2VsU3RlcHNdKHJlYXNvbikge1xuICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xlYXJQZW5kaW5nUHVsbEludG9zKHRoaXMpO1xuICAgICAgICAgICAgICBSZXNldFF1ZXVlKHRoaXMpO1xuICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9jYW5jZWxBbGdvcml0aG0ocmVhc29uKTtcbiAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyh0aGlzKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFtQdWxsU3RlcHNdKHJlYWRSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IHRoaXMuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW07XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9xdWV1ZVRvdGFsU2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbnRyeSA9IHRoaXMuX3F1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcXVldWVUb3RhbFNpemUgLT0gZW50cnkuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVySGFuZGxlUXVldWVEcmFpbih0aGlzKTtcbiAgICAgICAgICAgICAgICBjb25zdCB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoZW50cnkuYnVmZmVyLCBlbnRyeS5ieXRlT2Zmc2V0LCBlbnRyeS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICByZWFkUmVxdWVzdC5fY2h1bmtTdGVwcyh2aWV3KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgYXV0b0FsbG9jYXRlQ2h1bmtTaXplID0gdGhpcy5fYXV0b0FsbG9jYXRlQ2h1bmtTaXplO1xuICAgICAgICAgICAgICBpZiAoYXV0b0FsbG9jYXRlQ2h1bmtTaXplICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICBsZXQgYnVmZmVyO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYXV0b0FsbG9jYXRlQ2h1bmtTaXplKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChidWZmZXJFKSB7XG4gICAgICAgICAgICAgICAgICByZWFkUmVxdWVzdC5fZXJyb3JTdGVwcyhidWZmZXJFKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcHVsbEludG9EZXNjcmlwdG9yID0ge1xuICAgICAgICAgICAgICAgICAgYnVmZmVyLFxuICAgICAgICAgICAgICAgICAgYnVmZmVyQnl0ZUxlbmd0aDogYXV0b0FsbG9jYXRlQ2h1bmtTaXplLFxuICAgICAgICAgICAgICAgICAgYnl0ZU9mZnNldDogMCxcbiAgICAgICAgICAgICAgICAgIGJ5dGVMZW5ndGg6IGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSxcbiAgICAgICAgICAgICAgICAgIGJ5dGVzRmlsbGVkOiAwLFxuICAgICAgICAgICAgICAgICAgZWxlbWVudFNpemU6IDEsXG4gICAgICAgICAgICAgICAgICB2aWV3Q29uc3RydWN0b3I6IFVpbnQ4QXJyYXksXG4gICAgICAgICAgICAgICAgICByZWFkZXJUeXBlOiBcImRlZmF1bHRcIlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5fcGVuZGluZ1B1bGxJbnRvcy5wdXNoKHB1bGxJbnRvRGVzY3JpcHRvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1BZGRSZWFkUmVxdWVzdChzdHJlYW0sIHJlYWRSZXF1ZXN0KTtcbiAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLCB7XG4gICAgICAgICAgICBjbG9zZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgICAgICBlbnF1ZXVlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgICAgIGVycm9yOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgICAgIGJ5b2JSZXF1ZXN0OiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgICAgIGRlc2lyZWRTaXplOiB7IGVudW1lcmFibGU6IHRydWUgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICh0eXBlb2YgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcgPT09IFwic3ltYm9sXCIpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZSwgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IFwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclwiLFxuICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBJc1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIoeDIpIHtcbiAgICAgICAgICAgIGlmICghdHlwZUlzT2JqZWN0KHgyKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4MiwgXCJfY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbVwiKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geDIgaW5zdGFuY2VvZiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBJc1JlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QoeDIpIHtcbiAgICAgICAgICAgIGlmICghdHlwZUlzT2JqZWN0KHgyKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4MiwgXCJfYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJcIikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHgyIGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcikge1xuICAgICAgICAgICAgY29uc3Qgc2hvdWxkUHVsbCA9IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJTaG91bGRDYWxsUHVsbChjb250cm9sbGVyKTtcbiAgICAgICAgICAgIGlmICghc2hvdWxkUHVsbCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29udHJvbGxlci5fcHVsbGluZykge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLl9wdWxsQWdhaW4gPSB0cnVlO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250cm9sbGVyLl9wdWxsaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IHB1bGxQcm9taXNlID0gY29udHJvbGxlci5fcHVsbEFsZ29yaXRobSgpO1xuICAgICAgICAgICAgdXBvblByb21pc2UocHVsbFByb21pc2UsICgpID0+IHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5fcHVsbGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICBpZiAoY29udHJvbGxlci5fcHVsbEFnYWluKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5fcHVsbEFnYWluID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIChlMikgPT4ge1xuICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgZTIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhclBlbmRpbmdQdWxsSW50b3MoY29udHJvbGxlcikge1xuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckludmFsaWRhdGVCWU9CUmVxdWVzdChjb250cm9sbGVyKTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MgPSBuZXcgU2ltcGxlUXVldWUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNvbW1pdFB1bGxJbnRvRGVzY3JpcHRvcihzdHJlYW0sIHB1bGxJbnRvRGVzY3JpcHRvcikge1xuICAgICAgICAgICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChzdHJlYW0uX3N0YXRlID09PSBcImNsb3NlZFwiKSB7XG4gICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZmlsbGVkVmlldyA9IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDb252ZXJ0UHVsbEludG9EZXNjcmlwdG9yKHB1bGxJbnRvRGVzY3JpcHRvcik7XG4gICAgICAgICAgICBpZiAocHVsbEludG9EZXNjcmlwdG9yLnJlYWRlclR5cGUgPT09IFwiZGVmYXVsdFwiKSB7XG4gICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRnVsZmlsbFJlYWRSZXF1ZXN0KHN0cmVhbSwgZmlsbGVkVmlldywgZG9uZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbUZ1bGZpbGxSZWFkSW50b1JlcXVlc3Qoc3RyZWFtLCBmaWxsZWRWaWV3LCBkb25lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNvbnZlcnRQdWxsSW50b0Rlc2NyaXB0b3IocHVsbEludG9EZXNjcmlwdG9yKSB7XG4gICAgICAgICAgICBjb25zdCBieXRlc0ZpbGxlZCA9IHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZDtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRTaXplID0gcHVsbEludG9EZXNjcmlwdG9yLmVsZW1lbnRTaXplO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBwdWxsSW50b0Rlc2NyaXB0b3Iudmlld0NvbnN0cnVjdG9yKHB1bGxJbnRvRGVzY3JpcHRvci5idWZmZXIsIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlT2Zmc2V0LCBieXRlc0ZpbGxlZCAvIGVsZW1lbnRTaXplKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWVDaHVua1RvUXVldWUoY29udHJvbGxlciwgYnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLl9xdWV1ZS5wdXNoKHsgYnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoIH0pO1xuICAgICAgICAgICAgY29udHJvbGxlci5fcXVldWVUb3RhbFNpemUgKz0gYnl0ZUxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckZpbGxQdWxsSW50b0Rlc2NyaXB0b3JGcm9tUXVldWUoY29udHJvbGxlciwgcHVsbEludG9EZXNjcmlwdG9yKSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50U2l6ZSA9IHB1bGxJbnRvRGVzY3JpcHRvci5lbGVtZW50U2l6ZTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRBbGlnbmVkQnl0ZXMgPSBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQgLSBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQgJSBlbGVtZW50U2l6ZTtcbiAgICAgICAgICAgIGNvbnN0IG1heEJ5dGVzVG9Db3B5ID0gTWF0aC5taW4oY29udHJvbGxlci5fcXVldWVUb3RhbFNpemUsIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlTGVuZ3RoIC0gcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkKTtcbiAgICAgICAgICAgIGNvbnN0IG1heEJ5dGVzRmlsbGVkID0gcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkICsgbWF4Qnl0ZXNUb0NvcHk7XG4gICAgICAgICAgICBjb25zdCBtYXhBbGlnbmVkQnl0ZXMgPSBtYXhCeXRlc0ZpbGxlZCAtIG1heEJ5dGVzRmlsbGVkICUgZWxlbWVudFNpemU7XG4gICAgICAgICAgICBsZXQgdG90YWxCeXRlc1RvQ29weVJlbWFpbmluZyA9IG1heEJ5dGVzVG9Db3B5O1xuICAgICAgICAgICAgbGV0IHJlYWR5ID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAobWF4QWxpZ25lZEJ5dGVzID4gY3VycmVudEFsaWduZWRCeXRlcykge1xuICAgICAgICAgICAgICB0b3RhbEJ5dGVzVG9Db3B5UmVtYWluaW5nID0gbWF4QWxpZ25lZEJ5dGVzIC0gcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkO1xuICAgICAgICAgICAgICByZWFkeSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWV1ZSA9IGNvbnRyb2xsZXIuX3F1ZXVlO1xuICAgICAgICAgICAgd2hpbGUgKHRvdGFsQnl0ZXNUb0NvcHlSZW1haW5pbmcgPiAwKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGhlYWRPZlF1ZXVlID0gcXVldWUucGVlaygpO1xuICAgICAgICAgICAgICBjb25zdCBieXRlc1RvQ29weSA9IE1hdGgubWluKHRvdGFsQnl0ZXNUb0NvcHlSZW1haW5pbmcsIGhlYWRPZlF1ZXVlLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgICBjb25zdCBkZXN0U3RhcnQgPSBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZU9mZnNldCArIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZDtcbiAgICAgICAgICAgICAgQ29weURhdGFCbG9ja0J5dGVzKHB1bGxJbnRvRGVzY3JpcHRvci5idWZmZXIsIGRlc3RTdGFydCwgaGVhZE9mUXVldWUuYnVmZmVyLCBoZWFkT2ZRdWV1ZS5ieXRlT2Zmc2V0LCBieXRlc1RvQ29weSk7XG4gICAgICAgICAgICAgIGlmIChoZWFkT2ZRdWV1ZS5ieXRlTGVuZ3RoID09PSBieXRlc1RvQ29weSkge1xuICAgICAgICAgICAgICAgIHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaGVhZE9mUXVldWUuYnl0ZU9mZnNldCArPSBieXRlc1RvQ29weTtcbiAgICAgICAgICAgICAgICBoZWFkT2ZRdWV1ZS5ieXRlTGVuZ3RoIC09IGJ5dGVzVG9Db3B5O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplIC09IGJ5dGVzVG9Db3B5O1xuICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRmlsbEhlYWRQdWxsSW50b0Rlc2NyaXB0b3IoY29udHJvbGxlciwgYnl0ZXNUb0NvcHksIHB1bGxJbnRvRGVzY3JpcHRvcik7XG4gICAgICAgICAgICAgIHRvdGFsQnl0ZXNUb0NvcHlSZW1haW5pbmcgLT0gYnl0ZXNUb0NvcHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVhZHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGaWxsSGVhZFB1bGxJbnRvRGVzY3JpcHRvcihjb250cm9sbGVyLCBzaXplLCBwdWxsSW50b0Rlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZCArPSBzaXplO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVySGFuZGxlUXVldWVEcmFpbihjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBpZiAoY29udHJvbGxlci5fcXVldWVUb3RhbFNpemUgPT09IDAgJiYgY29udHJvbGxlci5fY2xvc2VSZXF1ZXN0ZWQpIHtcbiAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKTtcbiAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1DbG9zZShjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVySW52YWxpZGF0ZUJZT0JSZXF1ZXN0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGlmIChjb250cm9sbGVyLl9ieW9iUmVxdWVzdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250cm9sbGVyLl9ieW9iUmVxdWVzdC5fYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgICAgICAgICBjb250cm9sbGVyLl9ieW9iUmVxdWVzdC5fdmlldyA9IG51bGw7XG4gICAgICAgICAgICBjb250cm9sbGVyLl9ieW9iUmVxdWVzdCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJQcm9jZXNzUHVsbEludG9EZXNjcmlwdG9yc1VzaW5nUXVldWUoY29udHJvbGxlcikge1xuICAgICAgICAgICAgd2hpbGUgKGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBpZiAoY29udHJvbGxlci5fcXVldWVUb3RhbFNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgcHVsbEludG9EZXNjcmlwdG9yID0gY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5wZWVrKCk7XG4gICAgICAgICAgICAgIGlmIChSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRmlsbFB1bGxJbnRvRGVzY3JpcHRvckZyb21RdWV1ZShjb250cm9sbGVyLCBwdWxsSW50b0Rlc2NyaXB0b3IpKSB7XG4gICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclNoaWZ0UGVuZGluZ1B1bGxJbnRvKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDb21taXRQdWxsSW50b0Rlc2NyaXB0b3IoY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbSwgcHVsbEludG9EZXNjcmlwdG9yKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUHVsbEludG8oY29udHJvbGxlciwgdmlldywgcmVhZEludG9SZXF1ZXN0KSB7XG4gICAgICAgICAgICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtO1xuICAgICAgICAgICAgbGV0IGVsZW1lbnRTaXplID0gMTtcbiAgICAgICAgICAgIGlmICh2aWV3LmNvbnN0cnVjdG9yICE9PSBEYXRhVmlldykge1xuICAgICAgICAgICAgICBlbGVtZW50U2l6ZSA9IHZpZXcuY29uc3RydWN0b3IuQllURVNfUEVSX0VMRU1FTlQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjdG9yID0gdmlldy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IFRyYW5zZmVyQXJyYXlCdWZmZXIodmlldy5idWZmZXIpO1xuICAgICAgICAgICAgY29uc3QgcHVsbEludG9EZXNjcmlwdG9yID0ge1xuICAgICAgICAgICAgICBidWZmZXIsXG4gICAgICAgICAgICAgIGJ1ZmZlckJ5dGVMZW5ndGg6IGJ1ZmZlci5ieXRlTGVuZ3RoLFxuICAgICAgICAgICAgICBieXRlT2Zmc2V0OiB2aWV3LmJ5dGVPZmZzZXQsXG4gICAgICAgICAgICAgIGJ5dGVMZW5ndGg6IHZpZXcuYnl0ZUxlbmd0aCxcbiAgICAgICAgICAgICAgYnl0ZXNGaWxsZWQ6IDAsXG4gICAgICAgICAgICAgIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgICB2aWV3Q29uc3RydWN0b3I6IGN0b3IsXG4gICAgICAgICAgICAgIHJlYWRlclR5cGU6IFwiYnlvYlwiXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnB1c2gocHVsbEludG9EZXNjcmlwdG9yKTtcbiAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1BZGRSZWFkSW50b1JlcXVlc3Qoc3RyZWFtLCByZWFkSW50b1JlcXVlc3QpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gXCJjbG9zZWRcIikge1xuICAgICAgICAgICAgICBjb25zdCBlbXB0eVZpZXcgPSBuZXcgY3RvcihwdWxsSW50b0Rlc2NyaXB0b3IuYnVmZmVyLCBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZU9mZnNldCwgMCk7XG4gICAgICAgICAgICAgIHJlYWRJbnRvUmVxdWVzdC5fY2xvc2VTdGVwcyhlbXB0eVZpZXcpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29udHJvbGxlci5fcXVldWVUb3RhbFNpemUgPiAwKSB7XG4gICAgICAgICAgICAgIGlmIChSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRmlsbFB1bGxJbnRvRGVzY3JpcHRvckZyb21RdWV1ZShjb250cm9sbGVyLCBwdWxsSW50b0Rlc2NyaXB0b3IpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsbGVkVmlldyA9IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDb252ZXJ0UHVsbEludG9EZXNjcmlwdG9yKHB1bGxJbnRvRGVzY3JpcHRvcik7XG4gICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckhhbmRsZVF1ZXVlRHJhaW4oY29udHJvbGxlcik7XG4gICAgICAgICAgICAgICAgcmVhZEludG9SZXF1ZXN0Ll9jaHVua1N0ZXBzKGZpbGxlZFZpZXcpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY29udHJvbGxlci5fY2xvc2VSZXF1ZXN0ZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlMiA9IG5ldyBUeXBlRXJyb3IoXCJJbnN1ZmZpY2llbnQgYnl0ZXMgdG8gZmlsbCBlbGVtZW50cyBpbiB0aGUgZ2l2ZW4gYnVmZmVyXCIpO1xuICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBlMik7XG4gICAgICAgICAgICAgICAgcmVhZEludG9SZXF1ZXN0Ll9lcnJvclN0ZXBzKGUyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MucHVzaChwdWxsSW50b0Rlc2NyaXB0b3IpO1xuICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1BZGRSZWFkSW50b1JlcXVlc3Qoc3RyZWFtLCByZWFkSW50b1JlcXVlc3QpO1xuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kSW5DbG9zZWRTdGF0ZShjb250cm9sbGVyLCBmaXJzdERlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW07XG4gICAgICAgICAgICBpZiAoUmVhZGFibGVTdHJlYW1IYXNCWU9CUmVhZGVyKHN0cmVhbSkpIHtcbiAgICAgICAgICAgICAgd2hpbGUgKFJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZEludG9SZXF1ZXN0cyhzdHJlYW0pID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHB1bGxJbnRvRGVzY3JpcHRvciA9IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJTaGlmdFBlbmRpbmdQdWxsSW50byhjb250cm9sbGVyKTtcbiAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ29tbWl0UHVsbEludG9EZXNjcmlwdG9yKHN0cmVhbSwgcHVsbEludG9EZXNjcmlwdG9yKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZEluUmVhZGFibGVTdGF0ZShjb250cm9sbGVyLCBieXRlc1dyaXR0ZW4sIHB1bGxJbnRvRGVzY3JpcHRvcikge1xuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckZpbGxIZWFkUHVsbEludG9EZXNjcmlwdG9yKGNvbnRyb2xsZXIsIGJ5dGVzV3JpdHRlbiwgcHVsbEludG9EZXNjcmlwdG9yKTtcbiAgICAgICAgICAgIGlmIChwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQgPCBwdWxsSW50b0Rlc2NyaXB0b3IuZWxlbWVudFNpemUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclNoaWZ0UGVuZGluZ1B1bGxJbnRvKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgY29uc3QgcmVtYWluZGVyU2l6ZSA9IHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZCAlIHB1bGxJbnRvRGVzY3JpcHRvci5lbGVtZW50U2l6ZTtcbiAgICAgICAgICAgIGlmIChyZW1haW5kZXJTaXplID4gMCkge1xuICAgICAgICAgICAgICBjb25zdCBlbmQgPSBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZU9mZnNldCArIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZDtcbiAgICAgICAgICAgICAgY29uc3QgcmVtYWluZGVyID0gQXJyYXlCdWZmZXJTbGljZShwdWxsSW50b0Rlc2NyaXB0b3IuYnVmZmVyLCBlbmQgLSByZW1haW5kZXJTaXplLCBlbmQpO1xuICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZUNodW5rVG9RdWV1ZShjb250cm9sbGVyLCByZW1haW5kZXIsIDAsIHJlbWFpbmRlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZCAtPSByZW1haW5kZXJTaXplO1xuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNvbW1pdFB1bGxJbnRvRGVzY3JpcHRvcihjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtLCBwdWxsSW50b0Rlc2NyaXB0b3IpO1xuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclByb2Nlc3NQdWxsSW50b0Rlc2NyaXB0b3JzVXNpbmdRdWV1ZShjb250cm9sbGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRJbnRlcm5hbChjb250cm9sbGVyLCBieXRlc1dyaXR0ZW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0RGVzY3JpcHRvciA9IGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MucGVlaygpO1xuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckludmFsaWRhdGVCWU9CUmVxdWVzdChjb250cm9sbGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbS5fc3RhdGU7XG4gICAgICAgICAgICBpZiAoc3RhdGUgPT09IFwiY2xvc2VkXCIpIHtcbiAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRJbkNsb3NlZFN0YXRlKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRJblJlYWRhYmxlU3RhdGUoY29udHJvbGxlciwgYnl0ZXNXcml0dGVuLCBmaXJzdERlc2NyaXB0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJTaGlmdFBlbmRpbmdQdWxsSW50byhjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5zaGlmdCgpO1xuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3I7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJTaG91bGRDYWxsUHVsbChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtO1xuICAgICAgICAgICAgaWYgKHN0cmVhbS5fc3RhdGUgIT09IFwicmVhZGFibGVcIikge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29udHJvbGxlci5fY2xvc2VSZXF1ZXN0ZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjb250cm9sbGVyLl9zdGFydGVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChSZWFkYWJsZVN0cmVhbUhhc0RlZmF1bHRSZWFkZXIoc3RyZWFtKSAmJiBSZWFkYWJsZVN0cmVhbUdldE51bVJlYWRSZXF1ZXN0cyhzdHJlYW0pID4gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChSZWFkYWJsZVN0cmVhbUhhc0JZT0JSZWFkZXIoc3RyZWFtKSAmJiBSZWFkYWJsZVN0cmVhbUdldE51bVJlYWRJbnRvUmVxdWVzdHMoc3RyZWFtKSA+IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkZXNpcmVkU2l6ZSA9IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZShjb250cm9sbGVyKTtcbiAgICAgICAgICAgIGlmIChkZXNpcmVkU2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcikge1xuICAgICAgICAgICAgY29udHJvbGxlci5fcHVsbEFsZ29yaXRobSA9IHZvaWQgMDtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuX2NhbmNlbEFsZ29yaXRobSA9IHZvaWQgMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsb3NlKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW07XG4gICAgICAgICAgICBpZiAoY29udHJvbGxlci5fY2xvc2VSZXF1ZXN0ZWQgfHwgc3RyZWFtLl9zdGF0ZSAhPT0gXCJyZWFkYWJsZVwiKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5fY2xvc2VSZXF1ZXN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGZpcnN0UGVuZGluZ1B1bGxJbnRvID0gY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5wZWVrKCk7XG4gICAgICAgICAgICAgIGlmIChmaXJzdFBlbmRpbmdQdWxsSW50by5ieXRlc0ZpbGxlZCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlMiA9IG5ldyBUeXBlRXJyb3IoXCJJbnN1ZmZpY2llbnQgYnl0ZXMgdG8gZmlsbCBlbGVtZW50cyBpbiB0aGUgZ2l2ZW4gYnVmZmVyXCIpO1xuICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBlMik7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcik7XG4gICAgICAgICAgICBSZWFkYWJsZVN0cmVhbUNsb3NlKHN0cmVhbSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlKGNvbnRyb2xsZXIsIGNodW5rKSB7XG4gICAgICAgICAgICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtO1xuICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIuX2Nsb3NlUmVxdWVzdGVkIHx8IHN0cmVhbS5fc3RhdGUgIT09IFwicmVhZGFibGVcIikge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBidWZmZXIgPSBjaHVuay5idWZmZXI7XG4gICAgICAgICAgICBjb25zdCBieXRlT2Zmc2V0ID0gY2h1bmsuYnl0ZU9mZnNldDtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVMZW5ndGggPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNmZXJyZWRCdWZmZXIgPSBUcmFuc2ZlckFycmF5QnVmZmVyKGJ1ZmZlcik7XG4gICAgICAgICAgICBpZiAoY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGZpcnN0UGVuZGluZ1B1bGxJbnRvID0gY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5wZWVrKCk7XG4gICAgICAgICAgICAgIGlmIChJc0RldGFjaGVkQnVmZmVyKGZpcnN0UGVuZGluZ1B1bGxJbnRvLmJ1ZmZlcikpXG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICBmaXJzdFBlbmRpbmdQdWxsSW50by5idWZmZXIgPSBUcmFuc2ZlckFycmF5QnVmZmVyKGZpcnN0UGVuZGluZ1B1bGxJbnRvLmJ1ZmZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVySW52YWxpZGF0ZUJZT0JSZXF1ZXN0KGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgaWYgKFJlYWRhYmxlU3RyZWFtSGFzRGVmYXVsdFJlYWRlcihzdHJlYW0pKSB7XG4gICAgICAgICAgICAgIGlmIChSZWFkYWJsZVN0cmVhbUdldE51bVJlYWRSZXF1ZXN0cyhzdHJlYW0pID09PSAwKSB7XG4gICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWVDaHVua1RvUXVldWUoY29udHJvbGxlciwgdHJhbnNmZXJyZWRCdWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJTaGlmdFBlbmRpbmdQdWxsSW50byhjb250cm9sbGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNmZXJyZWRWaWV3ID0gbmV3IFVpbnQ4QXJyYXkodHJhbnNmZXJyZWRCdWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRnVsZmlsbFJlYWRSZXF1ZXN0KHN0cmVhbSwgdHJhbnNmZXJyZWRWaWV3LCBmYWxzZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoUmVhZGFibGVTdHJlYW1IYXNCWU9CUmVhZGVyKHN0cmVhbSkpIHtcbiAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWVDaHVua1RvUXVldWUoY29udHJvbGxlciwgdHJhbnNmZXJyZWRCdWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUHJvY2Vzc1B1bGxJbnRvRGVzY3JpcHRvcnNVc2luZ1F1ZXVlKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWVDaHVua1RvUXVldWUoY29udHJvbGxlciwgdHJhbnNmZXJyZWRCdWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBlMikge1xuICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbTtcbiAgICAgICAgICAgIGlmIChzdHJlYW0uX3N0YXRlICE9PSBcInJlYWRhYmxlXCIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsZWFyUGVuZGluZ1B1bGxJbnRvcyhjb250cm9sbGVyKTtcbiAgICAgICAgICAgIFJlc2V0UXVldWUoY29udHJvbGxlcik7XG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1FcnJvcihzdHJlYW0sIGUyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckdldEJZT0JSZXF1ZXN0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGlmIChjb250cm9sbGVyLl9ieW9iUmVxdWVzdCA9PT0gbnVsbCAmJiBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgY29uc3QgZmlyc3REZXNjcmlwdG9yID0gY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5wZWVrKCk7XG4gICAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgVWludDhBcnJheShmaXJzdERlc2NyaXB0b3IuYnVmZmVyLCBmaXJzdERlc2NyaXB0b3IuYnl0ZU9mZnNldCArIGZpcnN0RGVzY3JpcHRvci5ieXRlc0ZpbGxlZCwgZmlyc3REZXNjcmlwdG9yLmJ5dGVMZW5ndGggLSBmaXJzdERlc2NyaXB0b3IuYnl0ZXNGaWxsZWQpO1xuICAgICAgICAgICAgICBjb25zdCBieW9iUmVxdWVzdCA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdC5wcm90b3R5cGUpO1xuICAgICAgICAgICAgICBTZXRVcFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QoYnlvYlJlcXVlc3QsIGNvbnRyb2xsZXIsIHZpZXcpO1xuICAgICAgICAgICAgICBjb250cm9sbGVyLl9ieW9iUmVxdWVzdCA9IGJ5b2JSZXF1ZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuX2J5b2JSZXF1ZXN0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyR2V0RGVzaXJlZFNpemUoY29udHJvbGxlcikge1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtLl9zdGF0ZTtcbiAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gXCJlcnJvcmVkXCIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUgPT09IFwiY2xvc2VkXCIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29udHJvbGxlci5fc3RyYXRlZ3lIV00gLSBjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmQoY29udHJvbGxlciwgYnl0ZXNXcml0dGVuKSB7XG4gICAgICAgICAgICBjb25zdCBmaXJzdERlc2NyaXB0b3IgPSBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnBlZWsoKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbS5fc3RhdGU7XG4gICAgICAgICAgICBpZiAoc3RhdGUgPT09IFwiY2xvc2VkXCIpIHtcbiAgICAgICAgICAgICAgaWYgKGJ5dGVzV3JpdHRlbiAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJieXRlc1dyaXR0ZW4gbXVzdCBiZSAwIHdoZW4gY2FsbGluZyByZXNwb25kKCkgb24gYSBjbG9zZWQgc3RyZWFtXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoYnl0ZXNXcml0dGVuID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImJ5dGVzV3JpdHRlbiBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwIHdoZW4gY2FsbGluZyByZXNwb25kKCkgb24gYSByZWFkYWJsZSBzdHJlYW1cIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGZpcnN0RGVzY3JpcHRvci5ieXRlc0ZpbGxlZCArIGJ5dGVzV3JpdHRlbiA+IGZpcnN0RGVzY3JpcHRvci5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJieXRlc1dyaXR0ZW4gb3V0IG9mIHJhbmdlXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaXJzdERlc2NyaXB0b3IuYnVmZmVyID0gVHJhbnNmZXJBcnJheUJ1ZmZlcihmaXJzdERlc2NyaXB0b3IuYnVmZmVyKTtcbiAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kSW50ZXJuYWwoY29udHJvbGxlciwgYnl0ZXNXcml0dGVuKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRXaXRoTmV3Vmlldyhjb250cm9sbGVyLCB2aWV3KSB7XG4gICAgICAgICAgICBjb25zdCBmaXJzdERlc2NyaXB0b3IgPSBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnBlZWsoKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbS5fc3RhdGU7XG4gICAgICAgICAgICBpZiAoc3RhdGUgPT09IFwiY2xvc2VkXCIpIHtcbiAgICAgICAgICAgICAgaWYgKHZpZXcuYnl0ZUxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgdmlldydzIGxlbmd0aCBtdXN0IGJlIDAgd2hlbiBjYWxsaW5nIHJlc3BvbmRXaXRoTmV3VmlldygpIG9uIGEgY2xvc2VkIHN0cmVhbVwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHZpZXcuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgdmlldydzIGxlbmd0aCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwIHdoZW4gY2FsbGluZyByZXNwb25kV2l0aE5ld1ZpZXcoKSBvbiBhIHJlYWRhYmxlIHN0cmVhbVwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpcnN0RGVzY3JpcHRvci5ieXRlT2Zmc2V0ICsgZmlyc3REZXNjcmlwdG9yLmJ5dGVzRmlsbGVkICE9PSB2aWV3LmJ5dGVPZmZzZXQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGUgcmVnaW9uIHNwZWNpZmllZCBieSB2aWV3IGRvZXMgbm90IG1hdGNoIGJ5b2JSZXF1ZXN0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpcnN0RGVzY3JpcHRvci5idWZmZXJCeXRlTGVuZ3RoICE9PSB2aWV3LmJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlIGJ1ZmZlciBvZiB2aWV3IGhhcyBkaWZmZXJlbnQgY2FwYWNpdHkgdGhhbiBieW9iUmVxdWVzdFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaXJzdERlc2NyaXB0b3IuYnl0ZXNGaWxsZWQgKyB2aWV3LmJ5dGVMZW5ndGggPiBmaXJzdERlc2NyaXB0b3IuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZSByZWdpb24gc3BlY2lmaWVkIGJ5IHZpZXcgaXMgbGFyZ2VyIHRoYW4gYnlvYlJlcXVlc3RcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2aWV3Qnl0ZUxlbmd0aCA9IHZpZXcuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIGZpcnN0RGVzY3JpcHRvci5idWZmZXIgPSBUcmFuc2ZlckFycmF5QnVmZmVyKHZpZXcuYnVmZmVyKTtcbiAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kSW50ZXJuYWwoY29udHJvbGxlciwgdmlld0J5dGVMZW5ndGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBTZXRVcFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtLCBjb250cm9sbGVyLCBzdGFydEFsZ29yaXRobSwgcHVsbEFsZ29yaXRobSwgY2FuY2VsQWxnb3JpdGhtLCBoaWdoV2F0ZXJNYXJrLCBhdXRvQWxsb2NhdGVDaHVua1NpemUpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0gPSBzdHJlYW07XG4gICAgICAgICAgICBjb250cm9sbGVyLl9wdWxsQWdhaW4gPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuX3B1bGxpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuX2J5b2JSZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuX3F1ZXVlID0gY29udHJvbGxlci5fcXVldWVUb3RhbFNpemUgPSB2b2lkIDA7XG4gICAgICAgICAgICBSZXNldFF1ZXVlKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgY29udHJvbGxlci5fY2xvc2VSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuX3N0cmF0ZWd5SFdNID0gaGlnaFdhdGVyTWFyaztcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuX3B1bGxBbGdvcml0aG0gPSBwdWxsQWxnb3JpdGhtO1xuICAgICAgICAgICAgY29udHJvbGxlci5fY2FuY2VsQWxnb3JpdGhtID0gY2FuY2VsQWxnb3JpdGhtO1xuICAgICAgICAgICAgY29udHJvbGxlci5fYXV0b0FsbG9jYXRlQ2h1bmtTaXplID0gYXV0b0FsbG9jYXRlQ2h1bmtTaXplO1xuICAgICAgICAgICAgY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xuICAgICAgICAgICAgc3RyZWFtLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRSZXN1bHQgPSBzdGFydEFsZ29yaXRobSgpO1xuICAgICAgICAgICAgdXBvblByb21pc2UocHJvbWlzZVJlc29sdmVkV2l0aChzdGFydFJlc3VsdCksICgpID0+IHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5fc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgfSwgKHIyMikgPT4ge1xuICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgcjIyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBTZXRVcFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGcm9tVW5kZXJseWluZ1NvdXJjZShzdHJlYW0sIHVuZGVybHlpbmdCeXRlU291cmNlLCBoaWdoV2F0ZXJNYXJrKSB7XG4gICAgICAgICAgICBjb25zdCBjb250cm9sbGVyID0gT2JqZWN0LmNyZWF0ZShSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZSk7XG4gICAgICAgICAgICBsZXQgc3RhcnRBbGdvcml0aG0gPSAoKSA9PiB2b2lkIDA7XG4gICAgICAgICAgICBsZXQgcHVsbEFsZ29yaXRobSA9ICgpID0+IHByb21pc2VSZXNvbHZlZFdpdGgodm9pZCAwKTtcbiAgICAgICAgICAgIGxldCBjYW5jZWxBbGdvcml0aG0gPSAoKSA9PiBwcm9taXNlUmVzb2x2ZWRXaXRoKHZvaWQgMCk7XG4gICAgICAgICAgICBpZiAodW5kZXJseWluZ0J5dGVTb3VyY2Uuc3RhcnQgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBzdGFydEFsZ29yaXRobSA9ICgpID0+IHVuZGVybHlpbmdCeXRlU291cmNlLnN0YXJ0KGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVuZGVybHlpbmdCeXRlU291cmNlLnB1bGwgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBwdWxsQWxnb3JpdGhtID0gKCkgPT4gdW5kZXJseWluZ0J5dGVTb3VyY2UucHVsbChjb250cm9sbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1bmRlcmx5aW5nQnl0ZVNvdXJjZS5jYW5jZWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBjYW5jZWxBbGdvcml0aG0gPSAocmVhc29uKSA9PiB1bmRlcmx5aW5nQnl0ZVNvdXJjZS5jYW5jZWwocmVhc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSA9IHVuZGVybHlpbmdCeXRlU291cmNlLmF1dG9BbGxvY2F0ZUNodW5rU2l6ZTtcbiAgICAgICAgICAgIGlmIChhdXRvQWxsb2NhdGVDaHVua1NpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImF1dG9BbGxvY2F0ZUNodW5rU2l6ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgU2V0VXBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKHN0cmVhbSwgY29udHJvbGxlciwgc3RhcnRBbGdvcml0aG0sIHB1bGxBbGdvcml0aG0sIGNhbmNlbEFsZ29yaXRobSwgaGlnaFdhdGVyTWFyaywgYXV0b0FsbG9jYXRlQ2h1bmtTaXplKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gU2V0VXBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0KHJlcXVlc3QsIGNvbnRyb2xsZXIsIHZpZXcpIHtcbiAgICAgICAgICAgIHJlcXVlc3QuX2Fzc29jaWF0ZWRSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyID0gY29udHJvbGxlcjtcbiAgICAgICAgICAgIHJlcXVlc3QuX3ZpZXcgPSB2aWV3O1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBieW9iUmVxdWVzdEJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoYFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3RgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gYnl0ZVN0cmVhbUNvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKGBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIEFjcXVpcmVSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIoc3RyZWFtKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlcihzdHJlYW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUFkZFJlYWRJbnRvUmVxdWVzdChzdHJlYW0sIHJlYWRJbnRvUmVxdWVzdCkge1xuICAgICAgICAgICAgc3RyZWFtLl9yZWFkZXIuX3JlYWRJbnRvUmVxdWVzdHMucHVzaChyZWFkSW50b1JlcXVlc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUZ1bGZpbGxSZWFkSW50b1JlcXVlc3Qoc3RyZWFtLCBjaHVuaywgZG9uZSkge1xuICAgICAgICAgICAgY29uc3QgcmVhZGVyID0gc3RyZWFtLl9yZWFkZXI7XG4gICAgICAgICAgICBjb25zdCByZWFkSW50b1JlcXVlc3QgPSByZWFkZXIuX3JlYWRJbnRvUmVxdWVzdHMuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgIHJlYWRJbnRvUmVxdWVzdC5fY2xvc2VTdGVwcyhjaHVuayk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWFkSW50b1JlcXVlc3QuX2NodW5rU3RlcHMoY2h1bmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUdldE51bVJlYWRJbnRvUmVxdWVzdHMoc3RyZWFtKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyZWFtLl9yZWFkZXIuX3JlYWRJbnRvUmVxdWVzdHMubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUhhc0JZT0JSZWFkZXIoc3RyZWFtKSB7XG4gICAgICAgICAgICBjb25zdCByZWFkZXIgPSBzdHJlYW0uX3JlYWRlcjtcbiAgICAgICAgICAgIGlmIChyZWFkZXIgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHJlYWRlcikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNsYXNzIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlciB7XG4gICAgICAgICAgICBjb25zdHJ1Y3RvcihzdHJlYW0pIHtcbiAgICAgICAgICAgICAgYXNzZXJ0UmVxdWlyZWRBcmd1bWVudChzdHJlYW0sIDEsIFwiUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyXCIpO1xuICAgICAgICAgICAgICBhc3NlcnRSZWFkYWJsZVN0cmVhbShzdHJlYW0sIFwiRmlyc3QgcGFyYW1ldGVyXCIpO1xuICAgICAgICAgICAgICBpZiAoSXNSZWFkYWJsZVN0cmVhbUxvY2tlZChzdHJlYW0pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoaXMgc3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gbG9ja2VkIGZvciBleGNsdXNpdmUgcmVhZGluZyBieSBhbm90aGVyIHJlYWRlclwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcihzdHJlYW0uX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNvbnN0cnVjdCBhIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlciBmb3IgYSBzdHJlYW0gbm90IGNvbnN0cnVjdGVkIHdpdGggYSBieXRlIHNvdXJjZVwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNJbml0aWFsaXplKHRoaXMsIHN0cmVhbSk7XG4gICAgICAgICAgICAgIHRoaXMuX3JlYWRJbnRvUmVxdWVzdHMgPSBuZXcgU2ltcGxlUXVldWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdldCBjbG9zZWQoKSB7XG4gICAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChieW9iUmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvbihcImNsb3NlZFwiKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb3NlZFByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYW5jZWwocmVhc29uID0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChieW9iUmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvbihcImNhbmNlbFwiKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHRoaXMuX293bmVyUmVhZGFibGVTdHJlYW0gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHJlYWRlckxvY2tFeGNlcHRpb24oXCJjYW5jZWxcIikpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNDYW5jZWwodGhpcywgcmVhc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYWQodmlldykge1xuICAgICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoYnlvYlJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24oXCJyZWFkXCIpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIUFycmF5QnVmZmVyLmlzVmlldyh2aWV3KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoXCJ2aWV3IG11c3QgYmUgYW4gYXJyYXkgYnVmZmVyIHZpZXdcIikpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh2aWV3LmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKFwidmlldyBtdXN0IGhhdmUgbm9uLXplcm8gYnl0ZUxlbmd0aFwiKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHZpZXcuYnVmZmVyLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKGB2aWV3J3MgYnVmZmVyIG11c3QgaGF2ZSBub24temVybyBieXRlTGVuZ3RoYCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChJc0RldGFjaGVkQnVmZmVyKHZpZXcuYnVmZmVyKSlcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9vd25lclJlYWRhYmxlU3RyZWFtID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChyZWFkZXJMb2NrRXhjZXB0aW9uKFwicmVhZCBmcm9tXCIpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZXQgcmVzb2x2ZVByb21pc2U7XG4gICAgICAgICAgICAgIGxldCByZWplY3RQcm9taXNlO1xuICAgICAgICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3UHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xuICAgICAgICAgICAgICAgIHJlamVjdFByb21pc2UgPSByZWplY3Q7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjb25zdCByZWFkSW50b1JlcXVlc3QgPSB7XG4gICAgICAgICAgICAgICAgX2NodW5rU3RlcHM6IChjaHVuaykgPT4gcmVzb2x2ZVByb21pc2UoeyB2YWx1ZTogY2h1bmssIGRvbmU6IGZhbHNlIH0pLFxuICAgICAgICAgICAgICAgIF9jbG9zZVN0ZXBzOiAoY2h1bmspID0+IHJlc29sdmVQcm9taXNlKHsgdmFsdWU6IGNodW5rLCBkb25lOiB0cnVlIH0pLFxuICAgICAgICAgICAgICAgIF9lcnJvclN0ZXBzOiAoZTIpID0+IHJlamVjdFByb21pc2UoZTIpXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlclJlYWQodGhpcywgdmlldywgcmVhZEludG9SZXF1ZXN0KTtcbiAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWxlYXNlTG9jaygpIHtcbiAgICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtQllPQlJlYWRlcih0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGJ5b2JSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uKFwicmVsZWFzZUxvY2tcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHRoaXMuX293bmVyUmVhZGFibGVTdHJlYW0gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodGhpcy5fcmVhZEludG9SZXF1ZXN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRyaWVkIHRvIHJlbGVhc2UgYSByZWFkZXIgbG9jayB3aGVuIHRoYXQgcmVhZGVyIGhhcyBwZW5kaW5nIHJlYWQoKSBjYWxscyB1bi1zZXR0bGVkXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlci5wcm90b3R5cGUsIHtcbiAgICAgICAgICAgIGNhbmNlbDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgICAgICByZWFkOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgICAgIHJlbGVhc2VMb2NrOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgICAgIGNsb3NlZDogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAodHlwZW9mIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnID09PSBcInN5bWJvbFwiKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyLnByb3RvdHlwZSwgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IFwiUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyXCIsXG4gICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIElzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHgyKSB7XG4gICAgICAgICAgICBpZiAoIXR5cGVJc09iamVjdCh4MikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeDIsIFwiX3JlYWRJbnRvUmVxdWVzdHNcIikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHgyIGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXJSZWFkKHJlYWRlciwgdmlldywgcmVhZEludG9SZXF1ZXN0KSB7XG4gICAgICAgICAgICBjb25zdCBzdHJlYW0gPSByZWFkZXIuX293bmVyUmVhZGFibGVTdHJlYW07XG4gICAgICAgICAgICBzdHJlYW0uX2Rpc3R1cmJlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gXCJlcnJvcmVkXCIpIHtcbiAgICAgICAgICAgICAgcmVhZEludG9SZXF1ZXN0Ll9lcnJvclN0ZXBzKHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclB1bGxJbnRvKHN0cmVhbS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCB2aWV3LCByZWFkSW50b1JlcXVlc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBieW9iUmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyLnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXJgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gRXh0cmFjdEhpZ2hXYXRlck1hcmsoc3RyYXRlZ3ksIGRlZmF1bHRIV00pIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaGlnaFdhdGVyTWFyayB9ID0gc3RyYXRlZ3k7XG4gICAgICAgICAgICBpZiAoaGlnaFdhdGVyTWFyayA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0SFdNO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE51bWJlcklzTmFOKGhpZ2hXYXRlck1hcmspIHx8IGhpZ2hXYXRlck1hcmsgPCAwKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBoaWdoV2F0ZXJNYXJrXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhpZ2hXYXRlck1hcms7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIEV4dHJhY3RTaXplQWxnb3JpdGhtKHN0cmF0ZWd5KSB7XG4gICAgICAgICAgICBjb25zdCB7IHNpemUgfSA9IHN0cmF0ZWd5O1xuICAgICAgICAgICAgaWYgKCFzaXplKSB7XG4gICAgICAgICAgICAgIHJldHVybiAoKSA9PiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3koaW5pdCwgY29udGV4dCkge1xuICAgICAgICAgICAgYXNzZXJ0RGljdGlvbmFyeShpbml0LCBjb250ZXh0KTtcbiAgICAgICAgICAgIGNvbnN0IGhpZ2hXYXRlck1hcmsgPSBpbml0ID09PSBudWxsIHx8IGluaXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluaXQuaGlnaFdhdGVyTWFyaztcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBpbml0ID09PSBudWxsIHx8IGluaXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluaXQuc2l6ZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGhpZ2hXYXRlck1hcms6IGhpZ2hXYXRlck1hcmsgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnZlcnRVbnJlc3RyaWN0ZWREb3VibGUoaGlnaFdhdGVyTWFyayksXG4gICAgICAgICAgICAgIHNpemU6IHNpemUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3lTaXplKHNpemUsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3NpemUnIHRoYXRgKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gY29udmVydFF1ZXVpbmdTdHJhdGVneVNpemUoZm4sIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiAoY2h1bmspID0+IGNvbnZlcnRVbnJlc3RyaWN0ZWREb3VibGUoZm4oY2h1bmspKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gY29udmVydFVuZGVybHlpbmdTaW5rKG9yaWdpbmFsLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBhc3NlcnREaWN0aW9uYXJ5KG9yaWdpbmFsLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGNvbnN0IGFib3J0ID0gb3JpZ2luYWwgPT09IG51bGwgfHwgb3JpZ2luYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsLmFib3J0O1xuICAgICAgICAgICAgY29uc3QgY2xvc2UgPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwuY2xvc2U7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IG9yaWdpbmFsID09PSBudWxsIHx8IG9yaWdpbmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW5hbC5zdGFydDtcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwudHlwZTtcbiAgICAgICAgICAgIGNvbnN0IHdyaXRlID0gb3JpZ2luYWwgPT09IG51bGwgfHwgb3JpZ2luYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsLndyaXRlO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgYWJvcnQ6IGFib3J0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb252ZXJ0VW5kZXJseWluZ1NpbmtBYm9ydENhbGxiYWNrKGFib3J0LCBvcmlnaW5hbCwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnYWJvcnQnIHRoYXRgKSxcbiAgICAgICAgICAgICAgY2xvc2U6IGNsb3NlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb252ZXJ0VW5kZXJseWluZ1NpbmtDbG9zZUNhbGxiYWNrKGNsb3NlLCBvcmlnaW5hbCwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnY2xvc2UnIHRoYXRgKSxcbiAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb252ZXJ0VW5kZXJseWluZ1NpbmtTdGFydENhbGxiYWNrKHN0YXJ0LCBvcmlnaW5hbCwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnc3RhcnQnIHRoYXRgKSxcbiAgICAgICAgICAgICAgd3JpdGU6IHdyaXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb252ZXJ0VW5kZXJseWluZ1NpbmtXcml0ZUNhbGxiYWNrKHdyaXRlLCBvcmlnaW5hbCwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnd3JpdGUnIHRoYXRgKSxcbiAgICAgICAgICAgICAgdHlwZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gY29udmVydFVuZGVybHlpbmdTaW5rQWJvcnRDYWxsYmFjayhmbiwgb3JpZ2luYWwsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiAocmVhc29uKSA9PiBwcm9taXNlQ2FsbChmbiwgb3JpZ2luYWwsIFtyZWFzb25dKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gY29udmVydFVuZGVybHlpbmdTaW5rQ2xvc2VDYWxsYmFjayhmbiwgb3JpZ2luYWwsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiBwcm9taXNlQ2FsbChmbiwgb3JpZ2luYWwsIFtdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gY29udmVydFVuZGVybHlpbmdTaW5rU3RhcnRDYWxsYmFjayhmbiwgb3JpZ2luYWwsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiAoY29udHJvbGxlcikgPT4gcmVmbGVjdENhbGwoZm4sIG9yaWdpbmFsLCBbY29udHJvbGxlcl0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBjb252ZXJ0VW5kZXJseWluZ1NpbmtXcml0ZUNhbGxiYWNrKGZuLCBvcmlnaW5hbCwgY29udGV4dCkge1xuICAgICAgICAgICAgYXNzZXJ0RnVuY3Rpb24oZm4sIGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIChjaHVuaywgY29udHJvbGxlcikgPT4gcHJvbWlzZUNhbGwoZm4sIG9yaWdpbmFsLCBbY2h1bmssIGNvbnRyb2xsZXJdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gYXNzZXJ0V3JpdGFibGVTdHJlYW0oeDIsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGlmICghSXNXcml0YWJsZVN0cmVhbSh4MikpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtjb250ZXh0fSBpcyBub3QgYSBXcml0YWJsZVN0cmVhbS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gaXNBYm9ydFNpZ25hbDIodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZS5hYm9ydGVkID09PSBcImJvb2xlYW5cIjtcbiAgICAgICAgICAgIH0gY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgc3VwcG9ydHNBYm9ydENvbnRyb2xsZXIgPSB0eXBlb2YgQWJvcnRDb250cm9sbGVyID09PSBcImZ1bmN0aW9uXCI7XG4gICAgICAgICAgZnVuY3Rpb24gY3JlYXRlQWJvcnRDb250cm9sbGVyKCkge1xuICAgICAgICAgICAgaWYgKHN1cHBvcnRzQWJvcnRDb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjbGFzcyBXcml0YWJsZVN0cmVhbSB7XG4gICAgICAgICAgICBjb25zdHJ1Y3RvcihyYXdVbmRlcmx5aW5nU2luayA9IHt9LCByYXdTdHJhdGVneSA9IHt9KSB7XG4gICAgICAgICAgICAgIGlmIChyYXdVbmRlcmx5aW5nU2luayA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgcmF3VW5kZXJseWluZ1NpbmsgPSBudWxsO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFzc2VydE9iamVjdChyYXdVbmRlcmx5aW5nU2luaywgXCJGaXJzdCBwYXJhbWV0ZXJcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3Qgc3RyYXRlZ3kgPSBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5KHJhd1N0cmF0ZWd5LCBcIlNlY29uZCBwYXJhbWV0ZXJcIik7XG4gICAgICAgICAgICAgIGNvbnN0IHVuZGVybHlpbmdTaW5rID0gY29udmVydFVuZGVybHlpbmdTaW5rKHJhd1VuZGVybHlpbmdTaW5rLCBcIkZpcnN0IHBhcmFtZXRlclwiKTtcbiAgICAgICAgICAgICAgSW5pdGlhbGl6ZVdyaXRhYmxlU3RyZWFtKHRoaXMpO1xuICAgICAgICAgICAgICBjb25zdCB0eXBlID0gdW5kZXJseWluZ1NpbmsudHlwZTtcbiAgICAgICAgICAgICAgaWYgKHR5cGUgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCB0eXBlIGlzIHNwZWNpZmllZFwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBzaXplQWxnb3JpdGhtID0gRXh0cmFjdFNpemVBbGdvcml0aG0oc3RyYXRlZ3kpO1xuICAgICAgICAgICAgICBjb25zdCBoaWdoV2F0ZXJNYXJrID0gRXh0cmFjdEhpZ2hXYXRlck1hcmsoc3RyYXRlZ3ksIDEpO1xuICAgICAgICAgICAgICBTZXRVcFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJGcm9tVW5kZXJseWluZ1NpbmsodGhpcywgdW5kZXJseWluZ1NpbmssIGhpZ2hXYXRlck1hcmssIHNpemVBbGdvcml0aG0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2V0IGxvY2tlZCgpIHtcbiAgICAgICAgICAgICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbiQyKFwibG9ja2VkXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBJc1dyaXRhYmxlU3RyZWFtTG9ja2VkKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWJvcnQocmVhc29uID0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIGlmICghSXNXcml0YWJsZVN0cmVhbSh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24kMihcImFib3J0XCIpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoSXNXcml0YWJsZVN0cmVhbUxvY2tlZCh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgYWJvcnQgYSBzdHJlYW0gdGhhdCBhbHJlYWR5IGhhcyBhIHdyaXRlclwiKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtQWJvcnQodGhpcywgcmVhc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsb3NlKCkge1xuICAgICAgICAgICAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW0odGhpcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uJDIoXCJjbG9zZVwiKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKElzV3JpdGFibGVTdHJlYW1Mb2NrZWQodGhpcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNsb3NlIGEgc3RyZWFtIHRoYXQgYWxyZWFkeSBoYXMgYSB3cml0ZXJcIikpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodCh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2xvc2UgYW4gYWxyZWFkeS1jbG9zaW5nIHN0cmVhbVwiKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtQ2xvc2UodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZXRXcml0ZXIoKSB7XG4gICAgICAgICAgICAgIGlmICghSXNXcml0YWJsZVN0cmVhbSh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24kMihcImdldFdyaXRlclwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gQWNxdWlyZVdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcih0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoV3JpdGFibGVTdHJlYW0ucHJvdG90eXBlLCB7XG4gICAgICAgICAgICBhYm9ydDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgICAgICBjbG9zZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgICAgICBnZXRXcml0ZXI6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICAgICAgbG9ja2VkOiB7IGVudW1lcmFibGU6IHRydWUgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICh0eXBlb2YgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcgPT09IFwic3ltYm9sXCIpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0cmVhbS5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBcIldyaXRhYmxlU3RyZWFtXCIsXG4gICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIEFjcXVpcmVXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIoc3RyZWFtKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcihzdHJlYW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBDcmVhdGVXcml0YWJsZVN0cmVhbShzdGFydEFsZ29yaXRobSwgd3JpdGVBbGdvcml0aG0sIGNsb3NlQWxnb3JpdGhtLCBhYm9ydEFsZ29yaXRobSwgaGlnaFdhdGVyTWFyayA9IDEsIHNpemVBbGdvcml0aG0gPSAoKSA9PiAxKSB7XG4gICAgICAgICAgICBjb25zdCBzdHJlYW0gPSBPYmplY3QuY3JlYXRlKFdyaXRhYmxlU3RyZWFtLnByb3RvdHlwZSk7XG4gICAgICAgICAgICBJbml0aWFsaXplV3JpdGFibGVTdHJlYW0oc3RyZWFtKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBPYmplY3QuY3JlYXRlKFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlKTtcbiAgICAgICAgICAgIFNldFVwV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcihzdHJlYW0sIGNvbnRyb2xsZXIsIHN0YXJ0QWxnb3JpdGhtLCB3cml0ZUFsZ29yaXRobSwgY2xvc2VBbGdvcml0aG0sIGFib3J0QWxnb3JpdGhtLCBoaWdoV2F0ZXJNYXJrLCBzaXplQWxnb3JpdGhtKTtcbiAgICAgICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIEluaXRpYWxpemVXcml0YWJsZVN0cmVhbShzdHJlYW0pIHtcbiAgICAgICAgICAgIHN0cmVhbS5fc3RhdGUgPSBcIndyaXRhYmxlXCI7XG4gICAgICAgICAgICBzdHJlYW0uX3N0b3JlZEVycm9yID0gdm9pZCAwO1xuICAgICAgICAgICAgc3RyZWFtLl93cml0ZXIgPSB2b2lkIDA7XG4gICAgICAgICAgICBzdHJlYW0uX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlciA9IHZvaWQgMDtcbiAgICAgICAgICAgIHN0cmVhbS5fd3JpdGVSZXF1ZXN0cyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xuICAgICAgICAgICAgc3RyZWFtLl9pbkZsaWdodFdyaXRlUmVxdWVzdCA9IHZvaWQgMDtcbiAgICAgICAgICAgIHN0cmVhbS5fY2xvc2VSZXF1ZXN0ID0gdm9pZCAwO1xuICAgICAgICAgICAgc3RyZWFtLl9pbkZsaWdodENsb3NlUmVxdWVzdCA9IHZvaWQgMDtcbiAgICAgICAgICAgIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdCA9IHZvaWQgMDtcbiAgICAgICAgICAgIHN0cmVhbS5fYmFja3ByZXNzdXJlID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIElzV3JpdGFibGVTdHJlYW0oeDIpIHtcbiAgICAgICAgICAgIGlmICghdHlwZUlzT2JqZWN0KHgyKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4MiwgXCJfd3JpdGFibGVTdHJlYW1Db250cm9sbGVyXCIpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB4MiBpbnN0YW5jZW9mIFdyaXRhYmxlU3RyZWFtO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBJc1dyaXRhYmxlU3RyZWFtTG9ja2VkKHN0cmVhbSkge1xuICAgICAgICAgICAgaWYgKHN0cmVhbS5fd3JpdGVyID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtQWJvcnQoc3RyZWFtLCByZWFzb24pIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmIChzdHJlYW0uX3N0YXRlID09PSBcImNsb3NlZFwiIHx8IHN0cmVhbS5fc3RhdGUgPT09IFwiZXJyb3JlZFwiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHZvaWQgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJlYW0uX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlci5fYWJvcnRSZWFzb24gPSByZWFzb247XG4gICAgICAgICAgICAoX2EgPSBzdHJlYW0uX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlci5fYWJvcnRDb250cm9sbGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWJvcnQoKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcbiAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gXCJjbG9zZWRcIiB8fCBzdGF0ZSA9PT0gXCJlcnJvcmVkXCIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodm9pZCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICByZXR1cm4gc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0Ll9wcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHdhc0FscmVhZHlFcnJvcmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHN0YXRlID09PSBcImVycm9yaW5nXCIpIHtcbiAgICAgICAgICAgICAgd2FzQWxyZWFkeUVycm9yaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcmVhc29uID0gdm9pZCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ld1Byb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICBzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgPSB7XG4gICAgICAgICAgICAgICAgX3Byb21pc2U6IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBfcmVzb2x2ZTogcmVzb2x2ZSxcbiAgICAgICAgICAgICAgICBfcmVqZWN0OiByZWplY3QsXG4gICAgICAgICAgICAgICAgX3JlYXNvbjogcmVhc29uLFxuICAgICAgICAgICAgICAgIF93YXNBbHJlYWR5RXJyb3Jpbmc6IHdhc0FscmVhZHlFcnJvcmluZ1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QuX3Byb21pc2UgPSBwcm9taXNlO1xuICAgICAgICAgICAgaWYgKCF3YXNBbHJlYWR5RXJyb3JpbmcpIHtcbiAgICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1TdGFydEVycm9yaW5nKHN0cmVhbSwgcmVhc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbUNsb3NlKHN0cmVhbSkge1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBzdHJlYW0uX3N0YXRlO1xuICAgICAgICAgICAgaWYgKHN0YXRlID09PSBcImNsb3NlZFwiIHx8IHN0YXRlID09PSBcImVycm9yZWRcIikge1xuICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKGBUaGUgc3RyZWFtIChpbiAke3N0YXRlfSBzdGF0ZSkgaXMgbm90IGluIHRoZSB3cml0YWJsZSBzdGF0ZSBhbmQgY2Fubm90IGJlIGNsb3NlZGApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXdQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgY2xvc2VSZXF1ZXN0ID0ge1xuICAgICAgICAgICAgICAgIF9yZXNvbHZlOiByZXNvbHZlLFxuICAgICAgICAgICAgICAgIF9yZWplY3Q6IHJlamVjdFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBzdHJlYW0uX2Nsb3NlUmVxdWVzdCA9IGNsb3NlUmVxdWVzdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qgd3JpdGVyID0gc3RyZWFtLl93cml0ZXI7XG4gICAgICAgICAgICBpZiAod3JpdGVyICE9PSB2b2lkIDAgJiYgc3RyZWFtLl9iYWNrcHJlc3N1cmUgJiYgc3RhdGUgPT09IFwid3JpdGFibGVcIikge1xuICAgICAgICAgICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzb2x2ZSh3cml0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsb3NlKHN0cmVhbS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyKTtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbUFkZFdyaXRlUmVxdWVzdChzdHJlYW0pIHtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXdQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgY29uc3Qgd3JpdGVSZXF1ZXN0ID0ge1xuICAgICAgICAgICAgICAgIF9yZXNvbHZlOiByZXNvbHZlLFxuICAgICAgICAgICAgICAgIF9yZWplY3Q6IHJlamVjdFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBzdHJlYW0uX3dyaXRlUmVxdWVzdHMucHVzaCh3cml0ZVJlcXVlc3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWFsV2l0aFJlamVjdGlvbihzdHJlYW0sIGVycm9yKSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHN0cmVhbS5fc3RhdGU7XG4gICAgICAgICAgICBpZiAoc3RhdGUgPT09IFwid3JpdGFibGVcIikge1xuICAgICAgICAgICAgICBXcml0YWJsZVN0cmVhbVN0YXJ0RXJyb3Jpbmcoc3RyZWFtLCBlcnJvcik7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRmluaXNoRXJyb3Jpbmcoc3RyZWFtKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1TdGFydEVycm9yaW5nKHN0cmVhbSwgcmVhc29uKSB7XG4gICAgICAgICAgICBjb25zdCBjb250cm9sbGVyID0gc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXI7XG4gICAgICAgICAgICBzdHJlYW0uX3N0YXRlID0gXCJlcnJvcmluZ1wiO1xuICAgICAgICAgICAgc3RyZWFtLl9zdG9yZWRFcnJvciA9IHJlYXNvbjtcbiAgICAgICAgICAgIGNvbnN0IHdyaXRlciA9IHN0cmVhbS5fd3JpdGVyO1xuICAgICAgICAgICAgaWYgKHdyaXRlciAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckVuc3VyZVJlYWR5UHJvbWlzZVJlamVjdGVkKHdyaXRlciwgcmVhc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghV3JpdGFibGVTdHJlYW1IYXNPcGVyYXRpb25NYXJrZWRJbkZsaWdodChzdHJlYW0pICYmIGNvbnRyb2xsZXIuX3N0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1GaW5pc2hFcnJvcmluZyhzdHJlYW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbUZpbmlzaEVycm9yaW5nKHN0cmVhbSkge1xuICAgICAgICAgICAgc3RyZWFtLl9zdGF0ZSA9IFwiZXJyb3JlZFwiO1xuICAgICAgICAgICAgc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXJbRXJyb3JTdGVwc10oKTtcbiAgICAgICAgICAgIGNvbnN0IHN0b3JlZEVycm9yID0gc3RyZWFtLl9zdG9yZWRFcnJvcjtcbiAgICAgICAgICAgIHN0cmVhbS5fd3JpdGVSZXF1ZXN0cy5mb3JFYWNoKCh3cml0ZVJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgICAgd3JpdGVSZXF1ZXN0Ll9yZWplY3Qoc3RvcmVkRXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdHJlYW0uX3dyaXRlUmVxdWVzdHMgPSBuZXcgU2ltcGxlUXVldWUoKTtcbiAgICAgICAgICAgIGlmIChzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBXcml0YWJsZVN0cmVhbVJlamVjdENsb3NlQW5kQ2xvc2VkUHJvbWlzZUlmTmVlZGVkKHN0cmVhbSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFib3J0UmVxdWVzdCA9IHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdDtcbiAgICAgICAgICAgIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdCA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChhYm9ydFJlcXVlc3QuX3dhc0FscmVhZHlFcnJvcmluZykge1xuICAgICAgICAgICAgICBhYm9ydFJlcXVlc3QuX3JlamVjdChzdG9yZWRFcnJvcik7XG4gICAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtUmVqZWN0Q2xvc2VBbmRDbG9zZWRQcm9taXNlSWZOZWVkZWQoc3RyZWFtKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IHN0cmVhbS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyW0Fib3J0U3RlcHNdKGFib3J0UmVxdWVzdC5fcmVhc29uKTtcbiAgICAgICAgICAgIHVwb25Qcm9taXNlKHByb21pc2UsICgpID0+IHtcbiAgICAgICAgICAgICAgYWJvcnRSZXF1ZXN0Ll9yZXNvbHZlKCk7XG4gICAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtUmVqZWN0Q2xvc2VBbmRDbG9zZWRQcm9taXNlSWZOZWVkZWQoc3RyZWFtKTtcbiAgICAgICAgICAgIH0sIChyZWFzb24pID0+IHtcbiAgICAgICAgICAgICAgYWJvcnRSZXF1ZXN0Ll9yZWplY3QocmVhc29uKTtcbiAgICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1SZWplY3RDbG9zZUFuZENsb3NlZFByb21pc2VJZk5lZWRlZChzdHJlYW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRXcml0ZShzdHJlYW0pIHtcbiAgICAgICAgICAgIHN0cmVhbS5faW5GbGlnaHRXcml0ZVJlcXVlc3QuX3Jlc29sdmUodm9pZCAwKTtcbiAgICAgICAgICAgIHN0cmVhbS5faW5GbGlnaHRXcml0ZVJlcXVlc3QgPSB2b2lkIDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRXcml0ZVdpdGhFcnJvcihzdHJlYW0sIGVycm9yKSB7XG4gICAgICAgICAgICBzdHJlYW0uX2luRmxpZ2h0V3JpdGVSZXF1ZXN0Ll9yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgc3RyZWFtLl9pbkZsaWdodFdyaXRlUmVxdWVzdCA9IHZvaWQgMDtcbiAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVhbFdpdGhSZWplY3Rpb24oc3RyZWFtLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRDbG9zZShzdHJlYW0pIHtcbiAgICAgICAgICAgIHN0cmVhbS5faW5GbGlnaHRDbG9zZVJlcXVlc3QuX3Jlc29sdmUodm9pZCAwKTtcbiAgICAgICAgICAgIHN0cmVhbS5faW5GbGlnaHRDbG9zZVJlcXVlc3QgPSB2b2lkIDA7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHN0cmVhbS5fc3RhdGU7XG4gICAgICAgICAgICBpZiAoc3RhdGUgPT09IFwiZXJyb3JpbmdcIikge1xuICAgICAgICAgICAgICBzdHJlYW0uX3N0b3JlZEVycm9yID0gdm9pZCAwO1xuICAgICAgICAgICAgICBpZiAoc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICBzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QuX3Jlc29sdmUoKTtcbiAgICAgICAgICAgICAgICBzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgPSB2b2lkIDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0cmVhbS5fc3RhdGUgPSBcImNsb3NlZFwiO1xuICAgICAgICAgICAgY29uc3Qgd3JpdGVyID0gc3RyZWFtLl93cml0ZXI7XG4gICAgICAgICAgICBpZiAod3JpdGVyICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZXNvbHZlKHdyaXRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRDbG9zZVdpdGhFcnJvcihzdHJlYW0sIGVycm9yKSB7XG4gICAgICAgICAgICBzdHJlYW0uX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0Ll9yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgc3RyZWFtLl9pbkZsaWdodENsb3NlUmVxdWVzdCA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QuX3JlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdCA9IHZvaWQgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVhbFdpdGhSZWplY3Rpb24oc3RyZWFtLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KHN0cmVhbSkge1xuICAgICAgICAgICAgaWYgKHN0cmVhbS5fY2xvc2VSZXF1ZXN0ID09PSB2b2lkIDAgJiYgc3RyZWFtLl9pbkZsaWdodENsb3NlUmVxdWVzdCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbUhhc09wZXJhdGlvbk1hcmtlZEluRmxpZ2h0KHN0cmVhbSkge1xuICAgICAgICAgICAgaWYgKHN0cmVhbS5faW5GbGlnaHRXcml0ZVJlcXVlc3QgPT09IHZvaWQgMCAmJiBzdHJlYW0uX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtTWFya0Nsb3NlUmVxdWVzdEluRmxpZ2h0KHN0cmVhbSkge1xuICAgICAgICAgICAgc3RyZWFtLl9pbkZsaWdodENsb3NlUmVxdWVzdCA9IHN0cmVhbS5fY2xvc2VSZXF1ZXN0O1xuICAgICAgICAgICAgc3RyZWFtLl9jbG9zZVJlcXVlc3QgPSB2b2lkIDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtTWFya0ZpcnN0V3JpdGVSZXF1ZXN0SW5GbGlnaHQoc3RyZWFtKSB7XG4gICAgICAgICAgICBzdHJlYW0uX2luRmxpZ2h0V3JpdGVSZXF1ZXN0ID0gc3RyZWFtLl93cml0ZVJlcXVlc3RzLnNoaWZ0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtUmVqZWN0Q2xvc2VBbmRDbG9zZWRQcm9taXNlSWZOZWVkZWQoc3RyZWFtKSB7XG4gICAgICAgICAgICBpZiAoc3RyZWFtLl9jbG9zZVJlcXVlc3QgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBzdHJlYW0uX2Nsb3NlUmVxdWVzdC5fcmVqZWN0KHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuICAgICAgICAgICAgICBzdHJlYW0uX2Nsb3NlUmVxdWVzdCA9IHZvaWQgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHdyaXRlciA9IHN0cmVhbS5fd3JpdGVyO1xuICAgICAgICAgICAgaWYgKHdyaXRlciAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlUmVqZWN0KHdyaXRlciwgc3RyZWFtLl9zdG9yZWRFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtVXBkYXRlQmFja3ByZXNzdXJlKHN0cmVhbSwgYmFja3ByZXNzdXJlKSB7XG4gICAgICAgICAgICBjb25zdCB3cml0ZXIgPSBzdHJlYW0uX3dyaXRlcjtcbiAgICAgICAgICAgIGlmICh3cml0ZXIgIT09IHZvaWQgMCAmJiBiYWNrcHJlc3N1cmUgIT09IHN0cmVhbS5fYmFja3ByZXNzdXJlKSB7XG4gICAgICAgICAgICAgIGlmIChiYWNrcHJlc3N1cmUpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzZXQod3JpdGVyKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzb2x2ZSh3cml0ZXIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJlYW0uX2JhY2twcmVzc3VyZSA9IGJhY2twcmVzc3VyZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2xhc3MgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKHN0cmVhbSkge1xuICAgICAgICAgICAgICBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50KHN0cmVhbSwgMSwgXCJXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJcIik7XG4gICAgICAgICAgICAgIGFzc2VydFdyaXRhYmxlU3RyZWFtKHN0cmVhbSwgXCJGaXJzdCBwYXJhbWV0ZXJcIik7XG4gICAgICAgICAgICAgIGlmIChJc1dyaXRhYmxlU3RyZWFtTG9ja2VkKHN0cmVhbSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhpcyBzdHJlYW0gaGFzIGFscmVhZHkgYmVlbiBsb2NrZWQgZm9yIGV4Y2x1c2l2ZSB3cml0aW5nIGJ5IGFub3RoZXIgd3JpdGVyXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuX293bmVyV3JpdGFibGVTdHJlYW0gPSBzdHJlYW07XG4gICAgICAgICAgICAgIHN0cmVhbS5fd3JpdGVyID0gdGhpcztcbiAgICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBzdHJlYW0uX3N0YXRlO1xuICAgICAgICAgICAgICBpZiAoc3RhdGUgPT09IFwid3JpdGFibGVcIikge1xuICAgICAgICAgICAgICAgIGlmICghV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQoc3RyZWFtKSAmJiBzdHJlYW0uX2JhY2twcmVzc3VyZSkge1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemUodGhpcyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplQXNSZXNvbHZlZCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VJbml0aWFsaXplKHRoaXMpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBcImVycm9yaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQodGhpcywgc3RyZWFtLl9zdG9yZWRFcnJvcik7XG4gICAgICAgICAgICAgICAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VJbml0aWFsaXplKHRoaXMpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBcImNsb3NlZFwiKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemVBc1Jlc29sdmVkKHRoaXMpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQodGhpcyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RvcmVkRXJyb3IgPSBzdHJlYW0uX3N0b3JlZEVycm9yO1xuICAgICAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplQXNSZWplY3RlZCh0aGlzLCBzdG9yZWRFcnJvcik7XG4gICAgICAgICAgICAgICAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZWplY3RlZCh0aGlzLCBzdG9yZWRFcnJvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdldCBjbG9zZWQoKSB7XG4gICAgICAgICAgICAgIGlmICghSXNXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0V3JpdGVyQnJhbmRDaGVja0V4Y2VwdGlvbihcImNsb3NlZFwiKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb3NlZFByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZXQgZGVzaXJlZFNpemUoKSB7XG4gICAgICAgICAgICAgIGlmICghSXNXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBkZWZhdWx0V3JpdGVyQnJhbmRDaGVja0V4Y2VwdGlvbihcImRlc2lyZWRTaXplXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9vd25lcldyaXRhYmxlU3RyZWFtID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBkZWZhdWx0V3JpdGVyTG9ja0V4Y2VwdGlvbihcImRlc2lyZWRTaXplXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJHZXREZXNpcmVkU2l6ZSh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdldCByZWFkeSgpIHtcbiAgICAgICAgICAgICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcih0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRXcml0ZXJCcmFuZENoZWNrRXhjZXB0aW9uKFwicmVhZHlcIikpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWFkeVByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhYm9ydChyZWFzb24gPSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcih0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRXcml0ZXJCcmFuZENoZWNrRXhjZXB0aW9uKFwiYWJvcnRcIikpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9vd25lcldyaXRhYmxlU3RyZWFtID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0V3JpdGVyTG9ja0V4Y2VwdGlvbihcImFib3J0XCIpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyQWJvcnQodGhpcywgcmVhc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsb3NlKCkge1xuICAgICAgICAgICAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFdyaXRlckJyYW5kQ2hlY2tFeGNlcHRpb24oXCJjbG9zZVwiKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0gdGhpcy5fb3duZXJXcml0YWJsZVN0cmVhbTtcbiAgICAgICAgICAgICAgaWYgKHN0cmVhbSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFdyaXRlckxvY2tFeGNlcHRpb24oXCJjbG9zZVwiKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKFdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KHN0cmVhbSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNsb3NlIGFuIGFscmVhZHktY2xvc2luZyBzdHJlYW1cIikpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJDbG9zZSh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlbGVhc2VMb2NrKCkge1xuICAgICAgICAgICAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZGVmYXVsdFdyaXRlckJyYW5kQ2hlY2tFeGNlcHRpb24oXCJyZWxlYXNlTG9ja1wiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBzdHJlYW0gPSB0aGlzLl9vd25lcldyaXRhYmxlU3RyZWFtO1xuICAgICAgICAgICAgICBpZiAoc3RyZWFtID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyUmVsZWFzZSh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdyaXRlKGNodW5rID0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIGlmICghSXNXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0V3JpdGVyQnJhbmRDaGVja0V4Y2VwdGlvbihcIndyaXRlXCIpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodGhpcy5fb3duZXJXcml0YWJsZVN0cmVhbSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFdyaXRlckxvY2tFeGNlcHRpb24oXCJ3cml0ZSB0b1wiKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcldyaXRlKHRoaXMsIGNodW5rKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLnByb3RvdHlwZSwge1xuICAgICAgICAgICAgYWJvcnQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICAgICAgY2xvc2U6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICAgICAgcmVsZWFzZUxvY2s6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICAgICAgd3JpdGU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICAgICAgY2xvc2VkOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgICAgIGRlc2lyZWRTaXplOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgICAgIHJlYWR5OiB7IGVudW1lcmFibGU6IHRydWUgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICh0eXBlb2YgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcgPT09IFwic3ltYm9sXCIpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIucHJvdG90eXBlLCBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZywge1xuICAgICAgICAgICAgICB2YWx1ZTogXCJXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJcIixcbiAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gSXNXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIoeDIpIHtcbiAgICAgICAgICAgIGlmICghdHlwZUlzT2JqZWN0KHgyKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4MiwgXCJfb3duZXJXcml0YWJsZVN0cmVhbVwiKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geDIgaW5zdGFuY2VvZiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckFib3J0KHdyaXRlciwgcmVhc29uKSB7XG4gICAgICAgICAgICBjb25zdCBzdHJlYW0gPSB3cml0ZXIuX293bmVyV3JpdGFibGVTdHJlYW07XG4gICAgICAgICAgICByZXR1cm4gV3JpdGFibGVTdHJlYW1BYm9ydChzdHJlYW0sIHJlYXNvbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckNsb3NlKHdyaXRlcikge1xuICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0gd3JpdGVyLl9vd25lcldyaXRhYmxlU3RyZWFtO1xuICAgICAgICAgICAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtQ2xvc2Uoc3RyZWFtKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyQ2xvc2VXaXRoRXJyb3JQcm9wYWdhdGlvbih3cml0ZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IHdyaXRlci5fb3duZXJXcml0YWJsZVN0cmVhbTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcbiAgICAgICAgICAgIGlmIChXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChzdHJlYW0pIHx8IHN0YXRlID09PSBcImNsb3NlZFwiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHZvaWQgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUgPT09IFwiZXJyb3JlZFwiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckNsb3NlKHdyaXRlcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckVuc3VyZUNsb3NlZFByb21pc2VSZWplY3RlZCh3cml0ZXIsIGVycm9yKSB7XG4gICAgICAgICAgICBpZiAod3JpdGVyLl9jbG9zZWRQcm9taXNlU3RhdGUgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlUmVqZWN0KHdyaXRlciwgZXJyb3IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZXNldFRvUmVqZWN0ZWQod3JpdGVyLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckVuc3VyZVJlYWR5UHJvbWlzZVJlamVjdGVkKHdyaXRlciwgZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICh3cml0ZXIuX3JlYWR5UHJvbWlzZVN0YXRlID09PSBcInBlbmRpbmdcIikge1xuICAgICAgICAgICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVqZWN0KHdyaXRlciwgZXJyb3IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc2V0VG9SZWplY3RlZCh3cml0ZXIsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyR2V0RGVzaXJlZFNpemUod3JpdGVyKSB7XG4gICAgICAgICAgICBjb25zdCBzdHJlYW0gPSB3cml0ZXIuX293bmVyV3JpdGFibGVTdHJlYW07XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHN0cmVhbS5fc3RhdGU7XG4gICAgICAgICAgICBpZiAoc3RhdGUgPT09IFwiZXJyb3JlZFwiIHx8IHN0YXRlID09PSBcImVycm9yaW5nXCIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUgPT09IFwiY2xvc2VkXCIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldERlc2lyZWRTaXplKHN0cmVhbS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyUmVsZWFzZSh3cml0ZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IHdyaXRlci5fb3duZXJXcml0YWJsZVN0cmVhbTtcbiAgICAgICAgICAgIGNvbnN0IHJlbGVhc2VkRXJyb3IgPSBuZXcgVHlwZUVycm9yKGBXcml0ZXIgd2FzIHJlbGVhc2VkIGFuZCBjYW4gbm8gbG9uZ2VyIGJlIHVzZWQgdG8gbW9uaXRvciB0aGUgc3RyZWFtJ3MgY2xvc2VkbmVzc2ApO1xuICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyRW5zdXJlUmVhZHlQcm9taXNlUmVqZWN0ZWQod3JpdGVyLCByZWxlYXNlZEVycm9yKTtcbiAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckVuc3VyZUNsb3NlZFByb21pc2VSZWplY3RlZCh3cml0ZXIsIHJlbGVhc2VkRXJyb3IpO1xuICAgICAgICAgICAgc3RyZWFtLl93cml0ZXIgPSB2b2lkIDA7XG4gICAgICAgICAgICB3cml0ZXIuX293bmVyV3JpdGFibGVTdHJlYW0gPSB2b2lkIDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcldyaXRlKHdyaXRlciwgY2h1bmspIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IHdyaXRlci5fb3duZXJXcml0YWJsZVN0cmVhbTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBzdHJlYW0uX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlcjtcbiAgICAgICAgICAgIGNvbnN0IGNodW5rU2l6ZSA9IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXRDaHVua1NpemUoY29udHJvbGxlciwgY2h1bmspO1xuICAgICAgICAgICAgaWYgKHN0cmVhbSAhPT0gd3JpdGVyLl9vd25lcldyaXRhYmxlU3RyZWFtKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRXcml0ZXJMb2NrRXhjZXB0aW9uKFwid3JpdGUgdG9cIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBzdHJlYW0uX3N0YXRlO1xuICAgICAgICAgICAgaWYgKHN0YXRlID09PSBcImVycm9yZWRcIikge1xuICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChzdHJlYW0uX3N0b3JlZEVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChzdHJlYW0pIHx8IHN0YXRlID09PSBcImNsb3NlZFwiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoXCJUaGUgc3RyZWFtIGlzIGNsb3Npbmcgb3IgY2xvc2VkIGFuZCBjYW5ub3QgYmUgd3JpdHRlbiB0b1wiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUgPT09IFwiZXJyb3JpbmdcIikge1xuICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChzdHJlYW0uX3N0b3JlZEVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBXcml0YWJsZVN0cmVhbUFkZFdyaXRlUmVxdWVzdChzdHJlYW0pO1xuICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcldyaXRlKGNvbnRyb2xsZXIsIGNodW5rLCBjaHVua1NpemUpO1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGNsb3NlU2VudGluZWwgPSB7fTtcbiAgICAgICAgICBjbGFzcyBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBjb25zdHJ1Y3RvclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdldCBhYm9ydFJlYXNvbigpIHtcbiAgICAgICAgICAgICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24kMihcImFib3J0UmVhc29uXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hYm9ydFJlYXNvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdldCBzaWduYWwoKSB7XG4gICAgICAgICAgICAgIGlmICghSXNXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uJDIoXCJzaWduYWxcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHRoaXMuX2Fib3J0Q29udHJvbGxlciA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIldyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLnNpZ25hbCBpcyBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hYm9ydENvbnRyb2xsZXIuc2lnbmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3IoZTIgPSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24kMihcImVycm9yXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtLl9zdGF0ZTtcbiAgICAgICAgICAgICAgaWYgKHN0YXRlICE9PSBcIndyaXRhYmxlXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKHRoaXMsIGUyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFtBYm9ydFN0ZXBzXShyZWFzb24pIHtcbiAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fYWJvcnRBbGdvcml0aG0ocmVhc29uKTtcbiAgICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyh0aGlzKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFtFcnJvclN0ZXBzXSgpIHtcbiAgICAgICAgICAgICAgUmVzZXRRdWV1ZSh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUsIHtcbiAgICAgICAgICAgIGFib3J0UmVhc29uOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgICAgIHNpZ25hbDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgICAgICBlcnJvcjogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAodHlwZW9mIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnID09PSBcInN5bWJvbFwiKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBcIldyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJcIixcbiAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gSXNXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHgyKSB7XG4gICAgICAgICAgICBpZiAoIXR5cGVJc09iamVjdCh4MikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeDIsIFwiX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbVwiKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geDIgaW5zdGFuY2VvZiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBTZXRVcFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIoc3RyZWFtLCBjb250cm9sbGVyLCBzdGFydEFsZ29yaXRobSwgd3JpdGVBbGdvcml0aG0sIGNsb3NlQWxnb3JpdGhtLCBhYm9ydEFsZ29yaXRobSwgaGlnaFdhdGVyTWFyaywgc2l6ZUFsZ29yaXRobSkge1xuICAgICAgICAgICAgY29udHJvbGxlci5fY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtID0gc3RyZWFtO1xuICAgICAgICAgICAgc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICAgICAgICAgICAgY29udHJvbGxlci5fcXVldWUgPSB2b2lkIDA7XG4gICAgICAgICAgICBjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIFJlc2V0UXVldWUoY29udHJvbGxlcik7XG4gICAgICAgICAgICBjb250cm9sbGVyLl9hYm9ydFJlYXNvbiA9IHZvaWQgMDtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuX2Fib3J0Q29udHJvbGxlciA9IGNyZWF0ZUFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICAgICAgY29udHJvbGxlci5fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgY29udHJvbGxlci5fc3RyYXRlZ3lTaXplQWxnb3JpdGhtID0gc2l6ZUFsZ29yaXRobTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuX3N0cmF0ZWd5SFdNID0gaGlnaFdhdGVyTWFyaztcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuX3dyaXRlQWxnb3JpdGhtID0gd3JpdGVBbGdvcml0aG07XG4gICAgICAgICAgICBjb250cm9sbGVyLl9jbG9zZUFsZ29yaXRobSA9IGNsb3NlQWxnb3JpdGhtO1xuICAgICAgICAgICAgY29udHJvbGxlci5fYWJvcnRBbGdvcml0aG0gPSBhYm9ydEFsZ29yaXRobTtcbiAgICAgICAgICAgIGNvbnN0IGJhY2twcmVzc3VyZSA9IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXRCYWNrcHJlc3N1cmUoY29udHJvbGxlcik7XG4gICAgICAgICAgICBXcml0YWJsZVN0cmVhbVVwZGF0ZUJhY2twcmVzc3VyZShzdHJlYW0sIGJhY2twcmVzc3VyZSk7XG4gICAgICAgICAgICBjb25zdCBzdGFydFJlc3VsdCA9IHN0YXJ0QWxnb3JpdGhtKCk7XG4gICAgICAgICAgICBjb25zdCBzdGFydFByb21pc2UgPSBwcm9taXNlUmVzb2x2ZWRXaXRoKHN0YXJ0UmVzdWx0KTtcbiAgICAgICAgICAgIHVwb25Qcm9taXNlKHN0YXJ0UHJvbWlzZSwgKCkgPT4ge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLl9zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckFkdmFuY2VRdWV1ZUlmTmVlZGVkKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgfSwgKHIyMikgPT4ge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLl9zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1EZWFsV2l0aFJlamVjdGlvbihzdHJlYW0sIHIyMik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gU2V0VXBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRnJvbVVuZGVybHlpbmdTaW5rKHN0cmVhbSwgdW5kZXJseWluZ1NpbmssIGhpZ2hXYXRlck1hcmssIHNpemVBbGdvcml0aG0pIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBPYmplY3QuY3JlYXRlKFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlKTtcbiAgICAgICAgICAgIGxldCBzdGFydEFsZ29yaXRobSA9ICgpID0+IHZvaWQgMDtcbiAgICAgICAgICAgIGxldCB3cml0ZUFsZ29yaXRobSA9ICgpID0+IHByb21pc2VSZXNvbHZlZFdpdGgodm9pZCAwKTtcbiAgICAgICAgICAgIGxldCBjbG9zZUFsZ29yaXRobSA9ICgpID0+IHByb21pc2VSZXNvbHZlZFdpdGgodm9pZCAwKTtcbiAgICAgICAgICAgIGxldCBhYm9ydEFsZ29yaXRobSA9ICgpID0+IHByb21pc2VSZXNvbHZlZFdpdGgodm9pZCAwKTtcbiAgICAgICAgICAgIGlmICh1bmRlcmx5aW5nU2luay5zdGFydCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIHN0YXJ0QWxnb3JpdGhtID0gKCkgPT4gdW5kZXJseWluZ1Npbmsuc3RhcnQoY29udHJvbGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodW5kZXJseWluZ1Npbmsud3JpdGUgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICB3cml0ZUFsZ29yaXRobSA9IChjaHVuaykgPT4gdW5kZXJseWluZ1Npbmsud3JpdGUoY2h1bmssIGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVuZGVybHlpbmdTaW5rLmNsb3NlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgY2xvc2VBbGdvcml0aG0gPSAoKSA9PiB1bmRlcmx5aW5nU2luay5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVuZGVybHlpbmdTaW5rLmFib3J0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgYWJvcnRBbGdvcml0aG0gPSAocmVhc29uKSA9PiB1bmRlcmx5aW5nU2luay5hYm9ydChyZWFzb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgU2V0VXBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHN0cmVhbSwgY29udHJvbGxlciwgc3RhcnRBbGdvcml0aG0sIHdyaXRlQWxnb3JpdGhtLCBjbG9zZUFsZ29yaXRobSwgYWJvcnRBbGdvcml0aG0sIGhpZ2hXYXRlck1hcmssIHNpemVBbGdvcml0aG0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuX3dyaXRlQWxnb3JpdGhtID0gdm9pZCAwO1xuICAgICAgICAgICAgY29udHJvbGxlci5fY2xvc2VBbGdvcml0aG0gPSB2b2lkIDA7XG4gICAgICAgICAgICBjb250cm9sbGVyLl9hYm9ydEFsZ29yaXRobSA9IHZvaWQgMDtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuX3N0cmF0ZWd5U2l6ZUFsZ29yaXRobSA9IHZvaWQgMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsb3NlKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIEVucXVldWVWYWx1ZVdpdGhTaXplKGNvbnRyb2xsZXIsIGNsb3NlU2VudGluZWwsIDApO1xuICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckFkdmFuY2VRdWV1ZUlmTmVlZGVkKGNvbnRyb2xsZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0Q2h1bmtTaXplKGNvbnRyb2xsZXIsIGNodW5rKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gY29udHJvbGxlci5fc3RyYXRlZ3lTaXplQWxnb3JpdGhtKGNodW5rKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGNodW5rU2l6ZUUpIHtcbiAgICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9ySWZOZWVkZWQoY29udHJvbGxlciwgY2h1bmtTaXplRSk7XG4gICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0RGVzaXJlZFNpemUoY29udHJvbGxlcikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuX3N0cmF0ZWd5SFdNIC0gY29udHJvbGxlci5fcXVldWVUb3RhbFNpemU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJXcml0ZShjb250cm9sbGVyLCBjaHVuaywgY2h1bmtTaXplKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBFbnF1ZXVlVmFsdWVXaXRoU2l6ZShjb250cm9sbGVyLCBjaHVuaywgY2h1bmtTaXplKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVucXVldWVFKSB7XG4gICAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcklmTmVlZGVkKGNvbnRyb2xsZXIsIGVucXVldWVFKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtO1xuICAgICAgICAgICAgaWYgKCFXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChzdHJlYW0pICYmIHN0cmVhbS5fc3RhdGUgPT09IFwid3JpdGFibGVcIikge1xuICAgICAgICAgICAgICBjb25zdCBiYWNrcHJlc3N1cmUgPSBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0QmFja3ByZXNzdXJlKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgICBXcml0YWJsZVN0cmVhbVVwZGF0ZUJhY2twcmVzc3VyZShzdHJlYW0sIGJhY2twcmVzc3VyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQWR2YW5jZVF1ZXVlSWZOZWVkZWQoY29udHJvbGxlcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJBZHZhbmNlUXVldWVJZk5lZWRlZChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkV3JpdGFibGVTdHJlYW07XG4gICAgICAgICAgICBpZiAoIWNvbnRyb2xsZXIuX3N0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0cmVhbS5faW5GbGlnaHRXcml0ZVJlcXVlc3QgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHN0cmVhbS5fc3RhdGU7XG4gICAgICAgICAgICBpZiAoc3RhdGUgPT09IFwiZXJyb3JpbmdcIikge1xuICAgICAgICAgICAgICBXcml0YWJsZVN0cmVhbUZpbmlzaEVycm9yaW5nKHN0cmVhbSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb250cm9sbGVyLl9xdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBQZWVrUXVldWVWYWx1ZShjb250cm9sbGVyKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gY2xvc2VTZW50aW5lbCkge1xuICAgICAgICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyUHJvY2Vzc0Nsb3NlKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlclByb2Nlc3NXcml0ZShjb250cm9sbGVyLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcklmTmVlZGVkKGNvbnRyb2xsZXIsIGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoY29udHJvbGxlci5fY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtLl9zdGF0ZSA9PT0gXCJ3cml0YWJsZVwiKSB7XG4gICAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJQcm9jZXNzQ2xvc2UoY29udHJvbGxlcikge1xuICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtO1xuICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1NYXJrQ2xvc2VSZXF1ZXN0SW5GbGlnaHQoc3RyZWFtKTtcbiAgICAgICAgICAgIERlcXVldWVWYWx1ZShjb250cm9sbGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHNpbmtDbG9zZVByb21pc2UgPSBjb250cm9sbGVyLl9jbG9zZUFsZ29yaXRobSgpO1xuICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKTtcbiAgICAgICAgICAgIHVwb25Qcm9taXNlKHNpbmtDbG9zZVByb21pc2UsICgpID0+IHtcbiAgICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodENsb3NlKHN0cmVhbSk7XG4gICAgICAgICAgICB9LCAocmVhc29uKSA9PiB7XG4gICAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRDbG9zZVdpdGhFcnJvcihzdHJlYW0sIHJlYXNvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlclByb2Nlc3NXcml0ZShjb250cm9sbGVyLCBjaHVuaykge1xuICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtO1xuICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1NYXJrRmlyc3RXcml0ZVJlcXVlc3RJbkZsaWdodChzdHJlYW0pO1xuICAgICAgICAgICAgY29uc3Qgc2lua1dyaXRlUHJvbWlzZSA9IGNvbnRyb2xsZXIuX3dyaXRlQWxnb3JpdGhtKGNodW5rKTtcbiAgICAgICAgICAgIHVwb25Qcm9taXNlKHNpbmtXcml0ZVByb21pc2UsICgpID0+IHtcbiAgICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodFdyaXRlKHN0cmVhbSk7XG4gICAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcbiAgICAgICAgICAgICAgRGVxdWV1ZVZhbHVlKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgICBpZiAoIVdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KHN0cmVhbSkgJiYgc3RhdGUgPT09IFwid3JpdGFibGVcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhY2twcmVzc3VyZSA9IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXRCYWNrcHJlc3N1cmUoY29udHJvbGxlcik7XG4gICAgICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1VcGRhdGVCYWNrcHJlc3N1cmUoc3RyZWFtLCBiYWNrcHJlc3N1cmUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJBZHZhbmNlUXVldWVJZk5lZWRlZChjb250cm9sbGVyKTtcbiAgICAgICAgICAgIH0sIChyZWFzb24pID0+IHtcbiAgICAgICAgICAgICAgaWYgKHN0cmVhbS5fc3RhdGUgPT09IFwid3JpdGFibGVcIikge1xuICAgICAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodFdyaXRlV2l0aEVycm9yKHN0cmVhbSwgcmVhc29uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0QmFja3ByZXNzdXJlKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlc2lyZWRTaXplID0gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldERlc2lyZWRTaXplKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGRlc2lyZWRTaXplIDw9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBlcnJvcikge1xuICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtO1xuICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKTtcbiAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtU3RhcnRFcnJvcmluZyhzdHJlYW0sIGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbiQyKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKGBXcml0YWJsZVN0cmVhbS5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgV3JpdGFibGVTdHJlYW1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uJDIobmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoYFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gZGVmYXVsdFdyaXRlckJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoYFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlci5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJMb2NrRXhjZXB0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IFwiICsgbmFtZSArIFwiIGEgc3RyZWFtIHVzaW5nIGEgcmVsZWFzZWQgd3JpdGVyXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemUod3JpdGVyKSB7XG4gICAgICAgICAgICB3cml0ZXIuX2Nsb3NlZFByb21pc2UgPSBuZXdQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgd3JpdGVyLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgICB3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICAgICAgICB3cml0ZXIuX2Nsb3NlZFByb21pc2VTdGF0ZSA9IFwicGVuZGluZ1wiO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQod3JpdGVyLCByZWFzb24pIHtcbiAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZSh3cml0ZXIpO1xuICAgICAgICAgICAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZWplY3Qod3JpdGVyLCByZWFzb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1Jlc29sdmVkKHdyaXRlcikge1xuICAgICAgICAgICAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VJbml0aWFsaXplKHdyaXRlcik7XG4gICAgICAgICAgICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlc29sdmUod3JpdGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZWplY3Qod3JpdGVyLCByZWFzb24pIHtcbiAgICAgICAgICAgIGlmICh3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0UHJvbWlzZUlzSGFuZGxlZFRvVHJ1ZSh3cml0ZXIuX2Nsb3NlZFByb21pc2UpO1xuICAgICAgICAgICAgd3JpdGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdChyZWFzb24pO1xuICAgICAgICAgICAgd3JpdGVyLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUgPSB2b2lkIDA7XG4gICAgICAgICAgICB3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0ID0gdm9pZCAwO1xuICAgICAgICAgICAgd3JpdGVyLl9jbG9zZWRQcm9taXNlU3RhdGUgPSBcInJlamVjdGVkXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlUmVzZXRUb1JlamVjdGVkKHdyaXRlciwgcmVhc29uKSB7XG4gICAgICAgICAgICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkKHdyaXRlciwgcmVhc29uKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZXNvbHZlKHdyaXRlcikge1xuICAgICAgICAgICAgaWYgKHdyaXRlci5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd3JpdGVyLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUodm9pZCAwKTtcbiAgICAgICAgICAgIHdyaXRlci5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlID0gdm9pZCAwO1xuICAgICAgICAgICAgd3JpdGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdCA9IHZvaWQgMDtcbiAgICAgICAgICAgIHdyaXRlci5fY2xvc2VkUHJvbWlzZVN0YXRlID0gXCJyZXNvbHZlZFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZSh3cml0ZXIpIHtcbiAgICAgICAgICAgIHdyaXRlci5fcmVhZHlQcm9taXNlID0gbmV3UHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgIHdyaXRlci5fcmVhZHlQcm9taXNlX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgICB3cml0ZXIuX3JlYWR5UHJvbWlzZV9yZWplY3QgPSByZWplY3Q7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHdyaXRlci5fcmVhZHlQcm9taXNlU3RhdGUgPSBcInBlbmRpbmdcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkKHdyaXRlciwgcmVhc29uKSB7XG4gICAgICAgICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZSh3cml0ZXIpO1xuICAgICAgICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlamVjdCh3cml0ZXIsIHJlYXNvbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplQXNSZXNvbHZlZCh3cml0ZXIpIHtcbiAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplKHdyaXRlcik7XG4gICAgICAgICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzb2x2ZSh3cml0ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVqZWN0KHdyaXRlciwgcmVhc29uKSB7XG4gICAgICAgICAgICBpZiAod3JpdGVyLl9yZWFkeVByb21pc2VfcmVqZWN0ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0UHJvbWlzZUlzSGFuZGxlZFRvVHJ1ZSh3cml0ZXIuX3JlYWR5UHJvbWlzZSk7XG4gICAgICAgICAgICB3cml0ZXIuX3JlYWR5UHJvbWlzZV9yZWplY3QocmVhc29uKTtcbiAgICAgICAgICAgIHdyaXRlci5fcmVhZHlQcm9taXNlX3Jlc29sdmUgPSB2b2lkIDA7XG4gICAgICAgICAgICB3cml0ZXIuX3JlYWR5UHJvbWlzZV9yZWplY3QgPSB2b2lkIDA7XG4gICAgICAgICAgICB3cml0ZXIuX3JlYWR5UHJvbWlzZVN0YXRlID0gXCJyZWplY3RlZFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzZXQod3JpdGVyKSB7XG4gICAgICAgICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZSh3cml0ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzZXRUb1JlamVjdGVkKHdyaXRlciwgcmVhc29uKSB7XG4gICAgICAgICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQod3JpdGVyLCByZWFzb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzb2x2ZSh3cml0ZXIpIHtcbiAgICAgICAgICAgIGlmICh3cml0ZXIuX3JlYWR5UHJvbWlzZV9yZXNvbHZlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd3JpdGVyLl9yZWFkeVByb21pc2VfcmVzb2x2ZSh2b2lkIDApO1xuICAgICAgICAgICAgd3JpdGVyLl9yZWFkeVByb21pc2VfcmVzb2x2ZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIHdyaXRlci5fcmVhZHlQcm9taXNlX3JlamVjdCA9IHZvaWQgMDtcbiAgICAgICAgICAgIHdyaXRlci5fcmVhZHlQcm9taXNlU3RhdGUgPSBcImZ1bGZpbGxlZFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBOYXRpdmVET01FeGNlcHRpb24gPSB0eXBlb2YgRE9NRXhjZXB0aW9uICE9PSBcInVuZGVmaW5lZFwiID8gRE9NRXhjZXB0aW9uIDogdm9pZCAwO1xuICAgICAgICAgIGZ1bmN0aW9uIGlzRE9NRXhjZXB0aW9uQ29uc3RydWN0b3IoY3Rvcikge1xuICAgICAgICAgICAgaWYgKCEodHlwZW9mIGN0b3IgPT09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgY3RvciA9PT0gXCJvYmplY3RcIikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgbmV3IGN0b3IoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IGNhdGNoIChfYSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZURPTUV4Y2VwdGlvblBvbHlmaWxsKCkge1xuICAgICAgICAgICAgY29uc3QgY3RvciA9IGZ1bmN0aW9uIERPTUV4Y2VwdGlvbjMobWVzc2FnZSwgbmFtZSkge1xuICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8IFwiXCI7XG4gICAgICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWUgfHwgXCJFcnJvclwiO1xuICAgICAgICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0b3IucHJvdG90eXBlLCBcImNvbnN0cnVjdG9yXCIsIHsgdmFsdWU6IGN0b3IsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG4gICAgICAgICAgICByZXR1cm4gY3RvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgRE9NRXhjZXB0aW9uJDEgPSBpc0RPTUV4Y2VwdGlvbkNvbnN0cnVjdG9yKE5hdGl2ZURPTUV4Y2VwdGlvbikgPyBOYXRpdmVET01FeGNlcHRpb24gOiBjcmVhdGVET01FeGNlcHRpb25Qb2x5ZmlsbCgpO1xuICAgICAgICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtUGlwZVRvKHNvdXJjZSwgZGVzdCwgcHJldmVudENsb3NlLCBwcmV2ZW50QWJvcnQsIHByZXZlbnRDYW5jZWwsIHNpZ25hbCkge1xuICAgICAgICAgICAgY29uc3QgcmVhZGVyID0gQWNxdWlyZVJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcihzb3VyY2UpO1xuICAgICAgICAgICAgY29uc3Qgd3JpdGVyID0gQWNxdWlyZVdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcihkZXN0KTtcbiAgICAgICAgICAgIHNvdXJjZS5fZGlzdHVyYmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBzaHV0dGluZ0Rvd24gPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBjdXJyZW50V3JpdGUgPSBwcm9taXNlUmVzb2x2ZWRXaXRoKHZvaWQgMCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3UHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgIGxldCBhYm9ydEFsZ29yaXRobTtcbiAgICAgICAgICAgICAgaWYgKHNpZ25hbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgYWJvcnRBbGdvcml0aG0gPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBET01FeGNlcHRpb24kMShcIkFib3J0ZWRcIiwgXCJBYm9ydEVycm9yXCIpO1xuICAgICAgICAgICAgICAgICAgY29uc3QgYWN0aW9ucyA9IFtdO1xuICAgICAgICAgICAgICAgICAgaWYgKCFwcmV2ZW50QWJvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9ucy5wdXNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVzdC5fc3RhdGUgPT09IFwid3JpdGFibGVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtQWJvcnQoZGVzdCwgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh2b2lkIDApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmICghcHJldmVudENhbmNlbCkge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25zLnB1c2goKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuX3N0YXRlID09PSBcInJlYWRhYmxlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBSZWFkYWJsZVN0cmVhbUNhbmNlbChzb3VyY2UsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodm9pZCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBzaHV0ZG93bldpdGhBY3Rpb24oKCkgPT4gUHJvbWlzZS5hbGwoYWN0aW9ucy5tYXAoKGFjdGlvbikgPT4gYWN0aW9uKCkpKSwgdHJ1ZSwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICBhYm9ydEFsZ29yaXRobSgpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGFib3J0QWxnb3JpdGhtKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmdW5jdGlvbiBwaXBlTG9vcCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3UHJvbWlzZSgocmVzb2x2ZUxvb3AsIHJlamVjdExvb3ApID0+IHtcbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG5leHQoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVMb29wKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgUGVyZm9ybVByb21pc2VUaGVuKHBpcGVTdGVwKCksIG5leHQsIHJlamVjdExvb3ApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBuZXh0KGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmdW5jdGlvbiBwaXBlU3RlcCgpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2h1dHRpbmdEb3duKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBlcmZvcm1Qcm9taXNlVGhlbih3cml0ZXIuX3JlYWR5UHJvbWlzZSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld1Byb21pc2UoKHJlc29sdmVSZWFkLCByZWplY3RSZWFkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlclJlYWQocmVhZGVyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgX2NodW5rU3RlcHM6IChjaHVuaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFdyaXRlID0gUGVyZm9ybVByb21pc2VUaGVuKFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcldyaXRlKHdyaXRlciwgY2h1bmspLCB2b2lkIDAsIG5vb3AyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVSZWFkKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIF9jbG9zZVN0ZXBzOiAoKSA9PiByZXNvbHZlUmVhZCh0cnVlKSxcbiAgICAgICAgICAgICAgICAgICAgICBfZXJyb3JTdGVwczogcmVqZWN0UmVhZFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlzT3JCZWNvbWVzRXJyb3JlZChzb3VyY2UsIHJlYWRlci5fY2xvc2VkUHJvbWlzZSwgKHN0b3JlZEVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFwcmV2ZW50QWJvcnQpIHtcbiAgICAgICAgICAgICAgICAgIHNodXRkb3duV2l0aEFjdGlvbigoKSA9PiBXcml0YWJsZVN0cmVhbUFib3J0KGRlc3QsIHN0b3JlZEVycm9yKSwgdHJ1ZSwgc3RvcmVkRXJyb3IpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzaHV0ZG93bih0cnVlLCBzdG9yZWRFcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaXNPckJlY29tZXNFcnJvcmVkKGRlc3QsIHdyaXRlci5fY2xvc2VkUHJvbWlzZSwgKHN0b3JlZEVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFwcmV2ZW50Q2FuY2VsKSB7XG4gICAgICAgICAgICAgICAgICBzaHV0ZG93bldpdGhBY3Rpb24oKCkgPT4gUmVhZGFibGVTdHJlYW1DYW5jZWwoc291cmNlLCBzdG9yZWRFcnJvciksIHRydWUsIHN0b3JlZEVycm9yKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgc2h1dGRvd24odHJ1ZSwgc3RvcmVkRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlzT3JCZWNvbWVzQ2xvc2VkKHNvdXJjZSwgcmVhZGVyLl9jbG9zZWRQcm9taXNlLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFwcmV2ZW50Q2xvc2UpIHtcbiAgICAgICAgICAgICAgICAgIHNodXRkb3duV2l0aEFjdGlvbigoKSA9PiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJDbG9zZVdpdGhFcnJvclByb3BhZ2F0aW9uKHdyaXRlcikpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzaHV0ZG93bigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmIChXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChkZXN0KSB8fCBkZXN0Ll9zdGF0ZSA9PT0gXCJjbG9zZWRcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlc3RDbG9zZWQgPSBuZXcgVHlwZUVycm9yKFwidGhlIGRlc3RpbmF0aW9uIHdyaXRhYmxlIHN0cmVhbSBjbG9zZWQgYmVmb3JlIGFsbCBkYXRhIGNvdWxkIGJlIHBpcGVkIHRvIGl0XCIpO1xuICAgICAgICAgICAgICAgIGlmICghcHJldmVudENhbmNlbCkge1xuICAgICAgICAgICAgICAgICAgc2h1dGRvd25XaXRoQWN0aW9uKCgpID0+IFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHNvdXJjZSwgZGVzdENsb3NlZCksIHRydWUsIGRlc3RDbG9zZWQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzaHV0ZG93bih0cnVlLCBkZXN0Q2xvc2VkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc2V0UHJvbWlzZUlzSGFuZGxlZFRvVHJ1ZShwaXBlTG9vcCgpKTtcbiAgICAgICAgICAgICAgZnVuY3Rpb24gd2FpdEZvcldyaXRlc1RvRmluaXNoKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9sZEN1cnJlbnRXcml0ZSA9IGN1cnJlbnRXcml0ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGVyZm9ybVByb21pc2VUaGVuKGN1cnJlbnRXcml0ZSwgKCkgPT4gb2xkQ3VycmVudFdyaXRlICE9PSBjdXJyZW50V3JpdGUgPyB3YWl0Rm9yV3JpdGVzVG9GaW5pc2goKSA6IHZvaWQgMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZnVuY3Rpb24gaXNPckJlY29tZXNFcnJvcmVkKHN0cmVhbSwgcHJvbWlzZSwgYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmVhbS5fc3RhdGUgPT09IFwiZXJyb3JlZFwiKSB7XG4gICAgICAgICAgICAgICAgICBhY3Rpb24oc3RyZWFtLl9zdG9yZWRFcnJvcik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHVwb25SZWplY3Rpb24ocHJvbWlzZSwgYWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZnVuY3Rpb24gaXNPckJlY29tZXNDbG9zZWQoc3RyZWFtLCBwcm9taXNlLCBhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gXCJjbG9zZWRcIikge1xuICAgICAgICAgICAgICAgICAgYWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHVwb25GdWxmaWxsbWVudChwcm9taXNlLCBhY3Rpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmdW5jdGlvbiBzaHV0ZG93bldpdGhBY3Rpb24oYWN0aW9uLCBvcmlnaW5hbElzRXJyb3IsIG9yaWdpbmFsRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2h1dHRpbmdEb3duKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNodXR0aW5nRG93biA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGRlc3QuX3N0YXRlID09PSBcIndyaXRhYmxlXCIgJiYgIVdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KGRlc3QpKSB7XG4gICAgICAgICAgICAgICAgICB1cG9uRnVsZmlsbG1lbnQod2FpdEZvcldyaXRlc1RvRmluaXNoKCksIGRvVGhlUmVzdCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGRvVGhlUmVzdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBkb1RoZVJlc3QoKSB7XG4gICAgICAgICAgICAgICAgICB1cG9uUHJvbWlzZShhY3Rpb24oKSwgKCkgPT4gZmluYWxpemUob3JpZ2luYWxJc0Vycm9yLCBvcmlnaW5hbEVycm9yKSwgKG5ld0Vycm9yKSA9PiBmaW5hbGl6ZSh0cnVlLCBuZXdFcnJvcikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmdW5jdGlvbiBzaHV0ZG93bihpc0Vycm9yLCBlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChzaHV0dGluZ0Rvd24pIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2h1dHRpbmdEb3duID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoZGVzdC5fc3RhdGUgPT09IFwid3JpdGFibGVcIiAmJiAhV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQoZGVzdCkpIHtcbiAgICAgICAgICAgICAgICAgIHVwb25GdWxmaWxsbWVudCh3YWl0Rm9yV3JpdGVzVG9GaW5pc2goKSwgKCkgPT4gZmluYWxpemUoaXNFcnJvciwgZXJyb3IpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZmluYWxpemUoaXNFcnJvciwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmdW5jdGlvbiBmaW5hbGl6ZShpc0Vycm9yLCBlcnJvcikge1xuICAgICAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlclJlbGVhc2Uod3JpdGVyKTtcbiAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHJlYWRlcik7XG4gICAgICAgICAgICAgICAgaWYgKHNpZ25hbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGFib3J0QWxnb3JpdGhtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJlc29sdmUodm9pZCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjbGFzcyBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBjb25zdHJ1Y3RvclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdldCBkZXNpcmVkU2l6ZSgpIHtcbiAgICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24kMShcImRlc2lyZWRTaXplXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0RGVzaXJlZFNpemUodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbG9zZSgpIHtcbiAgICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24kMShcImNsb3NlXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbkNsb3NlT3JFbnF1ZXVlKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBzdHJlYW0gaXMgbm90IGluIGEgc3RhdGUgdGhhdCBwZXJtaXRzIGNsb3NlXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZSh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVucXVldWUoY2h1bmsgPSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24kMShcImVucXVldWVcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FuQ2xvc2VPckVucXVldWUodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIHN0cmVhbSBpcyBub3QgaW4gYSBzdGF0ZSB0aGF0IHBlcm1pdHMgZW5xdWV1ZVwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWUodGhpcywgY2h1bmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3IoZTIgPSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24kMShcImVycm9yXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcih0aGlzLCBlMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBbQ2FuY2VsU3RlcHNdKHJlYXNvbikge1xuICAgICAgICAgICAgICBSZXNldFF1ZXVlKHRoaXMpO1xuICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9jYW5jZWxBbGdvcml0aG0ocmVhc29uKTtcbiAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyh0aGlzKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFtQdWxsU3RlcHNdKHJlYWRSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IHRoaXMuX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbTtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX3F1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IERlcXVldWVWYWx1ZSh0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2xvc2VSZXF1ZXN0ZWQgJiYgdGhpcy5fcXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1DbG9zZShzdHJlYW0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVhZFJlcXVlc3QuX2NodW5rU3RlcHMoY2h1bmspO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtQWRkUmVhZFJlcXVlc3Qoc3RyZWFtLCByZWFkUmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQodGhpcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUsIHtcbiAgICAgICAgICAgIGNsb3NlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgICAgIGVucXVldWU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICAgICAgZXJyb3I6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICAgICAgZGVzaXJlZFNpemU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZyA9PT0gXCJzeW1ib2xcIikge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLCBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZywge1xuICAgICAgICAgICAgICB2YWx1ZTogXCJSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyXCIsXG4gICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIElzUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcih4Mikge1xuICAgICAgICAgICAgaWYgKCF0eXBlSXNPYmplY3QoeDIpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgyLCBcIl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW1cIikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHgyIGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcikge1xuICAgICAgICAgICAgY29uc3Qgc2hvdWxkUHVsbCA9IFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJTaG91bGRDYWxsUHVsbChjb250cm9sbGVyKTtcbiAgICAgICAgICAgIGlmICghc2hvdWxkUHVsbCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29udHJvbGxlci5fcHVsbGluZykge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLl9wdWxsQWdhaW4gPSB0cnVlO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250cm9sbGVyLl9wdWxsaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IHB1bGxQcm9taXNlID0gY29udHJvbGxlci5fcHVsbEFsZ29yaXRobSgpO1xuICAgICAgICAgICAgdXBvblByb21pc2UocHVsbFByb21pc2UsICgpID0+IHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5fcHVsbGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICBpZiAoY29udHJvbGxlci5fcHVsbEFnYWluKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5fcHVsbEFnYWluID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIChlMikgPT4ge1xuICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgZTIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJTaG91bGRDYWxsUHVsbChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW07XG4gICAgICAgICAgICBpZiAoIVJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYW5DbG9zZU9yRW5xdWV1ZShjb250cm9sbGVyKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWNvbnRyb2xsZXIuX3N0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKElzUmVhZGFibGVTdHJlYW1Mb2NrZWQoc3RyZWFtKSAmJiBSZWFkYWJsZVN0cmVhbUdldE51bVJlYWRSZXF1ZXN0cyhzdHJlYW0pID4gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRlc2lyZWRTaXplID0gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldERlc2lyZWRTaXplKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgaWYgKGRlc2lyZWRTaXplID4gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLl9wdWxsQWxnb3JpdGhtID0gdm9pZCAwO1xuICAgICAgICAgICAgY29udHJvbGxlci5fY2FuY2VsQWxnb3JpdGhtID0gdm9pZCAwO1xuICAgICAgICAgICAgY29udHJvbGxlci5fc3RyYXRlZ3lTaXplQWxnb3JpdGhtID0gdm9pZCAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xvc2UoY29udHJvbGxlcikge1xuICAgICAgICAgICAgaWYgKCFSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FuQ2xvc2VPckVucXVldWUoY29udHJvbGxlcikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlU3RyZWFtO1xuICAgICAgICAgICAgY29udHJvbGxlci5fY2xvc2VSZXF1ZXN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIuX3F1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbUNsb3NlKHN0cmVhbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlKGNvbnRyb2xsZXIsIGNodW5rKSB7XG4gICAgICAgICAgICBpZiAoIVJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYW5DbG9zZU9yRW5xdWV1ZShjb250cm9sbGVyKSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW07XG4gICAgICAgICAgICBpZiAoSXNSZWFkYWJsZVN0cmVhbUxvY2tlZChzdHJlYW0pICYmIFJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZFJlcXVlc3RzKHN0cmVhbSkgPiAwKSB7XG4gICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRnVsZmlsbFJlYWRSZXF1ZXN0KHN0cmVhbSwgY2h1bmssIGZhbHNlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGxldCBjaHVua1NpemU7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY2h1bmtTaXplID0gY29udHJvbGxlci5fc3RyYXRlZ3lTaXplQWxnb3JpdGhtKGNodW5rKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoY2h1bmtTaXplRSkge1xuICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBjaHVua1NpemVFKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBjaHVua1NpemVFO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgRW5xdWV1ZVZhbHVlV2l0aFNpemUoY29udHJvbGxlciwgY2h1bmssIGNodW5rU2l6ZSk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVucXVldWVFKSB7XG4gICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIGVucXVldWVFKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlbnF1ZXVlRTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBlMikge1xuICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlU3RyZWFtO1xuICAgICAgICAgICAgaWYgKHN0cmVhbS5fc3RhdGUgIT09IFwicmVhZGFibGVcIikge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSZXNldFF1ZXVlKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKTtcbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRXJyb3Ioc3RyZWFtLCBlMik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZShjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbS5fc3RhdGU7XG4gICAgICAgICAgICBpZiAoc3RhdGUgPT09IFwiZXJyb3JlZFwiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlID09PSBcImNsb3NlZFwiKSB7XG4gICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuX3N0cmF0ZWd5SFdNIC0gY29udHJvbGxlci5fcXVldWVUb3RhbFNpemU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJIYXNCYWNrcHJlc3N1cmUoY29udHJvbGxlcikge1xuICAgICAgICAgICAgaWYgKFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJTaG91bGRDYWxsUHVsbChjb250cm9sbGVyKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbkNsb3NlT3JFbnF1ZXVlKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlU3RyZWFtLl9zdGF0ZTtcbiAgICAgICAgICAgIGlmICghY29udHJvbGxlci5fY2xvc2VSZXF1ZXN0ZWQgJiYgc3RhdGUgPT09IFwicmVhZGFibGVcIikge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gU2V0VXBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHN0cmVhbSwgY29udHJvbGxlciwgc3RhcnRBbGdvcml0aG0sIHB1bGxBbGdvcml0aG0sIGNhbmNlbEFsZ29yaXRobSwgaGlnaFdhdGVyTWFyaywgc2l6ZUFsZ29yaXRobSkge1xuICAgICAgICAgICAgY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlU3RyZWFtID0gc3RyZWFtO1xuICAgICAgICAgICAgY29udHJvbGxlci5fcXVldWUgPSB2b2lkIDA7XG4gICAgICAgICAgICBjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIFJlc2V0UXVldWUoY29udHJvbGxlcik7XG4gICAgICAgICAgICBjb250cm9sbGVyLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICBjb250cm9sbGVyLl9jbG9zZVJlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgY29udHJvbGxlci5fcHVsbEFnYWluID0gZmFsc2U7XG4gICAgICAgICAgICBjb250cm9sbGVyLl9wdWxsaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBjb250cm9sbGVyLl9zdHJhdGVneVNpemVBbGdvcml0aG0gPSBzaXplQWxnb3JpdGhtO1xuICAgICAgICAgICAgY29udHJvbGxlci5fc3RyYXRlZ3lIV00gPSBoaWdoV2F0ZXJNYXJrO1xuICAgICAgICAgICAgY29udHJvbGxlci5fcHVsbEFsZ29yaXRobSA9IHB1bGxBbGdvcml0aG07XG4gICAgICAgICAgICBjb250cm9sbGVyLl9jYW5jZWxBbGdvcml0aG0gPSBjYW5jZWxBbGdvcml0aG07XG4gICAgICAgICAgICBzdHJlYW0uX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gICAgICAgICAgICBjb25zdCBzdGFydFJlc3VsdCA9IHN0YXJ0QWxnb3JpdGhtKCk7XG4gICAgICAgICAgICB1cG9uUHJvbWlzZShwcm9taXNlUmVzb2x2ZWRXaXRoKHN0YXJ0UmVzdWx0KSwgKCkgPT4ge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLl9zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcik7XG4gICAgICAgICAgICB9LCAocjIyKSA9PiB7XG4gICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCByMjIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFNldFVwUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckZyb21VbmRlcmx5aW5nU291cmNlKHN0cmVhbSwgdW5kZXJseWluZ1NvdXJjZSwgaGlnaFdhdGVyTWFyaywgc2l6ZUFsZ29yaXRobSkge1xuICAgICAgICAgICAgY29uc3QgY29udHJvbGxlciA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUpO1xuICAgICAgICAgICAgbGV0IHN0YXJ0QWxnb3JpdGhtID0gKCkgPT4gdm9pZCAwO1xuICAgICAgICAgICAgbGV0IHB1bGxBbGdvcml0aG0gPSAoKSA9PiBwcm9taXNlUmVzb2x2ZWRXaXRoKHZvaWQgMCk7XG4gICAgICAgICAgICBsZXQgY2FuY2VsQWxnb3JpdGhtID0gKCkgPT4gcHJvbWlzZVJlc29sdmVkV2l0aCh2b2lkIDApO1xuICAgICAgICAgICAgaWYgKHVuZGVybHlpbmdTb3VyY2Uuc3RhcnQgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBzdGFydEFsZ29yaXRobSA9ICgpID0+IHVuZGVybHlpbmdTb3VyY2Uuc3RhcnQoY29udHJvbGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodW5kZXJseWluZ1NvdXJjZS5wdWxsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgcHVsbEFsZ29yaXRobSA9ICgpID0+IHVuZGVybHlpbmdTb3VyY2UucHVsbChjb250cm9sbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1bmRlcmx5aW5nU291cmNlLmNhbmNlbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIGNhbmNlbEFsZ29yaXRobSA9IChyZWFzb24pID0+IHVuZGVybHlpbmdTb3VyY2UuY2FuY2VsKHJlYXNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBTZXRVcFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIoc3RyZWFtLCBjb250cm9sbGVyLCBzdGFydEFsZ29yaXRobSwgcHVsbEFsZ29yaXRobSwgY2FuY2VsQWxnb3JpdGhtLCBoaWdoV2F0ZXJNYXJrLCBzaXplQWxnb3JpdGhtKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uJDEobmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoYFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1UZWUoc3RyZWFtLCBjbG9uZUZvckJyYW5jaDIpIHtcbiAgICAgICAgICAgIGlmIChJc1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBSZWFkYWJsZUJ5dGVTdHJlYW1UZWUoc3RyZWFtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBSZWFkYWJsZVN0cmVhbURlZmF1bHRUZWUoc3RyZWFtKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1EZWZhdWx0VGVlKHN0cmVhbSwgY2xvbmVGb3JCcmFuY2gyKSB7XG4gICAgICAgICAgICBjb25zdCByZWFkZXIgPSBBY3F1aXJlUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHN0cmVhbSk7XG4gICAgICAgICAgICBsZXQgcmVhZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IHJlYWRBZ2FpbiA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGNhbmNlbGVkMSA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGNhbmNlbGVkMiA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IHJlYXNvbjE7XG4gICAgICAgICAgICBsZXQgcmVhc29uMjtcbiAgICAgICAgICAgIGxldCBicmFuY2gxO1xuICAgICAgICAgICAgbGV0IGJyYW5jaDI7XG4gICAgICAgICAgICBsZXQgcmVzb2x2ZUNhbmNlbFByb21pc2U7XG4gICAgICAgICAgICBjb25zdCBjYW5jZWxQcm9taXNlID0gbmV3UHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZSA9IHJlc29sdmU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHB1bGxBbGdvcml0aG0oKSB7XG4gICAgICAgICAgICAgIGlmIChyZWFkaW5nKSB7XG4gICAgICAgICAgICAgICAgcmVhZEFnYWluID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh2b2lkIDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICBjb25zdCByZWFkUmVxdWVzdCA9IHtcbiAgICAgICAgICAgICAgICBfY2h1bmtTdGVwczogKGNodW5rKSA9PiB7XG4gICAgICAgICAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRBZ2FpbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVuazEgPSBjaHVuaztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmsyID0gY2h1bms7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2FuY2VsZWQxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWUoYnJhbmNoMS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCBjaHVuazEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2FuY2VsZWQyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWUoYnJhbmNoMi5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCBjaHVuazIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlYWRBZ2Fpbikge1xuICAgICAgICAgICAgICAgICAgICAgIHB1bGxBbGdvcml0aG0oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBfY2xvc2VTdGVwczogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgcmVhZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxlZDEpIHtcbiAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsb3NlKGJyYW5jaDEuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoIWNhbmNlbGVkMikge1xuICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xvc2UoYnJhbmNoMi5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmICghY2FuY2VsZWQxIHx8ICFjYW5jZWxlZDIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2Uodm9pZCAwKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF9lcnJvclN0ZXBzOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICByZWFkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJSZWFkKHJlYWRlciwgcmVhZFJlcXVlc3QpO1xuICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh2b2lkIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gY2FuY2VsMUFsZ29yaXRobShyZWFzb24pIHtcbiAgICAgICAgICAgICAgY2FuY2VsZWQxID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcmVhc29uMSA9IHJlYXNvbjtcbiAgICAgICAgICAgICAgaWYgKGNhbmNlbGVkMikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBvc2l0ZVJlYXNvbiA9IENyZWF0ZUFycmF5RnJvbUxpc3QoW3JlYXNvbjEsIHJlYXNvbjJdKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjYW5jZWxSZXN1bHQgPSBSZWFkYWJsZVN0cmVhbUNhbmNlbChzdHJlYW0sIGNvbXBvc2l0ZVJlYXNvbik7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2UoY2FuY2VsUmVzdWx0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gY2FuY2VsUHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNhbmNlbDJBbGdvcml0aG0ocmVhc29uKSB7XG4gICAgICAgICAgICAgIGNhbmNlbGVkMiA9IHRydWU7XG4gICAgICAgICAgICAgIHJlYXNvbjIgPSByZWFzb247XG4gICAgICAgICAgICAgIGlmIChjYW5jZWxlZDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21wb3NpdGVSZWFzb24gPSBDcmVhdGVBcnJheUZyb21MaXN0KFtyZWFzb24xLCByZWFzb24yXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FuY2VsUmVzdWx0ID0gUmVhZGFibGVTdHJlYW1DYW5jZWwoc3RyZWFtLCBjb21wb3NpdGVSZWFzb24pO1xuICAgICAgICAgICAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKGNhbmNlbFJlc3VsdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGNhbmNlbFByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBzdGFydEFsZ29yaXRobSgpIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyYW5jaDEgPSBDcmVhdGVSZWFkYWJsZVN0cmVhbShzdGFydEFsZ29yaXRobSwgcHVsbEFsZ29yaXRobSwgY2FuY2VsMUFsZ29yaXRobSk7XG4gICAgICAgICAgICBicmFuY2gyID0gQ3JlYXRlUmVhZGFibGVTdHJlYW0oc3RhcnRBbGdvcml0aG0sIHB1bGxBbGdvcml0aG0sIGNhbmNlbDJBbGdvcml0aG0pO1xuICAgICAgICAgICAgdXBvblJlamVjdGlvbihyZWFkZXIuX2Nsb3NlZFByb21pc2UsIChyMjIpID0+IHtcbiAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKGJyYW5jaDEuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgcjIyKTtcbiAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKGJyYW5jaDIuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgcjIyKTtcbiAgICAgICAgICAgICAgaWYgKCFjYW5jZWxlZDEgfHwgIWNhbmNlbGVkMikge1xuICAgICAgICAgICAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKHZvaWQgMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIFticmFuY2gxLCBicmFuY2gyXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtVGVlKHN0cmVhbSkge1xuICAgICAgICAgICAgbGV0IHJlYWRlciA9IEFjcXVpcmVSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIoc3RyZWFtKTtcbiAgICAgICAgICAgIGxldCByZWFkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgcmVhZEFnYWluRm9yQnJhbmNoMSA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IHJlYWRBZ2FpbkZvckJyYW5jaDIgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBjYW5jZWxlZDEgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBjYW5jZWxlZDIgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCByZWFzb24xO1xuICAgICAgICAgICAgbGV0IHJlYXNvbjI7XG4gICAgICAgICAgICBsZXQgYnJhbmNoMTtcbiAgICAgICAgICAgIGxldCBicmFuY2gyO1xuICAgICAgICAgICAgbGV0IHJlc29sdmVDYW5jZWxQcm9taXNlO1xuICAgICAgICAgICAgY29uc3QgY2FuY2VsUHJvbWlzZSA9IG5ld1Byb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2UgPSByZXNvbHZlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmdW5jdGlvbiBmb3J3YXJkUmVhZGVyRXJyb3IodGhpc1JlYWRlcikge1xuICAgICAgICAgICAgICB1cG9uUmVqZWN0aW9uKHRoaXNSZWFkZXIuX2Nsb3NlZFByb21pc2UsIChyMjIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpc1JlYWRlciAhPT0gcmVhZGVyKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcihicmFuY2gxLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIHIyMik7XG4gICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKGJyYW5jaDIuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgcjIyKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNhbmNlbGVkMSB8fCAhY2FuY2VsZWQyKSB7XG4gICAgICAgICAgICAgICAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZSh2b2lkIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBwdWxsV2l0aERlZmF1bHRSZWFkZXIoKSB7XG4gICAgICAgICAgICAgIGlmIChJc1JlYWRhYmxlU3RyZWFtQllPQlJlYWRlcihyZWFkZXIpKSB7XG4gICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZShyZWFkZXIpO1xuICAgICAgICAgICAgICAgIHJlYWRlciA9IEFjcXVpcmVSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIoc3RyZWFtKTtcbiAgICAgICAgICAgICAgICBmb3J3YXJkUmVhZGVyRXJyb3IocmVhZGVyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCByZWFkUmVxdWVzdCA9IHtcbiAgICAgICAgICAgICAgICBfY2h1bmtTdGVwczogKGNodW5rKSA9PiB7XG4gICAgICAgICAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRBZ2FpbkZvckJyYW5jaDEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmVhZEFnYWluRm9yQnJhbmNoMiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVuazEgPSBjaHVuaztcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNodW5rMiA9IGNodW5rO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbmNlbGVkMSAmJiAhY2FuY2VsZWQyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rMiA9IENsb25lQXNVaW50OEFycmF5KGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChjbG9uZUUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcihicmFuY2gxLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIGNsb25lRSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IoYnJhbmNoMi5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCBjbG9uZUUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2UoUmVhZGFibGVTdHJlYW1DYW5jZWwoc3RyZWFtLCBjbG9uZUUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxlZDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZShicmFuY2gxLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIGNodW5rMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxlZDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZShicmFuY2gyLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIGNodW5rMik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVhZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVhZEFnYWluRm9yQnJhbmNoMSkge1xuICAgICAgICAgICAgICAgICAgICAgIHB1bGwxQWxnb3JpdGhtKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVhZEFnYWluRm9yQnJhbmNoMikge1xuICAgICAgICAgICAgICAgICAgICAgIHB1bGwyQWxnb3JpdGhtKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgX2Nsb3NlU3RlcHM6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgIHJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIGlmICghY2FuY2VsZWQxKSB7XG4gICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbG9zZShicmFuY2gxLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxlZDIpIHtcbiAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsb3NlKGJyYW5jaDIuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoYnJhbmNoMS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmQoYnJhbmNoMS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCAwKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChicmFuY2gyLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZChicmFuY2gyLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIDApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxlZDEgfHwgIWNhbmNlbGVkMikge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZSh2b2lkIDApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgX2Vycm9yU3RlcHM6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgIHJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlclJlYWQocmVhZGVyLCByZWFkUmVxdWVzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBwdWxsV2l0aEJZT0JSZWFkZXIodmlldywgZm9yQnJhbmNoMikge1xuICAgICAgICAgICAgICBpZiAoSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIocmVhZGVyKSkge1xuICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UocmVhZGVyKTtcbiAgICAgICAgICAgICAgICByZWFkZXIgPSBBY3F1aXJlUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgZm9yd2FyZFJlYWRlckVycm9yKHJlYWRlcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgYnlvYkJyYW5jaCA9IGZvckJyYW5jaDIgPyBicmFuY2gyIDogYnJhbmNoMTtcbiAgICAgICAgICAgICAgY29uc3Qgb3RoZXJCcmFuY2ggPSBmb3JCcmFuY2gyID8gYnJhbmNoMSA6IGJyYW5jaDI7XG4gICAgICAgICAgICAgIGNvbnN0IHJlYWRJbnRvUmVxdWVzdCA9IHtcbiAgICAgICAgICAgICAgICBfY2h1bmtTdGVwczogKGNodW5rKSA9PiB7XG4gICAgICAgICAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRBZ2FpbkZvckJyYW5jaDEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmVhZEFnYWluRm9yQnJhbmNoMiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBieW9iQ2FuY2VsZWQgPSBmb3JCcmFuY2gyID8gY2FuY2VsZWQyIDogY2FuY2VsZWQxO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvdGhlckNhbmNlbGVkID0gZm9yQnJhbmNoMiA/IGNhbmNlbGVkMSA6IGNhbmNlbGVkMjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvdGhlckNhbmNlbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgbGV0IGNsb25lZENodW5rO1xuICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9uZWRDaHVuayA9IENsb25lQXNVaW50OEFycmF5KGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChjbG9uZUUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcihieW9iQnJhbmNoLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIGNsb25lRSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3Iob3RoZXJCcmFuY2guX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2xvbmVFKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHN0cmVhbSwgY2xvbmVFKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGlmICghYnlvYkNhbmNlbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZFdpdGhOZXdWaWV3KGJ5b2JCcmFuY2guX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZShvdGhlckJyYW5jaC5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCBjbG9uZWRDaHVuayk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWJ5b2JDYW5jZWxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kV2l0aE5ld1ZpZXcoYnlvYkJyYW5jaC5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCBjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVhZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVhZEFnYWluRm9yQnJhbmNoMSkge1xuICAgICAgICAgICAgICAgICAgICAgIHB1bGwxQWxnb3JpdGhtKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVhZEFnYWluRm9yQnJhbmNoMikge1xuICAgICAgICAgICAgICAgICAgICAgIHB1bGwyQWxnb3JpdGhtKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgX2Nsb3NlU3RlcHM6IChjaHVuaykgPT4ge1xuICAgICAgICAgICAgICAgICAgcmVhZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgY29uc3QgYnlvYkNhbmNlbGVkID0gZm9yQnJhbmNoMiA/IGNhbmNlbGVkMiA6IGNhbmNlbGVkMTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG90aGVyQ2FuY2VsZWQgPSBmb3JCcmFuY2gyID8gY2FuY2VsZWQxIDogY2FuY2VsZWQyO1xuICAgICAgICAgICAgICAgICAgaWYgKCFieW9iQ2FuY2VsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsb3NlKGJ5b2JCcmFuY2guX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoIW90aGVyQ2FuY2VsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsb3NlKG90aGVyQnJhbmNoLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKGNodW5rICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFieW9iQ2FuY2VsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZFdpdGhOZXdWaWV3KGJ5b2JCcmFuY2guX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghb3RoZXJDYW5jZWxlZCAmJiBvdGhlckJyYW5jaC5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZChvdGhlckJyYW5jaC5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKCFieW9iQ2FuY2VsZWQgfHwgIW90aGVyQ2FuY2VsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2Uodm9pZCAwKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF9lcnJvclN0ZXBzOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICByZWFkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXJSZWFkKHJlYWRlciwgdmlldywgcmVhZEludG9SZXF1ZXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHB1bGwxQWxnb3JpdGhtKCkge1xuICAgICAgICAgICAgICBpZiAocmVhZGluZykge1xuICAgICAgICAgICAgICAgIHJlYWRBZ2FpbkZvckJyYW5jaDEgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHZvaWQgMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVhZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgIGNvbnN0IGJ5b2JSZXF1ZXN0ID0gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckdldEJZT0JSZXF1ZXN0KGJyYW5jaDEuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcik7XG4gICAgICAgICAgICAgIGlmIChieW9iUmVxdWVzdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHB1bGxXaXRoRGVmYXVsdFJlYWRlcigpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHB1bGxXaXRoQllPQlJlYWRlcihieW9iUmVxdWVzdC5fdmlldywgZmFsc2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHZvaWQgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBwdWxsMkFsZ29yaXRobSgpIHtcbiAgICAgICAgICAgICAgaWYgKHJlYWRpbmcpIHtcbiAgICAgICAgICAgICAgICByZWFkQWdhaW5Gb3JCcmFuY2gyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh2b2lkIDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICBjb25zdCBieW9iUmVxdWVzdCA9IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJHZXRCWU9CUmVxdWVzdChicmFuY2gyLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgICBpZiAoYnlvYlJlcXVlc3QgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwdWxsV2l0aERlZmF1bHRSZWFkZXIoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwdWxsV2l0aEJZT0JSZWFkZXIoYnlvYlJlcXVlc3QuX3ZpZXcsIHRydWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHZvaWQgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBjYW5jZWwxQWxnb3JpdGhtKHJlYXNvbikge1xuICAgICAgICAgICAgICBjYW5jZWxlZDEgPSB0cnVlO1xuICAgICAgICAgICAgICByZWFzb24xID0gcmVhc29uO1xuICAgICAgICAgICAgICBpZiAoY2FuY2VsZWQyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tcG9zaXRlUmVhc29uID0gQ3JlYXRlQXJyYXlGcm9tTGlzdChbcmVhc29uMSwgcmVhc29uMl0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbmNlbFJlc3VsdCA9IFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHN0cmVhbSwgY29tcG9zaXRlUmVhc29uKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZShjYW5jZWxSZXN1bHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBjYW5jZWxQcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gY2FuY2VsMkFsZ29yaXRobShyZWFzb24pIHtcbiAgICAgICAgICAgICAgY2FuY2VsZWQyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcmVhc29uMiA9IHJlYXNvbjtcbiAgICAgICAgICAgICAgaWYgKGNhbmNlbGVkMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBvc2l0ZVJlYXNvbiA9IENyZWF0ZUFycmF5RnJvbUxpc3QoW3JlYXNvbjEsIHJlYXNvbjJdKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjYW5jZWxSZXN1bHQgPSBSZWFkYWJsZVN0cmVhbUNhbmNlbChzdHJlYW0sIGNvbXBvc2l0ZVJlYXNvbik7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2UoY2FuY2VsUmVzdWx0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gY2FuY2VsUHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHN0YXJ0QWxnb3JpdGhtKCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmFuY2gxID0gQ3JlYXRlUmVhZGFibGVCeXRlU3RyZWFtKHN0YXJ0QWxnb3JpdGhtLCBwdWxsMUFsZ29yaXRobSwgY2FuY2VsMUFsZ29yaXRobSk7XG4gICAgICAgICAgICBicmFuY2gyID0gQ3JlYXRlUmVhZGFibGVCeXRlU3RyZWFtKHN0YXJ0QWxnb3JpdGhtLCBwdWxsMkFsZ29yaXRobSwgY2FuY2VsMkFsZ29yaXRobSk7XG4gICAgICAgICAgICBmb3J3YXJkUmVhZGVyRXJyb3IocmVhZGVyKTtcbiAgICAgICAgICAgIHJldHVybiBbYnJhbmNoMSwgYnJhbmNoMl07XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIGNvbnZlcnRVbmRlcmx5aW5nRGVmYXVsdE9yQnl0ZVNvdXJjZShzb3VyY2UsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGFzc2VydERpY3Rpb25hcnkoc291cmNlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsID0gc291cmNlO1xuICAgICAgICAgICAgY29uc3QgYXV0b0FsbG9jYXRlQ2h1bmtTaXplID0gb3JpZ2luYWwgPT09IG51bGwgfHwgb3JpZ2luYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsLmF1dG9BbGxvY2F0ZUNodW5rU2l6ZTtcbiAgICAgICAgICAgIGNvbnN0IGNhbmNlbCA9IG9yaWdpbmFsID09PSBudWxsIHx8IG9yaWdpbmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW5hbC5jYW5jZWw7XG4gICAgICAgICAgICBjb25zdCBwdWxsID0gb3JpZ2luYWwgPT09IG51bGwgfHwgb3JpZ2luYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsLnB1bGw7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IG9yaWdpbmFsID09PSBudWxsIHx8IG9yaWdpbmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW5hbC5zdGFydDtcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwudHlwZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGF1dG9BbGxvY2F0ZUNodW5rU2l6ZTogYXV0b0FsbG9jYXRlQ2h1bmtTaXplID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb252ZXJ0VW5zaWduZWRMb25nTG9uZ1dpdGhFbmZvcmNlUmFuZ2UoYXV0b0FsbG9jYXRlQ2h1bmtTaXplLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICdhdXRvQWxsb2NhdGVDaHVua1NpemUnIHRoYXRgKSxcbiAgICAgICAgICAgICAgY2FuY2VsOiBjYW5jZWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnZlcnRVbmRlcmx5aW5nU291cmNlQ2FuY2VsQ2FsbGJhY2soY2FuY2VsLCBvcmlnaW5hbCwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnY2FuY2VsJyB0aGF0YCksXG4gICAgICAgICAgICAgIHB1bGw6IHB1bGwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnZlcnRVbmRlcmx5aW5nU291cmNlUHVsbENhbGxiYWNrKHB1bGwsIG9yaWdpbmFsLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICdwdWxsJyB0aGF0YCksXG4gICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29udmVydFVuZGVybHlpbmdTb3VyY2VTdGFydENhbGxiYWNrKHN0YXJ0LCBvcmlnaW5hbCwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnc3RhcnQnIHRoYXRgKSxcbiAgICAgICAgICAgICAgdHlwZTogdHlwZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29udmVydFJlYWRhYmxlU3RyZWFtVHlwZSh0eXBlLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICd0eXBlJyB0aGF0YClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIGNvbnZlcnRVbmRlcmx5aW5nU291cmNlQ2FuY2VsQ2FsbGJhY2soZm4sIG9yaWdpbmFsLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBhc3NlcnRGdW5jdGlvbihmbiwgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gKHJlYXNvbikgPT4gcHJvbWlzZUNhbGwoZm4sIG9yaWdpbmFsLCBbcmVhc29uXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIGNvbnZlcnRVbmRlcmx5aW5nU291cmNlUHVsbENhbGxiYWNrKGZuLCBvcmlnaW5hbCwgY29udGV4dCkge1xuICAgICAgICAgICAgYXNzZXJ0RnVuY3Rpb24oZm4sIGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIChjb250cm9sbGVyKSA9PiBwcm9taXNlQ2FsbChmbiwgb3JpZ2luYWwsIFtjb250cm9sbGVyXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIGNvbnZlcnRVbmRlcmx5aW5nU291cmNlU3RhcnRDYWxsYmFjayhmbiwgb3JpZ2luYWwsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiAoY29udHJvbGxlcikgPT4gcmVmbGVjdENhbGwoZm4sIG9yaWdpbmFsLCBbY29udHJvbGxlcl0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBjb252ZXJ0UmVhZGFibGVTdHJlYW1UeXBlKHR5cGUsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHR5cGUgPSBgJHt0eXBlfWA7XG4gICAgICAgICAgICBpZiAodHlwZSAhPT0gXCJieXRlc1wiKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7Y29udGV4dH0gJyR7dHlwZX0nIGlzIG5vdCBhIHZhbGlkIGVudW1lcmF0aW9uIHZhbHVlIGZvciBSZWFkYWJsZVN0cmVhbVR5cGVgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBjb252ZXJ0UmVhZGVyT3B0aW9ucyhvcHRpb25zLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBhc3NlcnREaWN0aW9uYXJ5KG9wdGlvbnMsIGNvbnRleHQpO1xuICAgICAgICAgICAgY29uc3QgbW9kZSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tb2RlO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgbW9kZTogbW9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29udmVydFJlYWRhYmxlU3RyZWFtUmVhZGVyTW9kZShtb2RlLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICdtb2RlJyB0aGF0YClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIGNvbnZlcnRSZWFkYWJsZVN0cmVhbVJlYWRlck1vZGUobW9kZSwgY29udGV4dCkge1xuICAgICAgICAgICAgbW9kZSA9IGAke21vZGV9YDtcbiAgICAgICAgICAgIGlmIChtb2RlICE9PSBcImJ5b2JcIikge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2NvbnRleHR9ICcke21vZGV9JyBpcyBub3QgYSB2YWxpZCBlbnVtZXJhdGlvbiB2YWx1ZSBmb3IgUmVhZGFibGVTdHJlYW1SZWFkZXJNb2RlYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbW9kZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gY29udmVydEl0ZXJhdG9yT3B0aW9ucyhvcHRpb25zLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBhc3NlcnREaWN0aW9uYXJ5KG9wdGlvbnMsIGNvbnRleHQpO1xuICAgICAgICAgICAgY29uc3QgcHJldmVudENhbmNlbCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wcmV2ZW50Q2FuY2VsO1xuICAgICAgICAgICAgcmV0dXJuIHsgcHJldmVudENhbmNlbDogQm9vbGVhbihwcmV2ZW50Q2FuY2VsKSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBjb252ZXJ0UGlwZU9wdGlvbnMob3B0aW9ucywgY29udGV4dCkge1xuICAgICAgICAgICAgYXNzZXJ0RGljdGlvbmFyeShvcHRpb25zLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGNvbnN0IHByZXZlbnRBYm9ydCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wcmV2ZW50QWJvcnQ7XG4gICAgICAgICAgICBjb25zdCBwcmV2ZW50Q2FuY2VsID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnByZXZlbnRDYW5jZWw7XG4gICAgICAgICAgICBjb25zdCBwcmV2ZW50Q2xvc2UgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucHJldmVudENsb3NlO1xuICAgICAgICAgICAgY29uc3Qgc2lnbmFsID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25hbDtcbiAgICAgICAgICAgIGlmIChzaWduYWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBhc3NlcnRBYm9ydFNpZ25hbChzaWduYWwsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3NpZ25hbCcgdGhhdGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgcHJldmVudEFib3J0OiBCb29sZWFuKHByZXZlbnRBYm9ydCksXG4gICAgICAgICAgICAgIHByZXZlbnRDYW5jZWw6IEJvb2xlYW4ocHJldmVudENhbmNlbCksXG4gICAgICAgICAgICAgIHByZXZlbnRDbG9zZTogQm9vbGVhbihwcmV2ZW50Q2xvc2UpLFxuICAgICAgICAgICAgICBzaWduYWxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIGFzc2VydEFib3J0U2lnbmFsKHNpZ25hbCwgY29udGV4dCkge1xuICAgICAgICAgICAgaWYgKCFpc0Fib3J0U2lnbmFsMihzaWduYWwpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7Y29udGV4dH0gaXMgbm90IGFuIEFib3J0U2lnbmFsLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBjb252ZXJ0UmVhZGFibGVXcml0YWJsZVBhaXIocGFpciwgY29udGV4dCkge1xuICAgICAgICAgICAgYXNzZXJ0RGljdGlvbmFyeShwYWlyLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGNvbnN0IHJlYWRhYmxlID0gcGFpciA9PT0gbnVsbCB8fCBwYWlyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYWlyLnJlYWRhYmxlO1xuICAgICAgICAgICAgYXNzZXJ0UmVxdWlyZWRGaWVsZChyZWFkYWJsZSwgXCJyZWFkYWJsZVwiLCBcIlJlYWRhYmxlV3JpdGFibGVQYWlyXCIpO1xuICAgICAgICAgICAgYXNzZXJ0UmVhZGFibGVTdHJlYW0ocmVhZGFibGUsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3JlYWRhYmxlJyB0aGF0YCk7XG4gICAgICAgICAgICBjb25zdCB3cml0YWJsZSA9IHBhaXIgPT09IG51bGwgfHwgcGFpciA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFpci53cml0YWJsZTtcbiAgICAgICAgICAgIGFzc2VydFJlcXVpcmVkRmllbGQod3JpdGFibGUsIFwid3JpdGFibGVcIiwgXCJSZWFkYWJsZVdyaXRhYmxlUGFpclwiKTtcbiAgICAgICAgICAgIGFzc2VydFdyaXRhYmxlU3RyZWFtKHdyaXRhYmxlLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICd3cml0YWJsZScgdGhhdGApO1xuICAgICAgICAgICAgcmV0dXJuIHsgcmVhZGFibGUsIHdyaXRhYmxlIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGNsYXNzIFJlYWRhYmxlU3RyZWFtMiB7XG4gICAgICAgICAgICBjb25zdHJ1Y3RvcihyYXdVbmRlcmx5aW5nU291cmNlID0ge30sIHJhd1N0cmF0ZWd5ID0ge30pIHtcbiAgICAgICAgICAgICAgaWYgKHJhd1VuZGVybHlpbmdTb3VyY2UgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHJhd1VuZGVybHlpbmdTb3VyY2UgPSBudWxsO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFzc2VydE9iamVjdChyYXdVbmRlcmx5aW5nU291cmNlLCBcIkZpcnN0IHBhcmFtZXRlclwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBzdHJhdGVneSA9IGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3kocmF3U3RyYXRlZ3ksIFwiU2Vjb25kIHBhcmFtZXRlclwiKTtcbiAgICAgICAgICAgICAgY29uc3QgdW5kZXJseWluZ1NvdXJjZSA9IGNvbnZlcnRVbmRlcmx5aW5nRGVmYXVsdE9yQnl0ZVNvdXJjZShyYXdVbmRlcmx5aW5nU291cmNlLCBcIkZpcnN0IHBhcmFtZXRlclwiKTtcbiAgICAgICAgICAgICAgSW5pdGlhbGl6ZVJlYWRhYmxlU3RyZWFtKHRoaXMpO1xuICAgICAgICAgICAgICBpZiAodW5kZXJseWluZ1NvdXJjZS50eXBlID09PSBcImJ5dGVzXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RyYXRlZ3kuc2l6ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZSBzdHJhdGVneSBmb3IgYSBieXRlIHN0cmVhbSBjYW5ub3QgaGF2ZSBhIHNpemUgZnVuY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGhpZ2hXYXRlck1hcmsgPSBFeHRyYWN0SGlnaFdhdGVyTWFyayhzdHJhdGVneSwgMCk7XG4gICAgICAgICAgICAgICAgU2V0VXBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRnJvbVVuZGVybHlpbmdTb3VyY2UodGhpcywgdW5kZXJseWluZ1NvdXJjZSwgaGlnaFdhdGVyTWFyayk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2l6ZUFsZ29yaXRobSA9IEV4dHJhY3RTaXplQWxnb3JpdGhtKHN0cmF0ZWd5KTtcbiAgICAgICAgICAgICAgICBjb25zdCBoaWdoV2F0ZXJNYXJrID0gRXh0cmFjdEhpZ2hXYXRlck1hcmsoc3RyYXRlZ3ksIDEpO1xuICAgICAgICAgICAgICAgIFNldFVwUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckZyb21VbmRlcmx5aW5nU291cmNlKHRoaXMsIHVuZGVybHlpbmdTb3VyY2UsIGhpZ2hXYXRlck1hcmssIHNpemVBbGdvcml0aG0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZXQgbG9ja2VkKCkge1xuICAgICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW0odGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uJDEoXCJsb2NrZWRcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIElzUmVhZGFibGVTdHJlYW1Mb2NrZWQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYW5jZWwocmVhc29uID0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbSh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24kMShcImNhbmNlbFwiKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKElzUmVhZGFibGVTdHJlYW1Mb2NrZWQodGhpcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbmNlbCBhIHN0cmVhbSB0aGF0IGFscmVhZHkgaGFzIGEgcmVhZGVyXCIpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1DYW5jZWwodGhpcywgcmVhc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdldFJlYWRlcihyYXdPcHRpb25zID0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbSh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24kMShcImdldFJlYWRlclwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBvcHRpb25zID0gY29udmVydFJlYWRlck9wdGlvbnMocmF3T3B0aW9ucywgXCJGaXJzdCBwYXJhbWV0ZXJcIik7XG4gICAgICAgICAgICAgIGlmIChvcHRpb25zLm1vZGUgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBBY3F1aXJlUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHRoaXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBBY3F1aXJlUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGlwZVRocm91Z2gocmF3VHJhbnNmb3JtLCByYXdPcHRpb25zID0ge30pIHtcbiAgICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbiQxKFwicGlwZVRocm91Z2hcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYXNzZXJ0UmVxdWlyZWRBcmd1bWVudChyYXdUcmFuc2Zvcm0sIDEsIFwicGlwZVRocm91Z2hcIik7XG4gICAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGNvbnZlcnRSZWFkYWJsZVdyaXRhYmxlUGFpcihyYXdUcmFuc2Zvcm0sIFwiRmlyc3QgcGFyYW1ldGVyXCIpO1xuICAgICAgICAgICAgICBjb25zdCBvcHRpb25zID0gY29udmVydFBpcGVPcHRpb25zKHJhd09wdGlvbnMsIFwiU2Vjb25kIHBhcmFtZXRlclwiKTtcbiAgICAgICAgICAgICAgaWYgKElzUmVhZGFibGVTdHJlYW1Mb2NrZWQodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLnBpcGVUaHJvdWdoIGNhbm5vdCBiZSB1c2VkIG9uIGEgbG9ja2VkIFJlYWRhYmxlU3RyZWFtXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChJc1dyaXRhYmxlU3RyZWFtTG9ja2VkKHRyYW5zZm9ybS53cml0YWJsZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLnBpcGVUaHJvdWdoIGNhbm5vdCBiZSB1c2VkIG9uIGEgbG9ja2VkIFdyaXRhYmxlU3RyZWFtXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBSZWFkYWJsZVN0cmVhbVBpcGVUbyh0aGlzLCB0cmFuc2Zvcm0ud3JpdGFibGUsIG9wdGlvbnMucHJldmVudENsb3NlLCBvcHRpb25zLnByZXZlbnRBYm9ydCwgb3B0aW9ucy5wcmV2ZW50Q2FuY2VsLCBvcHRpb25zLnNpZ25hbCk7XG4gICAgICAgICAgICAgIHNldFByb21pc2VJc0hhbmRsZWRUb1RydWUocHJvbWlzZSk7XG4gICAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm0ucmVhZGFibGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwaXBlVG8oZGVzdGluYXRpb24sIHJhd09wdGlvbnMgPSB7fSkge1xuICAgICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW0odGhpcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uJDEoXCJwaXBlVG9cIikpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChkZXN0aW5hdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoYFBhcmFtZXRlciAxIGlzIHJlcXVpcmVkIGluICdwaXBlVG8nLmApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghSXNXcml0YWJsZVN0cmVhbShkZXN0aW5hdGlvbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKGBSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUucGlwZVRvJ3MgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIFdyaXRhYmxlU3RyZWFtYCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxldCBvcHRpb25zO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBjb252ZXJ0UGlwZU9wdGlvbnMocmF3T3B0aW9ucywgXCJTZWNvbmQgcGFyYW1ldGVyXCIpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGUyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoSXNSZWFkYWJsZVN0cmVhbUxvY2tlZCh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoXCJSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUucGlwZVRvIGNhbm5vdCBiZSB1c2VkIG9uIGEgbG9ja2VkIFJlYWRhYmxlU3RyZWFtXCIpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoSXNXcml0YWJsZVN0cmVhbUxvY2tlZChkZXN0aW5hdGlvbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKFwiUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLnBpcGVUbyBjYW5ub3QgYmUgdXNlZCBvbiBhIGxvY2tlZCBXcml0YWJsZVN0cmVhbVwiKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtUGlwZVRvKHRoaXMsIGRlc3RpbmF0aW9uLCBvcHRpb25zLnByZXZlbnRDbG9zZSwgb3B0aW9ucy5wcmV2ZW50QWJvcnQsIG9wdGlvbnMucHJldmVudENhbmNlbCwgb3B0aW9ucy5zaWduYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGVlKCkge1xuICAgICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW0odGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uJDEoXCJ0ZWVcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgYnJhbmNoZXMgPSBSZWFkYWJsZVN0cmVhbVRlZSh0aGlzKTtcbiAgICAgICAgICAgICAgcmV0dXJuIENyZWF0ZUFycmF5RnJvbUxpc3QoYnJhbmNoZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWVzKHJhd09wdGlvbnMgPSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbiQxKFwidmFsdWVzXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBjb252ZXJ0SXRlcmF0b3JPcHRpb25zKHJhd09wdGlvbnMsIFwiRmlyc3QgcGFyYW1ldGVyXCIpO1xuICAgICAgICAgICAgICByZXR1cm4gQWNxdWlyZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcih0aGlzLCBvcHRpb25zLnByZXZlbnRDYW5jZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZWFkYWJsZVN0cmVhbTIucHJvdG90eXBlLCB7XG4gICAgICAgICAgICBjYW5jZWw6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICAgICAgZ2V0UmVhZGVyOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgICAgIHBpcGVUaHJvdWdoOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgICAgIHBpcGVUbzogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgICAgICB0ZWU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICAgICAgdmFsdWVzOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgICAgIGxvY2tlZDogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAodHlwZW9mIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnID09PSBcInN5bWJvbFwiKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGVTdHJlYW0yLnByb3RvdHlwZSwgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IFwiUmVhZGFibGVTdHJlYW1cIixcbiAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBTeW1ib2xQb2x5ZmlsbC5hc3luY0l0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGVTdHJlYW0yLnByb3RvdHlwZSwgU3ltYm9sUG9seWZpbGwuYXN5bmNJdGVyYXRvciwge1xuICAgICAgICAgICAgICB2YWx1ZTogUmVhZGFibGVTdHJlYW0yLnByb3RvdHlwZS52YWx1ZXMsXG4gICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBDcmVhdGVSZWFkYWJsZVN0cmVhbShzdGFydEFsZ29yaXRobSwgcHVsbEFsZ29yaXRobSwgY2FuY2VsQWxnb3JpdGhtLCBoaWdoV2F0ZXJNYXJrID0gMSwgc2l6ZUFsZ29yaXRobSA9ICgpID0+IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVTdHJlYW0yLnByb3RvdHlwZSk7XG4gICAgICAgICAgICBJbml0aWFsaXplUmVhZGFibGVTdHJlYW0oc3RyZWFtKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBPYmplY3QuY3JlYXRlKFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlKTtcbiAgICAgICAgICAgIFNldFVwUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcihzdHJlYW0sIGNvbnRyb2xsZXIsIHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWxBbGdvcml0aG0sIGhpZ2hXYXRlck1hcmssIHNpemVBbGdvcml0aG0pO1xuICAgICAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gQ3JlYXRlUmVhZGFibGVCeXRlU3RyZWFtKHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWxBbGdvcml0aG0pIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVTdHJlYW0yLnByb3RvdHlwZSk7XG4gICAgICAgICAgICBJbml0aWFsaXplUmVhZGFibGVTdHJlYW0oc3RyZWFtKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBPYmplY3QuY3JlYXRlKFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlKTtcbiAgICAgICAgICAgIFNldFVwUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcihzdHJlYW0sIGNvbnRyb2xsZXIsIHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWxBbGdvcml0aG0sIDAsIHZvaWQgMCk7XG4gICAgICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBJbml0aWFsaXplUmVhZGFibGVTdHJlYW0oc3RyZWFtKSB7XG4gICAgICAgICAgICBzdHJlYW0uX3N0YXRlID0gXCJyZWFkYWJsZVwiO1xuICAgICAgICAgICAgc3RyZWFtLl9yZWFkZXIgPSB2b2lkIDA7XG4gICAgICAgICAgICBzdHJlYW0uX3N0b3JlZEVycm9yID0gdm9pZCAwO1xuICAgICAgICAgICAgc3RyZWFtLl9kaXN0dXJiZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gSXNSZWFkYWJsZVN0cmVhbSh4Mikge1xuICAgICAgICAgICAgaWYgKCF0eXBlSXNPYmplY3QoeDIpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgyLCBcIl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXJcIikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHgyIGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW0yO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBJc1JlYWRhYmxlU3RyZWFtTG9ja2VkKHN0cmVhbSkge1xuICAgICAgICAgICAgaWYgKHN0cmVhbS5fcmVhZGVyID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHN0cmVhbSwgcmVhc29uKSB7XG4gICAgICAgICAgICBzdHJlYW0uX2Rpc3R1cmJlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gXCJjbG9zZWRcIikge1xuICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh2b2lkIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0cmVhbS5fc3RhdGUgPT09IFwiZXJyb3JlZFwiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1DbG9zZShzdHJlYW0pO1xuICAgICAgICAgICAgY29uc3QgcmVhZGVyID0gc3RyZWFtLl9yZWFkZXI7XG4gICAgICAgICAgICBpZiAocmVhZGVyICE9PSB2b2lkIDAgJiYgSXNSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIocmVhZGVyKSkge1xuICAgICAgICAgICAgICByZWFkZXIuX3JlYWRJbnRvUmVxdWVzdHMuZm9yRWFjaCgocmVhZEludG9SZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmVhZEludG9SZXF1ZXN0Ll9jbG9zZVN0ZXBzKHZvaWQgMCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZWFkZXIuX3JlYWRJbnRvUmVxdWVzdHMgPSBuZXcgU2ltcGxlUXVldWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZUNhbmNlbFByb21pc2UgPSBzdHJlYW0uX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcltDYW5jZWxTdGVwc10ocmVhc29uKTtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1Qcm9taXNlV2l0aChzb3VyY2VDYW5jZWxQcm9taXNlLCBub29wMik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtQ2xvc2Uoc3RyZWFtKSB7XG4gICAgICAgICAgICBzdHJlYW0uX3N0YXRlID0gXCJjbG9zZWRcIjtcbiAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5fcmVhZGVyO1xuICAgICAgICAgICAgaWYgKHJlYWRlciA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVzb2x2ZShyZWFkZXIpO1xuICAgICAgICAgICAgaWYgKElzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHJlYWRlcikpIHtcbiAgICAgICAgICAgICAgcmVhZGVyLl9yZWFkUmVxdWVzdHMuZm9yRWFjaCgocmVhZFJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgICAgICByZWFkUmVxdWVzdC5fY2xvc2VTdGVwcygpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmVhZGVyLl9yZWFkUmVxdWVzdHMgPSBuZXcgU2ltcGxlUXVldWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1FcnJvcihzdHJlYW0sIGUyKSB7XG4gICAgICAgICAgICBzdHJlYW0uX3N0YXRlID0gXCJlcnJvcmVkXCI7XG4gICAgICAgICAgICBzdHJlYW0uX3N0b3JlZEVycm9yID0gZTI7XG4gICAgICAgICAgICBjb25zdCByZWFkZXIgPSBzdHJlYW0uX3JlYWRlcjtcbiAgICAgICAgICAgIGlmIChyZWFkZXIgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlamVjdChyZWFkZXIsIGUyKTtcbiAgICAgICAgICAgIGlmIChJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcihyZWFkZXIpKSB7XG4gICAgICAgICAgICAgIHJlYWRlci5fcmVhZFJlcXVlc3RzLmZvckVhY2goKHJlYWRSZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmVhZFJlcXVlc3QuX2Vycm9yU3RlcHMoZTIpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmVhZGVyLl9yZWFkUmVxdWVzdHMgPSBuZXcgU2ltcGxlUXVldWUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlYWRlci5fcmVhZEludG9SZXF1ZXN0cy5mb3JFYWNoKChyZWFkSW50b1JlcXVlc3QpID0+IHtcbiAgICAgICAgICAgICAgICByZWFkSW50b1JlcXVlc3QuX2Vycm9yU3RlcHMoZTIpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmVhZGVyLl9yZWFkSW50b1JlcXVlc3RzID0gbmV3IFNpbXBsZVF1ZXVlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24kMShuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihgUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFJlYWRhYmxlU3RyZWFtYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3lJbml0KGluaXQsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGFzc2VydERpY3Rpb25hcnkoaW5pdCwgY29udGV4dCk7XG4gICAgICAgICAgICBjb25zdCBoaWdoV2F0ZXJNYXJrID0gaW5pdCA9PT0gbnVsbCB8fCBpbml0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbml0LmhpZ2hXYXRlck1hcms7XG4gICAgICAgICAgICBhc3NlcnRSZXF1aXJlZEZpZWxkKGhpZ2hXYXRlck1hcmssIFwiaGlnaFdhdGVyTWFya1wiLCBcIlF1ZXVpbmdTdHJhdGVneUluaXRcIik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBoaWdoV2F0ZXJNYXJrOiBjb252ZXJ0VW5yZXN0cmljdGVkRG91YmxlKGhpZ2hXYXRlck1hcmspXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBieXRlTGVuZ3RoU2l6ZUZ1bmN0aW9uID0gKGNodW5rKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYnl0ZUxlbmd0aFNpemVGdW5jdGlvbiwgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IFwic2l6ZVwiLFxuICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNsYXNzIEJ5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3kge1xuICAgICAgICAgICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICAgICAgICBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50KG9wdGlvbnMsIDEsIFwiQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneVwiKTtcbiAgICAgICAgICAgICAgb3B0aW9ucyA9IGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3lJbml0KG9wdGlvbnMsIFwiRmlyc3QgcGFyYW1ldGVyXCIpO1xuICAgICAgICAgICAgICB0aGlzLl9ieXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5SGlnaFdhdGVyTWFyayA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdldCBoaWdoV2F0ZXJNYXJrKCkge1xuICAgICAgICAgICAgICBpZiAoIUlzQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneSh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGJ5dGVMZW5ndGhCcmFuZENoZWNrRXhjZXB0aW9uKFwiaGlnaFdhdGVyTWFya1wiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneUhpZ2hXYXRlck1hcms7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgICAgICAgaWYgKCFJc0J5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3kodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBieXRlTGVuZ3RoQnJhbmRDaGVja0V4Y2VwdGlvbihcInNpemVcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGJ5dGVMZW5ndGhTaXplRnVuY3Rpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEJ5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3kucHJvdG90eXBlLCB7XG4gICAgICAgICAgICBoaWdoV2F0ZXJNYXJrOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgICAgIHNpemU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZyA9PT0gXCJzeW1ib2xcIikge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3kucHJvdG90eXBlLCBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZywge1xuICAgICAgICAgICAgICB2YWx1ZTogXCJCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5XCIsXG4gICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIGJ5dGVMZW5ndGhCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKGBCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5LnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIElzQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneSh4Mikge1xuICAgICAgICAgICAgaWYgKCF0eXBlSXNPYmplY3QoeDIpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgyLCBcIl9ieXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5SGlnaFdhdGVyTWFya1wiKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geDIgaW5zdGFuY2VvZiBCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBjb3VudFNpemVGdW5jdGlvbiA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgIH07XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb3VudFNpemVGdW5jdGlvbiwgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IFwic2l6ZVwiLFxuICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNsYXNzIENvdW50UXVldWluZ1N0cmF0ZWd5IHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgYXNzZXJ0UmVxdWlyZWRBcmd1bWVudChvcHRpb25zLCAxLCBcIkNvdW50UXVldWluZ1N0cmF0ZWd5XCIpO1xuICAgICAgICAgICAgICBvcHRpb25zID0gY29udmVydFF1ZXVpbmdTdHJhdGVneUluaXQob3B0aW9ucywgXCJGaXJzdCBwYXJhbWV0ZXJcIik7XG4gICAgICAgICAgICAgIHRoaXMuX2NvdW50UXVldWluZ1N0cmF0ZWd5SGlnaFdhdGVyTWFyayA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdldCBoaWdoV2F0ZXJNYXJrKCkge1xuICAgICAgICAgICAgICBpZiAoIUlzQ291bnRRdWV1aW5nU3RyYXRlZ3kodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBjb3VudEJyYW5kQ2hlY2tFeGNlcHRpb24oXCJoaWdoV2F0ZXJNYXJrXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb3VudFF1ZXVpbmdTdHJhdGVneUhpZ2hXYXRlck1hcms7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgICAgICAgaWYgKCFJc0NvdW50UXVldWluZ1N0cmF0ZWd5KHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgY291bnRCcmFuZENoZWNrRXhjZXB0aW9uKFwic2l6ZVwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gY291bnRTaXplRnVuY3Rpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENvdW50UXVldWluZ1N0cmF0ZWd5LnByb3RvdHlwZSwge1xuICAgICAgICAgICAgaGlnaFdhdGVyTWFyazogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgICAgICBzaXplOiB7IGVudW1lcmFibGU6IHRydWUgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICh0eXBlb2YgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcgPT09IFwic3ltYm9sXCIpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb3VudFF1ZXVpbmdTdHJhdGVneS5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBcIkNvdW50UXVldWluZ1N0cmF0ZWd5XCIsXG4gICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIGNvdW50QnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihgQ291bnRRdWV1aW5nU3RyYXRlZ3kucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIENvdW50UXVldWluZ1N0cmF0ZWd5YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIElzQ291bnRRdWV1aW5nU3RyYXRlZ3koeDIpIHtcbiAgICAgICAgICAgIGlmICghdHlwZUlzT2JqZWN0KHgyKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4MiwgXCJfY291bnRRdWV1aW5nU3RyYXRlZ3lIaWdoV2F0ZXJNYXJrXCIpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB4MiBpbnN0YW5jZW9mIENvdW50UXVldWluZ1N0cmF0ZWd5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBjb252ZXJ0VHJhbnNmb3JtZXIob3JpZ2luYWwsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGFzc2VydERpY3Rpb25hcnkob3JpZ2luYWwsIGNvbnRleHQpO1xuICAgICAgICAgICAgY29uc3QgZmx1c2ggPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwuZmx1c2g7XG4gICAgICAgICAgICBjb25zdCByZWFkYWJsZVR5cGUgPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwucmVhZGFibGVUeXBlO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwuc3RhcnQ7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwudHJhbnNmb3JtO1xuICAgICAgICAgICAgY29uc3Qgd3JpdGFibGVUeXBlID0gb3JpZ2luYWwgPT09IG51bGwgfHwgb3JpZ2luYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsLndyaXRhYmxlVHlwZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGZsdXNoOiBmbHVzaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29udmVydFRyYW5zZm9ybWVyRmx1c2hDYWxsYmFjayhmbHVzaCwgb3JpZ2luYWwsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ2ZsdXNoJyB0aGF0YCksXG4gICAgICAgICAgICAgIHJlYWRhYmxlVHlwZSxcbiAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb252ZXJ0VHJhbnNmb3JtZXJTdGFydENhbGxiYWNrKHN0YXJ0LCBvcmlnaW5hbCwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnc3RhcnQnIHRoYXRgKSxcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnZlcnRUcmFuc2Zvcm1lclRyYW5zZm9ybUNhbGxiYWNrKHRyYW5zZm9ybSwgb3JpZ2luYWwsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3RyYW5zZm9ybScgdGhhdGApLFxuICAgICAgICAgICAgICB3cml0YWJsZVR5cGVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIGNvbnZlcnRUcmFuc2Zvcm1lckZsdXNoQ2FsbGJhY2soZm4sIG9yaWdpbmFsLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBhc3NlcnRGdW5jdGlvbihmbiwgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gKGNvbnRyb2xsZXIpID0+IHByb21pc2VDYWxsKGZuLCBvcmlnaW5hbCwgW2NvbnRyb2xsZXJdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gY29udmVydFRyYW5zZm9ybWVyU3RhcnRDYWxsYmFjayhmbiwgb3JpZ2luYWwsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiAoY29udHJvbGxlcikgPT4gcmVmbGVjdENhbGwoZm4sIG9yaWdpbmFsLCBbY29udHJvbGxlcl0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBjb252ZXJ0VHJhbnNmb3JtZXJUcmFuc2Zvcm1DYWxsYmFjayhmbiwgb3JpZ2luYWwsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiAoY2h1bmssIGNvbnRyb2xsZXIpID0+IHByb21pc2VDYWxsKGZuLCBvcmlnaW5hbCwgW2NodW5rLCBjb250cm9sbGVyXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNsYXNzIFRyYW5zZm9ybVN0cmVhbSB7XG4gICAgICAgICAgICBjb25zdHJ1Y3RvcihyYXdUcmFuc2Zvcm1lciA9IHt9LCByYXdXcml0YWJsZVN0cmF0ZWd5ID0ge30sIHJhd1JlYWRhYmxlU3RyYXRlZ3kgPSB7fSkge1xuICAgICAgICAgICAgICBpZiAocmF3VHJhbnNmb3JtZXIgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHJhd1RyYW5zZm9ybWVyID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCB3cml0YWJsZVN0cmF0ZWd5ID0gY29udmVydFF1ZXVpbmdTdHJhdGVneShyYXdXcml0YWJsZVN0cmF0ZWd5LCBcIlNlY29uZCBwYXJhbWV0ZXJcIik7XG4gICAgICAgICAgICAgIGNvbnN0IHJlYWRhYmxlU3RyYXRlZ3kgPSBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5KHJhd1JlYWRhYmxlU3RyYXRlZ3ksIFwiVGhpcmQgcGFyYW1ldGVyXCIpO1xuICAgICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1lciA9IGNvbnZlcnRUcmFuc2Zvcm1lcihyYXdUcmFuc2Zvcm1lciwgXCJGaXJzdCBwYXJhbWV0ZXJcIik7XG4gICAgICAgICAgICAgIGlmICh0cmFuc2Zvcm1lci5yZWFkYWJsZVR5cGUgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCByZWFkYWJsZVR5cGUgc3BlY2lmaWVkXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0cmFuc2Zvcm1lci53cml0YWJsZVR5cGUgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCB3cml0YWJsZVR5cGUgc3BlY2lmaWVkXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IHJlYWRhYmxlSGlnaFdhdGVyTWFyayA9IEV4dHJhY3RIaWdoV2F0ZXJNYXJrKHJlYWRhYmxlU3RyYXRlZ3ksIDApO1xuICAgICAgICAgICAgICBjb25zdCByZWFkYWJsZVNpemVBbGdvcml0aG0gPSBFeHRyYWN0U2l6ZUFsZ29yaXRobShyZWFkYWJsZVN0cmF0ZWd5KTtcbiAgICAgICAgICAgICAgY29uc3Qgd3JpdGFibGVIaWdoV2F0ZXJNYXJrID0gRXh0cmFjdEhpZ2hXYXRlck1hcmsod3JpdGFibGVTdHJhdGVneSwgMSk7XG4gICAgICAgICAgICAgIGNvbnN0IHdyaXRhYmxlU2l6ZUFsZ29yaXRobSA9IEV4dHJhY3RTaXplQWxnb3JpdGhtKHdyaXRhYmxlU3RyYXRlZ3kpO1xuICAgICAgICAgICAgICBsZXQgc3RhcnRQcm9taXNlX3Jlc29sdmU7XG4gICAgICAgICAgICAgIGNvbnN0IHN0YXJ0UHJvbWlzZSA9IG5ld1Byb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICBzdGFydFByb21pc2VfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBJbml0aWFsaXplVHJhbnNmb3JtU3RyZWFtKHRoaXMsIHN0YXJ0UHJvbWlzZSwgd3JpdGFibGVIaWdoV2F0ZXJNYXJrLCB3cml0YWJsZVNpemVBbGdvcml0aG0sIHJlYWRhYmxlSGlnaFdhdGVyTWFyaywgcmVhZGFibGVTaXplQWxnb3JpdGhtKTtcbiAgICAgICAgICAgICAgU2V0VXBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckZyb21UcmFuc2Zvcm1lcih0aGlzLCB0cmFuc2Zvcm1lcik7XG4gICAgICAgICAgICAgIGlmICh0cmFuc2Zvcm1lci5zdGFydCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRQcm9taXNlX3Jlc29sdmUodHJhbnNmb3JtZXIuc3RhcnQodGhpcy5fdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlcikpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXJ0UHJvbWlzZV9yZXNvbHZlKHZvaWQgMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdldCByZWFkYWJsZSgpIHtcbiAgICAgICAgICAgICAgaWYgKCFJc1RyYW5zZm9ybVN0cmVhbSh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24oXCJyZWFkYWJsZVwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVhZGFibGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZXQgd3JpdGFibGUoKSB7XG4gICAgICAgICAgICAgIGlmICghSXNUcmFuc2Zvcm1TdHJlYW0odGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uKFwid3JpdGFibGVcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhUcmFuc2Zvcm1TdHJlYW0ucHJvdG90eXBlLCB7XG4gICAgICAgICAgICByZWFkYWJsZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgICAgICB3cml0YWJsZTogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAodHlwZW9mIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnID09PSBcInN5bWJvbFwiKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVHJhbnNmb3JtU3RyZWFtLnByb3RvdHlwZSwgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IFwiVHJhbnNmb3JtU3RyZWFtXCIsXG4gICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIEluaXRpYWxpemVUcmFuc2Zvcm1TdHJlYW0oc3RyZWFtLCBzdGFydFByb21pc2UsIHdyaXRhYmxlSGlnaFdhdGVyTWFyaywgd3JpdGFibGVTaXplQWxnb3JpdGhtLCByZWFkYWJsZUhpZ2hXYXRlck1hcmssIHJlYWRhYmxlU2l6ZUFsZ29yaXRobSkge1xuICAgICAgICAgICAgZnVuY3Rpb24gc3RhcnRBbGdvcml0aG0oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzdGFydFByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiB3cml0ZUFsZ29yaXRobShjaHVuaykge1xuICAgICAgICAgICAgICByZXR1cm4gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNpbmtXcml0ZUFsZ29yaXRobShzdHJlYW0sIGNodW5rKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGFib3J0QWxnb3JpdGhtKHJlYXNvbikge1xuICAgICAgICAgICAgICByZXR1cm4gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNpbmtBYm9ydEFsZ29yaXRobShzdHJlYW0sIHJlYXNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBjbG9zZUFsZ29yaXRobSgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTaW5rQ2xvc2VBbGdvcml0aG0oc3RyZWFtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0cmVhbS5fd3JpdGFibGUgPSBDcmVhdGVXcml0YWJsZVN0cmVhbShzdGFydEFsZ29yaXRobSwgd3JpdGVBbGdvcml0aG0sIGNsb3NlQWxnb3JpdGhtLCBhYm9ydEFsZ29yaXRobSwgd3JpdGFibGVIaWdoV2F0ZXJNYXJrLCB3cml0YWJsZVNpemVBbGdvcml0aG0pO1xuICAgICAgICAgICAgZnVuY3Rpb24gcHVsbEFsZ29yaXRobSgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTb3VyY2VQdWxsQWxnb3JpdGhtKHN0cmVhbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBjYW5jZWxBbGdvcml0aG0ocmVhc29uKSB7XG4gICAgICAgICAgICAgIFRyYW5zZm9ybVN0cmVhbUVycm9yV3JpdGFibGVBbmRVbmJsb2NrV3JpdGUoc3RyZWFtLCByZWFzb24pO1xuICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh2b2lkIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyZWFtLl9yZWFkYWJsZSA9IENyZWF0ZVJlYWRhYmxlU3RyZWFtKHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWxBbGdvcml0aG0sIHJlYWRhYmxlSGlnaFdhdGVyTWFyaywgcmVhZGFibGVTaXplQWxnb3JpdGhtKTtcbiAgICAgICAgICAgIHN0cmVhbS5fYmFja3ByZXNzdXJlID0gdm9pZCAwO1xuICAgICAgICAgICAgc3RyZWFtLl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlID0gdm9pZCAwO1xuICAgICAgICAgICAgc3RyZWFtLl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlX3Jlc29sdmUgPSB2b2lkIDA7XG4gICAgICAgICAgICBUcmFuc2Zvcm1TdHJlYW1TZXRCYWNrcHJlc3N1cmUoc3RyZWFtLCB0cnVlKTtcbiAgICAgICAgICAgIHN0cmVhbS5fdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlciA9IHZvaWQgMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gSXNUcmFuc2Zvcm1TdHJlYW0oeDIpIHtcbiAgICAgICAgICAgIGlmICghdHlwZUlzT2JqZWN0KHgyKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4MiwgXCJfdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlclwiKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geDIgaW5zdGFuY2VvZiBUcmFuc2Zvcm1TdHJlYW07XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbUVycm9yKHN0cmVhbSwgZTIpIHtcbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihzdHJlYW0uX3JlYWRhYmxlLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIGUyKTtcbiAgICAgICAgICAgIFRyYW5zZm9ybVN0cmVhbUVycm9yV3JpdGFibGVBbmRVbmJsb2NrV3JpdGUoc3RyZWFtLCBlMik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbUVycm9yV3JpdGFibGVBbmRVbmJsb2NrV3JpdGUoc3RyZWFtLCBlMikge1xuICAgICAgICAgICAgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoc3RyZWFtLl90cmFuc2Zvcm1TdHJlYW1Db250cm9sbGVyKTtcbiAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcklmTmVlZGVkKHN0cmVhbS5fd3JpdGFibGUuX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlciwgZTIpO1xuICAgICAgICAgICAgaWYgKHN0cmVhbS5fYmFja3ByZXNzdXJlKSB7XG4gICAgICAgICAgICAgIFRyYW5zZm9ybVN0cmVhbVNldEJhY2twcmVzc3VyZShzdHJlYW0sIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtU2V0QmFja3ByZXNzdXJlKHN0cmVhbSwgYmFja3ByZXNzdXJlKSB7XG4gICAgICAgICAgICBpZiAoc3RyZWFtLl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgc3RyZWFtLl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlX3Jlc29sdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0cmVhbS5fYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZSA9IG5ld1Byb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgc3RyZWFtLl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdHJlYW0uX2JhY2twcmVzc3VyZSA9IGJhY2twcmVzc3VyZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2xhc3MgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIge1xuICAgICAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGNvbnN0cnVjdG9yXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2V0IGRlc2lyZWRTaXplKCkge1xuICAgICAgICAgICAgICBpZiAoIUlzVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oXCJkZXNpcmVkU2l6ZVwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCByZWFkYWJsZUNvbnRyb2xsZXIgPSB0aGlzLl9jb250cm9sbGVkVHJhbnNmb3JtU3RyZWFtLl9yZWFkYWJsZS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyO1xuICAgICAgICAgICAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldERlc2lyZWRTaXplKHJlYWRhYmxlQ29udHJvbGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbnF1ZXVlKGNodW5rID0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIGlmICghSXNUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcih0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbihcImVucXVldWVcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlKHRoaXMsIGNodW5rKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVycm9yKHJlYXNvbiA9IHZvaWQgMCkge1xuICAgICAgICAgICAgICBpZiAoIUlzVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oXCJlcnJvclwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKHRoaXMsIHJlYXNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZXJtaW5hdGUoKSB7XG4gICAgICAgICAgICAgIGlmICghSXNUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcih0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbihcInRlcm1pbmF0ZVwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlclRlcm1pbmF0ZSh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLCB7XG4gICAgICAgICAgICBlbnF1ZXVlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgICAgIGVycm9yOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgICAgIHRlcm1pbmF0ZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgICAgICBkZXNpcmVkU2l6ZTogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAodHlwZW9mIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnID09PSBcInN5bWJvbFwiKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLCBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZywge1xuICAgICAgICAgICAgICB2YWx1ZTogXCJUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlclwiLFxuICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBJc1RyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHgyKSB7XG4gICAgICAgICAgICBpZiAoIXR5cGVJc09iamVjdCh4MikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeDIsIFwiX2NvbnRyb2xsZWRUcmFuc2Zvcm1TdHJlYW1cIikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHgyIGluc3RhbmNlb2YgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFNldFVwVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIoc3RyZWFtLCBjb250cm9sbGVyLCB0cmFuc2Zvcm1BbGdvcml0aG0sIGZsdXNoQWxnb3JpdGhtKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLl9jb250cm9sbGVkVHJhbnNmb3JtU3RyZWFtID0gc3RyZWFtO1xuICAgICAgICAgICAgc3RyZWFtLl90cmFuc2Zvcm1TdHJlYW1Db250cm9sbGVyID0gY29udHJvbGxlcjtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuX3RyYW5zZm9ybUFsZ29yaXRobSA9IHRyYW5zZm9ybUFsZ29yaXRobTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuX2ZsdXNoQWxnb3JpdGhtID0gZmx1c2hBbGdvcml0aG07XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFNldFVwVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJGcm9tVHJhbnNmb3JtZXIoc3RyZWFtLCB0cmFuc2Zvcm1lcikge1xuICAgICAgICAgICAgY29uc3QgY29udHJvbGxlciA9IE9iamVjdC5jcmVhdGUoVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlKTtcbiAgICAgICAgICAgIGxldCB0cmFuc2Zvcm1BbGdvcml0aG0gPSAoY2h1bmspID0+IHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWUoY29udHJvbGxlciwgY2h1bmspO1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHZvaWQgMCk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKHRyYW5zZm9ybVJlc3VsdEUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aCh0cmFuc2Zvcm1SZXN1bHRFKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBmbHVzaEFsZ29yaXRobSA9ICgpID0+IHByb21pc2VSZXNvbHZlZFdpdGgodm9pZCAwKTtcbiAgICAgICAgICAgIGlmICh0cmFuc2Zvcm1lci50cmFuc2Zvcm0gIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm1BbGdvcml0aG0gPSAoY2h1bmspID0+IHRyYW5zZm9ybWVyLnRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJhbnNmb3JtZXIuZmx1c2ggIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBmbHVzaEFsZ29yaXRobSA9ICgpID0+IHRyYW5zZm9ybWVyLmZsdXNoKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgU2V0VXBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcihzdHJlYW0sIGNvbnRyb2xsZXIsIHRyYW5zZm9ybUFsZ29yaXRobSwgZmx1c2hBbGdvcml0aG0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLl90cmFuc2Zvcm1BbGdvcml0aG0gPSB2b2lkIDA7XG4gICAgICAgICAgICBjb250cm9sbGVyLl9mbHVzaEFsZ29yaXRobSA9IHZvaWQgMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlKGNvbnRyb2xsZXIsIGNodW5rKSB7XG4gICAgICAgICAgICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkVHJhbnNmb3JtU3RyZWFtO1xuICAgICAgICAgICAgY29uc3QgcmVhZGFibGVDb250cm9sbGVyID0gc3RyZWFtLl9yZWFkYWJsZS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyO1xuICAgICAgICAgICAgaWYgKCFSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FuQ2xvc2VPckVucXVldWUocmVhZGFibGVDb250cm9sbGVyKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUmVhZGFibGUgc2lkZSBpcyBub3QgaW4gYSBzdGF0ZSB0aGF0IHBlcm1pdHMgZW5xdWV1ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlKHJlYWRhYmxlQ29udHJvbGxlciwgY2h1bmspO1xuICAgICAgICAgICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgICAgICAgICAgVHJhbnNmb3JtU3RyZWFtRXJyb3JXcml0YWJsZUFuZFVuYmxvY2tXcml0ZShzdHJlYW0sIGUyKTtcbiAgICAgICAgICAgICAgdGhyb3cgc3RyZWFtLl9yZWFkYWJsZS5fc3RvcmVkRXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBiYWNrcHJlc3N1cmUgPSBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVySGFzQmFja3ByZXNzdXJlKHJlYWRhYmxlQ29udHJvbGxlcik7XG4gICAgICAgICAgICBpZiAoYmFja3ByZXNzdXJlICE9PSBzdHJlYW0uX2JhY2twcmVzc3VyZSkge1xuICAgICAgICAgICAgICBUcmFuc2Zvcm1TdHJlYW1TZXRCYWNrcHJlc3N1cmUoc3RyZWFtLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBlMikge1xuICAgICAgICAgICAgVHJhbnNmb3JtU3RyZWFtRXJyb3IoY29udHJvbGxlci5fY29udHJvbGxlZFRyYW5zZm9ybVN0cmVhbSwgZTIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlclBlcmZvcm1UcmFuc2Zvcm0oY29udHJvbGxlciwgY2h1bmspIHtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybVByb21pc2UgPSBjb250cm9sbGVyLl90cmFuc2Zvcm1BbGdvcml0aG0oY2h1bmspO1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybVByb21pc2VXaXRoKHRyYW5zZm9ybVByb21pc2UsIHZvaWQgMCwgKHIyMikgPT4ge1xuICAgICAgICAgICAgICBUcmFuc2Zvcm1TdHJlYW1FcnJvcihjb250cm9sbGVyLl9jb250cm9sbGVkVHJhbnNmb3JtU3RyZWFtLCByMjIpO1xuICAgICAgICAgICAgICB0aHJvdyByMjI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJUZXJtaW5hdGUoY29udHJvbGxlcikge1xuICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFRyYW5zZm9ybVN0cmVhbTtcbiAgICAgICAgICAgIGNvbnN0IHJlYWRhYmxlQ29udHJvbGxlciA9IHN0cmVhbS5fcmVhZGFibGUuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcjtcbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZShyZWFkYWJsZUNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgVHlwZUVycm9yKFwiVHJhbnNmb3JtU3RyZWFtIHRlcm1pbmF0ZWRcIik7XG4gICAgICAgICAgICBUcmFuc2Zvcm1TdHJlYW1FcnJvcldyaXRhYmxlQW5kVW5ibG9ja1dyaXRlKHN0cmVhbSwgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U2lua1dyaXRlQWxnb3JpdGhtKHN0cmVhbSwgY2h1bmspIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBzdHJlYW0uX3RyYW5zZm9ybVN0cmVhbUNvbnRyb2xsZXI7XG4gICAgICAgICAgICBpZiAoc3RyZWFtLl9iYWNrcHJlc3N1cmUpIHtcbiAgICAgICAgICAgICAgY29uc3QgYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZSA9IHN0cmVhbS5fYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybVByb21pc2VXaXRoKGJhY2twcmVzc3VyZUNoYW5nZVByb21pc2UsICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB3cml0YWJsZSA9IHN0cmVhbS5fd3JpdGFibGU7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB3cml0YWJsZS5fc3RhdGU7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlID09PSBcImVycm9yaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IHdyaXRhYmxlLl9zdG9yZWRFcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyUGVyZm9ybVRyYW5zZm9ybShjb250cm9sbGVyLCBjaHVuayk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyUGVyZm9ybVRyYW5zZm9ybShjb250cm9sbGVyLCBjaHVuayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTaW5rQWJvcnRBbGdvcml0aG0oc3RyZWFtLCByZWFzb24pIHtcbiAgICAgICAgICAgIFRyYW5zZm9ybVN0cmVhbUVycm9yKHN0cmVhbSwgcmVhc29uKTtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHZvaWQgMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTaW5rQ2xvc2VBbGdvcml0aG0oc3RyZWFtKSB7XG4gICAgICAgICAgICBjb25zdCByZWFkYWJsZSA9IHN0cmVhbS5fcmVhZGFibGU7XG4gICAgICAgICAgICBjb25zdCBjb250cm9sbGVyID0gc3RyZWFtLl90cmFuc2Zvcm1TdHJlYW1Db250cm9sbGVyO1xuICAgICAgICAgICAgY29uc3QgZmx1c2hQcm9taXNlID0gY29udHJvbGxlci5fZmx1c2hBbGdvcml0aG0oKTtcbiAgICAgICAgICAgIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybVByb21pc2VXaXRoKGZsdXNoUHJvbWlzZSwgKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAocmVhZGFibGUuX3N0YXRlID09PSBcImVycm9yZWRcIikge1xuICAgICAgICAgICAgICAgIHRocm93IHJlYWRhYmxlLl9zdG9yZWRFcnJvcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xvc2UocmVhZGFibGUuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcik7XG4gICAgICAgICAgICB9LCAocjIyKSA9PiB7XG4gICAgICAgICAgICAgIFRyYW5zZm9ybVN0cmVhbUVycm9yKHN0cmVhbSwgcjIyKTtcbiAgICAgICAgICAgICAgdGhyb3cgcmVhZGFibGUuX3N0b3JlZEVycm9yO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTb3VyY2VQdWxsQWxnb3JpdGhtKHN0cmVhbSkge1xuICAgICAgICAgICAgVHJhbnNmb3JtU3RyZWFtU2V0QmFja3ByZXNzdXJlKHN0cmVhbSwgZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHN0cmVhbS5fYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKGBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihgVHJhbnNmb3JtU3RyZWFtLnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBUcmFuc2Zvcm1TdHJlYW1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwb3J0czIyLkJ5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3kgPSBCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5O1xuICAgICAgICAgIGV4cG9ydHMyMi5Db3VudFF1ZXVpbmdTdHJhdGVneSA9IENvdW50UXVldWluZ1N0cmF0ZWd5O1xuICAgICAgICAgIGV4cG9ydHMyMi5SZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyID0gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcjtcbiAgICAgICAgICBleHBvcnRzMjIuUmVhZGFibGVTdHJlYW0gPSBSZWFkYWJsZVN0cmVhbTI7XG4gICAgICAgICAgZXhwb3J0czIyLlJlYWRhYmxlU3RyZWFtQllPQlJlYWRlciA9IFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlcjtcbiAgICAgICAgICBleHBvcnRzMjIuUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCA9IFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3Q7XG4gICAgICAgICAgZXhwb3J0czIyLlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIgPSBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyO1xuICAgICAgICAgIGV4cG9ydHMyMi5SZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIgPSBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXI7XG4gICAgICAgICAgZXhwb3J0czIyLlRyYW5zZm9ybVN0cmVhbSA9IFRyYW5zZm9ybVN0cmVhbTtcbiAgICAgICAgICBleHBvcnRzMjIuVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIgPSBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcjtcbiAgICAgICAgICBleHBvcnRzMjIuV3JpdGFibGVTdHJlYW0gPSBXcml0YWJsZVN0cmVhbTtcbiAgICAgICAgICBleHBvcnRzMjIuV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlciA9IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI7XG4gICAgICAgICAgZXhwb3J0czIyLldyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlciA9IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcjtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0czIyLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIHJlcXVpcmVfc3RyZWFtcyA9IF9fY29tbW9uSlMyKHtcbiAgICAgIFwibm9kZV9tb2R1bGVzL2ZldGNoLWJsb2Ivc3RyZWFtcy5janNcIigpIHtcbiAgICAgICAgdmFyIFBPT0xfU0laRTIgPSA2NTUzNjtcbiAgICAgICAgaWYgKCFnbG9iYWxUaGlzLlJlYWRhYmxlU3RyZWFtKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3MyID0gcmVxdWlyZShcInByb2Nlc3NcIik7XG4gICAgICAgICAgICBjb25zdCB7IGVtaXRXYXJuaW5nIH0gPSBwcm9jZXNzMjtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHByb2Nlc3MyLmVtaXRXYXJuaW5nID0gKCkgPT4ge1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGdsb2JhbFRoaXMsIHJlcXVpcmUoXCJzdHJlYW0vd2ViXCIpKTtcbiAgICAgICAgICAgICAgcHJvY2VzczIuZW1pdFdhcm5pbmcgPSBlbWl0V2FybmluZztcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIHByb2Nlc3MyLmVtaXRXYXJuaW5nID0gZW1pdFdhcm5pbmc7XG4gICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGdsb2JhbFRoaXMsIHJlcXVpcmVfcG9ueWZpbGxfZXMyMDE4KCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHsgQmxvYjogQmxvYjMgfSA9IHJlcXVpcmUoXCJidWZmZXJcIik7XG4gICAgICAgICAgaWYgKEJsb2IzICYmICFCbG9iMy5wcm90b3R5cGUuc3RyZWFtKSB7XG4gICAgICAgICAgICBCbG9iMy5wcm90b3R5cGUuc3RyZWFtID0gZnVuY3Rpb24gbmFtZShwYXJhbXMpIHtcbiAgICAgICAgICAgICAgbGV0IHBvc2l0aW9uID0gMDtcbiAgICAgICAgICAgICAgY29uc3QgYmxvYiA9IHRoaXM7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiYnl0ZXNcIixcbiAgICAgICAgICAgICAgICBhc3luYyBwdWxsKGN0cmwpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gYmxvYi5zbGljZShwb3NpdGlvbiwgTWF0aC5taW4oYmxvYi5zaXplLCBwb3NpdGlvbiArIFBPT0xfU0laRTIpKTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IGF3YWl0IGNodW5rLmFycmF5QnVmZmVyKCk7XG4gICAgICAgICAgICAgICAgICBwb3NpdGlvbiArPSBidWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICAgIGN0cmwuZW5xdWV1ZShuZXcgVWludDhBcnJheShidWZmZXIpKTtcbiAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PT0gYmxvYi5zaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBhc3luYyBmdW5jdGlvbiogdG9JdGVyYXRvcihwYXJ0cywgY2xvbmUyID0gdHJ1ZSkge1xuICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgICAgIGlmIChcInN0cmVhbVwiIGluIHBhcnQpIHtcbiAgICAgICAgICB5aWVsZCogcGFydC5zdHJlYW0oKTtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcocGFydCkpIHtcbiAgICAgICAgICBpZiAoY2xvbmUyKSB7XG4gICAgICAgICAgICBsZXQgcG9zaXRpb24gPSBwYXJ0LmJ5dGVPZmZzZXQ7XG4gICAgICAgICAgICBjb25zdCBlbmQgPSBwYXJ0LmJ5dGVPZmZzZXQgKyBwYXJ0LmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAocG9zaXRpb24gIT09IGVuZCkge1xuICAgICAgICAgICAgICBjb25zdCBzaXplID0gTWF0aC5taW4oZW5kIC0gcG9zaXRpb24sIFBPT0xfU0laRSk7XG4gICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gcGFydC5idWZmZXIuc2xpY2UocG9zaXRpb24sIHBvc2l0aW9uICsgc2l6ZSk7XG4gICAgICAgICAgICAgIHBvc2l0aW9uICs9IGNodW5rLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICAgIHlpZWxkIG5ldyBVaW50OEFycmF5KGNodW5rKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeWllbGQgcGFydDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0IHBvc2l0aW9uID0gMCwgYiA9IHBhcnQ7XG4gICAgICAgICAgd2hpbGUgKHBvc2l0aW9uICE9PSBiLnNpemUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNodW5rID0gYi5zbGljZShwb3NpdGlvbiwgTWF0aC5taW4oYi5zaXplLCBwb3NpdGlvbiArIFBPT0xfU0laRSkpO1xuICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gYXdhaXQgY2h1bmsuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgICAgIHBvc2l0aW9uICs9IGJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgeWllbGQgbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGltcG9ydF9zdHJlYW1zO1xuICAgIHZhciBQT09MX1NJWkU7XG4gICAgdmFyIF9CbG9iO1xuICAgIHZhciBCbG9iMjtcbiAgICB2YXIgZmV0Y2hfYmxvYl9kZWZhdWx0O1xuICAgIHZhciBpbml0X2ZldGNoX2Jsb2IgPSBfX2VzbSh7XG4gICAgICBcIm5vZGVfbW9kdWxlcy9mZXRjaC1ibG9iL2luZGV4LmpzXCIoKSB7XG4gICAgICAgIGltcG9ydF9zdHJlYW1zID0gX190b01vZHVsZShyZXF1aXJlX3N0cmVhbXMoKSk7XG4gICAgICAgIFBPT0xfU0laRSA9IDY1NTM2O1xuICAgICAgICBfQmxvYiA9IGNsYXNzIEJsb2IzIHtcbiAgICAgICAgICAjcGFydHMgPSBbXTtcbiAgICAgICAgICAjdHlwZSA9IFwiXCI7XG4gICAgICAgICAgI3NpemUgPSAwO1xuICAgICAgICAgICNlbmRpbmdzID0gXCJ0cmFuc3BhcmVudFwiO1xuICAgICAgICAgIGNvbnN0cnVjdG9yKGJsb2JQYXJ0cyA9IFtdLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYmxvYlBhcnRzICE9PSBcIm9iamVjdFwiIHx8IGJsb2JQYXJ0cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnQmxvYic6IFRoZSBwcm92aWRlZCB2YWx1ZSBjYW5ub3QgYmUgY29udmVydGVkIHRvIGEgc2VxdWVuY2UuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBibG9iUGFydHNbU3ltYm9sLml0ZXJhdG9yXSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdCbG9iJzogVGhlIG9iamVjdCBtdXN0IGhhdmUgYSBjYWxsYWJsZSBAQGl0ZXJhdG9yIHByb3BlcnR5LlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb3B0aW9ucyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdCbG9iJzogcGFyYW1ldGVyIDIgY2Fubm90IGNvbnZlcnQgdG8gZGljdGlvbmFyeS5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbClcbiAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGJsb2JQYXJ0cykge1xuICAgICAgICAgICAgICBsZXQgcGFydDtcbiAgICAgICAgICAgICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIHBhcnQgPSBuZXcgVWludDhBcnJheShlbGVtZW50LmJ1ZmZlci5zbGljZShlbGVtZW50LmJ5dGVPZmZzZXQsIGVsZW1lbnQuYnl0ZU9mZnNldCArIGVsZW1lbnQuYnl0ZUxlbmd0aCkpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIHBhcnQgPSBuZXcgVWludDhBcnJheShlbGVtZW50LnNsaWNlKDApKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50IGluc3RhbmNlb2YgQmxvYjMpIHtcbiAgICAgICAgICAgICAgICBwYXJ0ID0gZWxlbWVudDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJ0ID0gZW5jb2Rlci5lbmNvZGUoYCR7ZWxlbWVudH1gKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLiNzaXplICs9IEFycmF5QnVmZmVyLmlzVmlldyhwYXJ0KSA/IHBhcnQuYnl0ZUxlbmd0aCA6IHBhcnQuc2l6ZTtcbiAgICAgICAgICAgICAgdGhpcy4jcGFydHMucHVzaChwYXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI2VuZGluZ3MgPSBgJHtvcHRpb25zLmVuZGluZ3MgPT09IHZvaWQgMCA/IFwidHJhbnNwYXJlbnRcIiA6IG9wdGlvbnMuZW5kaW5nc31gO1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IG9wdGlvbnMudHlwZSA9PT0gdm9pZCAwID8gXCJcIiA6IFN0cmluZyhvcHRpb25zLnR5cGUpO1xuICAgICAgICAgICAgdGhpcy4jdHlwZSA9IC9eW1xceDIwLVxceDdFXSokLy50ZXN0KHR5cGUpID8gdHlwZSA6IFwiXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGdldCBzaXplKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3NpemU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGdldCB0eXBlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3R5cGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFzeW5jIHRleHQoKSB7XG4gICAgICAgICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gICAgICAgICAgICBsZXQgc3RyID0gXCJcIjtcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgcGFydCBvZiB0b0l0ZXJhdG9yKHRoaXMuI3BhcnRzLCBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgc3RyICs9IGRlY29kZXIuZGVjb2RlKHBhcnQsIHsgc3RyZWFtOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyICs9IGRlY29kZXIuZGVjb2RlKCk7XG4gICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhc3luYyBhcnJheUJ1ZmZlcigpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheSh0aGlzLnNpemUpO1xuICAgICAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHRvSXRlcmF0b3IodGhpcy4jcGFydHMsIGZhbHNlKSkge1xuICAgICAgICAgICAgICBkYXRhLnNldChjaHVuaywgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgb2Zmc2V0ICs9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXRhLmJ1ZmZlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RyZWFtKCkge1xuICAgICAgICAgICAgY29uc3QgaXQgPSB0b0l0ZXJhdG9yKHRoaXMuI3BhcnRzLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgZ2xvYmFsVGhpcy5SZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYnl0ZXNcIixcbiAgICAgICAgICAgICAgYXN5bmMgcHVsbChjdHJsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBhd2FpdCBpdC5uZXh0KCk7XG4gICAgICAgICAgICAgICAgY2h1bmsuZG9uZSA/IGN0cmwuY2xvc2UoKSA6IGN0cmwuZW5xdWV1ZShjaHVuay52YWx1ZSk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGFzeW5jIGNhbmNlbCgpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBpdC5yZXR1cm4oKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNsaWNlKHN0YXJ0ID0gMCwgZW5kID0gdGhpcy5zaXplLCB0eXBlID0gXCJcIikge1xuICAgICAgICAgICAgY29uc3QgeyBzaXplIH0gPSB0aGlzO1xuICAgICAgICAgICAgbGV0IHJlbGF0aXZlU3RhcnQgPSBzdGFydCA8IDAgPyBNYXRoLm1heChzaXplICsgc3RhcnQsIDApIDogTWF0aC5taW4oc3RhcnQsIHNpemUpO1xuICAgICAgICAgICAgbGV0IHJlbGF0aXZlRW5kID0gZW5kIDwgMCA/IE1hdGgubWF4KHNpemUgKyBlbmQsIDApIDogTWF0aC5taW4oZW5kLCBzaXplKTtcbiAgICAgICAgICAgIGNvbnN0IHNwYW4gPSBNYXRoLm1heChyZWxhdGl2ZUVuZCAtIHJlbGF0aXZlU3RhcnQsIDApO1xuICAgICAgICAgICAgY29uc3QgcGFydHMgPSB0aGlzLiNwYXJ0cztcbiAgICAgICAgICAgIGNvbnN0IGJsb2JQYXJ0cyA9IFtdO1xuICAgICAgICAgICAgbGV0IGFkZGVkID0gMDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgICAgICAgICAgICBpZiAoYWRkZWQgPj0gc3Bhbikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IHNpemUyID0gQXJyYXlCdWZmZXIuaXNWaWV3KHBhcnQpID8gcGFydC5ieXRlTGVuZ3RoIDogcGFydC5zaXplO1xuICAgICAgICAgICAgICBpZiAocmVsYXRpdmVTdGFydCAmJiBzaXplMiA8PSByZWxhdGl2ZVN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgcmVsYXRpdmVTdGFydCAtPSBzaXplMjtcbiAgICAgICAgICAgICAgICByZWxhdGl2ZUVuZCAtPSBzaXplMjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgY2h1bms7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhwYXJ0KSkge1xuICAgICAgICAgICAgICAgICAgY2h1bmsgPSBwYXJ0LnN1YmFycmF5KHJlbGF0aXZlU3RhcnQsIE1hdGgubWluKHNpemUyLCByZWxhdGl2ZUVuZCkpO1xuICAgICAgICAgICAgICAgICAgYWRkZWQgKz0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY2h1bmsgPSBwYXJ0LnNsaWNlKHJlbGF0aXZlU3RhcnQsIE1hdGgubWluKHNpemUyLCByZWxhdGl2ZUVuZCkpO1xuICAgICAgICAgICAgICAgICAgYWRkZWQgKz0gY2h1bmsuc2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVsYXRpdmVFbmQgLT0gc2l6ZTI7XG4gICAgICAgICAgICAgICAgYmxvYlBhcnRzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgICAgIHJlbGF0aXZlU3RhcnQgPSAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBibG9iID0gbmV3IEJsb2IzKFtdLCB7IHR5cGU6IFN0cmluZyh0eXBlKS50b0xvd2VyQ2FzZSgpIH0pO1xuICAgICAgICAgICAgYmxvYi4jc2l6ZSA9IHNwYW47XG4gICAgICAgICAgICBibG9iLiNwYXJ0cyA9IGJsb2JQYXJ0cztcbiAgICAgICAgICAgIHJldHVybiBibG9iO1xuICAgICAgICAgIH1cbiAgICAgICAgICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJCbG9iXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YXRpYyBbU3ltYm9sLmhhc0luc3RhbmNlXShvYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3QgJiYgdHlwZW9mIG9iamVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgKHR5cGVvZiBvYmplY3Quc3RyZWFtID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIG9iamVjdC5hcnJheUJ1ZmZlciA9PT0gXCJmdW5jdGlvblwiKSAmJiAvXihCbG9ifEZpbGUpJC8udGVzdChvYmplY3RbU3ltYm9sLnRvU3RyaW5nVGFnXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhfQmxvYi5wcm90b3R5cGUsIHtcbiAgICAgICAgICBzaXplOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgICB0eXBlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgICBzbGljZTogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbiAgICAgICAgfSk7XG4gICAgICAgIEJsb2IyID0gX0Jsb2I7XG4gICAgICAgIGZldGNoX2Jsb2JfZGVmYXVsdCA9IEJsb2IyO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBfRmlsZTtcbiAgICB2YXIgRmlsZTI7XG4gICAgdmFyIGZpbGVfZGVmYXVsdDtcbiAgICB2YXIgaW5pdF9maWxlID0gX19lc20oe1xuICAgICAgXCJub2RlX21vZHVsZXMvZmV0Y2gtYmxvYi9maWxlLmpzXCIoKSB7XG4gICAgICAgIGluaXRfZmV0Y2hfYmxvYigpO1xuICAgICAgICBfRmlsZSA9IGNsYXNzIEZpbGUgZXh0ZW5kcyBmZXRjaF9ibG9iX2RlZmF1bHQge1xuICAgICAgICAgICNsYXN0TW9kaWZpZWQgPSAwO1xuICAgICAgICAgICNuYW1lID0gXCJcIjtcbiAgICAgICAgICBjb25zdHJ1Y3RvcihmaWxlQml0cywgZmlsZU5hbWUsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEZhaWxlZCB0byBjb25zdHJ1Y3QgJ0ZpbGUnOiAyIGFyZ3VtZW50cyByZXF1aXJlZCwgYnV0IG9ubHkgJHthcmd1bWVudHMubGVuZ3RofSBwcmVzZW50LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3VwZXIoZmlsZUJpdHMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwpXG4gICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RNb2RpZmllZCA9IG9wdGlvbnMubGFzdE1vZGlmaWVkID09PSB2b2lkIDAgPyBEYXRlLm5vdygpIDogTnVtYmVyKG9wdGlvbnMubGFzdE1vZGlmaWVkKTtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzTmFOKGxhc3RNb2RpZmllZCkpIHtcbiAgICAgICAgICAgICAgdGhpcy4jbGFzdE1vZGlmaWVkID0gbGFzdE1vZGlmaWVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4jbmFtZSA9IFN0cmluZyhmaWxlTmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGdldCBuYW1lKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI25hbWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGdldCBsYXN0TW9kaWZpZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jbGFzdE1vZGlmaWVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJGaWxlXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YXRpYyBbU3ltYm9sLmhhc0luc3RhbmNlXShvYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiAhIW9iamVjdCAmJiBvYmplY3QgaW5zdGFuY2VvZiBmZXRjaF9ibG9iX2RlZmF1bHQgJiYgL14oRmlsZSkkLy50ZXN0KG9iamVjdFtTeW1ib2wudG9TdHJpbmdUYWddKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEZpbGUyID0gX0ZpbGU7XG4gICAgICAgIGZpbGVfZGVmYXVsdCA9IEZpbGUyO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGZvcm1EYXRhVG9CbG9iKEYyLCBCID0gZmV0Y2hfYmxvYl9kZWZhdWx0KSB7XG4gICAgICB2YXIgYiA9IGAke3IyKCl9JHtyMigpfWAucmVwbGFjZSgvXFwuL2csIFwiXCIpLnNsaWNlKC0yOCkucGFkU3RhcnQoMzIsIFwiLVwiKSwgYyA9IFtdLCBwID0gYC0tJHtifVxcclxuQ29udGVudC1EaXNwb3NpdGlvbjogZm9ybS1kYXRhOyBuYW1lPVwiYDtcbiAgICAgIEYyLmZvckVhY2goKHYsIG4pID0+IHR5cGVvZiB2ID09IFwic3RyaW5nXCIgPyBjLnB1c2gocCArIGUobikgKyBgXCJcXHJcblxcclxuJHt2LnJlcGxhY2UoL1xccig/IVxcbil8KD88IVxccilcXG4vZywgXCJcXHJcXG5cIil9XFxyXG5gKSA6IGMucHVzaChwICsgZShuKSArIGBcIjsgZmlsZW5hbWU9XCIke2Uodi5uYW1lLCAxKX1cIlxcclxuQ29udGVudC1UeXBlOiAke3YudHlwZSB8fCBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwifVxcclxuXFxyXG5gLCB2LCBcIlxcclxcblwiKSk7XG4gICAgICBjLnB1c2goYC0tJHtifS0tYCk7XG4gICAgICByZXR1cm4gbmV3IEIoYywgeyB0eXBlOiBcIm11bHRpcGFydC9mb3JtLWRhdGE7IGJvdW5kYXJ5PVwiICsgYiB9KTtcbiAgICB9XG4gICAgdmFyIHQ7XG4gICAgdmFyIGk7XG4gICAgdmFyIGg7XG4gICAgdmFyIHIyO1xuICAgIHZhciBtO1xuICAgIHZhciBmO1xuICAgIHZhciBlO1xuICAgIHZhciB4O1xuICAgIHZhciBGb3JtRGF0YTtcbiAgICB2YXIgaW5pdF9lc21fbWluID0gX19lc20oe1xuICAgICAgXCJub2RlX21vZHVsZXMvZm9ybWRhdGEtcG9seWZpbGwvZXNtLm1pbi5qc1wiKCkge1xuICAgICAgICBpbml0X2ZldGNoX2Jsb2IoKTtcbiAgICAgICAgaW5pdF9maWxlKCk7XG4gICAgICAgICh7IHRvU3RyaW5nVGFnOiB0LCBpdGVyYXRvcjogaSwgaGFzSW5zdGFuY2U6IGggfSA9IFN5bWJvbCk7XG4gICAgICAgIHIyID0gTWF0aC5yYW5kb207XG4gICAgICAgIG0gPSBcImFwcGVuZCxzZXQsZ2V0LGdldEFsbCxkZWxldGUsa2V5cyx2YWx1ZXMsZW50cmllcyxmb3JFYWNoLGNvbnN0cnVjdG9yXCIuc3BsaXQoXCIsXCIpO1xuICAgICAgICBmID0gKGEsIGIsIGMpID0+IChhICs9IFwiXCIsIC9eKEJsb2J8RmlsZSkkLy50ZXN0KGIgJiYgYlt0XSkgPyBbKGMgPSBjICE9PSB2b2lkIDAgPyBjICsgXCJcIiA6IGJbdF0gPT0gXCJGaWxlXCIgPyBiLm5hbWUgOiBcImJsb2JcIiwgYSksIGIubmFtZSAhPT0gYyB8fCBiW3RdID09IFwiYmxvYlwiID8gbmV3IGZpbGVfZGVmYXVsdChbYl0sIGMsIGIpIDogYl0gOiBbYSwgYiArIFwiXCJdKTtcbiAgICAgICAgZSA9IChjLCBmMykgPT4gKGYzID8gYyA6IGMucmVwbGFjZSgvXFxyP1xcbnxcXHIvZywgXCJcXHJcXG5cIikpLnJlcGxhY2UoL1xcbi9nLCBcIiUwQVwiKS5yZXBsYWNlKC9cXHIvZywgXCIlMERcIikucmVwbGFjZSgvXCIvZywgXCIlMjJcIik7XG4gICAgICAgIHggPSAobiwgYSwgZTIpID0+IHtcbiAgICAgICAgICBpZiAoYS5sZW5ndGggPCBlMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRmFpbGVkIHRvIGV4ZWN1dGUgJyR7bn0nIG9uICdGb3JtRGF0YSc6ICR7ZTJ9IGFyZ3VtZW50cyByZXF1aXJlZCwgYnV0IG9ubHkgJHthLmxlbmd0aH0gcHJlc2VudC5gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEZvcm1EYXRhID0gY2xhc3MgRm9ybURhdGEyIHtcbiAgICAgICAgICAjZCA9IFtdO1xuICAgICAgICAgIGNvbnN0cnVjdG9yKC4uLmEpIHtcbiAgICAgICAgICAgIGlmIChhLmxlbmd0aClcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRmFpbGVkIHRvIGNvbnN0cnVjdCAnRm9ybURhdGEnOiBwYXJhbWV0ZXIgMSBpcyBub3Qgb2YgdHlwZSAnSFRNTEZvcm1FbGVtZW50Jy5gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZ2V0IFt0XSgpIHtcbiAgICAgICAgICAgIHJldHVybiBcIkZvcm1EYXRhXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIFtpXSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVudHJpZXMoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RhdGljIFtoXShvKSB7XG4gICAgICAgICAgICByZXR1cm4gbyAmJiB0eXBlb2YgbyA9PT0gXCJvYmplY3RcIiAmJiBvW3RdID09PSBcIkZvcm1EYXRhXCIgJiYgIW0uc29tZSgobTIpID0+IHR5cGVvZiBvW20yXSAhPSBcImZ1bmN0aW9uXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhcHBlbmQoLi4uYSkge1xuICAgICAgICAgICAgeChcImFwcGVuZFwiLCBhcmd1bWVudHMsIDIpO1xuICAgICAgICAgICAgdGhpcy4jZC5wdXNoKGYoLi4uYSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWxldGUoYSkge1xuICAgICAgICAgICAgeChcImRlbGV0ZVwiLCBhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgYSArPSBcIlwiO1xuICAgICAgICAgICAgdGhpcy4jZCA9IHRoaXMuI2QuZmlsdGVyKChbYl0pID0+IGIgIT09IGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBnZXQoYSkge1xuICAgICAgICAgICAgeChcImdldFwiLCBhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgYSArPSBcIlwiO1xuICAgICAgICAgICAgZm9yICh2YXIgYiA9IHRoaXMuI2QsIGwgPSBiLmxlbmd0aCwgYyA9IDA7IGMgPCBsOyBjKyspXG4gICAgICAgICAgICAgIGlmIChiW2NdWzBdID09PSBhKVxuICAgICAgICAgICAgICAgIHJldHVybiBiW2NdWzFdO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGdldEFsbChhLCBiKSB7XG4gICAgICAgICAgICB4KFwiZ2V0QWxsXCIsIGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICBiID0gW107XG4gICAgICAgICAgICBhICs9IFwiXCI7XG4gICAgICAgICAgICB0aGlzLiNkLmZvckVhY2goKGMpID0+IGNbMF0gPT09IGEgJiYgYi5wdXNoKGNbMV0pKTtcbiAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBoYXMoYSkge1xuICAgICAgICAgICAgeChcImhhc1wiLCBhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgYSArPSBcIlwiO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2Quc29tZSgoYikgPT4gYlswXSA9PT0gYSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvckVhY2goYSwgYikge1xuICAgICAgICAgICAgeChcImZvckVhY2hcIiwgYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgIGZvciAodmFyIFtjLCBkXSBvZiB0aGlzKVxuICAgICAgICAgICAgICBhLmNhbGwoYiwgZCwgYywgdGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNldCguLi5hKSB7XG4gICAgICAgICAgICB4KFwic2V0XCIsIGFyZ3VtZW50cywgMik7XG4gICAgICAgICAgICB2YXIgYiA9IFtdLCBjID0gdHJ1ZTtcbiAgICAgICAgICAgIGEgPSBmKC4uLmEpO1xuICAgICAgICAgICAgdGhpcy4jZC5mb3JFYWNoKChkKSA9PiB7XG4gICAgICAgICAgICAgIGRbMF0gPT09IGFbMF0gPyBjICYmIChjID0gIWIucHVzaChhKSkgOiBiLnB1c2goZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGMgJiYgYi5wdXNoKGEpO1xuICAgICAgICAgICAgdGhpcy4jZCA9IGI7XG4gICAgICAgICAgfVxuICAgICAgICAgICplbnRyaWVzKCkge1xuICAgICAgICAgICAgeWllbGQqIHRoaXMuI2Q7XG4gICAgICAgICAgfVxuICAgICAgICAgICprZXlzKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgW2FdIG9mIHRoaXMpXG4gICAgICAgICAgICAgIHlpZWxkIGE7XG4gICAgICAgICAgfVxuICAgICAgICAgICp2YWx1ZXMoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBbLCBhXSBvZiB0aGlzKVxuICAgICAgICAgICAgICB5aWVsZCBhO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgcmVxdWlyZV9ub2RlX2RvbWV4Y2VwdGlvbiA9IF9fY29tbW9uSlMyKHtcbiAgICAgIFwibm9kZV9tb2R1bGVzL25vZGUtZG9tZXhjZXB0aW9uL2luZGV4LmpzXCIoZXhwb3J0czMsIG1vZHVsZTIyKSB7XG4gICAgICAgIGlmICghZ2xvYmFsVGhpcy5ET01FeGNlcHRpb24pIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBNZXNzYWdlQ2hhbm5lbCB9ID0gcmVxdWlyZShcIndvcmtlcl90aHJlYWRzXCIpLCBwb3J0ID0gbmV3IE1lc3NhZ2VDaGFubmVsKCkucG9ydDEsIGFiID0gbmV3IEFycmF5QnVmZmVyKCk7XG4gICAgICAgICAgICBwb3J0LnBvc3RNZXNzYWdlKGFiLCBbYWIsIGFiXSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBlcnIuY29uc3RydWN0b3IubmFtZSA9PT0gXCJET01FeGNlcHRpb25cIiAmJiAoZ2xvYmFsVGhpcy5ET01FeGNlcHRpb24gPSBlcnIuY29uc3RydWN0b3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtb2R1bGUyMi5leHBvcnRzID0gZ2xvYmFsVGhpcy5ET01FeGNlcHRpb247XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIGltcG9ydF9ub2RlX2ZzO1xuICAgIHZhciBpbXBvcnRfbm9kZV9wYXRoO1xuICAgIHZhciBpbXBvcnRfbm9kZV9kb21leGNlcHRpb247XG4gICAgdmFyIHN0YXQ7XG4gICAgdmFyIGJsb2JGcm9tU3luYztcbiAgICB2YXIgYmxvYkZyb207XG4gICAgdmFyIGZpbGVGcm9tO1xuICAgIHZhciBmaWxlRnJvbVN5bmM7XG4gICAgdmFyIGZyb21CbG9iO1xuICAgIHZhciBmcm9tRmlsZTtcbiAgICB2YXIgQmxvYkRhdGFJdGVtO1xuICAgIHZhciBpbml0X2Zyb20gPSBfX2VzbSh7XG4gICAgICBcIm5vZGVfbW9kdWxlcy9mZXRjaC1ibG9iL2Zyb20uanNcIigpIHtcbiAgICAgICAgaW1wb3J0X25vZGVfZnMgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCJmc1wiKSk7XG4gICAgICAgIGltcG9ydF9ub2RlX3BhdGggPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCJwYXRoXCIpKTtcbiAgICAgICAgaW1wb3J0X25vZGVfZG9tZXhjZXB0aW9uID0gX190b01vZHVsZShyZXF1aXJlX25vZGVfZG9tZXhjZXB0aW9uKCkpO1xuICAgICAgICBpbml0X2ZpbGUoKTtcbiAgICAgICAgaW5pdF9mZXRjaF9ibG9iKCk7XG4gICAgICAgICh7IHN0YXQgfSA9IGltcG9ydF9ub2RlX2ZzLnByb21pc2VzKTtcbiAgICAgICAgYmxvYkZyb21TeW5jID0gKHBhdGgsIHR5cGUpID0+IGZyb21CbG9iKCgwLCBpbXBvcnRfbm9kZV9mcy5zdGF0U3luYykocGF0aCksIHBhdGgsIHR5cGUpO1xuICAgICAgICBibG9iRnJvbSA9IChwYXRoLCB0eXBlKSA9PiBzdGF0KHBhdGgpLnRoZW4oKHN0YXQyKSA9PiBmcm9tQmxvYihzdGF0MiwgcGF0aCwgdHlwZSkpO1xuICAgICAgICBmaWxlRnJvbSA9IChwYXRoLCB0eXBlKSA9PiBzdGF0KHBhdGgpLnRoZW4oKHN0YXQyKSA9PiBmcm9tRmlsZShzdGF0MiwgcGF0aCwgdHlwZSkpO1xuICAgICAgICBmaWxlRnJvbVN5bmMgPSAocGF0aCwgdHlwZSkgPT4gZnJvbUZpbGUoKDAsIGltcG9ydF9ub2RlX2ZzLnN0YXRTeW5jKShwYXRoKSwgcGF0aCwgdHlwZSk7XG4gICAgICAgIGZyb21CbG9iID0gKHN0YXQyLCBwYXRoLCB0eXBlID0gXCJcIikgPT4gbmV3IGZldGNoX2Jsb2JfZGVmYXVsdChbbmV3IEJsb2JEYXRhSXRlbSh7XG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICBzaXplOiBzdGF0Mi5zaXplLFxuICAgICAgICAgIGxhc3RNb2RpZmllZDogc3RhdDIubXRpbWVNcyxcbiAgICAgICAgICBzdGFydDogMFxuICAgICAgICB9KV0sIHsgdHlwZSB9KTtcbiAgICAgICAgZnJvbUZpbGUgPSAoc3RhdDIsIHBhdGgsIHR5cGUgPSBcIlwiKSA9PiBuZXcgZmlsZV9kZWZhdWx0KFtuZXcgQmxvYkRhdGFJdGVtKHtcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIHNpemU6IHN0YXQyLnNpemUsXG4gICAgICAgICAgbGFzdE1vZGlmaWVkOiBzdGF0Mi5tdGltZU1zLFxuICAgICAgICAgIHN0YXJ0OiAwXG4gICAgICAgIH0pXSwgKDAsIGltcG9ydF9ub2RlX3BhdGguYmFzZW5hbWUpKHBhdGgpLCB7IHR5cGUsIGxhc3RNb2RpZmllZDogc3RhdDIubXRpbWVNcyB9KTtcbiAgICAgICAgQmxvYkRhdGFJdGVtID0gY2xhc3Mge1xuICAgICAgICAgICNwYXRoO1xuICAgICAgICAgICNzdGFydDtcbiAgICAgICAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLiNwYXRoID0gb3B0aW9ucy5wYXRoO1xuICAgICAgICAgICAgdGhpcy4jc3RhcnQgPSBvcHRpb25zLnN0YXJ0O1xuICAgICAgICAgICAgdGhpcy5zaXplID0gb3B0aW9ucy5zaXplO1xuICAgICAgICAgICAgdGhpcy5sYXN0TW9kaWZpZWQgPSBvcHRpb25zLmxhc3RNb2RpZmllZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2xpY2Uoc3RhcnQsIGVuZCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCbG9iRGF0YUl0ZW0oe1xuICAgICAgICAgICAgICBwYXRoOiB0aGlzLiNwYXRoLFxuICAgICAgICAgICAgICBsYXN0TW9kaWZpZWQ6IHRoaXMubGFzdE1vZGlmaWVkLFxuICAgICAgICAgICAgICBzaXplOiBlbmQgLSBzdGFydCxcbiAgICAgICAgICAgICAgc3RhcnQ6IHRoaXMuI3N0YXJ0ICsgc3RhcnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhc3luYyAqc3RyZWFtKCkge1xuICAgICAgICAgICAgY29uc3QgeyBtdGltZU1zIH0gPSBhd2FpdCBzdGF0KHRoaXMuI3BhdGgpO1xuICAgICAgICAgICAgaWYgKG10aW1lTXMgPiB0aGlzLmxhc3RNb2RpZmllZCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgaW1wb3J0X25vZGVfZG9tZXhjZXB0aW9uLmRlZmF1bHQoXCJUaGUgcmVxdWVzdGVkIGZpbGUgY291bGQgbm90IGJlIHJlYWQsIHR5cGljYWxseSBkdWUgdG8gcGVybWlzc2lvbiBwcm9ibGVtcyB0aGF0IGhhdmUgb2NjdXJyZWQgYWZ0ZXIgYSByZWZlcmVuY2UgdG8gYSBmaWxlIHdhcyBhY3F1aXJlZC5cIiwgXCJOb3RSZWFkYWJsZUVycm9yXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeWllbGQqICgwLCBpbXBvcnRfbm9kZV9mcy5jcmVhdGVSZWFkU3RyZWFtKSh0aGlzLiNwYXRoLCB7XG4gICAgICAgICAgICAgIHN0YXJ0OiB0aGlzLiNzdGFydCxcbiAgICAgICAgICAgICAgZW5kOiB0aGlzLiNzdGFydCArIHRoaXMuc2l6ZSAtIDFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJCbG9iXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBtdWx0aXBhcnRfcGFyc2VyX2V4cG9ydHMgPSB7fTtcbiAgICBfX2V4cG9ydChtdWx0aXBhcnRfcGFyc2VyX2V4cG9ydHMsIHtcbiAgICAgIHRvRm9ybURhdGE6ICgpID0+IHRvRm9ybURhdGFcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBfZmlsZU5hbWUoaGVhZGVyVmFsdWUpIHtcbiAgICAgIGNvbnN0IG0yID0gaGVhZGVyVmFsdWUubWF0Y2goL1xcYmZpbGVuYW1lPShcIiguKj8pXCJ8KFteKCk8PkAsOzpcXFxcXCIvW1xcXT89e31cXHNcXHRdKykpKCR8O1xccykvaSk7XG4gICAgICBpZiAoIW0yKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1hdGNoID0gbTJbMl0gfHwgbTJbM10gfHwgXCJcIjtcbiAgICAgIGxldCBmaWxlbmFtZSA9IG1hdGNoLnNsaWNlKG1hdGNoLmxhc3RJbmRleE9mKFwiXFxcXFwiKSArIDEpO1xuICAgICAgZmlsZW5hbWUgPSBmaWxlbmFtZS5yZXBsYWNlKC8lMjIvZywgJ1wiJyk7XG4gICAgICBmaWxlbmFtZSA9IGZpbGVuYW1lLnJlcGxhY2UoLyYjKFxcZHs0fSk7L2csIChtMywgY29kZSkgPT4ge1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZpbGVuYW1lO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiB0b0Zvcm1EYXRhKEJvZHkyLCBjdCkge1xuICAgICAgaWYgKCEvbXVsdGlwYXJ0L2kudGVzdChjdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBmZXRjaFwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG0yID0gY3QubWF0Y2goL2JvdW5kYXJ5PSg/OlwiKFteXCJdKylcInwoW147XSspKS9pKTtcbiAgICAgIGlmICghbTIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm5vIG9yIGJhZCBjb250ZW50LXR5cGUgaGVhZGVyLCBubyBtdWx0aXBhcnQgYm91bmRhcnlcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBwYXJzZXIgPSBuZXcgTXVsdGlwYXJ0UGFyc2VyKG0yWzFdIHx8IG0yWzJdKTtcbiAgICAgIGxldCBoZWFkZXJGaWVsZDtcbiAgICAgIGxldCBoZWFkZXJWYWx1ZTtcbiAgICAgIGxldCBlbnRyeVZhbHVlO1xuICAgICAgbGV0IGVudHJ5TmFtZTtcbiAgICAgIGxldCBjb250ZW50VHlwZTtcbiAgICAgIGxldCBmaWxlbmFtZTtcbiAgICAgIGNvbnN0IGVudHJ5Q2h1bmtzID0gW107XG4gICAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgY29uc3Qgb25QYXJ0RGF0YSA9ICh1aThhKSA9PiB7XG4gICAgICAgIGVudHJ5VmFsdWUgKz0gZGVjb2Rlci5kZWNvZGUodWk4YSwgeyBzdHJlYW06IHRydWUgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgYXBwZW5kVG9GaWxlID0gKHVpOGEpID0+IHtcbiAgICAgICAgZW50cnlDaHVua3MucHVzaCh1aThhKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBhcHBlbmRGaWxlVG9Gb3JtRGF0YSA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgZmlsZSA9IG5ldyBmaWxlX2RlZmF1bHQoZW50cnlDaHVua3MsIGZpbGVuYW1lLCB7IHR5cGU6IGNvbnRlbnRUeXBlIH0pO1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQoZW50cnlOYW1lLCBmaWxlKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBhcHBlbmRFbnRyeVRvRm9ybURhdGEgPSAoKSA9PiB7XG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZChlbnRyeU5hbWUsIGVudHJ5VmFsdWUpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoXCJ1dGYtOFwiKTtcbiAgICAgIGRlY29kZXIuZGVjb2RlKCk7XG4gICAgICBwYXJzZXIub25QYXJ0QmVnaW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcGFyc2VyLm9uUGFydERhdGEgPSBvblBhcnREYXRhO1xuICAgICAgICBwYXJzZXIub25QYXJ0RW5kID0gYXBwZW5kRW50cnlUb0Zvcm1EYXRhO1xuICAgICAgICBoZWFkZXJGaWVsZCA9IFwiXCI7XG4gICAgICAgIGhlYWRlclZhbHVlID0gXCJcIjtcbiAgICAgICAgZW50cnlWYWx1ZSA9IFwiXCI7XG4gICAgICAgIGVudHJ5TmFtZSA9IFwiXCI7XG4gICAgICAgIGNvbnRlbnRUeXBlID0gXCJcIjtcbiAgICAgICAgZmlsZW5hbWUgPSBudWxsO1xuICAgICAgICBlbnRyeUNodW5rcy5sZW5ndGggPSAwO1xuICAgICAgfTtcbiAgICAgIHBhcnNlci5vbkhlYWRlckZpZWxkID0gZnVuY3Rpb24odWk4YSkge1xuICAgICAgICBoZWFkZXJGaWVsZCArPSBkZWNvZGVyLmRlY29kZSh1aThhLCB7IHN0cmVhbTogdHJ1ZSB9KTtcbiAgICAgIH07XG4gICAgICBwYXJzZXIub25IZWFkZXJWYWx1ZSA9IGZ1bmN0aW9uKHVpOGEpIHtcbiAgICAgICAgaGVhZGVyVmFsdWUgKz0gZGVjb2Rlci5kZWNvZGUodWk4YSwgeyBzdHJlYW06IHRydWUgfSk7XG4gICAgICB9O1xuICAgICAgcGFyc2VyLm9uSGVhZGVyRW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGhlYWRlclZhbHVlICs9IGRlY29kZXIuZGVjb2RlKCk7XG4gICAgICAgIGhlYWRlckZpZWxkID0gaGVhZGVyRmllbGQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKGhlYWRlckZpZWxkID09PSBcImNvbnRlbnQtZGlzcG9zaXRpb25cIikge1xuICAgICAgICAgIGNvbnN0IG0zID0gaGVhZGVyVmFsdWUubWF0Y2goL1xcYm5hbWU9KFwiKFteXCJdKilcInwoW14oKTw+QCw7OlxcXFxcIi9bXFxdPz17fVxcc1xcdF0rKSkvaSk7XG4gICAgICAgICAgaWYgKG0zKSB7XG4gICAgICAgICAgICBlbnRyeU5hbWUgPSBtM1syXSB8fCBtM1szXSB8fCBcIlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmaWxlbmFtZSA9IF9maWxlTmFtZShoZWFkZXJWYWx1ZSk7XG4gICAgICAgICAgaWYgKGZpbGVuYW1lKSB7XG4gICAgICAgICAgICBwYXJzZXIub25QYXJ0RGF0YSA9IGFwcGVuZFRvRmlsZTtcbiAgICAgICAgICAgIHBhcnNlci5vblBhcnRFbmQgPSBhcHBlbmRGaWxlVG9Gb3JtRGF0YTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaGVhZGVyRmllbGQgPT09IFwiY29udGVudC10eXBlXCIpIHtcbiAgICAgICAgICBjb250ZW50VHlwZSA9IGhlYWRlclZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGhlYWRlclZhbHVlID0gXCJcIjtcbiAgICAgICAgaGVhZGVyRmllbGQgPSBcIlwiO1xuICAgICAgfTtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgQm9keTIpIHtcbiAgICAgICAgcGFyc2VyLndyaXRlKGNodW5rKTtcbiAgICAgIH1cbiAgICAgIHBhcnNlci5lbmQoKTtcbiAgICAgIHJldHVybiBmb3JtRGF0YTtcbiAgICB9XG4gICAgdmFyIHM7XG4gICAgdmFyIFM7XG4gICAgdmFyIGYyO1xuICAgIHZhciBGO1xuICAgIHZhciBMRjtcbiAgICB2YXIgQ1I7XG4gICAgdmFyIFNQQUNFO1xuICAgIHZhciBIWVBIRU47XG4gICAgdmFyIENPTE9OO1xuICAgIHZhciBBO1xuICAgIHZhciBaO1xuICAgIHZhciBsb3dlcjtcbiAgICB2YXIgbm9vcDtcbiAgICB2YXIgTXVsdGlwYXJ0UGFyc2VyO1xuICAgIHZhciBpbml0X211bHRpcGFydF9wYXJzZXIgPSBfX2VzbSh7XG4gICAgICBcIm5vZGVfbW9kdWxlcy9ub2RlLWZldGNoL3NyYy91dGlscy9tdWx0aXBhcnQtcGFyc2VyLmpzXCIoKSB7XG4gICAgICAgIGluaXRfZnJvbSgpO1xuICAgICAgICBpbml0X2VzbV9taW4oKTtcbiAgICAgICAgcyA9IDA7XG4gICAgICAgIFMgPSB7XG4gICAgICAgICAgU1RBUlRfQk9VTkRBUlk6IHMrKyxcbiAgICAgICAgICBIRUFERVJfRklFTERfU1RBUlQ6IHMrKyxcbiAgICAgICAgICBIRUFERVJfRklFTEQ6IHMrKyxcbiAgICAgICAgICBIRUFERVJfVkFMVUVfU1RBUlQ6IHMrKyxcbiAgICAgICAgICBIRUFERVJfVkFMVUU6IHMrKyxcbiAgICAgICAgICBIRUFERVJfVkFMVUVfQUxNT1NUX0RPTkU6IHMrKyxcbiAgICAgICAgICBIRUFERVJTX0FMTU9TVF9ET05FOiBzKyssXG4gICAgICAgICAgUEFSVF9EQVRBX1NUQVJUOiBzKyssXG4gICAgICAgICAgUEFSVF9EQVRBOiBzKyssXG4gICAgICAgICAgRU5EOiBzKytcbiAgICAgICAgfTtcbiAgICAgICAgZjIgPSAxO1xuICAgICAgICBGID0ge1xuICAgICAgICAgIFBBUlRfQk9VTkRBUlk6IGYyLFxuICAgICAgICAgIExBU1RfQk9VTkRBUlk6IGYyICo9IDJcbiAgICAgICAgfTtcbiAgICAgICAgTEYgPSAxMDtcbiAgICAgICAgQ1IgPSAxMztcbiAgICAgICAgU1BBQ0UgPSAzMjtcbiAgICAgICAgSFlQSEVOID0gNDU7XG4gICAgICAgIENPTE9OID0gNTg7XG4gICAgICAgIEEgPSA5NztcbiAgICAgICAgWiA9IDEyMjtcbiAgICAgICAgbG93ZXIgPSAoYykgPT4gYyB8IDMyO1xuICAgICAgICBub29wID0gKCkgPT4ge1xuICAgICAgICB9O1xuICAgICAgICBNdWx0aXBhcnRQYXJzZXIgPSBjbGFzcyB7XG4gICAgICAgICAgY29uc3RydWN0b3IoYm91bmRhcnkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICAgICAgdGhpcy5mbGFncyA9IDA7XG4gICAgICAgICAgICB0aGlzLm9uSGVhZGVyRW5kID0gbm9vcDtcbiAgICAgICAgICAgIHRoaXMub25IZWFkZXJGaWVsZCA9IG5vb3A7XG4gICAgICAgICAgICB0aGlzLm9uSGVhZGVyc0VuZCA9IG5vb3A7XG4gICAgICAgICAgICB0aGlzLm9uSGVhZGVyVmFsdWUgPSBub29wO1xuICAgICAgICAgICAgdGhpcy5vblBhcnRCZWdpbiA9IG5vb3A7XG4gICAgICAgICAgICB0aGlzLm9uUGFydERhdGEgPSBub29wO1xuICAgICAgICAgICAgdGhpcy5vblBhcnRFbmQgPSBub29wO1xuICAgICAgICAgICAgdGhpcy5ib3VuZGFyeUNoYXJzID0ge307XG4gICAgICAgICAgICBib3VuZGFyeSA9IFwiXFxyXFxuLS1cIiArIGJvdW5kYXJ5O1xuICAgICAgICAgICAgY29uc3QgdWk4YSA9IG5ldyBVaW50OEFycmF5KGJvdW5kYXJ5Lmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgYm91bmRhcnkubGVuZ3RoOyBpMisrKSB7XG4gICAgICAgICAgICAgIHVpOGFbaTJdID0gYm91bmRhcnkuY2hhckNvZGVBdChpMik7XG4gICAgICAgICAgICAgIHRoaXMuYm91bmRhcnlDaGFyc1t1aThhW2kyXV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ib3VuZGFyeSA9IHVpOGE7XG4gICAgICAgICAgICB0aGlzLmxvb2tiZWhpbmQgPSBuZXcgVWludDhBcnJheSh0aGlzLmJvdW5kYXJ5Lmxlbmd0aCArIDgpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFMuU1RBUlRfQk9VTkRBUlk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdyaXRlKGRhdGEpIHtcbiAgICAgICAgICAgIGxldCBpMiA9IDA7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGhfID0gZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgcHJldmlvdXNJbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICAgICAgICBsZXQgeyBsb29rYmVoaW5kLCBib3VuZGFyeSwgYm91bmRhcnlDaGFycywgaW5kZXgsIHN0YXRlLCBmbGFncyB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGJvdW5kYXJ5TGVuZ3RoID0gdGhpcy5ib3VuZGFyeS5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBib3VuZGFyeUVuZCA9IGJvdW5kYXJ5TGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlckxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IGM7XG4gICAgICAgICAgICBsZXQgY2w7XG4gICAgICAgICAgICBjb25zdCBtYXJrID0gKG5hbWUpID0+IHtcbiAgICAgICAgICAgICAgdGhpc1tuYW1lICsgXCJNYXJrXCJdID0gaTI7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgY2xlYXIgPSAobmFtZSkgPT4ge1xuICAgICAgICAgICAgICBkZWxldGUgdGhpc1tuYW1lICsgXCJNYXJrXCJdO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gKGNhbGxiYWNrU3ltYm9sLCBzdGFydCwgZW5kLCB1aThhKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChzdGFydCA9PT0gdm9pZCAwIHx8IHN0YXJ0ICE9PSBlbmQpIHtcbiAgICAgICAgICAgICAgICB0aGlzW2NhbGxiYWNrU3ltYm9sXSh1aThhICYmIHVpOGEuc3ViYXJyYXkoc3RhcnQsIGVuZCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgZGF0YUNhbGxiYWNrID0gKG5hbWUsIGNsZWFyMikgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBtYXJrU3ltYm9sID0gbmFtZSArIFwiTWFya1wiO1xuICAgICAgICAgICAgICBpZiAoIShtYXJrU3ltYm9sIGluIHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjbGVhcjIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhuYW1lLCB0aGlzW21hcmtTeW1ib2xdLCBpMiwgZGF0YSk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXNbbWFya1N5bWJvbF07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobmFtZSwgdGhpc1ttYXJrU3ltYm9sXSwgZGF0YS5sZW5ndGgsIGRhdGEpO1xuICAgICAgICAgICAgICAgIHRoaXNbbWFya1N5bWJvbF0gPSAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChpMiA9IDA7IGkyIDwgbGVuZ3RoXzsgaTIrKykge1xuICAgICAgICAgICAgICBjID0gZGF0YVtpMl07XG4gICAgICAgICAgICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFMuU1RBUlRfQk9VTkRBUlk6XG4gICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IGJvdW5kYXJ5Lmxlbmd0aCAtIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IEhZUEhFTikge1xuICAgICAgICAgICAgICAgICAgICAgIGZsYWdzIHw9IEYuTEFTVF9CT1VOREFSWTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjICE9PSBDUikge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5kZXggLSAxID09PSBib3VuZGFyeS5sZW5ndGggLSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmbGFncyAmIEYuTEFTVF9CT1VOREFSWSAmJiBjID09PSBIWVBIRU4pIHtcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IFMuRU5EO1xuICAgICAgICAgICAgICAgICAgICAgIGZsYWdzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghKGZsYWdzICYgRi5MQVNUX0JPVU5EQVJZKSAmJiBjID09PSBMRikge1xuICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhcIm9uUGFydEJlZ2luXCIpO1xuICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gUy5IRUFERVJfRklFTERfU1RBUlQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKGMgIT09IGJvdW5kYXJ5W2luZGV4ICsgMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSAtMjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChjID09PSBib3VuZGFyeVtpbmRleCArIDJdKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFMuSEVBREVSX0ZJRUxEX1NUQVJUOlxuICAgICAgICAgICAgICAgICAgc3RhdGUgPSBTLkhFQURFUl9GSUVMRDtcbiAgICAgICAgICAgICAgICAgIG1hcmsoXCJvbkhlYWRlckZpZWxkXCIpO1xuICAgICAgICAgICAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIGNhc2UgUy5IRUFERVJfRklFTEQ6XG4gICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gQ1IpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXIoXCJvbkhlYWRlckZpZWxkXCIpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IFMuSEVBREVSU19BTE1PU1RfRE9ORTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IEhZUEhFTikge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChjID09PSBDT0xPTikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGF0YUNhbGxiYWNrKFwib25IZWFkZXJGaWVsZFwiLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBTLkhFQURFUl9WQUxVRV9TVEFSVDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjbCA9IGxvd2VyKGMpO1xuICAgICAgICAgICAgICAgICAgaWYgKGNsIDwgQSB8fCBjbCA+IFopIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTLkhFQURFUl9WQUxVRV9TVEFSVDpcbiAgICAgICAgICAgICAgICAgIGlmIChjID09PSBTUEFDRSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIG1hcmsoXCJvbkhlYWRlclZhbHVlXCIpO1xuICAgICAgICAgICAgICAgICAgc3RhdGUgPSBTLkhFQURFUl9WQUxVRTtcbiAgICAgICAgICAgICAgICBjYXNlIFMuSEVBREVSX1ZBTFVFOlxuICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IENSKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFDYWxsYmFjayhcIm9uSGVhZGVyVmFsdWVcIiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKFwib25IZWFkZXJFbmRcIik7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gUy5IRUFERVJfVkFMVUVfQUxNT1NUX0RPTkU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFMuSEVBREVSX1ZBTFVFX0FMTU9TVF9ET05FOlxuICAgICAgICAgICAgICAgICAgaWYgKGMgIT09IExGKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHN0YXRlID0gUy5IRUFERVJfRklFTERfU1RBUlQ7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFMuSEVBREVSU19BTE1PU1RfRE9ORTpcbiAgICAgICAgICAgICAgICAgIGlmIChjICE9PSBMRikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjYWxsYmFjayhcIm9uSGVhZGVyc0VuZFwiKTtcbiAgICAgICAgICAgICAgICAgIHN0YXRlID0gUy5QQVJUX0RBVEFfU1RBUlQ7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFMuUEFSVF9EQVRBX1NUQVJUOlxuICAgICAgICAgICAgICAgICAgc3RhdGUgPSBTLlBBUlRfREFUQTtcbiAgICAgICAgICAgICAgICAgIG1hcmsoXCJvblBhcnREYXRhXCIpO1xuICAgICAgICAgICAgICAgIGNhc2UgUy5QQVJUX0RBVEE6XG4gICAgICAgICAgICAgICAgICBwcmV2aW91c0luZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaTIgKz0gYm91bmRhcnlFbmQ7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpMiA8IGJ1ZmZlckxlbmd0aCAmJiAhKGRhdGFbaTJdIGluIGJvdW5kYXJ5Q2hhcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaTIgKz0gYm91bmRhcnlMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaTIgLT0gYm91bmRhcnlFbmQ7XG4gICAgICAgICAgICAgICAgICAgIGMgPSBkYXRhW2kyXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IGJvdW5kYXJ5Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYm91bmRhcnlbaW5kZXhdID09PSBjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhQ2FsbGJhY2soXCJvblBhcnREYXRhXCIsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbmRleCA9PT0gYm91bmRhcnkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjID09PSBDUikge1xuICAgICAgICAgICAgICAgICAgICAgIGZsYWdzIHw9IEYuUEFSVF9CT1VOREFSWTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjID09PSBIWVBIRU4pIHtcbiAgICAgICAgICAgICAgICAgICAgICBmbGFncyB8PSBGLkxBU1RfQk9VTkRBUlk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGluZGV4IC0gMSA9PT0gYm91bmRhcnkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmbGFncyAmIEYuUEFSVF9CT1VOREFSWSkge1xuICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gTEYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsYWdzICY9IH5GLlBBUlRfQk9VTkRBUlk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhcIm9uUGFydEVuZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKFwib25QYXJ0QmVnaW5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IFMuSEVBREVSX0ZJRUxEX1NUQVJUO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZsYWdzICYgRi5MQVNUX0JPVU5EQVJZKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IEhZUEhFTikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soXCJvblBhcnRFbmRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IFMuRU5EO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmxhZ3MgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBsb29rYmVoaW5kW2luZGV4IC0gMV0gPSBjO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcmV2aW91c0luZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBfbG9va2JlaGluZCA9IG5ldyBVaW50OEFycmF5KGxvb2tiZWhpbmQuYnVmZmVyLCBsb29rYmVoaW5kLmJ5dGVPZmZzZXQsIGxvb2tiZWhpbmQuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKFwib25QYXJ0RGF0YVwiLCAwLCBwcmV2aW91c0luZGV4LCBfbG9va2JlaGluZCk7XG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzSW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICBtYXJrKFwib25QYXJ0RGF0YVwiKTtcbiAgICAgICAgICAgICAgICAgICAgaTItLTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgUy5FTkQ6XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIHN0YXRlIGVudGVyZWQ6ICR7c3RhdGV9YCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGFDYWxsYmFjayhcIm9uSGVhZGVyRmllbGRcIik7XG4gICAgICAgICAgICBkYXRhQ2FsbGJhY2soXCJvbkhlYWRlclZhbHVlXCIpO1xuICAgICAgICAgICAgZGF0YUNhbGxiYWNrKFwib25QYXJ0RGF0YVwiKTtcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICAgICAgICB9XG4gICAgICAgICAgZW5kKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFMuSEVBREVSX0ZJRUxEX1NUQVJUICYmIHRoaXMuaW5kZXggPT09IDAgfHwgdGhpcy5zdGF0ZSA9PT0gUy5QQVJUX0RBVEEgJiYgdGhpcy5pbmRleCA9PT0gdGhpcy5ib3VuZGFyeS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgdGhpcy5vblBhcnRFbmQoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZSAhPT0gUy5FTkQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVsdGlwYXJ0UGFyc2VyLmVuZCgpOiBzdHJlYW0gZW5kZWQgdW5leHBlY3RlZGx5XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBfX2V4cG9ydChleHBvcnRzMiwge1xuICAgICAgQWJvcnRFcnJvcjogKCkgPT4gQWJvcnRFcnJvcixcbiAgICAgIEJsb2I6ICgpID0+IEJsb2IyLFxuICAgICAgRmV0Y2hFcnJvcjogKCkgPT4gRmV0Y2hFcnJvcixcbiAgICAgIEZpbGU6ICgpID0+IGZpbGVfZGVmYXVsdCxcbiAgICAgIEZvcm1EYXRhOiAoKSA9PiBGb3JtRGF0YSxcbiAgICAgIEhlYWRlcnM6ICgpID0+IEhlYWRlcnMsXG4gICAgICBSZXF1ZXN0OiAoKSA9PiBSZXF1ZXN0LFxuICAgICAgUmVzcG9uc2U6ICgpID0+IFJlc3BvbnNlLFxuICAgICAgYmxvYkZyb206ICgpID0+IGJsb2JGcm9tLFxuICAgICAgYmxvYkZyb21TeW5jOiAoKSA9PiBibG9iRnJvbVN5bmMsXG4gICAgICBkZWZhdWx0OiAoKSA9PiBmZXRjaCxcbiAgICAgIGZpbGVGcm9tOiAoKSA9PiBmaWxlRnJvbSxcbiAgICAgIGZpbGVGcm9tU3luYzogKCkgPT4gZmlsZUZyb21TeW5jLFxuICAgICAgaXNSZWRpcmVjdDogKCkgPT4gaXNSZWRpcmVjdFxuICAgIH0pO1xuICAgIHZhciBpbXBvcnRfbm9kZV9odHRwMiA9IF9fdG9Nb2R1bGUocmVxdWlyZShcImh0dHBcIikpO1xuICAgIHZhciBpbXBvcnRfbm9kZV9odHRwcyA9IF9fdG9Nb2R1bGUocmVxdWlyZShcImh0dHBzXCIpKTtcbiAgICB2YXIgaW1wb3J0X25vZGVfemxpYiA9IF9fdG9Nb2R1bGUocmVxdWlyZShcInpsaWJcIikpO1xuICAgIHZhciBpbXBvcnRfbm9kZV9zdHJlYW0yID0gX190b01vZHVsZShyZXF1aXJlKFwic3RyZWFtXCIpKTtcbiAgICB2YXIgaW1wb3J0X25vZGVfYnVmZmVyMiA9IF9fdG9Nb2R1bGUocmVxdWlyZShcImJ1ZmZlclwiKSk7XG4gICAgZnVuY3Rpb24gZGF0YVVyaVRvQnVmZmVyKHVyaSkge1xuICAgICAgaWYgKCEvXmRhdGE6L2kudGVzdCh1cmkpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2B1cmlgIGRvZXMgbm90IGFwcGVhciB0byBiZSBhIERhdGEgVVJJIChtdXN0IGJlZ2luIHdpdGggXCJkYXRhOlwiKScpO1xuICAgICAgfVxuICAgICAgdXJpID0gdXJpLnJlcGxhY2UoL1xccj9cXG4vZywgXCJcIik7XG4gICAgICBjb25zdCBmaXJzdENvbW1hID0gdXJpLmluZGV4T2YoXCIsXCIpO1xuICAgICAgaWYgKGZpcnN0Q29tbWEgPT09IC0xIHx8IGZpcnN0Q29tbWEgPD0gNCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwibWFsZm9ybWVkIGRhdGE6IFVSSVwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1ldGEgPSB1cmkuc3Vic3RyaW5nKDUsIGZpcnN0Q29tbWEpLnNwbGl0KFwiO1wiKTtcbiAgICAgIGxldCBjaGFyc2V0ID0gXCJcIjtcbiAgICAgIGxldCBiYXNlNjQgPSBmYWxzZTtcbiAgICAgIGNvbnN0IHR5cGUgPSBtZXRhWzBdIHx8IFwidGV4dC9wbGFpblwiO1xuICAgICAgbGV0IHR5cGVGdWxsID0gdHlwZTtcbiAgICAgIGZvciAobGV0IGkyID0gMTsgaTIgPCBtZXRhLmxlbmd0aDsgaTIrKykge1xuICAgICAgICBpZiAobWV0YVtpMl0gPT09IFwiYmFzZTY0XCIpIHtcbiAgICAgICAgICBiYXNlNjQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKG1ldGFbaTJdKSB7XG4gICAgICAgICAgdHlwZUZ1bGwgKz0gYDske21ldGFbaTJdfWA7XG4gICAgICAgICAgaWYgKG1ldGFbaTJdLmluZGV4T2YoXCJjaGFyc2V0PVwiKSA9PT0gMCkge1xuICAgICAgICAgICAgY2hhcnNldCA9IG1ldGFbaTJdLnN1YnN0cmluZyg4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghbWV0YVswXSAmJiAhY2hhcnNldC5sZW5ndGgpIHtcbiAgICAgICAgdHlwZUZ1bGwgKz0gXCI7Y2hhcnNldD1VUy1BU0NJSVwiO1xuICAgICAgICBjaGFyc2V0ID0gXCJVUy1BU0NJSVwiO1xuICAgICAgfVxuICAgICAgY29uc3QgZW5jb2RpbmcgPSBiYXNlNjQgPyBcImJhc2U2NFwiIDogXCJhc2NpaVwiO1xuICAgICAgY29uc3QgZGF0YSA9IHVuZXNjYXBlKHVyaS5zdWJzdHJpbmcoZmlyc3RDb21tYSArIDEpKTtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGRhdGEsIGVuY29kaW5nKTtcbiAgICAgIGJ1ZmZlci50eXBlID0gdHlwZTtcbiAgICAgIGJ1ZmZlci50eXBlRnVsbCA9IHR5cGVGdWxsO1xuICAgICAgYnVmZmVyLmNoYXJzZXQgPSBjaGFyc2V0O1xuICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICB9XG4gICAgdmFyIGRpc3RfZGVmYXVsdCA9IGRhdGFVcmlUb0J1ZmZlcjtcbiAgICB2YXIgaW1wb3J0X25vZGVfc3RyZWFtID0gX190b01vZHVsZShyZXF1aXJlKFwic3RyZWFtXCIpKTtcbiAgICB2YXIgaW1wb3J0X25vZGVfdXRpbCA9IF9fdG9Nb2R1bGUocmVxdWlyZShcInV0aWxcIikpO1xuICAgIHZhciBpbXBvcnRfbm9kZV9idWZmZXIgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCJidWZmZXJcIikpO1xuICAgIGluaXRfZmV0Y2hfYmxvYigpO1xuICAgIGluaXRfZXNtX21pbigpO1xuICAgIHZhciBGZXRjaEJhc2VFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICAgICAgY29uc3RydWN0b3IobWVzc2FnZSwgdHlwZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICB9XG4gICAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICAgIH1cbiAgICAgIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBGZXRjaEVycm9yID0gY2xhc3MgZXh0ZW5kcyBGZXRjaEJhc2VFcnJvciB7XG4gICAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCB0eXBlLCBzeXN0ZW1FcnJvcikge1xuICAgICAgICBzdXBlcihtZXNzYWdlLCB0eXBlKTtcbiAgICAgICAgaWYgKHN5c3RlbUVycm9yKSB7XG4gICAgICAgICAgdGhpcy5jb2RlID0gdGhpcy5lcnJubyA9IHN5c3RlbUVycm9yLmNvZGU7XG4gICAgICAgICAgdGhpcy5lcnJvcmVkU3lzQ2FsbCA9IHN5c3RlbUVycm9yLnN5c2NhbGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBOQU1FID0gU3ltYm9sLnRvU3RyaW5nVGFnO1xuICAgIHZhciBpc1VSTFNlYXJjaFBhcmFtZXRlcnMgPSAob2JqZWN0KSA9PiB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqZWN0LmFwcGVuZCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBvYmplY3QuZGVsZXRlID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIG9iamVjdC5nZXQgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygb2JqZWN0LmdldEFsbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBvYmplY3QuaGFzID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIG9iamVjdC5zZXQgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygb2JqZWN0LnNvcnQgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmplY3RbTkFNRV0gPT09IFwiVVJMU2VhcmNoUGFyYW1zXCI7XG4gICAgfTtcbiAgICB2YXIgaXNCbG9iID0gKG9iamVjdCkgPT4ge1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiB0eXBlb2Ygb2JqZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmplY3QuYXJyYXlCdWZmZXIgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygb2JqZWN0LnR5cGUgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIG9iamVjdC5zdHJlYW0gPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgL14oQmxvYnxGaWxlKSQvLnRlc3Qob2JqZWN0W05BTUVdKTtcbiAgICB9O1xuICAgIHZhciBpc0Fib3J0U2lnbmFsID0gKG9iamVjdCkgPT4ge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09IFwib2JqZWN0XCIgJiYgKG9iamVjdFtOQU1FXSA9PT0gXCJBYm9ydFNpZ25hbFwiIHx8IG9iamVjdFtOQU1FXSA9PT0gXCJFdmVudFRhcmdldFwiKTtcbiAgICB9O1xuICAgIHZhciBpc0RvbWFpbk9yU3ViZG9tYWluID0gKGRlc3RpbmF0aW9uLCBvcmlnaW5hbCkgPT4ge1xuICAgICAgY29uc3Qgb3JpZyA9IG5ldyBVUkwob3JpZ2luYWwpLmhvc3RuYW1lO1xuICAgICAgY29uc3QgZGVzdCA9IG5ldyBVUkwoZGVzdGluYXRpb24pLmhvc3RuYW1lO1xuICAgICAgcmV0dXJuIG9yaWcgPT09IGRlc3QgfHwgb3JpZy5lbmRzV2l0aChgLiR7ZGVzdH1gKTtcbiAgICB9O1xuICAgIHZhciBpc1NhbWVQcm90b2NvbCA9IChkZXN0aW5hdGlvbiwgb3JpZ2luYWwpID0+IHtcbiAgICAgIGNvbnN0IG9yaWcgPSBuZXcgVVJMKG9yaWdpbmFsKS5wcm90b2NvbDtcbiAgICAgIGNvbnN0IGRlc3QgPSBuZXcgVVJMKGRlc3RpbmF0aW9uKS5wcm90b2NvbDtcbiAgICAgIHJldHVybiBvcmlnID09PSBkZXN0O1xuICAgIH07XG4gICAgdmFyIHBpcGVsaW5lID0gKDAsIGltcG9ydF9ub2RlX3V0aWwucHJvbWlzaWZ5KShpbXBvcnRfbm9kZV9zdHJlYW0uZGVmYXVsdC5waXBlbGluZSk7XG4gICAgdmFyIElOVEVSTkFMUyA9IFN5bWJvbChcIkJvZHkgaW50ZXJuYWxzXCIpO1xuICAgIHZhciBCb2R5ID0gY2xhc3Mge1xuICAgICAgY29uc3RydWN0b3IoYm9keSwge1xuICAgICAgICBzaXplID0gMFxuICAgICAgfSA9IHt9KSB7XG4gICAgICAgIGxldCBib3VuZGFyeSA9IG51bGw7XG4gICAgICAgIGlmIChib2R5ID09PSBudWxsKSB7XG4gICAgICAgICAgYm9keSA9IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNVUkxTZWFyY2hQYXJhbWV0ZXJzKGJvZHkpKSB7XG4gICAgICAgICAgYm9keSA9IGltcG9ydF9ub2RlX2J1ZmZlci5CdWZmZXIuZnJvbShib2R5LnRvU3RyaW5nKCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQmxvYihib2R5KSkge1xuICAgICAgICB9IGVsc2UgaWYgKGltcG9ydF9ub2RlX2J1ZmZlci5CdWZmZXIuaXNCdWZmZXIoYm9keSkpIHtcbiAgICAgICAgfSBlbHNlIGlmIChpbXBvcnRfbm9kZV91dGlsLnR5cGVzLmlzQW55QXJyYXlCdWZmZXIoYm9keSkpIHtcbiAgICAgICAgICBib2R5ID0gaW1wb3J0X25vZGVfYnVmZmVyLkJ1ZmZlci5mcm9tKGJvZHkpO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhib2R5KSkge1xuICAgICAgICAgIGJvZHkgPSBpbXBvcnRfbm9kZV9idWZmZXIuQnVmZmVyLmZyb20oYm9keS5idWZmZXIsIGJvZHkuYnl0ZU9mZnNldCwgYm9keS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIGlmIChib2R5IGluc3RhbmNlb2YgaW1wb3J0X25vZGVfc3RyZWFtLmRlZmF1bHQpIHtcbiAgICAgICAgfSBlbHNlIGlmIChib2R5IGluc3RhbmNlb2YgRm9ybURhdGEpIHtcbiAgICAgICAgICBib2R5ID0gZm9ybURhdGFUb0Jsb2IoYm9keSk7XG4gICAgICAgICAgYm91bmRhcnkgPSBib2R5LnR5cGUuc3BsaXQoXCI9XCIpWzFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJvZHkgPSBpbXBvcnRfbm9kZV9idWZmZXIuQnVmZmVyLmZyb20oU3RyaW5nKGJvZHkpKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RyZWFtID0gYm9keTtcbiAgICAgICAgaWYgKGltcG9ydF9ub2RlX2J1ZmZlci5CdWZmZXIuaXNCdWZmZXIoYm9keSkpIHtcbiAgICAgICAgICBzdHJlYW0gPSBpbXBvcnRfbm9kZV9zdHJlYW0uZGVmYXVsdC5SZWFkYWJsZS5mcm9tKGJvZHkpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQmxvYihib2R5KSkge1xuICAgICAgICAgIHN0cmVhbSA9IGltcG9ydF9ub2RlX3N0cmVhbS5kZWZhdWx0LlJlYWRhYmxlLmZyb20oYm9keS5zdHJlYW0oKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1tJTlRFUk5BTFNdID0ge1xuICAgICAgICAgIGJvZHksXG4gICAgICAgICAgc3RyZWFtLFxuICAgICAgICAgIGJvdW5kYXJ5LFxuICAgICAgICAgIGRpc3R1cmJlZDogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICAgICAgaWYgKGJvZHkgaW5zdGFuY2VvZiBpbXBvcnRfbm9kZV9zdHJlYW0uZGVmYXVsdCkge1xuICAgICAgICAgIGJvZHkub24oXCJlcnJvclwiLCAoZXJyb3JfKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IGVycm9yXyBpbnN0YW5jZW9mIEZldGNoQmFzZUVycm9yID8gZXJyb3JfIDogbmV3IEZldGNoRXJyb3IoYEludmFsaWQgcmVzcG9uc2UgYm9keSB3aGlsZSB0cnlpbmcgdG8gZmV0Y2ggJHt0aGlzLnVybH06ICR7ZXJyb3JfLm1lc3NhZ2V9YCwgXCJzeXN0ZW1cIiwgZXJyb3JfKTtcbiAgICAgICAgICAgIHRoaXNbSU5URVJOQUxTXS5lcnJvciA9IGVycm9yO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBnZXQgYm9keSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbSU5URVJOQUxTXS5zdHJlYW07XG4gICAgICB9XG4gICAgICBnZXQgYm9keVVzZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW0lOVEVSTkFMU10uZGlzdHVyYmVkO1xuICAgICAgfVxuICAgICAgYXN5bmMgYXJyYXlCdWZmZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoIH0gPSBhd2FpdCBjb25zdW1lQm9keSh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlci5zbGljZShieXRlT2Zmc2V0LCBieXRlT2Zmc2V0ICsgYnl0ZUxlbmd0aCk7XG4gICAgICB9XG4gICAgICBhc3luYyBmb3JtRGF0YSgpIHtcbiAgICAgICAgY29uc3QgY3QgPSB0aGlzLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpO1xuICAgICAgICBpZiAoY3Quc3RhcnRzV2l0aChcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiKSkge1xuICAgICAgICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoYXdhaXQgdGhpcy50ZXh0KCkpO1xuICAgICAgICAgIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiBwYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQobmFtZSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZm9ybURhdGE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyB0b0Zvcm1EYXRhOiB0b0Zvcm1EYXRhMiB9ID0gYXdhaXQgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiAoaW5pdF9tdWx0aXBhcnRfcGFyc2VyKCksIG11bHRpcGFydF9wYXJzZXJfZXhwb3J0cykpO1xuICAgICAgICByZXR1cm4gdG9Gb3JtRGF0YTIodGhpcy5ib2R5LCBjdCk7XG4gICAgICB9XG4gICAgICBhc3luYyBibG9iKCkge1xuICAgICAgICBjb25zdCBjdCA9IHRoaXMuaGVhZGVycyAmJiB0aGlzLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpIHx8IHRoaXNbSU5URVJOQUxTXS5ib2R5ICYmIHRoaXNbSU5URVJOQUxTXS5ib2R5LnR5cGUgfHwgXCJcIjtcbiAgICAgICAgY29uc3QgYnVmID0gYXdhaXQgdGhpcy5hcnJheUJ1ZmZlcigpO1xuICAgICAgICByZXR1cm4gbmV3IGZldGNoX2Jsb2JfZGVmYXVsdChbYnVmXSwge1xuICAgICAgICAgIHR5cGU6IGN0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgYXN5bmMganNvbigpIHtcbiAgICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHRoaXMudGV4dCgpO1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh0ZXh0KTtcbiAgICAgIH1cbiAgICAgIGFzeW5jIHRleHQoKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IGF3YWl0IGNvbnN1bWVCb2R5KHRoaXMpO1xuICAgICAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGJ1ZmZlcik7XG4gICAgICB9XG4gICAgICBidWZmZXIoKSB7XG4gICAgICAgIHJldHVybiBjb25zdW1lQm9keSh0aGlzKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIEJvZHkucHJvdG90eXBlLmJ1ZmZlciA9ICgwLCBpbXBvcnRfbm9kZV91dGlsLmRlcHJlY2F0ZSkoQm9keS5wcm90b3R5cGUuYnVmZmVyLCBcIlBsZWFzZSB1c2UgJ3Jlc3BvbnNlLmFycmF5QnVmZmVyKCknIGluc3RlYWQgb2YgJ3Jlc3BvbnNlLmJ1ZmZlcigpJ1wiLCBcIm5vZGUtZmV0Y2gjYnVmZmVyXCIpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEJvZHkucHJvdG90eXBlLCB7XG4gICAgICBib2R5OiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgIGJvZHlVc2VkOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgIGFycmF5QnVmZmVyOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgIGJsb2I6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAganNvbjogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICB0ZXh0OiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgIGRhdGE6IHsgZ2V0OiAoMCwgaW1wb3J0X25vZGVfdXRpbC5kZXByZWNhdGUpKCgpID0+IHtcbiAgICAgIH0sIFwiZGF0YSBkb2Vzbid0IGV4aXN0LCB1c2UganNvbigpLCB0ZXh0KCksIGFycmF5QnVmZmVyKCksIG9yIGJvZHkgaW5zdGVhZFwiLCBcImh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlLWZldGNoL25vZGUtZmV0Y2gvaXNzdWVzLzEwMDAgKHJlc3BvbnNlKVwiKSB9XG4gICAgfSk7XG4gICAgYXN5bmMgZnVuY3Rpb24gY29uc3VtZUJvZHkoZGF0YSkge1xuICAgICAgaWYgKGRhdGFbSU5URVJOQUxTXS5kaXN0dXJiZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgYm9keSB1c2VkIGFscmVhZHkgZm9yOiAke2RhdGEudXJsfWApO1xuICAgICAgfVxuICAgICAgZGF0YVtJTlRFUk5BTFNdLmRpc3R1cmJlZCA9IHRydWU7XG4gICAgICBpZiAoZGF0YVtJTlRFUk5BTFNdLmVycm9yKSB7XG4gICAgICAgIHRocm93IGRhdGFbSU5URVJOQUxTXS5lcnJvcjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgYm9keSB9ID0gZGF0YTtcbiAgICAgIGlmIChib2R5ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBpbXBvcnRfbm9kZV9idWZmZXIuQnVmZmVyLmFsbG9jKDApO1xuICAgICAgfVxuICAgICAgaWYgKCEoYm9keSBpbnN0YW5jZW9mIGltcG9ydF9ub2RlX3N0cmVhbS5kZWZhdWx0KSkge1xuICAgICAgICByZXR1cm4gaW1wb3J0X25vZGVfYnVmZmVyLkJ1ZmZlci5hbGxvYygwKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFjY3VtID0gW107XG4gICAgICBsZXQgYWNjdW1CeXRlcyA9IDA7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGJvZHkpIHtcbiAgICAgICAgICBpZiAoZGF0YS5zaXplID4gMCAmJiBhY2N1bUJ5dGVzICsgY2h1bmsubGVuZ3RoID4gZGF0YS5zaXplKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBGZXRjaEVycm9yKGBjb250ZW50IHNpemUgYXQgJHtkYXRhLnVybH0gb3ZlciBsaW1pdDogJHtkYXRhLnNpemV9YCwgXCJtYXgtc2l6ZVwiKTtcbiAgICAgICAgICAgIGJvZHkuZGVzdHJveShlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYWNjdW1CeXRlcyArPSBjaHVuay5sZW5ndGg7XG4gICAgICAgICAgYWNjdW0ucHVzaChjaHVuayk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IGVycm9yXyA9IGVycm9yIGluc3RhbmNlb2YgRmV0Y2hCYXNlRXJyb3IgPyBlcnJvciA6IG5ldyBGZXRjaEVycm9yKGBJbnZhbGlkIHJlc3BvbnNlIGJvZHkgd2hpbGUgdHJ5aW5nIHRvIGZldGNoICR7ZGF0YS51cmx9OiAke2Vycm9yLm1lc3NhZ2V9YCwgXCJzeXN0ZW1cIiwgZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcl87XG4gICAgICB9XG4gICAgICBpZiAoYm9keS5yZWFkYWJsZUVuZGVkID09PSB0cnVlIHx8IGJvZHkuX3JlYWRhYmxlU3RhdGUuZW5kZWQgPT09IHRydWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoYWNjdW0uZXZlcnkoKGMpID0+IHR5cGVvZiBjID09PSBcInN0cmluZ1wiKSkge1xuICAgICAgICAgICAgcmV0dXJuIGltcG9ydF9ub2RlX2J1ZmZlci5CdWZmZXIuZnJvbShhY2N1bS5qb2luKFwiXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGltcG9ydF9ub2RlX2J1ZmZlci5CdWZmZXIuY29uY2F0KGFjY3VtLCBhY2N1bUJ5dGVzKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRmV0Y2hFcnJvcihgQ291bGQgbm90IGNyZWF0ZSBCdWZmZXIgZnJvbSByZXNwb25zZSBib2R5IGZvciAke2RhdGEudXJsfTogJHtlcnJvci5tZXNzYWdlfWAsIFwic3lzdGVtXCIsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEZldGNoRXJyb3IoYFByZW1hdHVyZSBjbG9zZSBvZiBzZXJ2ZXIgcmVzcG9uc2Ugd2hpbGUgdHJ5aW5nIHRvIGZldGNoICR7ZGF0YS51cmx9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBjbG9uZSA9IChpbnN0YW5jZSwgaGlnaFdhdGVyTWFyaykgPT4ge1xuICAgICAgbGV0IHAxO1xuICAgICAgbGV0IHAyO1xuICAgICAgbGV0IHsgYm9keSB9ID0gaW5zdGFuY2VbSU5URVJOQUxTXTtcbiAgICAgIGlmIChpbnN0YW5jZS5ib2R5VXNlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgY2xvbmUgYm9keSBhZnRlciBpdCBpcyB1c2VkXCIpO1xuICAgICAgfVxuICAgICAgaWYgKGJvZHkgaW5zdGFuY2VvZiBpbXBvcnRfbm9kZV9zdHJlYW0uZGVmYXVsdCAmJiB0eXBlb2YgYm9keS5nZXRCb3VuZGFyeSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHAxID0gbmV3IGltcG9ydF9ub2RlX3N0cmVhbS5QYXNzVGhyb3VnaCh7IGhpZ2hXYXRlck1hcmsgfSk7XG4gICAgICAgIHAyID0gbmV3IGltcG9ydF9ub2RlX3N0cmVhbS5QYXNzVGhyb3VnaCh7IGhpZ2hXYXRlck1hcmsgfSk7XG4gICAgICAgIGJvZHkucGlwZShwMSk7XG4gICAgICAgIGJvZHkucGlwZShwMik7XG4gICAgICAgIGluc3RhbmNlW0lOVEVSTkFMU10uc3RyZWFtID0gcDE7XG4gICAgICAgIGJvZHkgPSBwMjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBib2R5O1xuICAgIH07XG4gICAgdmFyIGdldE5vblNwZWNGb3JtRGF0YUJvdW5kYXJ5ID0gKDAsIGltcG9ydF9ub2RlX3V0aWwuZGVwcmVjYXRlKSgoYm9keSkgPT4gYm9keS5nZXRCb3VuZGFyeSgpLCBcImZvcm0tZGF0YSBkb2Vzbid0IGZvbGxvdyB0aGUgc3BlYyBhbmQgcmVxdWlyZXMgc3BlY2lhbCB0cmVhdG1lbnQuIFVzZSBhbHRlcm5hdGl2ZSBwYWNrYWdlXCIsIFwiaHR0cHM6Ly9naXRodWIuY29tL25vZGUtZmV0Y2gvbm9kZS1mZXRjaC9pc3N1ZXMvMTE2N1wiKTtcbiAgICB2YXIgZXh0cmFjdENvbnRlbnRUeXBlID0gKGJvZHksIHJlcXVlc3QpID0+IHtcbiAgICAgIGlmIChib2R5ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBib2R5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBcInRleHQvcGxhaW47Y2hhcnNldD1VVEYtOFwiO1xuICAgICAgfVxuICAgICAgaWYgKGlzVVJMU2VhcmNoUGFyYW1ldGVycyhib2R5KSkge1xuICAgICAgICByZXR1cm4gXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD1VVEYtOFwiO1xuICAgICAgfVxuICAgICAgaWYgKGlzQmxvYihib2R5KSkge1xuICAgICAgICByZXR1cm4gYm9keS50eXBlIHx8IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoaW1wb3J0X25vZGVfYnVmZmVyLkJ1ZmZlci5pc0J1ZmZlcihib2R5KSB8fCBpbXBvcnRfbm9kZV91dGlsLnR5cGVzLmlzQW55QXJyYXlCdWZmZXIoYm9keSkgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KGJvZHkpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGJvZHkgaW5zdGFuY2VvZiBGb3JtRGF0YSkge1xuICAgICAgICByZXR1cm4gYG11bHRpcGFydC9mb3JtLWRhdGE7IGJvdW5kYXJ5PSR7cmVxdWVzdFtJTlRFUk5BTFNdLmJvdW5kYXJ5fWA7XG4gICAgICB9XG4gICAgICBpZiAoYm9keSAmJiB0eXBlb2YgYm9keS5nZXRCb3VuZGFyeSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBgbXVsdGlwYXJ0L2Zvcm0tZGF0YTtib3VuZGFyeT0ke2dldE5vblNwZWNGb3JtRGF0YUJvdW5kYXJ5KGJvZHkpfWA7XG4gICAgICB9XG4gICAgICBpZiAoYm9keSBpbnN0YW5jZW9mIGltcG9ydF9ub2RlX3N0cmVhbS5kZWZhdWx0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwidGV4dC9wbGFpbjtjaGFyc2V0PVVURi04XCI7XG4gICAgfTtcbiAgICB2YXIgZ2V0VG90YWxCeXRlcyA9IChyZXF1ZXN0KSA9PiB7XG4gICAgICBjb25zdCB7IGJvZHkgfSA9IHJlcXVlc3RbSU5URVJOQUxTXTtcbiAgICAgIGlmIChib2R5ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgaWYgKGlzQmxvYihib2R5KSkge1xuICAgICAgICByZXR1cm4gYm9keS5zaXplO1xuICAgICAgfVxuICAgICAgaWYgKGltcG9ydF9ub2RlX2J1ZmZlci5CdWZmZXIuaXNCdWZmZXIoYm9keSkpIHtcbiAgICAgICAgcmV0dXJuIGJvZHkubGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKGJvZHkgJiYgdHlwZW9mIGJvZHkuZ2V0TGVuZ3RoU3luYyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBib2R5Lmhhc0tub3duTGVuZ3RoICYmIGJvZHkuaGFzS25vd25MZW5ndGgoKSA/IGJvZHkuZ2V0TGVuZ3RoU3luYygpIDogbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgdmFyIHdyaXRlVG9TdHJlYW0gPSBhc3luYyAoZGVzdCwgeyBib2R5IH0pID0+IHtcbiAgICAgIGlmIChib2R5ID09PSBudWxsKSB7XG4gICAgICAgIGRlc3QuZW5kKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhd2FpdCBwaXBlbGluZShib2R5LCBkZXN0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBpbXBvcnRfbm9kZV91dGlsMiA9IF9fdG9Nb2R1bGUocmVxdWlyZShcInV0aWxcIikpO1xuICAgIHZhciBpbXBvcnRfbm9kZV9odHRwID0gX190b01vZHVsZShyZXF1aXJlKFwiaHR0cFwiKSk7XG4gICAgdmFyIHZhbGlkYXRlSGVhZGVyTmFtZSA9IHR5cGVvZiBpbXBvcnRfbm9kZV9odHRwLmRlZmF1bHQudmFsaWRhdGVIZWFkZXJOYW1lID09PSBcImZ1bmN0aW9uXCIgPyBpbXBvcnRfbm9kZV9odHRwLmRlZmF1bHQudmFsaWRhdGVIZWFkZXJOYW1lIDogKG5hbWUpID0+IHtcbiAgICAgIGlmICghL15bXFxeYFxcLVxcdyEjJCUmJyorLnx+XSskLy50ZXN0KG5hbWUpKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IFR5cGVFcnJvcihgSGVhZGVyIG5hbWUgbXVzdCBiZSBhIHZhbGlkIEhUVFAgdG9rZW4gWyR7bmFtZX1dYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlcnJvciwgXCJjb2RlXCIsIHsgdmFsdWU6IFwiRVJSX0lOVkFMSURfSFRUUF9UT0tFTlwiIH0pO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciB2YWxpZGF0ZUhlYWRlclZhbHVlID0gdHlwZW9mIGltcG9ydF9ub2RlX2h0dHAuZGVmYXVsdC52YWxpZGF0ZUhlYWRlclZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBpbXBvcnRfbm9kZV9odHRwLmRlZmF1bHQudmFsaWRhdGVIZWFkZXJWYWx1ZSA6IChuYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgaWYgKC9bXlxcdFxcdTAwMjAtXFx1MDA3RVxcdTAwODAtXFx1MDBGRl0vLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IFR5cGVFcnJvcihgSW52YWxpZCBjaGFyYWN0ZXIgaW4gaGVhZGVyIGNvbnRlbnQgW1wiJHtuYW1lfVwiXWApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyb3IsIFwiY29kZVwiLCB7IHZhbHVlOiBcIkVSUl9JTlZBTElEX0NIQVJcIiB9KTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgSGVhZGVycyA9IGNsYXNzIGV4dGVuZHMgVVJMU2VhcmNoUGFyYW1zIHtcbiAgICAgIGNvbnN0cnVjdG9yKGluaXQpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAoaW5pdCBpbnN0YW5jZW9mIEhlYWRlcnMpIHtcbiAgICAgICAgICBjb25zdCByYXcgPSBpbml0LnJhdygpO1xuICAgICAgICAgIGZvciAoY29uc3QgW25hbWUsIHZhbHVlc10gb2YgT2JqZWN0LmVudHJpZXMocmF3KSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goLi4udmFsdWVzLm1hcCgodmFsdWUpID0+IFtuYW1lLCB2YWx1ZV0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaW5pdCA9PSBudWxsKSB7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGluaXQgPT09IFwib2JqZWN0XCIgJiYgIWltcG9ydF9ub2RlX3V0aWwyLnR5cGVzLmlzQm94ZWRQcmltaXRpdmUoaW5pdCkpIHtcbiAgICAgICAgICBjb25zdCBtZXRob2QgPSBpbml0W1N5bWJvbC5pdGVyYXRvcl07XG4gICAgICAgICAgaWYgKG1ldGhvZCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCguLi5PYmplY3QuZW50cmllcyhpbml0KSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWV0aG9kICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkhlYWRlciBwYWlycyBtdXN0IGJlIGl0ZXJhYmxlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ID0gWy4uLmluaXRdLm1hcCgocGFpcikgPT4ge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIHBhaXIgIT09IFwib2JqZWN0XCIgfHwgaW1wb3J0X25vZGVfdXRpbDIudHlwZXMuaXNCb3hlZFByaW1pdGl2ZShwYWlyKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFYWNoIGhlYWRlciBwYWlyIG11c3QgYmUgYW4gaXRlcmFibGUgb2JqZWN0XCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBbLi4ucGFpcl07XG4gICAgICAgICAgICB9KS5tYXAoKHBhaXIpID0+IHtcbiAgICAgICAgICAgICAgaWYgKHBhaXIubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkVhY2ggaGVhZGVyIHBhaXIgbXVzdCBiZSBhIG5hbWUvdmFsdWUgdHVwbGVcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIFsuLi5wYWlyXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnSGVhZGVycyc6IFRoZSBwcm92aWRlZCB2YWx1ZSBpcyBub3Qgb2YgdHlwZSAnKHNlcXVlbmNlPHNlcXVlbmNlPEJ5dGVTdHJpbmc+PiBvciByZWNvcmQ8Qnl0ZVN0cmluZywgQnl0ZVN0cmluZz4pXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5sZW5ndGggPiAwID8gcmVzdWx0Lm1hcCgoW25hbWUsIHZhbHVlXSkgPT4ge1xuICAgICAgICAgIHZhbGlkYXRlSGVhZGVyTmFtZShuYW1lKTtcbiAgICAgICAgICB2YWxpZGF0ZUhlYWRlclZhbHVlKG5hbWUsIFN0cmluZyh2YWx1ZSkpO1xuICAgICAgICAgIHJldHVybiBbU3RyaW5nKG5hbWUpLnRvTG93ZXJDYXNlKCksIFN0cmluZyh2YWx1ZSldO1xuICAgICAgICB9KSA6IHZvaWQgMDtcbiAgICAgICAgc3VwZXIocmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm94eSh0aGlzLCB7XG4gICAgICAgICAgZ2V0KHRhcmdldCwgcCwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIHN3aXRjaCAocCkge1xuICAgICAgICAgICAgICBjYXNlIFwiYXBwZW5kXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJzZXRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gKG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICB2YWxpZGF0ZUhlYWRlck5hbWUobmFtZSk7XG4gICAgICAgICAgICAgICAgICB2YWxpZGF0ZUhlYWRlclZhbHVlKG5hbWUsIFN0cmluZyh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGVbcF0uY2FsbCh0YXJnZXQsIFN0cmluZyhuYW1lKS50b0xvd2VyQ2FzZSgpLCBTdHJpbmcodmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBjYXNlIFwiZGVsZXRlXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJoYXNcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImdldEFsbFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiAobmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgdmFsaWRhdGVIZWFkZXJOYW1lKG5hbWUpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGVbcF0uY2FsbCh0YXJnZXQsIFN0cmluZyhuYW1lKS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBjYXNlIFwia2V5c1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICB0YXJnZXQuc29ydCgpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTZXQoVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5rZXlzLmNhbGwodGFyZ2V0KSkua2V5cygpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcCwgcmVjZWl2ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICB9XG4gICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICAgIGdldChuYW1lKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMuZ2V0QWxsKG5hbWUpO1xuICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCB2YWx1ZSA9IHZhbHVlcy5qb2luKFwiLCBcIik7XG4gICAgICAgIGlmICgvXmNvbnRlbnQtZW5jb2RpbmckL2kudGVzdChuYW1lKSkge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBmb3JFYWNoKGNhbGxiYWNrLCB0aGlzQXJnID0gdm9pZCAwKSB7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiB0aGlzLmtleXMoKSkge1xuICAgICAgICAgIFJlZmxlY3QuYXBwbHkoY2FsbGJhY2ssIHRoaXNBcmcsIFt0aGlzLmdldChuYW1lKSwgbmFtZSwgdGhpc10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAqdmFsdWVzKCkge1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgdGhpcy5rZXlzKCkpIHtcbiAgICAgICAgICB5aWVsZCB0aGlzLmdldChuYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgKmVudHJpZXMoKSB7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiB0aGlzLmtleXMoKSkge1xuICAgICAgICAgIHlpZWxkIFtuYW1lLCB0aGlzLmdldChuYW1lKV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbnRyaWVzKCk7XG4gICAgICB9XG4gICAgICByYXcoKSB7XG4gICAgICAgIHJldHVybiBbLi4udGhpcy5rZXlzKCldLnJlZHVjZSgocmVzdWx0LCBrZXkpID0+IHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHRoaXMuZ2V0QWxsKGtleSk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSwge30pO1xuICAgICAgfVxuICAgICAgW1N5bWJvbC5mb3IoXCJub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbVwiKV0oKSB7XG4gICAgICAgIHJldHVybiBbLi4udGhpcy5rZXlzKCldLnJlZHVjZSgocmVzdWx0LCBrZXkpID0+IHtcbiAgICAgICAgICBjb25zdCB2YWx1ZXMgPSB0aGlzLmdldEFsbChrZXkpO1xuICAgICAgICAgIGlmIChrZXkgPT09IFwiaG9zdFwiKSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlc1swXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZXMubGVuZ3RoID4gMSA/IHZhbHVlcyA6IHZhbHVlc1swXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSwge30pO1xuICAgICAgfVxuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoSGVhZGVycy5wcm90b3R5cGUsIFtcImdldFwiLCBcImVudHJpZXNcIiwgXCJmb3JFYWNoXCIsIFwidmFsdWVzXCJdLnJlZHVjZSgocmVzdWx0LCBwcm9wZXJ0eSkgPT4ge1xuICAgICAgcmVzdWx0W3Byb3BlcnR5XSA9IHsgZW51bWVyYWJsZTogdHJ1ZSB9O1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCB7fSkpO1xuICAgIGZ1bmN0aW9uIGZyb21SYXdIZWFkZXJzKGhlYWRlcnMgPSBbXSkge1xuICAgICAgcmV0dXJuIG5ldyBIZWFkZXJzKGhlYWRlcnMucmVkdWNlKChyZXN1bHQsIHZhbHVlLCBpbmRleCwgYXJyYXkpID0+IHtcbiAgICAgICAgaWYgKGluZGV4ICUgMiA9PT0gMCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGFycmF5LnNsaWNlKGluZGV4LCBpbmRleCArIDIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSwgW10pLmZpbHRlcigoW25hbWUsIHZhbHVlXSkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhbGlkYXRlSGVhZGVyTmFtZShuYW1lKTtcbiAgICAgICAgICB2YWxpZGF0ZUhlYWRlclZhbHVlKG5hbWUsIFN0cmluZyh2YWx1ZSkpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICB9XG4gICAgdmFyIHJlZGlyZWN0U3RhdHVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoWzMwMSwgMzAyLCAzMDMsIDMwNywgMzA4XSk7XG4gICAgdmFyIGlzUmVkaXJlY3QgPSAoY29kZSkgPT4ge1xuICAgICAgcmV0dXJuIHJlZGlyZWN0U3RhdHVzLmhhcyhjb2RlKTtcbiAgICB9O1xuICAgIHZhciBJTlRFUk5BTFMyID0gU3ltYm9sKFwiUmVzcG9uc2UgaW50ZXJuYWxzXCIpO1xuICAgIHZhciBSZXNwb25zZSA9IGNsYXNzIGV4dGVuZHMgQm9keSB7XG4gICAgICBjb25zdHJ1Y3Rvcihib2R5ID0gbnVsbCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKGJvZHksIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBzdGF0dXMgPSBvcHRpb25zLnN0YXR1cyAhPSBudWxsID8gb3B0aW9ucy5zdGF0dXMgOiAyMDA7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICBpZiAoYm9keSAhPT0gbnVsbCAmJiAhaGVhZGVycy5oYXMoXCJDb250ZW50LVR5cGVcIikpIHtcbiAgICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IGV4dHJhY3RDb250ZW50VHlwZShib2R5LCB0aGlzKTtcbiAgICAgICAgICBpZiAoY29udGVudFR5cGUpIHtcbiAgICAgICAgICAgIGhlYWRlcnMuYXBwZW5kKFwiQ29udGVudC1UeXBlXCIsIGNvbnRlbnRUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1tJTlRFUk5BTFMyXSA9IHtcbiAgICAgICAgICB0eXBlOiBcImRlZmF1bHRcIixcbiAgICAgICAgICB1cmw6IG9wdGlvbnMudXJsLFxuICAgICAgICAgIHN0YXR1cyxcbiAgICAgICAgICBzdGF0dXNUZXh0OiBvcHRpb25zLnN0YXR1c1RleHQgfHwgXCJcIixcbiAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgIGNvdW50ZXI6IG9wdGlvbnMuY291bnRlcixcbiAgICAgICAgICBoaWdoV2F0ZXJNYXJrOiBvcHRpb25zLmhpZ2hXYXRlck1hcmtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tJTlRFUk5BTFMyXS50eXBlO1xuICAgICAgfVxuICAgICAgZ2V0IHVybCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbSU5URVJOQUxTMl0udXJsIHx8IFwiXCI7XG4gICAgICB9XG4gICAgICBnZXQgc3RhdHVzKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tJTlRFUk5BTFMyXS5zdGF0dXM7XG4gICAgICB9XG4gICAgICBnZXQgb2soKSB7XG4gICAgICAgIHJldHVybiB0aGlzW0lOVEVSTkFMUzJdLnN0YXR1cyA+PSAyMDAgJiYgdGhpc1tJTlRFUk5BTFMyXS5zdGF0dXMgPCAzMDA7XG4gICAgICB9XG4gICAgICBnZXQgcmVkaXJlY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbSU5URVJOQUxTMl0uY291bnRlciA+IDA7XG4gICAgICB9XG4gICAgICBnZXQgc3RhdHVzVGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbSU5URVJOQUxTMl0uc3RhdHVzVGV4dDtcbiAgICAgIH1cbiAgICAgIGdldCBoZWFkZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tJTlRFUk5BTFMyXS5oZWFkZXJzO1xuICAgICAgfVxuICAgICAgZ2V0IGhpZ2hXYXRlck1hcmsoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW0lOVEVSTkFMUzJdLmhpZ2hXYXRlck1hcms7XG4gICAgICB9XG4gICAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShjbG9uZSh0aGlzLCB0aGlzLmhpZ2hXYXRlck1hcmspLCB7XG4gICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgIHVybDogdGhpcy51cmwsXG4gICAgICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgICAgICBzdGF0dXNUZXh0OiB0aGlzLnN0YXR1c1RleHQsXG4gICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgIG9rOiB0aGlzLm9rLFxuICAgICAgICAgIHJlZGlyZWN0ZWQ6IHRoaXMucmVkaXJlY3RlZCxcbiAgICAgICAgICBzaXplOiB0aGlzLnNpemUsXG4gICAgICAgICAgaGlnaFdhdGVyTWFyazogdGhpcy5oaWdoV2F0ZXJNYXJrXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgc3RhdGljIHJlZGlyZWN0KHVybCwgc3RhdHVzID0gMzAyKSB7XG4gICAgICAgIGlmICghaXNSZWRpcmVjdChzdGF0dXMpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ZhaWxlZCB0byBleGVjdXRlIFwicmVkaXJlY3RcIiBvbiBcInJlc3BvbnNlXCI6IEludmFsaWQgc3RhdHVzIGNvZGUnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHtcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBsb2NhdGlvbjogbmV3IFVSTCh1cmwpLnRvU3RyaW5nKClcbiAgICAgICAgICB9LFxuICAgICAgICAgIHN0YXR1c1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHN0YXRpYyBlcnJvcigpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UobnVsbCwgeyBzdGF0dXM6IDAsIHN0YXR1c1RleHQ6IFwiXCIgfSk7XG4gICAgICAgIHJlc3BvbnNlW0lOVEVSTkFMUzJdLnR5cGUgPSBcImVycm9yXCI7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgIH1cbiAgICAgIHN0YXRpYyBqc29uKGRhdGEgPSB2b2lkIDAsIGluaXQgPSB7fSkge1xuICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgICAgIGlmIChib2R5ID09PSB2b2lkIDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZGF0YSBpcyBub3QgSlNPTiBzZXJpYWxpemFibGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKGluaXQgJiYgaW5pdC5oZWFkZXJzKTtcbiAgICAgICAgaWYgKCFoZWFkZXJzLmhhcyhcImNvbnRlbnQtdHlwZVwiKSkge1xuICAgICAgICAgIGhlYWRlcnMuc2V0KFwiY29udGVudC10eXBlXCIsIFwiYXBwbGljYXRpb24vanNvblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKGJvZHksIHtcbiAgICAgICAgICAuLi5pbml0LFxuICAgICAgICAgIGhlYWRlcnNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgICAgIHJldHVybiBcIlJlc3BvbnNlXCI7XG4gICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZXNwb25zZS5wcm90b3R5cGUsIHtcbiAgICAgIHR5cGU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgdXJsOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgIHN0YXR1czogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICBvazogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICByZWRpcmVjdGVkOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgIHN0YXR1c1RleHQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgaGVhZGVyczogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICBjbG9uZTogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbiAgICB9KTtcbiAgICB2YXIgaW1wb3J0X25vZGVfdXJsID0gX190b01vZHVsZShyZXF1aXJlKFwidXJsXCIpKTtcbiAgICB2YXIgaW1wb3J0X25vZGVfdXRpbDMgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCJ1dGlsXCIpKTtcbiAgICB2YXIgZ2V0U2VhcmNoID0gKHBhcnNlZFVSTCkgPT4ge1xuICAgICAgaWYgKHBhcnNlZFVSTC5zZWFyY2gpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlZFVSTC5zZWFyY2g7XG4gICAgICB9XG4gICAgICBjb25zdCBsYXN0T2Zmc2V0ID0gcGFyc2VkVVJMLmhyZWYubGVuZ3RoIC0gMTtcbiAgICAgIGNvbnN0IGhhc2ggPSBwYXJzZWRVUkwuaGFzaCB8fCAocGFyc2VkVVJMLmhyZWZbbGFzdE9mZnNldF0gPT09IFwiI1wiID8gXCIjXCIgOiBcIlwiKTtcbiAgICAgIHJldHVybiBwYXJzZWRVUkwuaHJlZltsYXN0T2Zmc2V0IC0gaGFzaC5sZW5ndGhdID09PSBcIj9cIiA/IFwiP1wiIDogXCJcIjtcbiAgICB9O1xuICAgIHZhciBpbXBvcnRfbm9kZV9uZXQgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCJuZXRcIikpO1xuICAgIGZ1bmN0aW9uIHN0cmlwVVJMRm9yVXNlQXNBUmVmZXJyZXIodXJsLCBvcmlnaW5Pbmx5ID0gZmFsc2UpIHtcbiAgICAgIGlmICh1cmwgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gXCJuby1yZWZlcnJlclwiO1xuICAgICAgfVxuICAgICAgdXJsID0gbmV3IFVSTCh1cmwpO1xuICAgICAgaWYgKC9eKGFib3V0fGJsb2J8ZGF0YSk6JC8udGVzdCh1cmwucHJvdG9jb2wpKSB7XG4gICAgICAgIHJldHVybiBcIm5vLXJlZmVycmVyXCI7XG4gICAgICB9XG4gICAgICB1cmwudXNlcm5hbWUgPSBcIlwiO1xuICAgICAgdXJsLnBhc3N3b3JkID0gXCJcIjtcbiAgICAgIHVybC5oYXNoID0gXCJcIjtcbiAgICAgIGlmIChvcmlnaW5Pbmx5KSB7XG4gICAgICAgIHVybC5wYXRobmFtZSA9IFwiXCI7XG4gICAgICAgIHVybC5zZWFyY2ggPSBcIlwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVybDtcbiAgICB9XG4gICAgdmFyIFJlZmVycmVyUG9saWN5ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICAgICAgXCJcIixcbiAgICAgIFwibm8tcmVmZXJyZXJcIixcbiAgICAgIFwibm8tcmVmZXJyZXItd2hlbi1kb3duZ3JhZGVcIixcbiAgICAgIFwic2FtZS1vcmlnaW5cIixcbiAgICAgIFwib3JpZ2luXCIsXG4gICAgICBcInN0cmljdC1vcmlnaW5cIixcbiAgICAgIFwib3JpZ2luLXdoZW4tY3Jvc3Mtb3JpZ2luXCIsXG4gICAgICBcInN0cmljdC1vcmlnaW4td2hlbi1jcm9zcy1vcmlnaW5cIixcbiAgICAgIFwidW5zYWZlLXVybFwiXG4gICAgXSk7XG4gICAgdmFyIERFRkFVTFRfUkVGRVJSRVJfUE9MSUNZID0gXCJzdHJpY3Qtb3JpZ2luLXdoZW4tY3Jvc3Mtb3JpZ2luXCI7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVSZWZlcnJlclBvbGljeShyZWZlcnJlclBvbGljeSkge1xuICAgICAgaWYgKCFSZWZlcnJlclBvbGljeS5oYXMocmVmZXJyZXJQb2xpY3kpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgcmVmZXJyZXJQb2xpY3k6ICR7cmVmZXJyZXJQb2xpY3l9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVmZXJyZXJQb2xpY3k7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzT3JpZ2luUG90ZW50aWFsbHlUcnVzdHdvcnRoeSh1cmwpIHtcbiAgICAgIGlmICgvXihodHRwfHdzKXM6JC8udGVzdCh1cmwucHJvdG9jb2wpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgaG9zdElwID0gdXJsLmhvc3QucmVwbGFjZSgvKF5cXFspfChdJCkvZywgXCJcIik7XG4gICAgICBjb25zdCBob3N0SVBWZXJzaW9uID0gKDAsIGltcG9ydF9ub2RlX25ldC5pc0lQKShob3N0SXApO1xuICAgICAgaWYgKGhvc3RJUFZlcnNpb24gPT09IDQgJiYgL14xMjdcXC4vLnRlc3QoaG9zdElwKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChob3N0SVBWZXJzaW9uID09PSA2ICYmIC9eKCgoMCs6KXs3fSl8KDo6KDArOil7MCw2fSkpMCoxJC8udGVzdChob3N0SXApKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHVybC5ob3N0ID09PSBcImxvY2FsaG9zdFwiIHx8IHVybC5ob3N0LmVuZHNXaXRoKFwiLmxvY2FsaG9zdFwiKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodXJsLnByb3RvY29sID09PSBcImZpbGU6XCIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzVXJsUG90ZW50aWFsbHlUcnVzdHdvcnRoeSh1cmwpIHtcbiAgICAgIGlmICgvXmFib3V0OihibGFua3xzcmNkb2MpJC8udGVzdCh1cmwpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHVybC5wcm90b2NvbCA9PT0gXCJkYXRhOlwiKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKC9eKGJsb2J8ZmlsZXN5c3RlbSk6JC8udGVzdCh1cmwucHJvdG9jb2wpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzT3JpZ2luUG90ZW50aWFsbHlUcnVzdHdvcnRoeSh1cmwpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXRlcm1pbmVSZXF1ZXN0c1JlZmVycmVyKHJlcXVlc3QsIHsgcmVmZXJyZXJVUkxDYWxsYmFjaywgcmVmZXJyZXJPcmlnaW5DYWxsYmFjayB9ID0ge30pIHtcbiAgICAgIGlmIChyZXF1ZXN0LnJlZmVycmVyID09PSBcIm5vLXJlZmVycmVyXCIgfHwgcmVxdWVzdC5yZWZlcnJlclBvbGljeSA9PT0gXCJcIikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBvbGljeSA9IHJlcXVlc3QucmVmZXJyZXJQb2xpY3k7XG4gICAgICBpZiAocmVxdWVzdC5yZWZlcnJlciA9PT0gXCJhYm91dDpjbGllbnRcIikge1xuICAgICAgICByZXR1cm4gXCJuby1yZWZlcnJlclwiO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVmZXJyZXJTb3VyY2UgPSByZXF1ZXN0LnJlZmVycmVyO1xuICAgICAgbGV0IHJlZmVycmVyVVJMID0gc3RyaXBVUkxGb3JVc2VBc0FSZWZlcnJlcihyZWZlcnJlclNvdXJjZSk7XG4gICAgICBsZXQgcmVmZXJyZXJPcmlnaW4gPSBzdHJpcFVSTEZvclVzZUFzQVJlZmVycmVyKHJlZmVycmVyU291cmNlLCB0cnVlKTtcbiAgICAgIGlmIChyZWZlcnJlclVSTC50b1N0cmluZygpLmxlbmd0aCA+IDQwOTYpIHtcbiAgICAgICAgcmVmZXJyZXJVUkwgPSByZWZlcnJlck9yaWdpbjtcbiAgICAgIH1cbiAgICAgIGlmIChyZWZlcnJlclVSTENhbGxiYWNrKSB7XG4gICAgICAgIHJlZmVycmVyVVJMID0gcmVmZXJyZXJVUkxDYWxsYmFjayhyZWZlcnJlclVSTCk7XG4gICAgICB9XG4gICAgICBpZiAocmVmZXJyZXJPcmlnaW5DYWxsYmFjaykge1xuICAgICAgICByZWZlcnJlck9yaWdpbiA9IHJlZmVycmVyT3JpZ2luQ2FsbGJhY2socmVmZXJyZXJPcmlnaW4pO1xuICAgICAgfVxuICAgICAgY29uc3QgY3VycmVudFVSTCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICAgICAgc3dpdGNoIChwb2xpY3kpIHtcbiAgICAgICAgY2FzZSBcIm5vLXJlZmVycmVyXCI6XG4gICAgICAgICAgcmV0dXJuIFwibm8tcmVmZXJyZXJcIjtcbiAgICAgICAgY2FzZSBcIm9yaWdpblwiOlxuICAgICAgICAgIHJldHVybiByZWZlcnJlck9yaWdpbjtcbiAgICAgICAgY2FzZSBcInVuc2FmZS11cmxcIjpcbiAgICAgICAgICByZXR1cm4gcmVmZXJyZXJVUkw7XG4gICAgICAgIGNhc2UgXCJzdHJpY3Qtb3JpZ2luXCI6XG4gICAgICAgICAgaWYgKGlzVXJsUG90ZW50aWFsbHlUcnVzdHdvcnRoeShyZWZlcnJlclVSTCkgJiYgIWlzVXJsUG90ZW50aWFsbHlUcnVzdHdvcnRoeShjdXJyZW50VVJMKSkge1xuICAgICAgICAgICAgcmV0dXJuIFwibm8tcmVmZXJyZXJcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlZmVycmVyT3JpZ2luLnRvU3RyaW5nKCk7XG4gICAgICAgIGNhc2UgXCJzdHJpY3Qtb3JpZ2luLXdoZW4tY3Jvc3Mtb3JpZ2luXCI6XG4gICAgICAgICAgaWYgKHJlZmVycmVyVVJMLm9yaWdpbiA9PT0gY3VycmVudFVSTC5vcmlnaW4pIHtcbiAgICAgICAgICAgIHJldHVybiByZWZlcnJlclVSTDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzVXJsUG90ZW50aWFsbHlUcnVzdHdvcnRoeShyZWZlcnJlclVSTCkgJiYgIWlzVXJsUG90ZW50aWFsbHlUcnVzdHdvcnRoeShjdXJyZW50VVJMKSkge1xuICAgICAgICAgICAgcmV0dXJuIFwibm8tcmVmZXJyZXJcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlZmVycmVyT3JpZ2luO1xuICAgICAgICBjYXNlIFwic2FtZS1vcmlnaW5cIjpcbiAgICAgICAgICBpZiAocmVmZXJyZXJVUkwub3JpZ2luID09PSBjdXJyZW50VVJMLm9yaWdpbikge1xuICAgICAgICAgICAgcmV0dXJuIHJlZmVycmVyVVJMO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gXCJuby1yZWZlcnJlclwiO1xuICAgICAgICBjYXNlIFwib3JpZ2luLXdoZW4tY3Jvc3Mtb3JpZ2luXCI6XG4gICAgICAgICAgaWYgKHJlZmVycmVyVVJMLm9yaWdpbiA9PT0gY3VycmVudFVSTC5vcmlnaW4pIHtcbiAgICAgICAgICAgIHJldHVybiByZWZlcnJlclVSTDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlZmVycmVyT3JpZ2luO1xuICAgICAgICBjYXNlIFwibm8tcmVmZXJyZXItd2hlbi1kb3duZ3JhZGVcIjpcbiAgICAgICAgICBpZiAoaXNVcmxQb3RlbnRpYWxseVRydXN0d29ydGh5KHJlZmVycmVyVVJMKSAmJiAhaXNVcmxQb3RlbnRpYWxseVRydXN0d29ydGh5KGN1cnJlbnRVUkwpKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJuby1yZWZlcnJlclwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVmZXJyZXJVUkw7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCByZWZlcnJlclBvbGljeTogJHtwb2xpY3l9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlUmVmZXJyZXJQb2xpY3lGcm9tSGVhZGVyKGhlYWRlcnMpIHtcbiAgICAgIGNvbnN0IHBvbGljeVRva2VucyA9IChoZWFkZXJzLmdldChcInJlZmVycmVyLXBvbGljeVwiKSB8fCBcIlwiKS5zcGxpdCgvWyxcXHNdKy8pO1xuICAgICAgbGV0IHBvbGljeSA9IFwiXCI7XG4gICAgICBmb3IgKGNvbnN0IHRva2VuIG9mIHBvbGljeVRva2Vucykge1xuICAgICAgICBpZiAodG9rZW4gJiYgUmVmZXJyZXJQb2xpY3kuaGFzKHRva2VuKSkge1xuICAgICAgICAgIHBvbGljeSA9IHRva2VuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcG9saWN5O1xuICAgIH1cbiAgICB2YXIgSU5URVJOQUxTMyA9IFN5bWJvbChcIlJlcXVlc3QgaW50ZXJuYWxzXCIpO1xuICAgIHZhciBpc1JlcXVlc3QgPSAob2JqZWN0KSA9PiB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqZWN0W0lOVEVSTkFMUzNdID09PSBcIm9iamVjdFwiO1xuICAgIH07XG4gICAgdmFyIGRvQmFkRGF0YVdhcm4gPSAoMCwgaW1wb3J0X25vZGVfdXRpbDMuZGVwcmVjYXRlKSgoKSA9PiB7XG4gICAgfSwgXCIuZGF0YSBpcyBub3QgYSB2YWxpZCBSZXF1ZXN0SW5pdCBwcm9wZXJ0eSwgdXNlIC5ib2R5IGluc3RlYWRcIiwgXCJodHRwczovL2dpdGh1Yi5jb20vbm9kZS1mZXRjaC9ub2RlLWZldGNoL2lzc3Vlcy8xMDAwIChyZXF1ZXN0KVwiKTtcbiAgICB2YXIgUmVxdWVzdCA9IGNsYXNzIGV4dGVuZHMgQm9keSB7XG4gICAgICBjb25zdHJ1Y3RvcihpbnB1dCwgaW5pdCA9IHt9KSB7XG4gICAgICAgIGxldCBwYXJzZWRVUkw7XG4gICAgICAgIGlmIChpc1JlcXVlc3QoaW5wdXQpKSB7XG4gICAgICAgICAgcGFyc2VkVVJMID0gbmV3IFVSTChpbnB1dC51cmwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcnNlZFVSTCA9IG5ldyBVUkwoaW5wdXQpO1xuICAgICAgICAgIGlucHV0ID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnNlZFVSTC51c2VybmFtZSAhPT0gXCJcIiB8fCBwYXJzZWRVUkwucGFzc3dvcmQgIT09IFwiXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke3BhcnNlZFVSTH0gaXMgYW4gdXJsIHdpdGggZW1iZWRkZWQgY3JlZGVudGlhbHMuYCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1ldGhvZCA9IGluaXQubWV0aG9kIHx8IGlucHV0Lm1ldGhvZCB8fCBcIkdFVFwiO1xuICAgICAgICBpZiAoL14oZGVsZXRlfGdldHxoZWFkfG9wdGlvbnN8cG9zdHxwdXQpJC9pLnRlc3QobWV0aG9kKSkge1xuICAgICAgICAgIG1ldGhvZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNSZXF1ZXN0KGluaXQpICYmIFwiZGF0YVwiIGluIGluaXQpIHtcbiAgICAgICAgICBkb0JhZERhdGFXYXJuKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChpbml0LmJvZHkgIT0gbnVsbCB8fCBpc1JlcXVlc3QoaW5wdXQpICYmIGlucHV0LmJvZHkgIT09IG51bGwpICYmIChtZXRob2QgPT09IFwiR0VUXCIgfHwgbWV0aG9kID09PSBcIkhFQURcIikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUmVxdWVzdCB3aXRoIEdFVC9IRUFEIG1ldGhvZCBjYW5ub3QgaGF2ZSBib2R5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlucHV0Qm9keSA9IGluaXQuYm9keSA/IGluaXQuYm9keSA6IGlzUmVxdWVzdChpbnB1dCkgJiYgaW5wdXQuYm9keSAhPT0gbnVsbCA/IGNsb25lKGlucHV0KSA6IG51bGw7XG4gICAgICAgIHN1cGVyKGlucHV0Qm9keSwge1xuICAgICAgICAgIHNpemU6IGluaXQuc2l6ZSB8fCBpbnB1dC5zaXplIHx8IDBcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhpbml0LmhlYWRlcnMgfHwgaW5wdXQuaGVhZGVycyB8fCB7fSk7XG4gICAgICAgIGlmIChpbnB1dEJvZHkgIT09IG51bGwgJiYgIWhlYWRlcnMuaGFzKFwiQ29udGVudC1UeXBlXCIpKSB7XG4gICAgICAgICAgY29uc3QgY29udGVudFR5cGUgPSBleHRyYWN0Q29udGVudFR5cGUoaW5wdXRCb2R5LCB0aGlzKTtcbiAgICAgICAgICBpZiAoY29udGVudFR5cGUpIHtcbiAgICAgICAgICAgIGhlYWRlcnMuc2V0KFwiQ29udGVudC1UeXBlXCIsIGNvbnRlbnRUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNpZ25hbCA9IGlzUmVxdWVzdChpbnB1dCkgPyBpbnB1dC5zaWduYWwgOiBudWxsO1xuICAgICAgICBpZiAoXCJzaWduYWxcIiBpbiBpbml0KSB7XG4gICAgICAgICAgc2lnbmFsID0gaW5pdC5zaWduYWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNpZ25hbCAhPSBudWxsICYmICFpc0Fib3J0U2lnbmFsKHNpZ25hbCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgc2lnbmFsIHRvIGJlIGFuIGluc3RhbmNlb2YgQWJvcnRTaWduYWwgb3IgRXZlbnRUYXJnZXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlZmVycmVyID0gaW5pdC5yZWZlcnJlciA9PSBudWxsID8gaW5wdXQucmVmZXJyZXIgOiBpbml0LnJlZmVycmVyO1xuICAgICAgICBpZiAocmVmZXJyZXIgPT09IFwiXCIpIHtcbiAgICAgICAgICByZWZlcnJlciA9IFwibm8tcmVmZXJyZXJcIjtcbiAgICAgICAgfSBlbHNlIGlmIChyZWZlcnJlcikge1xuICAgICAgICAgIGNvbnN0IHBhcnNlZFJlZmVycmVyID0gbmV3IFVSTChyZWZlcnJlcik7XG4gICAgICAgICAgcmVmZXJyZXIgPSAvXmFib3V0OihcXC9cXC8pP2NsaWVudCQvLnRlc3QocGFyc2VkUmVmZXJyZXIpID8gXCJjbGllbnRcIiA6IHBhcnNlZFJlZmVycmVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlZmVycmVyID0gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbSU5URVJOQUxTM10gPSB7XG4gICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgIHJlZGlyZWN0OiBpbml0LnJlZGlyZWN0IHx8IGlucHV0LnJlZGlyZWN0IHx8IFwiZm9sbG93XCIsXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICBwYXJzZWRVUkwsXG4gICAgICAgICAgc2lnbmFsLFxuICAgICAgICAgIHJlZmVycmVyXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZm9sbG93ID0gaW5pdC5mb2xsb3cgPT09IHZvaWQgMCA/IGlucHV0LmZvbGxvdyA9PT0gdm9pZCAwID8gMjAgOiBpbnB1dC5mb2xsb3cgOiBpbml0LmZvbGxvdztcbiAgICAgICAgdGhpcy5jb21wcmVzcyA9IGluaXQuY29tcHJlc3MgPT09IHZvaWQgMCA/IGlucHV0LmNvbXByZXNzID09PSB2b2lkIDAgPyB0cnVlIDogaW5wdXQuY29tcHJlc3MgOiBpbml0LmNvbXByZXNzO1xuICAgICAgICB0aGlzLmNvdW50ZXIgPSBpbml0LmNvdW50ZXIgfHwgaW5wdXQuY291bnRlciB8fCAwO1xuICAgICAgICB0aGlzLmFnZW50ID0gaW5pdC5hZ2VudCB8fCBpbnB1dC5hZ2VudDtcbiAgICAgICAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaW5pdC5oaWdoV2F0ZXJNYXJrIHx8IGlucHV0LmhpZ2hXYXRlck1hcmsgfHwgMTYzODQ7XG4gICAgICAgIHRoaXMuaW5zZWN1cmVIVFRQUGFyc2VyID0gaW5pdC5pbnNlY3VyZUhUVFBQYXJzZXIgfHwgaW5wdXQuaW5zZWN1cmVIVFRQUGFyc2VyIHx8IGZhbHNlO1xuICAgICAgICB0aGlzLnJlZmVycmVyUG9saWN5ID0gaW5pdC5yZWZlcnJlclBvbGljeSB8fCBpbnB1dC5yZWZlcnJlclBvbGljeSB8fCBcIlwiO1xuICAgICAgfVxuICAgICAgZ2V0IG1ldGhvZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbSU5URVJOQUxTM10ubWV0aG9kO1xuICAgICAgfVxuICAgICAgZ2V0IHVybCgpIHtcbiAgICAgICAgcmV0dXJuICgwLCBpbXBvcnRfbm9kZV91cmwuZm9ybWF0KSh0aGlzW0lOVEVSTkFMUzNdLnBhcnNlZFVSTCk7XG4gICAgICB9XG4gICAgICBnZXQgaGVhZGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbSU5URVJOQUxTM10uaGVhZGVycztcbiAgICAgIH1cbiAgICAgIGdldCByZWRpcmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbSU5URVJOQUxTM10ucmVkaXJlY3Q7XG4gICAgICB9XG4gICAgICBnZXQgc2lnbmFsKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tJTlRFUk5BTFMzXS5zaWduYWw7XG4gICAgICB9XG4gICAgICBnZXQgcmVmZXJyZXIoKSB7XG4gICAgICAgIGlmICh0aGlzW0lOVEVSTkFMUzNdLnJlZmVycmVyID09PSBcIm5vLXJlZmVycmVyXCIpIHtcbiAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpc1tJTlRFUk5BTFMzXS5yZWZlcnJlciA9PT0gXCJjbGllbnRcIikge1xuICAgICAgICAgIHJldHVybiBcImFib3V0OmNsaWVudFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzW0lOVEVSTkFMUzNdLnJlZmVycmVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXNbSU5URVJOQUxTM10ucmVmZXJyZXIudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfVxuICAgICAgZ2V0IHJlZmVycmVyUG9saWN5KCkge1xuICAgICAgICByZXR1cm4gdGhpc1tJTlRFUk5BTFMzXS5yZWZlcnJlclBvbGljeTtcbiAgICAgIH1cbiAgICAgIHNldCByZWZlcnJlclBvbGljeShyZWZlcnJlclBvbGljeSkge1xuICAgICAgICB0aGlzW0lOVEVSTkFMUzNdLnJlZmVycmVyUG9saWN5ID0gdmFsaWRhdGVSZWZlcnJlclBvbGljeShyZWZlcnJlclBvbGljeSk7XG4gICAgICB9XG4gICAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXF1ZXN0KHRoaXMpO1xuICAgICAgfVxuICAgICAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgICAgICByZXR1cm4gXCJSZXF1ZXN0XCI7XG4gICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZXF1ZXN0LnByb3RvdHlwZSwge1xuICAgICAgbWV0aG9kOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgIHVybDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICBoZWFkZXJzOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgIHJlZGlyZWN0OiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgIGNsb25lOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgIHNpZ25hbDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICByZWZlcnJlcjogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICByZWZlcnJlclBvbGljeTogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbiAgICB9KTtcbiAgICB2YXIgZ2V0Tm9kZVJlcXVlc3RPcHRpb25zID0gKHJlcXVlc3QpID0+IHtcbiAgICAgIGNvbnN0IHsgcGFyc2VkVVJMIH0gPSByZXF1ZXN0W0lOVEVSTkFMUzNdO1xuICAgICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHJlcXVlc3RbSU5URVJOQUxTM10uaGVhZGVycyk7XG4gICAgICBpZiAoIWhlYWRlcnMuaGFzKFwiQWNjZXB0XCIpKSB7XG4gICAgICAgIGhlYWRlcnMuc2V0KFwiQWNjZXB0XCIsIFwiKi8qXCIpO1xuICAgICAgfVxuICAgICAgbGV0IGNvbnRlbnRMZW5ndGhWYWx1ZSA9IG51bGw7XG4gICAgICBpZiAocmVxdWVzdC5ib2R5ID09PSBudWxsICYmIC9eKHBvc3R8cHV0KSQvaS50ZXN0KHJlcXVlc3QubWV0aG9kKSkge1xuICAgICAgICBjb250ZW50TGVuZ3RoVmFsdWUgPSBcIjBcIjtcbiAgICAgIH1cbiAgICAgIGlmIChyZXF1ZXN0LmJvZHkgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgdG90YWxCeXRlcyA9IGdldFRvdGFsQnl0ZXMocmVxdWVzdCk7XG4gICAgICAgIGlmICh0eXBlb2YgdG90YWxCeXRlcyA9PT0gXCJudW1iZXJcIiAmJiAhTnVtYmVyLmlzTmFOKHRvdGFsQnl0ZXMpKSB7XG4gICAgICAgICAgY29udGVudExlbmd0aFZhbHVlID0gU3RyaW5nKHRvdGFsQnl0ZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY29udGVudExlbmd0aFZhbHVlKSB7XG4gICAgICAgIGhlYWRlcnMuc2V0KFwiQ29udGVudC1MZW5ndGhcIiwgY29udGVudExlbmd0aFZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXF1ZXN0LnJlZmVycmVyUG9saWN5ID09PSBcIlwiKSB7XG4gICAgICAgIHJlcXVlc3QucmVmZXJyZXJQb2xpY3kgPSBERUZBVUxUX1JFRkVSUkVSX1BPTElDWTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXF1ZXN0LnJlZmVycmVyICYmIHJlcXVlc3QucmVmZXJyZXIgIT09IFwibm8tcmVmZXJyZXJcIikge1xuICAgICAgICByZXF1ZXN0W0lOVEVSTkFMUzNdLnJlZmVycmVyID0gZGV0ZXJtaW5lUmVxdWVzdHNSZWZlcnJlcihyZXF1ZXN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcXVlc3RbSU5URVJOQUxTM10ucmVmZXJyZXIgPSBcIm5vLXJlZmVycmVyXCI7XG4gICAgICB9XG4gICAgICBpZiAocmVxdWVzdFtJTlRFUk5BTFMzXS5yZWZlcnJlciBpbnN0YW5jZW9mIFVSTCkge1xuICAgICAgICBoZWFkZXJzLnNldChcIlJlZmVyZXJcIiwgcmVxdWVzdC5yZWZlcnJlcik7XG4gICAgICB9XG4gICAgICBpZiAoIWhlYWRlcnMuaGFzKFwiVXNlci1BZ2VudFwiKSkge1xuICAgICAgICBoZWFkZXJzLnNldChcIlVzZXItQWdlbnRcIiwgXCJub2RlLWZldGNoXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHJlcXVlc3QuY29tcHJlc3MgJiYgIWhlYWRlcnMuaGFzKFwiQWNjZXB0LUVuY29kaW5nXCIpKSB7XG4gICAgICAgIGhlYWRlcnMuc2V0KFwiQWNjZXB0LUVuY29kaW5nXCIsIFwiZ3ppcCwgZGVmbGF0ZSwgYnJcIik7XG4gICAgICB9XG4gICAgICBsZXQgeyBhZ2VudCB9ID0gcmVxdWVzdDtcbiAgICAgIGlmICh0eXBlb2YgYWdlbnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBhZ2VudCA9IGFnZW50KHBhcnNlZFVSTCk7XG4gICAgICB9XG4gICAgICBjb25zdCBzZWFyY2ggPSBnZXRTZWFyY2gocGFyc2VkVVJMKTtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIHBhdGg6IHBhcnNlZFVSTC5wYXRobmFtZSArIHNlYXJjaCxcbiAgICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgICAgaGVhZGVyczogaGVhZGVyc1tTeW1ib2wuZm9yKFwibm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b21cIildKCksXG4gICAgICAgIGluc2VjdXJlSFRUUFBhcnNlcjogcmVxdWVzdC5pbnNlY3VyZUhUVFBQYXJzZXIsXG4gICAgICAgIGFnZW50XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGFyc2VkVVJMLFxuICAgICAgICBvcHRpb25zXG4gICAgICB9O1xuICAgIH07XG4gICAgdmFyIEFib3J0RXJyb3IgPSBjbGFzcyBleHRlbmRzIEZldGNoQmFzZUVycm9yIHtcbiAgICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHR5cGUgPSBcImFib3J0ZWRcIikge1xuICAgICAgICBzdXBlcihtZXNzYWdlLCB0eXBlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGluaXRfZXNtX21pbigpO1xuICAgIGluaXRfZnJvbSgpO1xuICAgIHZhciBzdXBwb3J0ZWRTY2hlbWFzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiZGF0YTpcIiwgXCJodHRwOlwiLCBcImh0dHBzOlwiXSk7XG4gICAgYXN5bmMgZnVuY3Rpb24gZmV0Y2godXJsLCBvcHRpb25zXykge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHVybCwgb3B0aW9uc18pO1xuICAgICAgICBjb25zdCB7IHBhcnNlZFVSTCwgb3B0aW9ucyB9ID0gZ2V0Tm9kZVJlcXVlc3RPcHRpb25zKHJlcXVlc3QpO1xuICAgICAgICBpZiAoIXN1cHBvcnRlZFNjaGVtYXMuaGFzKHBhcnNlZFVSTC5wcm90b2NvbCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBub2RlLWZldGNoIGNhbm5vdCBsb2FkICR7dXJsfS4gVVJMIHNjaGVtZSBcIiR7cGFyc2VkVVJMLnByb3RvY29sLnJlcGxhY2UoLzokLywgXCJcIil9XCIgaXMgbm90IHN1cHBvcnRlZC5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyc2VkVVJMLnByb3RvY29sID09PSBcImRhdGE6XCIpIHtcbiAgICAgICAgICBjb25zdCBkYXRhID0gZGlzdF9kZWZhdWx0KHJlcXVlc3QudXJsKTtcbiAgICAgICAgICBjb25zdCByZXNwb25zZTIgPSBuZXcgUmVzcG9uc2UoZGF0YSwgeyBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IGRhdGEudHlwZUZ1bGwgfSB9KTtcbiAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlMik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlbmQgPSAocGFyc2VkVVJMLnByb3RvY29sID09PSBcImh0dHBzOlwiID8gaW1wb3J0X25vZGVfaHR0cHMuZGVmYXVsdCA6IGltcG9ydF9ub2RlX2h0dHAyLmRlZmF1bHQpLnJlcXVlc3Q7XG4gICAgICAgIGNvbnN0IHsgc2lnbmFsIH0gPSByZXF1ZXN0O1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBudWxsO1xuICAgICAgICBjb25zdCBhYm9ydCA9ICgpID0+IHtcbiAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBBYm9ydEVycm9yKFwiVGhlIG9wZXJhdGlvbiB3YXMgYWJvcnRlZC5cIik7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICBpZiAocmVxdWVzdC5ib2R5ICYmIHJlcXVlc3QuYm9keSBpbnN0YW5jZW9mIGltcG9ydF9ub2RlX3N0cmVhbTIuZGVmYXVsdC5SZWFkYWJsZSkge1xuICAgICAgICAgICAgcmVxdWVzdC5ib2R5LmRlc3Ryb3koZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXJlc3BvbnNlIHx8ICFyZXNwb25zZS5ib2R5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3BvbnNlLmJvZHkuZW1pdChcImVycm9yXCIsIGVycm9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHNpZ25hbCAmJiBzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFib3J0QW5kRmluYWxpemUgPSAoKSA9PiB7XG4gICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICBmaW5hbGl6ZSgpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXF1ZXN0XyA9IHNlbmQocGFyc2VkVVJMLnRvU3RyaW5nKCksIG9wdGlvbnMpO1xuICAgICAgICBpZiAoc2lnbmFsKSB7XG4gICAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBhYm9ydEFuZEZpbmFsaXplKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaW5hbGl6ZSA9ICgpID0+IHtcbiAgICAgICAgICByZXF1ZXN0Xy5hYm9ydCgpO1xuICAgICAgICAgIGlmIChzaWduYWwpIHtcbiAgICAgICAgICAgIHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgYWJvcnRBbmRGaW5hbGl6ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXF1ZXN0Xy5vbihcImVycm9yXCIsIChlcnJvcikgPT4ge1xuICAgICAgICAgIHJlamVjdChuZXcgRmV0Y2hFcnJvcihgcmVxdWVzdCB0byAke3JlcXVlc3QudXJsfSBmYWlsZWQsIHJlYXNvbjogJHtlcnJvci5tZXNzYWdlfWAsIFwic3lzdGVtXCIsIGVycm9yKSk7XG4gICAgICAgICAgZmluYWxpemUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZpeFJlc3BvbnNlQ2h1bmtlZFRyYW5zZmVyQmFkRW5kaW5nKHJlcXVlc3RfLCAoZXJyb3IpID0+IHtcbiAgICAgICAgICBpZiAocmVzcG9uc2UgJiYgcmVzcG9uc2UuYm9keSkge1xuICAgICAgICAgICAgcmVzcG9uc2UuYm9keS5kZXN0cm95KGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocHJvY2Vzcy52ZXJzaW9uIDwgXCJ2MTRcIikge1xuICAgICAgICAgIHJlcXVlc3RfLm9uKFwic29ja2V0XCIsIChzMikgPT4ge1xuICAgICAgICAgICAgbGV0IGVuZGVkV2l0aEV2ZW50c0NvdW50O1xuICAgICAgICAgICAgczIucHJlcGVuZExpc3RlbmVyKFwiZW5kXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgZW5kZWRXaXRoRXZlbnRzQ291bnQgPSBzMi5fZXZlbnRzQ291bnQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHMyLnByZXBlbmRMaXN0ZW5lcihcImNsb3NlXCIsIChoYWRFcnJvcikgPT4ge1xuICAgICAgICAgICAgICBpZiAocmVzcG9uc2UgJiYgZW5kZWRXaXRoRXZlbnRzQ291bnQgPCBzMi5fZXZlbnRzQ291bnQgJiYgIWhhZEVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXCJQcmVtYXR1cmUgY2xvc2VcIik7XG4gICAgICAgICAgICAgICAgZXJyb3IuY29kZSA9IFwiRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0VcIjtcbiAgICAgICAgICAgICAgICByZXNwb25zZS5ib2R5LmVtaXQoXCJlcnJvclwiLCBlcnJvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJlcXVlc3RfLm9uKFwicmVzcG9uc2VcIiwgKHJlc3BvbnNlXykgPT4ge1xuICAgICAgICAgIHJlcXVlc3RfLnNldFRpbWVvdXQoMCk7XG4gICAgICAgICAgY29uc3QgaGVhZGVycyA9IGZyb21SYXdIZWFkZXJzKHJlc3BvbnNlXy5yYXdIZWFkZXJzKTtcbiAgICAgICAgICBpZiAoaXNSZWRpcmVjdChyZXNwb25zZV8uc3RhdHVzQ29kZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0gaGVhZGVycy5nZXQoXCJMb2NhdGlvblwiKTtcbiAgICAgICAgICAgIGxldCBsb2NhdGlvblVSTCA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBsb2NhdGlvblVSTCA9IGxvY2F0aW9uID09PSBudWxsID8gbnVsbCA6IG5ldyBVUkwobG9jYXRpb24sIHJlcXVlc3QudXJsKTtcbiAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICBpZiAocmVxdWVzdC5yZWRpcmVjdCAhPT0gXCJtYW51YWxcIikge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRmV0Y2hFcnJvcihgdXJpIHJlcXVlc3RlZCByZXNwb25kcyB3aXRoIGFuIGludmFsaWQgcmVkaXJlY3QgVVJMOiAke2xvY2F0aW9ufWAsIFwiaW52YWxpZC1yZWRpcmVjdFwiKSk7XG4gICAgICAgICAgICAgICAgZmluYWxpemUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAocmVxdWVzdC5yZWRpcmVjdCkge1xuICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEZldGNoRXJyb3IoYHVyaSByZXF1ZXN0ZWQgcmVzcG9uZHMgd2l0aCBhIHJlZGlyZWN0LCByZWRpcmVjdCBtb2RlIGlzIHNldCB0byBlcnJvcjogJHtyZXF1ZXN0LnVybH1gLCBcIm5vLXJlZGlyZWN0XCIpKTtcbiAgICAgICAgICAgICAgICBmaW5hbGl6ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgY2FzZSBcIm1hbnVhbFwiOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiZm9sbG93XCI6IHtcbiAgICAgICAgICAgICAgICBpZiAobG9jYXRpb25VUkwgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC5jb3VudGVyID49IHJlcXVlc3QuZm9sbG93KSB7XG4gICAgICAgICAgICAgICAgICByZWplY3QobmV3IEZldGNoRXJyb3IoYG1heGltdW0gcmVkaXJlY3QgcmVhY2hlZCBhdDogJHtyZXF1ZXN0LnVybH1gLCBcIm1heC1yZWRpcmVjdFwiKSk7XG4gICAgICAgICAgICAgICAgICBmaW5hbGl6ZSgpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0T3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKHJlcXVlc3QuaGVhZGVycyksXG4gICAgICAgICAgICAgICAgICBmb2xsb3c6IHJlcXVlc3QuZm9sbG93LFxuICAgICAgICAgICAgICAgICAgY291bnRlcjogcmVxdWVzdC5jb3VudGVyICsgMSxcbiAgICAgICAgICAgICAgICAgIGFnZW50OiByZXF1ZXN0LmFnZW50LFxuICAgICAgICAgICAgICAgICAgY29tcHJlc3M6IHJlcXVlc3QuY29tcHJlc3MsXG4gICAgICAgICAgICAgICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgICAgICAgICAgICAgYm9keTogY2xvbmUocmVxdWVzdCksXG4gICAgICAgICAgICAgICAgICBzaWduYWw6IHJlcXVlc3Quc2lnbmFsLFxuICAgICAgICAgICAgICAgICAgc2l6ZTogcmVxdWVzdC5zaXplLFxuICAgICAgICAgICAgICAgICAgcmVmZXJyZXI6IHJlcXVlc3QucmVmZXJyZXIsXG4gICAgICAgICAgICAgICAgICByZWZlcnJlclBvbGljeTogcmVxdWVzdC5yZWZlcnJlclBvbGljeVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKCFpc0RvbWFpbk9yU3ViZG9tYWluKHJlcXVlc3QudXJsLCBsb2NhdGlvblVSTCkgfHwgIWlzU2FtZVByb3RvY29sKHJlcXVlc3QudXJsLCBsb2NhdGlvblVSTCkpIHtcbiAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBbXCJhdXRob3JpemF0aW9uXCIsIFwid3d3LWF1dGhlbnRpY2F0ZVwiLCBcImNvb2tpZVwiLCBcImNvb2tpZTJcIl0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdE9wdGlvbnMuaGVhZGVycy5kZWxldGUobmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZV8uc3RhdHVzQ29kZSAhPT0gMzAzICYmIHJlcXVlc3QuYm9keSAmJiBvcHRpb25zXy5ib2R5IGluc3RhbmNlb2YgaW1wb3J0X25vZGVfc3RyZWFtMi5kZWZhdWx0LlJlYWRhYmxlKSB7XG4gICAgICAgICAgICAgICAgICByZWplY3QobmV3IEZldGNoRXJyb3IoXCJDYW5ub3QgZm9sbG93IHJlZGlyZWN0IHdpdGggYm9keSBiZWluZyBhIHJlYWRhYmxlIHN0cmVhbVwiLCBcInVuc3VwcG9ydGVkLXJlZGlyZWN0XCIpKTtcbiAgICAgICAgICAgICAgICAgIGZpbmFsaXplKCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZV8uc3RhdHVzQ29kZSA9PT0gMzAzIHx8IChyZXNwb25zZV8uc3RhdHVzQ29kZSA9PT0gMzAxIHx8IHJlc3BvbnNlXy5zdGF0dXNDb2RlID09PSAzMDIpICYmIHJlcXVlc3QubWV0aG9kID09PSBcIlBPU1RcIikge1xuICAgICAgICAgICAgICAgICAgcmVxdWVzdE9wdGlvbnMubWV0aG9kID0gXCJHRVRcIjtcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3RPcHRpb25zLmJvZHkgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICByZXF1ZXN0T3B0aW9ucy5oZWFkZXJzLmRlbGV0ZShcImNvbnRlbnQtbGVuZ3RoXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZVJlZmVycmVyUG9saWN5ID0gcGFyc2VSZWZlcnJlclBvbGljeUZyb21IZWFkZXIoaGVhZGVycyk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlUmVmZXJyZXJQb2xpY3kpIHtcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3RPcHRpb25zLnJlZmVycmVyUG9saWN5ID0gcmVzcG9uc2VSZWZlcnJlclBvbGljeTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShmZXRjaChuZXcgUmVxdWVzdChsb2NhdGlvblVSTCwgcmVxdWVzdE9wdGlvbnMpKSk7XG4gICAgICAgICAgICAgICAgZmluYWxpemUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBUeXBlRXJyb3IoYFJlZGlyZWN0IG9wdGlvbiAnJHtyZXF1ZXN0LnJlZGlyZWN0fScgaXMgbm90IGEgdmFsaWQgdmFsdWUgb2YgUmVxdWVzdFJlZGlyZWN0YCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2lnbmFsKSB7XG4gICAgICAgICAgICByZXNwb25zZV8ub25jZShcImVuZFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgIHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgYWJvcnRBbmRGaW5hbGl6ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGJvZHkgPSAoMCwgaW1wb3J0X25vZGVfc3RyZWFtMi5waXBlbGluZSkocmVzcG9uc2VfLCBuZXcgaW1wb3J0X25vZGVfc3RyZWFtMi5QYXNzVGhyb3VnaCgpLCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChwcm9jZXNzLnZlcnNpb24gPCBcInYxMi4xMFwiKSB7XG4gICAgICAgICAgICByZXNwb25zZV8ub24oXCJhYm9ydGVkXCIsIGFib3J0QW5kRmluYWxpemUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCByZXNwb25zZU9wdGlvbnMgPSB7XG4gICAgICAgICAgICB1cmw6IHJlcXVlc3QudXJsLFxuICAgICAgICAgICAgc3RhdHVzOiByZXNwb25zZV8uc3RhdHVzQ29kZSxcbiAgICAgICAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlXy5zdGF0dXNNZXNzYWdlLFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgIHNpemU6IHJlcXVlc3Quc2l6ZSxcbiAgICAgICAgICAgIGNvdW50ZXI6IHJlcXVlc3QuY291bnRlcixcbiAgICAgICAgICAgIGhpZ2hXYXRlck1hcms6IHJlcXVlc3QuaGlnaFdhdGVyTWFya1xuICAgICAgICAgIH07XG4gICAgICAgICAgY29uc3QgY29kaW5ncyA9IGhlYWRlcnMuZ2V0KFwiQ29udGVudC1FbmNvZGluZ1wiKTtcbiAgICAgICAgICBpZiAoIXJlcXVlc3QuY29tcHJlc3MgfHwgcmVxdWVzdC5tZXRob2QgPT09IFwiSEVBRFwiIHx8IGNvZGluZ3MgPT09IG51bGwgfHwgcmVzcG9uc2VfLnN0YXR1c0NvZGUgPT09IDIwNCB8fCByZXNwb25zZV8uc3RhdHVzQ29kZSA9PT0gMzA0KSB7XG4gICAgICAgICAgICByZXNwb25zZSA9IG5ldyBSZXNwb25zZShib2R5LCByZXNwb25zZU9wdGlvbnMpO1xuICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHpsaWJPcHRpb25zID0ge1xuICAgICAgICAgICAgZmx1c2g6IGltcG9ydF9ub2RlX3psaWIuZGVmYXVsdC5aX1NZTkNfRkxVU0gsXG4gICAgICAgICAgICBmaW5pc2hGbHVzaDogaW1wb3J0X25vZGVfemxpYi5kZWZhdWx0LlpfU1lOQ19GTFVTSFxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKGNvZGluZ3MgPT09IFwiZ3ppcFwiIHx8IGNvZGluZ3MgPT09IFwieC1nemlwXCIpIHtcbiAgICAgICAgICAgIGJvZHkgPSAoMCwgaW1wb3J0X25vZGVfc3RyZWFtMi5waXBlbGluZSkoYm9keSwgaW1wb3J0X25vZGVfemxpYi5kZWZhdWx0LmNyZWF0ZUd1bnppcCh6bGliT3B0aW9ucyksIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKGJvZHksIHJlc3BvbnNlT3B0aW9ucyk7XG4gICAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvZGluZ3MgPT09IFwiZGVmbGF0ZVwiIHx8IGNvZGluZ3MgPT09IFwieC1kZWZsYXRlXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHJhdyA9ICgwLCBpbXBvcnRfbm9kZV9zdHJlYW0yLnBpcGVsaW5lKShyZXNwb25zZV8sIG5ldyBpbXBvcnRfbm9kZV9zdHJlYW0yLlBhc3NUaHJvdWdoKCksIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJhdy5vbmNlKFwiZGF0YVwiLCAoY2h1bmspID0+IHtcbiAgICAgICAgICAgICAgaWYgKChjaHVua1swXSAmIDE1KSA9PT0gOCkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSAoMCwgaW1wb3J0X25vZGVfc3RyZWFtMi5waXBlbGluZSkoYm9keSwgaW1wb3J0X25vZGVfemxpYi5kZWZhdWx0LmNyZWF0ZUluZmxhdGUoKSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gKDAsIGltcG9ydF9ub2RlX3N0cmVhbTIucGlwZWxpbmUpKGJvZHksIGltcG9ydF9ub2RlX3psaWIuZGVmYXVsdC5jcmVhdGVJbmZsYXRlUmF3KCksIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UoYm9keSwgcmVzcG9uc2VPcHRpb25zKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJhdy5vbmNlKFwiZW5kXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKGJvZHksIHJlc3BvbnNlT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29kaW5ncyA9PT0gXCJiclwiKSB7XG4gICAgICAgICAgICBib2R5ID0gKDAsIGltcG9ydF9ub2RlX3N0cmVhbTIucGlwZWxpbmUpKGJvZHksIGltcG9ydF9ub2RlX3psaWIuZGVmYXVsdC5jcmVhdGVCcm90bGlEZWNvbXByZXNzKCksIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKGJvZHksIHJlc3BvbnNlT3B0aW9ucyk7XG4gICAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UoYm9keSwgcmVzcG9uc2VPcHRpb25zKTtcbiAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHdyaXRlVG9TdHJlYW0ocmVxdWVzdF8sIHJlcXVlc3QpLmNhdGNoKHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZml4UmVzcG9uc2VDaHVua2VkVHJhbnNmZXJCYWRFbmRpbmcocmVxdWVzdCwgZXJyb3JDYWxsYmFjaykge1xuICAgICAgY29uc3QgTEFTVF9DSFVOSyA9IGltcG9ydF9ub2RlX2J1ZmZlcjIuQnVmZmVyLmZyb20oXCIwXFxyXFxuXFxyXFxuXCIpO1xuICAgICAgbGV0IGlzQ2h1bmtlZFRyYW5zZmVyID0gZmFsc2U7XG4gICAgICBsZXQgcHJvcGVyTGFzdENodW5rUmVjZWl2ZWQgPSBmYWxzZTtcbiAgICAgIGxldCBwcmV2aW91c0NodW5rO1xuICAgICAgcmVxdWVzdC5vbihcInJlc3BvbnNlXCIsIChyZXNwb25zZSkgPT4ge1xuICAgICAgICBjb25zdCB7IGhlYWRlcnMgfSA9IHJlc3BvbnNlO1xuICAgICAgICBpc0NodW5rZWRUcmFuc2ZlciA9IGhlYWRlcnNbXCJ0cmFuc2Zlci1lbmNvZGluZ1wiXSA9PT0gXCJjaHVua2VkXCIgJiYgIWhlYWRlcnNbXCJjb250ZW50LWxlbmd0aFwiXTtcbiAgICAgIH0pO1xuICAgICAgcmVxdWVzdC5vbihcInNvY2tldFwiLCAoc29ja2V0KSA9PiB7XG4gICAgICAgIGNvbnN0IG9uU29ja2V0Q2xvc2UgPSAoKSA9PiB7XG4gICAgICAgICAgaWYgKGlzQ2h1bmtlZFRyYW5zZmVyICYmICFwcm9wZXJMYXN0Q2h1bmtSZWNlaXZlZCkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXCJQcmVtYXR1cmUgY2xvc2VcIik7XG4gICAgICAgICAgICBlcnJvci5jb2RlID0gXCJFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRVwiO1xuICAgICAgICAgICAgZXJyb3JDYWxsYmFjayhlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvbkRhdGEgPSAoYnVmKSA9PiB7XG4gICAgICAgICAgcHJvcGVyTGFzdENodW5rUmVjZWl2ZWQgPSBpbXBvcnRfbm9kZV9idWZmZXIyLkJ1ZmZlci5jb21wYXJlKGJ1Zi5zbGljZSgtNSksIExBU1RfQ0hVTkspID09PSAwO1xuICAgICAgICAgIGlmICghcHJvcGVyTGFzdENodW5rUmVjZWl2ZWQgJiYgcHJldmlvdXNDaHVuaykge1xuICAgICAgICAgICAgaWYgKGJ1Zi5sZW5ndGggPCA1KSB7XG4gICAgICAgICAgICAgIHByb3Blckxhc3RDaHVua1JlY2VpdmVkID0gaW1wb3J0X25vZGVfYnVmZmVyMi5CdWZmZXIuY29tcGFyZShcbiAgICAgICAgICAgICAgICBpbXBvcnRfbm9kZV9idWZmZXIyLkJ1ZmZlci5mcm9tKFsuLi5wcmV2aW91c0NodW5rLnNsaWNlKC01KSwgLi4uYnVmXSkuc2xpY2UoLTUpLFxuICAgICAgICAgICAgICAgIExBU1RfQ0hVTktcbiAgICAgICAgICAgICAgKSA9PT0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcHJldmlvdXNDaHVuayA9IGJ1ZjtcbiAgICAgICAgfTtcbiAgICAgICAgc29ja2V0LnByZXBlbmRMaXN0ZW5lcihcImNsb3NlXCIsIG9uU29ja2V0Q2xvc2UpO1xuICAgICAgICBzb2NrZXQub24oXCJkYXRhXCIsIG9uRGF0YSk7XG4gICAgICAgIHJlcXVlc3Qub24oXCJjbG9zZVwiLCAoKSA9PiB7XG4gICAgICAgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKFwiY2xvc2VcIiwgb25Tb2NrZXRDbG9zZSk7XG4gICAgICAgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKFwiZGF0YVwiLCBvbkRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpbml0X2ZldGNoX2Jsb2IoKTtcbiAgICBpbml0X2VzbV9taW4oKTtcbiAgfVxufSk7XG5cbi8vIHNlcnZlci5qc1xuZnVuY3Rpb24gcihtKSB7XG4gIHJldHVybiBtICYmIG0uZGVmYXVsdCB8fCBtO1xufVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih1cmwsIG9wdHMpIHtcbiAgcmV0dXJuIHIocmVxdWlyZV9kaXN0KCkpKFN0cmluZyh1cmwpLnJlcGxhY2UoL15cXC9cXC8vZywgXCJodHRwczovL1wiKSwgb3B0cyk7XG59O1xuLyohIEJ1bmRsZWQgbGljZW5zZSBpbmZvcm1hdGlvbjpcblxubm9kZS1mZXRjaC1janMvZGlzdC9pbmRleC5qczpcbiAgKCohIGZldGNoLWJsb2IuIE1JVCBMaWNlbnNlLiBKaW1teSBXw6RydGluZyA8aHR0cHM6Ly9qaW1teS53YXJ0aW5nLnNlL29wZW5zb3VyY2U+ICopXG4gICgqISBmb3JtZGF0YS1wb2x5ZmlsbC4gTUlUIExpY2Vuc2UuIEppbW15IFfDpHJ0aW5nIDxodHRwczovL2ppbW15LndhcnRpbmcuc2Uvb3BlbnNvdXJjZT4gKilcbiAgKCohIG5vZGUtZG9tZXhjZXB0aW9uLiBNSVQgTGljZW5zZS4gSmltbXkgV8OkcnRpbmcgPGh0dHBzOi8vamltbXkud2FydGluZy5zZS9vcGVuc291cmNlPiAqKVxuKi9cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@plasmicapp/isomorphic-unfetch/dist/server.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@plasmicapp/isomorphic-unfetch/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@plasmicapp/isomorphic-unfetch/index.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("function r(m){return m && m.default || m;}\nmodule.exports = (typeof process == 'undefined'\n\t\t? global.fetch || r(__webpack_require__(/*! unfetch */ \"(ssr)/./node_modules/unfetch/dist/unfetch.module.js\"))\n\t\t: r(__webpack_require__(/*! ./dist/server */ \"(ssr)/./node_modules/@plasmicapp/isomorphic-unfetch/dist/server.js\"))\n);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBsYXNtaWNhcHAvaXNvbW9ycGhpYy11bmZldGNoL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLGNBQWM7QUFDZDtBQUNBLHNCQUFzQixtQkFBTyxDQUFDLG9FQUFTO0FBQ3ZDLE1BQU0sbUJBQU8sQ0FBQyx5RkFBZTtBQUM3QiIsInNvdXJjZXMiOlsiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvV29uZGVyVml0ZS1mcm9udGVuZC9ub2RlX21vZHVsZXMvQHBsYXNtaWNhcHAvaXNvbW9ycGhpYy11bmZldGNoL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIHIobSl7cmV0dXJuIG0gJiYgbS5kZWZhdWx0IHx8IG07fVxubW9kdWxlLmV4cG9ydHMgPSAodHlwZW9mIHByb2Nlc3MgPT0gJ3VuZGVmaW5lZCdcblx0XHQ/IGdsb2JhbC5mZXRjaCB8fCByKHJlcXVpcmUoJ3VuZmV0Y2gnKSlcblx0XHQ6IHIocmVxdWlyZSgnLi9kaXN0L3NlcnZlcicpKVxuKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@plasmicapp/isomorphic-unfetch/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@plasmicapp/loader-core/dist/index.esm.js":
/*!****************************************************************!*\
  !*** ./node_modules/@plasmicapp/loader-core/dist/index.esm.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Api: () => (/* reexport safe */ _plasmicapp_loader_fetcher__WEBPACK_IMPORTED_MODULE_0__.Api),\n/* harmony export */   PlasmicModulesFetcher: () => (/* reexport safe */ _plasmicapp_loader_fetcher__WEBPACK_IMPORTED_MODULE_0__.PlasmicModulesFetcher),\n/* harmony export */   PlasmicTracker: () => (/* binding */ PlasmicTracker),\n/* harmony export */   Registry: () => (/* binding */ Registry),\n/* harmony export */   getBundleSubset: () => (/* binding */ getBundleSubset)\n/* harmony export */ });\n/* harmony import */ var _plasmicapp_loader_fetcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @plasmicapp/loader-fetcher */ \"(ssr)/./node_modules/@plasmicapp/loader-fetcher/dist/index.esm.js\");\n/* harmony import */ var _plasmicapp_isomorphic_unfetch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @plasmicapp/isomorphic-unfetch */ \"(ssr)/./node_modules/@plasmicapp/isomorphic-unfetch/index.js\");\n/* harmony import */ var _plasmicapp_isomorphic_unfetch__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_plasmicapp_isomorphic_unfetch__WEBPACK_IMPORTED_MODULE_1__);\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// src/index.ts\n\n\n// src/deps-graph.ts\nvar DepsGraph = class {\n  constructor(bundle, browserBuild) {\n    this.bundle = bundle;\n    this.browserBuild = browserBuild;\n    this.dependsOn = {};\n    this.dependedBy = {};\n    this.rebuildGraph();\n  }\n  getTransitiveDependers(name2) {\n    return this.transitiveCrawl(name2, this.dependedBy);\n  }\n  getTransitiveDeps(name2) {\n    if (!(name2 in this.dependsOn)) {\n      return [];\n    }\n    return this.transitiveCrawl(name2, this.dependsOn);\n  }\n  transitiveCrawl(name2, edges) {\n    const deps = /* @__PURE__ */ new Set();\n    const crawl = (dep2) => {\n      var _a;\n      if (deps.has(dep2)) {\n        return;\n      }\n      deps.add(dep2);\n      for (const subdep of (_a = edges[dep2]) != null ? _a : []) {\n        crawl(subdep);\n      }\n    };\n    for (const dep2 of edges[name2]) {\n      crawl(dep2);\n    }\n    return Array.from(deps);\n  }\n  rebuildGraph() {\n    this.dependedBy = {};\n    this.dependsOn = {};\n    for (const mod of this.browserBuild ? this.bundle.modules.browser : this.bundle.modules.server) {\n      if (mod.type === \"code\") {\n        for (const imported of mod.imports) {\n          if (!(mod.fileName in this.dependsOn)) {\n            this.dependsOn[mod.fileName] = [imported];\n          } else {\n            this.dependsOn[mod.fileName].push(imported);\n          }\n          if (!(imported in this.dependedBy)) {\n            this.dependedBy[imported] = [mod.fileName];\n          } else {\n            this.dependedBy[imported].push(mod.fileName);\n          }\n        }\n      }\n    }\n  }\n};\n\n// src/bundles.ts\nfunction getBundleSubset(bundle, names, opts2) {\n  var _a, _b;\n  const namesSet = new Set(names);\n  const target = (_a = opts2 == null ? void 0 : opts2.target) != null ? _a : \"browser\";\n  const forBrowser = target === \"browser\";\n  const graph = new DepsGraph(bundle, forBrowser);\n  const deps = new Set(names.flatMap((name2) => graph.getTransitiveDeps(name2)));\n  const isSubModule = (fileName) => deps.has(fileName) || namesSet.has(fileName);\n  const modules = bundle.modules[target];\n  const filteredModules = modules.filter((mod) => isSubModule(mod.fileName));\n  const filteredComponents = bundle.components.filter(\n    (c) => isSubModule(c.entry)\n  );\n  const filteredComponentsIds = new Set(filteredComponents.map((c) => c.id));\n  const filteredIds = Object.fromEntries(\n    Object.entries(bundle.filteredIds).map(([k, v]) => [k, [...v]])\n  );\n  bundle.components.filter((c) => !filteredComponentsIds.has(c.id)).forEach((component) => {\n    var _a2;\n    filteredIds[component.projectId] = (_a2 = filteredIds[component.projectId]) != null ? _a2 : [];\n    if (!filteredIds[component.projectId].includes(component.id)) {\n      filteredIds[component.projectId].push(component.id);\n    }\n  });\n  return {\n    modules: {\n      browser: forBrowser ? filteredModules : [],\n      server: forBrowser ? [] : filteredModules\n    },\n    components: filteredComponents,\n    globalGroups: bundle.globalGroups,\n    projects: bundle.projects,\n    activeSplits: bundle.activeSplits,\n    bundleKey: (_b = bundle.bundleKey) != null ? _b : null,\n    deferChunksByDefault: bundle.deferChunksByDefault,\n    disableRootLoadingBoundaryByDefault: bundle.disableRootLoadingBoundaryByDefault,\n    filteredIds\n  };\n}\n\n// src/registry.ts\nvar isBrowser = typeof window !== \"undefined\" && window != null && typeof window.document !== \"undefined\";\nfunction isModuleBundlePromiseSet(name2) {\n  return globalThis.__PlasmicBundlePromises && !!globalThis.__PlasmicBundlePromises[name2] && !!globalThis.__PlasmicBundlePromises[name2].then;\n}\nvar Registry = class {\n  constructor() {\n    this.loadedModules = {};\n    this.registeredModules = {};\n    this.modules = {};\n  }\n  register(name2, module) {\n    this.registeredModules[name2] = module;\n  }\n  isEmpty() {\n    return Object.keys(this.loadedModules).length === 0;\n  }\n  clear() {\n    this.loadedModules = {};\n  }\n  getRegisteredModule(name2) {\n    return this.registeredModules[name2];\n  }\n  hasModule(name2, opts2 = {}) {\n    if (name2 in this.registeredModules && !opts2.forceOriginal) {\n      return true;\n    }\n    if (name2 in this.modules) {\n      return true;\n    }\n    if (globalThis.__PLASMIC_CHUNKS && !!globalThis.__PLASMIC_CHUNKS[name2]) {\n      return true;\n    }\n    if (isModuleBundlePromiseSet(name2)) {\n      return true;\n    }\n    return false;\n  }\n  load(name, opts = {}) {\n    if (name in this.registeredModules && !opts.forceOriginal) {\n      return this.registeredModules[name];\n    }\n    if (name in this.loadedModules) {\n      return this.loadedModules[name];\n    }\n    if (!this.modules[name] && globalThis.__PLASMIC_CHUNKS && !!globalThis.__PLASMIC_CHUNKS[name]) {\n      this.modules[name] = globalThis.__PLASMIC_CHUNKS[name];\n    }\n    if (!this.modules[name] && isModuleBundlePromiseSet(name)) {\n      throw globalThis.__PlasmicBundlePromises[name];\n    }\n    if (!(name in this.modules)) {\n      throw new Error(`Unknown module ${name}`);\n    }\n    const code = this.modules[name];\n    const requireFn = isBrowser ? (dep2) => {\n      const normalizedDep = resolvePath(dep2, name);\n      return this.load(normalizedDep);\n    } : (dep) => {\n      try {\n        const normalizedDep = resolvePath(dep, name);\n        return this.load(normalizedDep);\n      } catch (err) {\n        try {\n          return eval(\"require\")(dep);\n        } catch (e) {\n          throw err;\n        }\n      }\n    };\n    let func;\n    try {\n      func = new Function(\"require\", \"exports\", code);\n    } catch (err2) {\n      throw new Error(`PLASMIC: Failed to create function for ${name}: ${err2}`);\n    }\n    const exports = {};\n    this.loadedModules[name] = exports;\n    try {\n      func(requireFn, exports);\n    } catch (err2) {\n      delete this.loadedModules[name];\n      if (!(err2 instanceof Error) && !!err2 && !!err2.then) {\n        throw err2;\n      }\n      throw new Error(`PLASMIC: Failed to load ${name}: ${err2}`);\n    }\n    return exports;\n  }\n  updateModules(bundle) {\n    let updated = false;\n    for (const mod of isBrowser ? bundle.modules.browser : bundle.modules.server) {\n      if (mod.type === \"code\" && !!mod.code && mod.code !== this.modules[mod.fileName]) {\n        this.modules[mod.fileName] = mod.code;\n        if (!globalThis.__PLASMIC_CHUNKS) {\n          globalThis.__PLASMIC_CHUNKS = {};\n        }\n        globalThis.__PLASMIC_CHUNKS[mod.fileName] = mod.code;\n        updated = true;\n      }\n    }\n    if (updated) {\n      this.clear();\n    }\n  }\n};\nfunction resolvePath(path, from) {\n  const fromParts = from.split(\"/\");\n  const pathParts = path.split(\"/\");\n  if (pathParts.length === 0) {\n    return path;\n  }\n  if (pathParts[0] === \".\") {\n    return [\n      ...fromParts.slice(0, fromParts.length - 1),\n      ...pathParts.slice(1)\n    ].join(\"/\");\n  } else if (pathParts[0] === \"..\") {\n    let count = 0;\n    for (const part of pathParts) {\n      if (part === \"..\") {\n        count += 1;\n      } else {\n        break;\n      }\n    }\n    return [\n      ...fromParts.slice(0, fromParts.length - count - 1),\n      ...pathParts.slice(count)\n    ].join(\"/\");\n  } else {\n    return path;\n  }\n}\n\n// src/tracker/index.ts\n\n\n// src/tracker/utils.ts\nvar isBrowser2 = typeof window !== \"undefined\" && window != null && typeof window.document !== \"undefined\";\nfunction getPlasmicCookieValues() {\n  if (!isBrowser2) {\n    return {};\n  }\n  return Object.fromEntries(\n    document.cookie.split(\"; \").filter((cookie) => cookie.includes(\"plasmic:\")).map((cookie) => cookie.split(\"=\")).map(([key, value]) => [key.split(\":\")[1], value])\n  );\n}\nfunction getVariationCookieValues() {\n  const cookies = getPlasmicCookieValues();\n  return Object.fromEntries(\n    Object.keys(cookies).map((key) => [key.split(\".\")[1], cookies[key]]).filter((val) => !!val[0])\n  );\n}\nfunction getDistinctId() {\n  if (!isBrowser2) {\n    return \"LOADER-SERVER\";\n  }\n  return \"LOADER-CLIENT\";\n}\nfunction getCampaignParams() {\n  const { location } = window;\n  const params = {};\n  try {\n    const url = new URL(location.href);\n    const CAMPAIGN_KEYWORDS = [\n      \"utm_source\",\n      \"utm_medium\",\n      \"utm_campaign\",\n      \"utm_content\",\n      \"utm_term\",\n      \"gclid\"\n    ];\n    CAMPAIGN_KEYWORDS.forEach((keyword) => {\n      const value = url.searchParams.get(keyword);\n      if (value) {\n        params[keyword] = value;\n      }\n    });\n  } catch (err2) {\n  }\n  return params;\n}\nfunction getLocationMeta() {\n  const { location } = window;\n  const { referrer } = document;\n  return __spreadValues({\n    url: location.href,\n    host: location.host,\n    pathname: location.pathname,\n    referrer\n  }, getCampaignParams());\n}\nfunction getScreenMeta() {\n  const { screen } = window;\n  return {\n    screen_height: screen.height,\n    screen_width: screen.width,\n    viewport_height: window.innerHeight,\n    viewport_width: window.innerWidth\n  };\n}\nfunction getOS(userAgent) {\n  if (/Windows/i.test(userAgent)) {\n    if (/Phone/.test(userAgent) || /WPDesktop/.test(userAgent)) {\n      return \"Windows Phone\";\n    }\n    return \"Windows\";\n  } else if (/(iPhone|iPad|iPod)/.test(userAgent)) {\n    return \"iOS\";\n  } else if (/Android/.test(userAgent)) {\n    return \"Android\";\n  } else if (/(BlackBerry|PlayBook|BB10)/i.test(userAgent)) {\n    return \"BlackBerry\";\n  } else if (/Mac/i.test(userAgent)) {\n    return \"Mac OS X\";\n  } else if (/Linux/.test(userAgent)) {\n    return \"Linux\";\n  } else if (/CrOS/.test(userAgent)) {\n    return \"Chrome OS\";\n  } else {\n    return \"\";\n  }\n}\nfunction getDeviceInfo(userAgent) {\n  const PATTERNS = [\n    {\n      device: \"iPhone\",\n      patterns: [/iPhone/]\n    },\n    {\n      device: \"iPad\",\n      patterns: [/iPad/]\n    },\n    {\n      device: \"iPod Touch\",\n      patterns: [/iPod/]\n    },\n    {\n      device: \"Windows Phone\",\n      patterns: [/Windows Phone/i, /WPDesktop/]\n    },\n    {\n      device: \"Android\",\n      patterns: [/Android/]\n    }\n  ];\n  const match = PATTERNS.find(\n    (pattern) => pattern.patterns.some((expr) => expr.test(userAgent))\n  );\n  const device = match == null ? void 0 : match.device;\n  return {\n    device: device != null ? device : \"\",\n    deviceType: device ? \"Mobile\" : \"Desktop\",\n    os: getOS(userAgent)\n  };\n}\nfunction getUserAgentMeta() {\n  const { navigator } = window;\n  const { userAgent } = navigator;\n  return __spreadValues({}, getDeviceInfo(userAgent));\n}\nfunction getWindowMeta() {\n  if (!isBrowser2) {\n    return {};\n  }\n  return __spreadValues(__spreadValues(__spreadValues({}, getLocationMeta()), getScreenMeta()), getUserAgentMeta());\n}\nvar isProduction = \"development\" === \"production\";\nfunction getEnvMeta() {\n  return {\n    isBrowser: isBrowser2,\n    isProduction\n  };\n}\nfunction rawSplitVariation(variation) {\n  const rawVariations = {};\n  Object.keys(variation).forEach((variationKey) => {\n    const [, splitId] = variationKey.split(\".\");\n    if (splitId) {\n      rawVariations[splitId] = variation[variationKey];\n    }\n  });\n  return rawVariations;\n}\nvar POLL_TIME = 5e3;\nfunction throttled(func2) {\n  let timerId = void 0;\n  return (param) => {\n    if (timerId) {\n      return;\n    }\n    if (isBrowser2) {\n      timerId = window.requestAnimationFrame(() => {\n        timerId = void 0;\n        func2(param);\n      });\n    } else {\n      timerId = setTimeout(() => {\n        timerId = void 0;\n        func2(param);\n      }, POLL_TIME);\n    }\n  };\n}\n\n// src/tracker/index.ts\nvar API_ENDPOINT = \"https://analytics.plasmic.app/capture\";\nvar API_PUBLIC_KEY = \"phc_BRvYTAoMoam9fDHfrIneF67KdtMJagLVVCM6ELNYd4n\";\nvar TRACKER_VERSION = 4;\nvar PlasmicTracker = class {\n  constructor(opts2) {\n    this.opts = opts2;\n    this.eventQueue = [];\n    this.sendEvents = throttled((transport) => __async(this, null, function* () {\n      if (this.eventQueue.length === 0) {\n        return;\n      }\n      const events = [...this.eventQueue];\n      this.eventQueue.length = 0;\n      const body = {\n        api_key: API_PUBLIC_KEY,\n        batch: events\n      };\n      try {\n        const stringBody = JSON.stringify(body);\n        if (transport === \"beacon\") {\n          window.navigator.sendBeacon(API_ENDPOINT, stringBody);\n        } else {\n          this.fetch(API_ENDPOINT, {\n            method: \"POST\",\n            headers: {\n              Accept: \"application/json\"\n            },\n            body: stringBody\n          }).then(() => {\n          }).catch(() => {\n          });\n        }\n      } catch (err2) {\n      }\n    }));\n    this.fetch = (opts2.nativeFetch && globalThis.fetch ? globalThis.fetch : (_plasmicapp_isomorphic_unfetch__WEBPACK_IMPORTED_MODULE_1___default())).bind(globalThis);\n  }\n  trackRender(opts2) {\n    var _a, _b;\n    this.enqueue({\n      event: \"$render\",\n      properties: __spreadValues(__spreadValues(__spreadValues({}, this.getProperties()), (_a = opts2 == null ? void 0 : opts2.renderCtx) != null ? _a : {}), rawSplitVariation((_b = opts2 == null ? void 0 : opts2.variation) != null ? _b : {}))\n    });\n  }\n  trackFetch() {\n    this.enqueue({\n      event: \"$fetch\",\n      properties: this.getProperties()\n    });\n  }\n  trackConversion(value = 0) {\n    this.enqueue({\n      event: \"$conversion\",\n      properties: __spreadProps(__spreadValues({}, this.getProperties()), {\n        value\n      })\n    });\n  }\n  getProperties() {\n    var _a;\n    return __spreadProps(__spreadValues(__spreadValues(__spreadValues(__spreadValues({\n      distinct_id: getDistinctId()\n    }, getWindowMeta()), getEnvMeta()), this.getContextMeta()), getVariationCookieValues()), {\n      timestamp: (_a = Date.now()) != null ? _a : +/* @__PURE__ */ new Date(),\n      trackerVersion: TRACKER_VERSION\n    });\n  }\n  enqueue(event) {\n    if (this.opts.__plasmicTrackerDisabled) {\n      return;\n    }\n    this.eventQueue.push(event);\n    this.sendEvents(\"fetch\");\n  }\n  getContextMeta() {\n    return {\n      platform: this.opts.platform,\n      preview: this.opts.preview,\n      projectIds: this.opts.projectIds\n    };\n  }\n};\n\n//# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBsYXNtaWNhcHAvbG9hZGVyLWNvcmUvZGlzdC9pbmRleC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUN3RTs7QUFFeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1gsV0FBVztBQUNYLFdBQVc7QUFDWDtBQUNBLFFBQVE7QUFDUjtBQUNBLEtBQUs7QUFDTCw2RUFBNkUsdUVBQU87QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSwwRkFBMEYsc0ZBQXNGO0FBQ2pQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvd29uZGVybGFuZG1pdGNoL0Nhc2NhZGVQcm9qZWN0cy9Xb25kZXJWaXRlLWZyb250ZW5kL25vZGVfbW9kdWxlcy9AcGxhc21pY2FwcC9sb2FkZXItY29yZS9kaXN0L2luZGV4LmVzbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbnZhciBfX2dldE93blByb3BEZXNjcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG52YXIgX19zcHJlYWRQcm9wcyA9IChhLCBiKSA9PiBfX2RlZlByb3BzKGEsIF9fZ2V0T3duUHJvcERlc2NzKGIpKTtcbnZhciBfX2FzeW5jID0gKF9fdGhpcywgX19hcmd1bWVudHMsIGdlbmVyYXRvcikgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHZhciBmdWxmaWxsZWQgPSAodmFsdWUpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHJlamVjdGVkID0gKHZhbHVlKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvci50aHJvdyh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgc3RlcCA9ICh4KSA9PiB4LmRvbmUgPyByZXNvbHZlKHgudmFsdWUpIDogUHJvbWlzZS5yZXNvbHZlKHgudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7XG4gICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KF9fdGhpcywgX19hcmd1bWVudHMpKS5uZXh0KCkpO1xuICB9KTtcbn07XG5cbi8vIHNyYy9pbmRleC50c1xuaW1wb3J0IHsgQXBpLCBQbGFzbWljTW9kdWxlc0ZldGNoZXIgfSBmcm9tIFwiQHBsYXNtaWNhcHAvbG9hZGVyLWZldGNoZXJcIjtcblxuLy8gc3JjL2RlcHMtZ3JhcGgudHNcbnZhciBEZXBzR3JhcGggPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGJ1bmRsZSwgYnJvd3NlckJ1aWxkKSB7XG4gICAgdGhpcy5idW5kbGUgPSBidW5kbGU7XG4gICAgdGhpcy5icm93c2VyQnVpbGQgPSBicm93c2VyQnVpbGQ7XG4gICAgdGhpcy5kZXBlbmRzT24gPSB7fTtcbiAgICB0aGlzLmRlcGVuZGVkQnkgPSB7fTtcbiAgICB0aGlzLnJlYnVpbGRHcmFwaCgpO1xuICB9XG4gIGdldFRyYW5zaXRpdmVEZXBlbmRlcnMobmFtZTIpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2l0aXZlQ3Jhd2wobmFtZTIsIHRoaXMuZGVwZW5kZWRCeSk7XG4gIH1cbiAgZ2V0VHJhbnNpdGl2ZURlcHMobmFtZTIpIHtcbiAgICBpZiAoIShuYW1lMiBpbiB0aGlzLmRlcGVuZHNPbikpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudHJhbnNpdGl2ZUNyYXdsKG5hbWUyLCB0aGlzLmRlcGVuZHNPbik7XG4gIH1cbiAgdHJhbnNpdGl2ZUNyYXdsKG5hbWUyLCBlZGdlcykge1xuICAgIGNvbnN0IGRlcHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGNvbnN0IGNyYXdsID0gKGRlcDIpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmIChkZXBzLmhhcyhkZXAyKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkZXBzLmFkZChkZXAyKTtcbiAgICAgIGZvciAoY29uc3Qgc3ViZGVwIG9mIChfYSA9IGVkZ2VzW2RlcDJdKSAhPSBudWxsID8gX2EgOiBbXSkge1xuICAgICAgICBjcmF3bChzdWJkZXApO1xuICAgICAgfVxuICAgIH07XG4gICAgZm9yIChjb25zdCBkZXAyIG9mIGVkZ2VzW25hbWUyXSkge1xuICAgICAgY3Jhd2woZGVwMik7XG4gICAgfVxuICAgIHJldHVybiBBcnJheS5mcm9tKGRlcHMpO1xuICB9XG4gIHJlYnVpbGRHcmFwaCgpIHtcbiAgICB0aGlzLmRlcGVuZGVkQnkgPSB7fTtcbiAgICB0aGlzLmRlcGVuZHNPbiA9IHt9O1xuICAgIGZvciAoY29uc3QgbW9kIG9mIHRoaXMuYnJvd3NlckJ1aWxkID8gdGhpcy5idW5kbGUubW9kdWxlcy5icm93c2VyIDogdGhpcy5idW5kbGUubW9kdWxlcy5zZXJ2ZXIpIHtcbiAgICAgIGlmIChtb2QudHlwZSA9PT0gXCJjb2RlXCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBpbXBvcnRlZCBvZiBtb2QuaW1wb3J0cykge1xuICAgICAgICAgIGlmICghKG1vZC5maWxlTmFtZSBpbiB0aGlzLmRlcGVuZHNPbikpIHtcbiAgICAgICAgICAgIHRoaXMuZGVwZW5kc09uW21vZC5maWxlTmFtZV0gPSBbaW1wb3J0ZWRdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlcGVuZHNPblttb2QuZmlsZU5hbWVdLnB1c2goaW1wb3J0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIShpbXBvcnRlZCBpbiB0aGlzLmRlcGVuZGVkQnkpKSB7XG4gICAgICAgICAgICB0aGlzLmRlcGVuZGVkQnlbaW1wb3J0ZWRdID0gW21vZC5maWxlTmFtZV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVwZW5kZWRCeVtpbXBvcnRlZF0ucHVzaChtb2QuZmlsZU5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2J1bmRsZXMudHNcbmZ1bmN0aW9uIGdldEJ1bmRsZVN1YnNldChidW5kbGUsIG5hbWVzLCBvcHRzMikge1xuICB2YXIgX2EsIF9iO1xuICBjb25zdCBuYW1lc1NldCA9IG5ldyBTZXQobmFtZXMpO1xuICBjb25zdCB0YXJnZXQgPSAoX2EgPSBvcHRzMiA9PSBudWxsID8gdm9pZCAwIDogb3B0czIudGFyZ2V0KSAhPSBudWxsID8gX2EgOiBcImJyb3dzZXJcIjtcbiAgY29uc3QgZm9yQnJvd3NlciA9IHRhcmdldCA9PT0gXCJicm93c2VyXCI7XG4gIGNvbnN0IGdyYXBoID0gbmV3IERlcHNHcmFwaChidW5kbGUsIGZvckJyb3dzZXIpO1xuICBjb25zdCBkZXBzID0gbmV3IFNldChuYW1lcy5mbGF0TWFwKChuYW1lMikgPT4gZ3JhcGguZ2V0VHJhbnNpdGl2ZURlcHMobmFtZTIpKSk7XG4gIGNvbnN0IGlzU3ViTW9kdWxlID0gKGZpbGVOYW1lKSA9PiBkZXBzLmhhcyhmaWxlTmFtZSkgfHwgbmFtZXNTZXQuaGFzKGZpbGVOYW1lKTtcbiAgY29uc3QgbW9kdWxlcyA9IGJ1bmRsZS5tb2R1bGVzW3RhcmdldF07XG4gIGNvbnN0IGZpbHRlcmVkTW9kdWxlcyA9IG1vZHVsZXMuZmlsdGVyKChtb2QpID0+IGlzU3ViTW9kdWxlKG1vZC5maWxlTmFtZSkpO1xuICBjb25zdCBmaWx0ZXJlZENvbXBvbmVudHMgPSBidW5kbGUuY29tcG9uZW50cy5maWx0ZXIoXG4gICAgKGMpID0+IGlzU3ViTW9kdWxlKGMuZW50cnkpXG4gICk7XG4gIGNvbnN0IGZpbHRlcmVkQ29tcG9uZW50c0lkcyA9IG5ldyBTZXQoZmlsdGVyZWRDb21wb25lbnRzLm1hcCgoYykgPT4gYy5pZCkpO1xuICBjb25zdCBmaWx0ZXJlZElkcyA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBPYmplY3QuZW50cmllcyhidW5kbGUuZmlsdGVyZWRJZHMpLm1hcCgoW2ssIHZdKSA9PiBbaywgWy4uLnZdXSlcbiAgKTtcbiAgYnVuZGxlLmNvbXBvbmVudHMuZmlsdGVyKChjKSA9PiAhZmlsdGVyZWRDb21wb25lbnRzSWRzLmhhcyhjLmlkKSkuZm9yRWFjaCgoY29tcG9uZW50KSA9PiB7XG4gICAgdmFyIF9hMjtcbiAgICBmaWx0ZXJlZElkc1tjb21wb25lbnQucHJvamVjdElkXSA9IChfYTIgPSBmaWx0ZXJlZElkc1tjb21wb25lbnQucHJvamVjdElkXSkgIT0gbnVsbCA/IF9hMiA6IFtdO1xuICAgIGlmICghZmlsdGVyZWRJZHNbY29tcG9uZW50LnByb2plY3RJZF0uaW5jbHVkZXMoY29tcG9uZW50LmlkKSkge1xuICAgICAgZmlsdGVyZWRJZHNbY29tcG9uZW50LnByb2plY3RJZF0ucHVzaChjb21wb25lbnQuaWQpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7XG4gICAgbW9kdWxlczoge1xuICAgICAgYnJvd3NlcjogZm9yQnJvd3NlciA/IGZpbHRlcmVkTW9kdWxlcyA6IFtdLFxuICAgICAgc2VydmVyOiBmb3JCcm93c2VyID8gW10gOiBmaWx0ZXJlZE1vZHVsZXNcbiAgICB9LFxuICAgIGNvbXBvbmVudHM6IGZpbHRlcmVkQ29tcG9uZW50cyxcbiAgICBnbG9iYWxHcm91cHM6IGJ1bmRsZS5nbG9iYWxHcm91cHMsXG4gICAgcHJvamVjdHM6IGJ1bmRsZS5wcm9qZWN0cyxcbiAgICBhY3RpdmVTcGxpdHM6IGJ1bmRsZS5hY3RpdmVTcGxpdHMsXG4gICAgYnVuZGxlS2V5OiAoX2IgPSBidW5kbGUuYnVuZGxlS2V5KSAhPSBudWxsID8gX2IgOiBudWxsLFxuICAgIGRlZmVyQ2h1bmtzQnlEZWZhdWx0OiBidW5kbGUuZGVmZXJDaHVua3NCeURlZmF1bHQsXG4gICAgZGlzYWJsZVJvb3RMb2FkaW5nQm91bmRhcnlCeURlZmF1bHQ6IGJ1bmRsZS5kaXNhYmxlUm9vdExvYWRpbmdCb3VuZGFyeUJ5RGVmYXVsdCxcbiAgICBmaWx0ZXJlZElkc1xuICB9O1xufVxuXG4vLyBzcmMvcmVnaXN0cnkudHNcbnZhciBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdyAhPSBudWxsICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCI7XG5mdW5jdGlvbiBpc01vZHVsZUJ1bmRsZVByb21pc2VTZXQobmFtZTIpIHtcbiAgcmV0dXJuIGdsb2JhbFRoaXMuX19QbGFzbWljQnVuZGxlUHJvbWlzZXMgJiYgISFnbG9iYWxUaGlzLl9fUGxhc21pY0J1bmRsZVByb21pc2VzW25hbWUyXSAmJiAhIWdsb2JhbFRoaXMuX19QbGFzbWljQnVuZGxlUHJvbWlzZXNbbmFtZTJdLnRoZW47XG59XG52YXIgUmVnaXN0cnkgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubG9hZGVkTW9kdWxlcyA9IHt9O1xuICAgIHRoaXMucmVnaXN0ZXJlZE1vZHVsZXMgPSB7fTtcbiAgICB0aGlzLm1vZHVsZXMgPSB7fTtcbiAgfVxuICByZWdpc3RlcihuYW1lMiwgbW9kdWxlKSB7XG4gICAgdGhpcy5yZWdpc3RlcmVkTW9kdWxlc1tuYW1lMl0gPSBtb2R1bGU7XG4gIH1cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5sb2FkZWRNb2R1bGVzKS5sZW5ndGggPT09IDA7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5sb2FkZWRNb2R1bGVzID0ge307XG4gIH1cbiAgZ2V0UmVnaXN0ZXJlZE1vZHVsZShuYW1lMikge1xuICAgIHJldHVybiB0aGlzLnJlZ2lzdGVyZWRNb2R1bGVzW25hbWUyXTtcbiAgfVxuICBoYXNNb2R1bGUobmFtZTIsIG9wdHMyID0ge30pIHtcbiAgICBpZiAobmFtZTIgaW4gdGhpcy5yZWdpc3RlcmVkTW9kdWxlcyAmJiAhb3B0czIuZm9yY2VPcmlnaW5hbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChuYW1lMiBpbiB0aGlzLm1vZHVsZXMpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoZ2xvYmFsVGhpcy5fX1BMQVNNSUNfQ0hVTktTICYmICEhZ2xvYmFsVGhpcy5fX1BMQVNNSUNfQ0hVTktTW25hbWUyXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChpc01vZHVsZUJ1bmRsZVByb21pc2VTZXQobmFtZTIpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGxvYWQobmFtZSwgb3B0cyA9IHt9KSB7XG4gICAgaWYgKG5hbWUgaW4gdGhpcy5yZWdpc3RlcmVkTW9kdWxlcyAmJiAhb3B0cy5mb3JjZU9yaWdpbmFsKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWdpc3RlcmVkTW9kdWxlc1tuYW1lXTtcbiAgICB9XG4gICAgaWYgKG5hbWUgaW4gdGhpcy5sb2FkZWRNb2R1bGVzKSB7XG4gICAgICByZXR1cm4gdGhpcy5sb2FkZWRNb2R1bGVzW25hbWVdO1xuICAgIH1cbiAgICBpZiAoIXRoaXMubW9kdWxlc1tuYW1lXSAmJiBnbG9iYWxUaGlzLl9fUExBU01JQ19DSFVOS1MgJiYgISFnbG9iYWxUaGlzLl9fUExBU01JQ19DSFVOS1NbbmFtZV0pIHtcbiAgICAgIHRoaXMubW9kdWxlc1tuYW1lXSA9IGdsb2JhbFRoaXMuX19QTEFTTUlDX0NIVU5LU1tuYW1lXTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLm1vZHVsZXNbbmFtZV0gJiYgaXNNb2R1bGVCdW5kbGVQcm9taXNlU2V0KG5hbWUpKSB7XG4gICAgICB0aHJvdyBnbG9iYWxUaGlzLl9fUGxhc21pY0J1bmRsZVByb21pc2VzW25hbWVdO1xuICAgIH1cbiAgICBpZiAoIShuYW1lIGluIHRoaXMubW9kdWxlcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBtb2R1bGUgJHtuYW1lfWApO1xuICAgIH1cbiAgICBjb25zdCBjb2RlID0gdGhpcy5tb2R1bGVzW25hbWVdO1xuICAgIGNvbnN0IHJlcXVpcmVGbiA9IGlzQnJvd3NlciA/IChkZXAyKSA9PiB7XG4gICAgICBjb25zdCBub3JtYWxpemVkRGVwID0gcmVzb2x2ZVBhdGgoZGVwMiwgbmFtZSk7XG4gICAgICByZXR1cm4gdGhpcy5sb2FkKG5vcm1hbGl6ZWREZXApO1xuICAgIH0gOiAoZGVwKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBub3JtYWxpemVkRGVwID0gcmVzb2x2ZVBhdGgoZGVwLCBuYW1lKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZChub3JtYWxpemVkRGVwKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBldmFsKFwicmVxdWlyZVwiKShkZXApO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBsZXQgZnVuYztcbiAgICB0cnkge1xuICAgICAgZnVuYyA9IG5ldyBGdW5jdGlvbihcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIGNvZGUpO1xuICAgIH0gY2F0Y2ggKGVycjIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUExBU01JQzogRmFpbGVkIHRvIGNyZWF0ZSBmdW5jdGlvbiBmb3IgJHtuYW1lfTogJHtlcnIyfWApO1xuICAgIH1cbiAgICBjb25zdCBleHBvcnRzID0ge307XG4gICAgdGhpcy5sb2FkZWRNb2R1bGVzW25hbWVdID0gZXhwb3J0cztcbiAgICB0cnkge1xuICAgICAgZnVuYyhyZXF1aXJlRm4sIGV4cG9ydHMpO1xuICAgIH0gY2F0Y2ggKGVycjIpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmxvYWRlZE1vZHVsZXNbbmFtZV07XG4gICAgICBpZiAoIShlcnIyIGluc3RhbmNlb2YgRXJyb3IpICYmICEhZXJyMiAmJiAhIWVycjIudGhlbikge1xuICAgICAgICB0aHJvdyBlcnIyO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBQTEFTTUlDOiBGYWlsZWQgdG8gbG9hZCAke25hbWV9OiAke2VycjJ9YCk7XG4gICAgfVxuICAgIHJldHVybiBleHBvcnRzO1xuICB9XG4gIHVwZGF0ZU1vZHVsZXMoYnVuZGxlKSB7XG4gICAgbGV0IHVwZGF0ZWQgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IG1vZCBvZiBpc0Jyb3dzZXIgPyBidW5kbGUubW9kdWxlcy5icm93c2VyIDogYnVuZGxlLm1vZHVsZXMuc2VydmVyKSB7XG4gICAgICBpZiAobW9kLnR5cGUgPT09IFwiY29kZVwiICYmICEhbW9kLmNvZGUgJiYgbW9kLmNvZGUgIT09IHRoaXMubW9kdWxlc1ttb2QuZmlsZU5hbWVdKSB7XG4gICAgICAgIHRoaXMubW9kdWxlc1ttb2QuZmlsZU5hbWVdID0gbW9kLmNvZGU7XG4gICAgICAgIGlmICghZ2xvYmFsVGhpcy5fX1BMQVNNSUNfQ0hVTktTKSB7XG4gICAgICAgICAgZ2xvYmFsVGhpcy5fX1BMQVNNSUNfQ0hVTktTID0ge307XG4gICAgICAgIH1cbiAgICAgICAgZ2xvYmFsVGhpcy5fX1BMQVNNSUNfQ0hVTktTW21vZC5maWxlTmFtZV0gPSBtb2QuY29kZTtcbiAgICAgICAgdXBkYXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh1cGRhdGVkKSB7XG4gICAgICB0aGlzLmNsZWFyKCk7XG4gICAgfVxuICB9XG59O1xuZnVuY3Rpb24gcmVzb2x2ZVBhdGgocGF0aCwgZnJvbSkge1xuICBjb25zdCBmcm9tUGFydHMgPSBmcm9tLnNwbGl0KFwiL1wiKTtcbiAgY29uc3QgcGF0aFBhcnRzID0gcGF0aC5zcGxpdChcIi9cIik7XG4gIGlmIChwYXRoUGFydHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cbiAgaWYgKHBhdGhQYXJ0c1swXSA9PT0gXCIuXCIpIHtcbiAgICByZXR1cm4gW1xuICAgICAgLi4uZnJvbVBhcnRzLnNsaWNlKDAsIGZyb21QYXJ0cy5sZW5ndGggLSAxKSxcbiAgICAgIC4uLnBhdGhQYXJ0cy5zbGljZSgxKVxuICAgIF0uam9pbihcIi9cIik7XG4gIH0gZWxzZSBpZiAocGF0aFBhcnRzWzBdID09PSBcIi4uXCIpIHtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXRoUGFydHMpIHtcbiAgICAgIGlmIChwYXJ0ID09PSBcIi4uXCIpIHtcbiAgICAgICAgY291bnQgKz0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgLi4uZnJvbVBhcnRzLnNsaWNlKDAsIGZyb21QYXJ0cy5sZW5ndGggLSBjb3VudCAtIDEpLFxuICAgICAgLi4ucGF0aFBhcnRzLnNsaWNlKGNvdW50KVxuICAgIF0uam9pbihcIi9cIik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cbn1cblxuLy8gc3JjL3RyYWNrZXIvaW5kZXgudHNcbmltcG9ydCB1bmZldGNoIGZyb20gXCJAcGxhc21pY2FwcC9pc29tb3JwaGljLXVuZmV0Y2hcIjtcblxuLy8gc3JjL3RyYWNrZXIvdXRpbHMudHNcbnZhciBpc0Jyb3dzZXIyID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cgIT0gbnVsbCAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiO1xuZnVuY3Rpb24gZ2V0UGxhc21pY0Nvb2tpZVZhbHVlcygpIHtcbiAgaWYgKCFpc0Jyb3dzZXIyKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgZG9jdW1lbnQuY29va2llLnNwbGl0KFwiOyBcIikuZmlsdGVyKChjb29raWUpID0+IGNvb2tpZS5pbmNsdWRlcyhcInBsYXNtaWM6XCIpKS5tYXAoKGNvb2tpZSkgPT4gY29va2llLnNwbGl0KFwiPVwiKSkubWFwKChba2V5LCB2YWx1ZV0pID0+IFtrZXkuc3BsaXQoXCI6XCIpWzFdLCB2YWx1ZV0pXG4gICk7XG59XG5mdW5jdGlvbiBnZXRWYXJpYXRpb25Db29raWVWYWx1ZXMoKSB7XG4gIGNvbnN0IGNvb2tpZXMgPSBnZXRQbGFzbWljQ29va2llVmFsdWVzKCk7XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgT2JqZWN0LmtleXMoY29va2llcykubWFwKChrZXkpID0+IFtrZXkuc3BsaXQoXCIuXCIpWzFdLCBjb29raWVzW2tleV1dKS5maWx0ZXIoKHZhbCkgPT4gISF2YWxbMF0pXG4gICk7XG59XG5mdW5jdGlvbiBnZXREaXN0aW5jdElkKCkge1xuICBpZiAoIWlzQnJvd3NlcjIpIHtcbiAgICByZXR1cm4gXCJMT0FERVItU0VSVkVSXCI7XG4gIH1cbiAgcmV0dXJuIFwiTE9BREVSLUNMSUVOVFwiO1xufVxuZnVuY3Rpb24gZ2V0Q2FtcGFpZ25QYXJhbXMoKSB7XG4gIGNvbnN0IHsgbG9jYXRpb24gfSA9IHdpbmRvdztcbiAgY29uc3QgcGFyYW1zID0ge307XG4gIHRyeSB7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChsb2NhdGlvbi5ocmVmKTtcbiAgICBjb25zdCBDQU1QQUlHTl9LRVlXT1JEUyA9IFtcbiAgICAgIFwidXRtX3NvdXJjZVwiLFxuICAgICAgXCJ1dG1fbWVkaXVtXCIsXG4gICAgICBcInV0bV9jYW1wYWlnblwiLFxuICAgICAgXCJ1dG1fY29udGVudFwiLFxuICAgICAgXCJ1dG1fdGVybVwiLFxuICAgICAgXCJnY2xpZFwiXG4gICAgXTtcbiAgICBDQU1QQUlHTl9LRVlXT1JEUy5mb3JFYWNoKChrZXl3b3JkKSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHVybC5zZWFyY2hQYXJhbXMuZ2V0KGtleXdvcmQpO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHBhcmFtc1trZXl3b3JkXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGNhdGNoIChlcnIyKSB7XG4gIH1cbiAgcmV0dXJuIHBhcmFtcztcbn1cbmZ1bmN0aW9uIGdldExvY2F0aW9uTWV0YSgpIHtcbiAgY29uc3QgeyBsb2NhdGlvbiB9ID0gd2luZG93O1xuICBjb25zdCB7IHJlZmVycmVyIH0gPSBkb2N1bWVudDtcbiAgcmV0dXJuIF9fc3ByZWFkVmFsdWVzKHtcbiAgICB1cmw6IGxvY2F0aW9uLmhyZWYsXG4gICAgaG9zdDogbG9jYXRpb24uaG9zdCxcbiAgICBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgcmVmZXJyZXJcbiAgfSwgZ2V0Q2FtcGFpZ25QYXJhbXMoKSk7XG59XG5mdW5jdGlvbiBnZXRTY3JlZW5NZXRhKCkge1xuICBjb25zdCB7IHNjcmVlbiB9ID0gd2luZG93O1xuICByZXR1cm4ge1xuICAgIHNjcmVlbl9oZWlnaHQ6IHNjcmVlbi5oZWlnaHQsXG4gICAgc2NyZWVuX3dpZHRoOiBzY3JlZW4ud2lkdGgsXG4gICAgdmlld3BvcnRfaGVpZ2h0OiB3aW5kb3cuaW5uZXJIZWlnaHQsXG4gICAgdmlld3BvcnRfd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoXG4gIH07XG59XG5mdW5jdGlvbiBnZXRPUyh1c2VyQWdlbnQpIHtcbiAgaWYgKC9XaW5kb3dzL2kudGVzdCh1c2VyQWdlbnQpKSB7XG4gICAgaWYgKC9QaG9uZS8udGVzdCh1c2VyQWdlbnQpIHx8IC9XUERlc2t0b3AvLnRlc3QodXNlckFnZW50KSkge1xuICAgICAgcmV0dXJuIFwiV2luZG93cyBQaG9uZVwiO1xuICAgIH1cbiAgICByZXR1cm4gXCJXaW5kb3dzXCI7XG4gIH0gZWxzZSBpZiAoLyhpUGhvbmV8aVBhZHxpUG9kKS8udGVzdCh1c2VyQWdlbnQpKSB7XG4gICAgcmV0dXJuIFwiaU9TXCI7XG4gIH0gZWxzZSBpZiAoL0FuZHJvaWQvLnRlc3QodXNlckFnZW50KSkge1xuICAgIHJldHVybiBcIkFuZHJvaWRcIjtcbiAgfSBlbHNlIGlmICgvKEJsYWNrQmVycnl8UGxheUJvb2t8QkIxMCkvaS50ZXN0KHVzZXJBZ2VudCkpIHtcbiAgICByZXR1cm4gXCJCbGFja0JlcnJ5XCI7XG4gIH0gZWxzZSBpZiAoL01hYy9pLnRlc3QodXNlckFnZW50KSkge1xuICAgIHJldHVybiBcIk1hYyBPUyBYXCI7XG4gIH0gZWxzZSBpZiAoL0xpbnV4Ly50ZXN0KHVzZXJBZ2VudCkpIHtcbiAgICByZXR1cm4gXCJMaW51eFwiO1xuICB9IGVsc2UgaWYgKC9Dck9TLy50ZXN0KHVzZXJBZ2VudCkpIHtcbiAgICByZXR1cm4gXCJDaHJvbWUgT1NcIjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0RGV2aWNlSW5mbyh1c2VyQWdlbnQpIHtcbiAgY29uc3QgUEFUVEVSTlMgPSBbXG4gICAge1xuICAgICAgZGV2aWNlOiBcImlQaG9uZVwiLFxuICAgICAgcGF0dGVybnM6IFsvaVBob25lL11cbiAgICB9LFxuICAgIHtcbiAgICAgIGRldmljZTogXCJpUGFkXCIsXG4gICAgICBwYXR0ZXJuczogWy9pUGFkL11cbiAgICB9LFxuICAgIHtcbiAgICAgIGRldmljZTogXCJpUG9kIFRvdWNoXCIsXG4gICAgICBwYXR0ZXJuczogWy9pUG9kL11cbiAgICB9LFxuICAgIHtcbiAgICAgIGRldmljZTogXCJXaW5kb3dzIFBob25lXCIsXG4gICAgICBwYXR0ZXJuczogWy9XaW5kb3dzIFBob25lL2ksIC9XUERlc2t0b3AvXVxuICAgIH0sXG4gICAge1xuICAgICAgZGV2aWNlOiBcIkFuZHJvaWRcIixcbiAgICAgIHBhdHRlcm5zOiBbL0FuZHJvaWQvXVxuICAgIH1cbiAgXTtcbiAgY29uc3QgbWF0Y2ggPSBQQVRURVJOUy5maW5kKFxuICAgIChwYXR0ZXJuKSA9PiBwYXR0ZXJuLnBhdHRlcm5zLnNvbWUoKGV4cHIpID0+IGV4cHIudGVzdCh1c2VyQWdlbnQpKVxuICApO1xuICBjb25zdCBkZXZpY2UgPSBtYXRjaCA9PSBudWxsID8gdm9pZCAwIDogbWF0Y2guZGV2aWNlO1xuICByZXR1cm4ge1xuICAgIGRldmljZTogZGV2aWNlICE9IG51bGwgPyBkZXZpY2UgOiBcIlwiLFxuICAgIGRldmljZVR5cGU6IGRldmljZSA/IFwiTW9iaWxlXCIgOiBcIkRlc2t0b3BcIixcbiAgICBvczogZ2V0T1ModXNlckFnZW50KVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0VXNlckFnZW50TWV0YSgpIHtcbiAgY29uc3QgeyBuYXZpZ2F0b3IgfSA9IHdpbmRvdztcbiAgY29uc3QgeyB1c2VyQWdlbnQgfSA9IG5hdmlnYXRvcjtcbiAgcmV0dXJuIF9fc3ByZWFkVmFsdWVzKHt9LCBnZXREZXZpY2VJbmZvKHVzZXJBZ2VudCkpO1xufVxuZnVuY3Rpb24gZ2V0V2luZG93TWV0YSgpIHtcbiAgaWYgKCFpc0Jyb3dzZXIyKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIHJldHVybiBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgZ2V0TG9jYXRpb25NZXRhKCkpLCBnZXRTY3JlZW5NZXRhKCkpLCBnZXRVc2VyQWdlbnRNZXRhKCkpO1xufVxudmFyIGlzUHJvZHVjdGlvbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIjtcbmZ1bmN0aW9uIGdldEVudk1ldGEoKSB7XG4gIHJldHVybiB7XG4gICAgaXNCcm93c2VyOiBpc0Jyb3dzZXIyLFxuICAgIGlzUHJvZHVjdGlvblxuICB9O1xufVxuZnVuY3Rpb24gcmF3U3BsaXRWYXJpYXRpb24odmFyaWF0aW9uKSB7XG4gIGNvbnN0IHJhd1ZhcmlhdGlvbnMgPSB7fTtcbiAgT2JqZWN0LmtleXModmFyaWF0aW9uKS5mb3JFYWNoKCh2YXJpYXRpb25LZXkpID0+IHtcbiAgICBjb25zdCBbLCBzcGxpdElkXSA9IHZhcmlhdGlvbktleS5zcGxpdChcIi5cIik7XG4gICAgaWYgKHNwbGl0SWQpIHtcbiAgICAgIHJhd1ZhcmlhdGlvbnNbc3BsaXRJZF0gPSB2YXJpYXRpb25bdmFyaWF0aW9uS2V5XTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmF3VmFyaWF0aW9ucztcbn1cbnZhciBQT0xMX1RJTUUgPSA1ZTM7XG5mdW5jdGlvbiB0aHJvdHRsZWQoZnVuYzIpIHtcbiAgbGV0IHRpbWVySWQgPSB2b2lkIDA7XG4gIHJldHVybiAocGFyYW0pID0+IHtcbiAgICBpZiAodGltZXJJZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNCcm93c2VyMikge1xuICAgICAgdGltZXJJZCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICB0aW1lcklkID0gdm9pZCAwO1xuICAgICAgICBmdW5jMihwYXJhbSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aW1lcklkID0gdm9pZCAwO1xuICAgICAgICBmdW5jMihwYXJhbSk7XG4gICAgICB9LCBQT0xMX1RJTUUpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3RyYWNrZXIvaW5kZXgudHNcbnZhciBBUElfRU5EUE9JTlQgPSBcImh0dHBzOi8vYW5hbHl0aWNzLnBsYXNtaWMuYXBwL2NhcHR1cmVcIjtcbnZhciBBUElfUFVCTElDX0tFWSA9IFwicGhjX0JSdllUQW9Nb2FtOWZESGZySW5lRjY3S2R0TUphZ0xWVkNNNkVMTllkNG5cIjtcbnZhciBUUkFDS0VSX1ZFUlNJT04gPSA0O1xudmFyIFBsYXNtaWNUcmFja2VyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRzMikge1xuICAgIHRoaXMub3B0cyA9IG9wdHMyO1xuICAgIHRoaXMuZXZlbnRRdWV1ZSA9IFtdO1xuICAgIHRoaXMuc2VuZEV2ZW50cyA9IHRocm90dGxlZCgodHJhbnNwb3J0KSA9PiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAodGhpcy5ldmVudFF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBldmVudHMgPSBbLi4udGhpcy5ldmVudFF1ZXVlXTtcbiAgICAgIHRoaXMuZXZlbnRRdWV1ZS5sZW5ndGggPSAwO1xuICAgICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgYXBpX2tleTogQVBJX1BVQkxJQ19LRVksXG4gICAgICAgIGJhdGNoOiBldmVudHNcbiAgICAgIH07XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBzdHJpbmdCb2R5ID0gSlNPTi5zdHJpbmdpZnkoYm9keSk7XG4gICAgICAgIGlmICh0cmFuc3BvcnQgPT09IFwiYmVhY29uXCIpIHtcbiAgICAgICAgICB3aW5kb3cubmF2aWdhdG9yLnNlbmRCZWFjb24oQVBJX0VORFBPSU5ULCBzdHJpbmdCb2R5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmZldGNoKEFQSV9FTkRQT0lOVCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgQWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJvZHk6IHN0cmluZ0JvZHlcbiAgICAgICAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgICAgICB9KS5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycjIpIHtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgdGhpcy5mZXRjaCA9IChvcHRzMi5uYXRpdmVGZXRjaCAmJiBnbG9iYWxUaGlzLmZldGNoID8gZ2xvYmFsVGhpcy5mZXRjaCA6IHVuZmV0Y2gpLmJpbmQoZ2xvYmFsVGhpcyk7XG4gIH1cbiAgdHJhY2tSZW5kZXIob3B0czIpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHRoaXMuZW5xdWV1ZSh7XG4gICAgICBldmVudDogXCIkcmVuZGVyXCIsXG4gICAgICBwcm9wZXJ0aWVzOiBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgdGhpcy5nZXRQcm9wZXJ0aWVzKCkpLCAoX2EgPSBvcHRzMiA9PSBudWxsID8gdm9pZCAwIDogb3B0czIucmVuZGVyQ3R4KSAhPSBudWxsID8gX2EgOiB7fSksIHJhd1NwbGl0VmFyaWF0aW9uKChfYiA9IG9wdHMyID09IG51bGwgPyB2b2lkIDAgOiBvcHRzMi52YXJpYXRpb24pICE9IG51bGwgPyBfYiA6IHt9KSlcbiAgICB9KTtcbiAgfVxuICB0cmFja0ZldGNoKCkge1xuICAgIHRoaXMuZW5xdWV1ZSh7XG4gICAgICBldmVudDogXCIkZmV0Y2hcIixcbiAgICAgIHByb3BlcnRpZXM6IHRoaXMuZ2V0UHJvcGVydGllcygpXG4gICAgfSk7XG4gIH1cbiAgdHJhY2tDb252ZXJzaW9uKHZhbHVlID0gMCkge1xuICAgIHRoaXMuZW5xdWV1ZSh7XG4gICAgICBldmVudDogXCIkY29udmVyc2lvblwiLFxuICAgICAgcHJvcGVydGllczogX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgdGhpcy5nZXRQcm9wZXJ0aWVzKCkpLCB7XG4gICAgICAgIHZhbHVlXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG4gIGdldFByb3BlcnRpZXMoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgIGRpc3RpbmN0X2lkOiBnZXREaXN0aW5jdElkKClcbiAgICB9LCBnZXRXaW5kb3dNZXRhKCkpLCBnZXRFbnZNZXRhKCkpLCB0aGlzLmdldENvbnRleHRNZXRhKCkpLCBnZXRWYXJpYXRpb25Db29raWVWYWx1ZXMoKSksIHtcbiAgICAgIHRpbWVzdGFtcDogKF9hID0gRGF0ZS5ub3coKSkgIT0gbnVsbCA/IF9hIDogKy8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLFxuICAgICAgdHJhY2tlclZlcnNpb246IFRSQUNLRVJfVkVSU0lPTlxuICAgIH0pO1xuICB9XG4gIGVucXVldWUoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5vcHRzLl9fcGxhc21pY1RyYWNrZXJEaXNhYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmV2ZW50UXVldWUucHVzaChldmVudCk7XG4gICAgdGhpcy5zZW5kRXZlbnRzKFwiZmV0Y2hcIik7XG4gIH1cbiAgZ2V0Q29udGV4dE1ldGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBsYXRmb3JtOiB0aGlzLm9wdHMucGxhdGZvcm0sXG4gICAgICBwcmV2aWV3OiB0aGlzLm9wdHMucHJldmlldyxcbiAgICAgIHByb2plY3RJZHM6IHRoaXMub3B0cy5wcm9qZWN0SWRzXG4gICAgfTtcbiAgfVxufTtcbmV4cG9ydCB7XG4gIEFwaSxcbiAgUGxhc21pY01vZHVsZXNGZXRjaGVyLFxuICBQbGFzbWljVHJhY2tlcixcbiAgUmVnaXN0cnksXG4gIGdldEJ1bmRsZVN1YnNldFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@plasmicapp/loader-core/dist/index.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@plasmicapp/loader-fetcher/dist/index.esm.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@plasmicapp/loader-fetcher/dist/index.esm.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Api: () => (/* binding */ Api),\n/* harmony export */   PlasmicModulesFetcher: () => (/* binding */ PlasmicModulesFetcher),\n/* harmony export */   internal_getCachedBundleInNodeServer: () => (/* binding */ internal_getCachedBundleInNodeServer)\n/* harmony export */ });\n/* harmony import */ var _plasmicapp_isomorphic_unfetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @plasmicapp/isomorphic-unfetch */ \"(ssr)/./node_modules/@plasmicapp/isomorphic-unfetch/index.js\");\n/* harmony import */ var _plasmicapp_isomorphic_unfetch__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_plasmicapp_isomorphic_unfetch__WEBPACK_IMPORTED_MODULE_0__);\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// src/api.ts\n\nvar VERSION = \"10\";\nvar isBrowser = typeof window !== \"undefined\" && window != null && typeof window.document !== \"undefined\";\nfunction transformApiLoaderBundleOutput(bundle) {\n  return __spreadProps(__spreadValues({}, bundle), {\n    filteredIds: Object.fromEntries(bundle.projects.map((p) => [p.id, []]))\n  });\n}\nvar Api = class {\n  constructor(opts) {\n    this.opts = opts;\n    this.lastResponse = void 0;\n    var _a;\n    this.host = (_a = opts.host) != null ? _a : \"https://codegen.plasmic.app\";\n    this.fetch = (opts.nativeFetch && globalThis.fetch ? globalThis.fetch : (_plasmicapp_isomorphic_unfetch__WEBPACK_IMPORTED_MODULE_0___default())).bind(globalThis);\n  }\n  fetchLoaderData(projectIds, opts) {\n    return __async(this, null, function* () {\n      var _a, _b, _c, _d, _e, _f, _g, _h, _i;\n      const { platform, preview } = opts;\n      const query = new URLSearchParams([\n        [\"platform\", platform != null ? platform : \"react\"],\n        ...((_b = (_a = opts.platformOptions) == null ? void 0 : _a.nextjs) == null ? void 0 : _b.appDir) ? [[\"nextjsAppDir\", \"true\"]] : [],\n        ...projectIds.map((projectId) => [\"projectId\", projectId]),\n        ...opts.browserOnly ? [[\"browserOnly\", \"true\"]] : [],\n        ...opts.i18nKeyScheme ? [[\"i18nKeyScheme\", opts.i18nKeyScheme]] : [],\n        ...opts.i18nTagPrefix ? [[\"i18nTagPrefix\", opts.i18nTagPrefix]] : [],\n        ...opts.skipHead ? [[\"skipHead\", \"true\"]] : []\n      ]).toString();\n      const url = `${this.host}/api/v1/loader/code/${preview ? \"preview\" : \"published\"}?${query}`;\n      const useLastReponse = (\n        // We consider that manualRedirect is true by default, only by setting it to false\n        // we disable it.\n        !(this.opts.manualRedirect === false) && !preview && !isBrowser\n      );\n      if (useLastReponse) {\n        const redirectResp = yield this.fetch(url, {\n          method: \"GET\",\n          headers: this.makeGetHeaders(),\n          redirect: \"manual\"\n        });\n        if (redirectResp.status !== 301 && redirectResp.status !== 302) {\n          const error = yield this.parseJsonResponse(redirectResp);\n          throw new Error(\n            `Error fetching loader data, a redirect was expected: ${(_d = (_c = error == null ? void 0 : error.error) == null ? void 0 : _c.message) != null ? _d : redirectResp.statusText}`\n          );\n        }\n        const nextLocation = redirectResp.headers.get(\"location\");\n        if (!nextLocation) {\n          throw new Error(\n            `Error fetching loader data, a redirect was expected but no location header was found`\n          );\n        }\n        if (((_e = this.lastResponse) == null ? void 0 : _e.key) === nextLocation) {\n          return this.lastResponse.bundle;\n        }\n        const resp2 = yield this.fetch(`${this.host}${nextLocation}`, {\n          method: \"GET\",\n          headers: this.makeGetHeaders()\n        });\n        if (resp2.status >= 400) {\n          const error = yield this.parseJsonResponse(resp2);\n          throw new Error(\n            `Error fetching loader data: ${(_g = (_f = error == null ? void 0 : error.error) == null ? void 0 : _f.message) != null ? _g : resp2.statusText}`\n          );\n        }\n        const json2 = transformApiLoaderBundleOutput(\n          yield this.parseJsonResponse(resp2)\n        );\n        this.lastResponse = {\n          bundle: json2,\n          key: nextLocation\n        };\n        return json2;\n      }\n      const resp = yield this.fetch(url, {\n        method: \"GET\",\n        headers: this.makeGetHeaders()\n      });\n      if (resp.status >= 400) {\n        const error = yield this.parseJsonResponse(resp);\n        throw new Error(\n          `Error fetching loader data: ${(_i = (_h = error == null ? void 0 : error.error) == null ? void 0 : _h.message) != null ? _i : resp.statusText}`\n        );\n      }\n      const json = yield this.parseJsonResponse(resp);\n      return transformApiLoaderBundleOutput(json);\n    });\n  }\n  parseJsonResponse(resp) {\n    return __async(this, null, function* () {\n      const text = yield resp.text();\n      try {\n        return JSON.parse(text);\n      } catch (err) {\n        throw new Error(\n          `Error parsing JSON response: ${err}; status: ${resp.status}; response: ${text}`\n        );\n      }\n    });\n  }\n  fetchHtmlData(opts) {\n    return __async(this, null, function* () {\n      const { projectId, component, embedHydrate, hydrate } = opts;\n      const query = new URLSearchParams([\n        [\"projectId\", projectId],\n        [\"component\", component],\n        [\"embedHydrate\", embedHydrate ? \"1\" : \"0\"],\n        [\"hydrate\", hydrate ? \"1\" : \"0\"]\n      ]).toString();\n      const resp = yield this.fetch(`${this.host}/api/v1/loader/html?${query}`, {\n        method: \"GET\",\n        headers: this.makeGetHeaders()\n      });\n      const json = yield resp.json();\n      return json;\n    });\n  }\n  makeGetHeaders() {\n    return __spreadValues({\n      \"x-plasmic-loader-version\": VERSION\n    }, this.makeAuthHeaders());\n  }\n  makeAuthHeaders() {\n    const tokens = this.opts.projects.map((p) => `${p.id}:${p.token}`).join(\",\");\n    return {\n      \"x-plasmic-api-project-tokens\": tokens\n    };\n  }\n  getChunksUrl(bundle, modules) {\n    var _a;\n    return `${this.host}/api/v1/loader/chunks?bundleKey=${encodeURIComponent(\n      (_a = bundle.bundleKey) != null ? _a : \"null\"\n    )}&fileName=${encodeURIComponent(\n      modules.map((m) => m.fileName).sort().join(\",\")\n    )}`;\n  }\n};\n\n// src/fetcher.ts\nvar PlasmicModulesFetcher = class {\n  constructor(opts) {\n    this.opts = opts;\n    this.curFetch = void 0;\n    this.api = new Api({\n      projects: opts.projects,\n      host: opts.host,\n      nativeFetch: opts.nativeFetch,\n      manualRedirect: opts.manualRedirect\n    });\n  }\n  getChunksUrl(bundle, modules) {\n    return this.api.getChunksUrl(bundle, modules);\n  }\n  fetchAllData() {\n    return __async(this, null, function* () {\n      const bundle = yield this.getCachedOrFetch();\n      this.cacheBundleInNodeServer(bundle);\n      return bundle;\n    });\n  }\n  getCachedOrFetch() {\n    return __async(this, null, function* () {\n      var _a;\n      if (this.opts.cache) {\n        const cachedData = yield this.opts.cache.get();\n        if (cachedData) {\n          return cachedData;\n        }\n      }\n      if (this.curFetch) {\n        return yield this.curFetch;\n      }\n      if (typeof process === \"undefined\" || !((_a = process.env) == null ? void 0 : _a.PLASMIC_QUIET)) {\n        console.debug(\"Plasmic: doing a fresh fetch...\");\n      }\n      const fetchPromise = this.doFetch();\n      this.curFetch = fetchPromise;\n      try {\n        const data = yield fetchPromise;\n        return data;\n      } finally {\n        if (this.curFetch === fetchPromise) {\n          this.curFetch = void 0;\n        }\n      }\n    });\n  }\n  doFetch() {\n    return __async(this, null, function* () {\n      var _a, _b, _c, _d;\n      const data = yield this.api.fetchLoaderData(\n        this.opts.projects.map(\n          (p) => p.version ? `${p.id}@${p.version}` : p.id\n        ),\n        {\n          platform: this.opts.platform,\n          platformOptions: this.opts.platformOptions,\n          preview: this.opts.preview,\n          i18nKeyScheme: (_b = (_a = this.opts.i18n) == null ? void 0 : _a.keyScheme) != null ? _b : this.opts.i18nKeyScheme,\n          i18nTagPrefix: (_c = this.opts.i18n) == null ? void 0 : _c.tagPrefix,\n          browserOnly: isBrowser,\n          skipHead: this.opts.skipHead\n        }\n      );\n      if (this.opts.cache) {\n        yield this.opts.cache.set(data);\n      }\n      if (typeof process === \"undefined\" || !((_d = process.env) == null ? void 0 : _d.PLASMIC_QUIET)) {\n        console.debug(\n          `Plasmic: fetched designs for ${data.projects.map((p) => `\"${p.name}\" (${p.id}@${p.version})`).join(\", \")}`\n        );\n      }\n      return data;\n    });\n  }\n  cacheBundleInNodeServer(bundle) {\n    if (isBrowser) {\n      return;\n    }\n    const global = globalThis;\n    if (global.__PLASMIC_BUNDLES === void 0) {\n      global.__PLASMIC_BUNDLES = {};\n    }\n    global.__PLASMIC_BUNDLES[getBundleKey(this.opts)] = bundle;\n  }\n};\nfunction internal_getCachedBundleInNodeServer(opts) {\n  var _a;\n  if (isBrowser) {\n    throw new Error(`Should not be consulting Node server cache in browser`);\n  }\n  const global = globalThis;\n  return (_a = global.__PLASMIC_BUNDLES) == null ? void 0 : _a[getBundleKey(opts)];\n}\nfunction getBundleKey({\n  host,\n  platform,\n  i18nKeyScheme,\n  preview,\n  projects,\n  skipHead\n}) {\n  return JSON.stringify({\n    host,\n    platform,\n    i18nKeyScheme,\n    preview,\n    projects,\n    skipHead\n  });\n}\n\n//# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBsYXNtaWNhcHAvbG9hZGVyLWZldGNoZXIvZGlzdC9pbmRleC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsdUVBQU87QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG9CQUFvQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsVUFBVSxzQkFBc0Isa0NBQWtDLEdBQUcsTUFBTTtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxvRUFBb0Usd0hBQXdIO0FBQzVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsVUFBVSxFQUFFLGFBQWE7QUFDbkU7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsaUhBQWlIO0FBQzVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGdIQUFnSDtBQUN6SjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSwwQ0FBMEMsTUFBTSxVQUFVLGNBQWMsWUFBWSxLQUFLO0FBQ3pGO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsY0FBYyw4Q0FBOEM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFVBQVUsc0JBQXNCLE1BQU07QUFDN0U7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxvREFBb0QsS0FBSyxHQUFHLFFBQVE7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxVQUFVLGtDQUFrQztBQUMxRDtBQUNBLE1BQU0sWUFBWTtBQUNsQjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLEtBQUssR0FBRyxVQUFVO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDZCQUE2QixPQUFPLEtBQUssS0FBSyxHQUFHLFVBQVUsZUFBZTtBQUNwSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBS0U7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvV29uZGVyVml0ZS1mcm9udGVuZC9ub2RlX21vZHVsZXMvQHBsYXNtaWNhcHAvbG9hZGVyLWZldGNoZXIvZGlzdC9pbmRleC5lc20uanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZlByb3BzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG52YXIgX19nZXRPd25Qcm9wRGVzY3MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycztcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xudmFyIF9fc3ByZWFkUHJvcHMgPSAoYSwgYikgPT4gX19kZWZQcm9wcyhhLCBfX2dldE93blByb3BEZXNjcyhiKSk7XG52YXIgX19hc3luYyA9IChfX3RoaXMsIF9fYXJndW1lbnRzLCBnZW5lcmF0b3IpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB2YXIgZnVsZmlsbGVkID0gKHZhbHVlKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciByZWplY3RlZCA9ICh2YWx1ZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3IudGhyb3codmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHN0ZXAgPSAoeCkgPT4geC5kb25lID8gcmVzb2x2ZSh4LnZhbHVlKSA6IFByb21pc2UucmVzb2x2ZSh4LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xuICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseShfX3RoaXMsIF9fYXJndW1lbnRzKSkubmV4dCgpKTtcbiAgfSk7XG59O1xuXG4vLyBzcmMvYXBpLnRzXG5pbXBvcnQgdW5mZXRjaCBmcm9tIFwiQHBsYXNtaWNhcHAvaXNvbW9ycGhpYy11bmZldGNoXCI7XG52YXIgVkVSU0lPTiA9IFwiMTBcIjtcbnZhciBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdyAhPSBudWxsICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCI7XG5mdW5jdGlvbiB0cmFuc2Zvcm1BcGlMb2FkZXJCdW5kbGVPdXRwdXQoYnVuZGxlKSB7XG4gIHJldHVybiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBidW5kbGUpLCB7XG4gICAgZmlsdGVyZWRJZHM6IE9iamVjdC5mcm9tRW50cmllcyhidW5kbGUucHJvamVjdHMubWFwKChwKSA9PiBbcC5pZCwgW11dKSlcbiAgfSk7XG59XG52YXIgQXBpID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICB0aGlzLmxhc3RSZXNwb25zZSA9IHZvaWQgMDtcbiAgICB2YXIgX2E7XG4gICAgdGhpcy5ob3N0ID0gKF9hID0gb3B0cy5ob3N0KSAhPSBudWxsID8gX2EgOiBcImh0dHBzOi8vY29kZWdlbi5wbGFzbWljLmFwcFwiO1xuICAgIHRoaXMuZmV0Y2ggPSAob3B0cy5uYXRpdmVGZXRjaCAmJiBnbG9iYWxUaGlzLmZldGNoID8gZ2xvYmFsVGhpcy5mZXRjaCA6IHVuZmV0Y2gpLmJpbmQoZ2xvYmFsVGhpcyk7XG4gIH1cbiAgZmV0Y2hMb2FkZXJEYXRhKHByb2plY3RJZHMsIG9wdHMpIHtcbiAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2k7XG4gICAgICBjb25zdCB7IHBsYXRmb3JtLCBwcmV2aWV3IH0gPSBvcHRzO1xuICAgICAgY29uc3QgcXVlcnkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKFtcbiAgICAgICAgW1wicGxhdGZvcm1cIiwgcGxhdGZvcm0gIT0gbnVsbCA/IHBsYXRmb3JtIDogXCJyZWFjdFwiXSxcbiAgICAgICAgLi4uKChfYiA9IChfYSA9IG9wdHMucGxhdGZvcm1PcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogX2EubmV4dGpzKSA9PSBudWxsID8gdm9pZCAwIDogX2IuYXBwRGlyKSA/IFtbXCJuZXh0anNBcHBEaXJcIiwgXCJ0cnVlXCJdXSA6IFtdLFxuICAgICAgICAuLi5wcm9qZWN0SWRzLm1hcCgocHJvamVjdElkKSA9PiBbXCJwcm9qZWN0SWRcIiwgcHJvamVjdElkXSksXG4gICAgICAgIC4uLm9wdHMuYnJvd3Nlck9ubHkgPyBbW1wiYnJvd3Nlck9ubHlcIiwgXCJ0cnVlXCJdXSA6IFtdLFxuICAgICAgICAuLi5vcHRzLmkxOG5LZXlTY2hlbWUgPyBbW1wiaTE4bktleVNjaGVtZVwiLCBvcHRzLmkxOG5LZXlTY2hlbWVdXSA6IFtdLFxuICAgICAgICAuLi5vcHRzLmkxOG5UYWdQcmVmaXggPyBbW1wiaTE4blRhZ1ByZWZpeFwiLCBvcHRzLmkxOG5UYWdQcmVmaXhdXSA6IFtdLFxuICAgICAgICAuLi5vcHRzLnNraXBIZWFkID8gW1tcInNraXBIZWFkXCIsIFwidHJ1ZVwiXV0gOiBbXVxuICAgICAgXSkudG9TdHJpbmcoKTtcbiAgICAgIGNvbnN0IHVybCA9IGAke3RoaXMuaG9zdH0vYXBpL3YxL2xvYWRlci9jb2RlLyR7cHJldmlldyA/IFwicHJldmlld1wiIDogXCJwdWJsaXNoZWRcIn0/JHtxdWVyeX1gO1xuICAgICAgY29uc3QgdXNlTGFzdFJlcG9uc2UgPSAoXG4gICAgICAgIC8vIFdlIGNvbnNpZGVyIHRoYXQgbWFudWFsUmVkaXJlY3QgaXMgdHJ1ZSBieSBkZWZhdWx0LCBvbmx5IGJ5IHNldHRpbmcgaXQgdG8gZmFsc2VcbiAgICAgICAgLy8gd2UgZGlzYWJsZSBpdC5cbiAgICAgICAgISh0aGlzLm9wdHMubWFudWFsUmVkaXJlY3QgPT09IGZhbHNlKSAmJiAhcHJldmlldyAmJiAhaXNCcm93c2VyXG4gICAgICApO1xuICAgICAgaWYgKHVzZUxhc3RSZXBvbnNlKSB7XG4gICAgICAgIGNvbnN0IHJlZGlyZWN0UmVzcCA9IHlpZWxkIHRoaXMuZmV0Y2godXJsLCB7XG4gICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgIGhlYWRlcnM6IHRoaXMubWFrZUdldEhlYWRlcnMoKSxcbiAgICAgICAgICByZWRpcmVjdDogXCJtYW51YWxcIlxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHJlZGlyZWN0UmVzcC5zdGF0dXMgIT09IDMwMSAmJiByZWRpcmVjdFJlc3Auc3RhdHVzICE9PSAzMDIpIHtcbiAgICAgICAgICBjb25zdCBlcnJvciA9IHlpZWxkIHRoaXMucGFyc2VKc29uUmVzcG9uc2UocmVkaXJlY3RSZXNwKTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgRXJyb3IgZmV0Y2hpbmcgbG9hZGVyIGRhdGEsIGEgcmVkaXJlY3Qgd2FzIGV4cGVjdGVkOiAkeyhfZCA9IChfYyA9IGVycm9yID09IG51bGwgPyB2b2lkIDAgOiBlcnJvci5lcnJvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLm1lc3NhZ2UpICE9IG51bGwgPyBfZCA6IHJlZGlyZWN0UmVzcC5zdGF0dXNUZXh0fWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5leHRMb2NhdGlvbiA9IHJlZGlyZWN0UmVzcC5oZWFkZXJzLmdldChcImxvY2F0aW9uXCIpO1xuICAgICAgICBpZiAoIW5leHRMb2NhdGlvbikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBFcnJvciBmZXRjaGluZyBsb2FkZXIgZGF0YSwgYSByZWRpcmVjdCB3YXMgZXhwZWN0ZWQgYnV0IG5vIGxvY2F0aW9uIGhlYWRlciB3YXMgZm91bmRgXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKChfZSA9IHRoaXMubGFzdFJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2Uua2V5KSA9PT0gbmV4dExvY2F0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubGFzdFJlc3BvbnNlLmJ1bmRsZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwMiA9IHlpZWxkIHRoaXMuZmV0Y2goYCR7dGhpcy5ob3N0fSR7bmV4dExvY2F0aW9ufWAsIHtcbiAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgaGVhZGVyczogdGhpcy5tYWtlR2V0SGVhZGVycygpXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmVzcDIuc3RhdHVzID49IDQwMCkge1xuICAgICAgICAgIGNvbnN0IGVycm9yID0geWllbGQgdGhpcy5wYXJzZUpzb25SZXNwb25zZShyZXNwMik7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEVycm9yIGZldGNoaW5nIGxvYWRlciBkYXRhOiAkeyhfZyA9IChfZiA9IGVycm9yID09IG51bGwgPyB2b2lkIDAgOiBlcnJvci5lcnJvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9mLm1lc3NhZ2UpICE9IG51bGwgPyBfZyA6IHJlc3AyLnN0YXR1c1RleHR9YFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QganNvbjIgPSB0cmFuc2Zvcm1BcGlMb2FkZXJCdW5kbGVPdXRwdXQoXG4gICAgICAgICAgeWllbGQgdGhpcy5wYXJzZUpzb25SZXNwb25zZShyZXNwMilcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5sYXN0UmVzcG9uc2UgPSB7XG4gICAgICAgICAgYnVuZGxlOiBqc29uMixcbiAgICAgICAgICBrZXk6IG5leHRMb2NhdGlvblxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ganNvbjI7XG4gICAgICB9XG4gICAgICBjb25zdCByZXNwID0geWllbGQgdGhpcy5mZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICBoZWFkZXJzOiB0aGlzLm1ha2VHZXRIZWFkZXJzKClcbiAgICAgIH0pO1xuICAgICAgaWYgKHJlc3Auc3RhdHVzID49IDQwMCkge1xuICAgICAgICBjb25zdCBlcnJvciA9IHlpZWxkIHRoaXMucGFyc2VKc29uUmVzcG9uc2UocmVzcCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgRXJyb3IgZmV0Y2hpbmcgbG9hZGVyIGRhdGE6ICR7KF9pID0gKF9oID0gZXJyb3IgPT0gbnVsbCA/IHZvaWQgMCA6IGVycm9yLmVycm9yKSA9PSBudWxsID8gdm9pZCAwIDogX2gubWVzc2FnZSkgIT0gbnVsbCA/IF9pIDogcmVzcC5zdGF0dXNUZXh0fWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGpzb24gPSB5aWVsZCB0aGlzLnBhcnNlSnNvblJlc3BvbnNlKHJlc3ApO1xuICAgICAgcmV0dXJuIHRyYW5zZm9ybUFwaUxvYWRlckJ1bmRsZU91dHB1dChqc29uKTtcbiAgICB9KTtcbiAgfVxuICBwYXJzZUpzb25SZXNwb25zZShyZXNwKSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHRleHQgPSB5aWVsZCByZXNwLnRleHQoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHRleHQpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgRXJyb3IgcGFyc2luZyBKU09OIHJlc3BvbnNlOiAke2Vycn07IHN0YXR1czogJHtyZXNwLnN0YXR1c307IHJlc3BvbnNlOiAke3RleHR9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGZldGNoSHRtbERhdGEob3B0cykge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCB7IHByb2plY3RJZCwgY29tcG9uZW50LCBlbWJlZEh5ZHJhdGUsIGh5ZHJhdGUgfSA9IG9wdHM7XG4gICAgICBjb25zdCBxdWVyeSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoW1xuICAgICAgICBbXCJwcm9qZWN0SWRcIiwgcHJvamVjdElkXSxcbiAgICAgICAgW1wiY29tcG9uZW50XCIsIGNvbXBvbmVudF0sXG4gICAgICAgIFtcImVtYmVkSHlkcmF0ZVwiLCBlbWJlZEh5ZHJhdGUgPyBcIjFcIiA6IFwiMFwiXSxcbiAgICAgICAgW1wiaHlkcmF0ZVwiLCBoeWRyYXRlID8gXCIxXCIgOiBcIjBcIl1cbiAgICAgIF0pLnRvU3RyaW5nKCk7XG4gICAgICBjb25zdCByZXNwID0geWllbGQgdGhpcy5mZXRjaChgJHt0aGlzLmhvc3R9L2FwaS92MS9sb2FkZXIvaHRtbD8ke3F1ZXJ5fWAsIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICBoZWFkZXJzOiB0aGlzLm1ha2VHZXRIZWFkZXJzKClcbiAgICAgIH0pO1xuICAgICAgY29uc3QganNvbiA9IHlpZWxkIHJlc3AuanNvbigpO1xuICAgICAgcmV0dXJuIGpzb247XG4gICAgfSk7XG4gIH1cbiAgbWFrZUdldEhlYWRlcnMoKSB7XG4gICAgcmV0dXJuIF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgIFwieC1wbGFzbWljLWxvYWRlci12ZXJzaW9uXCI6IFZFUlNJT05cbiAgICB9LCB0aGlzLm1ha2VBdXRoSGVhZGVycygpKTtcbiAgfVxuICBtYWtlQXV0aEhlYWRlcnMoKSB7XG4gICAgY29uc3QgdG9rZW5zID0gdGhpcy5vcHRzLnByb2plY3RzLm1hcCgocCkgPT4gYCR7cC5pZH06JHtwLnRva2VufWApLmpvaW4oXCIsXCIpO1xuICAgIHJldHVybiB7XG4gICAgICBcIngtcGxhc21pYy1hcGktcHJvamVjdC10b2tlbnNcIjogdG9rZW5zXG4gICAgfTtcbiAgfVxuICBnZXRDaHVua3NVcmwoYnVuZGxlLCBtb2R1bGVzKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBgJHt0aGlzLmhvc3R9L2FwaS92MS9sb2FkZXIvY2h1bmtzP2J1bmRsZUtleT0ke2VuY29kZVVSSUNvbXBvbmVudChcbiAgICAgIChfYSA9IGJ1bmRsZS5idW5kbGVLZXkpICE9IG51bGwgPyBfYSA6IFwibnVsbFwiXG4gICAgKX0mZmlsZU5hbWU9JHtlbmNvZGVVUklDb21wb25lbnQoXG4gICAgICBtb2R1bGVzLm1hcCgobSkgPT4gbS5maWxlTmFtZSkuc29ydCgpLmpvaW4oXCIsXCIpXG4gICAgKX1gO1xuICB9XG59O1xuXG4vLyBzcmMvZmV0Y2hlci50c1xudmFyIFBsYXNtaWNNb2R1bGVzRmV0Y2hlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgdGhpcy5jdXJGZXRjaCA9IHZvaWQgMDtcbiAgICB0aGlzLmFwaSA9IG5ldyBBcGkoe1xuICAgICAgcHJvamVjdHM6IG9wdHMucHJvamVjdHMsXG4gICAgICBob3N0OiBvcHRzLmhvc3QsXG4gICAgICBuYXRpdmVGZXRjaDogb3B0cy5uYXRpdmVGZXRjaCxcbiAgICAgIG1hbnVhbFJlZGlyZWN0OiBvcHRzLm1hbnVhbFJlZGlyZWN0XG4gICAgfSk7XG4gIH1cbiAgZ2V0Q2h1bmtzVXJsKGJ1bmRsZSwgbW9kdWxlcykge1xuICAgIHJldHVybiB0aGlzLmFwaS5nZXRDaHVua3NVcmwoYnVuZGxlLCBtb2R1bGVzKTtcbiAgfVxuICBmZXRjaEFsbERhdGEoKSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IGJ1bmRsZSA9IHlpZWxkIHRoaXMuZ2V0Q2FjaGVkT3JGZXRjaCgpO1xuICAgICAgdGhpcy5jYWNoZUJ1bmRsZUluTm9kZVNlcnZlcihidW5kbGUpO1xuICAgICAgcmV0dXJuIGJ1bmRsZTtcbiAgICB9KTtcbiAgfVxuICBnZXRDYWNoZWRPckZldGNoKCkge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAodGhpcy5vcHRzLmNhY2hlKSB7XG4gICAgICAgIGNvbnN0IGNhY2hlZERhdGEgPSB5aWVsZCB0aGlzLm9wdHMuY2FjaGUuZ2V0KCk7XG4gICAgICAgIGlmIChjYWNoZWREYXRhKSB7XG4gICAgICAgICAgcmV0dXJuIGNhY2hlZERhdGE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmN1ckZldGNoKSB7XG4gICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmN1ckZldGNoO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcInVuZGVmaW5lZFwiIHx8ICEoKF9hID0gcHJvY2Vzcy5lbnYpID09IG51bGwgPyB2b2lkIDAgOiBfYS5QTEFTTUlDX1FVSUVUKSkge1xuICAgICAgICBjb25zb2xlLmRlYnVnKFwiUGxhc21pYzogZG9pbmcgYSBmcmVzaCBmZXRjaC4uLlwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZldGNoUHJvbWlzZSA9IHRoaXMuZG9GZXRjaCgpO1xuICAgICAgdGhpcy5jdXJGZXRjaCA9IGZldGNoUHJvbWlzZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB5aWVsZCBmZXRjaFByb21pc2U7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKHRoaXMuY3VyRmV0Y2ggPT09IGZldGNoUHJvbWlzZSkge1xuICAgICAgICAgIHRoaXMuY3VyRmV0Y2ggPSB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBkb0ZldGNoKCkge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICBjb25zdCBkYXRhID0geWllbGQgdGhpcy5hcGkuZmV0Y2hMb2FkZXJEYXRhKFxuICAgICAgICB0aGlzLm9wdHMucHJvamVjdHMubWFwKFxuICAgICAgICAgIChwKSA9PiBwLnZlcnNpb24gPyBgJHtwLmlkfUAke3AudmVyc2lvbn1gIDogcC5pZFxuICAgICAgICApLFxuICAgICAgICB7XG4gICAgICAgICAgcGxhdGZvcm06IHRoaXMub3B0cy5wbGF0Zm9ybSxcbiAgICAgICAgICBwbGF0Zm9ybU9wdGlvbnM6IHRoaXMub3B0cy5wbGF0Zm9ybU9wdGlvbnMsXG4gICAgICAgICAgcHJldmlldzogdGhpcy5vcHRzLnByZXZpZXcsXG4gICAgICAgICAgaTE4bktleVNjaGVtZTogKF9iID0gKF9hID0gdGhpcy5vcHRzLmkxOG4pID09IG51bGwgPyB2b2lkIDAgOiBfYS5rZXlTY2hlbWUpICE9IG51bGwgPyBfYiA6IHRoaXMub3B0cy5pMThuS2V5U2NoZW1lLFxuICAgICAgICAgIGkxOG5UYWdQcmVmaXg6IChfYyA9IHRoaXMub3B0cy5pMThuKSA9PSBudWxsID8gdm9pZCAwIDogX2MudGFnUHJlZml4LFxuICAgICAgICAgIGJyb3dzZXJPbmx5OiBpc0Jyb3dzZXIsXG4gICAgICAgICAgc2tpcEhlYWQ6IHRoaXMub3B0cy5za2lwSGVhZFxuICAgICAgICB9XG4gICAgICApO1xuICAgICAgaWYgKHRoaXMub3B0cy5jYWNoZSkge1xuICAgICAgICB5aWVsZCB0aGlzLm9wdHMuY2FjaGUuc2V0KGRhdGEpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcInVuZGVmaW5lZFwiIHx8ICEoKF9kID0gcHJvY2Vzcy5lbnYpID09IG51bGwgPyB2b2lkIDAgOiBfZC5QTEFTTUlDX1FVSUVUKSkge1xuICAgICAgICBjb25zb2xlLmRlYnVnKFxuICAgICAgICAgIGBQbGFzbWljOiBmZXRjaGVkIGRlc2lnbnMgZm9yICR7ZGF0YS5wcm9qZWN0cy5tYXAoKHApID0+IGBcIiR7cC5uYW1lfVwiICgke3AuaWR9QCR7cC52ZXJzaW9ufSlgKS5qb2luKFwiLCBcIil9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSk7XG4gIH1cbiAgY2FjaGVCdW5kbGVJbk5vZGVTZXJ2ZXIoYnVuZGxlKSB7XG4gICAgaWYgKGlzQnJvd3Nlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBnbG9iYWwgPSBnbG9iYWxUaGlzO1xuICAgIGlmIChnbG9iYWwuX19QTEFTTUlDX0JVTkRMRVMgPT09IHZvaWQgMCkge1xuICAgICAgZ2xvYmFsLl9fUExBU01JQ19CVU5ETEVTID0ge307XG4gICAgfVxuICAgIGdsb2JhbC5fX1BMQVNNSUNfQlVORExFU1tnZXRCdW5kbGVLZXkodGhpcy5vcHRzKV0gPSBidW5kbGU7XG4gIH1cbn07XG5mdW5jdGlvbiBpbnRlcm5hbF9nZXRDYWNoZWRCdW5kbGVJbk5vZGVTZXJ2ZXIob3B0cykge1xuICB2YXIgX2E7XG4gIGlmIChpc0Jyb3dzZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFNob3VsZCBub3QgYmUgY29uc3VsdGluZyBOb2RlIHNlcnZlciBjYWNoZSBpbiBicm93c2VyYCk7XG4gIH1cbiAgY29uc3QgZ2xvYmFsID0gZ2xvYmFsVGhpcztcbiAgcmV0dXJuIChfYSA9IGdsb2JhbC5fX1BMQVNNSUNfQlVORExFUykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hW2dldEJ1bmRsZUtleShvcHRzKV07XG59XG5mdW5jdGlvbiBnZXRCdW5kbGVLZXkoe1xuICBob3N0LFxuICBwbGF0Zm9ybSxcbiAgaTE4bktleVNjaGVtZSxcbiAgcHJldmlldyxcbiAgcHJvamVjdHMsXG4gIHNraXBIZWFkXG59KSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgaG9zdCxcbiAgICBwbGF0Zm9ybSxcbiAgICBpMThuS2V5U2NoZW1lLFxuICAgIHByZXZpZXcsXG4gICAgcHJvamVjdHMsXG4gICAgc2tpcEhlYWRcbiAgfSk7XG59XG5leHBvcnQge1xuICBBcGksXG4gIFBsYXNtaWNNb2R1bGVzRmV0Y2hlcixcbiAgaW50ZXJuYWxfZ2V0Q2FjaGVkQnVuZGxlSW5Ob2RlU2VydmVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@plasmicapp/loader-fetcher/dist/index.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@plasmicapp/loader-react/dist/index.esm.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@plasmicapp/loader-react/dist/index.esm.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DataCtxReader: () => (/* reexport safe */ _plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.DataCtxReader),\n/* harmony export */   DataProvider: () => (/* reexport safe */ _plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.DataProvider),\n/* harmony export */   GlobalActionsContext: () => (/* reexport safe */ _plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.GlobalActionsContext),\n/* harmony export */   GlobalActionsProvider: () => (/* reexport safe */ _plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.GlobalActionsProvider),\n/* harmony export */   InternalPlasmicComponentLoader: () => (/* binding */ InternalPlasmicComponentLoader),\n/* harmony export */   PageParamsProvider: () => (/* reexport safe */ _plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.PageParamsProvider),\n/* harmony export */   PlasmicCanvasContext: () => (/* reexport safe */ _plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.PlasmicCanvasContext),\n/* harmony export */   PlasmicCanvasHost: () => (/* reexport safe */ _plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.PlasmicCanvasHost),\n/* harmony export */   PlasmicComponent: () => (/* binding */ PlasmicComponent),\n/* harmony export */   PlasmicComponentLoader: () => (/* binding */ PlasmicComponentLoader),\n/* harmony export */   PlasmicRootProvider: () => (/* binding */ PlasmicRootProvider),\n/* harmony export */   PlasmicTranslatorContext: () => (/* reexport safe */ _plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.PlasmicTranslatorContext),\n/* harmony export */   convertBundlesToComponentRenderData: () => (/* binding */ convertBundlesToComponentRenderData),\n/* harmony export */   extractPlasmicQueryData: () => (/* binding */ extractPlasmicQueryData),\n/* harmony export */   extractPlasmicQueryDataFromElement: () => (/* binding */ extractPlasmicQueryDataFromElement),\n/* harmony export */   hydrateFromElement: () => (/* binding */ hydrateFromElement),\n/* harmony export */   initPlasmicLoader: () => (/* binding */ initPlasmicLoader),\n/* harmony export */   matchesPagePath: () => (/* binding */ matchesPagePath),\n/* harmony export */   plasmicPrepass: () => (/* binding */ plasmicPrepass),\n/* harmony export */   renderToElement: () => (/* binding */ renderToElement),\n/* harmony export */   renderToString: () => (/* binding */ renderToString),\n/* harmony export */   repeatedElement: () => (/* reexport safe */ _plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.repeatedElement),\n/* harmony export */   useDataEnv: () => (/* reexport safe */ _plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.useDataEnv),\n/* harmony export */   usePlasmicCanvasContext: () => (/* reexport safe */ _plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.usePlasmicCanvasContext),\n/* harmony export */   usePlasmicComponent: () => (/* binding */ usePlasmicComponent),\n/* harmony export */   usePlasmicQueryData: () => (/* reexport safe */ _plasmicapp_query__WEBPACK_IMPORTED_MODULE_3__.usePlasmicQueryData),\n/* harmony export */   useSelector: () => (/* reexport safe */ _plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.useSelector),\n/* harmony export */   useSelectors: () => (/* reexport safe */ _plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.useSelectors)\n/* harmony export */ });\n/* harmony import */ var _plasmicapp_data_sources_context__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @plasmicapp/data-sources-context */ \"(ssr)/./node_modules/@plasmicapp/data-sources-context/dist/index.esm.js\");\n/* harmony import */ var _plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @plasmicapp/host */ \"(ssr)/./node_modules/@plasmicapp/host/dist/host.esm.js\");\n/* harmony import */ var _plasmicapp_loader_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @plasmicapp/loader-core */ \"(ssr)/./node_modules/@plasmicapp/loader-core/dist/index.esm.js\");\n/* harmony import */ var _plasmicapp_query__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @plasmicapp/query */ \"(ssr)/./node_modules/@plasmicapp/query/dist/index.esm.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var pascalcase__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! pascalcase */ \"(ssr)/./node_modules/pascalcase/index.js\");\n/* harmony import */ var pascalcase__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(pascalcase__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var _plasmicapp_loader_fetcher__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @plasmicapp/loader-fetcher */ \"(ssr)/./node_modules/@plasmicapp/loader-fetcher/dist/index.esm.js\");\n/* harmony import */ var _plasmicapp_loader_splits__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @plasmicapp/loader-splits */ \"(ssr)/./node_modules/@plasmicapp/loader-splits/dist/index.esm.js\");\n/* harmony import */ var _plasmicapp_prepass__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @plasmicapp/prepass */ \"(ssr)/./node_modules/@plasmicapp/prepass/dist/index.esm.js\");\n/* harmony import */ var react_dom_server__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! react-dom/server */ \"(ssr)/./node_modules/next/dist/compiled/react-dom/server.js\");\n/* __next_internal_client_entry_do_not_use__ DataCtxReader,DataProvider,GlobalActionsContext,GlobalActionsProvider,InternalPlasmicComponentLoader,PageParamsProvider,PlasmicCanvasContext,PlasmicCanvasHost,PlasmicComponent,PlasmicComponentLoader,PlasmicRootProvider,PlasmicTranslatorContext,convertBundlesToComponentRenderData,extractPlasmicQueryData,extractPlasmicQueryDataFromElement,hydrateFromElement,initPlasmicLoader,matchesPagePath,plasmicPrepass,renderToElement,renderToString,repeatedElement,useDataEnv,usePlasmicCanvasContext,usePlasmicComponent,usePlasmicQueryData,useSelector,useSelectors auto */ var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __spreadValues = (a, b)=>{\n    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){\n        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n    }\n    return a;\n};\nvar __spreadProps = (a, b)=>__defProps(a, __getOwnPropDescs(b));\nvar __objRest = (source, exclude)=>{\n    var target = {};\n    for(var prop in source)if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];\n    if (source != null && __getOwnPropSymbols) for (var prop of __getOwnPropSymbols(source)){\n        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop)) target[prop] = source[prop];\n    }\n    return target;\n};\nvar __async = (__this, __arguments, generator)=>{\n    return new Promise((resolve, reject)=>{\n        var fulfilled = (value)=>{\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        };\n        var rejected = (value)=>{\n            try {\n                step(generator.throw(value));\n            } catch (e) {\n                reject(e);\n            }\n        };\n        var step = (x)=>x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n        step((generator = generator.apply(__this, __arguments)).next());\n    });\n};\n// src/loader-client.ts\n\n\n\n\n\n\n\n\n\n// src/PlasmicRootProvider.tsx\n\n\n\n// src/utils.tsx\n\n\nvar isBrowser = \"undefined\" !== \"undefined\";\nfunction useForceUpdate() {\n    const [, setTick] = react__WEBPACK_IMPORTED_MODULE_4__.useState(0);\n    const update = react__WEBPACK_IMPORTED_MODULE_4__.useCallback({\n        \"useForceUpdate.useCallback[update]\": ()=>{\n            setTick({\n                \"useForceUpdate.useCallback[update]\": (tick)=>tick + 1\n            }[\"useForceUpdate.useCallback[update]\"]);\n        }\n    }[\"useForceUpdate.useCallback[update]\"], []);\n    return update;\n}\nfunction useStableLookupSpec(spec) {\n    return useStableLookupSpecs(spec)[0];\n}\nfunction useStableLookupSpecs(...specs) {\n    const [stableSpecs, setStableSpecs] = react__WEBPACK_IMPORTED_MODULE_4__.useState(specs);\n    react__WEBPACK_IMPORTED_MODULE_4__.useEffect({\n        \"useStableLookupSpecs.useEffect\": ()=>{\n            if (specs.length !== stableSpecs.length || specs.some({\n                \"useStableLookupSpecs.useEffect\": (s, i)=>!areLookupSpecsEqual(s, stableSpecs[i])\n            }[\"useStableLookupSpecs.useEffect\"])) {\n                setStableSpecs(specs);\n            }\n        }\n    }[\"useStableLookupSpecs.useEffect\"], [\n        specs,\n        stableSpecs\n    ]);\n    return stableSpecs;\n}\nfunction areLookupSpecsEqual(spec1, spec2) {\n    if (spec1 === spec2) {\n        return true;\n    }\n    if (typeof spec1 !== typeof spec2) {\n        return false;\n    }\n    const fullSpec1 = toFullLookup(spec1);\n    const fullSpec2 = toFullLookup(spec2);\n    return (isNameSpec(fullSpec1) && isNameSpec(fullSpec2) && fullSpec1.name === fullSpec2.name && fullSpec1.isCode === fullSpec2.isCode || isPathSpec(fullSpec1) && isPathSpec(fullSpec2) && fullSpec1.path === fullSpec2.path) && fullSpec1.projectId === fullSpec2.projectId;\n}\nfunction isNameSpec(lookup) {\n    return \"name\" in lookup;\n}\nfunction isPathSpec(lookup) {\n    return \"path\" in lookup;\n}\nfunction toFullLookup(lookup) {\n    const namePart = typeof lookup === \"string\" ? lookup : lookup.name;\n    const projectId = typeof lookup === \"string\" ? void 0 : lookup.projectId;\n    const codeComponent = typeof lookup === \"string\" ? void 0 : lookup.isCode;\n    if (codeComponent !== true && namePart.startsWith(\"/\")) {\n        return {\n            path: normalizePath(namePart),\n            projectId\n        };\n    } else {\n        return {\n            name: codeComponent ? namePart : normalizeName(namePart),\n            rawName: namePart.trim(),\n            projectId,\n            isCode: codeComponent\n        };\n    }\n}\nfunction normalizePath(path) {\n    return path.trim();\n}\nfunction normalizeName(name) {\n    return pascalcase__WEBPACK_IMPORTED_MODULE_8___default()(name).trim();\n}\nfunction useIsMounted() {\n    const ref = react__WEBPACK_IMPORTED_MODULE_4__.useRef(false);\n    const isMounted = react__WEBPACK_IMPORTED_MODULE_4__.useCallback({\n        \"useIsMounted.useCallback[isMounted]\": ()=>ref.current\n    }[\"useIsMounted.useCallback[isMounted]\"], []);\n    react__WEBPACK_IMPORTED_MODULE_4__.useEffect({\n        \"useIsMounted.useEffect\": ()=>{\n            ref.current = true;\n            return ({\n                \"useIsMounted.useEffect\": ()=>{\n                    ref.current = false;\n                }\n            })[\"useIsMounted.useEffect\"];\n        }\n    }[\"useIsMounted.useEffect\"], []);\n    return isMounted;\n}\nfunction matchesPagePath(pattern, path) {\n    const normalizedPattern = \"/\" + pattern.replace(/^\\/|\\/$/g, \"\");\n    const normalizedPath = \"/\" + path.replace(/^\\/|\\/$/g, \"\");\n    const regexString = normalizedPattern.replace(/\\/\\[\\[\\.\\.\\.([^\\]^]+)]]/g, \"(?:/([^]*))?\").replace(/\\/\\[\\.\\.\\.([^\\]^]+)]/g, \"/([^]*)\").replace(/\\[([^\\]^]+)]/g, \"([^/]+)\").replace(/\\//g, \"\\\\/\");\n    const regex = new RegExp(`^/?${regexString}$`);\n    const match = normalizedPath.match(regex);\n    if (!match) return false;\n    const slugNames = [\n        ...pattern.matchAll(/\\[\\.?\\.?\\.?([^[\\]]+)]/g)\n    ].map((m)=>m[1]);\n    const params = {};\n    for(let i = 0; i < slugNames.length; i++){\n        const slugName = slugNames[i];\n        const value = match[i + 1];\n        if (pattern.includes(`[[...${slugName}]]`)) {\n            params[slugName] = value ? value.split(\"/\").filter(Boolean) : [];\n        } else if (pattern.includes(`[...${slugName}]`)) {\n            params[slugName] = value.split(\"/\").filter(Boolean);\n        } else if (value !== void 0) {\n            params[slugName] = value;\n        }\n    }\n    return {\n        params\n    };\n}\nfunction isDynamicPagePath(path) {\n    return !!path.match(/\\[[^/]*\\]/);\n}\nfunction matchesCompMeta(lookup, meta) {\n    if (lookup.projectId && meta.projectId !== lookup.projectId) {\n        return false;\n    }\n    return isNameSpec(lookup) ? (lookup.name === meta.name || lookup.rawName === meta.name || lookup.rawName === meta.displayName) && (lookup.isCode == null || lookup.isCode === meta.isCode) : !!(meta.path && matchesPagePath(meta.path, lookup.path));\n}\nfunction getCompMetas(metas, lookup) {\n    const full = toFullLookup(lookup);\n    return metas.filter((meta)=>matchesCompMeta(full, meta)).map((meta)=>{\n        if (isNameSpec(full) || !meta.path) {\n            return meta;\n        }\n        const match = matchesPagePath(meta.path, full.path);\n        if (!match) {\n            return meta;\n        }\n        return __spreadProps(__spreadValues({}, meta), {\n            params: match.params\n        });\n    }).sort((meta1, meta2)=>// We sort the matched component metas by the number of path params, so\n        // if there are two pages `/products/foo` and `/products/[slug]`,\n        // the first one will have higher precedence.\n        Array.from(Object.keys(meta1.params || {})).length - Array.from(Object.keys(meta2.params || {})).length);\n}\nfunction getLookupSpecName(lookup) {\n    if (typeof lookup === \"string\") {\n        return lookup;\n    } else if (lookup.projectId) {\n        return `${lookup.name} (project ${lookup.projectId})`;\n    } else {\n        return lookup.name;\n    }\n}\nfunction MaybeWrap(props) {\n    return props.cond ? props.wrapper(props.children) : props.children;\n}\nfunction uniq(elements) {\n    return Array.from(new Set(elements));\n}\nfunction intersect(a, b) {\n    const setB = new Set(b);\n    return a.filter((elt)=>setB.has(elt));\n}\n// src/variation.ts\nfunction getPlasmicCookieValues() {\n    return Object.fromEntries(document.cookie.split(\"; \").filter((cookie)=>cookie.includes(\"plasmic:\")).map((cookie)=>cookie.split(\"=\")).map(([key, value])=>[\n            key.split(\":\")[1],\n            value\n        ]));\n}\nfunction updatePlasmicCookieValue(key, value) {\n    document.cookie = `plasmic:${key}=${value}`;\n}\nfunction ensureVariationCookies(variation = {}) {\n    Object.keys(variation).map((variationKey)=>{\n        const sliceId = variation[variationKey];\n        updatePlasmicCookieValue(variationKey, sliceId);\n    });\n}\nvar getGlobalVariantsFromSplits = (splits, variation)=>{\n    const globalVariants = [];\n    Object.keys(variation).map((variationKey)=>{\n        const [_type, splitId] = variationKey.split(\".\");\n        const sliceId = variation[variationKey];\n        const split = splits.find((s)=>s.id === splitId || s.externalId === splitId);\n        if (split) {\n            const slice = split.slices.find((s)=>s.id === sliceId || s.externalId === sliceId);\n            if (slice) {\n                slice.contents.map((x)=>{\n                    globalVariants.push({\n                        name: x.group,\n                        value: x.variant,\n                        projectId: x.projectId\n                    });\n                });\n            }\n        }\n    });\n    return globalVariants;\n};\nvar mergeGlobalVariantsSpec = (target, from)=>{\n    let result = [\n        ...target\n    ];\n    const existingGlobalVariants = new Set(target.map((t)=>{\n        var _a;\n        return `${t.name}-${(_a = t.projectId) != null ? _a : \"\"}`;\n    }));\n    const newGlobals = from.filter((t)=>{\n        var _a;\n        return !existingGlobalVariants.has(`${t.name}-${(_a = t.projectId) != null ? _a : \"\"}`);\n    });\n    if (newGlobals.length > 0) {\n        result = [\n            ...result,\n            ...newGlobals\n        ];\n    }\n    return result;\n};\n// src/PlasmicRootProvider.tsx\nvar PlasmicRootContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.createContext(void 0);\nfunction PlasmicRootProvider(props) {\n    const { globalVariants, prefetchedData, children, skipCss, skipFonts, prefetchedQueryData, suspenseForQueryData, globalContextsProps, variation, translator, Head, Link, pageRoute, pageParams, pageQuery, suspenseFallback, disableLoadingBoundary, disableRootLoadingBoundary } = props;\n    const loader = props.loader.__internal;\n    if (prefetchedData) {\n        loader.registerPrefetchedBundle(prefetchedData.bundle);\n    }\n    const [splits, setSplits] = react__WEBPACK_IMPORTED_MODULE_4__.useState(loader.getActiveSplits());\n    const forceUpdate = useForceUpdate();\n    const watcher = react__WEBPACK_IMPORTED_MODULE_4__.useMemo({\n        \"PlasmicRootProvider.useMemo[watcher]\": ()=>({\n                onDataFetched: ({\n                    \"PlasmicRootProvider.useMemo[watcher]\": ()=>{\n                        setSplits(loader.getActiveSplits());\n                        forceUpdate();\n                    }\n                })[\"PlasmicRootProvider.useMemo[watcher]\"]\n            })\n    }[\"PlasmicRootProvider.useMemo[watcher]\"], [\n        loader,\n        forceUpdate\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_4__.useEffect({\n        \"PlasmicRootProvider.useEffect\": ()=>{\n            loader.subscribePlasmicRoot(watcher);\n            return ({\n                \"PlasmicRootProvider.useEffect\": ()=>loader.unsubscribePlasmicRoot(watcher)\n            })[\"PlasmicRootProvider.useEffect\"];\n        }\n    }[\"PlasmicRootProvider.useEffect\"], [\n        watcher,\n        loader\n    ]);\n    const currentContextValue = react__WEBPACK_IMPORTED_MODULE_4__.useContext(PlasmicRootContext);\n    const { user, userAuthToken, isUserLoading, authRedirectUri } = props;\n    const value = react__WEBPACK_IMPORTED_MODULE_4__.useMemo({\n        \"PlasmicRootProvider.useMemo[value]\": ()=>{\n            var _a, _b, _c;\n            const withCurrentContextValueFallback = {\n                \"PlasmicRootProvider.useMemo[value].withCurrentContextValueFallback\": (v, key)=>{\n                    return v !== void 0 ? v : currentContextValue == null ? void 0 : currentContextValue[key];\n                }\n            }[\"PlasmicRootProvider.useMemo[value].withCurrentContextValueFallback\"];\n            return {\n                globalVariants: [\n                    ...mergeGlobalVariantsSpec(globalVariants != null ? globalVariants : [], getGlobalVariantsFromSplits(splits, variation != null ? variation : {})),\n                    ...(_a = currentContextValue == null ? void 0 : currentContextValue.globalVariants) != null ? _a : []\n                ],\n                globalContextsProps: __spreadValues(__spreadValues({}, (_b = currentContextValue == null ? void 0 : currentContextValue.globalContextsProps) != null ? _b : {}), globalContextsProps != null ? globalContextsProps : {}),\n                loader: withCurrentContextValueFallback(loader, \"loader\"),\n                variation: __spreadValues(__spreadValues({}, (_c = currentContextValue == null ? void 0 : currentContextValue.variation) != null ? _c : {}), variation != null ? variation : {}),\n                translator: withCurrentContextValueFallback(translator, \"translator\"),\n                Head: withCurrentContextValueFallback(Head, \"Head\"),\n                Link: withCurrentContextValueFallback(Link, \"Link\"),\n                user: withCurrentContextValueFallback(user, \"user\"),\n                userAuthToken: withCurrentContextValueFallback(userAuthToken, \"userAuthToken\"),\n                isUserLoading: withCurrentContextValueFallback(isUserLoading, \"isUserLoading\"),\n                authRedirectUri: withCurrentContextValueFallback(authRedirectUri, \"authRedirectUri\"),\n                suspenseFallback: withCurrentContextValueFallback(suspenseFallback, \"suspenseFallback\"),\n                disableLoadingBoundary: withCurrentContextValueFallback(disableLoadingBoundary, \"disableLoadingBoundary\")\n            };\n        }\n    }[\"PlasmicRootProvider.useMemo[value]\"], [\n        globalVariants,\n        variation,\n        globalContextsProps,\n        loader,\n        splits,\n        translator,\n        Head,\n        Link,\n        user,\n        userAuthToken,\n        isUserLoading,\n        authRedirectUri,\n        suspenseFallback,\n        disableLoadingBoundary,\n        currentContextValue\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_4__.useEffect({\n        \"PlasmicRootProvider.useEffect\": ()=>{\n            ensureVariationCookies(variation);\n            loader.trackRender({\n                renderCtx: {\n                    // We track the provider as a single entity\n                    rootComponentId: \"provider\",\n                    teamIds: loader.getTeamIds(),\n                    projectIds: loader.getProjectIds()\n                },\n                variation: value.variation\n            });\n        }\n    }[\"PlasmicRootProvider.useEffect\"], [\n        loader,\n        value\n    ]);\n    const reactMajorVersion = +react__WEBPACK_IMPORTED_MODULE_4__.version.split(\".\")[0];\n    const shouldDisableRootLoadingBoundary = disableRootLoadingBoundary != null ? disableRootLoadingBoundary : loader.getBundle().disableRootLoadingBoundaryByDefault;\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.createElement(_plasmicapp_query__WEBPACK_IMPORTED_MODULE_3__.PlasmicQueryDataProvider, {\n        prefetchedCache: prefetchedQueryData,\n        suspense: suspenseForQueryData\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.createElement(PlasmicRootContext.Provider, {\n        value\n    }, !skipCss && /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.createElement(PlasmicCss, {\n        loader,\n        prefetchedData,\n        skipFonts\n    }), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.createElement(_plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.PageParamsProvider, {\n        route: pageRoute,\n        params: pageParams,\n        query: pageQuery\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.createElement(MaybeWrap, {\n        cond: !shouldDisableRootLoadingBoundary && reactMajorVersion >= 18,\n        wrapper: (contents)=>/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.createElement(react__WEBPACK_IMPORTED_MODULE_4__.Suspense, {\n                fallback: suspenseFallback != null ? suspenseFallback : \"Loading...\"\n            }, contents)\n    }, children))));\n}\nvar PlasmicCss = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.memo(function PlasmicCss2(props) {\n    const { loader, prefetchedData, skipFonts } = props;\n    const [useScopedCss, setUseScopedCss] = react__WEBPACK_IMPORTED_MODULE_4__.useState(!!prefetchedData);\n    const builtCss = buildCss(loader, {\n        scopedCompMetas: useScopedCss && prefetchedData ? prefetchedData.bundle.components : void 0,\n        skipFonts\n    });\n    const forceUpdate = useForceUpdate();\n    const watcher = react__WEBPACK_IMPORTED_MODULE_4__.useMemo({\n        \"PlasmicCss.PlasmicCss2.useMemo[watcher]\": ()=>({\n                onDataFetched: ({\n                    \"PlasmicCss.PlasmicCss2.useMemo[watcher]\": ()=>{\n                        setUseScopedCss(false);\n                        forceUpdate();\n                    }\n                })[\"PlasmicCss.PlasmicCss2.useMemo[watcher]\"]\n            })\n    }[\"PlasmicCss.PlasmicCss2.useMemo[watcher]\"], [\n        loader,\n        forceUpdate\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_4__.useEffect({\n        \"PlasmicCss.PlasmicCss2.useEffect\": ()=>{\n            loader.subscribePlasmicRoot(watcher);\n            return ({\n                \"PlasmicCss.PlasmicCss2.useEffect\": ()=>loader.unsubscribePlasmicRoot(watcher)\n            })[\"PlasmicCss.PlasmicCss2.useEffect\"];\n        }\n    }[\"PlasmicCss.PlasmicCss2.useEffect\"], [\n        watcher,\n        loader\n    ]);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.createElement(\"style\", {\n        dangerouslySetInnerHTML: {\n            __html: builtCss\n        }\n    });\n});\nfunction buildCss(loader, opts) {\n    const { scopedCompMetas, skipFonts } = opts;\n    const cssFiles = scopedCompMetas && /* @__PURE__ */ new Set([\n        \"entrypoint.css\",\n        ...scopedCompMetas.map((c)=>c.cssFile)\n    ]);\n    const cssModules = loader.getLookup().getCss().filter((f)=>!cssFiles || cssFiles.has(f.fileName));\n    const getPri = (fileName)=>fileName === \"entrypoint.css\" ? 0 : 1;\n    const compareModules = (a, b)=>getPri(a.fileName) !== getPri(b.fileName) ? getPri(a.fileName) - getPri(b.fileName) : a.fileName.localeCompare(b.fileName);\n    cssModules.sort(compareModules);\n    const remoteFonts = loader.getLookup().getRemoteFonts();\n    return `\n    ${skipFonts ? \"\" : remoteFonts.map((f)=>`@import url('${f.url}');`).join(\"\\n\")}\n    ${cssModules.map((mod)=>mod.source).join(\"\\n\")}\n  `;\n}\nfunction usePlasmicRootContext() {\n    return react__WEBPACK_IMPORTED_MODULE_4__.useContext(PlasmicRootContext);\n}\n// src/global-variants.ts\nfunction createUseGlobalVariant(name, projectId) {\n    return ()=>{\n        var _a;\n        const rootContext = usePlasmicRootContext();\n        if (!rootContext) {\n            return void 0;\n        }\n        const loader = rootContext.loader;\n        const spec = [\n            ...loader.getGlobalVariants(),\n            ...(_a = rootContext.globalVariants) != null ? _a : []\n        ].find((spec2)=>spec2.name === name && (!spec2.projectId || spec2.projectId === projectId));\n        return spec ? spec.value : void 0;\n    };\n}\n// src/loader-shared.ts\n\n\n\n// src/bundles.ts\n\nfunction getUsedComps(allComponents, entryCompIds) {\n    const q = [\n        ...entryCompIds\n    ];\n    const seenIds = new Set(entryCompIds);\n    const componentMetaById = new Map(allComponents.map((meta)=>[\n            meta.id,\n            meta\n        ]));\n    const usedComps = [];\n    while(q.length > 0){\n        const [id] = q.splice(0, 1);\n        const meta = componentMetaById.get(id);\n        if (!meta) {\n            continue;\n        }\n        usedComps.push(meta);\n        meta.usedComponents.forEach((usedCompId)=>{\n            if (!seenIds.has(usedCompId)) {\n                seenIds.add(usedCompId);\n                q.push(usedCompId);\n            }\n        });\n    }\n    return usedComps;\n}\nfunction prepComponentData(bundle, compMetas, opts) {\n    if (compMetas.length === 0) {\n        return {\n            entryCompMetas: bundle.components,\n            bundle,\n            remoteFontUrls: []\n        };\n    }\n    const usedComps = getUsedComps(bundle.components, compMetas.map((compMeta)=>compMeta.id));\n    const compPaths = usedComps.map((compMeta)=>compMeta.entry);\n    const subBundle = (0,_plasmicapp_loader_core__WEBPACK_IMPORTED_MODULE_2__.getBundleSubset)(bundle, [\n        \"entrypoint.css\",\n        ...compPaths,\n        \"root-provider.js\",\n        ...bundle.projects.map((x)=>x.globalContextsProviderFileName).filter((x)=>!!x),\n        // We need to explicitly include global context provider components\n        // to make sure they are kept in bundle.components. That's because\n        // for esbuild, just the globalContextsProviderFileName is not enough,\n        // because it will import a chunk that includes the global context\n        // component, instead of importing that global context component's\n        // entry file. And because nothing depends on the global context component's\n        // entry file, we end up excluding the global context component from\n        // bundle.components, which then makes its substitution not work.\n        // Instead, we forcibly include it here (we'll definitely need it anyway!).\n        ...bundle.components.filter((c)=>c.isGlobalContextProvider).map((c)=>c.entry),\n        ...bundle.globalGroups.map((g)=>g.contextFile)\n    ], opts);\n    const remoteFontUrls = [];\n    subBundle.projects.forEach((p)=>remoteFontUrls.push(...p.remoteFonts.map((f)=>f.url)));\n    return {\n        entryCompMetas: compMetas,\n        bundle: subBundle,\n        remoteFontUrls\n    };\n}\nfunction mergeBundles(target, from) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const existingProjects = new Set(target.projects.map((p)=>p.id));\n    const newProjects = from.projects.filter((p)=>!existingProjects.has(p.id));\n    if (newProjects.length > 0) {\n        target = __spreadProps(__spreadValues({}, target), {\n            projects: [\n                ...target.projects,\n                ...newProjects\n            ]\n        });\n    }\n    const existingCompIds = new Set(target.components.map((c)=>c.id));\n    function shouldIncludeComponentInBundle(c) {\n        var _a2;\n        if (existingCompIds.has(c.id)) {\n            return false;\n        }\n        if (!existingProjects.has(c.projectId)) {\n            return true;\n        }\n        const targetBundleFilteredIds = (_a2 = target.filteredIds[c.projectId]) != null ? _a2 : [];\n        return targetBundleFilteredIds.includes(c.id);\n    }\n    const newCompMetas = from.components.filter((m)=>shouldIncludeComponentInBundle(m));\n    if (newCompMetas.length > 0) {\n        target = __spreadProps(__spreadValues({}, target), {\n            components: [\n                ...target.components,\n                ...newCompMetas\n            ]\n        });\n        target.filteredIds = Object.fromEntries(Object.entries(target.filteredIds).map(([k, v])=>[\n                k,\n                [\n                    ...v\n                ]\n            ]));\n        from.projects.forEach((fromProject)=>{\n            var _a2, _b2;\n            const projectId = fromProject.id;\n            const fromBundleFilteredIds = (_a2 = from.filteredIds[projectId]) != null ? _a2 : [];\n            if (!existingProjects.has(projectId)) {\n                target.filteredIds[projectId] = [\n                    ...fromBundleFilteredIds\n                ];\n            } else {\n                target.filteredIds[projectId] = intersect((_b2 = target.filteredIds[projectId]) != null ? _b2 : [], fromBundleFilteredIds);\n            }\n        });\n    }\n    const existingModules = {\n        browser: new Set(target.modules.browser.map((m)=>m.fileName)),\n        server: new Set(target.modules.server.map((m)=>m.fileName))\n    };\n    const newModules = {\n        browser: from.modules.browser.filter((m)=>!existingModules.browser.has(m.fileName)),\n        server: from.modules.server.filter((m)=>!existingModules.server.has(m.fileName))\n    };\n    if (newModules.browser.length > 0 || newModules.server.length > 0) {\n        target = __spreadProps(__spreadValues({}, target), {\n            modules: {\n                browser: [\n                    ...target.modules.browser,\n                    ...newModules.browser\n                ],\n                server: [\n                    ...target.modules.server,\n                    ...newModules.server\n                ]\n            }\n        });\n    }\n    const existingGlobalIds = new Set(target.globalGroups.map((g)=>g.id));\n    const newGlobals = from.globalGroups.filter((g)=>!existingGlobalIds.has(g.id));\n    if (newGlobals.length > 0) {\n        target = __spreadProps(__spreadValues({}, target), {\n            globalGroups: [\n                ...target.globalGroups,\n                ...newGlobals\n            ]\n        });\n    }\n    const existingSplitIds = new Set(target.activeSplits.map((s)=>s.id));\n    const newSplits = (_a = from.activeSplits.filter(// Don't include splits belonging to projects already present\n    // in the target bundle\n    (s)=>!existingSplitIds.has(s.id) && !existingProjects.has(s.projectId))) != null ? _a : [];\n    if (newSplits.length > 0) {\n        target = __spreadProps(__spreadValues({}, target), {\n            activeSplits: [\n                ...target.activeSplits,\n                ...newSplits\n            ]\n        });\n    }\n    target.bundleKey = (_c = (_b = target.bundleKey) != null ? _b : from.bundleKey) != null ? _c : null;\n    target.deferChunksByDefault = (_e = (_d = target.deferChunksByDefault) != null ? _d : from.deferChunksByDefault) != null ? _e : false;\n    target.disableRootLoadingBoundaryByDefault = (_g = (_f = target.disableRootLoadingBoundaryByDefault) != null ? _f : from.disableRootLoadingBoundaryByDefault) != null ? _g : false;\n    return target;\n}\nvar convertBundlesToComponentRenderData = (bundles, compMetas)=>{\n    if (bundles.length === 0) {\n        return null;\n    }\n    const mergedBundles = bundles.reduce((prev, cur)=>mergeBundles(prev, cur));\n    return prepComponentData(mergedBundles, compMetas);\n};\n// src/component-lookup.ts\nfunction getFirstCompMeta(metas, lookup) {\n    const filtered = getCompMetas(metas, lookup);\n    return filtered.length === 0 ? void 0 : filtered[0];\n}\nvar ComponentLookup = class {\n    constructor(bundle, registry){\n        this.bundle = bundle;\n        this.registry = registry;\n    }\n    getComponentMeta(spec) {\n        const compMeta = getFirstCompMeta(this.bundle.components, spec);\n        return compMeta;\n    }\n    getComponent(spec, opts = {}) {\n        const compMeta = getFirstCompMeta(this.bundle.components, spec);\n        if (!compMeta) {\n            throw new Error(`Component not found: ${spec}`);\n        }\n        const moduleName = compMeta.entry;\n        if (!this.registry.hasModule(moduleName, opts)) {\n            throw new Error(`Component not yet fetched: ${compMeta.name}`);\n        }\n        const entry = this.registry.load(moduleName, {\n            forceOriginal: opts.forceOriginal\n        });\n        return !opts.forceOriginal && typeof (entry == null ? void 0 : entry.getPlasmicComponent) === \"function\" ? entry.getPlasmicComponent() : entry.default;\n    }\n    hasComponent(spec) {\n        const compMeta = getFirstCompMeta(this.bundle.components, spec);\n        if (compMeta) {\n            return this.registry.hasModule(compMeta.entry);\n        }\n        return false;\n    }\n    getGlobalContexts() {\n        const customGlobalMetas = this.bundle.globalGroups.filter((m)=>m.type === \"global-user-defined\");\n        return customGlobalMetas.map((meta)=>({\n                meta,\n                context: this.registry.load(meta.contextFile).default\n            }));\n    }\n    getGlobalContextsProvider(spec) {\n        const compMeta = getFirstCompMeta(this.bundle.components, spec);\n        const projectMeta = compMeta ? this.bundle.projects.find((x)=>x.id === compMeta.projectId) : void 0;\n        if (!projectMeta || !projectMeta.globalContextsProviderFileName || !this.registry.hasModule(projectMeta.globalContextsProviderFileName)) {\n            return void 0;\n        }\n        const entry = this.registry.load(projectMeta.globalContextsProviderFileName);\n        return typeof (entry == null ? void 0 : entry.getPlasmicComponent) === \"function\" ? entry.getPlasmicComponent() : entry.default;\n    }\n    getRootProvider() {\n        const entry = this.registry.load(\"root-provider.js\");\n        return entry.default;\n    }\n    getCss() {\n        return this.bundle.modules.browser.filter((mod)=>mod.type === \"asset\" && mod.fileName.endsWith(\"css\"));\n    }\n    getRemoteFonts() {\n        return this.bundle.projects.flatMap((p)=>p.remoteFonts);\n    }\n};\n// src/loader-shared.ts\nvar SUBSTITUTED_COMPONENTS = {};\nvar REGISTERED_CODE_COMPONENT_HELPERS = {};\nvar SUBSTITUTED_GLOBAL_VARIANT_HOOKS = {};\nvar REGISTERED_CUSTOM_FUNCTIONS = {};\nfunction customFunctionImportAlias(meta) {\n    const customFunctionPrefix = `__fn_`;\n    return meta.namespace ? `${customFunctionPrefix}${meta.namespace}__${meta.name}` : `${customFunctionPrefix}${meta.name}`;\n}\nfunction parseFetchComponentDataArgs(...args) {\n    let specs;\n    let opts;\n    if (Array.isArray(args[0])) {\n        specs = args[0];\n        opts = args[1];\n    } else {\n        specs = args;\n        opts = void 0;\n    }\n    return {\n        specs,\n        opts\n    };\n}\nvar BaseInternalPlasmicComponentLoader = class {\n    constructor(args){\n        this.registry = new _plasmicapp_loader_core__WEBPACK_IMPORTED_MODULE_2__.Registry();\n        this.globalVariants = [];\n        this.subs = [];\n        this.bundle = {\n            modules: {\n                browser: [],\n                server: []\n            },\n            components: [],\n            globalGroups: [],\n            projects: [],\n            activeSplits: [],\n            bundleKey: null,\n            deferChunksByDefault: false,\n            disableRootLoadingBoundaryByDefault: false,\n            filteredIds: {}\n        };\n        this.opts = args.opts;\n        this.fetcher = args.fetcher;\n        this.tracker = args.tracker;\n        this.onBundleMerged = args.onBundleMerged;\n        this.onBundleFetched = args.onBundleFetched;\n        this.registerModules(args.builtinModules);\n    }\n    maybeGetCompMetas(...specs) {\n        const found = /* @__PURE__ */ new Set();\n        const missing = [];\n        for (const spec of specs){\n            const filteredMetas = getCompMetas(this.bundle.components, spec);\n            if (filteredMetas.length > 0) {\n                filteredMetas.forEach((meta)=>found.add(meta));\n            } else {\n                missing.push(spec);\n            }\n        }\n        return {\n            found: Array.from(found.keys()),\n            missing\n        };\n    }\n    maybeFetchComponentData(...args) {\n        return __async(this, null, function*() {\n            const { specs, opts } = parseFetchComponentDataArgs(...args);\n            const returnWithSpecsToFetch = (specsToFetch)=>__async(this, null, function*() {\n                    yield this.fetchMissingData({\n                        missingSpecs: specsToFetch\n                    });\n                    const { found: existingMetas2, missing: missingSpecs2 } = this.maybeGetCompMetas(...specs);\n                    if (missingSpecs2.length > 0) {\n                        return null;\n                    }\n                    return prepComponentData(this.bundle, existingMetas2, opts);\n                });\n            if (this.opts.alwaysFresh) {\n                return yield returnWithSpecsToFetch(specs);\n            }\n            const { found: existingMetas, missing: missingSpecs } = this.maybeGetCompMetas(...specs);\n            if (missingSpecs.length === 0) {\n                return prepComponentData(this.bundle, existingMetas, opts);\n            }\n            return yield returnWithSpecsToFetch(missingSpecs);\n        });\n    }\n    fetchComponentData(...args) {\n        return __async(this, null, function*() {\n            const { specs, opts } = parseFetchComponentDataArgs(...args);\n            const data = yield this.maybeFetchComponentData(specs, opts);\n            if (!data) {\n                const { missing: missingSpecs } = this.maybeGetCompMetas(...specs);\n                throw new Error(`Unable to find components ${missingSpecs.map(getLookupSpecName).join(\", \")}`);\n            }\n            return data;\n        });\n    }\n    fetchPages(opts) {\n        return __async(this, null, function*() {\n            this.maybeReportClientSideFetch(()=>`Plasmic: fetching all page metadata in the browser`);\n            const data = yield this.fetchAllData();\n            return data.components.filter((comp)=>comp.isPage && comp.path && ((opts == null ? void 0 : opts.includeDynamicPages) || !isDynamicPagePath(comp.path)));\n        });\n    }\n    fetchComponents() {\n        return __async(this, null, function*() {\n            this.maybeReportClientSideFetch(()=>`Plasmic: fetching all component metadata in the browser`);\n            const data = yield this.fetchAllData();\n            return data.components;\n        });\n    }\n    getActiveSplits() {\n        return this.bundle.activeSplits;\n    }\n    getChunksUrl(bundle, modules) {\n        return this.fetcher.getChunksUrl(bundle, modules);\n    }\n    fetchMissingData(opts) {\n        return __async(this, null, function*() {\n            this.maybeReportClientSideFetch(()=>`Plasmic: fetching missing components in the browser: ${opts.missingSpecs.map((spec)=>getLookupSpecName(spec)).join(\", \")}`);\n            return this.fetchAllData();\n        });\n    }\n    maybeReportClientSideFetch(mkMsg) {\n        if (isBrowser && this.opts.onClientSideFetch) {\n            const msg = mkMsg();\n            if (this.opts.onClientSideFetch === \"warn\") {\n                console.warn(msg);\n            } else {\n                throw new Error(msg);\n            }\n        }\n    }\n    fetchAllData() {\n        return __async(this, null, function*() {\n            var _a;\n            const bundle = yield this.fetcher.fetchAllData();\n            this.tracker.trackFetch();\n            this.mergeBundle(bundle);\n            (_a = this.onBundleFetched) == null ? void 0 : _a.call(this);\n            return bundle;\n        });\n    }\n    mergeBundle(newBundle) {\n        var _a, _b;\n        newBundle.bundleKey = (_a = newBundle.bundleKey) != null ? _a : null;\n        if (newBundle.bundleKey && this.bundle.bundleKey && newBundle.bundleKey !== this.bundle.bundleKey) {\n            console.warn(`Plasmic Error: Different code export hashes. This can happen if your app is using different loaders with different project IDs or project versions.\nConflicting values:\n${newBundle.bundleKey}\n${this.bundle.bundleKey}`);\n        }\n        this.bundle = mergeBundles(newBundle, this.bundle);\n        (_b = this.onBundleMerged) == null ? void 0 : _b.call(this);\n    }\n    getBundle() {\n        return this.bundle;\n    }\n    clearCache() {\n        this.bundle = {\n            modules: {\n                browser: [],\n                server: []\n            },\n            components: [],\n            globalGroups: [],\n            projects: [],\n            activeSplits: [],\n            bundleKey: null,\n            deferChunksByDefault: false,\n            disableRootLoadingBoundaryByDefault: false,\n            filteredIds: {}\n        };\n        this.registry.clear();\n    }\n    registerModules(modules) {\n        if (Object.keys(modules).some((name)=>this.registry.getRegisteredModule(name) !== modules[name])) {\n            if (!this.registry.isEmpty()) {\n                console.warn(\"Calling PlasmicComponentLoader.registerModules() after Plasmic component has rendered; starting over.\");\n                this.registry.clear();\n            }\n            for (const key of Object.keys(modules)){\n                this.registry.register(key, modules[key]);\n            }\n        }\n    }\n    substituteComponent(component, name) {\n        this.internalSubstituteComponent(component, name, void 0);\n    }\n    internalSubstituteComponent(component, name, codeComponentHelpers) {\n        if (!this.isRegistryEmpty()) {\n            console.warn(\"Calling PlasmicComponentLoader.registerSubstitution() after Plasmic component has rendered; starting over.\");\n            this.clearRegistry();\n        }\n        this.subs.push({\n            lookup: name,\n            component,\n            codeComponentHelpers\n        });\n    }\n    refreshRegistry() {\n        for (const sub of this.subs){\n            const metas = getCompMetas(this.getBundle().components, sub.lookup);\n            metas.forEach((meta)=>{\n                SUBSTITUTED_COMPONENTS[meta.id] = sub.component;\n                if (sub.codeComponentHelpers) {\n                    REGISTERED_CODE_COMPONENT_HELPERS[meta.id] = sub.codeComponentHelpers;\n                }\n            });\n        }\n        this.registry.updateModules(this.getBundle());\n    }\n    isRegistryEmpty() {\n        return this.registry.isEmpty();\n    }\n    clearRegistry() {\n        this.registry.clear();\n    }\n    setGlobalVariants(globalVariants) {\n        this.globalVariants = globalVariants;\n    }\n    getGlobalVariants() {\n        return this.globalVariants;\n    }\n    registerPrefetchedBundle(bundle) {\n        if (!isBrowser) {\n            const cachedBundle = (0,_plasmicapp_loader_fetcher__WEBPACK_IMPORTED_MODULE_9__.internal_getCachedBundleInNodeServer)(this.opts);\n            if (cachedBundle) {\n                this.mergeBundle(cachedBundle);\n            }\n        }\n        this.mergeBundle(bundle);\n    }\n    getLookup() {\n        return new ComponentLookup(this.getBundle(), this.registry);\n    }\n    trackConversion(value = 0) {\n        this.tracker.trackConversion(value);\n    }\n    getActiveVariation(opts) {\n        return __async(this, null, function*() {\n            yield this.fetchComponents();\n            return (0,_plasmicapp_loader_splits__WEBPACK_IMPORTED_MODULE_10__.getActiveVariation)(__spreadProps(__spreadValues({}, opts), {\n                splits: this.getBundle().activeSplits\n            }));\n        });\n    }\n    getTeamIds() {\n        return uniq(this.getBundle().projects.map((p)=>p.teamId ? `${p.teamId}${p.indirect ? \"@indirect\" : \"\"}` : null).filter((x)=>!!x));\n    }\n    getProjectIds() {\n        return uniq(this.getBundle().projects.map((p)=>`${p.id}${p.indirect ? \"@indirect\" : \"\"}`));\n    }\n    trackRender(opts) {\n        this.tracker.trackRender(opts);\n    }\n};\nvar PlasmicComponentLoader = class {\n    constructor(internal){\n        this.warnedRegisterComponent = false;\n        this.__internal = internal;\n    }\n    /**\n   * Sets global variants to be used for all components.  Note that\n   * this is not reactive, and will not re-render all components\n   * already mounted; instead, it should be used to activate global\n   * variants that should always be activated for the lifetime of this\n   * app.  If you'd like to reactively change the global variants,\n   * you should specify them via <PlasmicRootProvider />\n   */ setGlobalVariants(globalVariants) {\n        this.__internal.setGlobalVariants(globalVariants);\n    }\n    registerModules(modules) {\n        this.__internal.registerModules(modules);\n    }\n    /**\n   * Register custom components that should be swapped in for\n   * components defined in your project.  You can use this to\n   * swap in / substitute a Plasmic component with a \"real\" component.\n   */ substituteComponent(component, name) {\n        this.__internal.substituteComponent(component, name);\n    }\n    registerComponent(component, metaOrName) {\n        if (metaOrName && typeof metaOrName === \"object\" && \"props\" in metaOrName) {\n            this.__internal.registerComponent(component, metaOrName);\n        } else {\n            if ( true && !this.warnedRegisterComponent) {\n                console.warn(`PlasmicLoader: Using deprecated method \\`registerComponent\\` for component substitution. Please consider using \\`substituteComponent\\` instead.`);\n                this.warnedRegisterComponent = true;\n            }\n            this.substituteComponent(component, metaOrName);\n        }\n    }\n    registerFunction(fn, meta) {\n        this.__internal.registerFunction(fn, meta);\n    }\n    registerGlobalContext(context, meta) {\n        this.__internal.registerGlobalContext(context, meta);\n    }\n    registerTrait(trait, meta) {\n        this.__internal.registerTrait(trait, meta);\n    }\n    registerToken(token) {\n        this.__internal.registerToken(token);\n    }\n    fetchComponentData(...args) {\n        return this.__internal.fetchComponentData(...args);\n    }\n    maybeFetchComponentData(...args) {\n        return __async(this, null, function*() {\n            return this.__internal.maybeFetchComponentData(...args);\n        });\n    }\n    /**\n   * Returns all the page component metadata for these projects.\n   */ fetchPages(opts) {\n        return __async(this, null, function*() {\n            return this.__internal.fetchPages(opts);\n        });\n    }\n    /**\n   * Returns all components metadata for these projects.\n   */ fetchComponents() {\n        return __async(this, null, function*() {\n            return this.__internal.fetchComponents();\n        });\n    }\n    _getActiveVariation(opts) {\n        return __async(this, null, function*() {\n            return this.__internal.getActiveVariation(opts);\n        });\n    }\n    getActiveVariation(opts) {\n        return __async(this, null, function*() {\n            return this._getActiveVariation({\n                traits: opts.traits,\n                getKnownValue: (key)=>{\n                    if (opts.known) {\n                        return opts.known[key];\n                    } else {\n                        const cookies = getPlasmicCookieValues();\n                        return cookies[key];\n                    }\n                },\n                updateKnownValue: (key, value)=>{\n                    if (!opts.known) {\n                        updatePlasmicCookieValue(key, value);\n                    }\n                }\n            });\n        });\n    }\n    getChunksUrl(bundle, modules) {\n        return this.__internal.getChunksUrl(bundle, modules);\n    }\n    getExternalVariation(variation, filters) {\n        return (0,_plasmicapp_loader_splits__WEBPACK_IMPORTED_MODULE_10__.getExternalIds)(this.getActiveSplits(), variation, filters);\n    }\n    getActiveSplits() {\n        return this.__internal.getActiveSplits();\n    }\n    trackConversion(value = 0) {\n        this.__internal.trackConversion(value);\n    }\n    clearCache() {\n        return this.__internal.clearCache();\n    }\n};\n// src/loader-client.ts\nvar InternalPlasmicComponentLoader = class extends BaseInternalPlasmicComponentLoader {\n    constructor(opts){\n        const tracker = new _plasmicapp_loader_core__WEBPACK_IMPORTED_MODULE_2__.PlasmicTracker(__spreadProps(__spreadValues({}, opts), {\n            projectIds: opts.projects.map((p)=>p.id)\n        }));\n        super({\n            opts,\n            tracker,\n            fetcher: new _plasmicapp_loader_core__WEBPACK_IMPORTED_MODULE_2__.PlasmicModulesFetcher(opts),\n            onBundleMerged: ()=>{\n                this.refreshRegistry();\n            },\n            onBundleFetched: ()=>{\n                this.roots.forEach((watcher)=>{\n                    var _a;\n                    return (_a = watcher.onDataFetched) == null ? void 0 : _a.call(watcher);\n                });\n            },\n            builtinModules: {\n                react: (react__WEBPACK_IMPORTED_MODULE_4___default()),\n                \"react-dom\": (react_dom__WEBPACK_IMPORTED_MODULE_5___default()),\n                \"react/jsx-runtime\": react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__,\n                \"react/jsx-dev-runtime\": react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_6__,\n                // Also inject @plasmicapp/query and @plasmicapp/host to use the\n                // same contexts here and in loader-downloaded code.\n                \"@plasmicapp/query\": _plasmicapp_query__WEBPACK_IMPORTED_MODULE_3__,\n                \"@plasmicapp/data-sources-context\": _plasmicapp_data_sources_context__WEBPACK_IMPORTED_MODULE_0__,\n                \"@plasmicapp/host\": _plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__,\n                \"@plasmicapp/loader-runtime-registry\": {\n                    components: SUBSTITUTED_COMPONENTS,\n                    globalVariantHooks: SUBSTITUTED_GLOBAL_VARIANT_HOOKS,\n                    codeComponentHelpers: REGISTERED_CODE_COMPONENT_HELPERS,\n                    functions: REGISTERED_CUSTOM_FUNCTIONS\n                }\n            }\n        });\n        this.roots = [];\n    }\n    registerComponent(component, meta) {\n        var _a, _b;\n        const stateHelpers = Object.fromEntries(Object.entries((_a = meta.states) != null ? _a : {}).filter(([_, stateSpec])=>Object.keys(stateSpec).some((key)=>_plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.stateHelpersKeys.includes(key))).map(([stateName, stateSpec])=>[\n                stateName,\n                Object.fromEntries(_plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.stateHelpersKeys.filter((key)=>key in stateSpec).map((key)=>[\n                        key,\n                        stateSpec[key]\n                    ]))\n            ]));\n        const helpers = {\n            states: stateHelpers\n        };\n        this.internalSubstituteComponent(component, {\n            name: meta.name,\n            isCode: true\n        }, Object.keys(stateHelpers).length > 0 ? helpers : void 0);\n        (0,_plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.registerComponent)(component, __spreadValues(__spreadProps(__spreadValues({}, meta), {\n            // Import path is not used as we will use component substitution\n            importPath: (_b = meta.importPath) != null ? _b : \"\"\n        }), Object.keys(stateHelpers).length > 0 ? {\n            componentHelpers: {\n                helpers,\n                importPath: \"\",\n                importName: \"\"\n            }\n        } : {}));\n    }\n    registerFunction(fn, meta) {\n        var _a;\n        (0,_plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.registerFunction)(fn, __spreadProps(__spreadValues({}, meta), {\n            importPath: (_a = meta.importPath) != null ? _a : \"\"\n        }));\n        REGISTERED_CUSTOM_FUNCTIONS[customFunctionImportAlias(meta)] = fn;\n    }\n    registerGlobalContext(context, meta) {\n        var _a;\n        this.substituteComponent(context, {\n            name: meta.name,\n            isCode: true\n        });\n        (0,_plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.registerGlobalContext)(context, __spreadProps(__spreadValues({}, meta), {\n            importPath: (_a = meta.importPath) != null ? _a : \"\"\n        }));\n    }\n    registerTrait(trait, meta) {\n        (0,_plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.registerTrait)(trait, meta);\n    }\n    registerToken(token) {\n        (0,_plasmicapp_host__WEBPACK_IMPORTED_MODULE_1__.registerToken)(token);\n    }\n    subscribePlasmicRoot(watcher) {\n        this.roots.push(watcher);\n    }\n    unsubscribePlasmicRoot(watcher) {\n        const index = this.roots.indexOf(watcher);\n        if (index >= 0) {\n            this.roots.splice(index, 1);\n        }\n    }\n    refreshRegistry() {\n        for (const globalGroup of this.getBundle().globalGroups){\n            if (globalGroup.type !== \"global-screen\") {\n                SUBSTITUTED_GLOBAL_VARIANT_HOOKS[globalGroup.id] = createUseGlobalVariant(globalGroup.name, globalGroup.projectId);\n            }\n        }\n        super.refreshRegistry();\n    }\n};\n// src/index.ts\n\n\n// src/PlasmicComponent.tsx\n\n// src/usePlasmicComponent.tsx\n\nfunction usePlasmicComponent(spec, opts = {}) {\n    const rootContext = usePlasmicRootContext();\n    if (!rootContext) {\n        throw new Error(`You can only use usePlasmicComponent if wrapped in <PlasmicRootProvider />`);\n    }\n    const loader = rootContext.loader;\n    const lookup = loader.getLookup();\n    const component = lookup.hasComponent(spec) ? lookup.getComponent(spec, opts) : void 0;\n    const stableSpec = useStableLookupSpec(spec);\n    const isMounted = useIsMounted();\n    const forceUpdate = useForceUpdate();\n    react__WEBPACK_IMPORTED_MODULE_4__.useEffect({\n        \"usePlasmicComponent.useEffect\": ()=>{\n            if (!component) {\n                ({\n                    \"usePlasmicComponent.useEffect\": ()=>__async(this, null, {\n                            \"usePlasmicComponent.useEffect\": function*() {\n                                yield loader.fetchComponentData(stableSpec);\n                                if (isMounted()) {\n                                    forceUpdate();\n                                }\n                            }\n                        }[\"usePlasmicComponent.useEffect\"])\n                })[\"usePlasmicComponent.useEffect\"]();\n            }\n        }\n    }[\"usePlasmicComponent.useEffect\"], [\n        component,\n        stableSpec\n    ]);\n    return component;\n}\n// src/PlasmicComponent.tsx\nvar PlasmicComponentContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.createContext(false);\nfunction PlasmicComponent(props) {\n    const { component, projectId, componentProps, forceOriginal } = props;\n    const rootContext = usePlasmicRootContext();\n    const isRootLoader = !react__WEBPACK_IMPORTED_MODULE_4__.useContext(PlasmicComponentContext);\n    if (!rootContext) {\n        throw new Error(`You must use <PlasmicRootProvider/> at the root of your app`);\n    }\n    const _a = rootContext, { loader, globalContextsProps, variation, userAuthToken, isUserLoading, authRedirectUri, translator } = _a, rest = __objRest(_a, [\n        \"loader\",\n        \"globalContextsProps\",\n        \"variation\",\n        \"userAuthToken\",\n        \"isUserLoading\",\n        \"authRedirectUri\",\n        \"translator\"\n    ]);\n    const Component = usePlasmicComponent({\n        name: component,\n        projectId,\n        isCode: false\n    }, {\n        forceOriginal\n    });\n    react__WEBPACK_IMPORTED_MODULE_4__.useEffect({\n        \"PlasmicComponent.useEffect\": ()=>{\n            if (isRootLoader) {\n                const meta = loader.getLookup().getComponentMeta({\n                    name: component,\n                    projectId\n                });\n                if (meta) {\n                    loader.trackRender({\n                        renderCtx: {\n                            rootProjectId: meta.projectId,\n                            rootComponentId: meta.id,\n                            rootComponentName: component,\n                            teamIds: loader.getTeamIds(),\n                            projectIds: loader.getProjectIds()\n                        },\n                        variation\n                    });\n                }\n            }\n        }\n    }[\"PlasmicComponent.useEffect\"], [\n        component,\n        projectId,\n        loader,\n        variation\n    ]);\n    const element = react__WEBPACK_IMPORTED_MODULE_4__.useMemo({\n        \"PlasmicComponent.useMemo[element]\": ()=>{\n            var _a2;\n            if (!Component) {\n                return null;\n            }\n            let elt = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.createElement(Component, __spreadValues({}, componentProps));\n            if (isRootLoader) {\n                const lookup = loader.getLookup();\n                const ReactWebRootProvider = lookup.getRootProvider();\n                const GlobalContextsProvider = lookup.getGlobalContextsProvider({\n                    name: component,\n                    projectId\n                });\n                elt = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.createElement(ReactWebRootProvider, __spreadProps(__spreadValues({}, rest), {\n                    userAuthToken,\n                    isUserLoading,\n                    authRedirectUri,\n                    i18n: {\n                        translator,\n                        tagPrefix: (_a2 = loader.opts.i18n) == null ? void 0 : _a2.tagPrefix\n                    }\n                }), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.createElement(MaybeWrap, {\n                    cond: !!GlobalContextsProvider,\n                    wrapper: {\n                        \"PlasmicComponent.useMemo[element]\": (children)=>/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.createElement(GlobalContextsProvider, __spreadValues({}, globalContextsProps), children)\n                    }[\"PlasmicComponent.useMemo[element]\"]\n                }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.createElement(PlasmicComponentContext.Provider, {\n                    value: true\n                }, elt)));\n            }\n            return elt;\n        }\n    }[\"PlasmicComponent.useMemo[element]\"], [\n        Component,\n        componentProps,\n        loader,\n        isRootLoader,\n        component,\n        projectId,\n        globalContextsProps,\n        userAuthToken,\n        // Just use the token to memo, `user` should be derived from it\n        isUserLoading,\n        authRedirectUri\n    ]);\n    return element;\n}\n// src/prepass-client.ts\n\nfunction extractPlasmicQueryData(element) {\n    return (0,_plasmicapp_prepass__WEBPACK_IMPORTED_MODULE_11__.extractPlasmicQueryData)(element);\n}\nfunction plasmicPrepass(element) {\n    return (0,_plasmicapp_prepass__WEBPACK_IMPORTED_MODULE_11__.plasmicPrepass)(element);\n}\n// src/render.tsx\n\n\n\n\nfunction renderToElement(_0, _1, _2) {\n    return __async(this, arguments, function*(loader, target, lookup, opts = {}) {\n        return new Promise((resolve)=>{\n            const element = makeElement(loader, lookup, opts);\n            react_dom__WEBPACK_IMPORTED_MODULE_5___default().render(element, target, ()=>resolve());\n        });\n    });\n}\nfunction renderToString(loader, lookup, opts = {}) {\n    const element = makeElement(loader, lookup, opts);\n    return (0,react_dom_server__WEBPACK_IMPORTED_MODULE_12__.renderToString)(element);\n}\nfunction extractPlasmicQueryDataFromElement(_0, _1) {\n    return __async(this, arguments, function*(loader, lookup, opts = {}) {\n        const element = makeElement(loader, lookup, opts);\n        return (0,_plasmicapp_prepass__WEBPACK_IMPORTED_MODULE_11__.extractPlasmicQueryData)(element);\n    });\n}\nfunction hydrateFromElement(_0, _1, _2) {\n    return __async(this, arguments, function*(loader, target, lookup, opts = {}) {\n        return new Promise((resolve)=>{\n            const element = makeElement(loader, lookup, opts);\n            react_dom__WEBPACK_IMPORTED_MODULE_5___default().hydrate(element, target, ()=>resolve());\n        });\n    });\n}\nfunction makeElement(loader, lookup, opts = {}) {\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4___default().createElement(PlasmicRootProvider, {\n        loader,\n        prefetchedData: opts.prefetchedData,\n        globalVariants: opts.globalVariants,\n        prefetchedQueryData: opts.prefetchedQueryData,\n        pageParams: opts.pageParams,\n        pageQuery: opts.pageQuery\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4___default().createElement(PlasmicComponent, {\n        component: typeof lookup === \"string\" ? lookup : lookup.name,\n        projectId: typeof lookup === \"string\" ? void 0 : lookup.projectId,\n        componentProps: opts.componentProps\n    }));\n}\n// src/index.ts\nfunction initPlasmicLoader(opts) {\n    const internal = new InternalPlasmicComponentLoader(opts);\n    return new PlasmicComponentLoader(internal);\n}\n //# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBsYXNtaWNhcHAvbG9hZGVyLXJlYWN0L2Rpc3QvaW5kZXguZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTJDO0FBRWQ7QUFXdEI7QUFDK0M7QUFDeEI7QUFDWjtBQUNHO0FBQ1U7QUFDSDs7QUNsQk87QUFFTTtBQUNsQjs7QUNIQTtBQUNBO0FBRWhCLElBQU0sWUFBWSxPQUFPLFNBQVc7QUFvQnBDLFNBQVMsaUJBQWlCO0lBQy9CLE1BQU0sQ0FBQyxFQUFFLE9BQU8sSUFBVSw0Q0FBUyxDQUFDO0lBQ3BDLE1BQU0sU0FBZTs4Q0FBWTtZQUMvQjtzREFBUSxDQUFDLE9BQVMsT0FBTyxDQUFDOztRQUM1Qjs2Q0FBRyxDQUFDLENBQUM7SUFDTCxPQUFPO0FBQ1Q7QUFFTyxTQUFTLG9CQUFvQixNQUEyQjtJQUM3RCxPQUFPLHFCQUFxQixJQUFJLEVBQUUsQ0FBQztBQUNyQztBQUVPLFNBQVMsd0JBQXdCLE9BQThCO0lBQ3BFLE1BQU0sQ0FBQyxhQUFhLGNBQWMsSUFBVSw0Q0FBUyxLQUFLO0lBRXBEOzBDQUFVO1lBQ2QsSUFDRSxNQUFNLFdBQVcsWUFBWSxVQUM3QixNQUFNO2tEQUFLLENBQUMsR0FBRyxJQUFNLENBQUMsb0JBQW9CLEdBQUcsWUFBWSxDQUFDLENBQUMsQ0FBQztrREFDNUQ7Z0JBQ0EsZUFBZSxLQUFLO1lBQ3RCO1FBQ0Y7eUNBQUc7UUFBQztRQUFPLFdBQVc7S0FBQztJQUN2QixPQUFPO0FBQ1Q7QUFFQSxTQUFTLG9CQUNQLE9BQ0EsT0FDQTtJQUNBLElBQUksVUFBVSxPQUFPO1FBQ25CLE9BQU87SUFDVDtJQUNBLElBQUksT0FBTyxVQUFVLE9BQU8sT0FBTztRQUNqQyxPQUFPO0lBQ1Q7SUFFQSxNQUFNLFlBQVksYUFBYSxLQUFLO0lBQ3BD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bnQudHMiLCIvVXNlcnMvd29uZGVybGFuZG1pdGNoL0Nhc2NhZGVQcm9qZWN0cy9zcmMvUGxhc21pY1Jvb3RQcm92aWRlci50c3giLCIvVXNlcnMvd29uZGVybGFuZG1pdGNoL0Nhc2NhZGVQcm9qZWN0cy9zcmMvdXRpbHMudHN4IiwiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvc3JjL3ZhcmlhdGlvbi50cyIsIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL3NyYy9nbG9iYWwtdmFyaWFudHMudHMiLCIvVXNlcnMvd29uZGVybGFuZG1pdGNoL0Nhc2NhZGVQcm9qZWN0cy9zcmMvbG9hZGVyLXNoYXJlZC50cyIsIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL3NyYy9idW5kbGVzLnRzIiwiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvc3JjL2NvbXBvbmVudC1sb29rdXAudHMiLCIvVXNlcnMvd29uZGVybGFuZG1pdGNoL0Nhc2NhZGVQcm9qZWN0cy9zcmMvaW5kZXgudHMiLCIvVXNlcnMvd29uZGVybGFuZG1pdGNoL0Nhc2NhZGVQcm9qZWN0cy9zcmMvUGxhc21pY0NvbXBvbmVudC50c3giLCIvVXNlcnMvd29uZGVybGFuZG1pdGNoL0Nhc2NhZGVQcm9qZWN0cy9zcmMvdXNlUGxhc21pY0NvbXBvbmVudC50c3giLCIvVXNlcnMvd29uZGVybGFuZG1pdGNoL0Nhc2NhZGVQcm9qZWN0cy9zcmMvcHJlcGFzcy1jbGllbnQudHMiLCIvVXNlcnMvd29uZGVybGFuZG1pdGNoL0Nhc2NhZGVQcm9qZWN0cy9zcmMvcmVuZGVyLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBQbGFzbWljRGF0YVNvdXJjZXNDb250ZXh0IGZyb20gXCJAcGxhc21pY2FwcC9kYXRhLXNvdXJjZXMtY29udGV4dFwiO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtaW1wb3J0c1xuaW1wb3J0ICogYXMgUGxhc21pY0hvc3QgZnJvbSBcIkBwbGFzbWljYXBwL2hvc3RcIjtcbmltcG9ydCB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWltcG9ydHNcbiAgcmVnaXN0ZXJDb21wb25lbnQsXG4gIHJlZ2lzdGVyRnVuY3Rpb24sXG4gIHJlZ2lzdGVyR2xvYmFsQ29udGV4dCxcbiAgcmVnaXN0ZXJUb2tlbixcbiAgcmVnaXN0ZXJUcmFpdCxcbiAgc3RhdGVIZWxwZXJzS2V5cyxcbiAgVG9rZW5SZWdpc3RyYXRpb24sXG4gIFRyYWl0TWV0YSxcbn0gZnJvbSBcIkBwbGFzbWljYXBwL2hvc3RcIjtcbmltcG9ydCB7IFBsYXNtaWNNb2R1bGVzRmV0Y2hlciwgUGxhc21pY1RyYWNrZXIgfSBmcm9tIFwiQHBsYXNtaWNhcHAvbG9hZGVyLWNvcmVcIjtcbmltcG9ydCAqIGFzIFBsYXNtaWNRdWVyeSBmcm9tIFwiQHBsYXNtaWNhcHAvcXVlcnlcIjtcbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBSZWFjdERPTSBmcm9tIFwicmVhY3QtZG9tXCI7XG5pbXBvcnQgKiBhcyBqc3hEZXZSdW50aW1lIGZyb20gXCJyZWFjdC9qc3gtZGV2LXJ1bnRpbWVcIjtcbmltcG9ydCAqIGFzIGpzeFJ1bnRpbWUgZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5pbXBvcnQgeyBjcmVhdGVVc2VHbG9iYWxWYXJpYW50IH0gZnJvbSBcIi4vZ2xvYmFsLXZhcmlhbnRzXCI7XG5pbXBvcnQge1xuICBCYXNlSW50ZXJuYWxQbGFzbWljQ29tcG9uZW50TG9hZGVyLFxuICBDb2RlQ29tcG9uZW50TWV0YSxcbiAgY3VzdG9tRnVuY3Rpb25JbXBvcnRBbGlhcyxcbiAgQ3VzdG9tRnVuY3Rpb25NZXRhLFxuICBHbG9iYWxDb250ZXh0TWV0YSxcbiAgSW5pdE9wdGlvbnMsXG4gIFBsYXNtaWNSb290V2F0Y2hlcixcbiAgUkVHSVNURVJFRF9DT0RFX0NPTVBPTkVOVF9IRUxQRVJTLFxuICBSRUdJU1RFUkVEX0NVU1RPTV9GVU5DVElPTlMsXG4gIFNVQlNUSVRVVEVEX0NPTVBPTkVOVFMsXG4gIFNVQlNUSVRVVEVEX0dMT0JBTF9WQVJJQU5UX0hPT0tTLFxufSBmcm9tIFwiLi9sb2FkZXItc2hhcmVkXCI7XG5cbmV4cG9ydCBjbGFzcyBJbnRlcm5hbFBsYXNtaWNDb21wb25lbnRMb2FkZXIgZXh0ZW5kcyBCYXNlSW50ZXJuYWxQbGFzbWljQ29tcG9uZW50TG9hZGVyIHtcbiAgcHJpdmF0ZSByZWFkb25seSByb290czogUGxhc21pY1Jvb3RXYXRjaGVyW10gPSBbXTtcblxuICBjb25zdHJ1Y3RvcihvcHRzOiBJbml0T3B0aW9ucykge1xuICAgIGNvbnN0IHRyYWNrZXIgPSBuZXcgUGxhc21pY1RyYWNrZXIoe1xuICAgICAgLi4ub3B0cyxcbiAgICAgIHByb2plY3RJZHM6IG9wdHMucHJvamVjdHMubWFwKChwKSA9PiBwLmlkKSxcbiAgICB9KTtcbiAgICBzdXBlcih7XG4gICAgICBvcHRzLFxuICAgICAgdHJhY2tlcixcbiAgICAgIGZldGNoZXI6IG5ldyBQbGFzbWljTW9kdWxlc0ZldGNoZXIob3B0cyksXG4gICAgICBvbkJ1bmRsZU1lcmdlZDogKCkgPT4ge1xuICAgICAgICB0aGlzLnJlZnJlc2hSZWdpc3RyeSgpO1xuICAgICAgfSxcbiAgICAgIG9uQnVuZGxlRmV0Y2hlZDogKCkgPT4ge1xuICAgICAgICB0aGlzLnJvb3RzLmZvckVhY2goKHdhdGNoZXIpID0+IHdhdGNoZXIub25EYXRhRmV0Y2hlZD8uKCkpO1xuICAgICAgfSxcbiAgICAgIGJ1aWx0aW5Nb2R1bGVzOiB7XG4gICAgICAgIHJlYWN0OiBSZWFjdCxcbiAgICAgICAgXCJyZWFjdC1kb21cIjogUmVhY3RET00sXG4gICAgICAgIFwicmVhY3QvanN4LXJ1bnRpbWVcIjoganN4UnVudGltZSxcbiAgICAgICAgXCJyZWFjdC9qc3gtZGV2LXJ1bnRpbWVcIjoganN4RGV2UnVudGltZSxcblxuICAgICAgICAvLyBBbHNvIGluamVjdCBAcGxhc21pY2FwcC9xdWVyeSBhbmQgQHBsYXNtaWNhcHAvaG9zdCB0byB1c2UgdGhlXG4gICAgICAgIC8vIHNhbWUgY29udGV4dHMgaGVyZSBhbmQgaW4gbG9hZGVyLWRvd25sb2FkZWQgY29kZS5cbiAgICAgICAgXCJAcGxhc21pY2FwcC9xdWVyeVwiOiBQbGFzbWljUXVlcnksXG4gICAgICAgIFwiQHBsYXNtaWNhcHAvZGF0YS1zb3VyY2VzLWNvbnRleHRcIjogUGxhc21pY0RhdGFTb3VyY2VzQ29udGV4dCxcbiAgICAgICAgXCJAcGxhc21pY2FwcC9ob3N0XCI6IFBsYXNtaWNIb3N0LFxuICAgICAgICBcIkBwbGFzbWljYXBwL2xvYWRlci1ydW50aW1lLXJlZ2lzdHJ5XCI6IHtcbiAgICAgICAgICBjb21wb25lbnRzOiBTVUJTVElUVVRFRF9DT01QT05FTlRTLFxuICAgICAgICAgIGdsb2JhbFZhcmlhbnRIb29rczogU1VCU1RJVFVURURfR0xPQkFMX1ZBUklBTlRfSE9PS1MsXG4gICAgICAgICAgY29kZUNvbXBvbmVudEhlbHBlcnM6IFJFR0lTVEVSRURfQ09ERV9DT01QT05FTlRfSEVMUEVSUyxcbiAgICAgICAgICBmdW5jdGlvbnM6IFJFR0lTVEVSRURfQ1VTVE9NX0ZVTkNUSU9OUyxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICByZWdpc3RlckNvbXBvbmVudDxUIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50VHlwZTxhbnk+PihcbiAgICBjb21wb25lbnQ6IFQsXG4gICAgbWV0YTogQ29kZUNvbXBvbmVudE1ldGE8UmVhY3QuQ29tcG9uZW50UHJvcHM8VD4+XG4gICkge1xuICAgIC8vIG1ha2luZyB0aGUgY29tcG9uZW50IG1ldGEgY29uc2lzdGVudCBiZXR3ZWVuIGNvZGVnZW4gYW5kIGxvYWRlclxuICAgIGNvbnN0IHN0YXRlSGVscGVycyA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgIE9iamVjdC5lbnRyaWVzKG1ldGEuc3RhdGVzID8/IHt9KVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgICAgIC5maWx0ZXIoKFtfLCBzdGF0ZVNwZWNdKSA9PlxuICAgICAgICAgIE9iamVjdC5rZXlzKHN0YXRlU3BlYykuc29tZSgoa2V5KSA9PiBzdGF0ZUhlbHBlcnNLZXlzLmluY2x1ZGVzKGtleSkpXG4gICAgICAgIClcbiAgICAgICAgLm1hcCgoW3N0YXRlTmFtZSwgc3RhdGVTcGVjXSkgPT4gW1xuICAgICAgICAgIHN0YXRlTmFtZSxcbiAgICAgICAgICBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgICAgICBzdGF0ZUhlbHBlcnNLZXlzXG4gICAgICAgICAgICAgIC5maWx0ZXIoKGtleSkgPT4ga2V5IGluIHN0YXRlU3BlYylcbiAgICAgICAgICAgICAgLm1hcCgoa2V5KSA9PiBba2V5LCBzdGF0ZVNwZWNba2V5XV0pXG4gICAgICAgICAgKSxcbiAgICAgICAgXSlcbiAgICApO1xuICAgIGNvbnN0IGhlbHBlcnMgPSB7IHN0YXRlczogc3RhdGVIZWxwZXJzIH07XG4gICAgdGhpcy5pbnRlcm5hbFN1YnN0aXR1dGVDb21wb25lbnQoXG4gICAgICBjb21wb25lbnQsXG4gICAgICB7IG5hbWU6IG1ldGEubmFtZSwgaXNDb2RlOiB0cnVlIH0sXG4gICAgICBPYmplY3Qua2V5cyhzdGF0ZUhlbHBlcnMpLmxlbmd0aCA+IDAgPyBoZWxwZXJzIDogdW5kZWZpbmVkXG4gICAgKTtcbiAgICByZWdpc3RlckNvbXBvbmVudChjb21wb25lbnQsIHtcbiAgICAgIC4uLm1ldGEsXG4gICAgICAvLyBJbXBvcnQgcGF0aCBpcyBub3QgdXNlZCBhcyB3ZSB3aWxsIHVzZSBjb21wb25lbnQgc3Vic3RpdHV0aW9uXG4gICAgICBpbXBvcnRQYXRoOiBtZXRhLmltcG9ydFBhdGggPz8gXCJcIixcbiAgICAgIC4uLihPYmplY3Qua2V5cyhzdGF0ZUhlbHBlcnMpLmxlbmd0aCA+IDBcbiAgICAgICAgPyB7XG4gICAgICAgICAgICBjb21wb25lbnRIZWxwZXJzOiB7XG4gICAgICAgICAgICAgIGhlbHBlcnMsXG4gICAgICAgICAgICAgIGltcG9ydFBhdGg6IFwiXCIsXG4gICAgICAgICAgICAgIGltcG9ydE5hbWU6IFwiXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH1cbiAgICAgICAgOiB7fSksXG4gICAgfSk7XG4gIH1cblxuICByZWdpc3RlckZ1bmN0aW9uPEYgZXh0ZW5kcyAoLi4uYXJnczogYW55W10pID0+IGFueT4oXG4gICAgZm46IEYsXG4gICAgbWV0YTogQ3VzdG9tRnVuY3Rpb25NZXRhPEY+XG4gICkge1xuICAgIHJlZ2lzdGVyRnVuY3Rpb24oZm4sIHtcbiAgICAgIC4uLm1ldGEsXG4gICAgICBpbXBvcnRQYXRoOiBtZXRhLmltcG9ydFBhdGggPz8gXCJcIixcbiAgICB9KTtcbiAgICBSRUdJU1RFUkVEX0NVU1RPTV9GVU5DVElPTlNbY3VzdG9tRnVuY3Rpb25JbXBvcnRBbGlhcyhtZXRhKV0gPSBmbjtcbiAgfVxuXG4gIHJlZ2lzdGVyR2xvYmFsQ29udGV4dDxUIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50VHlwZTxhbnk+PihcbiAgICBjb250ZXh0OiBULFxuICAgIG1ldGE6IEdsb2JhbENvbnRleHRNZXRhPFJlYWN0LkNvbXBvbmVudFByb3BzPFQ+PlxuICApIHtcbiAgICB0aGlzLnN1YnN0aXR1dGVDb21wb25lbnQoY29udGV4dCwgeyBuYW1lOiBtZXRhLm5hbWUsIGlzQ29kZTogdHJ1ZSB9KTtcbiAgICAvLyBJbXBvcnQgcGF0aCBpcyBub3QgdXNlZCBhcyB3ZSB3aWxsIHVzZSBjb21wb25lbnQgc3Vic3RpdHV0aW9uXG4gICAgcmVnaXN0ZXJHbG9iYWxDb250ZXh0KGNvbnRleHQsIHtcbiAgICAgIC4uLm1ldGEsXG4gICAgICBpbXBvcnRQYXRoOiBtZXRhLmltcG9ydFBhdGggPz8gXCJcIixcbiAgICB9KTtcbiAgfVxuXG4gIHJlZ2lzdGVyVHJhaXQodHJhaXQ6IHN0cmluZywgbWV0YTogVHJhaXRNZXRhKSB7XG4gICAgcmVnaXN0ZXJUcmFpdCh0cmFpdCwgbWV0YSk7XG4gIH1cblxuICByZWdpc3RlclRva2VuKHRva2VuOiBUb2tlblJlZ2lzdHJhdGlvbikge1xuICAgIHJlZ2lzdGVyVG9rZW4odG9rZW4pO1xuICB9XG5cbiAgc3Vic2NyaWJlUGxhc21pY1Jvb3Qod2F0Y2hlcjogUGxhc21pY1Jvb3RXYXRjaGVyKSB7XG4gICAgdGhpcy5yb290cy5wdXNoKHdhdGNoZXIpO1xuICB9XG5cbiAgdW5zdWJzY3JpYmVQbGFzbWljUm9vdCh3YXRjaGVyOiBQbGFzbWljUm9vdFdhdGNoZXIpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMucm9vdHMuaW5kZXhPZih3YXRjaGVyKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgdGhpcy5yb290cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfVxuXG4gIHJlZnJlc2hSZWdpc3RyeSgpIHtcbiAgICAvLyBXZSBzd2FwIGdsb2JhbCB2YXJpYW50cycgdXNlWFhYR2xvYmFsVmFyaWFudCgpIGhvb2sgd2l0aFxuICAgIC8vIGEgZmFrZSBvbmUgdGhhdCBqdXN0IHJlYWRzIGZyb20gdGhlIFBsYXNtaWNSb290Q29udGV4dC4gQmVjYXVzZVxuICAgIC8vIGdsb2JhbCB2YXJpYW50IHZhbHVlcyBhcmUgbm90IHN1cHBsaWVkIGJ5IHRoZSBnZW5lcmF0ZWQgZ2xvYmFsIHZhcmlhbnRcbiAgICAvLyBjb250ZXh0IHByb3ZpZGVycywgYnV0IGluc3RlYWQgYnkgPFBsYXNtaWNSb290UHJvdmlkZXIvPiBhbmQgYnlcbiAgICAvLyBQbGFzbWljQ29tcG9uZW50TG9hZGVyLnNldEdsb2JhbFZhcmlhbnRzKCksIHdlIHJlZGlyZWN0IHRoZXNlXG4gICAgLy8gaG9va3MgdG8gcmVhZCBmcm9tIHRoZW0gaW5zdGVhZC5cbiAgICBmb3IgKGNvbnN0IGdsb2JhbEdyb3VwIG9mIHRoaXMuZ2V0QnVuZGxlKCkuZ2xvYmFsR3JvdXBzKSB7XG4gICAgICBpZiAoZ2xvYmFsR3JvdXAudHlwZSAhPT0gXCJnbG9iYWwtc2NyZWVuXCIpIHtcbiAgICAgICAgU1VCU1RJVFVURURfR0xPQkFMX1ZBUklBTlRfSE9PS1NbZ2xvYmFsR3JvdXAuaWRdID1cbiAgICAgICAgICBjcmVhdGVVc2VHbG9iYWxWYXJpYW50KGdsb2JhbEdyb3VwLm5hbWUsIGdsb2JhbEdyb3VwLnByb2plY3RJZCk7XG4gICAgICB9XG4gICAgfVxuICAgIHN1cGVyLnJlZnJlc2hSZWdpc3RyeSgpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBQbGFzbWljRGF0YVNvdXJjZUNvbnRleHRWYWx1ZSB9IGZyb20gXCJAcGxhc21pY2FwcC9kYXRhLXNvdXJjZXMtY29udGV4dFwiO1xuaW1wb3J0IHsgUGFnZVBhcmFtc1Byb3ZpZGVyIH0gZnJvbSBcIkBwbGFzbWljYXBwL2hvc3RcIjtcbmltcG9ydCB7IEFzc2V0TW9kdWxlLCBDb21wb25lbnRNZXRhLCBTcGxpdCB9IGZyb20gXCJAcGxhc21pY2FwcC9sb2FkZXItY29yZVwiO1xuaW1wb3J0IHsgUGxhc21pY1F1ZXJ5RGF0YVByb3ZpZGVyIH0gZnJvbSBcIkBwbGFzbWljYXBwL3F1ZXJ5XCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IEludGVybmFsUGxhc21pY0NvbXBvbmVudExvYWRlciB9IGZyb20gXCIuL2xvYWRlci1jbGllbnRcIjtcbmltcG9ydCB7IENvbXBvbmVudFJlbmRlckRhdGEsIFBsYXNtaWNDb21wb25lbnRMb2FkZXIgfSBmcm9tIFwiLi9sb2FkZXItc2hhcmVkXCI7XG5pbXBvcnQgeyBNYXliZVdyYXAsIHVzZUZvcmNlVXBkYXRlIH0gZnJvbSBcIi4vdXRpbHNcIjtcbmltcG9ydCB7XG4gIGVuc3VyZVZhcmlhdGlvbkNvb2tpZXMsXG4gIGdldEdsb2JhbFZhcmlhbnRzRnJvbVNwbGl0cyxcbiAgbWVyZ2VHbG9iYWxWYXJpYW50c1NwZWMsXG59IGZyb20gXCIuL3ZhcmlhdGlvblwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFBsYXNtaWNSb290Q29udGV4dFZhbHVlIGV4dGVuZHMgUGxhc21pY0RhdGFTb3VyY2VDb250ZXh0VmFsdWUge1xuICBnbG9iYWxWYXJpYW50cz86IEdsb2JhbFZhcmlhbnRTcGVjW107XG4gIGdsb2JhbENvbnRleHRzUHJvcHM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuICBsb2FkZXI6IEludGVybmFsUGxhc21pY0NvbXBvbmVudExvYWRlcjtcbiAgdmFyaWF0aW9uPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbiAgdHJhbnNsYXRvcj86IFBsYXNtaWNUcmFuc2xhdG9yO1xuICBIZWFkPzogUmVhY3QuQ29tcG9uZW50VHlwZTxhbnk+O1xuICBMaW5rPzogUmVhY3QuQ29tcG9uZW50VHlwZTxhbnk+O1xuICBkaXNhYmxlTG9hZGluZ0JvdW5kYXJ5PzogYm9vbGVhbjtcbiAgc3VzcGVuc2VGYWxsYmFjaz86IFJlYWN0LlJlYWN0Tm9kZTtcbn1cblxuY29uc3QgUGxhc21pY1Jvb3RDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dDxcbiAgUGxhc21pY1Jvb3RDb250ZXh0VmFsdWUgfCB1bmRlZmluZWRcbj4odW5kZWZpbmVkKTtcblxuZXhwb3J0IGludGVyZmFjZSBHbG9iYWxWYXJpYW50U3BlYyB7XG4gIG5hbWU6IHN0cmluZztcbiAgcHJvamVjdElkPzogc3RyaW5nO1xuICB2YWx1ZTogYW55O1xufVxuXG5leHBvcnQgdHlwZSBQbGFzbWljVHJhbnNsYXRvciA9IChcbiAgc3RyOiBzdHJpbmcsXG4gIG9wdHM/OiB7XG4gICAgY29tcG9uZW50cz86IHtcbiAgICAgIFtrZXk6IHN0cmluZ106IFJlYWN0LlJlYWN0RWxlbWVudCB8IFJlYWN0LlJlYWN0RnJhZ21lbnQ7XG4gICAgfTtcbiAgfVxuKSA9PiBSZWFjdC5SZWFjdE5vZGU7XG5cbi8qKlxuICogUGxhc21pY1Jvb3RQcm92aWRlciBzaG91bGQgYmUgdXNlZCBhdCB0aGUgcm9vdCBvZiB5b3VyIHBhZ2VcbiAqIG9yIGFwcGxpY2F0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gUGxhc21pY1Jvb3RQcm92aWRlcihcbiAgcHJvcHM6IHtcbiAgICAvKipcbiAgICAgKiBUaGUgZ2xvYmFsIFBsYXNtaWNDb21wb25lbnRMb2FkZXIgaW5zdGFuY2UgeW91IGNyZWF0ZWQgdmlhXG4gICAgICogaW5pdFBsYXNtaWNMb2FkZXIoKS5cbiAgICAgKi9cbiAgICBsb2FkZXI6IFBsYXNtaWNDb21wb25lbnRMb2FkZXI7XG5cbiAgICAvKipcbiAgICAgKiBHbG9iYWwgdmFyaWFudHMgdG8gYWN0aXZhdGUgZm9yIFBsYXNtaWMgY29tcG9uZW50c1xuICAgICAqL1xuICAgIGdsb2JhbFZhcmlhbnRzPzogR2xvYmFsVmFyaWFudFNwZWNbXTtcblxuICAgIGNoaWxkcmVuPzogUmVhY3QuUmVhY3ROb2RlO1xuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgd2lsbCBza2lwIHJlbmRlcmluZyBjc3NcbiAgICAgKi9cbiAgICBza2lwQ3NzPzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHdpbGwgc2tpcCBpbnN0YWxsaW5nIGZvbnRzXG4gICAgICovXG4gICAgc2tpcEZvbnRzPzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIElmIHlvdSBoYXZlIHByZS1mZXRjaGVkIGNvbXBvbmVudCBkYXRhIHZpYSBQbGFzbWljQ29tcG9uZW50TG9hZGVyLFxuICAgICAqIHlvdSBjYW4gcGFzcyB0aGVtIGluIGhlcmU7IFBsYXNtaWNDb21wb25lbnQgd2lsbCBhdm9pZCBmZXRjaGluZ1xuICAgICAqIGNvbXBvbmVudCBkYXRhIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gcHJlLWZldGNoZWQuXG4gICAgICovXG4gICAgcHJlZmV0Y2hlZERhdGE/OiBDb21wb25lbnRSZW5kZXJEYXRhO1xuXG4gICAgLyoqXG4gICAgICogSWYgeW91IGhhdmUgcHJlLWZldGNoZWQgZGF0YSB0aGF0IGFyZSBuZWVkZWQgYnkgdXNlUGxhc21pY1F1ZXJ5RGF0YSgpLFxuICAgICAqIHRoZW4gcGFzcyBpbiB0aGUgcHJlLWZldGNoZWQgY2FjaGUgaGVyZSwgbWFwcGluZyBxdWVyeSBrZXkgdG8gZmV0Y2hlZCBkYXRhLlxuICAgICAqL1xuICAgIHByZWZldGNoZWRRdWVyeURhdGE/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuXG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHdoZXRoZXIgdXNlUGxhc21pY1F1ZXJ5RGF0YSgpIHNob3VsZCBiZSBvcGVyYXRpbmcgaW4gc3VzcGVuc2UgbW9kZVxuICAgICAqICh0aHJvd2luZyBwcm9taXNlcykuXG4gICAgICovXG4gICAgc3VzcGVuc2VGb3JRdWVyeURhdGE/OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgeW91ciBHbG9iYWwgQ29udGV4dHMgUHJvdmlkZXIgcHJvcHMuIFRoaXMgaXMgYSBtYXAgZnJvbVxuICAgICAqIGdsb2JhbENvbnRleHRDb21wb25lbnROYW1lUHJvcHMgdG8gb2JqZWN0IG9mIHByb3BzIHRvIHVzZSBmb3IgdGhhdFxuICAgICAqIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBnbG9iYWxDb250ZXh0c1Byb3BzPzogUmVjb3JkPHN0cmluZywgYW55PjtcblxuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyBhIG1hcHBpbmcgb2Ygc3BsaXQgaWQgdG8gc2xpY2UgaWQgdGhhdCBzaG91bGQgYmUgYWN0aXZhdGVkXG4gICAgICovXG4gICAgdmFyaWF0aW9uPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcblxuICAgIC8qKlxuICAgICAqIFRyYW5zbGF0b3IgZnVuY3Rpb24gdG8gYmUgdXNlZCBmb3IgdGV4dCBibG9ja3NcbiAgICAgKi9cbiAgICB0cmFuc2xhdG9yPzogUGxhc21pY1RyYW5zbGF0b3I7XG5cbiAgICAvKipcbiAgICAgKiBIZWFkIGNvbXBvbmVudCB0byB1c2UgaW4gUGxhc21pY0hlYWQgY29tcG9uZW50IChlLmcuIEhlYWQgZnJvbSBuZXh0L2hlYWRcbiAgICAgKiBvciBIZWxtZXQgZnJvbSByZWFjdC1oZWxtZXQpLlxuICAgICAqL1xuICAgIEhlYWQ/OiBSZWFjdC5Db21wb25lbnRUeXBlPGFueT47XG5cbiAgICAvKipcbiAgICAgKiBMaW5rIGNvbXBvbmVudCB0byB1c2UuIENhbiBiZSBhbnkgY29tcG9uZW50IHRoYXQgdGFrZXMgaW4gcHJvcHMgcGFzc2VkXG4gICAgICogdG8gYW4gPGEvPiB0YWcuXG4gICAgICovXG4gICAgTGluaz86IFJlYWN0LkNvbXBvbmVudFR5cGU8YW55PjtcblxuICAgIC8qKlxuICAgICAqIFBhZ2Ugcm91dGUgd2l0aG91dCBwYXJhbXMgc3Vic3RpdHV0aW9uIChlLmcuIC9wcm9kdWN0cy9bc2x1Z10pLlxuICAgICAqL1xuICAgIHBhZ2VSb3V0ZT86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFBhZ2UgcGF0aCBwYXJhbWV0ZXJzIChlLmcuIHtzbHVnOiBcImZvb1wifSBpZiBwYWdlIHBhdGggaXNcbiAgICAgKiAvcHJvZHVjdHMvW3NsdWddIGFuZCBVUkkgaXMgL3Byb2R1Y3RzL2ZvbykuXG4gICAgICovXG4gICAgcGFnZVBhcmFtcz86IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IHN0cmluZ1tdIHwgdW5kZWZpbmVkPjtcblxuICAgIC8qKlxuICAgICAqIFBhZ2UgcXVlcnkgcGFyYW1ldGVycyAoZS5nLiB7cTogXCJmb29cIn0gaWYgcGFnZSBwYXRoIGlzXG4gICAgICogL3NvbWUvcGF0aD9xPWZvbykuXG4gICAgICovXG4gICAgcGFnZVF1ZXJ5PzogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgc3RyaW5nW10gfCB1bmRlZmluZWQ+O1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGludGVybmFsIFBsYXNtaWMgUmVhY3QuU3VzcGVuc2UgYm91bmRhcmllcyBzaG91bGQgYmUgcmVtb3ZlZFxuICAgICAqL1xuICAgIGRpc2FibGVMb2FkaW5nQm91bmRhcnk/OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIHJvb3QgUmVhY3QuU3VzcGVuc2UgYm91bmRhcnkgc2hvdWxkIGJlIHJlbW92ZWRcbiAgICAgKi9cbiAgICBkaXNhYmxlUm9vdExvYWRpbmdCb3VuZGFyeT86IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogRmFsbGJhY2sgdmFsdWUgZm9yIFJlYWN0LlN1c3BlbnNlIGJvdW5kYXJ5XG4gICAgICovXG4gICAgc3VzcGVuc2VGYWxsYmFjaz86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgfSAmIFBsYXNtaWNEYXRhU291cmNlQ29udGV4dFZhbHVlXG4pIHtcbiAgY29uc3Qge1xuICAgIGdsb2JhbFZhcmlhbnRzLFxuICAgIHByZWZldGNoZWREYXRhLFxuICAgIGNoaWxkcmVuLFxuICAgIHNraXBDc3MsXG4gICAgc2tpcEZvbnRzLFxuICAgIHByZWZldGNoZWRRdWVyeURhdGEsXG4gICAgc3VzcGVuc2VGb3JRdWVyeURhdGEsXG4gICAgZ2xvYmFsQ29udGV4dHNQcm9wcyxcbiAgICB2YXJpYXRpb24sXG4gICAgdHJhbnNsYXRvcixcbiAgICBIZWFkLFxuICAgIExpbmssXG4gICAgcGFnZVJvdXRlLFxuICAgIHBhZ2VQYXJhbXMsXG4gICAgcGFnZVF1ZXJ5LFxuICAgIHN1c3BlbnNlRmFsbGJhY2ssXG4gICAgZGlzYWJsZUxvYWRpbmdCb3VuZGFyeSxcbiAgICBkaXNhYmxlUm9vdExvYWRpbmdCb3VuZGFyeSxcbiAgfSA9IHByb3BzO1xuICBjb25zdCBsb2FkZXIgPSAocHJvcHMubG9hZGVyIGFzIGFueSlcbiAgICAuX19pbnRlcm5hbCBhcyBJbnRlcm5hbFBsYXNtaWNDb21wb25lbnRMb2FkZXI7XG5cbiAgaWYgKHByZWZldGNoZWREYXRhKSB7XG4gICAgbG9hZGVyLnJlZ2lzdGVyUHJlZmV0Y2hlZEJ1bmRsZShwcmVmZXRjaGVkRGF0YS5idW5kbGUpO1xuICB9XG5cbiAgY29uc3QgW3NwbGl0cywgc2V0U3BsaXRzXSA9IFJlYWN0LnVzZVN0YXRlPFNwbGl0W10+KGxvYWRlci5nZXRBY3RpdmVTcGxpdHMoKSk7XG4gIGNvbnN0IGZvcmNlVXBkYXRlID0gdXNlRm9yY2VVcGRhdGUoKTtcbiAgY29uc3Qgd2F0Y2hlciA9IFJlYWN0LnVzZU1lbW8oXG4gICAgKCkgPT4gKHtcbiAgICAgIG9uRGF0YUZldGNoZWQ6ICgpID0+IHtcbiAgICAgICAgc2V0U3BsaXRzKGxvYWRlci5nZXRBY3RpdmVTcGxpdHMoKSk7XG4gICAgICAgIGZvcmNlVXBkYXRlKCk7XG4gICAgICB9LFxuICAgIH0pLFxuICAgIFtsb2FkZXIsIGZvcmNlVXBkYXRlXVxuICApO1xuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbG9hZGVyLnN1YnNjcmliZVBsYXNtaWNSb290KHdhdGNoZXIpO1xuICAgIHJldHVybiAoKSA9PiBsb2FkZXIudW5zdWJzY3JpYmVQbGFzbWljUm9vdCh3YXRjaGVyKTtcbiAgfSwgW3dhdGNoZXIsIGxvYWRlcl0pO1xuXG4gIGNvbnN0IGN1cnJlbnRDb250ZXh0VmFsdWUgPSBSZWFjdC51c2VDb250ZXh0KFBsYXNtaWNSb290Q29udGV4dCk7XG5cbiAgY29uc3QgeyB1c2VyLCB1c2VyQXV0aFRva2VuLCBpc1VzZXJMb2FkaW5nLCBhdXRoUmVkaXJlY3RVcmkgfSA9IHByb3BzO1xuXG4gIGNvbnN0IHZhbHVlID0gUmVhY3QudXNlTWVtbzxQbGFzbWljUm9vdENvbnRleHRWYWx1ZT4oKCkgPT4ge1xuICAgIC8vIEZhbGxiYWNrIHRvIHRoZSB2YWx1ZSBpbiBgY3VycmVudENvbnRleHRWYWx1ZWAgaWYgbm9uZSBpcyBwcm92aWRlZFxuICAgIGNvbnN0IHdpdGhDdXJyZW50Q29udGV4dFZhbHVlRmFsbGJhY2sgPSA8XG4gICAgICBLIGV4dGVuZHMga2V5b2YgUGxhc21pY1Jvb3RDb250ZXh0VmFsdWVcbiAgICA+KFxuICAgICAgdjogUGxhc21pY1Jvb3RDb250ZXh0VmFsdWVbS10sXG4gICAgICBrZXk6IEtcbiAgICApOiBQbGFzbWljUm9vdENvbnRleHRWYWx1ZVtLXSA9PiB7XG4gICAgICByZXR1cm4gKHYgIT09IHVuZGVmaW5lZCA/IHYgOiBjdXJyZW50Q29udGV4dFZhbHVlPy5ba2V5XSkhO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIGdsb2JhbFZhcmlhbnRzOiBbXG4gICAgICAgIC4uLm1lcmdlR2xvYmFsVmFyaWFudHNTcGVjKFxuICAgICAgICAgIGdsb2JhbFZhcmlhbnRzID8/IFtdLFxuICAgICAgICAgIGdldEdsb2JhbFZhcmlhbnRzRnJvbVNwbGl0cyhzcGxpdHMsIHZhcmlhdGlvbiA/PyB7fSlcbiAgICAgICAgKSxcbiAgICAgICAgLi4uKGN1cnJlbnRDb250ZXh0VmFsdWU/Lmdsb2JhbFZhcmlhbnRzID8/IFtdKSxcbiAgICAgIF0sXG4gICAgICBnbG9iYWxDb250ZXh0c1Byb3BzOiB7XG4gICAgICAgIC4uLihjdXJyZW50Q29udGV4dFZhbHVlPy5nbG9iYWxDb250ZXh0c1Byb3BzID8/IHt9KSxcbiAgICAgICAgLi4uKGdsb2JhbENvbnRleHRzUHJvcHMgPz8ge30pLFxuICAgICAgfSxcbiAgICAgIGxvYWRlcjogd2l0aEN1cnJlbnRDb250ZXh0VmFsdWVGYWxsYmFjayhsb2FkZXIsIFwibG9hZGVyXCIpLFxuICAgICAgdmFyaWF0aW9uOiB7XG4gICAgICAgIC4uLihjdXJyZW50Q29udGV4dFZhbHVlPy52YXJpYXRpb24gPz8ge30pLFxuICAgICAgICAuLi4odmFyaWF0aW9uID8/IHt9KSxcbiAgICAgIH0sXG4gICAgICB0cmFuc2xhdG9yOiB3aXRoQ3VycmVudENvbnRleHRWYWx1ZUZhbGxiYWNrKHRyYW5zbGF0b3IsIFwidHJhbnNsYXRvclwiKSxcbiAgICAgIEhlYWQ6IHdpdGhDdXJyZW50Q29udGV4dFZhbHVlRmFsbGJhY2soSGVhZCwgXCJIZWFkXCIpLFxuICAgICAgTGluazogd2l0aEN1cnJlbnRDb250ZXh0VmFsdWVGYWxsYmFjayhMaW5rLCBcIkxpbmtcIiksXG4gICAgICB1c2VyOiB3aXRoQ3VycmVudENvbnRleHRWYWx1ZUZhbGxiYWNrKHVzZXIsIFwidXNlclwiKSxcbiAgICAgIHVzZXJBdXRoVG9rZW46IHdpdGhDdXJyZW50Q29udGV4dFZhbHVlRmFsbGJhY2soXG4gICAgICAgIHVzZXJBdXRoVG9rZW4sXG4gICAgICAgIFwidXNlckF1dGhUb2tlblwiXG4gICAgICApLFxuICAgICAgaXNVc2VyTG9hZGluZzogd2l0aEN1cnJlbnRDb250ZXh0VmFsdWVGYWxsYmFjayhcbiAgICAgICAgaXNVc2VyTG9hZGluZyxcbiAgICAgICAgXCJpc1VzZXJMb2FkaW5nXCJcbiAgICAgICksXG4gICAgICBhdXRoUmVkaXJlY3RVcmk6IHdpdGhDdXJyZW50Q29udGV4dFZhbHVlRmFsbGJhY2soXG4gICAgICAgIGF1dGhSZWRpcmVjdFVyaSxcbiAgICAgICAgXCJhdXRoUmVkaXJlY3RVcmlcIlxuICAgICAgKSxcbiAgICAgIHN1c3BlbnNlRmFsbGJhY2s6IHdpdGhDdXJyZW50Q29udGV4dFZhbHVlRmFsbGJhY2soXG4gICAgICAgIHN1c3BlbnNlRmFsbGJhY2ssXG4gICAgICAgIFwic3VzcGVuc2VGYWxsYmFja1wiXG4gICAgICApLFxuICAgICAgZGlzYWJsZUxvYWRpbmdCb3VuZGFyeTogd2l0aEN1cnJlbnRDb250ZXh0VmFsdWVGYWxsYmFjayhcbiAgICAgICAgZGlzYWJsZUxvYWRpbmdCb3VuZGFyeSxcbiAgICAgICAgXCJkaXNhYmxlTG9hZGluZ0JvdW5kYXJ5XCJcbiAgICAgICksXG4gICAgfTtcbiAgfSwgW1xuICAgIGdsb2JhbFZhcmlhbnRzLFxuICAgIHZhcmlhdGlvbixcbiAgICBnbG9iYWxDb250ZXh0c1Byb3BzLFxuICAgIGxvYWRlcixcbiAgICBzcGxpdHMsXG4gICAgdHJhbnNsYXRvcixcbiAgICBIZWFkLFxuICAgIExpbmssXG4gICAgdXNlcixcbiAgICB1c2VyQXV0aFRva2VuLFxuICAgIGlzVXNlckxvYWRpbmcsXG4gICAgYXV0aFJlZGlyZWN0VXJpLFxuICAgIHN1c3BlbnNlRmFsbGJhY2ssXG4gICAgZGlzYWJsZUxvYWRpbmdCb3VuZGFyeSxcbiAgICBjdXJyZW50Q29udGV4dFZhbHVlLFxuICBdKTtcblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGVuc3VyZVZhcmlhdGlvbkNvb2tpZXModmFyaWF0aW9uKTtcbiAgICBsb2FkZXIudHJhY2tSZW5kZXIoe1xuICAgICAgcmVuZGVyQ3R4OiB7XG4gICAgICAgIC8vIFdlIHRyYWNrIHRoZSBwcm92aWRlciBhcyBhIHNpbmdsZSBlbnRpdHlcbiAgICAgICAgcm9vdENvbXBvbmVudElkOiBcInByb3ZpZGVyXCIsXG4gICAgICAgIHRlYW1JZHM6IGxvYWRlci5nZXRUZWFtSWRzKCksXG4gICAgICAgIHByb2plY3RJZHM6IGxvYWRlci5nZXRQcm9qZWN0SWRzKCksXG4gICAgICB9LFxuICAgICAgdmFyaWF0aW9uOiB2YWx1ZS52YXJpYXRpb24sXG4gICAgfSk7XG4gIH0sIFtsb2FkZXIsIHZhbHVlXSk7XG5cbiAgY29uc3QgcmVhY3RNYWpvclZlcnNpb24gPSArUmVhY3QudmVyc2lvbi5zcGxpdChcIi5cIilbMF07XG5cbiAgY29uc3Qgc2hvdWxkRGlzYWJsZVJvb3RMb2FkaW5nQm91bmRhcnkgPVxuICAgIGRpc2FibGVSb290TG9hZGluZ0JvdW5kYXJ5ID8/XG4gICAgbG9hZGVyLmdldEJ1bmRsZSgpLmRpc2FibGVSb290TG9hZGluZ0JvdW5kYXJ5QnlEZWZhdWx0O1xuXG4gIHJldHVybiAoXG4gICAgPFBsYXNtaWNRdWVyeURhdGFQcm92aWRlclxuICAgICAgcHJlZmV0Y2hlZENhY2hlPXtwcmVmZXRjaGVkUXVlcnlEYXRhfVxuICAgICAgc3VzcGVuc2U9e3N1c3BlbnNlRm9yUXVlcnlEYXRhfVxuICAgID5cbiAgICAgIDxQbGFzbWljUm9vdENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3ZhbHVlfT5cbiAgICAgICAgeyFza2lwQ3NzICYmIChcbiAgICAgICAgICA8UGxhc21pY0Nzc1xuICAgICAgICAgICAgbG9hZGVyPXtsb2FkZXJ9XG4gICAgICAgICAgICBwcmVmZXRjaGVkRGF0YT17cHJlZmV0Y2hlZERhdGF9XG4gICAgICAgICAgICBza2lwRm9udHM9e3NraXBGb250c31cbiAgICAgICAgICAvPlxuICAgICAgICApfVxuICAgICAgICA8UGFnZVBhcmFtc1Byb3ZpZGVyXG4gICAgICAgICAgcm91dGU9e3BhZ2VSb3V0ZX1cbiAgICAgICAgICBwYXJhbXM9e3BhZ2VQYXJhbXN9XG4gICAgICAgICAgcXVlcnk9e3BhZ2VRdWVyeX1cbiAgICAgICAgPlxuICAgICAgICAgIDxNYXliZVdyYXBcbiAgICAgICAgICAgIGNvbmQ9eyFzaG91bGREaXNhYmxlUm9vdExvYWRpbmdCb3VuZGFyeSAmJiByZWFjdE1ham9yVmVyc2lvbiA+PSAxOH1cbiAgICAgICAgICAgIHdyYXBwZXI9eyhjb250ZW50cykgPT4gKFxuICAgICAgICAgICAgICA8UmVhY3QuU3VzcGVuc2UgZmFsbGJhY2s9e3N1c3BlbnNlRmFsbGJhY2sgPz8gXCJMb2FkaW5nLi4uXCJ9PlxuICAgICAgICAgICAgICAgIHtjb250ZW50c31cbiAgICAgICAgICAgICAgPC9SZWFjdC5TdXNwZW5zZT5cbiAgICAgICAgICAgICl9XG4gICAgICAgICAgPlxuICAgICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICAgIDwvTWF5YmVXcmFwPlxuICAgICAgICA8L1BhZ2VQYXJhbXNQcm92aWRlcj5cbiAgICAgIDwvUGxhc21pY1Jvb3RDb250ZXh0LlByb3ZpZGVyPlxuICAgIDwvUGxhc21pY1F1ZXJ5RGF0YVByb3ZpZGVyPlxuICApO1xufVxuXG4vKipcbiAqIEluamVjdCBhbGwgY3NzIG1vZHVsZXMgYXMgPHN0eWxlLz4gdGFncy4gV2UgY2FuJ3QgdXNlIHRoZSB1c3VhbCBzdHlsZUluamVjdG9yIHBvc3Rjc3NcbiAqIHVzZXMgYmVjYXVzZSB0aGF0IGRvZXNuJ3Qgd29yayBvbiB0aGUgc2VydmVyIHNpZGUgZm9yIFNTUi5cbiAqL1xuY29uc3QgUGxhc21pY0NzcyA9IFJlYWN0Lm1lbW8oZnVuY3Rpb24gUGxhc21pY0Nzcyhwcm9wczoge1xuICBsb2FkZXI6IEludGVybmFsUGxhc21pY0NvbXBvbmVudExvYWRlcjtcbiAgcHJlZmV0Y2hlZERhdGE/OiBDb21wb25lbnRSZW5kZXJEYXRhO1xuICBza2lwRm9udHM/OiBib29sZWFuO1xufSkge1xuICBjb25zdCB7IGxvYWRlciwgcHJlZmV0Y2hlZERhdGEsIHNraXBGb250cyB9ID0gcHJvcHM7XG4gIGNvbnN0IFt1c2VTY29wZWRDc3MsIHNldFVzZVNjb3BlZENzc10gPSBSZWFjdC51c2VTdGF0ZSghIXByZWZldGNoZWREYXRhKTtcbiAgY29uc3QgYnVpbHRDc3MgPSBidWlsZENzcyhsb2FkZXIsIHtcbiAgICBzY29wZWRDb21wTWV0YXM6XG4gICAgICB1c2VTY29wZWRDc3MgJiYgcHJlZmV0Y2hlZERhdGFcbiAgICAgICAgPyBwcmVmZXRjaGVkRGF0YS5idW5kbGUuY29tcG9uZW50c1xuICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICBza2lwRm9udHMsXG4gIH0pO1xuICBjb25zdCBmb3JjZVVwZGF0ZSA9IHVzZUZvcmNlVXBkYXRlKCk7XG4gIGNvbnN0IHdhdGNoZXIgPSBSZWFjdC51c2VNZW1vKFxuICAgICgpID0+ICh7XG4gICAgICBvbkRhdGFGZXRjaGVkOiAoKSA9PiB7XG4gICAgICAgIC8vIElmIG5ldyBkYXRhIGhhcyBiZWVuIGZldGNoZWQsIHRoZW4gdXNlIGFsbCB0aGUgZmV0Y2hlZCBjc3NcbiAgICAgICAgc2V0VXNlU2NvcGVkQ3NzKGZhbHNlKTtcbiAgICAgICAgZm9yY2VVcGRhdGUoKTtcbiAgICAgIH0sXG4gICAgfSksXG4gICAgW2xvYWRlciwgZm9yY2VVcGRhdGVdXG4gICk7XG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBsb2FkZXIuc3Vic2NyaWJlUGxhc21pY1Jvb3Qod2F0Y2hlcik7XG4gICAgcmV0dXJuICgpID0+IGxvYWRlci51bnN1YnNjcmliZVBsYXNtaWNSb290KHdhdGNoZXIpO1xuICB9LCBbd2F0Y2hlciwgbG9hZGVyXSk7XG5cbiAgcmV0dXJuIDxzdHlsZSBkYW5nZXJvdXNseVNldElubmVySFRNTD17eyBfX2h0bWw6IGJ1aWx0Q3NzIH19IC8+O1xufSk7XG5cbmZ1bmN0aW9uIGJ1aWxkQ3NzKFxuICBsb2FkZXI6IEludGVybmFsUGxhc21pY0NvbXBvbmVudExvYWRlcixcbiAgb3B0czoge1xuICAgIHNjb3BlZENvbXBNZXRhcz86IENvbXBvbmVudE1ldGFbXTtcbiAgICBza2lwRm9udHM/OiBib29sZWFuO1xuICB9XG4pIHtcbiAgY29uc3QgeyBzY29wZWRDb21wTWV0YXMsIHNraXBGb250cyB9ID0gb3B0cztcbiAgY29uc3QgY3NzRmlsZXMgPVxuICAgIHNjb3BlZENvbXBNZXRhcyAmJlxuICAgIG5ldyBTZXQ8c3RyaW5nPihbXG4gICAgICBcImVudHJ5cG9pbnQuY3NzXCIsXG4gICAgICAuLi5zY29wZWRDb21wTWV0YXMubWFwKChjKSA9PiBjLmNzc0ZpbGUpLFxuICAgIF0pO1xuICBjb25zdCBjc3NNb2R1bGVzID0gbG9hZGVyXG4gICAgLmdldExvb2t1cCgpXG4gICAgLmdldENzcygpXG4gICAgLmZpbHRlcigoZikgPT4gIWNzc0ZpbGVzIHx8IGNzc0ZpbGVzLmhhcyhmLmZpbGVOYW1lKSk7XG5cbiAgY29uc3QgZ2V0UHJpID0gKGZpbGVOYW1lOiBzdHJpbmcpID0+IChmaWxlTmFtZSA9PT0gXCJlbnRyeXBvaW50LmNzc1wiID8gMCA6IDEpO1xuICBjb25zdCBjb21wYXJlTW9kdWxlcyA9IChhOiBBc3NldE1vZHVsZSwgYjogQXNzZXRNb2R1bGUpID0+XG4gICAgZ2V0UHJpKGEuZmlsZU5hbWUpICE9PSBnZXRQcmkoYi5maWxlTmFtZSlcbiAgICAgID8gZ2V0UHJpKGEuZmlsZU5hbWUpIC0gZ2V0UHJpKGIuZmlsZU5hbWUpXG4gICAgICA6IGEuZmlsZU5hbWUubG9jYWxlQ29tcGFyZShiLmZpbGVOYW1lKTtcbiAgY3NzTW9kdWxlcy5zb3J0KGNvbXBhcmVNb2R1bGVzKTtcblxuICBjb25zdCByZW1vdGVGb250cyA9IGxvYWRlci5nZXRMb29rdXAoKS5nZXRSZW1vdGVGb250cygpO1xuXG4gIC8vIE1ha2Ugc3VyZSB0aGUgQGltcG9ydCBzdGF0ZW1lbnRzIGNvbWUgYXQgdGhlIGZyb250IG9mIGNzc1xuICByZXR1cm4gYFxuICAgICR7XG4gICAgICBza2lwRm9udHNcbiAgICAgICAgPyBcIlwiXG4gICAgICAgIDogcmVtb3RlRm9udHMubWFwKChmKSA9PiBgQGltcG9ydCB1cmwoJyR7Zi51cmx9Jyk7YCkuam9pbihcIlxcblwiKVxuICAgIH1cbiAgICAke2Nzc01vZHVsZXMubWFwKChtb2QpID0+IG1vZC5zb3VyY2UpLmpvaW4oXCJcXG5cIil9XG4gIGA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VQbGFzbWljUm9vdENvbnRleHQoKSB7XG4gIHJldHVybiBSZWFjdC51c2VDb250ZXh0KFBsYXNtaWNSb290Q29udGV4dCk7XG59XG4iLCJpbXBvcnQgeyBDb21wb25lbnRNZXRhIH0gZnJvbSBcIkBwbGFzbWljYXBwL2xvYWRlci1jb3JlXCI7XG5pbXBvcnQgcGFzY2FsY2FzZSBmcm9tIFwicGFzY2FsY2FzZVwiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5cbmV4cG9ydCBjb25zdCBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiO1xuXG5leHBvcnQgdHlwZSBDb21wb25lbnRMb29rdXBTcGVjID1cbiAgfCBzdHJpbmdcbiAgfCB7IG5hbWU6IHN0cmluZzsgcHJvamVjdElkPzogc3RyaW5nOyBpc0NvZGU/OiBib29sZWFuIH07XG5cbmludGVyZmFjZSBGdWxsTmFtZUxvb2t1cFNwZWMge1xuICBuYW1lOiBzdHJpbmc7XG4gIHJhd05hbWU/OiBzdHJpbmc7XG4gIHByb2plY3RJZD86IHN0cmluZztcbiAgaXNDb2RlPzogYm9vbGVhbjtcbn1cblxuaW50ZXJmYWNlIEZ1bGxQYXRoTG9va3VwU3BlYyB7XG4gIHBhdGg6IHN0cmluZztcbiAgcHJvamVjdElkPzogc3RyaW5nO1xufVxuXG50eXBlIEZ1bGxMb29rdXBTcGVjID0gRnVsbE5hbWVMb29rdXBTcGVjIHwgRnVsbFBhdGhMb29rdXBTcGVjO1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlRm9yY2VVcGRhdGUoKSB7XG4gIGNvbnN0IFssIHNldFRpY2tdID0gUmVhY3QudXNlU3RhdGUoMCk7XG4gIGNvbnN0IHVwZGF0ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBzZXRUaWNrKCh0aWNrKSA9PiB0aWNrICsgMSk7XG4gIH0sIFtdKTtcbiAgcmV0dXJuIHVwZGF0ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVN0YWJsZUxvb2t1cFNwZWMoc3BlYzogQ29tcG9uZW50TG9va3VwU3BlYykge1xuICByZXR1cm4gdXNlU3RhYmxlTG9va3VwU3BlY3Moc3BlYylbMF07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VTdGFibGVMb29rdXBTcGVjcyguLi5zcGVjczogQ29tcG9uZW50TG9va3VwU3BlY1tdKSB7XG4gIGNvbnN0IFtzdGFibGVTcGVjcywgc2V0U3RhYmxlU3BlY3NdID0gUmVhY3QudXNlU3RhdGUoc3BlY3MpO1xuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKFxuICAgICAgc3BlY3MubGVuZ3RoICE9PSBzdGFibGVTcGVjcy5sZW5ndGggfHxcbiAgICAgIHNwZWNzLnNvbWUoKHMsIGkpID0+ICFhcmVMb29rdXBTcGVjc0VxdWFsKHMsIHN0YWJsZVNwZWNzW2ldKSlcbiAgICApIHtcbiAgICAgIHNldFN0YWJsZVNwZWNzKHNwZWNzKTtcbiAgICB9XG4gIH0sIFtzcGVjcywgc3RhYmxlU3BlY3NdKTtcbiAgcmV0dXJuIHN0YWJsZVNwZWNzO1xufVxuXG5mdW5jdGlvbiBhcmVMb29rdXBTcGVjc0VxdWFsKFxuICBzcGVjMTogQ29tcG9uZW50TG9va3VwU3BlYyxcbiAgc3BlYzI6IENvbXBvbmVudExvb2t1cFNwZWNcbikge1xuICBpZiAoc3BlYzEgPT09IHNwZWMyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHR5cGVvZiBzcGVjMSAhPT0gdHlwZW9mIHNwZWMyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgZnVsbFNwZWMxID0gdG9GdWxsTG9va3VwKHNwZWMxKTtcbiAgY29uc3QgZnVsbFNwZWMyID0gdG9GdWxsTG9va3VwKHNwZWMyKTtcbiAgcmV0dXJuIChcbiAgICAoKGlzTmFtZVNwZWMoZnVsbFNwZWMxKSAmJlxuICAgICAgaXNOYW1lU3BlYyhmdWxsU3BlYzIpICYmXG4gICAgICBmdWxsU3BlYzEubmFtZSA9PT0gZnVsbFNwZWMyLm5hbWUgJiZcbiAgICAgIGZ1bGxTcGVjMS5pc0NvZGUgPT09IGZ1bGxTcGVjMi5pc0NvZGUpIHx8XG4gICAgICAoaXNQYXRoU3BlYyhmdWxsU3BlYzEpICYmXG4gICAgICAgIGlzUGF0aFNwZWMoZnVsbFNwZWMyKSAmJlxuICAgICAgICBmdWxsU3BlYzEucGF0aCA9PT0gZnVsbFNwZWMyLnBhdGgpKSAmJlxuICAgIGZ1bGxTcGVjMS5wcm9qZWN0SWQgPT09IGZ1bGxTcGVjMi5wcm9qZWN0SWRcbiAgKTtcbn1cblxuZnVuY3Rpb24gaXNOYW1lU3BlYyhsb29rdXA6IEZ1bGxMb29rdXBTcGVjKTogbG9va3VwIGlzIEZ1bGxOYW1lTG9va3VwU3BlYyB7XG4gIHJldHVybiBcIm5hbWVcIiBpbiBsb29rdXA7XG59XG5cbmZ1bmN0aW9uIGlzUGF0aFNwZWMobG9va3VwOiBGdWxsTG9va3VwU3BlYyk6IGxvb2t1cCBpcyBGdWxsUGF0aExvb2t1cFNwZWMge1xuICByZXR1cm4gXCJwYXRoXCIgaW4gbG9va3VwO1xufVxuXG5mdW5jdGlvbiB0b0Z1bGxMb29rdXAobG9va3VwOiBDb21wb25lbnRMb29rdXBTcGVjKTogRnVsbExvb2t1cFNwZWMge1xuICBjb25zdCBuYW1lUGFydCA9IHR5cGVvZiBsb29rdXAgPT09IFwic3RyaW5nXCIgPyBsb29rdXAgOiBsb29rdXAubmFtZTtcbiAgY29uc3QgcHJvamVjdElkID0gdHlwZW9mIGxvb2t1cCA9PT0gXCJzdHJpbmdcIiA/IHVuZGVmaW5lZCA6IGxvb2t1cC5wcm9qZWN0SWQ7XG4gIGNvbnN0IGNvZGVDb21wb25lbnQgPSB0eXBlb2YgbG9va3VwID09PSBcInN0cmluZ1wiID8gdW5kZWZpbmVkIDogbG9va3VwLmlzQ29kZTtcblxuICBpZiAoY29kZUNvbXBvbmVudCAhPT0gdHJ1ZSAmJiBuYW1lUGFydC5zdGFydHNXaXRoKFwiL1wiKSkge1xuICAgIHJldHVybiB7IHBhdGg6IG5vcm1hbGl6ZVBhdGgobmFtZVBhcnQpLCBwcm9qZWN0SWQgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogY29kZUNvbXBvbmVudCA/IG5hbWVQYXJ0IDogbm9ybWFsaXplTmFtZShuYW1lUGFydCksXG4gICAgICByYXdOYW1lOiBuYW1lUGFydC50cmltKCksXG4gICAgICBwcm9qZWN0SWQsXG4gICAgICBpc0NvZGU6IGNvZGVDb21wb25lbnQsXG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVQYXRoKHBhdGg6IHN0cmluZykge1xuICByZXR1cm4gcGF0aC50cmltKCk7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZU5hbWUobmFtZTogc3RyaW5nKSB7XG4gIC8vIE5vdCBhIGZ1bGwgbm9ybWFsaXphdGlvbiwgYnV0IHNob3VsZCBiZSBnb29kIGVub3VnaFxuICByZXR1cm4gcGFzY2FsY2FzZShuYW1lKS50cmltKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VJc01vdW50ZWQoKTogKCkgPT4gYm9vbGVhbiB7XG4gIGNvbnN0IHJlZiA9IFJlYWN0LnVzZVJlZjxib29sZWFuPihmYWxzZSk7XG4gIGNvbnN0IGlzTW91bnRlZCA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHJlZi5jdXJyZW50LCBbXSk7XG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICByZWYuY3VycmVudCA9IHRydWU7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgfTtcbiAgfSwgW10pO1xuXG4gIHJldHVybiBpc01vdW50ZWQ7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYGxvb2t1cGAgcmVzb2x2ZXMgdG8gYHBhZ2VQYXRoYC4gSWYgaXQncyBhIG1hdGNoLCByZXR1cm4gYW4gb2JqZWN0XG4gKiBjb250YWluaW5nIHBhdGggcGFyYW1zOyBvdGhlcndpc2UsIHJldHVybiBmYWxzZS5cbiAqXG4gKiBGb3IgZXhhbXBsZSxcbiAqIC0gYG1hdGNoZXNQYWdlUGF0aChcIi9oZWxsby9bbmFtZV1cIiwgXCIvaGVsbG8vd29ybGRcIilgIC0+IGB7cGFyYW1zOiB7bmFtZTpcbiAqICAgXCJ3b3JsZFwifX1gXG4gKiAtIGBtYXRjaGVzUGFnZVBhdGgoXCIvaGVsbG8vW25hbWVdXCIsIFwiL1wiKWAgLT4gYGZhbHNlYFxuICogLSBgbWF0Y2hlc1BhZ2VQYXRoKFwiL2hlbGxvL1suLi5jYXRjaGFsbF1cIiwgXCIvaGVsbG8vYS9iL2NcIilgIC0+IGB7cGFyYW1zOiB7Y2F0Y2hhbGw6IFtcImFcIiwgXCJiXCIsIFwiY1wiXX19YFxuICogLSBgbWF0Y2hlc1BhZ2VQYXRoKFwiL2hlbGxvL1tbLi4uY2F0Y2hhbGxdXVwiLCBcIi9oZWxsby9cIilgIC0+IGB7cGFyYW1zOiB7Y2F0Y2hhbGw6IFtdfX1gXG4gKiAtIGBtYXRjaGVzUGFnZVBhdGgoXCIvXCIsIFwiXCIpYCAtPiBge3BhcmFtczoge319YFxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF0Y2hlc1BhZ2VQYXRoKHBhdHRlcm46IHN0cmluZywgcGF0aDogc3RyaW5nKSB7XG4gIC8vIChnZW5lcmF0ZWQgYnkgQ2hhdEdQVCA0IGZyb20gdGhlIHRlc3QgY2FzZXMpXG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoIGFuZCBwYXR0ZXJuIGJ5IGVuc3VyaW5nIHRoZXkgYm90aCBzdGFydCBhbmQgZW5kIHdpdGhvdXQgc2xhc2hlc1xuICBjb25zdCBub3JtYWxpemVkUGF0dGVybiA9IFwiL1wiICsgcGF0dGVybi5yZXBsYWNlKC9eXFwvfFxcLyQvZywgXCJcIik7XG4gIGNvbnN0IG5vcm1hbGl6ZWRQYXRoID0gXCIvXCIgKyBwYXRoLnJlcGxhY2UoL15cXC98XFwvJC9nLCBcIlwiKTtcblxuICAvLyBNb2RpZnkgdGhlIHJlZ2V4IHRvIG1hdGNoIG9wdGlvbmFsIGxlYWRpbmcgc2xhc2hlc1xuICBjb25zdCByZWdleFN0cmluZyA9IG5vcm1hbGl6ZWRQYXR0ZXJuXG4gICAgLnJlcGxhY2UoL1xcL1xcW1xcW1xcLlxcLlxcLihbXlxcXV5dKyldXS9nLCBcIig/Oi8oW15dKikpP1wiKSAvLyBPcHRpb25hbCBjYXRjaC1hbGxcbiAgICAucmVwbGFjZSgvXFwvXFxbXFwuXFwuXFwuKFteXFxdXl0rKV0vZywgXCIvKFteXSopXCIpIC8vIENhdGNoLWFsbFxuICAgIC5yZXBsYWNlKC9cXFsoW15cXF1eXSspXS9nLCBcIihbXi9dKylcIikgLy8gTm9ybWFsIHNsdWdcbiAgICAucmVwbGFjZSgvXFwvL2csIFwiXFxcXC9cIik7IC8vIEVzY2FwZSBmb3J3YXJkIHNsYXNoZXNcblxuICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAoYF4vPyR7cmVnZXhTdHJpbmd9JGApOyAvLyBBbGxvdyBvcHRpb25hbCBsZWFkaW5nIHNsYXNoXG4gIGNvbnN0IG1hdGNoID0gbm9ybWFsaXplZFBhdGgubWF0Y2gocmVnZXgpO1xuXG4gIGlmICghbWF0Y2gpIHJldHVybiBmYWxzZTtcblxuICAvLyBFeHRyYWN0IHNsdWcgbmFtZXMgZnJvbSBwYXR0ZXJuXG4gIGNvbnN0IHNsdWdOYW1lcyA9IFsuLi5wYXR0ZXJuLm1hdGNoQWxsKC9cXFtcXC4/XFwuP1xcLj8oW15bXFxdXSspXS9nKV0ubWFwKFxuICAgIChtKSA9PiBtWzFdXG4gICk7XG5cbiAgLy8gQ29uc3RydWN0IHBhcmFtcyBvYmplY3RcbiAgY29uc3QgcGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBzdHJpbmdbXT4gPSB7fTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbHVnTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzbHVnTmFtZSA9IHNsdWdOYW1lc1tpXTtcbiAgICBjb25zdCB2YWx1ZSA9IG1hdGNoW2kgKyAxXTtcblxuICAgIGlmIChwYXR0ZXJuLmluY2x1ZGVzKGBbWy4uLiR7c2x1Z05hbWV9XV1gKSkge1xuICAgICAgLy8gSGFuZGxlIG9wdGlvbmFsIGNhdGNoYWxsIHNsdWdzXG4gICAgICBwYXJhbXNbc2x1Z05hbWVdID0gdmFsdWUgPyB2YWx1ZS5zcGxpdChcIi9cIikuZmlsdGVyKEJvb2xlYW4pIDogW107XG4gICAgfSBlbHNlIGlmIChwYXR0ZXJuLmluY2x1ZGVzKGBbLi4uJHtzbHVnTmFtZX1dYCkpIHtcbiAgICAgIC8vIEhhbmRsZSBtYW5kYXRvcnkgY2F0Y2hhbGwgc2x1Z3NcbiAgICAgIHBhcmFtc1tzbHVnTmFtZV0gPSB2YWx1ZS5zcGxpdChcIi9cIikuZmlsdGVyKEJvb2xlYW4pO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gSGFuZGxlIG5vcm1hbCBzbHVnc1xuICAgICAgcGFyYW1zW3NsdWdOYW1lXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7IHBhcmFtcyB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNEeW5hbWljUGFnZVBhdGgocGF0aDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiAhIXBhdGgubWF0Y2goL1xcW1teL10qXFxdLyk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXNDb21wTWV0YShsb29rdXA6IEZ1bGxMb29rdXBTcGVjLCBtZXRhOiBDb21wb25lbnRNZXRhKSB7XG4gIGlmIChsb29rdXAucHJvamVjdElkICYmIG1ldGEucHJvamVjdElkICE9PSBsb29rdXAucHJvamVjdElkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzTmFtZVNwZWMobG9va3VwKVxuICAgID8gKGxvb2t1cC5uYW1lID09PSBtZXRhLm5hbWUgfHxcbiAgICAgICAgbG9va3VwLnJhd05hbWUgPT09IG1ldGEubmFtZSB8fFxuICAgICAgICBsb29rdXAucmF3TmFtZSA9PT0gbWV0YS5kaXNwbGF5TmFtZSkgJiZcbiAgICAgICAgKGxvb2t1cC5pc0NvZGUgPT0gbnVsbCB8fCBsb29rdXAuaXNDb2RlID09PSBtZXRhLmlzQ29kZSlcbiAgICA6ICEhKG1ldGEucGF0aCAmJiBtYXRjaGVzUGFnZVBhdGgobWV0YS5wYXRoLCBsb29rdXAucGF0aCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29tcE1ldGFzKFxuICBtZXRhczogQ29tcG9uZW50TWV0YVtdLFxuICBsb29rdXA6IENvbXBvbmVudExvb2t1cFNwZWNcbikge1xuICBjb25zdCBmdWxsID0gdG9GdWxsTG9va3VwKGxvb2t1cCk7XG4gIHJldHVybiBtZXRhc1xuICAgIC5maWx0ZXIoKG1ldGEpID0+IG1hdGNoZXNDb21wTWV0YShmdWxsLCBtZXRhKSlcbiAgICAubWFwPENvbXBvbmVudE1ldGEgJiB7IHBhcmFtcz86IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IHN0cmluZ1tdPiB9PihcbiAgICAgIChtZXRhKSA9PiB7XG4gICAgICAgIGlmIChpc05hbWVTcGVjKGZ1bGwpIHx8ICFtZXRhLnBhdGgpIHtcbiAgICAgICAgICByZXR1cm4gbWV0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1hdGNoID0gbWF0Y2hlc1BhZ2VQYXRoKG1ldGEucGF0aCwgZnVsbC5wYXRoKTtcbiAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgIHJldHVybiBtZXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgLi4ubWV0YSwgcGFyYW1zOiBtYXRjaC5wYXJhbXMgfTtcbiAgICAgIH1cbiAgICApXG4gICAgLnNvcnQoXG4gICAgICAobWV0YTEsIG1ldGEyKSA9PlxuICAgICAgICAvLyBXZSBzb3J0IHRoZSBtYXRjaGVkIGNvbXBvbmVudCBtZXRhcyBieSB0aGUgbnVtYmVyIG9mIHBhdGggcGFyYW1zLCBzb1xuICAgICAgICAvLyBpZiB0aGVyZSBhcmUgdHdvIHBhZ2VzIGAvcHJvZHVjdHMvZm9vYCBhbmQgYC9wcm9kdWN0cy9bc2x1Z11gLFxuICAgICAgICAvLyB0aGUgZmlyc3Qgb25lIHdpbGwgaGF2ZSBoaWdoZXIgcHJlY2VkZW5jZS5cbiAgICAgICAgQXJyYXkuZnJvbShPYmplY3Qua2V5cyhtZXRhMS5wYXJhbXMgfHwge30pKS5sZW5ndGggLVxuICAgICAgICBBcnJheS5mcm9tKE9iamVjdC5rZXlzKG1ldGEyLnBhcmFtcyB8fCB7fSkpLmxlbmd0aFxuICAgICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRMb29rdXBTcGVjTmFtZShsb29rdXA6IENvbXBvbmVudExvb2t1cFNwZWMpIHtcbiAgaWYgKHR5cGVvZiBsb29rdXAgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gbG9va3VwO1xuICB9IGVsc2UgaWYgKGxvb2t1cC5wcm9qZWN0SWQpIHtcbiAgICByZXR1cm4gYCR7bG9va3VwLm5hbWV9IChwcm9qZWN0ICR7bG9va3VwLnByb2plY3RJZH0pYDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbG9va3VwLm5hbWU7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIE1heWJlV3JhcChwcm9wczoge1xuICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlO1xuICBjb25kOiBib29sZWFuO1xuICB3cmFwcGVyOiAoY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZSkgPT4gUmVhY3QuUmVhY3RFbGVtZW50O1xufSkge1xuICByZXR1cm4gKFxuICAgIHByb3BzLmNvbmQgPyBwcm9wcy53cmFwcGVyKHByb3BzLmNoaWxkcmVuKSA6IHByb3BzLmNoaWxkcmVuXG4gICkgYXMgUmVhY3QuUmVhY3RFbGVtZW50O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdW5pcTxUPihlbGVtZW50czogVFtdKTogVFtdIHtcbiAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldChlbGVtZW50cykpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdW5pcUJ5PFQsIEs+KGVsZW1lbnRzOiBUW10sIGl0ZXJhdG9yOiAoZWx0OiBUKSA9PiBLKTogVFtdIHtcbiAgY29uc3QgdmlzID0gbmV3IFNldDxLPigpO1xuICBjb25zdCBmaWx0ZXJlZDogVFtdID0gW107XG4gIGZvciAoY29uc3QgZWx0IG9mIGVsZW1lbnRzKSB7XG4gICAgY29uc3Qga2V5ID0gaXRlcmF0b3IoZWx0KTtcbiAgICBpZiAoIXZpcy5oYXMoa2V5KSkge1xuICAgICAgdmlzLmFkZChrZXkpO1xuICAgICAgZmlsdGVyZWQucHVzaChlbHQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmlsdGVyZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnNlY3Q8VD4oYTogVFtdLCBiOiBUW10pOiBUW10ge1xuICBjb25zdCBzZXRCID0gbmV3IFNldChiKTtcbiAgcmV0dXJuIGEuZmlsdGVyKChlbHQpID0+IHNldEIuaGFzKGVsdCkpO1xufVxuIiwiaW1wb3J0IHR5cGUge1xuICBFeHBlcmltZW50U2xpY2UsXG4gIFNlZ21lbnRTbGljZSxcbiAgU3BsaXQsXG59IGZyb20gXCJAcGxhc21pY2FwcC9sb2FkZXItY29yZVwiO1xuaW1wb3J0IHR5cGUgeyBHbG9iYWxWYXJpYW50U3BlYyB9IGZyb20gXCIuL1BsYXNtaWNSb290UHJvdmlkZXJcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFBsYXNtaWNDb29raWVWYWx1ZXMoKSB7XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgZG9jdW1lbnQuY29va2llXG4gICAgICAuc3BsaXQoXCI7IFwiKVxuICAgICAgLmZpbHRlcigoY29va2llKSA9PiBjb29raWUuaW5jbHVkZXMoXCJwbGFzbWljOlwiKSlcbiAgICAgIC5tYXAoKGNvb2tpZSkgPT4gY29va2llLnNwbGl0KFwiPVwiKSlcbiAgICAgIC5tYXAoKFtrZXksIHZhbHVlXSkgPT4gW2tleS5zcGxpdChcIjpcIilbMV0sIHZhbHVlXSlcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZVBsYXNtaWNDb29raWVWYWx1ZShrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZykge1xuICBkb2N1bWVudC5jb29raWUgPSBgcGxhc21pYzoke2tleX09JHt2YWx1ZX1gO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlVmFyaWF0aW9uQ29va2llcyh2YXJpYXRpb246IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fSkge1xuICBPYmplY3Qua2V5cyh2YXJpYXRpb24pLm1hcCgodmFyaWF0aW9uS2V5KSA9PiB7XG4gICAgY29uc3Qgc2xpY2VJZCA9IHZhcmlhdGlvblt2YXJpYXRpb25LZXldO1xuICAgIHVwZGF0ZVBsYXNtaWNDb29raWVWYWx1ZSh2YXJpYXRpb25LZXksIHNsaWNlSWQpO1xuICB9KTtcbn1cblxuZXhwb3J0IGNvbnN0IGdldEdsb2JhbFZhcmlhbnRzRnJvbVNwbGl0cyA9IChcbiAgc3BsaXRzOiBTcGxpdFtdLFxuICB2YXJpYXRpb246IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbikgPT4ge1xuICBjb25zdCBnbG9iYWxWYXJpYW50czogR2xvYmFsVmFyaWFudFNwZWNbXSA9IFtdO1xuXG4gIE9iamVjdC5rZXlzKHZhcmlhdGlvbikubWFwKCh2YXJpYXRpb25LZXk6IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IFtfdHlwZSwgc3BsaXRJZF0gPSB2YXJpYXRpb25LZXkuc3BsaXQoXCIuXCIpO1xuICAgIGNvbnN0IHNsaWNlSWQgPSB2YXJpYXRpb25bdmFyaWF0aW9uS2V5XTtcbiAgICBjb25zdCBzcGxpdCA9IHNwbGl0cy5maW5kKFxuICAgICAgKHMpID0+IHMuaWQgPT09IHNwbGl0SWQgfHwgcy5leHRlcm5hbElkID09PSBzcGxpdElkXG4gICAgKTtcbiAgICBpZiAoc3BsaXQpIHtcbiAgICAgIGNvbnN0IHNsaWNlOiBFeHBlcmltZW50U2xpY2UgfCBTZWdtZW50U2xpY2UgfCB1bmRlZmluZWQgPSAoXG4gICAgICAgIHNwbGl0LnNsaWNlcyBhcyBBcnJheTxFeHBlcmltZW50U2xpY2UgfCBTZWdtZW50U2xpY2U+XG4gICAgICApLmZpbmQoKHM6IGFueSkgPT4gcy5pZCA9PT0gc2xpY2VJZCB8fCBzLmV4dGVybmFsSWQgPT09IHNsaWNlSWQpO1xuICAgICAgaWYgKHNsaWNlKSB7XG4gICAgICAgIHNsaWNlLmNvbnRlbnRzLm1hcCgoeCkgPT4ge1xuICAgICAgICAgIGdsb2JhbFZhcmlhbnRzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogeC5ncm91cCxcbiAgICAgICAgICAgIHZhbHVlOiB4LnZhcmlhbnQsXG4gICAgICAgICAgICBwcm9qZWN0SWQ6IHgucHJvamVjdElkLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBnbG9iYWxWYXJpYW50cztcbn07XG5cbmV4cG9ydCBjb25zdCBtZXJnZUdsb2JhbFZhcmlhbnRzU3BlYyA9IChcbiAgdGFyZ2V0OiBHbG9iYWxWYXJpYW50U3BlY1tdLFxuICBmcm9tOiBHbG9iYWxWYXJpYW50U3BlY1tdXG4pID0+IHtcbiAgbGV0IHJlc3VsdCA9IFsuLi50YXJnZXRdO1xuICBjb25zdCBleGlzdGluZ0dsb2JhbFZhcmlhbnRzID0gbmV3IFNldChcbiAgICB0YXJnZXQubWFwKCh0KSA9PiBgJHt0Lm5hbWV9LSR7dC5wcm9qZWN0SWQgPz8gXCJcIn1gKVxuICApO1xuICBjb25zdCBuZXdHbG9iYWxzID0gZnJvbS5maWx0ZXIoXG4gICAgKHQpID0+ICFleGlzdGluZ0dsb2JhbFZhcmlhbnRzLmhhcyhgJHt0Lm5hbWV9LSR7dC5wcm9qZWN0SWQgPz8gXCJcIn1gKVxuICApO1xuXG4gIGlmIChuZXdHbG9iYWxzLmxlbmd0aCA+IDApIHtcbiAgICByZXN1bHQgPSBbLi4ucmVzdWx0LCAuLi5uZXdHbG9iYWxzXTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiLyoqXG4gKiBXZSBkb24ndCBhY3R1YWxseSBtYWtlIHVzZSBvZiB0aGUgZ2xvYmFsIHZhcmlhbnQgUmVhY3QgY29udGV4dHMgZ2VuZXJhdGVkXG4gKiBpbiB0aGUgYnVuZGxlLiAgVGhhdCdzIGJlY2F1c2Ugd2Ugd291bGQgaGF2ZSB0byB3YWl0IHVudGlsIHRoZSBkYXRhIGlzXG4gKiBsb2FkZWQgYmVmb3JlIHdlIGNhbiBzZXQgdXAgdGhlIGNvbnRleHQgcHJvdmlkZXJzLCBidXQgc2V0dGluZyB1cCBjb250ZXh0XG4gKiBwcm92aWRlcnMgd2lsbCBtdXRhdGUgdGhlIFJlYWN0IHRyZWUgYW5kIGludmFsaWRhdGUgYWxsIHRoZSBjaGlsZHJlbi4gVGhhdCBtZWFuc1xuICogb25jZSBkYXRhIGNvbWVzIGluLCB3ZSdsbCByZS1yZW5kZXIgdGhlIFJlYWN0IHRyZWUgZnJvbSB0aGUgcHJvdmlkZXJzIGRvd25cbiAqIGluIGEgd2F5IHRoYXQgd2lsbCBsb3NlIGFsbCBleGlzdGluZyBSZWFjdCBzdGF0ZS4gIFRoZXJlZm9yZSwgaW5zdGVhZCxcbiAqIHdlIGFsd2F5cyBoYXZlIGEgc2luZ2xlIGNvbnRleHQgcHJvdmlkZWQgLS0gdGhlIFBsYXNtaWNSb290Q29udGV4dCAtLSBhbmQgd2VcbiAqIGNyZWF0ZSB0aGVzZSBmYWtlIHVzZUdsb2JhbFZhcmlhbnQoKSBob29rcyB0aGF0IGp1c3QgcmVhZCBmcm9tIHRoYXRcbiAqIFBsYXNtaWNSb290Q29udGV4dC4gIFRoaXMgYWxsb3dzIHVzIHRvIGhhdmUgYSBzdGFibGUgUmVhY3QgdHJlZSBiZWZvcmUgYW5kXG4gKiBhZnRlciB0aGUgZGF0YSBsb2FkLlxuICovXG5cbmltcG9ydCB7IEludGVybmFsUGxhc21pY0NvbXBvbmVudExvYWRlciB9IGZyb20gXCIuL2xvYWRlci1jbGllbnRcIjtcbmltcG9ydCB7IHVzZVBsYXNtaWNSb290Q29udGV4dCB9IGZyb20gXCIuL1BsYXNtaWNSb290UHJvdmlkZXJcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVVzZUdsb2JhbFZhcmlhbnQobmFtZTogc3RyaW5nLCBwcm9qZWN0SWQ6IHN0cmluZykge1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGNvbnN0IHJvb3RDb250ZXh0ID0gdXNlUGxhc21pY1Jvb3RDb250ZXh0KCk7XG4gICAgaWYgKCFyb290Q29udGV4dCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBjb25zdCBsb2FkZXIgPSByb290Q29udGV4dC5sb2FkZXIgYXMgSW50ZXJuYWxQbGFzbWljQ29tcG9uZW50TG9hZGVyO1xuICAgIGNvbnN0IHNwZWMgPSBbXG4gICAgICAuLi5sb2FkZXIuZ2V0R2xvYmFsVmFyaWFudHMoKSxcbiAgICAgIC4uLihyb290Q29udGV4dC5nbG9iYWxWYXJpYW50cyA/PyBbXSksXG4gICAgXS5maW5kKFxuICAgICAgKHNwZWMyKSA9PlxuICAgICAgICBzcGVjMi5uYW1lID09PSBuYW1lICYmXG4gICAgICAgICghc3BlYzIucHJvamVjdElkIHx8IHNwZWMyLnByb2plY3RJZCA9PT0gcHJvamVjdElkKVxuICAgICk7XG4gICAgcmV0dXJuIHNwZWMgPyBzcGVjLnZhbHVlIDogdW5kZWZpbmVkO1xuICB9O1xufVxuIiwiaW1wb3J0IHR5cGUge1xuICBDb21wb25lbnRIZWxwZXJzLFxuICBDb21wb25lbnRIZWxwZXJzIGFzIEludGVybmFsQ29kZUNvbXBvbmVudEhlbHBlcnMsXG4gIENvZGVDb21wb25lbnRNZXRhIGFzIEludGVybmFsQ29kZUNvbXBvbmVudE1ldGEsXG4gIEN1c3RvbUZ1bmN0aW9uTWV0YSBhcyBJbnRlcm5hbEN1c3RvbUZ1bmN0aW9uTWV0YSxcbiAgR2xvYmFsQ29udGV4dE1ldGEgYXMgSW50ZXJuYWxHbG9iYWxDb250ZXh0TWV0YSxcbiAgU3RhdGVIZWxwZXJzLFxuICBTdGF0ZVNwZWMsXG4gIFRva2VuUmVnaXN0cmF0aW9uLFxuICBUcmFpdE1ldGEsXG4gIHVzZURhdGFFbnYsXG4gIHVzZVNlbGVjdG9yLFxuICB1c2VTZWxlY3RvcnMsXG59IGZyb20gXCJAcGxhc21pY2FwcC9ob3N0XCI7XG5pbXBvcnQge1xuICBMb2FkZXJCdW5kbGVDYWNoZSxcbiAgUGFnZU1ldGEsXG4gIFBsYXNtaWNNb2R1bGVzRmV0Y2hlcixcbiAgUGxhc21pY1RyYWNrZXIsXG4gIFJlZ2lzdHJ5LFxuICBUcmFja1JlbmRlck9wdGlvbnMsXG59IGZyb20gXCJAcGxhc21pY2FwcC9sb2FkZXItY29yZVwiO1xuaW1wb3J0IHtcbiAgQ29kZU1vZHVsZSxcbiAgQ29tcG9uZW50TWV0YSxcbiAgTG9hZGVyQnVuZGxlT3V0cHV0LFxuICBpbnRlcm5hbF9nZXRDYWNoZWRCdW5kbGVJbk5vZGVTZXJ2ZXIsXG59IGZyb20gXCJAcGxhc21pY2FwcC9sb2FkZXItZmV0Y2hlclwiO1xuaW1wb3J0IHsgZ2V0QWN0aXZlVmFyaWF0aW9uLCBnZXRFeHRlcm5hbElkcyB9IGZyb20gXCJAcGxhc21pY2FwcC9sb2FkZXItc3BsaXRzXCI7XG5pbXBvcnQgdHlwZSB7IHVzZU11dGFibGVQbGFzbWljUXVlcnlEYXRhIH0gZnJvbSBcIkBwbGFzbWljYXBwL3F1ZXJ5XCI7XG5pbXBvcnQgdHlwZSB7IEdsb2JhbFZhcmlhbnRTcGVjIH0gZnJvbSBcIi4vUGxhc21pY1Jvb3RQcm92aWRlclwiO1xuaW1wb3J0IHsgbWVyZ2VCdW5kbGVzLCBwcmVwQ29tcG9uZW50RGF0YSB9IGZyb20gXCIuL2J1bmRsZXNcIjtcbmltcG9ydCB7IENvbXBvbmVudExvb2t1cCB9IGZyb20gXCIuL2NvbXBvbmVudC1sb29rdXBcIjtcbmltcG9ydCB7XG4gIENvbXBvbmVudExvb2t1cFNwZWMsXG4gIGdldENvbXBNZXRhcyxcbiAgZ2V0TG9va3VwU3BlY05hbWUsXG4gIGlzQnJvd3NlcixcbiAgaXNEeW5hbWljUGFnZVBhdGgsXG4gIHVuaXEsXG59IGZyb20gXCIuL3V0aWxzXCI7XG5pbXBvcnQgeyBnZXRQbGFzbWljQ29va2llVmFsdWVzLCB1cGRhdGVQbGFzbWljQ29va2llVmFsdWUgfSBmcm9tIFwiLi92YXJpYXRpb25cIjtcblxuZXhwb3J0IGludGVyZmFjZSBJbml0T3B0aW9ucyB7XG4gIHByb2plY3RzOiB7XG4gICAgaWQ6IHN0cmluZztcbiAgICB0b2tlbjogc3RyaW5nO1xuICAgIHZlcnNpb24/OiBzdHJpbmc7XG4gIH1bXTtcbiAgY2FjaGU/OiBMb2FkZXJCdW5kbGVDYWNoZTtcbiAgcGxhdGZvcm0/OiBcInJlYWN0XCIgfCBcIm5leHRqc1wiIHwgXCJnYXRzYnlcIjtcbiAgcGxhdGZvcm1PcHRpb25zPzoge1xuICAgIG5leHRqcz86IHtcbiAgICAgIGFwcERpcjogYm9vbGVhbjtcbiAgICB9O1xuICB9O1xuICBwcmV2aWV3PzogYm9vbGVhbjtcbiAgaG9zdD86IHN0cmluZztcbiAgb25DbGllbnRTaWRlRmV0Y2g/OiBcIndhcm5cIiB8IFwiZXJyb3JcIjtcbiAgaTE4bj86IHtcbiAgICBrZXlTY2hlbWU6IFwiY29udGVudFwiIHwgXCJoYXNoXCIgfCBcInBhdGhcIjtcbiAgICB0YWdQcmVmaXg/OiBzdHJpbmc7XG4gIH07XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgaTE4bi5rZXlTY2hlbWUgaW5zdGVhZFxuICAgKi9cbiAgaTE4bktleVNjaGVtZT86IFwiY29udGVudFwiIHwgXCJoYXNoXCI7XG5cbiAgLyoqXG4gICAqIEJ5IGRlZmF1bHQsIGZldGNoQ29tcG9uZW50RGF0YSgpIGFuZCBmZXRjaFBhZ2VzKCkgY2FsbHMgY2FjaGVkIGluIG1lbW9yeVxuICAgKiB3aXRoIHRoZSBQbGFzbWljQ29tcG9uZW50TG9hZGVyIGluc3RhbmNlLiAgSWYgYWx3YXlzRnJlc2ggaXMgdHJ1ZSwgdGhlblxuICAgKiBkYXRhIGlzIGFsd2F5cyBmcmVzaGx5IGZldGNoZWQgb3ZlciB0aGUgbmV0d29yay5cbiAgICovXG4gIGFsd2F5c0ZyZXNoPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogSWYgdHJ1ZSwgZ2VuZXJhdGVkIGNvZGUgZnJvbSB0aGUgc2VydmVyIHdvbid0IGluY2x1ZGUgcGFnZSBtZXRhZGF0YSB0YWdzXG4gICAqL1xuICBza2lwSGVhZD86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIElmIHRydWUsIHVzZXMgYnJvd3NlciAvIG5vZGUncyBuYXRpdmUgZmV0Y2hcbiAgICovXG4gIG5hdGl2ZUZldGNoPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogSWYgdHJ1ZSwgd2lsbCBub3QgcmVkaXJlY3QgdG8gdGhlIGNvZGVnZW4gc2VydmVyIGF1dG9tYXRpY2FsbHksIGFuZCB3aWxsXG4gICAqIHRyeSB0byByZXVzZSB0aGUgZXhpc3RpbmcgYnVuZGxlIGluIHRoZSBjYWNoZS5cbiAgICovXG4gIG1hbnVhbFJlZGlyZWN0PzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb21wb25lbnRSZW5kZXJEYXRhIHtcbiAgZW50cnlDb21wTWV0YXM6IChDb21wb25lbnRNZXRhICYgeyBwYXJhbXM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IH0pW107XG4gIGJ1bmRsZTogTG9hZGVyQnVuZGxlT3V0cHV0O1xuICByZW1vdGVGb250VXJsczogc3RyaW5nW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29tcG9uZW50U3Vic3RpdHV0aW9uU3BlYyB7XG4gIGxvb2t1cDogQ29tcG9uZW50TG9va3VwU3BlYztcbiAgY29tcG9uZW50OiBSZWFjdC5Db21wb25lbnRUeXBlPGFueT47XG4gIGNvZGVDb21wb25lbnRIZWxwZXJzPzogSW50ZXJuYWxDb2RlQ29tcG9uZW50SGVscGVyczxcbiAgICBSZWFjdC5Db21wb25lbnRQcm9wczxhbnk+XG4gID47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGxhc21pY1Jvb3RXYXRjaGVyIHtcbiAgb25EYXRhRmV0Y2hlZD86ICgpID0+IHZvaWQ7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9ucyB0byBkZXNjcmliZSBjb2RlIGNvbXBvbmVudCBiZWhhdmlvcnMsIGluIG9yZGVyIHRvIGFsbG93XG4gKiBkYXRhIGV4dHJhY3Rpb24gaW4gUlNDIC8gTmV4dC5qcyBBcHAgcm91dGluZy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZWFjdFNlcnZlck9wcyB7XG4gIHJlYWREYXRhRW52OiB0eXBlb2YgdXNlRGF0YUVudjtcbiAgcmVhZERhdGFTZWxlY3RvcjogdHlwZW9mIHVzZVNlbGVjdG9yO1xuICByZWFkRGF0YVNlbGVjdG9yczogdHlwZW9mIHVzZVNlbGVjdG9ycztcbiAgLyoqXG4gICAqIFRoZSBjb250ZXh0cyBhcmUgcGFzc2VkIHVzaW5nIGEga2V5IGluc3RlYWQgb2YgdGhlIGNvbnRleHQgcHJvdmlkZXJcbiAgICogTm90aWNlIGl0IGNhbm5vdCBhY2Nlc3MgdGhlIGRlZmF1bHQgY29udGV4dCB2YWx1ZSBpZiBub25lIGhhcyBiZWVuIHByb3ZpZGVkLFxuICAgKiBzaW5jZSBSZWFjdCBzZXJ2ZXIgY29tcG9uZW50cyBjYW5ub3QgY3JlYXRlIGNvbnRleHRzLlxuICAgKi9cbiAgcmVhZENvbnRleHQ6IChjb250ZXh0S2V5OiBzdHJpbmcpID0+IGFueTtcbiAgLyoqXG4gICAqIEFsbG93cyBkYXRhIGZldGNoaW5nIGZyb20gdGhlIGNvZGUgY29tcG9uZW50IGFuZCBjYWNoaW5nIHRoZSByZXN1bHQsXG4gICAqIHdoaWNoIHdpbGwgYmUgc3RvcmVkIGluIHRoZSBgcXVlcnlDYWNoZWAgcmV0dXJuZWQgYnlcbiAgICogYGV4dHJhY3RQbGFzbWljUXVlcnlEYXRhYC5cbiAgICovXG4gIGZldGNoRGF0YTogdHlwZW9mIHVzZU11dGFibGVQbGFzbWljUXVlcnlEYXRhO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgZGF0YSBwcm92aWRlZCBieSBhIGNvZGUgY29tcG9uZW50IHZpYSBgRGF0YVByb3ZpZGVyYFxuICovXG5leHBvcnQgaW50ZXJmYWNlIFNlcnZlclByb3ZpZGVkRGF0YSB7XG4gIG5hbWU6IHN0cmluZztcbiAgZGF0YTogYW55O1xufVxuXG4vKipcbiAqIFByb3ZpZGVzIGEgbmV3IHZhbHVlIGZvciBhIGdpdmVuIGNvbnRleHQga2V5LCBzaW1pbGFyIHRvIENvbnRleHQuUHJvdmlkZXIuXG4gKiBUaGUgY29udGV4dCBpdHNlbGYgaXMgbm90IGF2YWlsYWJsZSAoUlNDIGRvZXNuJ3QgYWxsb3cgY2FsbGluZ1xuICogYGNyZWF0ZUNvbnRleHRgKSBzbyBlYWNoIGNvbnRleHQgd2lsbCBuZWVkIHRvIGJlIHJlcHJlc2VudGVkIGFzIGEgdW5pcXVlXG4gKiBcImNvbnRleHQga2V5XCIuIEFsc28gaXQgbWVhbnMgdGhlIGRlZmF1bHQgY29udGV4dCB2YWx1ZSBpcyBub3QgYXZhaWxhYmxlXG4gKiBpbiBjYXNlIG5vIHZhbHVlIGlzIHBhc3NlZCAoYW5kIHJlYWRpbmcgdGhhdCBjb250ZXh0IHdpbGwgcmV0dXJuIGB1bmRlZmluZWRgKVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFNlcnZlclByb3ZpZGVkQ29udGV4dCB7XG4gIC8qKlxuICAgKiBJZGVudGlmaWVyIHRvIHRoZSBjb250ZXh0LCByZXF1aXJlZCB0byByZWFkIGl0IGxhdGVyIHZpYVxuICAgKiBgUmVhY3RTZXJ2ZXJPcHMucmVhZENvbnRleHQoKWAuXG4gICAqL1xuICBjb250ZXh0S2V5OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBDb250ZXh0IHZhbHVlIGJlaW5nIHByb3ZpZGVkIChzaW1pbGFyIHRvIGBDb250ZXh0LlByb3ZpZGVyYCkuXG4gICAqL1xuICB2YWx1ZTogYW55O1xufVxuXG4vKipcbiAqICBFYWNoIGNoaWxkIG9mIGEgY29kZSBjb21wb25lbnQgbWlnaHQgcmVjZWl2ZSBzZXBhcmF0ZSBgRGF0YVByb3ZpZGVyYCBhbmRcbiAqICBDb250ZXh0IHZhbHVlcy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTZXJ2ZXJDaGlsZERhdGEge1xuICBwcm92aWRlZERhdGE/OiBTZXJ2ZXJQcm92aWRlZERhdGEgfCBTZXJ2ZXJQcm92aWRlZERhdGFbXTtcbiAgcHJvdmlkZWRDb250ZXh0cz86IFNlcnZlclByb3ZpZGVkQ29udGV4dCB8IFNlcnZlclByb3ZpZGVkQ29udGV4dFtdO1xuICBub2RlOiBSZWFjdC5SZWFjdE5vZGU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VydmVySW5mbyB7XG4gIC8qKlxuICAgKiBPcHRpb25hbDogSW5kaWNhdGVzIHRoZSBSZWFjdCBOb2RlcyBjcmVhdGVkIGJ5IHRoZSBjb21wb25lbnQgYW5kIHRoZVxuICAgKiByZXNwZWN0aXZlIGNvbnRleHRzIHByb3ZpZGVkIHRvIHRoZW0uIElmIG5vdCBzcGVjaWZpZWQsIGl0IHdpbGwgcmVuZGVyIHRoZVxuICAgKiBjaGlsZHJlbiBwYXNzZWQgdG8gdGhlIGNvbXBvbmVudCBhcyBwcm9wcy5cbiAgICovXG4gIGNoaWxkcmVuPzogU2VydmVyQ2hpbGREYXRhIHwgU2VydmVyQ2hpbGREYXRhW107XG4gIHByb3ZpZGVkRGF0YT86IFNlcnZlclByb3ZpZGVkRGF0YSB8IFNlcnZlclByb3ZpZGVkRGF0YVtdO1xuICBwcm92aWRlZENvbnRleHRzPzogU2VydmVyUHJvdmlkZWRDb250ZXh0IHwgU2VydmVyUHJvdmlkZWRDb250ZXh0W107XG59XG5cbmV4cG9ydCB0eXBlIENvZGVDb21wb25lbnRNZXRhPFA+ID0gT21pdDxcbiAgSW50ZXJuYWxDb2RlQ29tcG9uZW50TWV0YTxQPixcbiAgXCJpbXBvcnRQYXRoXCIgfCBcImNvbXBvbmVudEhlbHBlcnNcIiB8IFwic3RhdGVzXCJcbj4gJiB7XG4gIC8qKlxuICAgKiBUaGUgcGF0aCB0byBiZSB1c2VkIHdoZW4gaW1wb3J0aW5nIHRoZSBjb21wb25lbnQgaW4gdGhlIGdlbmVyYXRlZCBjb2RlLlxuICAgKiBJdCBjYW4gYmUgdGhlIG5hbWUgb2YgdGhlIHBhY2thZ2UgdGhhdCBjb250YWlucyB0aGUgY29tcG9uZW50LCBvciB0aGUgcGF0aFxuICAgKiB0byB0aGUgZmlsZSBpbiB0aGUgcHJvamVjdCAocmVsYXRpdmUgdG8gdGhlIHJvb3QgZGlyZWN0b3J5KS5cbiAgICogT3B0aW9uYWw6IG5vdCB1c2VkIGJ5IFBsYXNtaWMgaGVhZGxlc3MgQVBJLCBvbmx5IGJ5IGNvZGVnZW4uXG4gICAqL1xuICBpbXBvcnRQYXRoPzogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIHN0YXRlcyBoZWxwZXJzIGFyZSByZWdpc3RlcmVkIHRvZ2V0aGVyIHdpdGggdGhlIHN0YXRlcyBmb3IgdGhlIFBsYXNtaWMgaGVhZGxlc3MgQVBJXG4gICAqL1xuICBzdGF0ZXM/OiBSZWNvcmQ8c3RyaW5nLCBTdGF0ZVNwZWM8UD4gJiBTdGF0ZUhlbHBlcnM8UCwgYW55Pj47XG5cbiAgLyoqXG4gICAqIEhlbHBlciBmdW5jdGlvbiB0byBlbmFibGUgZGF0YSBleHRyYWN0aW9uIHdoZW4gcnVubmluZyBQbGFzbWljIGZyb21cbiAgICogTmV4dC5qcyBBcHAgUm91dGVyLlxuICAgKi9cbiAgZ2V0U2VydmVySW5mbz86IChwcm9wczogUCwgb3BzOiBSZWFjdFNlcnZlck9wcykgPT4gU2VydmVySW5mbztcbn07XG5cbmV4cG9ydCB0eXBlIEdsb2JhbENvbnRleHRNZXRhPFA+ID0gT21pdDxcbiAgSW50ZXJuYWxHbG9iYWxDb250ZXh0TWV0YTxQPixcbiAgXCJpbXBvcnRQYXRoXCJcbj4gJiB7XG4gIC8qKlxuICAgKiBUaGUgcGF0aCB0byBiZSB1c2VkIHdoZW4gaW1wb3J0aW5nIHRoZSBjb21wb25lbnQgaW4gdGhlIGdlbmVyYXRlZCBjb2RlLlxuICAgKiBJdCBjYW4gYmUgdGhlIG5hbWUgb2YgdGhlIHBhY2thZ2UgdGhhdCBjb250YWlucyB0aGUgY29tcG9uZW50LCBvciB0aGUgcGF0aFxuICAgKiB0byB0aGUgZmlsZSBpbiB0aGUgcHJvamVjdCAocmVsYXRpdmUgdG8gdGhlIHJvb3QgZGlyZWN0b3J5KS5cbiAgICogT3B0aW9uYWw6IG5vdCB1c2VkIGJ5IFBsYXNtaWMgaGVhZGxlc3MgQVBJLCBvbmx5IGJ5IGNvZGVnZW4uXG4gICAqL1xuICBpbXBvcnRQYXRoPzogc3RyaW5nO1xufTtcblxuZXhwb3J0IHR5cGUgQ3VzdG9tRnVuY3Rpb25NZXRhPEYgZXh0ZW5kcyAoLi4uYXJnczogYW55W10pID0+IGFueT4gPSBPbWl0PFxuICBJbnRlcm5hbEN1c3RvbUZ1bmN0aW9uTWV0YTxGPixcbiAgXCJpbXBvcnRQYXRoXCJcbj4gJiB7XG4gIC8qKlxuICAgKiBUaGUgcGF0aCB0byBiZSB1c2VkIHdoZW4gaW1wb3J0aW5nIHRoZSBmdW5jdGlvbiBpbiB0aGUgZ2VuZXJhdGVkIGNvZGUuXG4gICAqIEl0IGNhbiBiZSB0aGUgbmFtZSBvZiB0aGUgcGFja2FnZSB0aGF0IGNvbnRhaW5zIHRoZSBmdW5jdGlvbiwgb3IgdGhlIHBhdGhcbiAgICogdG8gdGhlIGZpbGUgaW4gdGhlIHByb2plY3QgKHJlbGF0aXZlIHRvIHRoZSByb290IGRpcmVjdG9yeSkuXG4gICAqIE9wdGlvbmFsOiBub3QgdXNlZCBieSBQbGFzbWljIGhlYWRsZXNzIEFQSSwgb25seSBieSBjb2RlZ2VuLlxuICAgKi9cbiAgaW1wb3J0UGF0aD86IHN0cmluZztcbn07XG5cbmV4cG9ydCB0eXBlIEZldGNoUGFnZXNPcHRzID0ge1xuICAvKipcbiAgICogV2hldGhlciB0byBpbmNsdWRlIGR5bmFtaWMgcGFnZXMgaW4gZmV0Y2hQYWdlcygpIG91dHB1dC4gQSBwYWdlIGlzXG4gICAqIGNvbnNpZGVyZWQgZHluYW1pYyBpZiBpdHMgcGF0aCBjb250YWlucyBzb21lIHBhcmFtIGJldHdlZW4gYnJhY2tldHMsXG4gICAqIGUuZy4gXCJbc2x1Z11cIi5cbiAgICovXG4gIGluY2x1ZGVEeW5hbWljUGFnZXM/OiBib29sZWFuO1xufTtcblxuZXhwb3J0IGNvbnN0IFNVQlNUSVRVVEVEX0NPTVBPTkVOVFM6IFJlY29yZDxcbiAgc3RyaW5nLFxuICBSZWFjdC5Db21wb25lbnRUeXBlPGFueT5cbj4gPSB7fTtcbmV4cG9ydCBjb25zdCBSRUdJU1RFUkVEX0NPREVfQ09NUE9ORU5UX0hFTFBFUlM6IFJlY29yZDxcbiAgc3RyaW5nLFxuICBJbnRlcm5hbENvZGVDb21wb25lbnRIZWxwZXJzPFJlYWN0LkNvbXBvbmVudFByb3BzPGFueT4+XG4+ID0ge307XG5leHBvcnQgY29uc3QgU1VCU1RJVFVURURfR0xPQkFMX1ZBUklBTlRfSE9PS1M6IFJlY29yZDxzdHJpbmcsICgpID0+IGFueT4gPSB7fTtcbmV4cG9ydCBjb25zdCBSRUdJU1RFUkVEX0NVU1RPTV9GVU5DVElPTlM6IFJlY29yZDxcbiAgc3RyaW5nLFxuICAoLi4uYXJnczogYW55W10pID0+IGFueVxuPiA9IHt9O1xuXG5leHBvcnQgZnVuY3Rpb24gY3VzdG9tRnVuY3Rpb25JbXBvcnRBbGlhczxGIGV4dGVuZHMgKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnk+KFxuICBtZXRhOiBDdXN0b21GdW5jdGlvbk1ldGE8Rj5cbikge1xuICBjb25zdCBjdXN0b21GdW5jdGlvblByZWZpeCA9IGBfX2ZuX2A7XG4gIHJldHVybiBtZXRhLm5hbWVzcGFjZVxuICAgID8gYCR7Y3VzdG9tRnVuY3Rpb25QcmVmaXh9JHttZXRhLm5hbWVzcGFjZX1fXyR7bWV0YS5uYW1lfWBcbiAgICA6IGAke2N1c3RvbUZ1bmN0aW9uUHJlZml4fSR7bWV0YS5uYW1lfWA7XG59XG5cbmludGVyZmFjZSBCdWlsdGluUmVnaXN0ZXJlZE1vZHVsZXMge1xuICByZWFjdDogdHlwZW9mIGltcG9ydChcInJlYWN0XCIpO1xuICBcInJlYWN0LWRvbVwiOiB0eXBlb2YgaW1wb3J0KFwicmVhY3QtZG9tXCIpO1xuICBcInJlYWN0L2pzeC1ydW50aW1lXCI6IHR5cGVvZiBpbXBvcnQoXCJyZWFjdC9qc3gtcnVudGltZVwiKTtcbiAgXCJyZWFjdC9qc3gtZGV2LXJ1bnRpbWVcIjogdHlwZW9mIGltcG9ydChcInJlYWN0L2pzeC1kZXYtcnVudGltZVwiKTtcbiAgXCJAcGxhc21pY2FwcC9xdWVyeVwiOiB0eXBlb2YgaW1wb3J0KFwiQHBsYXNtaWNhcHAvcXVlcnlcIik7XG4gIFwiQHBsYXNtaWNhcHAvZGF0YS1zb3VyY2VzLWNvbnRleHRcIjogdHlwZW9mIGltcG9ydChcIkBwbGFzbWljYXBwL2RhdGEtc291cmNlcy1jb250ZXh0XCIpO1xuICBcIkBwbGFzbWljYXBwL2hvc3RcIjogdHlwZW9mIGltcG9ydChcIkBwbGFzbWljYXBwL2hvc3RcIik7XG4gIFwiQHBsYXNtaWNhcHAvbG9hZGVyLXJ1bnRpbWUtcmVnaXN0cnlcIjoge1xuICAgIGNvbXBvbmVudHM6IFJlY29yZDxzdHJpbmcsIFJlYWN0LkNvbXBvbmVudFR5cGU8YW55Pj47XG4gICAgZ2xvYmFsVmFyaWFudEhvb2tzOiBSZWNvcmQ8c3RyaW5nLCAoKSA9PiBhbnk+O1xuICAgIGNvZGVDb21wb25lbnRIZWxwZXJzOiBSZWNvcmQ8c3RyaW5nLCBDb21wb25lbnRIZWxwZXJzPGFueT4+O1xuICAgIGZ1bmN0aW9uczogUmVjb3JkPHN0cmluZywgKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnk+O1xuICB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZldGNoQ29tcG9uZW50RGF0YU9wdHMge1xuICAvKipcbiAgICogV2lsbCBmZXRjaCBlaXRoZXIgY29kZSB0YXJnZXRpbmcgU1NSIG9yIGJyb3dzZXIgaHlkcmF0aW9uIGluIHRoZVxuICAgKiByZXR1cm5lZCBidW5kbGUuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHRoZSB0YXJnZXQgaXMgYnJvd3Nlci4gVGhhdCdzIG9rYXksIGJlY2F1c2UgZXZlbiB3aGVuXG4gICAqIGRvaW5nIFNTUiwgYXMgbG9uZyBhcyB5b3UgYXJlIHVzaW5nIHRoZSBzYW1lIGluc3RhbmNlIG9mIFBsYXNtaWNMb2FkZXJcbiAgICogdGhhdCB3YXMgdXNlZCB0byBmZXRjaCBjb21wb25lbnQgZGF0YSwgaXQgd2lsbCBzdGlsbCBrbm93IGhvdyB0byBnZXQgYXRcbiAgICogdGhlIHNlcnZlciBjb2RlLlxuICAgKlxuICAgKiBCdXQsIGlmIHlvdSBhcmUgYnVpbGRpbmcgeW91ciBvd24gU1NSIHNvbHV0aW9uLCB3aGVyZSBmZXRjaGluZyBhbmQgcmVuZGVyaW5nXG4gICAqIGFyZSB1c2luZyBkaWZmZXJlbnQgaW5zdGFuY2VzIG9mIFBsYXNtaWNMb2FkZXIsIHRoZW4geW91J2xsIHdhbnQgdG8gbWFrZVxuICAgKiBzdXJlIHRoYXQgd2hlbiB5b3UgZmV0Y2gsIHlvdSBhcmUgZmV0Y2hpbmcgdGhlIHJpZ2h0IG9uZSB0byBiZSB1c2VkIGluIHRoZVxuICAgKiByaWdodCBlbnZpcm9ubWVudCBmb3IgZWl0aGVyIFNTUiBvciBicm93c2VyIGh5ZHJhdGlvbi5cbiAgICovXG4gIHRhcmdldD86IFwic2VydmVyXCIgfCBcImJyb3dzZXJcIjtcbn1cblxuZnVuY3Rpb24gcGFyc2VGZXRjaENvbXBvbmVudERhdGFBcmdzKFxuICBzcGVjczogQ29tcG9uZW50TG9va3VwU3BlY1tdLFxuICBvcHRzPzogRmV0Y2hDb21wb25lbnREYXRhT3B0c1xuKTogeyBzcGVjczogQ29tcG9uZW50TG9va3VwU3BlY1tdOyBvcHRzPzogRmV0Y2hDb21wb25lbnREYXRhT3B0cyB9O1xuZnVuY3Rpb24gcGFyc2VGZXRjaENvbXBvbmVudERhdGFBcmdzKC4uLnNwZWNzOiBDb21wb25lbnRMb29rdXBTcGVjW10pOiB7XG4gIHNwZWNzOiBDb21wb25lbnRMb29rdXBTcGVjW107XG4gIG9wdHM/OiBGZXRjaENvbXBvbmVudERhdGFPcHRzO1xufTtcbmZ1bmN0aW9uIHBhcnNlRmV0Y2hDb21wb25lbnREYXRhQXJncyguLi5hcmdzOiBhbnlbXSkge1xuICBsZXQgc3BlY3M6IENvbXBvbmVudExvb2t1cFNwZWNbXTtcbiAgbGV0IG9wdHM6IEZldGNoQ29tcG9uZW50RGF0YU9wdHMgfCB1bmRlZmluZWQ7XG4gIGlmIChBcnJheS5pc0FycmF5KGFyZ3NbMF0pKSB7XG4gICAgc3BlY3MgPSBhcmdzWzBdO1xuICAgIG9wdHMgPSBhcmdzWzFdO1xuICB9IGVsc2Uge1xuICAgIHNwZWNzID0gYXJncztcbiAgICBvcHRzID0gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiB7IHNwZWNzLCBvcHRzIH07XG59XG5cbi8qKiBTdWJzZXQgb2YgbG9hZGVyIGZ1bmN0aW9uYWxpdHkgdGhhdCB3b3JrcyBvbiBDbGllbnQgYW5kIFJlYWN0IFNlcnZlciBDb21wb25lbnRzLiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJhc2VJbnRlcm5hbFBsYXNtaWNDb21wb25lbnRMb2FkZXIge1xuICBwdWJsaWMgcmVhZG9ubHkgb3B0czogSW5pdE9wdGlvbnM7XG4gIHByaXZhdGUgcmVhZG9ubHkgcmVnaXN0cnkgPSBuZXcgUmVnaXN0cnkoKTtcbiAgcHJpdmF0ZSByZWFkb25seSB0cmFja2VyOiBQbGFzbWljVHJhY2tlcjtcbiAgcHJpdmF0ZSByZWFkb25seSBmZXRjaGVyOiBQbGFzbWljTW9kdWxlc0ZldGNoZXI7XG4gIHByaXZhdGUgcmVhZG9ubHkgb25CdW5kbGVNZXJnZWQ/OiAoKSA9PiB2b2lkO1xuICBwcml2YXRlIHJlYWRvbmx5IG9uQnVuZGxlRmV0Y2hlZD86ICgpID0+IHZvaWQ7XG4gIHByaXZhdGUgZ2xvYmFsVmFyaWFudHM6IEdsb2JhbFZhcmlhbnRTcGVjW10gPSBbXTtcbiAgcHJpdmF0ZSBzdWJzOiBDb21wb25lbnRTdWJzdGl0dXRpb25TcGVjW10gPSBbXTtcblxuICBwcml2YXRlIGJ1bmRsZTogTG9hZGVyQnVuZGxlT3V0cHV0ID0ge1xuICAgIG1vZHVsZXM6IHtcbiAgICAgIGJyb3dzZXI6IFtdLFxuICAgICAgc2VydmVyOiBbXSxcbiAgICB9LFxuICAgIGNvbXBvbmVudHM6IFtdLFxuICAgIGdsb2JhbEdyb3VwczogW10sXG4gICAgcHJvamVjdHM6IFtdLFxuICAgIGFjdGl2ZVNwbGl0czogW10sXG4gICAgYnVuZGxlS2V5OiBudWxsLFxuICAgIGRlZmVyQ2h1bmtzQnlEZWZhdWx0OiBmYWxzZSxcbiAgICBkaXNhYmxlUm9vdExvYWRpbmdCb3VuZGFyeUJ5RGVmYXVsdDogZmFsc2UsXG4gICAgZmlsdGVyZWRJZHM6IHt9LFxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKGFyZ3M6IHtcbiAgICBvcHRzOiBJbml0T3B0aW9ucztcbiAgICBmZXRjaGVyOiBQbGFzbWljTW9kdWxlc0ZldGNoZXI7XG4gICAgdHJhY2tlcjogUGxhc21pY1RyYWNrZXI7XG4gICAgLyoqIENhbGxlZCBhZnRlciBgbWVyZ2VCdW5kbGVgIChpbmNsdWRpbmcgYGZldGNoYCBjYWxscykuICovXG4gICAgb25CdW5kbGVNZXJnZWQ/OiAoKSA9PiB2b2lkO1xuICAgIC8qKiBDYWxsZWQgYWZ0ZXIgYW55IGBmZXRjaGAgY2FsbHMuICovXG4gICAgb25CdW5kbGVGZXRjaGVkPzogKCkgPT4gdm9pZDtcbiAgICBidWlsdGluTW9kdWxlczogQnVpbHRpblJlZ2lzdGVyZWRNb2R1bGVzO1xuICB9KSB7XG4gICAgdGhpcy5vcHRzID0gYXJncy5vcHRzO1xuICAgIHRoaXMuZmV0Y2hlciA9IGFyZ3MuZmV0Y2hlcjtcbiAgICB0aGlzLnRyYWNrZXIgPSBhcmdzLnRyYWNrZXI7XG4gICAgdGhpcy5vbkJ1bmRsZU1lcmdlZCA9IGFyZ3Mub25CdW5kbGVNZXJnZWQ7XG4gICAgdGhpcy5vbkJ1bmRsZUZldGNoZWQgPSBhcmdzLm9uQnVuZGxlRmV0Y2hlZDtcbiAgICB0aGlzLnJlZ2lzdGVyTW9kdWxlcyhhcmdzLmJ1aWx0aW5Nb2R1bGVzKTtcbiAgfVxuXG4gIHByaXZhdGUgbWF5YmVHZXRDb21wTWV0YXMoLi4uc3BlY3M6IENvbXBvbmVudExvb2t1cFNwZWNbXSkge1xuICAgIGNvbnN0IGZvdW5kID0gbmV3IFNldDxDb21wb25lbnRNZXRhPigpO1xuICAgIGNvbnN0IG1pc3Npbmc6IENvbXBvbmVudExvb2t1cFNwZWNbXSA9IFtdO1xuICAgIGZvciAoY29uc3Qgc3BlYyBvZiBzcGVjcykge1xuICAgICAgY29uc3QgZmlsdGVyZWRNZXRhcyA9IGdldENvbXBNZXRhcyh0aGlzLmJ1bmRsZS5jb21wb25lbnRzLCBzcGVjKTtcbiAgICAgIGlmIChmaWx0ZXJlZE1ldGFzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZmlsdGVyZWRNZXRhcy5mb3JFYWNoKChtZXRhKSA9PiBmb3VuZC5hZGQobWV0YSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWlzc2luZy5wdXNoKHNwZWMpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBmb3VuZDogQXJyYXkuZnJvbShmb3VuZC5rZXlzKCkpLCBtaXNzaW5nIH07XG4gIH1cblxuICBhc3luYyBtYXliZUZldGNoQ29tcG9uZW50RGF0YShcbiAgICBzcGVjczogQ29tcG9uZW50TG9va3VwU3BlY1tdLFxuICAgIG9wdHM/OiBGZXRjaENvbXBvbmVudERhdGFPcHRzXG4gICk6IFByb21pc2U8Q29tcG9uZW50UmVuZGVyRGF0YSB8IG51bGw+O1xuICBhc3luYyBtYXliZUZldGNoQ29tcG9uZW50RGF0YShcbiAgICAuLi5zcGVjczogQ29tcG9uZW50TG9va3VwU3BlY1tdXG4gICk6IFByb21pc2U8Q29tcG9uZW50UmVuZGVyRGF0YSB8IG51bGw+O1xuICBhc3luYyBtYXliZUZldGNoQ29tcG9uZW50RGF0YShcbiAgICAuLi5hcmdzOiBhbnlbXVxuICApOiBQcm9taXNlPENvbXBvbmVudFJlbmRlckRhdGEgfCBudWxsPiB7XG4gICAgY29uc3QgeyBzcGVjcywgb3B0cyB9ID0gcGFyc2VGZXRjaENvbXBvbmVudERhdGFBcmdzKC4uLmFyZ3MpO1xuICAgIGNvbnN0IHJldHVybldpdGhTcGVjc1RvRmV0Y2ggPSBhc3luYyAoXG4gICAgICBzcGVjc1RvRmV0Y2g6IENvbXBvbmVudExvb2t1cFNwZWNbXVxuICAgICkgPT4ge1xuICAgICAgYXdhaXQgdGhpcy5mZXRjaE1pc3NpbmdEYXRhKHsgbWlzc2luZ1NwZWNzOiBzcGVjc1RvRmV0Y2ggfSk7XG4gICAgICBjb25zdCB7IGZvdW5kOiBleGlzdGluZ01ldGFzMiwgbWlzc2luZzogbWlzc2luZ1NwZWNzMiB9ID1cbiAgICAgICAgdGhpcy5tYXliZUdldENvbXBNZXRhcyguLi5zcGVjcyk7XG4gICAgICBpZiAobWlzc2luZ1NwZWNzMi5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJlcENvbXBvbmVudERhdGEodGhpcy5idW5kbGUsIGV4aXN0aW5nTWV0YXMyLCBvcHRzKTtcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMub3B0cy5hbHdheXNGcmVzaCkge1xuICAgICAgLy8gSWYgYWx3YXlzRnJlc2gsIHRoZW4gd2UgdHJlYXQgYWxsIHNwZWNzIGFzIG1pc3NpbmdcbiAgICAgIHJldHVybiBhd2FpdCByZXR1cm5XaXRoU3BlY3NUb0ZldGNoKHNwZWNzKTtcbiAgICB9XG5cbiAgICAvLyBFbHNlIHdlIG9ubHkgZmV0Y2ggYWN0dWFsbHkgbWlzc2luZyBzcGVjc1xuICAgIGNvbnN0IHsgZm91bmQ6IGV4aXN0aW5nTWV0YXMsIG1pc3Npbmc6IG1pc3NpbmdTcGVjcyB9ID1cbiAgICAgIHRoaXMubWF5YmVHZXRDb21wTWV0YXMoLi4uc3BlY3MpO1xuICAgIGlmIChtaXNzaW5nU3BlY3MubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gcHJlcENvbXBvbmVudERhdGEodGhpcy5idW5kbGUsIGV4aXN0aW5nTWV0YXMsIG9wdHMpO1xuICAgIH1cblxuICAgIHJldHVybiBhd2FpdCByZXR1cm5XaXRoU3BlY3NUb0ZldGNoKG1pc3NpbmdTcGVjcyk7XG4gIH1cblxuICBhc3luYyBmZXRjaENvbXBvbmVudERhdGEoXG4gICAgc3BlY3M6IENvbXBvbmVudExvb2t1cFNwZWNbXSxcbiAgICBvcHRzPzogRmV0Y2hDb21wb25lbnREYXRhT3B0c1xuICApOiBQcm9taXNlPENvbXBvbmVudFJlbmRlckRhdGE+O1xuICBhc3luYyBmZXRjaENvbXBvbmVudERhdGEoXG4gICAgLi4uc3BlY3M6IENvbXBvbmVudExvb2t1cFNwZWNbXVxuICApOiBQcm9taXNlPENvbXBvbmVudFJlbmRlckRhdGE+O1xuICBhc3luYyBmZXRjaENvbXBvbmVudERhdGEoLi4uYXJnczogYW55W10pOiBQcm9taXNlPENvbXBvbmVudFJlbmRlckRhdGE+IHtcbiAgICBjb25zdCB7IHNwZWNzLCBvcHRzIH0gPSBwYXJzZUZldGNoQ29tcG9uZW50RGF0YUFyZ3MoLi4uYXJncyk7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMubWF5YmVGZXRjaENvbXBvbmVudERhdGEoc3BlY3MsIG9wdHMpO1xuXG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICBjb25zdCB7IG1pc3Npbmc6IG1pc3NpbmdTcGVjcyB9ID0gdGhpcy5tYXliZUdldENvbXBNZXRhcyguLi5zcGVjcyk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBVbmFibGUgdG8gZmluZCBjb21wb25lbnRzICR7bWlzc2luZ1NwZWNzXG4gICAgICAgICAgLm1hcChnZXRMb29rdXBTcGVjTmFtZSlcbiAgICAgICAgICAuam9pbihcIiwgXCIpfWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICBhc3luYyBmZXRjaFBhZ2VzKG9wdHM/OiBGZXRjaFBhZ2VzT3B0cykge1xuICAgIHRoaXMubWF5YmVSZXBvcnRDbGllbnRTaWRlRmV0Y2goXG4gICAgICAoKSA9PiBgUGxhc21pYzogZmV0Y2hpbmcgYWxsIHBhZ2UgbWV0YWRhdGEgaW4gdGhlIGJyb3dzZXJgXG4gICAgKTtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5mZXRjaEFsbERhdGEoKTtcbiAgICByZXR1cm4gZGF0YS5jb21wb25lbnRzLmZpbHRlcihcbiAgICAgIChjb21wKSA9PlxuICAgICAgICBjb21wLmlzUGFnZSAmJlxuICAgICAgICBjb21wLnBhdGggJiZcbiAgICAgICAgKG9wdHM/LmluY2x1ZGVEeW5hbWljUGFnZXMgfHwgIWlzRHluYW1pY1BhZ2VQYXRoKGNvbXAucGF0aCkpXG4gICAgKSBhcyBQYWdlTWV0YVtdO1xuICB9XG5cbiAgYXN5bmMgZmV0Y2hDb21wb25lbnRzKCkge1xuICAgIHRoaXMubWF5YmVSZXBvcnRDbGllbnRTaWRlRmV0Y2goXG4gICAgICAoKSA9PiBgUGxhc21pYzogZmV0Y2hpbmcgYWxsIGNvbXBvbmVudCBtZXRhZGF0YSBpbiB0aGUgYnJvd3NlcmBcbiAgICApO1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmZldGNoQWxsRGF0YSgpO1xuICAgIHJldHVybiBkYXRhLmNvbXBvbmVudHM7XG4gIH1cblxuICBnZXRBY3RpdmVTcGxpdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYnVuZGxlLmFjdGl2ZVNwbGl0cztcbiAgfVxuXG4gIGdldENodW5rc1VybChidW5kbGU6IExvYWRlckJ1bmRsZU91dHB1dCwgbW9kdWxlczogQ29kZU1vZHVsZVtdKSB7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hlci5nZXRDaHVua3NVcmwoYnVuZGxlLCBtb2R1bGVzKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZmV0Y2hNaXNzaW5nRGF0YShvcHRzOiB7XG4gICAgbWlzc2luZ1NwZWNzOiBDb21wb25lbnRMb29rdXBTcGVjW107XG4gIH0pIHtcbiAgICAvLyBUT0RPOiBkbyBiZXR0ZXIgdGhhbiBqdXN0IGZldGNoaW5nIGV2ZXJ5dGhpbmdcbiAgICB0aGlzLm1heWJlUmVwb3J0Q2xpZW50U2lkZUZldGNoKFxuICAgICAgKCkgPT5cbiAgICAgICAgYFBsYXNtaWM6IGZldGNoaW5nIG1pc3NpbmcgY29tcG9uZW50cyBpbiB0aGUgYnJvd3NlcjogJHtvcHRzLm1pc3NpbmdTcGVjc1xuICAgICAgICAgIC5tYXAoKHNwZWMpID0+IGdldExvb2t1cFNwZWNOYW1lKHNwZWMpKVxuICAgICAgICAgIC5qb2luKFwiLCBcIil9YFxuICAgICk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hBbGxEYXRhKCk7XG4gIH1cblxuICBwcml2YXRlIG1heWJlUmVwb3J0Q2xpZW50U2lkZUZldGNoKG1rTXNnOiAoKSA9PiBzdHJpbmcpIHtcbiAgICBpZiAoaXNCcm93c2VyICYmIHRoaXMub3B0cy5vbkNsaWVudFNpZGVGZXRjaCkge1xuICAgICAgY29uc3QgbXNnID0gbWtNc2coKTtcbiAgICAgIGlmICh0aGlzLm9wdHMub25DbGllbnRTaWRlRmV0Y2ggPT09IFwid2FyblwiKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBmZXRjaEFsbERhdGEoKSB7XG4gICAgY29uc3QgYnVuZGxlID0gYXdhaXQgdGhpcy5mZXRjaGVyLmZldGNoQWxsRGF0YSgpO1xuICAgIHRoaXMudHJhY2tlci50cmFja0ZldGNoKCk7XG4gICAgdGhpcy5tZXJnZUJ1bmRsZShidW5kbGUpO1xuICAgIHRoaXMub25CdW5kbGVGZXRjaGVkPy4oKTtcbiAgICByZXR1cm4gYnVuZGxlO1xuICB9XG5cbiAgbWVyZ2VCdW5kbGUobmV3QnVuZGxlOiBMb2FkZXJCdW5kbGVPdXRwdXQpIHtcbiAgICBuZXdCdW5kbGUuYnVuZGxlS2V5ID0gbmV3QnVuZGxlLmJ1bmRsZUtleSA/PyBudWxsO1xuICAgIGlmIChcbiAgICAgIG5ld0J1bmRsZS5idW5kbGVLZXkgJiZcbiAgICAgIHRoaXMuYnVuZGxlLmJ1bmRsZUtleSAmJlxuICAgICAgbmV3QnVuZGxlLmJ1bmRsZUtleSAhPT0gdGhpcy5idW5kbGUuYnVuZGxlS2V5XG4gICAgKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGBQbGFzbWljIEVycm9yOiBEaWZmZXJlbnQgY29kZSBleHBvcnQgaGFzaGVzLiBUaGlzIGNhbiBoYXBwZW4gaWYgeW91ciBhcHAgaXMgdXNpbmcgZGlmZmVyZW50IGxvYWRlcnMgd2l0aCBkaWZmZXJlbnQgcHJvamVjdCBJRHMgb3IgcHJvamVjdCB2ZXJzaW9ucy5cbkNvbmZsaWN0aW5nIHZhbHVlczpcbiR7bmV3QnVuZGxlLmJ1bmRsZUtleX1cbiR7dGhpcy5idW5kbGUuYnVuZGxlS2V5fWBcbiAgICAgICk7XG4gICAgfVxuICAgIC8vIE1lcmdlIHRoZSBvbGQgYnVuZGxlIGludG8gdGhlIG5ldyBidW5kbGUsIHRoaXMgd2F5XG4gICAgLy8gdGhlIG5ldyBidW5kbGUgd2lsbCBlbmZvcmNlIHRoZSBsYXRlc3QgZGF0YSBmcm9tIHRoZSBzZXJ2ZXJcbiAgICAvLyBhbGxvd2luZyBlbGVtZW50cyB0byBiZSBkZWxldGVkIGJ5IG5ld2VyIGJ1bmRsZXNcbiAgICB0aGlzLmJ1bmRsZSA9IG1lcmdlQnVuZGxlcyhuZXdCdW5kbGUsIHRoaXMuYnVuZGxlKTtcblxuICAgIHRoaXMub25CdW5kbGVNZXJnZWQ/LigpO1xuICB9XG5cbiAgZ2V0QnVuZGxlKCk6IExvYWRlckJ1bmRsZU91dHB1dCB7XG4gICAgcmV0dXJuIHRoaXMuYnVuZGxlO1xuICB9XG5cbiAgY2xlYXJDYWNoZSgpIHtcbiAgICB0aGlzLmJ1bmRsZSA9IHtcbiAgICAgIG1vZHVsZXM6IHtcbiAgICAgICAgYnJvd3NlcjogW10sXG4gICAgICAgIHNlcnZlcjogW10sXG4gICAgICB9LFxuICAgICAgY29tcG9uZW50czogW10sXG4gICAgICBnbG9iYWxHcm91cHM6IFtdLFxuICAgICAgcHJvamVjdHM6IFtdLFxuICAgICAgYWN0aXZlU3BsaXRzOiBbXSxcbiAgICAgIGJ1bmRsZUtleTogbnVsbCxcbiAgICAgIGRlZmVyQ2h1bmtzQnlEZWZhdWx0OiBmYWxzZSxcbiAgICAgIGRpc2FibGVSb290TG9hZGluZ0JvdW5kYXJ5QnlEZWZhdWx0OiBmYWxzZSxcbiAgICAgIGZpbHRlcmVkSWRzOiB7fSxcbiAgICB9O1xuICAgIHRoaXMucmVnaXN0cnkuY2xlYXIoKTtcbiAgfVxuXG4gIHJlZ2lzdGVyTW9kdWxlcyhtb2R1bGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSB7XG4gICAgaWYgKFxuICAgICAgT2JqZWN0LmtleXMobW9kdWxlcykuc29tZShcbiAgICAgICAgKG5hbWUpID0+IHRoaXMucmVnaXN0cnkuZ2V0UmVnaXN0ZXJlZE1vZHVsZShuYW1lKSAhPT0gbW9kdWxlc1tuYW1lXVxuICAgICAgKVxuICAgICkge1xuICAgICAgaWYgKCF0aGlzLnJlZ2lzdHJ5LmlzRW1wdHkoKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCJDYWxsaW5nIFBsYXNtaWNDb21wb25lbnRMb2FkZXIucmVnaXN0ZXJNb2R1bGVzKCkgYWZ0ZXIgUGxhc21pYyBjb21wb25lbnQgaGFzIHJlbmRlcmVkOyBzdGFydGluZyBvdmVyLlwiXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMucmVnaXN0cnkuY2xlYXIoKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG1vZHVsZXMpKSB7XG4gICAgICAgIHRoaXMucmVnaXN0cnkucmVnaXN0ZXIoa2V5LCBtb2R1bGVzW2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHN1YnN0aXR1dGVDb21wb25lbnQ8UD4oXG4gICAgY29tcG9uZW50OiBSZWFjdC5Db21wb25lbnRUeXBlPFA+LFxuICAgIG5hbWU6IENvbXBvbmVudExvb2t1cFNwZWNcbiAgKSB7XG4gICAgdGhpcy5pbnRlcm5hbFN1YnN0aXR1dGVDb21wb25lbnQoY29tcG9uZW50LCBuYW1lLCB1bmRlZmluZWQpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGludGVybmFsU3Vic3RpdHV0ZUNvbXBvbmVudDxQPihcbiAgICBjb21wb25lbnQ6IFJlYWN0LkNvbXBvbmVudFR5cGU8UD4sXG4gICAgbmFtZTogQ29tcG9uZW50TG9va3VwU3BlYyxcbiAgICBjb2RlQ29tcG9uZW50SGVscGVyczpcbiAgICAgIHwgSW50ZXJuYWxDb2RlQ29tcG9uZW50SGVscGVyczxcbiAgICAgICAgICBSZWFjdC5Db21wb25lbnRQcm9wczxSZWFjdC5Db21wb25lbnRUeXBlPFA+PlxuICAgICAgICA+XG4gICAgICB8IHVuZGVmaW5lZFxuICApIHtcbiAgICBpZiAoIXRoaXMuaXNSZWdpc3RyeUVtcHR5KCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgXCJDYWxsaW5nIFBsYXNtaWNDb21wb25lbnRMb2FkZXIucmVnaXN0ZXJTdWJzdGl0dXRpb24oKSBhZnRlciBQbGFzbWljIGNvbXBvbmVudCBoYXMgcmVuZGVyZWQ7IHN0YXJ0aW5nIG92ZXIuXCJcbiAgICAgICk7XG4gICAgICB0aGlzLmNsZWFyUmVnaXN0cnkoKTtcbiAgICB9XG4gICAgdGhpcy5zdWJzLnB1c2goeyBsb29rdXA6IG5hbWUsIGNvbXBvbmVudCwgY29kZUNvbXBvbmVudEhlbHBlcnMgfSk7XG4gIH1cblxuICBhYnN0cmFjdCByZWdpc3RlckNvbXBvbmVudDxUIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50VHlwZTxhbnk+PihcbiAgICBjb21wb25lbnQ6IFQsXG4gICAgbWV0YTogQ29kZUNvbXBvbmVudE1ldGE8UmVhY3QuQ29tcG9uZW50UHJvcHM8VD4+XG4gICk6IHZvaWQ7XG4gIGFic3RyYWN0IHJlZ2lzdGVyRnVuY3Rpb248RiBleHRlbmRzICguLi5hcmdzOiBhbnlbXSkgPT4gYW55PihcbiAgICBmbjogRixcbiAgICBtZXRhOiBDdXN0b21GdW5jdGlvbk1ldGE8Rj5cbiAgKTogdm9pZDtcbiAgYWJzdHJhY3QgcmVnaXN0ZXJHbG9iYWxDb250ZXh0PFQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnRUeXBlPGFueT4+KFxuICAgIGNvbnRleHQ6IFQsXG4gICAgbWV0YTogR2xvYmFsQ29udGV4dE1ldGE8UmVhY3QuQ29tcG9uZW50UHJvcHM8VD4+XG4gICk6IHZvaWQ7XG4gIGFic3RyYWN0IHJlZ2lzdGVyVHJhaXQodHJhaXQ6IHN0cmluZywgbWV0YTogVHJhaXRNZXRhKTogdm9pZDtcbiAgYWJzdHJhY3QgcmVnaXN0ZXJUb2tlbih0b2tlbjogVG9rZW5SZWdpc3RyYXRpb24pOiB2b2lkO1xuXG4gIHByb3RlY3RlZCByZWZyZXNoUmVnaXN0cnkoKSB7XG4gICAgLy8gT25jZSB3ZSBoYXZlIHJlY2VpdmVkIGRhdGEsIHdlIHJlZ2lzdGVyIGNvbXBvbmVudHMgdG9cbiAgICAvLyBzdWJzdGl0dXRlLiAgV2UgaGFkIHRvIHdhaXQgZm9yIGRhdGEgdG8gZG8gdGhpcyBzb1xuICAgIC8vIHRoYXQgd2UgY2FuIGxvb2sgdXAgdGhlIHJpZ2h0IG1vZHVsZSBuYW1lIHRvIHN1YnN0aXR1dGVcbiAgICAvLyBpbiBjb21wb25lbnQgbWV0YS5cbiAgICBmb3IgKGNvbnN0IHN1YiBvZiB0aGlzLnN1YnMpIHtcbiAgICAgIGNvbnN0IG1ldGFzID0gZ2V0Q29tcE1ldGFzKHRoaXMuZ2V0QnVuZGxlKCkuY29tcG9uZW50cywgc3ViLmxvb2t1cCk7XG4gICAgICBtZXRhcy5mb3JFYWNoKChtZXRhKSA9PiB7XG4gICAgICAgIFNVQlNUSVRVVEVEX0NPTVBPTkVOVFNbbWV0YS5pZF0gPSBzdWIuY29tcG9uZW50O1xuICAgICAgICBpZiAoc3ViLmNvZGVDb21wb25lbnRIZWxwZXJzKSB7XG4gICAgICAgICAgUkVHSVNURVJFRF9DT0RFX0NPTVBPTkVOVF9IRUxQRVJTW21ldGEuaWRdID0gc3ViLmNvZGVDb21wb25lbnRIZWxwZXJzO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLnJlZ2lzdHJ5LnVwZGF0ZU1vZHVsZXModGhpcy5nZXRCdW5kbGUoKSk7XG4gIH1cblxuICBpc1JlZ2lzdHJ5RW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVnaXN0cnkuaXNFbXB0eSgpO1xuICB9XG5cbiAgY2xlYXJSZWdpc3RyeSgpIHtcbiAgICB0aGlzLnJlZ2lzdHJ5LmNsZWFyKCk7XG4gIH1cblxuICBzZXRHbG9iYWxWYXJpYW50cyhnbG9iYWxWYXJpYW50czogR2xvYmFsVmFyaWFudFNwZWNbXSkge1xuICAgIHRoaXMuZ2xvYmFsVmFyaWFudHMgPSBnbG9iYWxWYXJpYW50cztcbiAgfVxuXG4gIGdldEdsb2JhbFZhcmlhbnRzKCkge1xuICAgIHJldHVybiB0aGlzLmdsb2JhbFZhcmlhbnRzO1xuICB9XG5cbiAgcmVnaXN0ZXJQcmVmZXRjaGVkQnVuZGxlKGJ1bmRsZTogTG9hZGVyQnVuZGxlT3V0cHV0KSB7XG4gICAgLy8gRm9yIFJlYWN0IFNlcnZlciBDb21wb25lbnRzIChOZXh0LmpzIDEzKyksXG4gICAgLy8gd2UgbmVlZCB0byBwYXNzIHNlcnZlciBtb2R1bGVzIGluIExvYWRlckJ1bmRsZU91dHB1dCBmcm9tIFNlcnZlciBDb21wb25lbnRzIHRvIENsaWVudCBDb21wb25lbnRzLlxuICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gcGFzcyB0aGVtIHZpYSBub3JtYWwgcGFnZSBwcm9wcyBiZWNhdXNlIHRoYXQgd2lsbCBiZSBzZXJpYWxpemVkIHRvIHRoZSBicm93c2VyLlxuICAgIC8vIEluc3RlYWQsIHdlIHBhc3MgdGhlIGJ1bmRsZSAoaW5jbHVkaW5nIHRoZSBzZXJ2ZXIgbW9kdWxlcykgdmlhIHRoZSBOb2RlIGBnbG9iYWxgIHZhcmlhYmxlLlxuICAgIC8vXG4gICAgLy8gVGhpcyBpcyB0aGUgY29kZSB0aGF0IHJlYWRzIHRoZSBzdG9yZWQgYnVuZGxlIGFuZCBtZXJnZXMgaXQgYmFjayBpbnRvIHRoZSBsb2FkZXIuXG4gICAgaWYgKCFpc0Jyb3dzZXIpIHtcbiAgICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgYSBjYWNoZWQgYnVuZGxlIG9uIHRoaXMgTm9kZSBzZXJ2ZXIuXG4gICAgICBjb25zdCBjYWNoZWRCdW5kbGUgPSBpbnRlcm5hbF9nZXRDYWNoZWRCdW5kbGVJbk5vZGVTZXJ2ZXIodGhpcy5vcHRzKTtcbiAgICAgIGlmIChjYWNoZWRCdW5kbGUpIHtcbiAgICAgICAgLy8gSWYgaXQncyB0aGVyZSwgbWVyZ2UgdGhlIGNhY2hlZCBidW5kbGUgZmlyc3QuXG4gICAgICAgIHRoaXMubWVyZ2VCdW5kbGUoY2FjaGVkQnVuZGxlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5tZXJnZUJ1bmRsZShidW5kbGUpO1xuICB9XG5cbiAgZ2V0TG9va3VwKCkge1xuICAgIHJldHVybiBuZXcgQ29tcG9uZW50TG9va3VwKHRoaXMuZ2V0QnVuZGxlKCksIHRoaXMucmVnaXN0cnkpO1xuICB9XG5cbiAgdHJhY2tDb252ZXJzaW9uKHZhbHVlID0gMCkge1xuICAgIHRoaXMudHJhY2tlci50cmFja0NvbnZlcnNpb24odmFsdWUpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGdldEFjdGl2ZVZhcmlhdGlvbihcbiAgICBvcHRzOiBPbWl0PFBhcmFtZXRlcnM8dHlwZW9mIGdldEFjdGl2ZVZhcmlhdGlvbj5bMF0sIFwic3BsaXRzXCI+XG4gICkge1xuICAgIGF3YWl0IHRoaXMuZmV0Y2hDb21wb25lbnRzKCk7XG4gICAgcmV0dXJuIGdldEFjdGl2ZVZhcmlhdGlvbih7XG4gICAgICAuLi5vcHRzLFxuICAgICAgc3BsaXRzOiB0aGlzLmdldEJ1bmRsZSgpLmFjdGl2ZVNwbGl0cyxcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRUZWFtSWRzKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gdW5pcShcbiAgICAgIHRoaXMuZ2V0QnVuZGxlKClcbiAgICAgICAgLnByb2plY3RzLm1hcCgocCkgPT5cbiAgICAgICAgICBwLnRlYW1JZCA/IGAke3AudGVhbUlkfSR7cC5pbmRpcmVjdCA/IFwiQGluZGlyZWN0XCIgOiBcIlwifWAgOiBudWxsXG4gICAgICAgIClcbiAgICAgICAgLmZpbHRlcigoeCk6IHggaXMgc3RyaW5nID0+ICEheClcbiAgICApO1xuICB9XG5cbiAgcHVibGljIGdldFByb2plY3RJZHMoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiB1bmlxKFxuICAgICAgdGhpcy5nZXRCdW5kbGUoKS5wcm9qZWN0cy5tYXAoXG4gICAgICAgIChwKSA9PiBgJHtwLmlkfSR7cC5pbmRpcmVjdCA/IFwiQGluZGlyZWN0XCIgOiBcIlwifWBcbiAgICAgIClcbiAgICApO1xuICB9XG5cbiAgcHVibGljIHRyYWNrUmVuZGVyKG9wdHM/OiBUcmFja1JlbmRlck9wdGlvbnMpIHtcbiAgICB0aGlzLnRyYWNrZXIudHJhY2tSZW5kZXIob3B0cyk7XG4gIH1cbn1cblxuLyoqXG4gKiBMaWJyYXJ5IGZvciBmZXRjaGluZyBjb21wb25lbnQgZGF0YSwgYW5kIHJlZ2lzdGVyaW5nXG4gKiBjdXN0b20gY29tcG9uZW50cy5cbiAqL1xuZXhwb3J0IGNsYXNzIFBsYXNtaWNDb21wb25lbnRMb2FkZXIge1xuICBwcml2YXRlIF9faW50ZXJuYWw6IEJhc2VJbnRlcm5hbFBsYXNtaWNDb21wb25lbnRMb2FkZXI7XG5cbiAgY29uc3RydWN0b3IoaW50ZXJuYWw6IEJhc2VJbnRlcm5hbFBsYXNtaWNDb21wb25lbnRMb2FkZXIpIHtcbiAgICB0aGlzLl9faW50ZXJuYWwgPSBpbnRlcm5hbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGdsb2JhbCB2YXJpYW50cyB0byBiZSB1c2VkIGZvciBhbGwgY29tcG9uZW50cy4gIE5vdGUgdGhhdFxuICAgKiB0aGlzIGlzIG5vdCByZWFjdGl2ZSwgYW5kIHdpbGwgbm90IHJlLXJlbmRlciBhbGwgY29tcG9uZW50c1xuICAgKiBhbHJlYWR5IG1vdW50ZWQ7IGluc3RlYWQsIGl0IHNob3VsZCBiZSB1c2VkIHRvIGFjdGl2YXRlIGdsb2JhbFxuICAgKiB2YXJpYW50cyB0aGF0IHNob3VsZCBhbHdheXMgYmUgYWN0aXZhdGVkIGZvciB0aGUgbGlmZXRpbWUgb2YgdGhpc1xuICAgKiBhcHAuICBJZiB5b3UnZCBsaWtlIHRvIHJlYWN0aXZlbHkgY2hhbmdlIHRoZSBnbG9iYWwgdmFyaWFudHMsXG4gICAqIHlvdSBzaG91bGQgc3BlY2lmeSB0aGVtIHZpYSA8UGxhc21pY1Jvb3RQcm92aWRlciAvPlxuICAgKi9cbiAgc2V0R2xvYmFsVmFyaWFudHMoZ2xvYmFsVmFyaWFudHM6IEdsb2JhbFZhcmlhbnRTcGVjW10pIHtcbiAgICB0aGlzLl9faW50ZXJuYWwuc2V0R2xvYmFsVmFyaWFudHMoZ2xvYmFsVmFyaWFudHMpO1xuICB9XG5cbiAgcmVnaXN0ZXJNb2R1bGVzKG1vZHVsZXM6IFJlY29yZDxzdHJpbmcsIGFueT4pIHtcbiAgICB0aGlzLl9faW50ZXJuYWwucmVnaXN0ZXJNb2R1bGVzKG1vZHVsZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGN1c3RvbSBjb21wb25lbnRzIHRoYXQgc2hvdWxkIGJlIHN3YXBwZWQgaW4gZm9yXG4gICAqIGNvbXBvbmVudHMgZGVmaW5lZCBpbiB5b3VyIHByb2plY3QuICBZb3UgY2FuIHVzZSB0aGlzIHRvXG4gICAqIHN3YXAgaW4gLyBzdWJzdGl0dXRlIGEgUGxhc21pYyBjb21wb25lbnQgd2l0aCBhIFwicmVhbFwiIGNvbXBvbmVudC5cbiAgICovXG4gIHN1YnN0aXR1dGVDb21wb25lbnQ8UD4oXG4gICAgY29tcG9uZW50OiBSZWFjdC5Db21wb25lbnRUeXBlPFA+LFxuICAgIG5hbWU6IENvbXBvbmVudExvb2t1cFNwZWNcbiAgKSB7XG4gICAgdGhpcy5fX2ludGVybmFsLnN1YnN0aXR1dGVDb21wb25lbnQoY29tcG9uZW50LCBuYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBjb2RlIGNvbXBvbmVudHMgdG8gYmUgdXNlZCBvbiBQbGFzbWljIEVkaXRvci5cbiAgICovXG4gIHJlZ2lzdGVyQ29tcG9uZW50PFQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnRUeXBlPGFueT4+KFxuICAgIGNvbXBvbmVudDogVCxcbiAgICBtZXRhOiBDb2RlQ29tcG9uZW50TWV0YTxSZWFjdC5Db21wb25lbnRQcm9wczxUPj5cbiAgKTogdm9pZDtcblxuICAvKipcbiAgICogW1tkZXByZWNhdGVkXV0gUGxlYXNlIHVzZSBgc3Vic3RpdHV0ZUNvbXBvbmVudGAgaW5zdGVhZCBmb3IgY29tcG9uZW50XG4gICAqIHN1YnN0aXR1dGlvbiwgb3IgdGhlIG90aGVyIGByZWdpc3RlckNvbXBvbmVudGAgb3ZlcmxvYWQgdG8gcmVnaXN0ZXJcbiAgICogY29kZSBjb21wb25lbnRzIHRvIGJlIHVzZWQgb24gUGxhc21pYyBFZGl0b3IuXG4gICAqXG4gICAqIEBzZWUgYHN1YnN0aXR1dGVDb21wb25lbnRgXG4gICAqL1xuICByZWdpc3RlckNvbXBvbmVudDxUIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50VHlwZTxhbnk+PihcbiAgICBjb21wb25lbnQ6IFQsXG4gICAgbmFtZTogQ29tcG9uZW50TG9va3VwU3BlY1xuICApOiB2b2lkO1xuXG4gIHJlZ2lzdGVyQ29tcG9uZW50PFQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnRUeXBlPGFueT4+KFxuICAgIGNvbXBvbmVudDogVCxcbiAgICBtZXRhT3JOYW1lOiBDb21wb25lbnRMb29rdXBTcGVjIHwgQ29kZUNvbXBvbmVudE1ldGE8UmVhY3QuQ29tcG9uZW50UHJvcHM8VD4+XG4gICkge1xuICAgIC8vICdwcm9wcycgaXMgYSByZXF1aXJlZCBmaWVsZCBpbiBDb2RlQ29tcG9uZW50TWV0YVxuICAgIGlmIChtZXRhT3JOYW1lICYmIHR5cGVvZiBtZXRhT3JOYW1lID09PSBcIm9iamVjdFwiICYmIFwicHJvcHNcIiBpbiBtZXRhT3JOYW1lKSB7XG4gICAgICB0aGlzLl9faW50ZXJuYWwucmVnaXN0ZXJDb21wb25lbnQoY29tcG9uZW50LCBtZXRhT3JOYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRGVwcmVjYXRlZCBjYWxsXG4gICAgICBpZiAoXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIgJiZcbiAgICAgICAgIXRoaXMud2FybmVkUmVnaXN0ZXJDb21wb25lbnRcbiAgICAgICkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgYFBsYXNtaWNMb2FkZXI6IFVzaW5nIGRlcHJlY2F0ZWQgbWV0aG9kIFxcYHJlZ2lzdGVyQ29tcG9uZW50XFxgIGZvciBjb21wb25lbnQgc3Vic3RpdHV0aW9uLiBgICtcbiAgICAgICAgICAgIGBQbGVhc2UgY29uc2lkZXIgdXNpbmcgXFxgc3Vic3RpdHV0ZUNvbXBvbmVudFxcYCBpbnN0ZWFkLmBcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy53YXJuZWRSZWdpc3RlckNvbXBvbmVudCA9IHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLnN1YnN0aXR1dGVDb21wb25lbnQoY29tcG9uZW50LCBtZXRhT3JOYW1lKTtcbiAgICB9XG4gIH1cbiAgcHJpdmF0ZSB3YXJuZWRSZWdpc3RlckNvbXBvbmVudCA9IGZhbHNlO1xuXG4gIHJlZ2lzdGVyRnVuY3Rpb248RiBleHRlbmRzICguLi5hcmdzOiBhbnlbXSkgPT4gYW55PihcbiAgICBmbjogRixcbiAgICBtZXRhOiBDdXN0b21GdW5jdGlvbk1ldGE8Rj5cbiAgKSB7XG4gICAgdGhpcy5fX2ludGVybmFsLnJlZ2lzdGVyRnVuY3Rpb24oZm4sIG1ldGEpO1xuICB9XG5cbiAgcmVnaXN0ZXJHbG9iYWxDb250ZXh0PFQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnRUeXBlPGFueT4+KFxuICAgIGNvbnRleHQ6IFQsXG4gICAgbWV0YTogR2xvYmFsQ29udGV4dE1ldGE8UmVhY3QuQ29tcG9uZW50UHJvcHM8VD4+XG4gICkge1xuICAgIHRoaXMuX19pbnRlcm5hbC5yZWdpc3Rlckdsb2JhbENvbnRleHQoY29udGV4dCwgbWV0YSk7XG4gIH1cblxuICByZWdpc3RlclRyYWl0KHRyYWl0OiBzdHJpbmcsIG1ldGE6IFRyYWl0TWV0YSkge1xuICAgIHRoaXMuX19pbnRlcm5hbC5yZWdpc3RlclRyYWl0KHRyYWl0LCBtZXRhKTtcbiAgfVxuXG4gIHJlZ2lzdGVyVG9rZW4odG9rZW46IFRva2VuUmVnaXN0cmF0aW9uKSB7XG4gICAgdGhpcy5fX2ludGVybmFsLnJlZ2lzdGVyVG9rZW4odG9rZW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIFByZS1mZXRjaGVzIGNvbXBvbmVudCBkYXRhIG5lZWRlZCB0byBmb3IgUGxhc21pY0xvYWRlciB0byByZW5kZXJcbiAgICogdGhlc2UgY29tcG9uZW50cy4gIFNob3VsZCBiZSBwYXNzZWQgaW50byBQbGFzbWljUm9vdFByb3ZpZGVyIGFzXG4gICAqIHRoZSBwcmVmZXRjaGVkRGF0YSBwcm9wLlxuICAgKlxuICAgKiBZb3UgY2FuIGxvb2sgdXAgYSBjb21wb25lbnQgZWl0aGVyIGJ5OlxuICAgKiAtIHRoZSBuYW1lIG9mIHRoZSBjb21wb25lbnRcbiAgICogLSB0aGUgcGF0aCBmb3IgYSBwYWdlIGNvbXBvbmVudFxuICAgKiAtIGFuIGFycmF5IG9mIHN0cmluZ3MgdGhhdCBtYWtlIHVwIHBhcnRzIG9mIHRoZSBwYXRoXG4gICAqIC0gb2JqZWN0IHsgbmFtZTogXCJuYW1lX29yX3BhdGhcIiwgcHJvamVjdElkOiAuLi59LCB0byBzcGVjaWZ5IHdoaWNoIHByb2plY3RcbiAgICogICB0byB1c2UsIGlmIG11bHRpcGxlIHByb2plY3RzIGhhdmUgdGhlIHNhbWUgY29tcG9uZW50IG5hbWVcbiAgICpcbiAgICogVGhyb3dzIGFuIEVycm9yIGlmIGEgc3BlY2lmaWVkIGNvbXBvbmVudCB0byBmZXRjaCBkb2VzIG5vdCBleGlzdCBpblxuICAgKiB0aGUgUGxhc21pYyBwcm9qZWN0LlxuICAgKi9cbiAgZmV0Y2hDb21wb25lbnREYXRhKFxuICAgIC4uLnNwZWNzOiBDb21wb25lbnRMb29rdXBTcGVjW11cbiAgKTogUHJvbWlzZTxDb21wb25lbnRSZW5kZXJEYXRhPjtcbiAgZmV0Y2hDb21wb25lbnREYXRhKFxuICAgIHNwZWNzOiBDb21wb25lbnRMb29rdXBTcGVjW10sXG4gICAgb3B0cz86IEZldGNoQ29tcG9uZW50RGF0YU9wdHNcbiAgKTogUHJvbWlzZTxDb21wb25lbnRSZW5kZXJEYXRhPjtcbiAgZmV0Y2hDb21wb25lbnREYXRhKC4uLmFyZ3M6IGFueVtdKTogUHJvbWlzZTxDb21wb25lbnRSZW5kZXJEYXRhPiB7XG4gICAgcmV0dXJuIHRoaXMuX19pbnRlcm5hbC5mZXRjaENvbXBvbmVudERhdGEoLi4uYXJncyk7XG4gIH1cblxuICAvKipcbiAgICogTGlrZSBmZXRjaENvbXBvbmVudERhdGEoKSwgYnV0IHJldHVybnMgbnVsbCBpbnN0ZWFkIG9mIHRocm93aW5nIGFuIEVycm9yXG4gICAqIHdoZW4gYSBjb21wb25lbnQgaXMgbm90IGZvdW5kLiAgVXNlZnVsIHdoZW4geW91IGFyZSBpbXBsZW1lbnRpbmcgYSBjYXRjaC1hbGxcbiAgICogcGFnZSBhbmQgd2FudCB0byBjaGVjayBpZiBhIHNwZWNpZmljIHBhdGggaGFkIGJlZW4gZGVmaW5lZCBmb3IgUGxhc21pYy5cbiAgICovXG4gIGFzeW5jIG1heWJlRmV0Y2hDb21wb25lbnREYXRhKFxuICAgIC4uLnNwZWNzOiBDb21wb25lbnRMb29rdXBTcGVjW11cbiAgKTogUHJvbWlzZTxDb21wb25lbnRSZW5kZXJEYXRhIHwgbnVsbD47XG4gIGFzeW5jIG1heWJlRmV0Y2hDb21wb25lbnREYXRhKFxuICAgIHNwZWNzOiBDb21wb25lbnRMb29rdXBTcGVjW10sXG4gICAgb3B0cz86IEZldGNoQ29tcG9uZW50RGF0YU9wdHNcbiAgKTogUHJvbWlzZTxDb21wb25lbnRSZW5kZXJEYXRhIHwgbnVsbD47XG4gIGFzeW5jIG1heWJlRmV0Y2hDb21wb25lbnREYXRhKFxuICAgIC4uLmFyZ3M6IGFueVtdXG4gICk6IFByb21pc2U8Q29tcG9uZW50UmVuZGVyRGF0YSB8IG51bGw+IHtcbiAgICByZXR1cm4gdGhpcy5fX2ludGVybmFsLm1heWJlRmV0Y2hDb21wb25lbnREYXRhKC4uLmFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIHRoZSBwYWdlIGNvbXBvbmVudCBtZXRhZGF0YSBmb3IgdGhlc2UgcHJvamVjdHMuXG4gICAqL1xuICBhc3luYyBmZXRjaFBhZ2VzKG9wdHM/OiBGZXRjaFBhZ2VzT3B0cykge1xuICAgIHJldHVybiB0aGlzLl9faW50ZXJuYWwuZmV0Y2hQYWdlcyhvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBjb21wb25lbnRzIG1ldGFkYXRhIGZvciB0aGVzZSBwcm9qZWN0cy5cbiAgICovXG4gIGFzeW5jIGZldGNoQ29tcG9uZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fX2ludGVybmFsLmZldGNoQ29tcG9uZW50cygpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIF9nZXRBY3RpdmVWYXJpYXRpb24oXG4gICAgb3B0czogUGFyYW1ldGVyczx0eXBlb2YgdGhpcy5fX2ludGVybmFsLmdldEFjdGl2ZVZhcmlhdGlvbj5bMF1cbiAgKSB7XG4gICAgcmV0dXJuIHRoaXMuX19pbnRlcm5hbC5nZXRBY3RpdmVWYXJpYXRpb24ob3B0cyk7XG4gIH1cblxuICBhc3luYyBnZXRBY3RpdmVWYXJpYXRpb24ob3B0czoge1xuICAgIGtub3duPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbiAgICB0cmFpdHM6IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4+O1xuICB9KSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldEFjdGl2ZVZhcmlhdGlvbih7XG4gICAgICB0cmFpdHM6IG9wdHMudHJhaXRzLFxuICAgICAgZ2V0S25vd25WYWx1ZTogKGtleTogc3RyaW5nKSA9PiB7XG4gICAgICAgIGlmIChvcHRzLmtub3duKSB7XG4gICAgICAgICAgcmV0dXJuIG9wdHMua25vd25ba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBjb29raWVzID0gZ2V0UGxhc21pY0Nvb2tpZVZhbHVlcygpO1xuICAgICAgICAgIHJldHVybiBjb29raWVzW2tleV07XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1cGRhdGVLbm93blZhbHVlOiAoa2V5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpID0+IHtcbiAgICAgICAgaWYgKCFvcHRzLmtub3duKSB7XG4gICAgICAgICAgdXBkYXRlUGxhc21pY0Nvb2tpZVZhbHVlKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgIH0pO1xuICB9XG5cbiAgZ2V0Q2h1bmtzVXJsKGJ1bmRsZTogTG9hZGVyQnVuZGxlT3V0cHV0LCBtb2R1bGVzOiBDb2RlTW9kdWxlW10pIHtcbiAgICByZXR1cm4gdGhpcy5fX2ludGVybmFsLmdldENodW5rc1VybChidW5kbGUsIG1vZHVsZXMpO1xuICB9XG5cbiAgZ2V0RXh0ZXJuYWxWYXJpYXRpb24oXG4gICAgdmFyaWF0aW9uOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+LFxuICAgIGZpbHRlcnM/OiBQYXJhbWV0ZXJzPHR5cGVvZiBnZXRFeHRlcm5hbElkcz5bMl1cbiAgKSB7XG4gICAgcmV0dXJuIGdldEV4dGVybmFsSWRzKHRoaXMuZ2V0QWN0aXZlU3BsaXRzKCksIHZhcmlhdGlvbiwgZmlsdGVycyk7XG4gIH1cblxuICBnZXRBY3RpdmVTcGxpdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19pbnRlcm5hbC5nZXRBY3RpdmVTcGxpdHMoKTtcbiAgfVxuXG4gIHRyYWNrQ29udmVyc2lvbih2YWx1ZSA9IDApIHtcbiAgICB0aGlzLl9faW50ZXJuYWwudHJhY2tDb252ZXJzaW9uKHZhbHVlKTtcbiAgfVxuXG4gIGNsZWFyQ2FjaGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19pbnRlcm5hbC5jbGVhckNhY2hlKCk7XG4gIH1cbn1cbiIsImltcG9ydCB7XG4gIENvbXBvbmVudE1ldGEsXG4gIGdldEJ1bmRsZVN1YnNldCxcbiAgTG9hZGVyQnVuZGxlT3V0cHV0LFxufSBmcm9tIFwiQHBsYXNtaWNhcHAvbG9hZGVyLWNvcmVcIjtcbmltcG9ydCB0eXBlIHsgQ29tcG9uZW50UmVuZGVyRGF0YSB9IGZyb20gXCIuL2xvYWRlci1zaGFyZWRcIjtcbmltcG9ydCB7IGludGVyc2VjdCB9IGZyb20gXCIuL3V0aWxzXCI7XG5cbmZ1bmN0aW9uIGdldFVzZWRDb21wcyhhbGxDb21wb25lbnRzOiBDb21wb25lbnRNZXRhW10sIGVudHJ5Q29tcElkczogc3RyaW5nW10pIHtcbiAgY29uc3QgcTogc3RyaW5nW10gPSBbLi4uZW50cnlDb21wSWRzXTtcbiAgY29uc3Qgc2VlbklkcyA9IG5ldyBTZXQ8c3RyaW5nPihlbnRyeUNvbXBJZHMpO1xuICBjb25zdCBjb21wb25lbnRNZXRhQnlJZCA9IG5ldyBNYXA8c3RyaW5nLCBDb21wb25lbnRNZXRhPihcbiAgICBhbGxDb21wb25lbnRzLm1hcCgobWV0YSkgPT4gW21ldGEuaWQsIG1ldGFdKVxuICApO1xuICBjb25zdCB1c2VkQ29tcHM6IENvbXBvbmVudE1ldGFbXSA9IFtdO1xuICB3aGlsZSAocS5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgW2lkXSA9IHEuc3BsaWNlKDAsIDEpO1xuICAgIGNvbnN0IG1ldGEgPSBjb21wb25lbnRNZXRhQnlJZC5nZXQoaWQpO1xuICAgIGlmICghbWV0YSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHVzZWRDb21wcy5wdXNoKG1ldGEpO1xuICAgIG1ldGEudXNlZENvbXBvbmVudHMuZm9yRWFjaCgodXNlZENvbXBJZCkgPT4ge1xuICAgICAgaWYgKCFzZWVuSWRzLmhhcyh1c2VkQ29tcElkKSkge1xuICAgICAgICBzZWVuSWRzLmFkZCh1c2VkQ29tcElkKTtcbiAgICAgICAgcS5wdXNoKHVzZWRDb21wSWQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiB1c2VkQ29tcHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcmVwQ29tcG9uZW50RGF0YShcbiAgYnVuZGxlOiBMb2FkZXJCdW5kbGVPdXRwdXQsXG4gIGNvbXBNZXRhczogQ29tcG9uZW50TWV0YVtdLFxuICBvcHRzPzoge1xuICAgIHRhcmdldD86IFwiYnJvd3NlclwiIHwgXCJzZXJ2ZXJcIjtcbiAgfVxuKTogQ29tcG9uZW50UmVuZGVyRGF0YSB7XG4gIGlmIChjb21wTWV0YXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVudHJ5Q29tcE1ldGFzOiBidW5kbGUuY29tcG9uZW50cyxcbiAgICAgIGJ1bmRsZTogYnVuZGxlLFxuICAgICAgcmVtb3RlRm9udFVybHM6IFtdLFxuICAgIH07XG4gIH1cblxuICBjb25zdCB1c2VkQ29tcHMgPSBnZXRVc2VkQ29tcHMoXG4gICAgYnVuZGxlLmNvbXBvbmVudHMsXG4gICAgY29tcE1ldGFzLm1hcCgoY29tcE1ldGEpID0+IGNvbXBNZXRhLmlkKVxuICApO1xuICBjb25zdCBjb21wUGF0aHMgPSB1c2VkQ29tcHMubWFwKChjb21wTWV0YSkgPT4gY29tcE1ldGEuZW50cnkpO1xuICBjb25zdCBzdWJCdW5kbGUgPSBnZXRCdW5kbGVTdWJzZXQoXG4gICAgYnVuZGxlLFxuICAgIFtcbiAgICAgIFwiZW50cnlwb2ludC5jc3NcIixcbiAgICAgIC4uLmNvbXBQYXRocyxcbiAgICAgIFwicm9vdC1wcm92aWRlci5qc1wiLFxuICAgICAgLi4uYnVuZGxlLnByb2plY3RzXG4gICAgICAgIC5tYXAoKHgpID0+IHguZ2xvYmFsQ29udGV4dHNQcm92aWRlckZpbGVOYW1lKVxuICAgICAgICAuZmlsdGVyKCh4KSA9PiAhIXgpLFxuICAgICAgLy8gV2UgbmVlZCB0byBleHBsaWNpdGx5IGluY2x1ZGUgZ2xvYmFsIGNvbnRleHQgcHJvdmlkZXIgY29tcG9uZW50c1xuICAgICAgLy8gdG8gbWFrZSBzdXJlIHRoZXkgYXJlIGtlcHQgaW4gYnVuZGxlLmNvbXBvbmVudHMuIFRoYXQncyBiZWNhdXNlXG4gICAgICAvLyBmb3IgZXNidWlsZCwganVzdCB0aGUgZ2xvYmFsQ29udGV4dHNQcm92aWRlckZpbGVOYW1lIGlzIG5vdCBlbm91Z2gsXG4gICAgICAvLyBiZWNhdXNlIGl0IHdpbGwgaW1wb3J0IGEgY2h1bmsgdGhhdCBpbmNsdWRlcyB0aGUgZ2xvYmFsIGNvbnRleHRcbiAgICAgIC8vIGNvbXBvbmVudCwgaW5zdGVhZCBvZiBpbXBvcnRpbmcgdGhhdCBnbG9iYWwgY29udGV4dCBjb21wb25lbnQnc1xuICAgICAgLy8gZW50cnkgZmlsZS4gQW5kIGJlY2F1c2Ugbm90aGluZyBkZXBlbmRzIG9uIHRoZSBnbG9iYWwgY29udGV4dCBjb21wb25lbnQnc1xuICAgICAgLy8gZW50cnkgZmlsZSwgd2UgZW5kIHVwIGV4Y2x1ZGluZyB0aGUgZ2xvYmFsIGNvbnRleHQgY29tcG9uZW50IGZyb21cbiAgICAgIC8vIGJ1bmRsZS5jb21wb25lbnRzLCB3aGljaCB0aGVuIG1ha2VzIGl0cyBzdWJzdGl0dXRpb24gbm90IHdvcmsuXG4gICAgICAvLyBJbnN0ZWFkLCB3ZSBmb3JjaWJseSBpbmNsdWRlIGl0IGhlcmUgKHdlJ2xsIGRlZmluaXRlbHkgbmVlZCBpdCBhbnl3YXkhKS5cbiAgICAgIC4uLmJ1bmRsZS5jb21wb25lbnRzXG4gICAgICAgIC5maWx0ZXIoKGMpID0+IGMuaXNHbG9iYWxDb250ZXh0UHJvdmlkZXIpXG4gICAgICAgIC5tYXAoKGMpID0+IGMuZW50cnkpLFxuICAgICAgLi4uYnVuZGxlLmdsb2JhbEdyb3Vwcy5tYXAoKGcpID0+IGcuY29udGV4dEZpbGUpLFxuICAgIF0sXG4gICAgb3B0c1xuICApO1xuXG4gIGNvbnN0IHJlbW90ZUZvbnRVcmxzOiBzdHJpbmdbXSA9IFtdO1xuICBzdWJCdW5kbGUucHJvamVjdHMuZm9yRWFjaCgocCkgPT5cbiAgICByZW1vdGVGb250VXJscy5wdXNoKC4uLnAucmVtb3RlRm9udHMubWFwKChmKSA9PiBmLnVybCkpXG4gICk7XG5cbiAgcmV0dXJuIHtcbiAgICBlbnRyeUNvbXBNZXRhczogY29tcE1ldGFzLFxuICAgIGJ1bmRsZTogc3ViQnVuZGxlLFxuICAgIHJlbW90ZUZvbnRVcmxzLFxuICB9O1xufVxuXG4vLyBJdCdzIGltcG9ydGFudCB0byBkZWVwIGNsb25lIGFueSBhdHRyaWJ1dGVzIHRoYXQgYXJlIGdvaW5nIHRvIGJlIGNoYW5nZWQgaW4gdGhlXG4vLyB0YXJnZXQgYnVuZGxlLCBzaW5jZSB0aGUgYnVpbGQgb2YgcGFnZXMgY2FuIGJlIGRvbmUgaW4gbXVsdGlwbGUgc3RhZ2VzL3Byb2Nlc3Nlc1xuLy8gd2UgZG9uJ3Qgd2FudCB0byBtdXRhdGUgdGhlIG9yaWdpbmFsIGJ1bmRsZSwgd2hpY2ggY2FuIGltcGFjdCBvdGhlciBwYWdlcy5cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUJ1bmRsZXMoXG4gIHRhcmdldDogTG9hZGVyQnVuZGxlT3V0cHV0LFxuICBmcm9tOiBMb2FkZXJCdW5kbGVPdXRwdXRcbikge1xuICBjb25zdCBleGlzdGluZ1Byb2plY3RzID0gbmV3IFNldCh0YXJnZXQucHJvamVjdHMubWFwKChwKSA9PiBwLmlkKSk7XG4gIGNvbnN0IG5ld1Byb2plY3RzID0gZnJvbS5wcm9qZWN0cy5maWx0ZXIoKHApID0+ICFleGlzdGluZ1Byb2plY3RzLmhhcyhwLmlkKSk7XG4gIGlmIChuZXdQcm9qZWN0cy5sZW5ndGggPiAwKSB7XG4gICAgdGFyZ2V0ID0ge1xuICAgICAgLi4udGFyZ2V0LFxuICAgICAgcHJvamVjdHM6IFsuLi50YXJnZXQucHJvamVjdHMsIC4uLm5ld1Byb2plY3RzXSxcbiAgICB9O1xuICB9XG5cbiAgY29uc3QgZXhpc3RpbmdDb21wSWRzID0gbmV3IFNldCh0YXJnZXQuY29tcG9uZW50cy5tYXAoKGMpID0+IGMuaWQpKTtcblxuICBmdW5jdGlvbiBzaG91bGRJbmNsdWRlQ29tcG9uZW50SW5CdW5kbGUoYzogQ29tcG9uZW50TWV0YSkge1xuICAgIC8vIElmIHRoZSBjb21wb25lbnQgaXMgYWxyZWFkeSBwcmVzZW50IGluIHRoZSB0YXJnZXQgYnVuZGxlLCBkb24ndCBpbmNsdWRlIGl0XG4gICAgaWYgKGV4aXN0aW5nQ29tcElkcy5oYXMoYy5pZCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gSWYgdGhlIGNvbXBvbmVudCBiZWxvbmdzIHRvIGEgcHJvamVjdCB0aGF0IGlzIG5vdCBwcmVzZW50IGluIHRoZSB0YXJnZXQgYnVuZGxlLFxuICAgIC8vIGluY2x1ZGUgaXRcbiAgICBpZiAoIWV4aXN0aW5nUHJvamVjdHMuaGFzKGMucHJvamVjdElkKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIElmIHRoZSBjb21wb25lbnQgaXMgcHJlc2VudCBpbiB0aGUgZmlsdGVyZWRJZHMgb2YgdGhlIHByb2plY3QgaXQgYmVsb25ncyB0byxcbiAgICAvLyBpbiB0aGUgdGFyZ2V0IGJ1bmRsZSwgd2UgY29uc2lkZXIgdGhhdCB0aGUgY29tcG9uZW50IHdhcyBub3QgZGVsZXRlZCBpbiB0aGUgdGFyZ2V0XG4gICAgLy8gYnVuZGxlLCBzbyB3ZSBjYW4gaW5jbHVkZSBpdFxuICAgIGNvbnN0IHRhcmdldEJ1bmRsZUZpbHRlcmVkSWRzID0gdGFyZ2V0LmZpbHRlcmVkSWRzW2MucHJvamVjdElkXSA/PyBbXTtcbiAgICByZXR1cm4gdGFyZ2V0QnVuZGxlRmlsdGVyZWRJZHMuaW5jbHVkZXMoYy5pZCk7XG4gIH1cblxuICBjb25zdCBuZXdDb21wTWV0YXMgPSBmcm9tLmNvbXBvbmVudHMuZmlsdGVyKChtKSA9PlxuICAgIHNob3VsZEluY2x1ZGVDb21wb25lbnRJbkJ1bmRsZShtKVxuICApO1xuICBpZiAobmV3Q29tcE1ldGFzLmxlbmd0aCA+IDApIHtcbiAgICB0YXJnZXQgPSB7XG4gICAgICAuLi50YXJnZXQsXG4gICAgICBjb21wb25lbnRzOiBbLi4udGFyZ2V0LmNvbXBvbmVudHMsIC4uLm5ld0NvbXBNZXRhc10sXG4gICAgfTtcblxuICAgIC8vIERlZXAgY2xvbmUgdGhlIGZpbHRlcmVkSWRzIG9iamVjdCB0byBhdm9pZCBtdXRhdGluZyB0aGUgb3JpZ2luYWwgYnVuZGxlXG4gICAgdGFyZ2V0LmZpbHRlcmVkSWRzID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgT2JqZWN0LmVudHJpZXModGFyZ2V0LmZpbHRlcmVkSWRzKS5tYXAoKFtrLCB2XSkgPT4gW2ssIFsuLi52XV0pXG4gICAgKTtcblxuICAgIGZyb20ucHJvamVjdHMuZm9yRWFjaCgoZnJvbVByb2plY3QpID0+IHtcbiAgICAgIGNvbnN0IHByb2plY3RJZCA9IGZyb21Qcm9qZWN0LmlkO1xuICAgICAgY29uc3QgZnJvbUJ1bmRsZUZpbHRlcmVkSWRzID0gZnJvbS5maWx0ZXJlZElkc1twcm9qZWN0SWRdID8/IFtdO1xuICAgICAgaWYgKCFleGlzdGluZ1Byb2plY3RzLmhhcyhwcm9qZWN0SWQpKSB7XG4gICAgICAgIHRhcmdldC5maWx0ZXJlZElkc1twcm9qZWN0SWRdID0gWy4uLmZyb21CdW5kbGVGaWx0ZXJlZElkc107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXQuZmlsdGVyZWRJZHNbcHJvamVjdElkXSA9IGludGVyc2VjdChcbiAgICAgICAgICB0YXJnZXQuZmlsdGVyZWRJZHNbcHJvamVjdElkXSA/PyBbXSxcbiAgICAgICAgICBmcm9tQnVuZGxlRmlsdGVyZWRJZHNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IGV4aXN0aW5nTW9kdWxlcyA9IHtcbiAgICBicm93c2VyOiBuZXcgU2V0KHRhcmdldC5tb2R1bGVzLmJyb3dzZXIubWFwKChtKSA9PiBtLmZpbGVOYW1lKSksXG4gICAgc2VydmVyOiBuZXcgU2V0KHRhcmdldC5tb2R1bGVzLnNlcnZlci5tYXAoKG0pID0+IG0uZmlsZU5hbWUpKSxcbiAgfTtcbiAgY29uc3QgbmV3TW9kdWxlcyA9IHtcbiAgICBicm93c2VyOiBmcm9tLm1vZHVsZXMuYnJvd3Nlci5maWx0ZXIoXG4gICAgICAobSkgPT4gIWV4aXN0aW5nTW9kdWxlcy5icm93c2VyLmhhcyhtLmZpbGVOYW1lKVxuICAgICksXG4gICAgc2VydmVyOiBmcm9tLm1vZHVsZXMuc2VydmVyLmZpbHRlcihcbiAgICAgIChtKSA9PiAhZXhpc3RpbmdNb2R1bGVzLnNlcnZlci5oYXMobS5maWxlTmFtZSlcbiAgICApLFxuICB9O1xuICBpZiAobmV3TW9kdWxlcy5icm93c2VyLmxlbmd0aCA+IDAgfHwgbmV3TW9kdWxlcy5zZXJ2ZXIubGVuZ3RoID4gMCkge1xuICAgIHRhcmdldCA9IHtcbiAgICAgIC4uLnRhcmdldCxcbiAgICAgIG1vZHVsZXM6IHtcbiAgICAgICAgYnJvd3NlcjogWy4uLnRhcmdldC5tb2R1bGVzLmJyb3dzZXIsIC4uLm5ld01vZHVsZXMuYnJvd3Nlcl0sXG4gICAgICAgIHNlcnZlcjogWy4uLnRhcmdldC5tb2R1bGVzLnNlcnZlciwgLi4ubmV3TW9kdWxlcy5zZXJ2ZXJdLFxuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgY29uc3QgZXhpc3RpbmdHbG9iYWxJZHMgPSBuZXcgU2V0KHRhcmdldC5nbG9iYWxHcm91cHMubWFwKChnKSA9PiBnLmlkKSk7XG4gIGNvbnN0IG5ld0dsb2JhbHMgPSBmcm9tLmdsb2JhbEdyb3Vwcy5maWx0ZXIoXG4gICAgKGcpID0+ICFleGlzdGluZ0dsb2JhbElkcy5oYXMoZy5pZClcbiAgKTtcbiAgaWYgKG5ld0dsb2JhbHMubGVuZ3RoID4gMCkge1xuICAgIHRhcmdldCA9IHtcbiAgICAgIC4uLnRhcmdldCxcbiAgICAgIGdsb2JhbEdyb3VwczogWy4uLnRhcmdldC5nbG9iYWxHcm91cHMsIC4uLm5ld0dsb2JhbHNdLFxuICAgIH07XG4gIH1cblxuICBjb25zdCBleGlzdGluZ1NwbGl0SWRzID0gbmV3IFNldCh0YXJnZXQuYWN0aXZlU3BsaXRzLm1hcCgocykgPT4gcy5pZCkpO1xuICBjb25zdCBuZXdTcGxpdHMgPVxuICAgIGZyb20uYWN0aXZlU3BsaXRzLmZpbHRlcihcbiAgICAgIC8vIERvbid0IGluY2x1ZGUgc3BsaXRzIGJlbG9uZ2luZyB0byBwcm9qZWN0cyBhbHJlYWR5IHByZXNlbnRcbiAgICAgIC8vIGluIHRoZSB0YXJnZXQgYnVuZGxlXG4gICAgICAocykgPT4gIWV4aXN0aW5nU3BsaXRJZHMuaGFzKHMuaWQpICYmICFleGlzdGluZ1Byb2plY3RzLmhhcyhzLnByb2plY3RJZClcbiAgICApID8/IFtdO1xuICBpZiAobmV3U3BsaXRzLmxlbmd0aCA+IDApIHtcbiAgICB0YXJnZXQgPSB7XG4gICAgICAuLi50YXJnZXQsXG4gICAgICBhY3RpdmVTcGxpdHM6IFsuLi50YXJnZXQuYWN0aXZlU3BsaXRzLCAuLi5uZXdTcGxpdHNdLFxuICAgIH07XG4gIH1cblxuICAvLyBBdm9pZCBgdW5kZWZpbmVkYCBhcyBpdCBjYW5ub3QgYmUgc2VyaWFsaXplZCBhcyBKU09OXG4gIHRhcmdldC5idW5kbGVLZXkgPSB0YXJnZXQuYnVuZGxlS2V5ID8/IGZyb20uYnVuZGxlS2V5ID8/IG51bGw7XG4gIHRhcmdldC5kZWZlckNodW5rc0J5RGVmYXVsdCA9XG4gICAgdGFyZ2V0LmRlZmVyQ2h1bmtzQnlEZWZhdWx0ID8/IGZyb20uZGVmZXJDaHVua3NCeURlZmF1bHQgPz8gZmFsc2U7XG5cbiAgdGFyZ2V0LmRpc2FibGVSb290TG9hZGluZ0JvdW5kYXJ5QnlEZWZhdWx0ID1cbiAgICB0YXJnZXQuZGlzYWJsZVJvb3RMb2FkaW5nQm91bmRhcnlCeURlZmF1bHQgPz9cbiAgICBmcm9tLmRpc2FibGVSb290TG9hZGluZ0JvdW5kYXJ5QnlEZWZhdWx0ID8/XG4gICAgZmFsc2U7XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZXhwb3J0IGNvbnN0IGNvbnZlcnRCdW5kbGVzVG9Db21wb25lbnRSZW5kZXJEYXRhID0gKFxuICBidW5kbGVzOiBMb2FkZXJCdW5kbGVPdXRwdXRbXSxcbiAgY29tcE1ldGFzOiBDb21wb25lbnRNZXRhW11cbik6IENvbXBvbmVudFJlbmRlckRhdGEgfCBudWxsID0+IHtcbiAgaWYgKGJ1bmRsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBtZXJnZWRCdW5kbGVzID0gYnVuZGxlcy5yZWR1Y2UoKHByZXYsIGN1cikgPT4gbWVyZ2VCdW5kbGVzKHByZXYsIGN1cikpO1xuICByZXR1cm4gcHJlcENvbXBvbmVudERhdGEobWVyZ2VkQnVuZGxlcywgY29tcE1ldGFzKTtcbn07XG4iLCJpbXBvcnQge1xuICBBc3NldE1vZHVsZSxcbiAgQ29tcG9uZW50TWV0YSxcbiAgRm9udE1ldGEsXG4gIEdsb2JhbEdyb3VwTWV0YSxcbiAgTG9hZGVyQnVuZGxlT3V0cHV0LFxuICBSZWdpc3RyeSxcbn0gZnJvbSAnQHBsYXNtaWNhcHAvbG9hZGVyLWNvcmUnO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgQ29tcG9uZW50TG9va3VwU3BlYywgZ2V0Q29tcE1ldGFzIH0gZnJvbSAnLi91dGlscyc7XG5cbmZ1bmN0aW9uIGdldEZpcnN0Q29tcE1ldGEobWV0YXM6IENvbXBvbmVudE1ldGFbXSwgbG9va3VwOiBDb21wb25lbnRMb29rdXBTcGVjKSB7XG4gIGNvbnN0IGZpbHRlcmVkID0gZ2V0Q29tcE1ldGFzKG1ldGFzLCBsb29rdXApO1xuICByZXR1cm4gZmlsdGVyZWQubGVuZ3RoID09PSAwID8gdW5kZWZpbmVkIDogZmlsdGVyZWRbMF07XG59XG5cbmV4cG9ydCBjbGFzcyBDb21wb25lbnRMb29rdXAge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGJ1bmRsZTogTG9hZGVyQnVuZGxlT3V0cHV0LCBwcml2YXRlIHJlZ2lzdHJ5OiBSZWdpc3RyeSkge31cblxuICBnZXRDb21wb25lbnRNZXRhKHNwZWM6IENvbXBvbmVudExvb2t1cFNwZWMpOiBDb21wb25lbnRNZXRhIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBjb21wTWV0YSA9IGdldEZpcnN0Q29tcE1ldGEodGhpcy5idW5kbGUuY29tcG9uZW50cywgc3BlYyk7XG4gICAgcmV0dXJuIGNvbXBNZXRhO1xuICB9XG5cbiAgZ2V0Q29tcG9uZW50PFAgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnRUeXBlID0gYW55PihcbiAgICBzcGVjOiBDb21wb25lbnRMb29rdXBTcGVjLFxuICAgIG9wdHM6IHsgZm9yY2VPcmlnaW5hbD86IGJvb2xlYW4gfSA9IHt9XG4gICkge1xuICAgIGNvbnN0IGNvbXBNZXRhID0gZ2V0Rmlyc3RDb21wTWV0YSh0aGlzLmJ1bmRsZS5jb21wb25lbnRzLCBzcGVjKTtcbiAgICBpZiAoIWNvbXBNZXRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbXBvbmVudCBub3QgZm91bmQ6ICR7c3BlY31gKTtcbiAgICB9XG4gICAgY29uc3QgbW9kdWxlTmFtZSA9IGNvbXBNZXRhLmVudHJ5O1xuICAgIGlmICghdGhpcy5yZWdpc3RyeS5oYXNNb2R1bGUobW9kdWxlTmFtZSwgb3B0cykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ29tcG9uZW50IG5vdCB5ZXQgZmV0Y2hlZDogJHtjb21wTWV0YS5uYW1lfWApO1xuICAgIH1cbiAgICBjb25zdCBlbnRyeSA9IHRoaXMucmVnaXN0cnkubG9hZChtb2R1bGVOYW1lLCB7XG4gICAgICBmb3JjZU9yaWdpbmFsOiBvcHRzLmZvcmNlT3JpZ2luYWwsXG4gICAgfSk7XG4gICAgcmV0dXJuICFvcHRzLmZvcmNlT3JpZ2luYWwgJiZcbiAgICAgIHR5cGVvZiBlbnRyeT8uZ2V0UGxhc21pY0NvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBlbnRyeS5nZXRQbGFzbWljQ29tcG9uZW50KClcbiAgICAgIDogKGVudHJ5LmRlZmF1bHQgYXMgUCk7XG4gIH1cblxuICBoYXNDb21wb25lbnQoc3BlYzogQ29tcG9uZW50TG9va3VwU3BlYykge1xuICAgIGNvbnN0IGNvbXBNZXRhID0gZ2V0Rmlyc3RDb21wTWV0YSh0aGlzLmJ1bmRsZS5jb21wb25lbnRzLCBzcGVjKTtcbiAgICBpZiAoY29tcE1ldGEpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlZ2lzdHJ5Lmhhc01vZHVsZShjb21wTWV0YS5lbnRyeSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGdldEdsb2JhbENvbnRleHRzKCk6IHsgbWV0YTogR2xvYmFsR3JvdXBNZXRhOyBjb250ZXh0OiBhbnkgfVtdIHtcbiAgICBjb25zdCBjdXN0b21HbG9iYWxNZXRhcyA9IHRoaXMuYnVuZGxlLmdsb2JhbEdyb3Vwcy5maWx0ZXIoXG4gICAgICAobSkgPT4gbS50eXBlID09PSAnZ2xvYmFsLXVzZXItZGVmaW5lZCdcbiAgICApO1xuICAgIHJldHVybiBjdXN0b21HbG9iYWxNZXRhcy5tYXAoKG1ldGEpID0+ICh7XG4gICAgICBtZXRhLFxuICAgICAgY29udGV4dDogdGhpcy5yZWdpc3RyeS5sb2FkKG1ldGEuY29udGV4dEZpbGUpLmRlZmF1bHQsXG4gICAgfSkpO1xuICB9XG5cbiAgZ2V0R2xvYmFsQ29udGV4dHNQcm92aWRlcihzcGVjOiBDb21wb25lbnRMb29rdXBTcGVjKSB7XG4gICAgY29uc3QgY29tcE1ldGEgPSBnZXRGaXJzdENvbXBNZXRhKHRoaXMuYnVuZGxlLmNvbXBvbmVudHMsIHNwZWMpO1xuICAgIGNvbnN0IHByb2plY3RNZXRhID0gY29tcE1ldGFcbiAgICAgID8gdGhpcy5idW5kbGUucHJvamVjdHMuZmluZCgoeCkgPT4geC5pZCA9PT0gY29tcE1ldGEucHJvamVjdElkKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoXG4gICAgICAhcHJvamVjdE1ldGEgfHxcbiAgICAgICFwcm9qZWN0TWV0YS5nbG9iYWxDb250ZXh0c1Byb3ZpZGVyRmlsZU5hbWUgfHxcbiAgICAgICF0aGlzLnJlZ2lzdHJ5Lmhhc01vZHVsZShwcm9qZWN0TWV0YS5nbG9iYWxDb250ZXh0c1Byb3ZpZGVyRmlsZU5hbWUpXG4gICAgKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBlbnRyeSA9IHRoaXMucmVnaXN0cnkubG9hZChcbiAgICAgIHByb2plY3RNZXRhLmdsb2JhbENvbnRleHRzUHJvdmlkZXJGaWxlTmFtZVxuICAgICk7XG5cbiAgICByZXR1cm4gdHlwZW9mIGVudHJ5Py5nZXRQbGFzbWljQ29tcG9uZW50ID09PSAnZnVuY3Rpb24nXG4gICAgICA/IGVudHJ5LmdldFBsYXNtaWNDb21wb25lbnQoKVxuICAgICAgOiBlbnRyeS5kZWZhdWx0O1xuICB9XG5cbiAgZ2V0Um9vdFByb3ZpZGVyKCkge1xuICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5yZWdpc3RyeS5sb2FkKCdyb290LXByb3ZpZGVyLmpzJyk7XG4gICAgcmV0dXJuIGVudHJ5LmRlZmF1bHQ7XG4gIH1cblxuICBnZXRDc3MoKTogQXNzZXRNb2R1bGVbXSB7XG4gICAgLy8gV2UgY2FuIHByb2JhYmx5IGFsd2F5cyBnZXQgdGhlIG1vZHVsZXMgZnJvbSB0aGUgYnJvd3NlciBidWlsZFxuICAgIHJldHVybiB0aGlzLmJ1bmRsZS5tb2R1bGVzLmJyb3dzZXIuZmlsdGVyKFxuICAgICAgKG1vZCkgPT4gbW9kLnR5cGUgPT09ICdhc3NldCcgJiYgbW9kLmZpbGVOYW1lLmVuZHNXaXRoKCdjc3MnKVxuICAgICkgYXMgQXNzZXRNb2R1bGVbXTtcbiAgfVxuXG4gIGdldFJlbW90ZUZvbnRzKCk6IEZvbnRNZXRhW10ge1xuICAgIHJldHVybiB0aGlzLmJ1bmRsZS5wcm9qZWN0cy5mbGF0TWFwKChwKSA9PiBwLnJlbW90ZUZvbnRzKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgSW50ZXJuYWxQbGFzbWljQ29tcG9uZW50TG9hZGVyIH0gZnJvbSBcIi4vbG9hZGVyLWNsaWVudFwiO1xuaW1wb3J0IHtcbiAgQ29kZUNvbXBvbmVudE1ldGEsXG4gIEZldGNoQ29tcG9uZW50RGF0YU9wdHMsXG4gIEluaXRPcHRpb25zLFxuICBQbGFzbWljQ29tcG9uZW50TG9hZGVyLFxufSBmcm9tIFwiLi9sb2FkZXItc2hhcmVkXCI7XG5cbmV4cG9ydCB7XG4gIERhdGFDdHhSZWFkZXIsXG4gIERhdGFQcm92aWRlcixcbiAgR2xvYmFsQWN0aW9uc0NvbnRleHQsXG4gIEdsb2JhbEFjdGlvbnNQcm92aWRlcixcbiAgUGFnZVBhcmFtc1Byb3ZpZGVyLFxuICBQbGFzbWljQ2FudmFzQ29udGV4dCxcbiAgUGxhc21pY0NhbnZhc0hvc3QsXG4gIFBsYXNtaWNUcmFuc2xhdG9yQ29udGV4dCxcbiAgcmVwZWF0ZWRFbGVtZW50LFxuICB1c2VEYXRhRW52LFxuICB1c2VQbGFzbWljQ2FudmFzQ29udGV4dCxcbiAgdXNlU2VsZWN0b3IsXG4gIHVzZVNlbGVjdG9ycyxcbn0gZnJvbSBcIkBwbGFzbWljYXBwL2hvc3RcIjtcbmV4cG9ydCB0eXBlIHsgUHJvcFR5cGUsIFRva2VuUmVnaXN0cmF0aW9uIH0gZnJvbSBcIkBwbGFzbWljYXBwL2hvc3RcIjtcbmV4cG9ydCB7IHVzZVBsYXNtaWNRdWVyeURhdGEgfSBmcm9tIFwiQHBsYXNtaWNhcHAvcXVlcnlcIjtcbmV4cG9ydCB7IFBsYXNtaWNDb21wb25lbnQgfSBmcm9tIFwiLi9QbGFzbWljQ29tcG9uZW50XCI7XG5leHBvcnQgeyBQbGFzbWljUm9vdFByb3ZpZGVyIH0gZnJvbSBcIi4vUGxhc21pY1Jvb3RQcm92aWRlclwiO1xuZXhwb3J0IHR5cGUge1xuICBHbG9iYWxWYXJpYW50U3BlYyxcbiAgUGxhc21pY1RyYW5zbGF0b3IsXG59IGZyb20gXCIuL1BsYXNtaWNSb290UHJvdmlkZXJcIjtcbmV4cG9ydCB7IGV4dHJhY3RQbGFzbWljUXVlcnlEYXRhLCBwbGFzbWljUHJlcGFzcyB9IGZyb20gXCIuL3ByZXBhc3MtY2xpZW50XCI7XG5leHBvcnQge1xuICBleHRyYWN0UGxhc21pY1F1ZXJ5RGF0YUZyb21FbGVtZW50LFxuICBoeWRyYXRlRnJvbUVsZW1lbnQsXG4gIHJlbmRlclRvRWxlbWVudCxcbiAgcmVuZGVyVG9TdHJpbmcsXG59IGZyb20gXCIuL3JlbmRlclwiO1xuZXhwb3J0ICogZnJvbSBcIi4vc2hhcmVkLWV4cG9ydHNcIjtcbmV4cG9ydCB7IHVzZVBsYXNtaWNDb21wb25lbnQgfSBmcm9tIFwiLi91c2VQbGFzbWljQ29tcG9uZW50XCI7XG5leHBvcnQgdHlwZSB7IENvbXBvbmVudExvb2t1cFNwZWMgfSBmcm9tIFwiLi91dGlsc1wiO1xuZXhwb3J0IHsgSW50ZXJuYWxQbGFzbWljQ29tcG9uZW50TG9hZGVyLCBQbGFzbWljQ29tcG9uZW50TG9hZGVyIH07XG5leHBvcnQgdHlwZSB7IENvZGVDb21wb25lbnRNZXRhLCBGZXRjaENvbXBvbmVudERhdGFPcHRzIH07XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0UGxhc21pY0xvYWRlcihvcHRzOiBJbml0T3B0aW9ucyk6IFBsYXNtaWNDb21wb25lbnRMb2FkZXIge1xuICBjb25zdCBpbnRlcm5hbCA9IG5ldyBJbnRlcm5hbFBsYXNtaWNDb21wb25lbnRMb2FkZXIob3B0cyk7XG4gIHJldHVybiBuZXcgUGxhc21pY0NvbXBvbmVudExvYWRlcihpbnRlcm5hbCk7XG59XG4iLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZVBsYXNtaWNSb290Q29udGV4dCB9IGZyb20gXCIuL1BsYXNtaWNSb290UHJvdmlkZXJcIjtcbmltcG9ydCB7IHVzZVBsYXNtaWNDb21wb25lbnQgfSBmcm9tIFwiLi91c2VQbGFzbWljQ29tcG9uZW50XCI7XG5pbXBvcnQgeyBNYXliZVdyYXAgfSBmcm9tIFwiLi91dGlsc1wiO1xuXG5jb25zdCBQbGFzbWljQ29tcG9uZW50Q29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoZmFsc2UpO1xuXG5leHBvcnQgZnVuY3Rpb24gUGxhc21pY0NvbXBvbmVudChwcm9wczoge1xuICAvKipcbiAgICogTmFtZSBvZiB0aGUgY29tcG9uZW50IHRvIHJlbmRlciwgb3IgdGhlIHBhdGggb2YgdGhlIHBhZ2UgY29tcG9uZW50XG4gICAqL1xuICBjb21wb25lbnQ6IHN0cmluZztcbiAgLyoqXG4gICAqIE9wdGlvbmFsbHkgc3BlY2lmeSBhIHByb2plY3RJZCBpZiB0aGVyZSBhcmUgbXVsdGlwbGUgY29tcG9uZW50c1xuICAgKiBvZiB0aGUgc2FtZSBuYW1lIGZyb20gZGlmZmVyZW50IHByb2plY3RzXG4gICAqL1xuICBwcm9qZWN0SWQ/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBJZiB5b3UgdXNlZCByZWdpc3RlckNvbXBvbmVudCgpLCB0aGVuIGlmIHRoZSBuYW1lIG1hdGNoZXMgYSByZWdpc3RlcmVkXG4gICAqIGNvbXBvbmVudCwgdGhhdCBjb21wb25lbnQgaXMgdXNlZC4gIElmIHlvdSB3YW50IHRoZSBQbGFzbWljLWdlbmVyYXRlZFxuICAgKiBjb21wb25lbnQgaW5zdGVhZCwgc3BlY2lmeSBmb3JjZU9yaWdpbmFsLlxuICAgKi9cbiAgZm9yY2VPcmlnaW5hbD86IGJvb2xlYW47XG4gIGNvbXBvbmVudFByb3BzPzogYW55O1xufSk6IFJlYWN0LlJlYWN0RWxlbWVudCB8IG51bGwge1xuICBjb25zdCB7IGNvbXBvbmVudCwgcHJvamVjdElkLCBjb21wb25lbnRQcm9wcywgZm9yY2VPcmlnaW5hbCB9ID0gcHJvcHM7XG5cbiAgY29uc3Qgcm9vdENvbnRleHQgPSB1c2VQbGFzbWljUm9vdENvbnRleHQoKTtcbiAgY29uc3QgaXNSb290TG9hZGVyID0gIVJlYWN0LnVzZUNvbnRleHQoUGxhc21pY0NvbXBvbmVudENvbnRleHQpO1xuXG4gIGlmICghcm9vdENvbnRleHQpIHtcbiAgICAvLyBubyBleGlzdGluZyBQbGFzbWljUm9vdFByb3ZpZGVyXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFlvdSBtdXN0IHVzZSA8UGxhc21pY1Jvb3RQcm92aWRlci8+IGF0IHRoZSByb290IG9mIHlvdXIgYXBwYFxuICAgICk7XG4gIH1cblxuICBjb25zdCB7XG4gICAgbG9hZGVyLFxuICAgIGdsb2JhbENvbnRleHRzUHJvcHMsXG4gICAgdmFyaWF0aW9uLFxuICAgIHVzZXJBdXRoVG9rZW4sXG4gICAgaXNVc2VyTG9hZGluZyxcbiAgICBhdXRoUmVkaXJlY3RVcmksXG4gICAgdHJhbnNsYXRvcixcbiAgICAuLi5yZXN0XG4gIH0gPSByb290Q29udGV4dDtcblxuICBjb25zdCBDb21wb25lbnQgPSB1c2VQbGFzbWljQ29tcG9uZW50KFxuICAgIHsgbmFtZTogY29tcG9uZW50LCBwcm9qZWN0SWQsIGlzQ29kZTogZmFsc2UgfSxcbiAgICB7IGZvcmNlT3JpZ2luYWwgfVxuICApO1xuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGlzUm9vdExvYWRlcikge1xuICAgICAgY29uc3QgbWV0YSA9IGxvYWRlclxuICAgICAgICAuZ2V0TG9va3VwKClcbiAgICAgICAgLmdldENvbXBvbmVudE1ldGEoeyBuYW1lOiBjb21wb25lbnQsIHByb2plY3RJZCB9KTtcblxuICAgICAgaWYgKG1ldGEpIHtcbiAgICAgICAgbG9hZGVyLnRyYWNrUmVuZGVyKHtcbiAgICAgICAgICByZW5kZXJDdHg6IHtcbiAgICAgICAgICAgIHJvb3RQcm9qZWN0SWQ6IG1ldGEucHJvamVjdElkLFxuICAgICAgICAgICAgcm9vdENvbXBvbmVudElkOiBtZXRhLmlkLFxuICAgICAgICAgICAgcm9vdENvbXBvbmVudE5hbWU6IGNvbXBvbmVudCxcbiAgICAgICAgICAgIHRlYW1JZHM6IGxvYWRlci5nZXRUZWFtSWRzKCksXG4gICAgICAgICAgICBwcm9qZWN0SWRzOiBsb2FkZXIuZ2V0UHJvamVjdElkcygpLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdmFyaWF0aW9uLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtjb21wb25lbnQsIHByb2plY3RJZCwgbG9hZGVyLCB2YXJpYXRpb25dKTtcblxuICBjb25zdCBlbGVtZW50ID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKCFDb21wb25lbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGxldCBlbHQgPSA8Q29tcG9uZW50IHsuLi5jb21wb25lbnRQcm9wc30gLz47XG5cbiAgICBpZiAoaXNSb290TG9hZGVyKSB7XG4gICAgICAvLyBJZiB0aGlzIGlzIHRoZSByb290IFBsYXNtaWNDb21wb25lbnQsIHRoZW4gd3JhcCB0aGUgY29udGVudCB3aXRoIHRoZVxuICAgICAgLy8gcmVhY3Qtd2ViJ3MgUGxhc21pY1Jvb3RQcm92aWRlci4gIFdlIGFyZSBkb2luZyB0aGlzIGhlcmUsIGluc3RlYWQgb2ZcbiAgICAgIC8vIHNheSBQbGFzbWljUm9vdFByb3ZpZGVyLCBiZWNhdXNlIHdlIGRvbid0IGhhdmUgYWNjZXNzIHRvIHRoaXMgY29udGV4dFxuICAgICAgLy8gcHJvdmlkZXIgdW50aWwgZGF0YSBoYXMgYmVlbiBsb2FkZWQuICBJZiB3ZSBpbnNlcnQgdGhpcyBwcm92aWRlciBpbnRvXG4gICAgICAvLyB0aGUgdHJlZSBhdCB0aGUgcm9vdCBhZnRlciBkYXRhIGlzIGxvYWRlZCwgdGhlbiB3ZSdsbCBpbnZhbGlkYXRlIHRoZVxuICAgICAgLy8gUmVhY3QgdHJlZSBhbmQgdHJlZSBzdGF0ZSwgd2hpY2ggaXMgYmFkLiAgSW5zdGVhZCwgd2UgZG8gaXQgYXQgdGhlXG4gICAgICAvLyBcInJvb3QtbW9zdCBQbGFzbWljQ29tcG9uZW50XCI7IHdlIHdvbid0IHJpc2sgaW52YWxpZGF0aW5nIHRoZSBzdWItdHJlZVxuICAgICAgLy8gaGVyZSBiZWNhdXNlIHRoZXJlIHdlcmUgbm8gY2hpbGRyZW4gYmVmb3JlIHRoZSBkYXRhIGNhbWUgaW4uXG4gICAgICBjb25zdCBsb29rdXAgPSBsb2FkZXIuZ2V0TG9va3VwKCk7XG4gICAgICBjb25zdCBSZWFjdFdlYlJvb3RQcm92aWRlciA9IGxvb2t1cC5nZXRSb290UHJvdmlkZXIoKTtcbiAgICAgIGNvbnN0IEdsb2JhbENvbnRleHRzUHJvdmlkZXIgPSBsb29rdXAuZ2V0R2xvYmFsQ29udGV4dHNQcm92aWRlcih7XG4gICAgICAgIG5hbWU6IGNvbXBvbmVudCxcbiAgICAgICAgcHJvamVjdElkLFxuICAgICAgfSk7XG4gICAgICBlbHQgPSAoXG4gICAgICAgIDxSZWFjdFdlYlJvb3RQcm92aWRlclxuICAgICAgICAgIHsuLi5yZXN0fVxuICAgICAgICAgIHVzZXJBdXRoVG9rZW49e3VzZXJBdXRoVG9rZW59XG4gICAgICAgICAgaXNVc2VyTG9hZGluZz17aXNVc2VyTG9hZGluZ31cbiAgICAgICAgICBhdXRoUmVkaXJlY3RVcmk9e2F1dGhSZWRpcmVjdFVyaX1cbiAgICAgICAgICBpMThuPXt7XG4gICAgICAgICAgICB0cmFuc2xhdG9yLFxuICAgICAgICAgICAgdGFnUHJlZml4OiBsb2FkZXIub3B0cy5pMThuPy50YWdQcmVmaXgsXG4gICAgICAgICAgfX1cbiAgICAgICAgPlxuICAgICAgICAgIDxNYXliZVdyYXBcbiAgICAgICAgICAgIGNvbmQ9eyEhR2xvYmFsQ29udGV4dHNQcm92aWRlcn1cbiAgICAgICAgICAgIHdyYXBwZXI9eyhjaGlsZHJlbikgPT4gKFxuICAgICAgICAgICAgICA8R2xvYmFsQ29udGV4dHNQcm92aWRlciB7Li4uZ2xvYmFsQ29udGV4dHNQcm9wc30+XG4gICAgICAgICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICAgICAgICA8L0dsb2JhbENvbnRleHRzUHJvdmlkZXI+XG4gICAgICAgICAgICApfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxQbGFzbWljQ29tcG9uZW50Q29udGV4dC5Qcm92aWRlciB2YWx1ZT17dHJ1ZX0+XG4gICAgICAgICAgICAgIHtlbHR9XG4gICAgICAgICAgICA8L1BsYXNtaWNDb21wb25lbnRDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgICAgIDwvTWF5YmVXcmFwPlxuICAgICAgICA8L1JlYWN0V2ViUm9vdFByb3ZpZGVyPlxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGVsdDtcbiAgfSwgW1xuICAgIENvbXBvbmVudCxcbiAgICBjb21wb25lbnRQcm9wcyxcbiAgICBsb2FkZXIsXG4gICAgaXNSb290TG9hZGVyLFxuICAgIGNvbXBvbmVudCxcbiAgICBwcm9qZWN0SWQsXG4gICAgZ2xvYmFsQ29udGV4dHNQcm9wcyxcbiAgICB1c2VyQXV0aFRva2VuLCAvLyBKdXN0IHVzZSB0aGUgdG9rZW4gdG8gbWVtbywgYHVzZXJgIHNob3VsZCBiZSBkZXJpdmVkIGZyb20gaXRcbiAgICBpc1VzZXJMb2FkaW5nLFxuICAgIGF1dGhSZWRpcmVjdFVyaSxcbiAgXSk7XG4gIHJldHVybiBlbGVtZW50O1xufVxuIiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlUGxhc21pY1Jvb3RDb250ZXh0IH0gZnJvbSAnLi9QbGFzbWljUm9vdFByb3ZpZGVyJztcbmltcG9ydCB7XG4gIENvbXBvbmVudExvb2t1cFNwZWMsXG4gIHVzZUZvcmNlVXBkYXRlLFxuICB1c2VJc01vdW50ZWQsXG4gIHVzZVN0YWJsZUxvb2t1cFNwZWMsXG59IGZyb20gJy4vdXRpbHMnO1xuXG4vKipcbiAqIEhvb2sgdGhhdCBmZXRjaGVzIGFuZCByZXR1cm5zIGEgUmVhY3QgY29tcG9uZW50IGZvciByZW5kZXJpbmcgdGhlIGFyZ3VtZW50XG4gKiBQbGFzbWljIGNvbXBvbmVudC4gIFJldHVybnMgdW5kZWZpbmVkIGlmIHRoZSBjb21wb25lbnQgZGF0YSBpcyBzdGlsbFxuICogYmVpbmcgZmV0Y2hlZC5cbiAqXG4gKiBAcGFyYW0gb3B0cy5mb3JjZU9yaWdpbmFsIGlmIHlvdSB1c2VkIFBsYXNtaWNDb21wb25lbnRMb2FkZXIucmVnaXN0ZXJDb21wb25lbnQsXG4gKiAgIHRoZW4gbm9ybWFsbHkgdXNlUGxhc21pY0NvbXBvbmVudCB3aWxsIHJldHVybiB0aGUgcmVnaXN0ZXJlZCBjb21wb25lbnQuXG4gKiAgIFlvdSBjYW4gc2V0IGZvcmNlT3JpZ2luYWwgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0byByZXR1cm4gdGhlIFBsYXNtaWMtZ2VuZXJhdGVkXG4gKiAgIGNvbXBvbmVudCBpbnN0ZWFkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUGxhc21pY0NvbXBvbmVudDxQIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50VHlwZSA9IGFueT4oXG4gIHNwZWM6IENvbXBvbmVudExvb2t1cFNwZWMsXG4gIG9wdHM6IHsgZm9yY2VPcmlnaW5hbD86IGJvb2xlYW4gfSA9IHt9XG4pIHtcbiAgY29uc3Qgcm9vdENvbnRleHQgPSB1c2VQbGFzbWljUm9vdENvbnRleHQoKTtcbiAgaWYgKCFyb290Q29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBZb3UgY2FuIG9ubHkgdXNlIHVzZVBsYXNtaWNDb21wb25lbnQgaWYgd3JhcHBlZCBpbiA8UGxhc21pY1Jvb3RQcm92aWRlciAvPmBcbiAgICApO1xuICB9XG5cbiAgY29uc3QgbG9hZGVyID0gcm9vdENvbnRleHQubG9hZGVyO1xuICBjb25zdCBsb29rdXAgPSBsb2FkZXIuZ2V0TG9va3VwKCk7XG5cbiAgY29uc3QgY29tcG9uZW50ID0gbG9va3VwLmhhc0NvbXBvbmVudChzcGVjKVxuICAgID8gbG9va3VwLmdldENvbXBvbmVudChzcGVjLCBvcHRzKVxuICAgIDogdW5kZWZpbmVkO1xuXG4gIGNvbnN0IHN0YWJsZVNwZWMgPSB1c2VTdGFibGVMb29rdXBTcGVjKHNwZWMpO1xuICBjb25zdCBpc01vdW50ZWQgPSB1c2VJc01vdW50ZWQoKTtcbiAgY29uc3QgZm9yY2VVcGRhdGUgPSB1c2VGb3JjZVVwZGF0ZSgpO1xuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFjb21wb25lbnQpIHtcbiAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IGxvYWRlci5mZXRjaENvbXBvbmVudERhdGEoc3RhYmxlU3BlYyk7XG4gICAgICAgIGlmIChpc01vdW50ZWQoKSkge1xuICAgICAgICAgIGZvcmNlVXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pKCk7XG4gICAgfVxuICB9LCBbY29tcG9uZW50LCBzdGFibGVTcGVjXSk7XG5cbiAgcmV0dXJuIGNvbXBvbmVudCBhcyBQO1xufVxuIiwiaW1wb3J0IHtcbiAgZXh0cmFjdFBsYXNtaWNRdWVyeURhdGEgYXMgaW50ZXJuYWxFeHRyYWN0UXVlcnlEYXRhLFxuICBwbGFzbWljUHJlcGFzcyBhcyBpbnRlcm5hbFBsYXNtaWNQcmVwYXNzLFxufSBmcm9tIFwiQHBsYXNtaWNhcHAvcHJlcGFzc1wiO1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgcHJlcGFzcyBvdmVyIFBsYXNtaWMgY29udGVudCwga2lja2luZyBvZmYgdGhlIG5lY2Vzc2FyeVxuICogZGF0YSBmZXRjaGVzLCBhbmQgcG9wdWxhdGluZyB0aGUgZmV0Y2hlZCBkYXRhIGludG8gYSBjYWNoZS4gIFRoaXNcbiAqIGNhY2hlIGNhbiBiZSBwYXNzZWQgYXMgcHJlZmV0Y2hlZFF1ZXJ5RGF0YSBpbnRvIFBsYXNtaWNSb290UHJvdmlkZXIuXG4gKlxuICogVG8gbGltaXQgcmVuZGVyaW5nIGVycm9ycyB0aGF0IGNhbiBvY2N1ciB3aGVuIHlvdSBkbyB0aGlzLCB3ZSByZWNvbW1lbmRcbiAqIHRoYXQgeW91IHBhc3MgaW4gX29ubHlfIHRoZSBQbGFzbWljQ29tcG9uZW50cyB0aGF0IHlvdSBhcmUgcGxhbm5pbmcgdG8gdXNlXG4gKiBhcyB0aGUgYXJndW1lbnQuICBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgIGNvbnN0IGNhY2hlID0gYXdhaXQgZXh0cmFjdFBsYXNtaWNRdWVyeURhdGEoXG4gKiAgICAgPFBsYXNtaWNSb290UHJvdmlkZXIgbG9hZGVyPXtQTEFTTUlDfSBwcmVmZXRjaGVkRGF0YT17cGxhc21pY0RhdGF9PlxuICogICAgICAgPFBsYXNtaWNDb21wb25lbnQgY29tcG9uZW50PVwiSG9tZVwiIGNvbXBvbmVudFByb3BzPXt7XG4gKiAgICAgICAgIC8vIFNwZWNpZnkgdGhlIGNvbXBvbmVudCBwcm9wIG92ZXJyaWRlcyB5b3UgYXJlIHBsYW5uaW5nIHRvIHVzZVxuICogICAgICAgICAvLyB0byByZW5kZXIgdGhlIHBhZ2UsIGFzIHRoZXkgbWF5IGNoYW5nZSB3aGF0IGRhdGEgaXMgZmV0Y2hlZC5cbiAqICAgICAgICAgLi4uXG4gKiAgICAgICB9fSAvPlxuICogICAgICAgPFBsYXNtaWNDb21wb25lbnQgY29tcG9uZW50PVwiTmF2QmFyXCIgY29tcG9uZW50UHJvcHM9e3tcbiAqICAgICAgICAgLi4uXG4gKiAgICAgICB9fSAvPlxuICogICAgICAgLi4uXG4gKiAgICAgPC9QbGFzbWljUm9vdFByb3ZpZGVyPlxuICogICApO1xuICpcbiAqIElmIHlvdXIgUGxhc21pY0NvbXBvbmVudCB3aWxsIGJlIHdyYXBwaW5nIGNvbXBvbmVudHMgdGhhdCByZXF1aXJlIHNwZWNpYWxcbiAqIGNvbnRleHQgc2V0IHVwLCB5b3Ugc2hvdWxkIGFsc28gd3JhcCB0aGUgZWxlbWVudCBhYm92ZSB3aXRoIHRob3NlIGNvbnRleHRcbiAqIHByb3ZpZGVycy5cbiAqXG4gKiBZb3Ugc2hvdWxkIGF2b2lkIHBhc3NpbmcgaW4gZWxlbWVudHMgdGhhdCBhcmUgbm90IHJlbGF0ZWQgdG8gUGxhc21pYywgYXMgYW55XG4gKiByZW5kZXJpbmcgZXJyb3JzIGZyb20gdGhvc2UgZWxlbWVudHMgZHVyaW5nIHRoZSBwcmVwYXNzIG1heSByZXN1bHQgaW4gZGF0YVxuICogbm90IGJlaW5nIHBvcHVsYXRlZCBpbiB0aGUgY2FjaGUuXG4gKlxuICogQHBhcmFtIGVsZW1lbnQgYSBSZWFjdCBlbGVtZW50IGNvbnRhaW5pbmcgaW5zdGFuY2VzIG9mIFBsYXNtaWNDb21wb25lbnQuXG4gKiAgIFdpbGwgYXR0ZW1wdCB0byBzYXRpc2Z5IGFsbCBkYXRhIG5lZWRzIGZyb20gdXNlUGxhc21pY0RhdGFRdWVyeSgpXG4gKiAgIGluIHRoaXMgZWxlbWVudCB0cmVlLlxuICogQHJldHVybnMgYW4gb2JqZWN0IG1hcHBpbmcgcXVlcnkga2V5IHRvIGZldGNoZWQgZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFBsYXNtaWNRdWVyeURhdGEoXG4gIGVsZW1lbnQ6IFJlYWN0LlJlYWN0RWxlbWVudFxuKTogUHJvbWlzZTxSZWNvcmQ8c3RyaW5nLCBhbnk+PiB7XG4gIHJldHVybiBpbnRlcm5hbEV4dHJhY3RRdWVyeURhdGEoZWxlbWVudCk7XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgTWFpbnRhaW5lZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBsYXNtaWNQcmVwYXNzKGVsZW1lbnQ6IFJlYWN0LlJlYWN0RWxlbWVudCk6IFByb21pc2U8dm9pZD4ge1xuICByZXR1cm4gaW50ZXJuYWxQbGFzbWljUHJlcGFzcyhlbGVtZW50KTtcbn1cbiIsImltcG9ydCB7IGV4dHJhY3RQbGFzbWljUXVlcnlEYXRhIH0gZnJvbSBcIkBwbGFzbWljYXBwL3ByZXBhc3NcIjtcbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBSZWFjdERPTSBmcm9tIFwicmVhY3QtZG9tXCI7XG5pbXBvcnQgeyByZW5kZXJUb1N0cmluZyBhcyByZWFjdFJlbmRlclRvU3RyaW5nIH0gZnJvbSBcInJlYWN0LWRvbS9zZXJ2ZXJcIjtcbmltcG9ydCB7IENvbXBvbmVudFJlbmRlckRhdGEsIFBsYXNtaWNDb21wb25lbnRMb2FkZXIgfSBmcm9tIFwiLi9sb2FkZXItc2hhcmVkXCI7XG5pbXBvcnQgeyBQbGFzbWljQ29tcG9uZW50IH0gZnJvbSBcIi4vUGxhc21pY0NvbXBvbmVudFwiO1xuaW1wb3J0IHsgR2xvYmFsVmFyaWFudFNwZWMsIFBsYXNtaWNSb290UHJvdmlkZXIgfSBmcm9tIFwiLi9QbGFzbWljUm9vdFByb3ZpZGVyXCI7XG5pbXBvcnQgeyBDb21wb25lbnRMb29rdXBTcGVjIH0gZnJvbSBcIi4vdXRpbHNcIjtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlbmRlclRvRWxlbWVudChcbiAgbG9hZGVyOiBQbGFzbWljQ29tcG9uZW50TG9hZGVyLFxuICB0YXJnZXQ6IEhUTUxFbGVtZW50LFxuICBsb29rdXA6IENvbXBvbmVudExvb2t1cFNwZWMsXG4gIG9wdHM6IHtcbiAgICBwcmVmZXRjaGVkRGF0YT86IENvbXBvbmVudFJlbmRlckRhdGE7XG4gICAgY29tcG9uZW50UHJvcHM/OiBhbnk7XG4gICAgZ2xvYmFsVmFyaWFudHM/OiBHbG9iYWxWYXJpYW50U3BlY1tdO1xuICAgIHByZWZldGNoZWRRdWVyeURhdGE/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuICAgIHBhZ2VQYXJhbXM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuICAgIHBhZ2VRdWVyeT86IFJlY29yZDxzdHJpbmcsIGFueT47XG4gIH0gPSB7fVxuKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSkgPT4ge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBtYWtlRWxlbWVudChsb2FkZXIsIGxvb2t1cCwgb3B0cyk7XG4gICAgUmVhY3RET00ucmVuZGVyKGVsZW1lbnQsIHRhcmdldCwgKCkgPT4gcmVzb2x2ZSgpKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJUb1N0cmluZyhcbiAgbG9hZGVyOiBQbGFzbWljQ29tcG9uZW50TG9hZGVyLFxuICBsb29rdXA6IENvbXBvbmVudExvb2t1cFNwZWMsXG4gIG9wdHM6IHtcbiAgICBwcmVmZXRjaGVkRGF0YT86IENvbXBvbmVudFJlbmRlckRhdGE7XG4gICAgY29tcG9uZW50UHJvcHM/OiBhbnk7XG4gICAgZ2xvYmFsVmFyaWFudHM/OiBHbG9iYWxWYXJpYW50U3BlY1tdO1xuICAgIHByZWZldGNoZWRRdWVyeURhdGE/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuICB9ID0ge31cbikge1xuICBjb25zdCBlbGVtZW50ID0gbWFrZUVsZW1lbnQobG9hZGVyLCBsb29rdXAsIG9wdHMpO1xuICByZXR1cm4gcmVhY3RSZW5kZXJUb1N0cmluZyhlbGVtZW50KTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGV4dHJhY3RQbGFzbWljUXVlcnlEYXRhRnJvbUVsZW1lbnQoXG4gIGxvYWRlcjogUGxhc21pY0NvbXBvbmVudExvYWRlcixcbiAgbG9va3VwOiBDb21wb25lbnRMb29rdXBTcGVjLFxuICBvcHRzOiB7XG4gICAgcHJlZmV0Y2hlZERhdGE/OiBDb21wb25lbnRSZW5kZXJEYXRhO1xuICAgIGNvbXBvbmVudFByb3BzPzogYW55O1xuICAgIGdsb2JhbFZhcmlhbnRzPzogR2xvYmFsVmFyaWFudFNwZWNbXTtcbiAgICBwcmVmZXRjaGVkUXVlcnlEYXRhPzogUmVjb3JkPHN0cmluZywgYW55PjtcbiAgfSA9IHt9XG4pIHtcbiAgY29uc3QgZWxlbWVudCA9IG1ha2VFbGVtZW50KGxvYWRlciwgbG9va3VwLCBvcHRzKTtcbiAgcmV0dXJuIGV4dHJhY3RQbGFzbWljUXVlcnlEYXRhKGVsZW1lbnQpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaHlkcmF0ZUZyb21FbGVtZW50KFxuICBsb2FkZXI6IFBsYXNtaWNDb21wb25lbnRMb2FkZXIsXG4gIHRhcmdldDogSFRNTEVsZW1lbnQsXG4gIGxvb2t1cDogQ29tcG9uZW50TG9va3VwU3BlYyxcbiAgb3B0czoge1xuICAgIHByZWZldGNoZWREYXRhPzogQ29tcG9uZW50UmVuZGVyRGF0YTtcbiAgICBjb21wb25lbnRQcm9wcz86IGFueTtcbiAgICBnbG9iYWxWYXJpYW50cz86IEdsb2JhbFZhcmlhbnRTcGVjW107XG4gICAgcHJlZmV0Y2hlZFF1ZXJ5RGF0YT86IFJlY29yZDxzdHJpbmcsIGFueT47XG4gIH0gPSB7fVxuKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSkgPT4ge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBtYWtlRWxlbWVudChsb2FkZXIsIGxvb2t1cCwgb3B0cyk7XG4gICAgUmVhY3RET00uaHlkcmF0ZShlbGVtZW50LCB0YXJnZXQsICgpID0+IHJlc29sdmUoKSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBtYWtlRWxlbWVudChcbiAgbG9hZGVyOiBQbGFzbWljQ29tcG9uZW50TG9hZGVyLFxuICBsb29rdXA6IENvbXBvbmVudExvb2t1cFNwZWMsXG4gIG9wdHM6IHtcbiAgICBwcmVmZXRjaGVkRGF0YT86IENvbXBvbmVudFJlbmRlckRhdGE7XG4gICAgY29tcG9uZW50UHJvcHM/OiBhbnk7XG4gICAgZ2xvYmFsVmFyaWFudHM/OiBHbG9iYWxWYXJpYW50U3BlY1tdO1xuICAgIHByZWZldGNoZWRRdWVyeURhdGE/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuICAgIHBhZ2VQYXJhbXM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuICAgIHBhZ2VRdWVyeT86IFJlY29yZDxzdHJpbmcsIGFueT47XG4gIH0gPSB7fVxuKSB7XG4gIHJldHVybiAoXG4gICAgPFBsYXNtaWNSb290UHJvdmlkZXJcbiAgICAgIGxvYWRlcj17bG9hZGVyfVxuICAgICAgcHJlZmV0Y2hlZERhdGE9e29wdHMucHJlZmV0Y2hlZERhdGF9XG4gICAgICBnbG9iYWxWYXJpYW50cz17b3B0cy5nbG9iYWxWYXJpYW50c31cbiAgICAgIHByZWZldGNoZWRRdWVyeURhdGE9e29wdHMucHJlZmV0Y2hlZFF1ZXJ5RGF0YX1cbiAgICAgIHBhZ2VQYXJhbXM9e29wdHMucGFnZVBhcmFtc31cbiAgICAgIHBhZ2VRdWVyeT17b3B0cy5wYWdlUXVlcnl9XG4gICAgPlxuICAgICAgPFBsYXNtaWNDb21wb25lbnRcbiAgICAgICAgY29tcG9uZW50PXt0eXBlb2YgbG9va3VwID09PSBcInN0cmluZ1wiID8gbG9va3VwIDogbG9va3VwLm5hbWV9XG4gICAgICAgIHByb2plY3RJZD17dHlwZW9mIGxvb2t1cCA9PT0gXCJzdHJpbmdcIiA/IHVuZGVmaW5lZCA6IGxvb2t1cC5wcm9qZWN0SWR9XG4gICAgICAgIGNvbXBvbmVudFByb3BzPXtvcHRzLmNvbXBvbmVudFByb3BzfVxuICAgICAgLz5cbiAgICA8L1BsYXNtaWNSb290UHJvdmlkZXI+XG4gICk7XG59XG4iXSwibmFtZXMiOlsiUGxhc21pY01vZHVsZXNGZXRjaGVyIiwiUGxhc21pY1RyYWNrZXIiLCJSZWFjdCIsIlBsYXNtaWNDc3MiLCJfYSIsIl9iIiwiUGFnZVBhcmFtc1Byb3ZpZGVyIiwiZXh0cmFjdFBsYXNtaWNRdWVyeURhdGEiLCJSZWFjdERPTSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@plasmicapp/loader-react/dist/index.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@plasmicapp/loader-splits/dist/index.esm.js":
/*!******************************************************************!*\
  !*** ./node_modules/@plasmicapp/loader-splits/dist/index.esm.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   describeVariation: () => (/* binding */ describeVariation),\n/* harmony export */   describeVariationForKey: () => (/* binding */ describeVariationForKey),\n/* harmony export */   getActiveVariation: () => (/* binding */ getActiveVariation),\n/* harmony export */   getExternalIds: () => (/* binding */ getExternalIds),\n/* harmony export */   getSeededRandomFunction: () => (/* binding */ getSeededRandomFunction),\n/* harmony export */   getSplitKey: () => (/* binding */ getSplitKey)\n/* harmony export */ });\n/* harmony import */ var json_logic_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! json-logic-js */ \"(ssr)/./node_modules/json-logic-js/logic.js\");\n/* harmony import */ var json_logic_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(json_logic_js__WEBPACK_IMPORTED_MODULE_0__);\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\n\n// src/random.ts\nvar getSeededRandomFunction = (strSeed) => {\n  function cyrb128(str) {\n    let h1 = 1779033703, h2 = 3144134277, h3 = 1013904242, h4 = 2773480762;\n    for (let i = 0, k; i < str.length; i++) {\n      k = str.charCodeAt(i);\n      h1 = h2 ^ Math.imul(h1 ^ k, 597399067);\n      h2 = h3 ^ Math.imul(h2 ^ k, 2869860233);\n      h3 = h4 ^ Math.imul(h3 ^ k, 951274213);\n      h4 = h1 ^ Math.imul(h4 ^ k, 2716044179);\n    }\n    h1 = Math.imul(h3 ^ h1 >>> 18, 597399067);\n    h2 = Math.imul(h4 ^ h2 >>> 22, 2869860233);\n    h3 = Math.imul(h1 ^ h3 >>> 17, 951274213);\n    h4 = Math.imul(h2 ^ h4 >>> 19, 2716044179);\n    return [\n      (h1 ^ h2 ^ h3 ^ h4) >>> 0,\n      (h2 ^ h1) >>> 0,\n      (h3 ^ h1) >>> 0,\n      (h4 ^ h1) >>> 0\n    ];\n  }\n  function sfc32(a, b, c, d) {\n    return function() {\n      a >>>= 0;\n      b >>>= 0;\n      c >>>= 0;\n      d >>>= 0;\n      let t = a + b | 0;\n      a = b ^ b >>> 9;\n      b = c + (c << 3) | 0;\n      c = c << 21 | c >>> 11;\n      d = d + 1 | 0;\n      t = t + d | 0;\n      c = c + t | 0;\n      return (t >>> 0) / 4294967296;\n    };\n  }\n  const seed = cyrb128(strSeed);\n  const rand = sfc32(seed[0], seed[1], seed[2], seed[3]);\n  return rand;\n};\n\n// src/variation.ts\n\nvar isBrowser = typeof window !== \"undefined\" && window != null && typeof window.document !== \"undefined\";\nvar PLASMIC_SEED = \"plasmic_seed\";\nvar BUILTIN_TRAITS_UNKNOWN = {\n  pageUrl: \"unknown\"\n};\nvar getBrowserBuiltinTraits = () => {\n  if (!isBrowser) {\n    return {};\n  }\n  return {\n    pageUrl: document.location.href\n  };\n};\nvar getSplitKey = (split) => {\n  return `${split.type === \"experiment\" ? \"exp.\" : \"seg.\"}${split.id}`;\n};\nfunction getActiveVariation(opts) {\n  const { splits, getKnownValue, updateKnownValue } = opts;\n  const getRandomValue = (key) => {\n    var _a;\n    if (opts.getRandomValue) {\n      return opts.getRandomValue(key);\n    }\n    if (opts.traits[PLASMIC_SEED]) {\n      const rand = getSeededRandomFunction(\n        ((_a = opts.traits[PLASMIC_SEED]) != null ? _a : \"\") + key\n      );\n      return rand();\n    }\n    if (!opts.enableUnseededExperiments) {\n      return 0;\n    }\n    return Math.random();\n  };\n  const variation = {};\n  splits.forEach((split) => {\n    var _a;\n    const key = getSplitKey(split);\n    const knownVal = getKnownValue == null ? void 0 : getKnownValue(key);\n    if (knownVal) {\n      variation[key] = knownVal;\n      return;\n    }\n    const numSlices = split.slices.length;\n    let chosenSlice = void 0;\n    if (split.type === \"experiment\") {\n      if (opts.useSeedBucketing) {\n        const seed = opts.traits[PLASMIC_SEED];\n        const buckets = [];\n        const totalBuckets = (_a = opts.seedRange) != null ? _a : 1;\n        let avaiableBuckets = totalBuckets;\n        for (let i = 0; i < numSlices; i++) {\n          const slice = split.slices[i];\n          const numBuckets = Math.min(\n            Math.floor(slice.prob * totalBuckets),\n            avaiableBuckets\n          );\n          for (let j = 0; j < numBuckets; j++) {\n            buckets.push(slice.id);\n          }\n          avaiableBuckets -= numBuckets;\n        }\n        if (buckets.length > 0) {\n          const shuffleRand = getSeededRandomFunction(split.id);\n          for (let i = 0; i < buckets.length; i++) {\n            const j = Math.floor(shuffleRand() * (i + 1));\n            [buckets[i], buckets[j]] = [buckets[j], buckets[i]];\n          }\n          const sliceIdx = +(seed != null ? seed : \"0\") % buckets.length;\n          chosenSlice = split.slices.find((s) => s.id === buckets[sliceIdx]);\n        } else {\n          chosenSlice = split.slices[numSlices - 1];\n        }\n      } else {\n        let p = getRandomValue(split.id);\n        chosenSlice = split.slices[numSlices - 1];\n        for (let i = 0; i < numSlices; i++) {\n          if (p - split.slices[i].prob <= 0) {\n            chosenSlice = split.slices[i];\n            break;\n          }\n          p -= split.slices[i].prob;\n        }\n      }\n    } else if (split.type === \"segment\") {\n      for (let i = 0; i < numSlices; i++) {\n        if (json_logic_js__WEBPACK_IMPORTED_MODULE_0___default().apply(split.slices[i].cond, __spreadValues(__spreadValues(__spreadValues({\n          time: (/* @__PURE__ */ new Date()).toISOString()\n        }, BUILTIN_TRAITS_UNKNOWN), getBrowserBuiltinTraits()), opts.traits))) {\n          chosenSlice = split.slices[i];\n        }\n      }\n    }\n    if (chosenSlice) {\n      variation[key] = chosenSlice.id;\n      if (split.externalId && chosenSlice.externalId) {\n        variation[`ext.${split.externalId}`] = chosenSlice.externalId;\n      }\n      if (split.type === \"experiment\") {\n        updateKnownValue == null ? void 0 : updateKnownValue(key, chosenSlice.id);\n      }\n    }\n  });\n  return variation;\n}\nfunction getExternalIds(splits, variation, filters) {\n  const externalVariation = {};\n  function shouldIncludeSplit(split) {\n    if (!filters) {\n      return true;\n    }\n    if (filters.projectIds && !filters.projectIds.includes(split.projectId)) {\n      return false;\n    }\n    if (filters.customFilter && !filters.customFilter(split)) {\n      return false;\n    }\n    return true;\n  }\n  Object.keys(variation).forEach((variationKey) => {\n    const [, splitId] = variationKey.split(\".\");\n    const sliceId = variation[variationKey];\n    const split = splits.find(\n      (s) => s.id === splitId || s.externalId === splitId\n    );\n    if (split && split.externalId && shouldIncludeSplit(split)) {\n      const slice = split.slices.find((s) => s.id === sliceId || s.externalId === sliceId);\n      if (slice == null ? void 0 : slice.externalId) {\n        externalVariation[`${split.externalId}`] = slice.externalId;\n      }\n    }\n  });\n  return externalVariation;\n}\nfunction describeVariationForKey(splits, key, value) {\n  const [, splitId] = key.split(\".\");\n  const split = splits.find(\n    (s) => s.id === splitId || s.externalId === splitId\n  );\n  if (!split) {\n    throw new Error(`Split not found for key \"${key}\"`);\n  }\n  const sliceIndex = split.slices.findIndex(\n    (s) => s.id === value || s.externalId === value\n  );\n  if (sliceIndex === -1) {\n    throw new Error(`Invalid split value \"${value}\" for key \"${key}\"`);\n  }\n  return {\n    name: split.name,\n    description: split.description,\n    pagesPaths: split.pagesPaths,\n    type: sliceIndex === 0 ? \"original\" : \"override\",\n    chosenValue: value,\n    externalIdGroup: split.externalId,\n    externalIdValue: sliceIndex >= 0 && split.slices[sliceIndex].externalId ? split.slices[sliceIndex].externalId : void 0\n  };\n}\nfunction describeVariation(splits, variation) {\n  return Object.fromEntries(\n    Object.entries(variation).map(([key, value]) => {\n      return [key, describeVariationForKey(splits, key, value)];\n    })\n  );\n}\n\n//# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBsYXNtaWNhcHAvbG9hZGVyLXNwbGl0cy9kaXN0L2luZGV4LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ3NDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDhDQUE4QyxFQUFFLFNBQVM7QUFDckU7QUFDQTtBQUNBLFVBQVUsMENBQTBDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZ0JBQWdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixvQkFBb0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixzQkFBc0IsZUFBZTtBQUNyQyxZQUFZLDBEQUFlO0FBQzNCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGlCQUFpQjtBQUM5QztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsSUFBSTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE1BQU0sYUFBYSxJQUFJO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBUUU7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvV29uZGVyVml0ZS1mcm9udGVuZC9ub2RlX21vZHVsZXMvQHBsYXNtaWNhcHAvbG9hZGVyLXNwbGl0cy9kaXN0L2luZGV4LmVzbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG5cbi8vIHNyYy9yYW5kb20udHNcbnZhciBnZXRTZWVkZWRSYW5kb21GdW5jdGlvbiA9IChzdHJTZWVkKSA9PiB7XG4gIGZ1bmN0aW9uIGN5cmIxMjgoc3RyKSB7XG4gICAgbGV0IGgxID0gMTc3OTAzMzcwMywgaDIgPSAzMTQ0MTM0Mjc3LCBoMyA9IDEwMTM5MDQyNDIsIGg0ID0gMjc3MzQ4MDc2MjtcbiAgICBmb3IgKGxldCBpID0gMCwgazsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgayA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgaDEgPSBoMiBeIE1hdGguaW11bChoMSBeIGssIDU5NzM5OTA2Nyk7XG4gICAgICBoMiA9IGgzIF4gTWF0aC5pbXVsKGgyIF4gaywgMjg2OTg2MDIzMyk7XG4gICAgICBoMyA9IGg0IF4gTWF0aC5pbXVsKGgzIF4gaywgOTUxMjc0MjEzKTtcbiAgICAgIGg0ID0gaDEgXiBNYXRoLmltdWwoaDQgXiBrLCAyNzE2MDQ0MTc5KTtcbiAgICB9XG4gICAgaDEgPSBNYXRoLmltdWwoaDMgXiBoMSA+Pj4gMTgsIDU5NzM5OTA2Nyk7XG4gICAgaDIgPSBNYXRoLmltdWwoaDQgXiBoMiA+Pj4gMjIsIDI4Njk4NjAyMzMpO1xuICAgIGgzID0gTWF0aC5pbXVsKGgxIF4gaDMgPj4+IDE3LCA5NTEyNzQyMTMpO1xuICAgIGg0ID0gTWF0aC5pbXVsKGgyIF4gaDQgPj4+IDE5LCAyNzE2MDQ0MTc5KTtcbiAgICByZXR1cm4gW1xuICAgICAgKGgxIF4gaDIgXiBoMyBeIGg0KSA+Pj4gMCxcbiAgICAgIChoMiBeIGgxKSA+Pj4gMCxcbiAgICAgIChoMyBeIGgxKSA+Pj4gMCxcbiAgICAgIChoNCBeIGgxKSA+Pj4gMFxuICAgIF07XG4gIH1cbiAgZnVuY3Rpb24gc2ZjMzIoYSwgYiwgYywgZCkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGEgPj4+PSAwO1xuICAgICAgYiA+Pj49IDA7XG4gICAgICBjID4+Pj0gMDtcbiAgICAgIGQgPj4+PSAwO1xuICAgICAgbGV0IHQgPSBhICsgYiB8IDA7XG4gICAgICBhID0gYiBeIGIgPj4+IDk7XG4gICAgICBiID0gYyArIChjIDw8IDMpIHwgMDtcbiAgICAgIGMgPSBjIDw8IDIxIHwgYyA+Pj4gMTE7XG4gICAgICBkID0gZCArIDEgfCAwO1xuICAgICAgdCA9IHQgKyBkIHwgMDtcbiAgICAgIGMgPSBjICsgdCB8IDA7XG4gICAgICByZXR1cm4gKHQgPj4+IDApIC8gNDI5NDk2NzI5NjtcbiAgICB9O1xuICB9XG4gIGNvbnN0IHNlZWQgPSBjeXJiMTI4KHN0clNlZWQpO1xuICBjb25zdCByYW5kID0gc2ZjMzIoc2VlZFswXSwgc2VlZFsxXSwgc2VlZFsyXSwgc2VlZFszXSk7XG4gIHJldHVybiByYW5kO1xufTtcblxuLy8gc3JjL3ZhcmlhdGlvbi50c1xuaW1wb3J0IGpzb25Mb2dpYyBmcm9tIFwianNvbi1sb2dpYy1qc1wiO1xudmFyIGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93ICE9IG51bGwgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIjtcbnZhciBQTEFTTUlDX1NFRUQgPSBcInBsYXNtaWNfc2VlZFwiO1xudmFyIEJVSUxUSU5fVFJBSVRTX1VOS05PV04gPSB7XG4gIHBhZ2VVcmw6IFwidW5rbm93blwiXG59O1xudmFyIGdldEJyb3dzZXJCdWlsdGluVHJhaXRzID0gKCkgPT4ge1xuICBpZiAoIWlzQnJvd3Nlcikge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHBhZ2VVcmw6IGRvY3VtZW50LmxvY2F0aW9uLmhyZWZcbiAgfTtcbn07XG52YXIgZ2V0U3BsaXRLZXkgPSAoc3BsaXQpID0+IHtcbiAgcmV0dXJuIGAke3NwbGl0LnR5cGUgPT09IFwiZXhwZXJpbWVudFwiID8gXCJleHAuXCIgOiBcInNlZy5cIn0ke3NwbGl0LmlkfWA7XG59O1xuZnVuY3Rpb24gZ2V0QWN0aXZlVmFyaWF0aW9uKG9wdHMpIHtcbiAgY29uc3QgeyBzcGxpdHMsIGdldEtub3duVmFsdWUsIHVwZGF0ZUtub3duVmFsdWUgfSA9IG9wdHM7XG4gIGNvbnN0IGdldFJhbmRvbVZhbHVlID0gKGtleSkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBpZiAob3B0cy5nZXRSYW5kb21WYWx1ZSkge1xuICAgICAgcmV0dXJuIG9wdHMuZ2V0UmFuZG9tVmFsdWUoa2V5KTtcbiAgICB9XG4gICAgaWYgKG9wdHMudHJhaXRzW1BMQVNNSUNfU0VFRF0pIHtcbiAgICAgIGNvbnN0IHJhbmQgPSBnZXRTZWVkZWRSYW5kb21GdW5jdGlvbihcbiAgICAgICAgKChfYSA9IG9wdHMudHJhaXRzW1BMQVNNSUNfU0VFRF0pICE9IG51bGwgPyBfYSA6IFwiXCIpICsga2V5XG4gICAgICApO1xuICAgICAgcmV0dXJuIHJhbmQoKTtcbiAgICB9XG4gICAgaWYgKCFvcHRzLmVuYWJsZVVuc2VlZGVkRXhwZXJpbWVudHMpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKTtcbiAgfTtcbiAgY29uc3QgdmFyaWF0aW9uID0ge307XG4gIHNwbGl0cy5mb3JFYWNoKChzcGxpdCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBrZXkgPSBnZXRTcGxpdEtleShzcGxpdCk7XG4gICAgY29uc3Qga25vd25WYWwgPSBnZXRLbm93blZhbHVlID09IG51bGwgPyB2b2lkIDAgOiBnZXRLbm93blZhbHVlKGtleSk7XG4gICAgaWYgKGtub3duVmFsKSB7XG4gICAgICB2YXJpYXRpb25ba2V5XSA9IGtub3duVmFsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBudW1TbGljZXMgPSBzcGxpdC5zbGljZXMubGVuZ3RoO1xuICAgIGxldCBjaG9zZW5TbGljZSA9IHZvaWQgMDtcbiAgICBpZiAoc3BsaXQudHlwZSA9PT0gXCJleHBlcmltZW50XCIpIHtcbiAgICAgIGlmIChvcHRzLnVzZVNlZWRCdWNrZXRpbmcpIHtcbiAgICAgICAgY29uc3Qgc2VlZCA9IG9wdHMudHJhaXRzW1BMQVNNSUNfU0VFRF07XG4gICAgICAgIGNvbnN0IGJ1Y2tldHMgPSBbXTtcbiAgICAgICAgY29uc3QgdG90YWxCdWNrZXRzID0gKF9hID0gb3B0cy5zZWVkUmFuZ2UpICE9IG51bGwgPyBfYSA6IDE7XG4gICAgICAgIGxldCBhdmFpYWJsZUJ1Y2tldHMgPSB0b3RhbEJ1Y2tldHM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtU2xpY2VzOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBzbGljZSA9IHNwbGl0LnNsaWNlc1tpXTtcbiAgICAgICAgICBjb25zdCBudW1CdWNrZXRzID0gTWF0aC5taW4oXG4gICAgICAgICAgICBNYXRoLmZsb29yKHNsaWNlLnByb2IgKiB0b3RhbEJ1Y2tldHMpLFxuICAgICAgICAgICAgYXZhaWFibGVCdWNrZXRzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG51bUJ1Y2tldHM7IGorKykge1xuICAgICAgICAgICAgYnVja2V0cy5wdXNoKHNsaWNlLmlkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXZhaWFibGVCdWNrZXRzIC09IG51bUJ1Y2tldHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1Y2tldHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IHNodWZmbGVSYW5kID0gZ2V0U2VlZGVkUmFuZG9tRnVuY3Rpb24oc3BsaXQuaWQpO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVja2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaiA9IE1hdGguZmxvb3Ioc2h1ZmZsZVJhbmQoKSAqIChpICsgMSkpO1xuICAgICAgICAgICAgW2J1Y2tldHNbaV0sIGJ1Y2tldHNbal1dID0gW2J1Y2tldHNbal0sIGJ1Y2tldHNbaV1dO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBzbGljZUlkeCA9ICsoc2VlZCAhPSBudWxsID8gc2VlZCA6IFwiMFwiKSAlIGJ1Y2tldHMubGVuZ3RoO1xuICAgICAgICAgIGNob3NlblNsaWNlID0gc3BsaXQuc2xpY2VzLmZpbmQoKHMpID0+IHMuaWQgPT09IGJ1Y2tldHNbc2xpY2VJZHhdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaG9zZW5TbGljZSA9IHNwbGl0LnNsaWNlc1tudW1TbGljZXMgLSAxXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHAgPSBnZXRSYW5kb21WYWx1ZShzcGxpdC5pZCk7XG4gICAgICAgIGNob3NlblNsaWNlID0gc3BsaXQuc2xpY2VzW251bVNsaWNlcyAtIDFdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVNsaWNlczsgaSsrKSB7XG4gICAgICAgICAgaWYgKHAgLSBzcGxpdC5zbGljZXNbaV0ucHJvYiA8PSAwKSB7XG4gICAgICAgICAgICBjaG9zZW5TbGljZSA9IHNwbGl0LnNsaWNlc1tpXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwIC09IHNwbGl0LnNsaWNlc1tpXS5wcm9iO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzcGxpdC50eXBlID09PSBcInNlZ21lbnRcIikge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1TbGljZXM7IGkrKykge1xuICAgICAgICBpZiAoanNvbkxvZ2ljLmFwcGx5KHNwbGl0LnNsaWNlc1tpXS5jb25kLCBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7XG4gICAgICAgICAgdGltZTogKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS50b0lTT1N0cmluZygpXG4gICAgICAgIH0sIEJVSUxUSU5fVFJBSVRTX1VOS05PV04pLCBnZXRCcm93c2VyQnVpbHRpblRyYWl0cygpKSwgb3B0cy50cmFpdHMpKSkge1xuICAgICAgICAgIGNob3NlblNsaWNlID0gc3BsaXQuc2xpY2VzW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjaG9zZW5TbGljZSkge1xuICAgICAgdmFyaWF0aW9uW2tleV0gPSBjaG9zZW5TbGljZS5pZDtcbiAgICAgIGlmIChzcGxpdC5leHRlcm5hbElkICYmIGNob3NlblNsaWNlLmV4dGVybmFsSWQpIHtcbiAgICAgICAgdmFyaWF0aW9uW2BleHQuJHtzcGxpdC5leHRlcm5hbElkfWBdID0gY2hvc2VuU2xpY2UuZXh0ZXJuYWxJZDtcbiAgICAgIH1cbiAgICAgIGlmIChzcGxpdC50eXBlID09PSBcImV4cGVyaW1lbnRcIikge1xuICAgICAgICB1cGRhdGVLbm93blZhbHVlID09IG51bGwgPyB2b2lkIDAgOiB1cGRhdGVLbm93blZhbHVlKGtleSwgY2hvc2VuU2xpY2UuaWQpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiB2YXJpYXRpb247XG59XG5mdW5jdGlvbiBnZXRFeHRlcm5hbElkcyhzcGxpdHMsIHZhcmlhdGlvbiwgZmlsdGVycykge1xuICBjb25zdCBleHRlcm5hbFZhcmlhdGlvbiA9IHt9O1xuICBmdW5jdGlvbiBzaG91bGRJbmNsdWRlU3BsaXQoc3BsaXQpIHtcbiAgICBpZiAoIWZpbHRlcnMpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoZmlsdGVycy5wcm9qZWN0SWRzICYmICFmaWx0ZXJzLnByb2plY3RJZHMuaW5jbHVkZXMoc3BsaXQucHJvamVjdElkKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZmlsdGVycy5jdXN0b21GaWx0ZXIgJiYgIWZpbHRlcnMuY3VzdG9tRmlsdGVyKHNwbGl0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBPYmplY3Qua2V5cyh2YXJpYXRpb24pLmZvckVhY2goKHZhcmlhdGlvbktleSkgPT4ge1xuICAgIGNvbnN0IFssIHNwbGl0SWRdID0gdmFyaWF0aW9uS2V5LnNwbGl0KFwiLlwiKTtcbiAgICBjb25zdCBzbGljZUlkID0gdmFyaWF0aW9uW3ZhcmlhdGlvbktleV07XG4gICAgY29uc3Qgc3BsaXQgPSBzcGxpdHMuZmluZChcbiAgICAgIChzKSA9PiBzLmlkID09PSBzcGxpdElkIHx8IHMuZXh0ZXJuYWxJZCA9PT0gc3BsaXRJZFxuICAgICk7XG4gICAgaWYgKHNwbGl0ICYmIHNwbGl0LmV4dGVybmFsSWQgJiYgc2hvdWxkSW5jbHVkZVNwbGl0KHNwbGl0KSkge1xuICAgICAgY29uc3Qgc2xpY2UgPSBzcGxpdC5zbGljZXMuZmluZCgocykgPT4gcy5pZCA9PT0gc2xpY2VJZCB8fCBzLmV4dGVybmFsSWQgPT09IHNsaWNlSWQpO1xuICAgICAgaWYgKHNsaWNlID09IG51bGwgPyB2b2lkIDAgOiBzbGljZS5leHRlcm5hbElkKSB7XG4gICAgICAgIGV4dGVybmFsVmFyaWF0aW9uW2Ake3NwbGl0LmV4dGVybmFsSWR9YF0gPSBzbGljZS5leHRlcm5hbElkO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBleHRlcm5hbFZhcmlhdGlvbjtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlVmFyaWF0aW9uRm9yS2V5KHNwbGl0cywga2V5LCB2YWx1ZSkge1xuICBjb25zdCBbLCBzcGxpdElkXSA9IGtleS5zcGxpdChcIi5cIik7XG4gIGNvbnN0IHNwbGl0ID0gc3BsaXRzLmZpbmQoXG4gICAgKHMpID0+IHMuaWQgPT09IHNwbGl0SWQgfHwgcy5leHRlcm5hbElkID09PSBzcGxpdElkXG4gICk7XG4gIGlmICghc3BsaXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFNwbGl0IG5vdCBmb3VuZCBmb3Iga2V5IFwiJHtrZXl9XCJgKTtcbiAgfVxuICBjb25zdCBzbGljZUluZGV4ID0gc3BsaXQuc2xpY2VzLmZpbmRJbmRleChcbiAgICAocykgPT4gcy5pZCA9PT0gdmFsdWUgfHwgcy5leHRlcm5hbElkID09PSB2YWx1ZVxuICApO1xuICBpZiAoc2xpY2VJbmRleCA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc3BsaXQgdmFsdWUgXCIke3ZhbHVlfVwiIGZvciBrZXkgXCIke2tleX1cImApO1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogc3BsaXQubmFtZSxcbiAgICBkZXNjcmlwdGlvbjogc3BsaXQuZGVzY3JpcHRpb24sXG4gICAgcGFnZXNQYXRoczogc3BsaXQucGFnZXNQYXRocyxcbiAgICB0eXBlOiBzbGljZUluZGV4ID09PSAwID8gXCJvcmlnaW5hbFwiIDogXCJvdmVycmlkZVwiLFxuICAgIGNob3NlblZhbHVlOiB2YWx1ZSxcbiAgICBleHRlcm5hbElkR3JvdXA6IHNwbGl0LmV4dGVybmFsSWQsXG4gICAgZXh0ZXJuYWxJZFZhbHVlOiBzbGljZUluZGV4ID49IDAgJiYgc3BsaXQuc2xpY2VzW3NsaWNlSW5kZXhdLmV4dGVybmFsSWQgPyBzcGxpdC5zbGljZXNbc2xpY2VJbmRleF0uZXh0ZXJuYWxJZCA6IHZvaWQgMFxuICB9O1xufVxuZnVuY3Rpb24gZGVzY3JpYmVWYXJpYXRpb24oc3BsaXRzLCB2YXJpYXRpb24pIHtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBPYmplY3QuZW50cmllcyh2YXJpYXRpb24pLm1hcCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICByZXR1cm4gW2tleSwgZGVzY3JpYmVWYXJpYXRpb25Gb3JLZXkoc3BsaXRzLCBrZXksIHZhbHVlKV07XG4gICAgfSlcbiAgKTtcbn1cbmV4cG9ydCB7XG4gIGRlc2NyaWJlVmFyaWF0aW9uLFxuICBkZXNjcmliZVZhcmlhdGlvbkZvcktleSxcbiAgZ2V0QWN0aXZlVmFyaWF0aW9uLFxuICBnZXRFeHRlcm5hbElkcyxcbiAgZ2V0U2VlZGVkUmFuZG9tRnVuY3Rpb24sXG4gIGdldFNwbGl0S2V5XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@plasmicapp/loader-splits/dist/index.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@plasmicapp/prepass/dist/index.esm.js":
/*!************************************************************!*\
  !*** ./node_modules/@plasmicapp/prepass/dist/index.esm.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   extractPlasmicQueryData: () => (/* binding */ extractPlasmicQueryData),\n/* harmony export */   plasmicPrepass: () => (/* binding */ plasmicPrepass),\n/* harmony export */   plasmicPrepassExtract: () => (/* binding */ plasmicPrepassExtract)\n/* harmony export */ });\n/* harmony import */ var _plasmicapp_query__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @plasmicapp/query */ \"(ssr)/./node_modules/@plasmicapp/query/dist/index.esm.js\");\n/* harmony import */ var _plasmicapp_react_ssr_prepass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @plasmicapp/react-ssr-prepass */ \"(ssr)/./node_modules/@plasmicapp/react-ssr-prepass/dist/react-ssr-prepass.es.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\nasync function plasmicPrepassExtract(element, onClientComponentRef) {\n  const cache = /* @__PURE__ */ new Map();\n  const headMetadata = {};\n  try {\n    await plasmicPrepass(\n      /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_plasmicapp_query__WEBPACK_IMPORTED_MODULE_0__.PlasmicPrepassContext, { cache }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_plasmicapp_query__WEBPACK_IMPORTED_MODULE_0__.HeadMetadataContext.Provider, { value: headMetadata }, element)),\n      onClientComponentRef\n    );\n  } catch (err) {\n    console.warn(`PLASMIC: Error encountered while pre-rendering`, err);\n  }\n  const filteredCache = Object.fromEntries(\n    Array.from(cache.entries()).filter(\n      ([key, val]) => !key.startsWith(\"$swr$\") && !key.startsWith(\"$csq$\") && val !== void 0\n    )\n  );\n  const queryData = (() => {\n    try {\n      return JSON.parse(\n        JSON.stringify(\n          filteredCache,\n          (_key, value) => value !== void 0 ? value : null\n        )\n      );\n    } catch {\n      return filteredCache;\n    }\n  })();\n  return {\n    queryData,\n    headMetadata\n  };\n}\nasync function extractPlasmicQueryData(element, onClientComponentRef) {\n  return (await plasmicPrepassExtract(element, onClientComponentRef)).queryData;\n}\nasync function plasmicPrepass(element, onClientComponentRef) {\n  await (0,_plasmicapp_react_ssr_prepass__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(element, void 0, onClientComponentRef);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBsYXNtaWNhcHAvcHJlcGFzcy9kaXN0L2luZGV4LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBRzJCO0FBQ3lCO0FBQzFCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMERBQW1CLENBQUMsb0VBQXFCLElBQUksT0FBTyxrQkFBa0IsMERBQW1CLENBQUMsa0VBQW1CLGFBQWEscUJBQXFCO0FBQ3JLO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx5RUFBTztBQUNmO0FBS0UiLCJzb3VyY2VzIjpbIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL1dvbmRlclZpdGUtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BwbGFzbWljYXBwL3ByZXBhc3MvZGlzdC9pbmRleC5lc20uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgSGVhZE1ldGFkYXRhQ29udGV4dCxcbiAgUGxhc21pY1ByZXBhc3NDb250ZXh0XG59IGZyb20gXCJAcGxhc21pY2FwcC9xdWVyeVwiO1xuaW1wb3J0IHByZXBhc3MgZnJvbSBcIkBwbGFzbWljYXBwL3JlYWN0LXNzci1wcmVwYXNzXCI7XG5pbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5hc3luYyBmdW5jdGlvbiBwbGFzbWljUHJlcGFzc0V4dHJhY3QoZWxlbWVudCwgb25DbGllbnRDb21wb25lbnRSZWYpIHtcbiAgY29uc3QgY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCBoZWFkTWV0YWRhdGEgPSB7fTtcbiAgdHJ5IHtcbiAgICBhd2FpdCBwbGFzbWljUHJlcGFzcyhcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFBsYXNtaWNQcmVwYXNzQ29udGV4dCwgeyBjYWNoZSB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChIZWFkTWV0YWRhdGFDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBoZWFkTWV0YWRhdGEgfSwgZWxlbWVudCkpLFxuICAgICAgb25DbGllbnRDb21wb25lbnRSZWZcbiAgICApO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLndhcm4oYFBMQVNNSUM6IEVycm9yIGVuY291bnRlcmVkIHdoaWxlIHByZS1yZW5kZXJpbmdgLCBlcnIpO1xuICB9XG4gIGNvbnN0IGZpbHRlcmVkQ2FjaGUgPSBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgQXJyYXkuZnJvbShjYWNoZS5lbnRyaWVzKCkpLmZpbHRlcihcbiAgICAgIChba2V5LCB2YWxdKSA9PiAha2V5LnN0YXJ0c1dpdGgoXCIkc3dyJFwiKSAmJiAha2V5LnN0YXJ0c1dpdGgoXCIkY3NxJFwiKSAmJiB2YWwgIT09IHZvaWQgMFxuICAgIClcbiAgKTtcbiAgY29uc3QgcXVlcnlEYXRhID0gKCgpID0+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UoXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KFxuICAgICAgICAgIGZpbHRlcmVkQ2FjaGUsXG4gICAgICAgICAgKF9rZXksIHZhbHVlKSA9PiB2YWx1ZSAhPT0gdm9pZCAwID8gdmFsdWUgOiBudWxsXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gZmlsdGVyZWRDYWNoZTtcbiAgICB9XG4gIH0pKCk7XG4gIHJldHVybiB7XG4gICAgcXVlcnlEYXRhLFxuICAgIGhlYWRNZXRhZGF0YVxuICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gZXh0cmFjdFBsYXNtaWNRdWVyeURhdGEoZWxlbWVudCwgb25DbGllbnRDb21wb25lbnRSZWYpIHtcbiAgcmV0dXJuIChhd2FpdCBwbGFzbWljUHJlcGFzc0V4dHJhY3QoZWxlbWVudCwgb25DbGllbnRDb21wb25lbnRSZWYpKS5xdWVyeURhdGE7XG59XG5hc3luYyBmdW5jdGlvbiBwbGFzbWljUHJlcGFzcyhlbGVtZW50LCBvbkNsaWVudENvbXBvbmVudFJlZikge1xuICBhd2FpdCBwcmVwYXNzKGVsZW1lbnQsIHZvaWQgMCwgb25DbGllbnRDb21wb25lbnRSZWYpO1xufVxuZXhwb3J0IHtcbiAgZXh0cmFjdFBsYXNtaWNRdWVyeURhdGEsXG4gIHBsYXNtaWNQcmVwYXNzLFxuICBwbGFzbWljUHJlcGFzc0V4dHJhY3Rcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@plasmicapp/prepass/dist/index.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@plasmicapp/query/dist/index.esm.js":
/*!**********************************************************!*\
  !*** ./node_modules/@plasmicapp/query/dist/index.esm.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HeadMetadataContext: () => (/* binding */ HeadMetadataContext),\n/* harmony export */   PlasmicPrepassContext: () => (/* binding */ PlasmicPrepassContext),\n/* harmony export */   PlasmicQueryDataProvider: () => (/* binding */ PlasmicQueryDataProvider),\n/* harmony export */   addLoadingStateListener: () => (/* binding */ addLoadingStateListener),\n/* harmony export */   isPlasmicPrepass: () => (/* binding */ isPlasmicPrepass),\n/* harmony export */   useMutablePlasmicQueryData: () => (/* binding */ useMutablePlasmicQueryData),\n/* harmony export */   usePlasmicDataConfig: () => (/* binding */ usePlasmicDataConfig),\n/* harmony export */   usePlasmicQueryData: () => (/* binding */ usePlasmicQueryData),\n/* harmony export */   useSWRConfig: () => (/* reexport safe */ swr__WEBPACK_IMPORTED_MODULE_1__.useSWRConfig),\n/* harmony export */   wrapLoadingFetcher: () => (/* binding */ wrapLoadingFetcher)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var swr__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! swr */ \"(ssr)/./node_modules/swr/dist/index.mjs\");\n/* __next_internal_client_entry_do_not_use__ HeadMetadataContext,PlasmicPrepassContext,PlasmicQueryDataProvider,addLoadingStateListener,isPlasmicPrepass,useMutablePlasmicQueryData,usePlasmicDataConfig,usePlasmicQueryData,useSWRConfig,wrapLoadingFetcher auto */ var __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __spreadValues = (a, b)=>{\n    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){\n        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n    }\n    return a;\n};\nvar __async = (__this, __arguments, generator)=>{\n    return new Promise((resolve, reject)=>{\n        var fulfilled = (value)=>{\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        };\n        var rejected = (value)=>{\n            try {\n                step(generator.throw(value));\n            } catch (e) {\n                reject(e);\n            }\n        };\n        var step = (x)=>x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n        step((generator = generator.apply(__this, __arguments)).next());\n    });\n};\n// src/query-data.tsx\n\n\nvar __SWRConfig = void 0;\nvar mutateKeys = (invalidateKey)=>{\n    if (__SWRConfig) {\n        const { cache, mutate } = __SWRConfig;\n        (invalidateKey != null ? [\n            invalidateKey\n        ] : Array.from(cache.keys())).forEach((key)=>{\n            mutate(key);\n        });\n    }\n};\nfunction getPlasmicDefaultSWROptions(opts) {\n    return {\n        revalidateIfStale: !!(opts == null ? void 0 : opts.isMutable),\n        revalidateOnFocus: false,\n        revalidateOnReconnect: false\n    };\n}\nfunction usePlasmicQueryData(key, fetcher) {\n    const prepassCtx = react__WEBPACK_IMPORTED_MODULE_0___default().useContext(PrepassContext);\n    const opts = getPlasmicDefaultSWROptions();\n    if (prepassCtx) {\n        opts.suspense = true;\n    }\n    const config = (0,swr__WEBPACK_IMPORTED_MODULE_1__.useSWRConfig)();\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect({\n        \"usePlasmicQueryData.useEffect\": ()=>{\n            __SWRConfig = config;\n        }\n    }[\"usePlasmicQueryData.useEffect\"], [\n        config\n    ]);\n    const wrappedFetcher = react__WEBPACK_IMPORTED_MODULE_0___default().useMemo({\n        \"usePlasmicQueryData.useMemo[wrappedFetcher]\": ()=>wrapLoadingFetcher(fetcher)\n    }[\"usePlasmicQueryData.useMemo[wrappedFetcher]\"], [\n        fetcher\n    ]);\n    const resp = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(key, wrappedFetcher, opts);\n    if (resp.data !== void 0) {\n        return {\n            data: resp.data\n        };\n    } else if (resp.error) {\n        return {\n            error: resp.error\n        };\n    } else {\n        return {\n            isLoading: true\n        };\n    }\n}\nfunction useMutablePlasmicQueryData(key, fetcher, options) {\n    const prepassCtx = react__WEBPACK_IMPORTED_MODULE_0___default().useContext(PrepassContext);\n    const opts = __spreadValues(__spreadValues({}, getPlasmicDefaultSWROptions({\n        isMutable: true\n    })), options);\n    if (prepassCtx) {\n        opts.suspense = true;\n    }\n    const config = (0,swr__WEBPACK_IMPORTED_MODULE_1__.useSWRConfig)();\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect({\n        \"useMutablePlasmicQueryData.useEffect\": ()=>{\n            __SWRConfig = config;\n        }\n    }[\"useMutablePlasmicQueryData.useEffect\"], [\n        config\n    ]);\n    const [isLoading, setIsLoading] = react__WEBPACK_IMPORTED_MODULE_0___default().useState(false);\n    const fetcherWrapper = react__WEBPACK_IMPORTED_MODULE_0___default().useCallback({\n        \"useMutablePlasmicQueryData.useCallback[fetcherWrapper]\": (...args)=>__async(this, null, {\n                \"useMutablePlasmicQueryData.useCallback[fetcherWrapper]\": function*() {\n                    setIsLoading(true);\n                    try {\n                        return yield wrapLoadingFetcher(fetcher)(...args);\n                    } finally{\n                        setIsLoading(false);\n                    }\n                }\n            }[\"useMutablePlasmicQueryData.useCallback[fetcherWrapper]\"])\n    }[\"useMutablePlasmicQueryData.useCallback[fetcherWrapper]\"], [\n        fetcher\n    ]);\n    const laggyDataRef = react__WEBPACK_IMPORTED_MODULE_0___default().useRef();\n    const { isValidating, mutate, data, error } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(key, fetcherWrapper, opts);\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect({\n        \"useMutablePlasmicQueryData.useEffect\": ()=>{\n            if (data !== void 0) {\n                laggyDataRef.current = data;\n            }\n        }\n    }[\"useMutablePlasmicQueryData.useEffect\"], [\n        data\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0___default().useMemo({\n        \"useMutablePlasmicQueryData.useMemo\": ()=>__spreadValues(__spreadValues({\n                isValidating,\n                mutate,\n                isLoading: data === void 0 && error === void 0 || isLoading\n            }, data !== void 0 ? {\n                data\n            } : error === void 0 && laggyDataRef.current ? // Show previous data if available\n            {\n                data: laggyDataRef.current,\n                isLagging: true\n            } : {}), error !== void 0 ? {\n                error\n            } : {})\n    }[\"useMutablePlasmicQueryData.useMemo\"], [\n        isValidating,\n        mutate,\n        data,\n        error,\n        isLoading\n    ]);\n}\nfunction PlasmicQueryDataProvider(props) {\n    const { children, suspense, prefetchedCache } = props;\n    const prepass = react__WEBPACK_IMPORTED_MODULE_0___default().useContext(PrepassContext);\n    if (prepass) {\n        return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), null, children);\n    } else {\n        return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(swr__WEBPACK_IMPORTED_MODULE_1__.SWRConfig, {\n            value: {\n                fallback: prefetchedCache != null ? prefetchedCache : {},\n                suspense\n            }\n        }, children);\n    }\n}\nvar PrepassContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext(false);\nfunction PlasmicPrepassContext(props) {\n    const { cache, children } = props;\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(PrepassContext.Provider, {\n        value: true\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(swr__WEBPACK_IMPORTED_MODULE_1__.SWRConfig, {\n        value: {\n            provider: ()=>cache,\n            suspense: true,\n            fallback: {}\n        }\n    }, children));\n}\nvar usePlasmicDataConfig = swr__WEBPACK_IMPORTED_MODULE_1__.useSWRConfig;\nvar loadingCount = 0;\nvar listeners = [];\nfunction addLoadingStateListener(listener, opts) {\n    listeners.push(listener);\n    if (opts == null ? void 0 : opts.immediate) {\n        listener(loadingCount > 0);\n    }\n    return ()=>{\n        listeners.splice(listeners.indexOf(listener), 1);\n    };\n}\nfunction wrapLoadingFetcher(fetcher) {\n    return (...args)=>__async(this, null, function*() {\n            if (loadingCount === 0) {\n                listeners.forEach((listener)=>listener(true));\n            }\n            loadingCount += 1;\n            try {\n                const res = fetcher(...args);\n                return isPromiseLike(res) ? yield res : res;\n            } finally{\n                loadingCount -= 1;\n                if (loadingCount === 0) {\n                    listeners.forEach((listener)=>listener(false));\n                }\n            }\n        });\n}\nfunction isPromiseLike(x) {\n    return !!x && typeof x === \"object\" && \"then\" in x && typeof x.then === \"function\";\n}\nfunction isPlasmicPrepass() {\n    var _a, _b, _c;\n    return !!((_c = (_b = (_a = (react__WEBPACK_IMPORTED_MODULE_0___default().__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED)) == null ? void 0 : _a.ReactCurrentDispatcher) == null ? void 0 : _b.current) == null ? void 0 : _c.isPlasmicPrepass);\n}\nvar HeadMetadataContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext({});\n// src/index.tsx\n\nif (false) {}\n //# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBsYXNtaWNhcHAvcXVlcnkvZGlzdC9pbmRleC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXlDO0FBUWxDO0FBSVAsSUFBSSxjQUEyRDtBQUN4RCxJQUFNLGFBQWEsQ0FBQztJQUN6QixJQUFJLGFBQWE7UUFDZixNQUFNLEVBQUUsT0FBTyxPQUFPLElBQUk7U0FDekIsaUJBQWlCLE9BQ2Q7WUFBQyxhQUFhO1NBQUEsR0FDZCxNQUFNLEtBQU0sTUFBMkIsS0FBSyxFQUFDLEVBQy9DLFFBQVEsQ0FBQztZQUNULE9BQU8sR0FBRztRQUNaLENBQUM7SUFDSDtBQUNGO0FBSUEsU0FBUyw0QkFBNEIsTUFFaEI7SUFDbkIsT0FBTztRQUNMLG1CQUFtQixDQUFDLENBQUMsOEJBQU07UUFDM0IsbUJBQW1CO1FBQ25CLHVCQUF1QjtJQUN6QjtBQUNGO0FBWU8sU0FBUyxvQkFDZCxLQUNBLFNBQ2tEO0lBQ2xELE1BQU0sYUFBYSx1REFBTSxDQUFXLGNBQWM7SUFFbEQsTUFBTSxPQUFPLDRCQUE0QjtJQUN6QyxJQUFJLFlBQVk7UUFHZCxLQUFLLFdBQVc7SUFDbEI7SUFFQSxNQUFNLFNBQVMsaURBQVksQ0FBQztJQUM1QixzREFBTTt5Q0FBVTtZQUNkLGNBQWM7UUFDaEI7d0NBQUc7UUFBQyxNQUFNO0tBQUM7SUFFWCxNQUFNLGlCQUFpQixvREFBTTt1REFDM0IsSUFBTSxtQkFBbUIsT0FBTztzREFDaEM7UUFBQyxPQUFPO0tBQUE7SUFHVixNQUFNLE9BQU8sK0NBQU0sQ0FBQyxLQUFLLGdCQUFnQixJQUFJO0lBQzdDLElBQUksS0FBSyxTQUFTLFFBQVc7UUFDM0IsT0FBTztZQUFFLE1BQU0sS0FBSztRQUFLO0lBQzNCLFdBQVcsS0FBSyxPQUFPO1FBQ3JCLE9BQU87WUFBRSxPQUFPLEtBQUs7UUFBTTtJQUM3QixPQUFPO1FBQ0wsT0FBTztZQUFF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U0FBRTtnQkFDQSxnQkFBZ0I7Z0JBQ2hCLElBQUksaUJBQWlCLEdBQUc7b0JBQ3RCLFVBQVUsUUFBUSxDQUFDLFdBQWEsU0FBUyxLQUFLLENBQUM7Z0JBQ2pEO1lBQ0Y7UUFDRjtBQUNGO0FBRUEsU0FBUyxjQUFjLEdBQVE7SUFDN0IsT0FDRSxDQUFDLENBQUMsS0FBSyxPQUFPLE1BQU0sWUFBWSxVQUFVLEtBQUssT0FBTyxFQUFFLFNBQVM7QUFFckU7QUFFTyxTQUFTLG1CQUFtQjtJQWpRbkM7SUFrUUUsT0FBTyxDQUFDLEdBQUUsa0hBQWMsS0FBZCxtQkFDTiwyQkFETSxtQkFDa0IsWUFEbEIsbUJBQzJCO0FBQ3ZDO0FBU08sSUFBTSxvQ0FBc0IsMERBQU0sQ0FBNEIsQ0FBQyxDQUFDOztBQzVRMUM7QUFrQjdCLElBQUksS0FBNkIsRUFBRSxFQVNsQyIsInNvdXJjZXMiOlsiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvc3JjL3F1ZXJ5LWRhdGEudHN4IiwiL1VzZXJzL3dvbmRlcmxhbmRtaXRjaC9DYXNjYWRlUHJvamVjdHMvc3JjL2luZGV4LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgUHJvcHNXaXRoQ2hpbGRyZW4gfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB1c2VTV1IsIHtcbiAgRmV0Y2hlcixcbiAgS2V5LFxuICBTV1JDb25maWcsXG4gIFNXUkNvbmZpZ3VyYXRpb24sXG4gIFNXUlJlc3BvbnNlLFxuICB1c2VTV1JDb25maWcsXG59IGZyb20gXCJzd3JcIjtcblxuZXhwb3J0IHR5cGUgeyBTV1JSZXNwb25zZSB9IGZyb20gXCJzd3JcIjtcblxubGV0IF9fU1dSQ29uZmlnOiBSZXR1cm5UeXBlPHR5cGVvZiB1c2VTV1JDb25maWc+IHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuZXhwb3J0IGNvbnN0IG11dGF0ZUtleXMgPSAoaW52YWxpZGF0ZUtleT86IHN0cmluZykgPT4ge1xuICBpZiAoX19TV1JDb25maWcpIHtcbiAgICBjb25zdCB7IGNhY2hlLCBtdXRhdGUgfSA9IF9fU1dSQ29uZmlnO1xuICAgIChpbnZhbGlkYXRlS2V5ICE9IG51bGxcbiAgICAgID8gW2ludmFsaWRhdGVLZXldXG4gICAgICA6IEFycmF5LmZyb20oKGNhY2hlIGFzIE1hcDxzdHJpbmcsIGFueT4pLmtleXMoKSlcbiAgICApLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgbXV0YXRlKGtleSk7XG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIEBwbGFzbWljYXBwL3F1ZXJ5IGlzIG9wdGltaXplZCBmb3IgU1NSLCBzbyB3ZSBkbyBub3QgcmV2YWxpZGF0ZVxuLy8gYXV0b21hdGljYWxseSB1cG9uIGh5ZHJhdGlvbjsgYXMgaWYgdGhlIGRhdGEgaXMgaW1tdXRhYmxlLlxuZnVuY3Rpb24gZ2V0UGxhc21pY0RlZmF1bHRTV1JPcHRpb25zKG9wdHM/OiB7XG4gIGlzTXV0YWJsZT86IGJvb2xlYW47XG59KTogU1dSQ29uZmlndXJhdGlvbiB7XG4gIHJldHVybiB7XG4gICAgcmV2YWxpZGF0ZUlmU3RhbGU6ICEhb3B0cz8uaXNNdXRhYmxlLFxuICAgIHJldmFsaWRhdGVPbkZvY3VzOiBmYWxzZSxcbiAgICByZXZhbGlkYXRlT25SZWNvbm5lY3Q6IGZhbHNlLFxuICB9O1xufVxuXG4vKipcbiAqIEZldGNoZXMgZGF0YSBhc3luY2hyb25vdXNseS4gVGhpcyBkYXRhIHNob3VsZCBiZSBjb25zaWRlcmVkIGltbXV0YWJsZSBmb3IgdGhlXG4gKiBzZXNzaW9uIC0tIHRoZXJlIGlzIG5vIHdheSB0byBpbnZhbGlkYXRlIG9yIHJlLWZldGNoIHRoaXMgZGF0YS5cbiAqXG4gKiBAcGFyYW0ga2V5IGEgdW5pcXVlIGtleSBmb3IgdGhpcyBkYXRhIGZldGNoOyBpZiBkYXRhIGFscmVhZHkgZXhpc3RzIHVuZGVyIHRoaXNcbiAqICAga2V5LCB0aGF0IGRhdGEgaXMgcmV0dXJuZWQgaW1tZWRpYXRlbHkuXG4gKiBAcGFyYW0gZmV0Y2hlciBhbiBhc3luYyBmdW5jdGlvbiB0aGF0IHJlc29sdmVzIHRvIHRoZSBmZXRjaGVkIGRhdGEuXG4gKiBAcmV0dXJucyBhbiBvYmplY3Qgd2l0aCBlaXRoZXIgYSBcImRhdGFcIiBrZXkgd2l0aCB0aGUgZmV0Y2hlZCBkYXRhIGlmIHRoZSBmZXRjaFxuICogICB3YXMgc3VjY2Vzc2Z1bCwgb3IgYW4gXCJlcnJvclwiIGtleSB3aXRoIHRoZSB0aHJvd24gRXJyb3IgaWYgdGhlIGZldGNoIGZhaWxlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVBsYXNtaWNRdWVyeURhdGE8VD4oXG4gIGtleTogS2V5LFxuICBmZXRjaGVyOiBGZXRjaGVyPFQ+XG4pOiB7IGRhdGE/OiBUOyBlcnJvcj86IEVycm9yOyBpc0xvYWRpbmc/OiBib29sZWFuIH0ge1xuICBjb25zdCBwcmVwYXNzQ3R4ID0gUmVhY3QudXNlQ29udGV4dChQcmVwYXNzQ29udGV4dCk7XG5cbiAgY29uc3Qgb3B0cyA9IGdldFBsYXNtaWNEZWZhdWx0U1dST3B0aW9ucygpO1xuICBpZiAocHJlcGFzc0N0eCkge1xuICAgIC8vIElmIHdlJ3JlIGRvaW5nIHByZXBhc3MsIHRoZW4gd2UgYXJlIGFsd2F5cyBpbiBzdXNwZW5zZSBtb2RlLCBiZWNhdXNlXG4gICAgLy8gcmVhY3Qtc3NyLXByZXBhc3Mgb25seSB3b3JrcyB3aXRoIHN1c3BlbnNlLXRocm93aW5nIGRhdGEgZmV0Y2hpbmcuXG4gICAgb3B0cy5zdXNwZW5zZSA9IHRydWU7XG4gIH1cblxuICBjb25zdCBjb25maWcgPSB1c2VTV1JDb25maWcoKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBfX1NXUkNvbmZpZyA9IGNvbmZpZztcbiAgfSwgW2NvbmZpZ10pO1xuXG4gIGNvbnN0IHdyYXBwZWRGZXRjaGVyID0gUmVhY3QudXNlTWVtbyhcbiAgICAoKSA9PiB3cmFwTG9hZGluZ0ZldGNoZXIoZmV0Y2hlciksXG4gICAgW2ZldGNoZXJdXG4gICk7XG5cbiAgY29uc3QgcmVzcCA9IHVzZVNXUihrZXksIHdyYXBwZWRGZXRjaGVyLCBvcHRzKTtcbiAgaWYgKHJlc3AuZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHsgZGF0YTogcmVzcC5kYXRhIH07XG4gIH0gZWxzZSBpZiAocmVzcC5lcnJvcikge1xuICAgIHJldHVybiB7IGVycm9yOiByZXNwLmVycm9yIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHsgaXNMb2FkaW5nOiB0cnVlIH07XG4gIH1cbn1cblxuLyoqXG4gKiBGZXRjaGVzIGRhdGEgYXN5bmNocm9ub3VzbHkgdXNpbmcgU1dSIEhvb2sgKGh0dHBzOi8vc3dyLnZlcmNlbC5hcHAvKVxuICpcbiAqIEBwYXJhbSBrZXkgYSB1bmlxdWUga2V5IGZvciB0aGlzIGRhdGEgZmV0Y2g7IGlmIGRhdGEgYWxyZWFkeSBleGlzdHMgdW5kZXIgdGhpc1xuICogICBrZXksIHRoYXQgZGF0YSBpcyByZXR1cm5lZCBpbW1lZGlhdGVseS5cbiAqIEBwYXJhbSBmZXRjaGVyIGFuIGFzeW5jIGZ1bmN0aW9uIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGZldGNoZWQgZGF0YS5cbiAqIEBwYXJhbSBvcHRpb25zIChvcHRpb25hbCkgYW4gb2JqZWN0IG9mIG9wdGlvbnMgZm9yIHRoaXMgaG9vayAoaHR0cHM6Ly9zd3IudmVyY2VsLmFwcC9kb2NzL29wdGlvbnMpLlxuICogQHJldHVybnMgYW4gb2JqZWN0IHdpdGggZWl0aGVyIGEgXCJkYXRhXCIga2V5IHdpdGggdGhlIGZldGNoZWQgZGF0YSBpZiB0aGUgZmV0Y2hcbiAqICAgd2FzIHN1Y2Nlc3NmdWwsIG9yIGFuIFwiZXJyb3JcIiBrZXkgd2l0aCB0aGUgdGhyb3duIEVycm9yIGlmIHRoZSBmZXRjaCBmYWlsZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VNdXRhYmxlUGxhc21pY1F1ZXJ5RGF0YTxULCBFPihcbiAga2V5OiBLZXksXG4gIGZldGNoZXI6IEZldGNoZXI8VD4sXG4gIG9wdGlvbnM/OiBTV1JDb25maWd1cmF0aW9uPFQsIEU+XG4pOiBTV1JSZXNwb25zZTxULCBFPiAmIHsgaXNMb2FkaW5nPzogYm9vbGVhbjsgaXNMYWdnaW5nPzogYm9vbGVhbiB9IHtcbiAgY29uc3QgcHJlcGFzc0N0eCA9IFJlYWN0LnVzZUNvbnRleHQoUHJlcGFzc0NvbnRleHQpO1xuXG4gIGNvbnN0IG9wdHMgPSB7XG4gICAgLi4uZ2V0UGxhc21pY0RlZmF1bHRTV1JPcHRpb25zKHsgaXNNdXRhYmxlOiB0cnVlIH0pLFxuICAgIC4uLm9wdGlvbnMsXG4gIH07XG4gIGlmIChwcmVwYXNzQ3R4KSB7XG4gICAgb3B0cy5zdXNwZW5zZSA9IHRydWU7XG4gIH1cblxuICBjb25zdCBjb25maWcgPSB1c2VTV1JDb25maWcoKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBfX1NXUkNvbmZpZyA9IGNvbmZpZztcbiAgfSwgW2NvbmZpZ10pO1xuXG4gIGNvbnN0IFtpc0xvYWRpbmcsIHNldElzTG9hZGluZ10gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IGZldGNoZXJXcmFwcGVyID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKC4uLmFyZ3M6IGFueVtdKSA9PiB7XG4gICAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgd3JhcExvYWRpbmdGZXRjaGVyKGZldGNoZXIpKC4uLmFyZ3MpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFtmZXRjaGVyXVxuICApO1xuXG4gIC8vIEJhc2VkIG9uIGh0dHBzOi8vc3dyLnZlcmNlbC5hcHAvZG9jcy9taWRkbGV3YXJlI2tlZXAtcHJldmlvdXMtcmVzdWx0XG4gIGNvbnN0IGxhZ2d5RGF0YVJlZiA9IFJlYWN0LnVzZVJlZjxhbnk+KCk7XG5cbiAgY29uc3QgeyBpc1ZhbGlkYXRpbmcsIG11dGF0ZSwgZGF0YSwgZXJyb3IgfSA9IHVzZVNXUihcbiAgICBrZXksXG4gICAgZmV0Y2hlcldyYXBwZXIsXG4gICAgb3B0c1xuICApO1xuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbGFnZ3lEYXRhUmVmLmN1cnJlbnQgPSBkYXRhO1xuICAgIH1cbiAgfSwgW2RhdGFdKTtcblxuICByZXR1cm4gUmVhY3QudXNlTWVtbyhcbiAgICAoKSA9PiAoe1xuICAgICAgaXNWYWxpZGF0aW5nLFxuICAgICAgbXV0YXRlLFxuICAgICAgaXNMb2FkaW5nOiAoZGF0YSA9PT0gdW5kZWZpbmVkICYmIGVycm9yID09PSB1bmRlZmluZWQpIHx8IGlzTG9hZGluZyxcbiAgICAgIC4uLihkYXRhICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyB7IGRhdGEgfVxuICAgICAgICA6IGVycm9yID09PSB1bmRlZmluZWQgJiYgbGFnZ3lEYXRhUmVmLmN1cnJlbnRcbiAgICAgICAgPyAvLyBTaG93IHByZXZpb3VzIGRhdGEgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgeyBkYXRhOiBsYWdneURhdGFSZWYuY3VycmVudCwgaXNMYWdnaW5nOiB0cnVlIH1cbiAgICAgICAgOiB7fSksXG4gICAgICAuLi4oZXJyb3IgIT09IHVuZGVmaW5lZCA/IHsgZXJyb3IgfSA6IHt9KSxcbiAgICB9KSxcbiAgICBbaXNWYWxpZGF0aW5nLCBtdXRhdGUsIGRhdGEsIGVycm9yLCBpc0xvYWRpbmddXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBQbGFzbWljUXVlcnlEYXRhUHJvdmlkZXIocHJvcHM6IHtcbiAgc3VzcGVuc2U/OiBib29sZWFuO1xuICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlO1xuICBwcmVmZXRjaGVkQ2FjaGU/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xufSkge1xuICBjb25zdCB7IGNoaWxkcmVuLCBzdXNwZW5zZSwgcHJlZmV0Y2hlZENhY2hlIH0gPSBwcm9wcztcbiAgY29uc3QgcHJlcGFzcyA9IFJlYWN0LnVzZUNvbnRleHQoUHJlcGFzc0NvbnRleHQpO1xuICBpZiAocHJlcGFzcykge1xuICAgIC8vIElmIHdlJ3JlIGluIHByZXBhc3MsIHRoZW4gdGhlcmUncyBhbHJlYWR5IGEgd3JhcHBpZ24gU1dSQ29uZmlnO1xuICAgIC8vIGRvbid0IGludGVyZmVyZSB3aXRoIGl0LlxuICAgIHJldHVybiA8PntjaGlsZHJlbn08Lz47XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxTV1JDb25maWdcbiAgICAgICAgdmFsdWU9e3tcbiAgICAgICAgICBmYWxsYmFjazogcHJlZmV0Y2hlZENhY2hlID8/IHt9LFxuICAgICAgICAgIHN1c3BlbnNlLFxuICAgICAgICB9fVxuICAgICAgPlxuICAgICAgICB7Y2hpbGRyZW59XG4gICAgICA8L1NXUkNvbmZpZz5cbiAgICApO1xuICB9XG59XG5cbmNvbnN0IFByZXBhc3NDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dDxib29sZWFuPihmYWxzZSk7XG5cbmV4cG9ydCBmdW5jdGlvbiBQbGFzbWljUHJlcGFzc0NvbnRleHQoXG4gIHByb3BzOiBQcm9wc1dpdGhDaGlsZHJlbjx7XG4gICAgY2FjaGU6IE1hcDxzdHJpbmcsIGFueT47XG4gIH0+XG4pIHtcbiAgY29uc3QgeyBjYWNoZSwgY2hpbGRyZW4gfSA9IHByb3BzO1xuICByZXR1cm4gKFxuICAgIDxQcmVwYXNzQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17dHJ1ZX0+XG4gICAgICA8U1dSQ29uZmlnXG4gICAgICAgIHZhbHVlPXt7XG4gICAgICAgICAgcHJvdmlkZXI6ICgpID0+IGNhY2hlLFxuICAgICAgICAgIHN1c3BlbnNlOiB0cnVlLFxuICAgICAgICAgIGZhbGxiYWNrOiB7fSxcbiAgICAgICAgfX1cbiAgICAgID5cbiAgICAgICAge2NoaWxkcmVufVxuICAgICAgPC9TV1JDb25maWc+XG4gICAgPC9QcmVwYXNzQ29udGV4dC5Qcm92aWRlcj5cbiAgKTtcbn1cblxuZXhwb3J0IGNvbnN0IHVzZVBsYXNtaWNEYXRhQ29uZmlnOiB0eXBlb2YgdXNlU1dSQ29uZmlnID0gdXNlU1dSQ29uZmlnO1xuXG5sZXQgbG9hZGluZ0NvdW50ID0gMDtcbmV4cG9ydCB0eXBlIExvYWRpbmdTdGF0ZUxpc3RlbmVyID0gKGlzTG9hZGluZzogYm9vbGVhbikgPT4gdm9pZDtcbmNvbnN0IGxpc3RlbmVyczogTG9hZGluZ1N0YXRlTGlzdGVuZXJbXSA9IFtdO1xuXG4vKipcbiAqIFN1YnNjcmliZXMgdG8gd2hldGhlciBhbnkgbG9hZGluZyBpcyBoYXBwZW5pbmcgdmlhIEBwbGFzbWljYXBwL3F1ZXJ5LlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVuc3Vic2NyaWJlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkTG9hZGluZ1N0YXRlTGlzdGVuZXIoXG4gIGxpc3RlbmVyOiBMb2FkaW5nU3RhdGVMaXN0ZW5lcixcbiAgb3B0cz86IHsgaW1tZWRpYXRlPzogYm9vbGVhbiB9XG4pIHtcbiAgbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICBpZiAob3B0cz8uaW1tZWRpYXRlKSB7XG4gICAgbGlzdGVuZXIobG9hZGluZ0NvdW50ID4gMCk7XG4gIH1cbiAgcmV0dXJuICgpID0+IHtcbiAgICBsaXN0ZW5lcnMuc3BsaWNlKGxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKSwgMSk7XG4gIH07XG59XG5cbi8qKlxuICogSW5zdHJ1bWVudHMgYW4gYXN5bmMgZnVuY3Rpb24gdG8gaW5jcmVtZW50IGFuZCBkZWNyZW1lbnQgdGhlIG51bWJlciBvZlxuICogc2ltdWx0YW5lb3VzIGFzeW5jIGxvYWRzLiBZb3UgY2FuIHRoZW4gc3Vic2NyaWJlIHRvIHdoZXRoZXIgdGhlcmVcbiAqIGFyZSBhbnkgbG9hZHMgaGFwcGVuaW5nIHZpYSBhZGRMb2FkaW5nU3RhdGVMaXN0ZW5lcigpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gd3JhcExvYWRpbmdGZXRjaGVyPFxuICBUIGV4dGVuZHMgKC4uLmFyZ3M6IGFueVtdKSA9PiBQcm9taXNlPGFueT4gfCBhbnlcbj4oZmV0Y2hlcjogVCk6IFQge1xuICByZXR1cm4gKGFzeW5jICguLi5hcmdzOiBhbnkpID0+IHtcbiAgICBpZiAobG9hZGluZ0NvdW50ID09PSAwKSB7XG4gICAgICBsaXN0ZW5lcnMuZm9yRWFjaCgobGlzdGVuZXIpID0+IGxpc3RlbmVyKHRydWUpKTtcbiAgICB9XG4gICAgbG9hZGluZ0NvdW50ICs9IDE7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlcyA9IGZldGNoZXIoLi4uYXJncyk7XG4gICAgICByZXR1cm4gaXNQcm9taXNlTGlrZShyZXMpID8gYXdhaXQgcmVzIDogcmVzO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBsb2FkaW5nQ291bnQgLT0gMTtcbiAgICAgIGlmIChsb2FkaW5nQ291bnQgPT09IDApIHtcbiAgICAgICAgbGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKSA9PiBsaXN0ZW5lcihmYWxzZSkpO1xuICAgICAgfVxuICAgIH1cbiAgfSkgYXMgVDtcbn1cblxuZnVuY3Rpb24gaXNQcm9taXNlTGlrZSh4OiBhbnkpIHtcbiAgcmV0dXJuIChcbiAgICAhIXggJiYgdHlwZW9mIHggPT09IFwib2JqZWN0XCIgJiYgXCJ0aGVuXCIgaW4geCAmJiB0eXBlb2YgeC50aGVuID09PSBcImZ1bmN0aW9uXCJcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUGxhc21pY1ByZXBhc3MoKSB7XG4gIHJldHVybiAhIShSZWFjdCBhcyBhbnkpLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEXG4gICAgPy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyPy5jdXJyZW50Py5pc1BsYXNtaWNQcmVwYXNzO1xufVxuXG5leHBvcnQgdHlwZSBIZWFkTWV0YWRhdGEgPSB7XG4gIHRpdGxlPzogc3RyaW5nO1xuICBkZXNjcmlwdGlvbj86IHN0cmluZztcbiAgaW1hZ2U/OiBzdHJpbmc7XG4gIGNhbm9uaWNhbD86IHN0cmluZztcbn07XG5cbmV4cG9ydCBjb25zdCBIZWFkTWV0YWRhdGFDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dDxIZWFkTWV0YWRhdGE+KHt9KTtcbiIsImltcG9ydCB7IG11dGF0ZUtleXMgfSBmcm9tIFwiLi9xdWVyeS1kYXRhXCI7XG5leHBvcnQgeyB1c2VTV1JDb25maWcgfSBmcm9tIFwic3dyXCI7XG5leHBvcnQge1xuICBhZGRMb2FkaW5nU3RhdGVMaXN0ZW5lcixcbiAgSGVhZE1ldGFkYXRhQ29udGV4dCxcbiAgaXNQbGFzbWljUHJlcGFzcyxcbiAgUGxhc21pY1ByZXBhc3NDb250ZXh0LFxuICBQbGFzbWljUXVlcnlEYXRhUHJvdmlkZXIsXG4gIHVzZU11dGFibGVQbGFzbWljUXVlcnlEYXRhLFxuICB1c2VQbGFzbWljRGF0YUNvbmZpZyxcbiAgdXNlUGxhc21pY1F1ZXJ5RGF0YSxcbiAgd3JhcExvYWRpbmdGZXRjaGVyLFxufSBmcm9tIFwiLi9xdWVyeS1kYXRhXCI7XG5leHBvcnQgdHlwZSB7XG4gIEhlYWRNZXRhZGF0YSxcbiAgTG9hZGluZ1N0YXRlTGlzdGVuZXIsXG4gIFNXUlJlc3BvbnNlLFxufSBmcm9tIFwiLi9xdWVyeS1kYXRhXCI7XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIGNvbnN0IHJvb3QgPSB3aW5kb3cgYXMgYW55O1xuICBjb25zdCBtYXliZUV4aXN0aW5nTXV0YXRlQWxsS2V5cyA9IHJvb3QuX19TV1JNdXRhdGVBbGxLZXlzO1xuICByb290Ll9fU1dSTXV0YXRlQWxsS2V5cyA9IChpbnZhbGlkYXRlS2V5Pzogc3RyaW5nKSA9PiB7XG4gICAgbXV0YXRlS2V5cyhpbnZhbGlkYXRlS2V5KTtcbiAgICBpZiAodHlwZW9mIG1heWJlRXhpc3RpbmdNdXRhdGVBbGxLZXlzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIG1heWJlRXhpc3RpbmdNdXRhdGVBbGxLZXlzKGludmFsaWRhdGVLZXkpO1xuICAgIH1cbiAgfTtcbn1cbiJdLCJuYW1lcyI6WyJ1c2VTV1JDb25maWciXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@plasmicapp/query/dist/index.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@plasmicapp/react-ssr-prepass/dist/react-ssr-prepass.es.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@plasmicapp/react-ssr-prepass/dist/react-ssr-prepass.es.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ renderPrepass)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\nfunction _extends() {\n  return _extends = Object.assign ? Object.assign.bind() : function(n) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n      for (var r in t) {\n        ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n      }\n    }\n    return n;\n  }, _extends.apply(null, arguments);\n}\n\nvar Element = 60103;\n\nvar TransitionalElement = 60103;\n\nvar Portal = 60106;\n\nvar Fragment = 60107;\n\nvar StrictMode = 60108;\n\nvar Profiler = 60114;\n\nvar ContextProvider = 60109;\n\nvar ContextConsumer = undefined;\n\nvar Context = 60110;\n\nvar ConcurrentMode = 60111;\n\nvar ForwardRef = 60112;\n\nvar Suspense = 60113;\n\nvar Memo = 60115;\n\nvar Lazy = 60116;\n\nvar ClientReferenceTag = undefined;\n\nif (typeof Symbol === \"function\" && Symbol.for) {\n  var symbolFor = Symbol.for;\n  Element = symbolFor(\"react.element\");\n  TransitionalElement = symbolFor(\"react.transitional.element\");\n  Portal = symbolFor(\"react.portal\");\n  Fragment = symbolFor(\"react.fragment\");\n  StrictMode = symbolFor(\"react.strict_mode\");\n  Profiler = symbolFor(\"react.profiler\");\n  ContextProvider = symbolFor(\"react.provider\");\n  ContextConsumer = symbolFor(\"react.consumer\");\n  Context = symbolFor(\"react.context\");\n  ConcurrentMode = symbolFor(\"react.concurrent_mode\");\n  ForwardRef = symbolFor(\"react.forward_ref\");\n  Suspense = symbolFor(\"react.suspense\");\n  Memo = symbolFor(\"react.memo\");\n  Lazy = symbolFor(\"react.lazy\");\n  ClientReferenceTag = symbolFor(\"react.client.reference\");\n}\n\nvar REACT_ELEMENT_TYPE = Element;\n\nvar REACT_TRANSITIONAL_ELEMENT_TYPE = TransitionalElement;\n\nvar REACT_PORTAL_TYPE = Portal;\n\nvar REACT_FRAGMENT_TYPE = Fragment;\n\nvar REACT_STRICT_MODE_TYPE = StrictMode;\n\nvar REACT_PROFILER_TYPE = Profiler;\n\nvar REACT_PROVIDER_TYPE = ContextProvider;\n\nvar REACT_CONSUMER_TYPE = ContextConsumer;\n\nvar REACT_CONTEXT_TYPE = Context;\n\nvar REACT_CONCURRENT_MODE_TYPE = ConcurrentMode;\n\nvar REACT_FORWARD_REF_TYPE = ForwardRef;\n\nvar REACT_SUSPENSE_TYPE = Suspense;\n\nvar REACT_MEMO_TYPE = Memo;\n\nvar REACT_LAZY_TYPE = Lazy;\n\nvar CLIENT_REFERENCE_TAG = ClientReferenceTag;\n\nfunction isClientReference(reference) {\n  return reference.$$typeof === CLIENT_REFERENCE_TAG;\n}\n\nvar getComponentName = function(type) {\n  if (isClientReference(type)) {\n    return undefined;\n  }\n  if (type.displayName) {\n    return type.displayName;\n  }\n  if (shouldConstruct(type)) {\n    return type.constructor.name;\n  } else {\n    return type.name;\n  }\n};\n\nfunction isReact19() {\n  return !(react__WEBPACK_IMPORTED_MODULE_0___default().__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED);\n}\n\nvar shouldConstruct = function(Comp) {\n  return Comp.prototype && Comp.prototype.isReactComponent;\n};\n\nvar typeOf = function(x) {\n  switch (x.$$typeof) {\n   case REACT_PORTAL_TYPE:\n    return REACT_PORTAL_TYPE;\n\n   case REACT_ELEMENT_TYPE:\n   case REACT_TRANSITIONAL_ELEMENT_TYPE:\n    switch (x.type) {\n     case REACT_CONCURRENT_MODE_TYPE:\n      return REACT_CONCURRENT_MODE_TYPE;\n\n     case REACT_FRAGMENT_TYPE:\n      return REACT_FRAGMENT_TYPE;\n\n     case REACT_PROFILER_TYPE:\n      return REACT_PROFILER_TYPE;\n\n     case REACT_STRICT_MODE_TYPE:\n      return REACT_STRICT_MODE_TYPE;\n\n     case REACT_SUSPENSE_TYPE:\n      return REACT_SUSPENSE_TYPE;\n\n     default:\n      {\n        switch (x.type && x.type.$$typeof) {\n         case REACT_LAZY_TYPE:\n          return REACT_LAZY_TYPE;\n\n         case REACT_MEMO_TYPE:\n          return REACT_MEMO_TYPE;\n\n         case REACT_CONSUMER_TYPE:\n          return REACT_CONSUMER_TYPE;\n\n         case REACT_CONTEXT_TYPE:\n          return isReact19() ? REACT_PROVIDER_TYPE : REACT_CONSUMER_TYPE;\n\n         case REACT_PROVIDER_TYPE:\n          return REACT_PROVIDER_TYPE;\n\n         case REACT_FORWARD_REF_TYPE:\n          return REACT_FORWARD_REF_TYPE;\n\n         default:\n          return REACT_ELEMENT_TYPE;\n        }\n      }\n    }\n\n   default:\n    return undefined;\n  }\n};\n\nvar toArray = react__WEBPACK_IMPORTED_MODULE_0__.Children.toArray;\n\nvar isAbstractElement = function(node) {\n  return node !== null && typeof node === \"object\";\n};\n\nvar getChildrenArray = function(node) {\n  return toArray(node).filter(isAbstractElement);\n};\n\nvar computeProps = function(props, defaultProps) {\n  return typeof defaultProps === \"object\" ? _extends({}, defaultProps, props) : props;\n};\n\nvar currentContextStore = new Map;\n\nvar currentContextMap = {};\n\nvar prevContextMap = undefined;\n\nvar prevContextEntry = undefined;\n\nvar getCurrentContextMap = function() {\n  return _extends({}, currentContextMap);\n};\n\nvar getCurrentContextStore = function() {\n  return new Map(currentContextStore);\n};\n\nvar flushPrevContextMap = function() {\n  var prev = prevContextMap;\n  prevContextMap = undefined;\n  return prev;\n};\n\nvar flushPrevContextStore = function() {\n  var prev = prevContextEntry;\n  prevContextEntry = undefined;\n  return prev;\n};\n\nvar restoreContextMap = function(prev) {\n  if (prev !== undefined) {\n    _extends(currentContextMap, prev);\n  }\n};\n\nvar restoreContextStore = function(prev) {\n  if (prev !== undefined) {\n    currentContextStore.set(prev[0], prev[1]);\n  }\n};\n\nvar setCurrentContextMap = function(map) {\n  prevContextMap = undefined;\n  currentContextMap = map;\n};\n\nvar setCurrentContextStore = function(store) {\n  prevContextEntry = undefined;\n  currentContextStore = store;\n};\n\nvar assignContextMap = function(map) {\n  prevContextMap = {};\n  for (var name in map) {\n    prevContextMap[name] = currentContextMap[name];\n    currentContextMap[name] = map[name];\n  }\n};\n\nvar setContextValue = function(context, value) {\n  prevContextEntry = [ context, currentContextStore.get(context) ];\n  currentContextStore.set(context, value);\n};\n\nvar readContextValue = function(context) {\n  var value = currentContextStore.get(context);\n  if (value !== undefined) {\n    return value;\n  }\n  return context._currentValue;\n};\n\nvar emptyContext = {};\n\nvar maskContext = function(type) {\n  var contextType = type.contextType;\n  var contextTypes = type.contextTypes;\n  if (contextType) {\n    return readContextValue(contextType);\n  } else if (!contextTypes) {\n    return emptyContext;\n  }\n  var maskedContext = {};\n  for (var name in contextTypes) {\n    maskedContext[name] = currentContextMap[name];\n  }\n  return maskedContext;\n};\n\nvar currentErrorFrame = null;\n\nvar getCurrentErrorFrame = function() {\n  return currentErrorFrame;\n};\n\nvar setCurrentErrorFrame = function(frame) {\n  currentErrorFrame = frame || null;\n};\n\nvar rendererStateRef = {\n  current: {\n    uniqueID: 0\n  }\n};\n\nvar initRendererState = function() {\n  return rendererStateRef.current = {\n    uniqueID: 0\n  };\n};\n\nvar setCurrentRendererState = function(state) {\n  return rendererStateRef.current = state;\n};\n\nfunction is(x, y) {\n  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;\n}\n\nvar objectIs = typeof Object.is === \"function\" ? Object.is : is;\n\nvar is$1 = objectIs;\n\nvar currentIdentity = null;\n\nvar makeIdentity = function() {\n  return {};\n};\n\nvar setCurrentIdentity = function(id) {\n  currentIdentity = id;\n};\n\nvar getCurrentIdentity = function() {\n  if (currentIdentity === null) {\n    throw new Error(\"[react-ssr-prepass] Hooks can only be called inside the body of a function component. \" + \"(https://fb.me/react-invalid-hook-call)\");\n  }\n  return currentIdentity;\n};\n\nvar firstWorkInProgressHook = null;\n\nvar workInProgressHook = null;\n\nvar didScheduleRenderPhaseUpdate = false;\n\nvar renderPhaseUpdates = null;\n\nvar numberOfReRenders = 0;\n\nvar RE_RENDER_LIMIT$1 = 25;\n\nvar getFirstHook = function() {\n  return firstWorkInProgressHook;\n};\n\nvar setFirstHook = function(hook) {\n  firstWorkInProgressHook = hook;\n};\n\nfunction areHookInputsEqual(nextDeps, prevDeps) {\n  if (prevDeps === null) {\n    return false;\n  }\n  for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) {\n    if (!is$1(nextDeps[i], prevDeps[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction createHook() {\n  return {\n    memoizedState: null,\n    queue: null,\n    next: null\n  };\n}\n\nfunction createWorkInProgressHook() {\n  if (workInProgressHook === null) {\n    if (firstWorkInProgressHook === null) {\n      return firstWorkInProgressHook = workInProgressHook = createHook();\n    } else {\n      return workInProgressHook = firstWorkInProgressHook;\n    }\n  } else {\n    if (workInProgressHook.next === null) {\n      return workInProgressHook = workInProgressHook.next = createHook();\n    } else {\n      return workInProgressHook = workInProgressHook.next;\n    }\n  }\n}\n\nfunction renderWithHooks(Component, props, refOrContext) {\n  workInProgressHook = null;\n  var children = Component(props, refOrContext);\n  while (numberOfReRenders < RE_RENDER_LIMIT$1 && didScheduleRenderPhaseUpdate) {\n    didScheduleRenderPhaseUpdate = false;\n    numberOfReRenders += 1;\n    workInProgressHook = null;\n    children = Component(props, refOrContext);\n  }\n  numberOfReRenders = 0;\n  renderPhaseUpdates = null;\n  workInProgressHook = null;\n  return children;\n}\n\nfunction readContext(context, _) {\n  return readContextValue(context);\n}\n\nfunction useContext(context, _) {\n  getCurrentIdentity();\n  return readContextValue(context);\n}\n\nfunction basicStateReducer(state, action) {\n  return typeof action === \"function\" ? action(state) : action;\n}\n\nfunction useState(initialState) {\n  return useReducer(basicStateReducer, initialState);\n}\n\nfunction useReducer(reducer, initialArg, init) {\n  var id = getCurrentIdentity();\n  workInProgressHook = createWorkInProgressHook();\n  if (workInProgressHook.queue === null) {\n    var initialState;\n    if (reducer === basicStateReducer) {\n      initialState = typeof initialArg === \"function\" ? initialArg() : initialArg;\n    } else {\n      initialState = init !== undefined ? init(initialArg) : initialArg;\n    }\n    workInProgressHook.memoizedState = initialState;\n  }\n  var queue = workInProgressHook.queue || (workInProgressHook.queue = {\n    last: null,\n    dispatch: null\n  });\n  var dispatch = queue.dispatch || (queue.dispatch = dispatchAction.bind(null, id, queue));\n  if (renderPhaseUpdates !== null) {\n    var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);\n    if (firstRenderPhaseUpdate !== undefined) {\n      renderPhaseUpdates.delete(queue);\n      var newState = workInProgressHook.memoizedState;\n      var update = firstRenderPhaseUpdate;\n      do {\n        var action = update.action;\n        newState = reducer(newState, action);\n        update = update.next;\n      } while (update !== null);\n      workInProgressHook.memoizedState = newState;\n    }\n  }\n  return [ workInProgressHook.memoizedState, dispatch ];\n}\n\nfunction useMemo(nextCreate, deps) {\n  getCurrentIdentity();\n  workInProgressHook = createWorkInProgressHook();\n  var nextDeps = deps === undefined ? null : deps;\n  var prevState = workInProgressHook.memoizedState;\n  if (prevState !== null && nextDeps !== null) {\n    var prevDeps = prevState[1];\n    if (areHookInputsEqual(nextDeps, prevDeps)) {\n      return prevState[0];\n    }\n  }\n  var nextValue = nextCreate();\n  workInProgressHook.memoizedState = [ nextValue, nextDeps ];\n  return nextValue;\n}\n\nfunction useRef(initialValue) {\n  getCurrentIdentity();\n  workInProgressHook = createWorkInProgressHook();\n  var previousRef = workInProgressHook.memoizedState;\n  if (previousRef === null) {\n    var ref = {\n      current: initialValue\n    };\n    workInProgressHook.memoizedState = ref;\n    return ref;\n  } else {\n    return previousRef;\n  }\n}\n\nfunction useOpaqueIdentifier() {\n  getCurrentIdentity();\n  workInProgressHook = createWorkInProgressHook();\n  if (!workInProgressHook.memoizedState) {\n    workInProgressHook.memoizedState = \"R:\" + (rendererStateRef.current.uniqueID++).toString(36);\n  }\n  return workInProgressHook.memoizedState;\n}\n\nfunction dispatchAction(componentIdentity, queue, action) {\n  if (componentIdentity === currentIdentity) {\n    didScheduleRenderPhaseUpdate = true;\n    var update = {\n      action: action,\n      next: null\n    };\n    if (renderPhaseUpdates === null) {\n      renderPhaseUpdates = new Map;\n    }\n    var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);\n    if (firstRenderPhaseUpdate === undefined) {\n      renderPhaseUpdates.set(queue, update);\n    } else {\n      var lastRenderPhaseUpdate = firstRenderPhaseUpdate;\n      while (lastRenderPhaseUpdate.next !== null) {\n        lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;\n      }\n      lastRenderPhaseUpdate.next = update;\n    }\n  }\n}\n\nfunction useCallback(callback, deps) {\n  return useMemo((function() {\n    return callback;\n  }), deps);\n}\n\nfunction useMutableSource(source, getSnapshot, _subscribe) {\n  getCurrentIdentity();\n  return getSnapshot(source._source);\n}\n\nfunction noop() {}\n\nfunction _ref$3(callback) {\n  callback();\n}\n\nfunction useTransition() {\n  var startTransition = _ref$3;\n  return [ startTransition, false ];\n}\n\nfunction useDeferredValue(input) {\n  return input;\n}\n\nfunction useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n  return getSnapshot();\n}\n\nvar Dispatcher = {\n  readContext: readContext,\n  useSyncExternalStore: useSyncExternalStore,\n  useContext: useContext,\n  useMemo: useMemo,\n  useReducer: useReducer,\n  useRef: useRef,\n  useState: useState,\n  useCallback: useCallback,\n  useMutableSource: useMutableSource,\n  useTransition: useTransition,\n  useDeferredValue: useDeferredValue,\n  useOpaqueIdentifier: useOpaqueIdentifier,\n  useId: useOpaqueIdentifier,\n  unstable_useId: useOpaqueIdentifier,\n  unstable_useOpaqueIdentifier: useOpaqueIdentifier,\n  useLayoutEffect: noop,\n  useImperativeHandle: noop,\n  useEffect: noop,\n  useDebugValue: noop,\n  useInsertionEffect: noop,\n  isPlasmicPrepass: true\n};\n\nvar resolve = function(type) {\n  var payload = type._payload || type;\n  if (payload._status === 0) {\n    return payload._result;\n  } else if (payload._status === 1) {\n    return Promise.resolve(payload._result);\n  } else if (payload._status === 2) {\n    return Promise.reject(payload._result);\n  }\n  payload._status = 0;\n  return payload._result = (payload._ctor || payload._result)().then((function(Component) {\n    payload._result = Component;\n    if (typeof Component === \"function\") {\n      payload._status = 1;\n    } else if (Component !== null && typeof Component === \"object\" && typeof Component.default === \"function\") {\n      payload._result = Component.default;\n      payload._status = 1;\n    } else {\n      payload._status = 2;\n    }\n  })).catch((function(error) {\n    payload._status = 2;\n    payload._result = error;\n    return Promise.reject(error);\n  }));\n};\n\nvar makeFrame$2 = function(type, props, thenable) {\n  return {\n    kind: \"frame.lazy\",\n    contextMap: getCurrentContextMap(),\n    contextStore: getCurrentContextStore(),\n    errorFrame: getCurrentErrorFrame(),\n    thenable: thenable,\n    props: props,\n    type: type\n  };\n};\n\nvar render$4 = function(type, props, queue) {\n  var payload = type._payload || type;\n  if (payload._status === 1 && payload._result) {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(payload._result, props);\n  }\n  try {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(type._init(type._payload), props);\n  } catch (err) {\n    if (!!err && typeof err.then === \"function\") {\n      queue.push(makeFrame$2(type, props, err));\n    }\n    return null;\n  }\n};\n\nvar mount$3 = function(type, props, queue) {\n  var payload = type._payload || type;\n  if (payload._status != null && payload._status <= 0) {\n    queue.push(makeFrame$2(type, props, resolve(type)));\n    return null;\n  }\n  return render$4(type, props, queue);\n};\n\nvar update$4 = function(queue, frame) {\n  setCurrentIdentity(null);\n  setCurrentContextMap(frame.contextMap);\n  setCurrentContextStore(frame.contextStore);\n  setCurrentErrorFrame(frame.errorFrame);\n  return render$4(frame.type, frame.props, queue);\n};\n\nvar makeFrame$1 = function(type, props, thenable) {\n  return {\n    contextMap: getCurrentContextMap(),\n    contextStore: getCurrentContextStore(),\n    id: getCurrentIdentity(),\n    hook: getFirstHook(),\n    kind: \"frame.hooks\",\n    errorFrame: getCurrentErrorFrame(),\n    thenable: thenable,\n    props: props,\n    type: type\n  };\n};\n\nvar render$3 = function(type, props, queue) {\n  try {\n    return renderWithHooks(type, computeProps(props, type.defaultProps), maskContext(type));\n  } catch (error) {\n    if (typeof error.then !== \"function\") {\n      console.warn(\"PLASMIC: Encountered error when pre-rendering \" + getComponentName(type) + \": \" + error);\n      return null;\n    }\n    queue.push(makeFrame$1(type, props, error));\n    return null;\n  }\n};\n\nvar mount$2 = function(type, props, queue, visitor, element) {\n  setFirstHook(null);\n  setCurrentIdentity(makeIdentity());\n  var promise = visitor(element);\n  if (promise) {\n    queue.push(makeFrame$1(type, props, promise));\n    return null;\n  }\n  return render$3(type, props, queue);\n};\n\nvar update$3 = function(queue, frame) {\n  setFirstHook(frame.hook);\n  setCurrentIdentity(frame.id);\n  setCurrentContextMap(frame.contextMap);\n  setCurrentContextStore(frame.contextStore);\n  setCurrentErrorFrame(frame.errorFrame);\n  return render$3(frame.type, frame.props, queue);\n};\n\nvar RE_RENDER_LIMIT = 25;\n\nfunction _ref$2() {\n  return false;\n}\n\nfunction _ref2$1() {\n  return null;\n}\n\nvar createUpdater = function() {\n  var queue = [];\n  return {\n    _thrown: 0,\n    queue: queue,\n    isMounted: _ref$2,\n    enqueueForceUpdate: _ref2$1,\n    enqueueReplaceState: function(instance, completeState) {\n      if (instance._isMounted) {\n        queue.length = 0;\n        queue.push(completeState);\n      }\n    },\n    enqueueSetState: function(instance, currentPartialState) {\n      if (instance._isMounted) {\n        queue.push(currentPartialState);\n      }\n    }\n  };\n};\n\nvar flushEnqueuedState = function(instance) {\n  var queue = instance.updater.queue;\n  if (queue.length > 0) {\n    var nextState = _extends({}, instance.state);\n    for (var i = 0, l = queue.length; i < l; i++) {\n      var partial = queue[i];\n      var partialState = typeof partial === \"function\" ? partial.call(instance, nextState, instance.props, instance.context) : partial;\n      if (partialState !== null) {\n        _extends(nextState, partialState);\n      }\n    }\n    instance.state = nextState;\n    queue.length = 0;\n  }\n};\n\nvar createInstance = function(type, props) {\n  var updater = createUpdater();\n  var computedProps = computeProps(props, type.defaultProps);\n  var context = maskContext(type);\n  var instance = new type(computedProps, context, updater);\n  instance.props = computedProps;\n  instance.context = context;\n  instance.updater = updater;\n  instance._isMounted = true;\n  if (instance.state === undefined) {\n    instance.state = null;\n  }\n  if (typeof instance.componentDidCatch === \"function\" || typeof type.getDerivedStateFromError === \"function\") {\n    var frame = makeFrame(type, instance, null);\n    frame.errorFrame = frame;\n    setCurrentErrorFrame(frame);\n  }\n  if (typeof type.getDerivedStateFromProps === \"function\") {\n    var getDerivedStateFromProps = type.getDerivedStateFromProps;\n    var state = getDerivedStateFromProps(instance.props, instance.state);\n    if (state !== null && state !== undefined) {\n      instance.state = _extends({}, instance.state, state);\n    }\n  } else if (typeof instance.componentWillMount === \"function\") {\n    instance.componentWillMount();\n  } else if (typeof instance.UNSAFE_componentWillMount === \"function\") {\n    instance.UNSAFE_componentWillMount();\n  }\n  return instance;\n};\n\nvar makeFrame = function(type, instance, thenable) {\n  return {\n    contextMap: getCurrentContextMap(),\n    contextStore: getCurrentContextStore(),\n    errorFrame: getCurrentErrorFrame(),\n    thenable: thenable,\n    kind: \"frame.class\",\n    error: null,\n    instance: instance,\n    type: type\n  };\n};\n\nvar render$2 = function(type, instance, queue) {\n  flushEnqueuedState(instance);\n  var child = null;\n  try {\n    child = instance.render();\n  } catch (error) {\n    if (typeof error.then !== \"function\") {\n      console.warn(\"PLASMIC: Encountered error when pre-rendering component \" + getComponentName(type) + \". This is fine as long as you are not fetching data with @plasmicapp/query inside this component.  Error: \" + error);\n      return null;\n    }\n    queue.push(makeFrame(type, instance, error));\n    return null;\n  }\n  if (type.childContextTypes !== undefined && typeof instance.getChildContext === \"function\") {\n    var childContext = instance.getChildContext();\n    if (childContext !== null && typeof childContext === \"object\") {\n      assignContextMap(childContext);\n    }\n  }\n  if (typeof instance.getDerivedStateFromProps !== \"function\" && (typeof instance.componentWillMount === \"function\" || typeof instance.UNSAFE_componentWillMount === \"function\") && typeof instance.componentWillUnmount === \"function\") {\n    try {\n      instance.componentWillUnmount();\n    } catch (_err) {}\n  }\n  instance._isMounted = false;\n  return child;\n};\n\nvar mount$1 = function(type, props, queue, visitor, element) {\n  setCurrentIdentity(null);\n  var instance = createInstance(type, props);\n  var promise = visitor(element, instance);\n  if (promise) {\n    queue.push(makeFrame(type, instance, promise));\n    return null;\n  }\n  return render$2(type, instance, queue);\n};\n\nvar update$2 = function(queue, frame) {\n  setCurrentIdentity(null);\n  setCurrentContextMap(frame.contextMap);\n  setCurrentContextStore(frame.contextStore);\n  setCurrentErrorFrame(frame.errorFrame);\n  if (frame.error) {\n    if (++frame.instance.updater._thrown >= RE_RENDER_LIMIT) {\n      return null;\n    }\n    frame.instance._isMounted = true;\n    if (typeof frame.instance.componentDidCatch === \"function\") {\n      frame.instance.componentDidCatch(frame.error);\n    }\n    if (typeof frame.type.getDerivedStateFromError === \"function\") {\n      frame.instance.updater.enqueueSetState(frame.instance, frame.type.getDerivedStateFromError(frame.error));\n    }\n  }\n  return render$2(frame.type, frame.instance, queue);\n};\n\nfunction _ref$1(elt) {\n  return elt && typeof elt === \"object\" && typeOf(elt);\n}\n\nvar render$1 = function(type, props, queue, clientRefVisitor, element) {\n  try {\n    var node = clientRefVisitor(element);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), {}, [].concat(node ? getChildrenArray(node) : Object.values(props).flat(Infinity).filter(_ref$1)));\n  } catch (error) {\n    if (typeof error.then !== \"function\") {\n      console.warn(\"PLASMIC: Encountered error when pre-rendering client reference: \" + error);\n      return null;\n    }\n    queue.push({\n      contextMap: getCurrentContextMap(),\n      contextStore: getCurrentContextStore(),\n      errorFrame: getCurrentErrorFrame(),\n      id: getCurrentIdentity(),\n      hook: getFirstHook(),\n      thenable: error,\n      kind: \"client-ref\",\n      type: type,\n      props: props,\n      element: element,\n      clientRefVisitor: clientRefVisitor\n    });\n    return null;\n  }\n};\n\nvar mount = function(type, props, queue, clientRefVisitor, element) {\n  setFirstHook(null);\n  setCurrentIdentity(makeIdentity());\n  return render$1(type, props, queue, clientRefVisitor, element);\n};\n\nvar update$1 = function(queue, frame) {\n  setFirstHook(frame.hook);\n  setCurrentIdentity(frame.id);\n  setCurrentContextMap(frame.contextMap);\n  setCurrentContextStore(frame.contextStore);\n  setCurrentErrorFrame(frame.errorFrame);\n  return render$1(frame.type, frame.props, queue, frame.clientRefVisitor, frame.element);\n};\n\nvar REACT_INTERNALS = (react__WEBPACK_IMPORTED_MODULE_0___default().__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) || (react__WEBPACK_IMPORTED_MODULE_0___default().__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE) || (react__WEBPACK_IMPORTED_MODULE_0___default().__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE);\n\nvar ReactCurrentDispatcher = REACT_INTERNALS.ReactCurrentDispatcher || REACT_INTERNALS;\n\nvar getReactCurrentDispatcher = function() {\n  return ReactCurrentDispatcher.current || ReactCurrentDispatcher.H;\n};\n\nvar injectReactCurrentDispatcher = function(newDispatcher) {\n  if (!isReact19()) {\n    ReactCurrentDispatcher.current = newDispatcher;\n  } else {\n    ReactCurrentDispatcher.H = newDispatcher;\n  }\n};\n\nvar SHOULD_YIELD = typeof setImmediate === \"function\";\n\nvar YIELD_AFTER_MS = 5;\n\nvar render = function(type, props, queue, visitor, clientRefVisitor, element) {\n  if (isClientReference(type)) {\n    return mount(type, props, queue, clientRefVisitor, element);\n  }\n  return shouldConstruct(type) ? mount$1(type, props, queue, visitor, element) : mount$2(type, props, queue, visitor, element);\n};\n\nvar visitElement = function(element, queue, visitor, clientRefVisitor) {\n  switch (typeOf(element)) {\n   case REACT_SUSPENSE_TYPE:\n   case REACT_STRICT_MODE_TYPE:\n   case REACT_CONCURRENT_MODE_TYPE:\n   case REACT_PROFILER_TYPE:\n   case REACT_FRAGMENT_TYPE:\n    {\n      var fragmentElement = element;\n      return getChildrenArray(fragmentElement.props.children);\n    }\n\n   case REACT_PROVIDER_TYPE:\n    {\n      var providerElement = element;\n      var ref = providerElement.props;\n      var value = ref.value;\n      var children = ref.children;\n      var type = providerElement.type;\n      var context = typeof type._context === \"object\" ? type._context : type;\n      setContextValue(context, value);\n      return getChildrenArray(children);\n    }\n\n   case REACT_CONSUMER_TYPE:\n    {\n      var consumerElement = element;\n      var ref$1 = consumerElement.props;\n      var children$1 = ref$1.children;\n      if (typeof children$1 === \"function\") {\n        var type$1 = consumerElement.type;\n        var context$1 = typeof type$1._context === \"object\" ? type$1._context : type$1;\n        var value$1 = readContextValue(context$1);\n        return getChildrenArray(children$1(value$1));\n      } else {\n        return [];\n      }\n    }\n\n   case REACT_LAZY_TYPE:\n    {\n      var lazyElement = element;\n      var type$2 = lazyElement.type;\n      var child = mount$3(type$2, lazyElement.props, queue);\n      return getChildrenArray(child);\n    }\n\n   case REACT_MEMO_TYPE:\n    {\n      var memoElement = element;\n      var ref$2 = memoElement.type;\n      var type$3 = ref$2.type;\n      var child$1 = (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(type$3, memoElement.props);\n      return getChildrenArray(child$1);\n    }\n\n   case REACT_FORWARD_REF_TYPE:\n    {\n      var refElement = element;\n      var ref$3 = refElement.type;\n      var type$4 = ref$3.render;\n      var defaultProps = ref$3.defaultProps;\n      var props = computeProps(refElement.props, defaultProps);\n      var child$2 = (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(type$4, props);\n      return getChildrenArray(child$2);\n    }\n\n   case REACT_ELEMENT_TYPE:\n    {\n      var el = element;\n      if (typeof el.type === \"string\") {\n        return getChildrenArray(el.props.children);\n      } else {\n        var userElement = element;\n        var type$5 = userElement.type;\n        var props$1 = userElement.props;\n        var child$3 = render(type$5, props$1, queue, visitor, clientRefVisitor, userElement);\n        return getChildrenArray(child$3);\n      }\n    }\n\n   case REACT_PORTAL_TYPE:\n   default:\n    return [];\n  }\n};\n\nvar visitLoop = function(traversalChildren, traversalMap, traversalStore, traversalErrorFrame, queue, visitor, clientRefVisitor) {\n  var prevDispatcher = getReactCurrentDispatcher();\n  var start = Date.now();\n  try {\n    injectReactCurrentDispatcher(Dispatcher);\n    while (traversalChildren.length > 0) {\n      var element = traversalChildren[traversalChildren.length - 1].shift();\n      if (element !== undefined) {\n        var children = visitElement(element, queue, visitor, clientRefVisitor);\n        traversalChildren.push(children);\n        traversalMap.push(flushPrevContextMap());\n        traversalStore.push(flushPrevContextStore());\n        traversalErrorFrame.push(getCurrentErrorFrame());\n      } else {\n        traversalChildren.pop();\n        restoreContextMap(traversalMap.pop());\n        restoreContextStore(traversalStore.pop());\n        setCurrentErrorFrame(traversalErrorFrame.pop());\n      }\n      if (SHOULD_YIELD && Date.now() - start > YIELD_AFTER_MS) {\n        return true;\n      }\n    }\n    return false;\n  } catch (error) {\n    var errorFrame = getCurrentErrorFrame();\n    if (!errorFrame) {\n      throw error;\n    }\n    errorFrame.error = error;\n    queue.unshift(errorFrame);\n    return false;\n  } finally {\n    injectReactCurrentDispatcher(prevDispatcher);\n  }\n};\n\nvar makeYieldFrame = function(traversalChildren, traversalMap, traversalStore, traversalErrorFrame) {\n  return {\n    contextMap: getCurrentContextMap(),\n    contextStore: getCurrentContextStore(),\n    errorFrame: getCurrentErrorFrame(),\n    thenable: null,\n    kind: \"frame.yield\",\n    traversalChildren: traversalChildren,\n    traversalMap: traversalMap,\n    traversalStore: traversalStore,\n    traversalErrorFrame: traversalErrorFrame\n  };\n};\n\nvar visit = function(init, queue, visitor, clientRefVisitor) {\n  var traversalChildren = [ init ];\n  var traversalMap = [ flushPrevContextMap() ];\n  var traversalStore = [ flushPrevContextStore() ];\n  var traversalErrorFrame = [ getCurrentErrorFrame() ];\n  var hasYielded = visitLoop(traversalChildren, traversalMap, traversalStore, traversalErrorFrame, queue, visitor, clientRefVisitor);\n  if (hasYielded) {\n    queue.unshift(makeYieldFrame(traversalChildren, traversalMap, traversalStore, traversalErrorFrame));\n  }\n};\n\nvar update = function(frame, queue, visitor, clientRefVisitor) {\n  if (frame.kind === \"frame.yield\") {\n    setCurrentIdentity(null);\n    setCurrentContextMap(frame.contextMap);\n    setCurrentContextStore(frame.contextStore);\n    setCurrentErrorFrame(frame.errorFrame);\n    var hasYielded = visitLoop(frame.traversalChildren, frame.traversalMap, frame.traversalStore, frame.traversalErrorFrame, queue, visitor, clientRefVisitor);\n    if (hasYielded) {\n      queue.unshift(makeYieldFrame(frame.traversalChildren, frame.traversalMap, frame.traversalStore, frame.traversalErrorFrame));\n    }\n  } else {\n    var prevDispatcher = getReactCurrentDispatcher();\n    var children = null;\n    injectReactCurrentDispatcher(Dispatcher);\n    try {\n      if (frame.kind === \"frame.class\") {\n        children = update$2(queue, frame);\n      } else if (frame.kind === \"frame.hooks\") {\n        children = update$3(queue, frame);\n      } else if (frame.kind === \"frame.lazy\") {\n        children = update$4(queue, frame);\n      } else if (frame.kind === \"client-ref\") {\n        children = update$1(queue, frame);\n      }\n    } catch (error) {\n      var errorFrame = getCurrentErrorFrame();\n      if (!errorFrame) {\n        throw error;\n      }\n      errorFrame.error = error;\n      queue.unshift(errorFrame);\n      children = null;\n    } finally {\n      injectReactCurrentDispatcher(prevDispatcher);\n    }\n    visit(getChildrenArray(children), queue, visitor, clientRefVisitor);\n  }\n};\n\nfunction _ref(resolve, reject) {\n  setImmediate(resolve);\n}\n\nvar flushFrames = function(queue, visitor, clientRefVisitor, state) {\n  var frame = queue.shift();\n  if (!frame) {\n    return Promise.resolve();\n  }\n  if (SHOULD_YIELD && frame.kind === \"frame.yield\") {\n    frame.thenable = new Promise(_ref);\n  }\n  return Promise.resolve(frame.thenable).then((function() {\n    setCurrentRendererState(state);\n    update(frame, queue, visitor, clientRefVisitor);\n    return flushFrames(queue, visitor, clientRefVisitor, state);\n  }), (function(error) {\n    if (!frame.errorFrame) {\n      throw error;\n    }\n    frame.errorFrame.error = error;\n    update(frame.errorFrame, queue, visitor, clientRefVisitor);\n  }));\n};\n\nvar defaultVisitor = function() {\n  return undefined;\n};\n\nvar runningPrepassCount = 0;\n\nfunction _ref2() {\n  runningPrepassCount--;\n  if (!runningPrepassCount) {\n    delete globalThis.__ssrPrepassEnv;\n  }\n}\n\nvar renderPrepass = function(element, visitor, clientRefVisitor) {\n  if (!visitor) {\n    visitor = defaultVisitor;\n  }\n  if (!clientRefVisitor) {\n    clientRefVisitor = defaultVisitor;\n  }\n  var queue = [];\n  var state = initRendererState();\n  setCurrentContextMap({});\n  setCurrentContextStore(new Map);\n  setCurrentErrorFrame(null);\n  try {\n    runningPrepassCount++;\n    globalThis.__ssrPrepassEnv = {\n      readContextValue: readContextValue,\n      setContextValue: setContextValue\n    };\n    visit(getChildrenArray(element), queue, visitor, clientRefVisitor);\n  } catch (error) {\n    runningPrepassCount--;\n    if (!runningPrepassCount) {\n      delete globalThis.__ssrPrepassEnv;\n    }\n    return Promise.reject(error);\n  }\n  return flushFrames(queue, visitor, clientRefVisitor, state).finally(_ref2);\n};\n\n\n//# sourceMappingURL=react-ssr-prepass.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBsYXNtaWNhcHAvcmVhY3Qtc3NyLXByZXBhc3MvZGlzdC9yZWFjdC1zc3ItcHJlcGFzcy5lcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBdUQ7O0FBRXZEO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsaUdBQXdEO0FBQ2xFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLDJDQUFROztBQUV0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdURBQXVEO0FBQ3ZEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esb0JBQW9CO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNENBQTRDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0RBQWE7QUFDeEI7QUFDQTtBQUNBLFdBQVcsb0RBQWE7QUFDeEIsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvREFBYSxDQUFDLHVEQUFjLElBQUk7QUFDM0MsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLGlHQUF3RCxJQUFJLDhHQUFxRSxJQUFJLDhHQUFxRTs7QUFFaE87O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvREFBYTtBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9EQUFhO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFb0M7QUFDcEMiLCJzb3VyY2VzIjpbIi9Vc2Vycy93b25kZXJsYW5kbWl0Y2gvQ2FzY2FkZVByb2plY3RzL1dvbmRlclZpdGUtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BwbGFzbWljYXBwL3JlYWN0LXNzci1wcmVwYXNzL2Rpc3QvcmVhY3Qtc3NyLXByZXBhc3MuZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IENoaWxkcmVuLCBjcmVhdGVFbGVtZW50IH0gZnJvbSBcInJlYWN0XCI7XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICByZXR1cm4gX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbihuKSB7XG4gICAgZm9yICh2YXIgZSA9IDE7IGUgPCBhcmd1bWVudHMubGVuZ3RoOyBlKyspIHtcbiAgICAgIHZhciB0ID0gYXJndW1lbnRzW2VdO1xuICAgICAgZm9yICh2YXIgciBpbiB0KSB7XG4gICAgICAgICh7fSkuaGFzT3duUHJvcGVydHkuY2FsbCh0LCByKSAmJiAobltyXSA9IHRbcl0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbjtcbiAgfSwgX2V4dGVuZHMuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn1cblxudmFyIEVsZW1lbnQgPSA2MDEwMztcblxudmFyIFRyYW5zaXRpb25hbEVsZW1lbnQgPSA2MDEwMztcblxudmFyIFBvcnRhbCA9IDYwMTA2O1xuXG52YXIgRnJhZ21lbnQgPSA2MDEwNztcblxudmFyIFN0cmljdE1vZGUgPSA2MDEwODtcblxudmFyIFByb2ZpbGVyID0gNjAxMTQ7XG5cbnZhciBDb250ZXh0UHJvdmlkZXIgPSA2MDEwOTtcblxudmFyIENvbnRleHRDb25zdW1lciA9IHVuZGVmaW5lZDtcblxudmFyIENvbnRleHQgPSA2MDExMDtcblxudmFyIENvbmN1cnJlbnRNb2RlID0gNjAxMTE7XG5cbnZhciBGb3J3YXJkUmVmID0gNjAxMTI7XG5cbnZhciBTdXNwZW5zZSA9IDYwMTEzO1xuXG52YXIgTWVtbyA9IDYwMTE1O1xuXG52YXIgTGF6eSA9IDYwMTE2O1xuXG52YXIgQ2xpZW50UmVmZXJlbmNlVGFnID0gdW5kZWZpbmVkO1xuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5mb3IpIHtcbiAgdmFyIHN5bWJvbEZvciA9IFN5bWJvbC5mb3I7XG4gIEVsZW1lbnQgPSBzeW1ib2xGb3IoXCJyZWFjdC5lbGVtZW50XCIpO1xuICBUcmFuc2l0aW9uYWxFbGVtZW50ID0gc3ltYm9sRm9yKFwicmVhY3QudHJhbnNpdGlvbmFsLmVsZW1lbnRcIik7XG4gIFBvcnRhbCA9IHN5bWJvbEZvcihcInJlYWN0LnBvcnRhbFwiKTtcbiAgRnJhZ21lbnQgPSBzeW1ib2xGb3IoXCJyZWFjdC5mcmFnbWVudFwiKTtcbiAgU3RyaWN0TW9kZSA9IHN5bWJvbEZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpO1xuICBQcm9maWxlciA9IHN5bWJvbEZvcihcInJlYWN0LnByb2ZpbGVyXCIpO1xuICBDb250ZXh0UHJvdmlkZXIgPSBzeW1ib2xGb3IoXCJyZWFjdC5wcm92aWRlclwiKTtcbiAgQ29udGV4dENvbnN1bWVyID0gc3ltYm9sRm9yKFwicmVhY3QuY29uc3VtZXJcIik7XG4gIENvbnRleHQgPSBzeW1ib2xGb3IoXCJyZWFjdC5jb250ZXh0XCIpO1xuICBDb25jdXJyZW50TW9kZSA9IHN5bWJvbEZvcihcInJlYWN0LmNvbmN1cnJlbnRfbW9kZVwiKTtcbiAgRm9yd2FyZFJlZiA9IHN5bWJvbEZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpO1xuICBTdXNwZW5zZSA9IHN5bWJvbEZvcihcInJlYWN0LnN1c3BlbnNlXCIpO1xuICBNZW1vID0gc3ltYm9sRm9yKFwicmVhY3QubWVtb1wiKTtcbiAgTGF6eSA9IHN5bWJvbEZvcihcInJlYWN0LmxhenlcIik7XG4gIENsaWVudFJlZmVyZW5jZVRhZyA9IHN5bWJvbEZvcihcInJlYWN0LmNsaWVudC5yZWZlcmVuY2VcIik7XG59XG5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBFbGVtZW50O1xuXG52YXIgUkVBQ1RfVFJBTlNJVElPTkFMX0VMRU1FTlRfVFlQRSA9IFRyYW5zaXRpb25hbEVsZW1lbnQ7XG5cbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IFBvcnRhbDtcblxudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBGcmFnbWVudDtcblxudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTdHJpY3RNb2RlO1xuXG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFByb2ZpbGVyO1xuXG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IENvbnRleHRQcm92aWRlcjtcblxudmFyIFJFQUNUX0NPTlNVTUVSX1RZUEUgPSBDb250ZXh0Q29uc3VtZXI7XG5cbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBDb250ZXh0O1xuXG52YXIgUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEUgPSBDb25jdXJyZW50TW9kZTtcblxudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBGb3J3YXJkUmVmO1xuXG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IFN1c3BlbnNlO1xuXG52YXIgUkVBQ1RfTUVNT19UWVBFID0gTWVtbztcblxudmFyIFJFQUNUX0xBWllfVFlQRSA9IExhenk7XG5cbnZhciBDTElFTlRfUkVGRVJFTkNFX1RBRyA9IENsaWVudFJlZmVyZW5jZVRhZztcblxuZnVuY3Rpb24gaXNDbGllbnRSZWZlcmVuY2UocmVmZXJlbmNlKSB7XG4gIHJldHVybiByZWZlcmVuY2UuJCR0eXBlb2YgPT09IENMSUVOVF9SRUZFUkVOQ0VfVEFHO1xufVxuXG52YXIgZ2V0Q29tcG9uZW50TmFtZSA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKGlzQ2xpZW50UmVmZXJlbmNlKHR5cGUpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBpZiAodHlwZS5kaXNwbGF5TmFtZSkge1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lO1xuICB9XG4gIGlmIChzaG91bGRDb25zdHJ1Y3QodHlwZSkpIHtcbiAgICByZXR1cm4gdHlwZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0eXBlLm5hbWU7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGlzUmVhY3QxOSgpIHtcbiAgcmV0dXJuICFSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcbn1cblxudmFyIHNob3VsZENvbnN0cnVjdCA9IGZ1bmN0aW9uKENvbXApIHtcbiAgcmV0dXJuIENvbXAucHJvdG90eXBlICYmIENvbXAucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQ7XG59O1xuXG52YXIgdHlwZU9mID0gZnVuY3Rpb24oeCkge1xuICBzd2l0Y2ggKHguJCR0eXBlb2YpIHtcbiAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgcmV0dXJuIFJFQUNUX1BPUlRBTF9UWVBFO1xuXG4gICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgIGNhc2UgUkVBQ1RfVFJBTlNJVElPTkFMX0VMRU1FTlRfVFlQRTpcbiAgICBzd2l0Y2ggKHgudHlwZSkge1xuICAgICBjYXNlIFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuIFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFO1xuXG4gICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgIHJldHVybiBSRUFDVF9GUkFHTUVOVF9UWVBFO1xuXG4gICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgIHJldHVybiBSRUFDVF9QUk9GSUxFUl9UWVBFO1xuXG4gICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgIHJldHVybiBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xuXG4gICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiBSRUFDVF9TVVNQRU5TRV9UWVBFO1xuXG4gICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHN3aXRjaCAoeC50eXBlICYmIHgudHlwZS4kJHR5cGVvZikge1xuICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFJFQUNUX0xBWllfVFlQRTtcblxuICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFJFQUNUX01FTU9fVFlQRTtcblxuICAgICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICAgIHJldHVybiBSRUFDVF9DT05TVU1FUl9UWVBFO1xuXG4gICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICByZXR1cm4gaXNSZWFjdDE5KCkgPyBSRUFDVF9QUk9WSURFUl9UWVBFIDogUkVBQ1RfQ09OU1VNRVJfVFlQRTtcblxuICAgICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICAgIHJldHVybiBSRUFDVF9QUk9WSURFUl9UWVBFO1xuXG4gICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU7XG5cbiAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgZGVmYXVsdDpcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59O1xuXG52YXIgdG9BcnJheSA9IENoaWxkcmVuLnRvQXJyYXk7XG5cbnZhciBpc0Fic3RyYWN0RWxlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgIT09IG51bGwgJiYgdHlwZW9mIG5vZGUgPT09IFwib2JqZWN0XCI7XG59O1xuXG52YXIgZ2V0Q2hpbGRyZW5BcnJheSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgcmV0dXJuIHRvQXJyYXkobm9kZSkuZmlsdGVyKGlzQWJzdHJhY3RFbGVtZW50KTtcbn07XG5cbnZhciBjb21wdXRlUHJvcHMgPSBmdW5jdGlvbihwcm9wcywgZGVmYXVsdFByb3BzKSB7XG4gIHJldHVybiB0eXBlb2YgZGVmYXVsdFByb3BzID09PSBcIm9iamVjdFwiID8gX2V4dGVuZHMoe30sIGRlZmF1bHRQcm9wcywgcHJvcHMpIDogcHJvcHM7XG59O1xuXG52YXIgY3VycmVudENvbnRleHRTdG9yZSA9IG5ldyBNYXA7XG5cbnZhciBjdXJyZW50Q29udGV4dE1hcCA9IHt9O1xuXG52YXIgcHJldkNvbnRleHRNYXAgPSB1bmRlZmluZWQ7XG5cbnZhciBwcmV2Q29udGV4dEVudHJ5ID0gdW5kZWZpbmVkO1xuXG52YXIgZ2V0Q3VycmVudENvbnRleHRNYXAgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBjdXJyZW50Q29udGV4dE1hcCk7XG59O1xuXG52YXIgZ2V0Q3VycmVudENvbnRleHRTdG9yZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IE1hcChjdXJyZW50Q29udGV4dFN0b3JlKTtcbn07XG5cbnZhciBmbHVzaFByZXZDb250ZXh0TWFwID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwcmV2ID0gcHJldkNvbnRleHRNYXA7XG4gIHByZXZDb250ZXh0TWFwID0gdW5kZWZpbmVkO1xuICByZXR1cm4gcHJldjtcbn07XG5cbnZhciBmbHVzaFByZXZDb250ZXh0U3RvcmUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHByZXYgPSBwcmV2Q29udGV4dEVudHJ5O1xuICBwcmV2Q29udGV4dEVudHJ5ID0gdW5kZWZpbmVkO1xuICByZXR1cm4gcHJldjtcbn07XG5cbnZhciByZXN0b3JlQ29udGV4dE1hcCA9IGZ1bmN0aW9uKHByZXYpIHtcbiAgaWYgKHByZXYgIT09IHVuZGVmaW5lZCkge1xuICAgIF9leHRlbmRzKGN1cnJlbnRDb250ZXh0TWFwLCBwcmV2KTtcbiAgfVxufTtcblxudmFyIHJlc3RvcmVDb250ZXh0U3RvcmUgPSBmdW5jdGlvbihwcmV2KSB7XG4gIGlmIChwcmV2ICE9PSB1bmRlZmluZWQpIHtcbiAgICBjdXJyZW50Q29udGV4dFN0b3JlLnNldChwcmV2WzBdLCBwcmV2WzFdKTtcbiAgfVxufTtcblxudmFyIHNldEN1cnJlbnRDb250ZXh0TWFwID0gZnVuY3Rpb24obWFwKSB7XG4gIHByZXZDb250ZXh0TWFwID0gdW5kZWZpbmVkO1xuICBjdXJyZW50Q29udGV4dE1hcCA9IG1hcDtcbn07XG5cbnZhciBzZXRDdXJyZW50Q29udGV4dFN0b3JlID0gZnVuY3Rpb24oc3RvcmUpIHtcbiAgcHJldkNvbnRleHRFbnRyeSA9IHVuZGVmaW5lZDtcbiAgY3VycmVudENvbnRleHRTdG9yZSA9IHN0b3JlO1xufTtcblxudmFyIGFzc2lnbkNvbnRleHRNYXAgPSBmdW5jdGlvbihtYXApIHtcbiAgcHJldkNvbnRleHRNYXAgPSB7fTtcbiAgZm9yICh2YXIgbmFtZSBpbiBtYXApIHtcbiAgICBwcmV2Q29udGV4dE1hcFtuYW1lXSA9IGN1cnJlbnRDb250ZXh0TWFwW25hbWVdO1xuICAgIGN1cnJlbnRDb250ZXh0TWFwW25hbWVdID0gbWFwW25hbWVdO1xuICB9XG59O1xuXG52YXIgc2V0Q29udGV4dFZhbHVlID0gZnVuY3Rpb24oY29udGV4dCwgdmFsdWUpIHtcbiAgcHJldkNvbnRleHRFbnRyeSA9IFsgY29udGV4dCwgY3VycmVudENvbnRleHRTdG9yZS5nZXQoY29udGV4dCkgXTtcbiAgY3VycmVudENvbnRleHRTdG9yZS5zZXQoY29udGV4dCwgdmFsdWUpO1xufTtcblxudmFyIHJlYWRDb250ZXh0VmFsdWUgPSBmdW5jdGlvbihjb250ZXh0KSB7XG4gIHZhciB2YWx1ZSA9IGN1cnJlbnRDb250ZXh0U3RvcmUuZ2V0KGNvbnRleHQpO1xuICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gY29udGV4dC5fY3VycmVudFZhbHVlO1xufTtcblxudmFyIGVtcHR5Q29udGV4dCA9IHt9O1xuXG52YXIgbWFza0NvbnRleHQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBjb250ZXh0VHlwZSA9IHR5cGUuY29udGV4dFR5cGU7XG4gIHZhciBjb250ZXh0VHlwZXMgPSB0eXBlLmNvbnRleHRUeXBlcztcbiAgaWYgKGNvbnRleHRUeXBlKSB7XG4gICAgcmV0dXJuIHJlYWRDb250ZXh0VmFsdWUoY29udGV4dFR5cGUpO1xuICB9IGVsc2UgaWYgKCFjb250ZXh0VHlwZXMpIHtcbiAgICByZXR1cm4gZW1wdHlDb250ZXh0O1xuICB9XG4gIHZhciBtYXNrZWRDb250ZXh0ID0ge307XG4gIGZvciAodmFyIG5hbWUgaW4gY29udGV4dFR5cGVzKSB7XG4gICAgbWFza2VkQ29udGV4dFtuYW1lXSA9IGN1cnJlbnRDb250ZXh0TWFwW25hbWVdO1xuICB9XG4gIHJldHVybiBtYXNrZWRDb250ZXh0O1xufTtcblxudmFyIGN1cnJlbnRFcnJvckZyYW1lID0gbnVsbDtcblxudmFyIGdldEN1cnJlbnRFcnJvckZyYW1lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBjdXJyZW50RXJyb3JGcmFtZTtcbn07XG5cbnZhciBzZXRDdXJyZW50RXJyb3JGcmFtZSA9IGZ1bmN0aW9uKGZyYW1lKSB7XG4gIGN1cnJlbnRFcnJvckZyYW1lID0gZnJhbWUgfHwgbnVsbDtcbn07XG5cbnZhciByZW5kZXJlclN0YXRlUmVmID0ge1xuICBjdXJyZW50OiB7XG4gICAgdW5pcXVlSUQ6IDBcbiAgfVxufTtcblxudmFyIGluaXRSZW5kZXJlclN0YXRlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiByZW5kZXJlclN0YXRlUmVmLmN1cnJlbnQgPSB7XG4gICAgdW5pcXVlSUQ6IDBcbiAgfTtcbn07XG5cbnZhciBzZXRDdXJyZW50UmVuZGVyZXJTdGF0ZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHJldHVybiByZW5kZXJlclN0YXRlUmVmLmN1cnJlbnQgPSBzdGF0ZTtcbn07XG5cbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgcmV0dXJuIHggPT09IHkgJiYgKHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5KSB8fCB4ICE9PSB4ICYmIHkgIT09IHk7XG59XG5cbnZhciBvYmplY3RJcyA9IHR5cGVvZiBPYmplY3QuaXMgPT09IFwiZnVuY3Rpb25cIiA/IE9iamVjdC5pcyA6IGlzO1xuXG52YXIgaXMkMSA9IG9iamVjdElzO1xuXG52YXIgY3VycmVudElkZW50aXR5ID0gbnVsbDtcblxudmFyIG1ha2VJZGVudGl0eSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge307XG59O1xuXG52YXIgc2V0Q3VycmVudElkZW50aXR5ID0gZnVuY3Rpb24oaWQpIHtcbiAgY3VycmVudElkZW50aXR5ID0gaWQ7XG59O1xuXG52YXIgZ2V0Q3VycmVudElkZW50aXR5ID0gZnVuY3Rpb24oKSB7XG4gIGlmIChjdXJyZW50SWRlbnRpdHkgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJbcmVhY3Qtc3NyLXByZXBhc3NdIEhvb2tzIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgdGhlIGJvZHkgb2YgYSBmdW5jdGlvbiBjb21wb25lbnQuIFwiICsgXCIoaHR0cHM6Ly9mYi5tZS9yZWFjdC1pbnZhbGlkLWhvb2stY2FsbClcIik7XG4gIH1cbiAgcmV0dXJuIGN1cnJlbnRJZGVudGl0eTtcbn07XG5cbnZhciBmaXJzdFdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG5cbnZhciB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xuXG52YXIgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9IGZhbHNlO1xuXG52YXIgcmVuZGVyUGhhc2VVcGRhdGVzID0gbnVsbDtcblxudmFyIG51bWJlck9mUmVSZW5kZXJzID0gMDtcblxudmFyIFJFX1JFTkRFUl9MSU1JVCQxID0gMjU7XG5cbnZhciBnZXRGaXJzdEhvb2sgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rO1xufTtcblxudmFyIHNldEZpcnN0SG9vayA9IGZ1bmN0aW9uKGhvb2spIHtcbiAgZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2sgPSBob29rO1xufTtcblxuZnVuY3Rpb24gYXJlSG9va0lucHV0c0VxdWFsKG5leHREZXBzLCBwcmV2RGVwcykge1xuICBpZiAocHJldkRlcHMgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmV2RGVwcy5sZW5ndGggJiYgaSA8IG5leHREZXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFpcyQxKG5leHREZXBzW2ldLCBwcmV2RGVwc1tpXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUhvb2soKSB7XG4gIHJldHVybiB7XG4gICAgbWVtb2l6ZWRTdGF0ZTogbnVsbCxcbiAgICBxdWV1ZTogbnVsbCxcbiAgICBuZXh0OiBudWxsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdvcmtJblByb2dyZXNzSG9vaygpIHtcbiAgaWYgKHdvcmtJblByb2dyZXNzSG9vayA9PT0gbnVsbCkge1xuICAgIGlmIChmaXJzdFdvcmtJblByb2dyZXNzSG9vayA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rID0gY3JlYXRlSG9vaygpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3NIb29rID0gZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2s7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh3b3JrSW5Qcm9ncmVzc0hvb2submV4dCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0ID0gY3JlYXRlSG9vaygpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rLm5leHQ7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlcldpdGhIb29rcyhDb21wb25lbnQsIHByb3BzLCByZWZPckNvbnRleHQpIHtcbiAgd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcbiAgdmFyIGNoaWxkcmVuID0gQ29tcG9uZW50KHByb3BzLCByZWZPckNvbnRleHQpO1xuICB3aGlsZSAobnVtYmVyT2ZSZVJlbmRlcnMgPCBSRV9SRU5ERVJfTElNSVQkMSAmJiBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlKSB7XG4gICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9IGZhbHNlO1xuICAgIG51bWJlck9mUmVSZW5kZXJzICs9IDE7XG4gICAgd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcbiAgICBjaGlsZHJlbiA9IENvbXBvbmVudChwcm9wcywgcmVmT3JDb250ZXh0KTtcbiAgfVxuICBudW1iZXJPZlJlUmVuZGVycyA9IDA7XG4gIHJlbmRlclBoYXNlVXBkYXRlcyA9IG51bGw7XG4gIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxuZnVuY3Rpb24gcmVhZENvbnRleHQoY29udGV4dCwgXykge1xuICByZXR1cm4gcmVhZENvbnRleHRWYWx1ZShjb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gdXNlQ29udGV4dChjb250ZXh0LCBfKSB7XG4gIGdldEN1cnJlbnRJZGVudGl0eSgpO1xuICByZXR1cm4gcmVhZENvbnRleHRWYWx1ZShjb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gYmFzaWNTdGF0ZVJlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuICByZXR1cm4gdHlwZW9mIGFjdGlvbiA9PT0gXCJmdW5jdGlvblwiID8gYWN0aW9uKHN0YXRlKSA6IGFjdGlvbjtcbn1cblxuZnVuY3Rpb24gdXNlU3RhdGUoaW5pdGlhbFN0YXRlKSB7XG4gIHJldHVybiB1c2VSZWR1Y2VyKGJhc2ljU3RhdGVSZWR1Y2VyLCBpbml0aWFsU3RhdGUpO1xufVxuXG5mdW5jdGlvbiB1c2VSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgdmFyIGlkID0gZ2V0Q3VycmVudElkZW50aXR5KCk7XG4gIHdvcmtJblByb2dyZXNzSG9vayA9IGNyZWF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICBpZiAod29ya0luUHJvZ3Jlc3NIb29rLnF1ZXVlID09PSBudWxsKSB7XG4gICAgdmFyIGluaXRpYWxTdGF0ZTtcbiAgICBpZiAocmVkdWNlciA9PT0gYmFzaWNTdGF0ZVJlZHVjZXIpIHtcbiAgICAgIGluaXRpYWxTdGF0ZSA9IHR5cGVvZiBpbml0aWFsQXJnID09PSBcImZ1bmN0aW9uXCIgPyBpbml0aWFsQXJnKCkgOiBpbml0aWFsQXJnO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbml0aWFsU3RhdGUgPSBpbml0ICE9PSB1bmRlZmluZWQgPyBpbml0KGluaXRpYWxBcmcpIDogaW5pdGlhbEFyZztcbiAgICB9XG4gICAgd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gIH1cbiAgdmFyIHF1ZXVlID0gd29ya0luUHJvZ3Jlc3NIb29rLnF1ZXVlIHx8ICh3b3JrSW5Qcm9ncmVzc0hvb2sucXVldWUgPSB7XG4gICAgbGFzdDogbnVsbCxcbiAgICBkaXNwYXRjaDogbnVsbFxuICB9KTtcbiAgdmFyIGRpc3BhdGNoID0gcXVldWUuZGlzcGF0Y2ggfHwgKHF1ZXVlLmRpc3BhdGNoID0gZGlzcGF0Y2hBY3Rpb24uYmluZChudWxsLCBpZCwgcXVldWUpKTtcbiAgaWYgKHJlbmRlclBoYXNlVXBkYXRlcyAhPT0gbnVsbCkge1xuICAgIHZhciBmaXJzdFJlbmRlclBoYXNlVXBkYXRlID0gcmVuZGVyUGhhc2VVcGRhdGVzLmdldChxdWV1ZSk7XG4gICAgaWYgKGZpcnN0UmVuZGVyUGhhc2VVcGRhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVuZGVyUGhhc2VVcGRhdGVzLmRlbGV0ZShxdWV1ZSk7XG4gICAgICB2YXIgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZTtcbiAgICAgIHZhciB1cGRhdGUgPSBmaXJzdFJlbmRlclBoYXNlVXBkYXRlO1xuICAgICAgZG8ge1xuICAgICAgICB2YXIgYWN0aW9uID0gdXBkYXRlLmFjdGlvbjtcbiAgICAgICAgbmV3U3RhdGUgPSByZWR1Y2VyKG5ld1N0YXRlLCBhY3Rpb24pO1xuICAgICAgICB1cGRhdGUgPSB1cGRhdGUubmV4dDtcbiAgICAgIH0gd2hpbGUgKHVwZGF0ZSAhPT0gbnVsbCk7XG4gICAgICB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gWyB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSwgZGlzcGF0Y2ggXTtcbn1cblxuZnVuY3Rpb24gdXNlTWVtbyhuZXh0Q3JlYXRlLCBkZXBzKSB7XG4gIGdldEN1cnJlbnRJZGVudGl0eSgpO1xuICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIG5leHREZXBzID0gZGVwcyA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlcHM7XG4gIHZhciBwcmV2U3RhdGUgPSB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZTtcbiAgaWYgKHByZXZTdGF0ZSAhPT0gbnVsbCAmJiBuZXh0RGVwcyAhPT0gbnVsbCkge1xuICAgIHZhciBwcmV2RGVwcyA9IHByZXZTdGF0ZVsxXTtcbiAgICBpZiAoYXJlSG9va0lucHV0c0VxdWFsKG5leHREZXBzLCBwcmV2RGVwcykpIHtcbiAgICAgIHJldHVybiBwcmV2U3RhdGVbMF07XG4gICAgfVxuICB9XG4gIHZhciBuZXh0VmFsdWUgPSBuZXh0Q3JlYXRlKCk7XG4gIHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlID0gWyBuZXh0VmFsdWUsIG5leHREZXBzIF07XG4gIHJldHVybiBuZXh0VmFsdWU7XG59XG5cbmZ1bmN0aW9uIHVzZVJlZihpbml0aWFsVmFsdWUpIHtcbiAgZ2V0Q3VycmVudElkZW50aXR5KCk7XG4gIHdvcmtJblByb2dyZXNzSG9vayA9IGNyZWF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgcHJldmlvdXNSZWYgPSB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZTtcbiAgaWYgKHByZXZpb3VzUmVmID09PSBudWxsKSB7XG4gICAgdmFyIHJlZiA9IHtcbiAgICAgIGN1cnJlbnQ6IGluaXRpYWxWYWx1ZVxuICAgIH07XG4gICAgd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUgPSByZWY7XG4gICAgcmV0dXJuIHJlZjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcHJldmlvdXNSZWY7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXNlT3BhcXVlSWRlbnRpZmllcigpIHtcbiAgZ2V0Q3VycmVudElkZW50aXR5KCk7XG4gIHdvcmtJblByb2dyZXNzSG9vayA9IGNyZWF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICBpZiAoIXdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlKSB7XG4gICAgd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUgPSBcIlI6XCIgKyAocmVuZGVyZXJTdGF0ZVJlZi5jdXJyZW50LnVuaXF1ZUlEKyspLnRvU3RyaW5nKDM2KTtcbiAgfVxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGU7XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoQWN0aW9uKGNvbXBvbmVudElkZW50aXR5LCBxdWV1ZSwgYWN0aW9uKSB7XG4gIGlmIChjb21wb25lbnRJZGVudGl0eSA9PT0gY3VycmVudElkZW50aXR5KSB7XG4gICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9IHRydWU7XG4gICAgdmFyIHVwZGF0ZSA9IHtcbiAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG4gICAgaWYgKHJlbmRlclBoYXNlVXBkYXRlcyA9PT0gbnVsbCkge1xuICAgICAgcmVuZGVyUGhhc2VVcGRhdGVzID0gbmV3IE1hcDtcbiAgICB9XG4gICAgdmFyIGZpcnN0UmVuZGVyUGhhc2VVcGRhdGUgPSByZW5kZXJQaGFzZVVwZGF0ZXMuZ2V0KHF1ZXVlKTtcbiAgICBpZiAoZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZW5kZXJQaGFzZVVwZGF0ZXMuc2V0KHF1ZXVlLCB1cGRhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbGFzdFJlbmRlclBoYXNlVXBkYXRlID0gZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZTtcbiAgICAgIHdoaWxlIChsYXN0UmVuZGVyUGhhc2VVcGRhdGUubmV4dCAhPT0gbnVsbCkge1xuICAgICAgICBsYXN0UmVuZGVyUGhhc2VVcGRhdGUgPSBsYXN0UmVuZGVyUGhhc2VVcGRhdGUubmV4dDtcbiAgICAgIH1cbiAgICAgIGxhc3RSZW5kZXJQaGFzZVVwZGF0ZS5uZXh0ID0gdXBkYXRlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VDYWxsYmFjayhjYWxsYmFjaywgZGVwcykge1xuICByZXR1cm4gdXNlTWVtbygoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrO1xuICB9KSwgZGVwcyk7XG59XG5cbmZ1bmN0aW9uIHVzZU11dGFibGVTb3VyY2Uoc291cmNlLCBnZXRTbmFwc2hvdCwgX3N1YnNjcmliZSkge1xuICBnZXRDdXJyZW50SWRlbnRpdHkoKTtcbiAgcmV0dXJuIGdldFNuYXBzaG90KHNvdXJjZS5fc291cmNlKTtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmZ1bmN0aW9uIF9yZWYkMyhjYWxsYmFjaykge1xuICBjYWxsYmFjaygpO1xufVxuXG5mdW5jdGlvbiB1c2VUcmFuc2l0aW9uKCkge1xuICB2YXIgc3RhcnRUcmFuc2l0aW9uID0gX3JlZiQzO1xuICByZXR1cm4gWyBzdGFydFRyYW5zaXRpb24sIGZhbHNlIF07XG59XG5cbmZ1bmN0aW9uIHVzZURlZmVycmVkVmFsdWUoaW5wdXQpIHtcbiAgcmV0dXJuIGlucHV0O1xufVxuXG5mdW5jdGlvbiB1c2VTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCkge1xuICByZXR1cm4gZ2V0U25hcHNob3QoKTtcbn1cblxudmFyIERpc3BhdGNoZXIgPSB7XG4gIHJlYWRDb250ZXh0OiByZWFkQ29udGV4dCxcbiAgdXNlU3luY0V4dGVybmFsU3RvcmU6IHVzZVN5bmNFeHRlcm5hbFN0b3JlLFxuICB1c2VDb250ZXh0OiB1c2VDb250ZXh0LFxuICB1c2VNZW1vOiB1c2VNZW1vLFxuICB1c2VSZWR1Y2VyOiB1c2VSZWR1Y2VyLFxuICB1c2VSZWY6IHVzZVJlZixcbiAgdXNlU3RhdGU6IHVzZVN0YXRlLFxuICB1c2VDYWxsYmFjazogdXNlQ2FsbGJhY2ssXG4gIHVzZU11dGFibGVTb3VyY2U6IHVzZU11dGFibGVTb3VyY2UsXG4gIHVzZVRyYW5zaXRpb246IHVzZVRyYW5zaXRpb24sXG4gIHVzZURlZmVycmVkVmFsdWU6IHVzZURlZmVycmVkVmFsdWUsXG4gIHVzZU9wYXF1ZUlkZW50aWZpZXI6IHVzZU9wYXF1ZUlkZW50aWZpZXIsXG4gIHVzZUlkOiB1c2VPcGFxdWVJZGVudGlmaWVyLFxuICB1bnN0YWJsZV91c2VJZDogdXNlT3BhcXVlSWRlbnRpZmllcixcbiAgdW5zdGFibGVfdXNlT3BhcXVlSWRlbnRpZmllcjogdXNlT3BhcXVlSWRlbnRpZmllcixcbiAgdXNlTGF5b3V0RWZmZWN0OiBub29wLFxuICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBub29wLFxuICB1c2VFZmZlY3Q6IG5vb3AsXG4gIHVzZURlYnVnVmFsdWU6IG5vb3AsXG4gIHVzZUluc2VydGlvbkVmZmVjdDogbm9vcCxcbiAgaXNQbGFzbWljUHJlcGFzczogdHJ1ZVxufTtcblxudmFyIHJlc29sdmUgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBwYXlsb2FkID0gdHlwZS5fcGF5bG9hZCB8fCB0eXBlO1xuICBpZiAocGF5bG9hZC5fc3RhdHVzID09PSAwKSB7XG4gICAgcmV0dXJuIHBheWxvYWQuX3Jlc3VsdDtcbiAgfSBlbHNlIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IDEpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHBheWxvYWQuX3Jlc3VsdCk7XG4gIH0gZWxzZSBpZiAocGF5bG9hZC5fc3RhdHVzID09PSAyKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHBheWxvYWQuX3Jlc3VsdCk7XG4gIH1cbiAgcGF5bG9hZC5fc3RhdHVzID0gMDtcbiAgcmV0dXJuIHBheWxvYWQuX3Jlc3VsdCA9IChwYXlsb2FkLl9jdG9yIHx8IHBheWxvYWQuX3Jlc3VsdCkoKS50aGVuKChmdW5jdGlvbihDb21wb25lbnQpIHtcbiAgICBwYXlsb2FkLl9yZXN1bHQgPSBDb21wb25lbnQ7XG4gICAgaWYgKHR5cGVvZiBDb21wb25lbnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcGF5bG9hZC5fc3RhdHVzID0gMTtcbiAgICB9IGVsc2UgaWYgKENvbXBvbmVudCAhPT0gbnVsbCAmJiB0eXBlb2YgQ29tcG9uZW50ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBDb21wb25lbnQuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBwYXlsb2FkLl9yZXN1bHQgPSBDb21wb25lbnQuZGVmYXVsdDtcbiAgICAgIHBheWxvYWQuX3N0YXR1cyA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBheWxvYWQuX3N0YXR1cyA9IDI7XG4gICAgfVxuICB9KSkuY2F0Y2goKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgcGF5bG9hZC5fc3RhdHVzID0gMjtcbiAgICBwYXlsb2FkLl9yZXN1bHQgPSBlcnJvcjtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICB9KSk7XG59O1xuXG52YXIgbWFrZUZyYW1lJDIgPSBmdW5jdGlvbih0eXBlLCBwcm9wcywgdGhlbmFibGUpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcImZyYW1lLmxhenlcIixcbiAgICBjb250ZXh0TWFwOiBnZXRDdXJyZW50Q29udGV4dE1hcCgpLFxuICAgIGNvbnRleHRTdG9yZTogZ2V0Q3VycmVudENvbnRleHRTdG9yZSgpLFxuICAgIGVycm9yRnJhbWU6IGdldEN1cnJlbnRFcnJvckZyYW1lKCksXG4gICAgdGhlbmFibGU6IHRoZW5hYmxlLFxuICAgIHByb3BzOiBwcm9wcyxcbiAgICB0eXBlOiB0eXBlXG4gIH07XG59O1xuXG52YXIgcmVuZGVyJDQgPSBmdW5jdGlvbih0eXBlLCBwcm9wcywgcXVldWUpIHtcbiAgdmFyIHBheWxvYWQgPSB0eXBlLl9wYXlsb2FkIHx8IHR5cGU7XG4gIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IDEgJiYgcGF5bG9hZC5fcmVzdWx0KSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQocGF5bG9hZC5fcmVzdWx0LCBwcm9wcyk7XG4gIH1cbiAgdHJ5IHtcbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudCh0eXBlLl9pbml0KHR5cGUuX3BheWxvYWQpLCBwcm9wcyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmICghIWVyciAmJiB0eXBlb2YgZXJyLnRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcXVldWUucHVzaChtYWtlRnJhbWUkMih0eXBlLCBwcm9wcywgZXJyKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG52YXIgbW91bnQkMyA9IGZ1bmN0aW9uKHR5cGUsIHByb3BzLCBxdWV1ZSkge1xuICB2YXIgcGF5bG9hZCA9IHR5cGUuX3BheWxvYWQgfHwgdHlwZTtcbiAgaWYgKHBheWxvYWQuX3N0YXR1cyAhPSBudWxsICYmIHBheWxvYWQuX3N0YXR1cyA8PSAwKSB7XG4gICAgcXVldWUucHVzaChtYWtlRnJhbWUkMih0eXBlLCBwcm9wcywgcmVzb2x2ZSh0eXBlKSkpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiByZW5kZXIkNCh0eXBlLCBwcm9wcywgcXVldWUpO1xufTtcblxudmFyIHVwZGF0ZSQ0ID0gZnVuY3Rpb24ocXVldWUsIGZyYW1lKSB7XG4gIHNldEN1cnJlbnRJZGVudGl0eShudWxsKTtcbiAgc2V0Q3VycmVudENvbnRleHRNYXAoZnJhbWUuY29udGV4dE1hcCk7XG4gIHNldEN1cnJlbnRDb250ZXh0U3RvcmUoZnJhbWUuY29udGV4dFN0b3JlKTtcbiAgc2V0Q3VycmVudEVycm9yRnJhbWUoZnJhbWUuZXJyb3JGcmFtZSk7XG4gIHJldHVybiByZW5kZXIkNChmcmFtZS50eXBlLCBmcmFtZS5wcm9wcywgcXVldWUpO1xufTtcblxudmFyIG1ha2VGcmFtZSQxID0gZnVuY3Rpb24odHlwZSwgcHJvcHMsIHRoZW5hYmxlKSB7XG4gIHJldHVybiB7XG4gICAgY29udGV4dE1hcDogZ2V0Q3VycmVudENvbnRleHRNYXAoKSxcbiAgICBjb250ZXh0U3RvcmU6IGdldEN1cnJlbnRDb250ZXh0U3RvcmUoKSxcbiAgICBpZDogZ2V0Q3VycmVudElkZW50aXR5KCksXG4gICAgaG9vazogZ2V0Rmlyc3RIb29rKCksXG4gICAga2luZDogXCJmcmFtZS5ob29rc1wiLFxuICAgIGVycm9yRnJhbWU6IGdldEN1cnJlbnRFcnJvckZyYW1lKCksXG4gICAgdGhlbmFibGU6IHRoZW5hYmxlLFxuICAgIHByb3BzOiBwcm9wcyxcbiAgICB0eXBlOiB0eXBlXG4gIH07XG59O1xuXG52YXIgcmVuZGVyJDMgPSBmdW5jdGlvbih0eXBlLCBwcm9wcywgcXVldWUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcmVuZGVyV2l0aEhvb2tzKHR5cGUsIGNvbXB1dGVQcm9wcyhwcm9wcywgdHlwZS5kZWZhdWx0UHJvcHMpLCBtYXNrQ29udGV4dCh0eXBlKSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKHR5cGVvZiBlcnJvci50aGVuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlBMQVNNSUM6IEVuY291bnRlcmVkIGVycm9yIHdoZW4gcHJlLXJlbmRlcmluZyBcIiArIGdldENvbXBvbmVudE5hbWUodHlwZSkgKyBcIjogXCIgKyBlcnJvcik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcXVldWUucHVzaChtYWtlRnJhbWUkMSh0eXBlLCBwcm9wcywgZXJyb3IpKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxudmFyIG1vdW50JDIgPSBmdW5jdGlvbih0eXBlLCBwcm9wcywgcXVldWUsIHZpc2l0b3IsIGVsZW1lbnQpIHtcbiAgc2V0Rmlyc3RIb29rKG51bGwpO1xuICBzZXRDdXJyZW50SWRlbnRpdHkobWFrZUlkZW50aXR5KCkpO1xuICB2YXIgcHJvbWlzZSA9IHZpc2l0b3IoZWxlbWVudCk7XG4gIGlmIChwcm9taXNlKSB7XG4gICAgcXVldWUucHVzaChtYWtlRnJhbWUkMSh0eXBlLCBwcm9wcywgcHJvbWlzZSkpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiByZW5kZXIkMyh0eXBlLCBwcm9wcywgcXVldWUpO1xufTtcblxudmFyIHVwZGF0ZSQzID0gZnVuY3Rpb24ocXVldWUsIGZyYW1lKSB7XG4gIHNldEZpcnN0SG9vayhmcmFtZS5ob29rKTtcbiAgc2V0Q3VycmVudElkZW50aXR5KGZyYW1lLmlkKTtcbiAgc2V0Q3VycmVudENvbnRleHRNYXAoZnJhbWUuY29udGV4dE1hcCk7XG4gIHNldEN1cnJlbnRDb250ZXh0U3RvcmUoZnJhbWUuY29udGV4dFN0b3JlKTtcbiAgc2V0Q3VycmVudEVycm9yRnJhbWUoZnJhbWUuZXJyb3JGcmFtZSk7XG4gIHJldHVybiByZW5kZXIkMyhmcmFtZS50eXBlLCBmcmFtZS5wcm9wcywgcXVldWUpO1xufTtcblxudmFyIFJFX1JFTkRFUl9MSU1JVCA9IDI1O1xuXG5mdW5jdGlvbiBfcmVmJDIoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gX3JlZjIkMSgpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBjcmVhdGVVcGRhdGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBxdWV1ZSA9IFtdO1xuICByZXR1cm4ge1xuICAgIF90aHJvd246IDAsXG4gICAgcXVldWU6IHF1ZXVlLFxuICAgIGlzTW91bnRlZDogX3JlZiQyLFxuICAgIGVucXVldWVGb3JjZVVwZGF0ZTogX3JlZjIkMSxcbiAgICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbihpbnN0YW5jZSwgY29tcGxldGVTdGF0ZSkge1xuICAgICAgaWYgKGluc3RhbmNlLl9pc01vdW50ZWQpIHtcbiAgICAgICAgcXVldWUubGVuZ3RoID0gMDtcbiAgICAgICAgcXVldWUucHVzaChjb21wbGV0ZVN0YXRlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24oaW5zdGFuY2UsIGN1cnJlbnRQYXJ0aWFsU3RhdGUpIHtcbiAgICAgIGlmIChpbnN0YW5jZS5faXNNb3VudGVkKSB7XG4gICAgICAgIHF1ZXVlLnB1c2goY3VycmVudFBhcnRpYWxTdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufTtcblxudmFyIGZsdXNoRW5xdWV1ZWRTdGF0ZSA9IGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gIHZhciBxdWV1ZSA9IGluc3RhbmNlLnVwZGF0ZXIucXVldWU7XG4gIGlmIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgdmFyIG5leHRTdGF0ZSA9IF9leHRlbmRzKHt9LCBpbnN0YW5jZS5zdGF0ZSk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBxdWV1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBwYXJ0aWFsID0gcXVldWVbaV07XG4gICAgICB2YXIgcGFydGlhbFN0YXRlID0gdHlwZW9mIHBhcnRpYWwgPT09IFwiZnVuY3Rpb25cIiA/IHBhcnRpYWwuY2FsbChpbnN0YW5jZSwgbmV4dFN0YXRlLCBpbnN0YW5jZS5wcm9wcywgaW5zdGFuY2UuY29udGV4dCkgOiBwYXJ0aWFsO1xuICAgICAgaWYgKHBhcnRpYWxTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICBfZXh0ZW5kcyhuZXh0U3RhdGUsIHBhcnRpYWxTdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGluc3RhbmNlLnN0YXRlID0gbmV4dFN0YXRlO1xuICAgIHF1ZXVlLmxlbmd0aCA9IDA7XG4gIH1cbn07XG5cbnZhciBjcmVhdGVJbnN0YW5jZSA9IGZ1bmN0aW9uKHR5cGUsIHByb3BzKSB7XG4gIHZhciB1cGRhdGVyID0gY3JlYXRlVXBkYXRlcigpO1xuICB2YXIgY29tcHV0ZWRQcm9wcyA9IGNvbXB1dGVQcm9wcyhwcm9wcywgdHlwZS5kZWZhdWx0UHJvcHMpO1xuICB2YXIgY29udGV4dCA9IG1hc2tDb250ZXh0KHR5cGUpO1xuICB2YXIgaW5zdGFuY2UgPSBuZXcgdHlwZShjb21wdXRlZFByb3BzLCBjb250ZXh0LCB1cGRhdGVyKTtcbiAgaW5zdGFuY2UucHJvcHMgPSBjb21wdXRlZFByb3BzO1xuICBpbnN0YW5jZS5jb250ZXh0ID0gY29udGV4dDtcbiAgaW5zdGFuY2UudXBkYXRlciA9IHVwZGF0ZXI7XG4gIGluc3RhbmNlLl9pc01vdW50ZWQgPSB0cnVlO1xuICBpZiAoaW5zdGFuY2Uuc3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgIGluc3RhbmNlLnN0YXRlID0gbnVsbDtcbiAgfVxuICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZENhdGNoID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIHR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB2YXIgZnJhbWUgPSBtYWtlRnJhbWUodHlwZSwgaW5zdGFuY2UsIG51bGwpO1xuICAgIGZyYW1lLmVycm9yRnJhbWUgPSBmcmFtZTtcbiAgICBzZXRDdXJyZW50RXJyb3JGcmFtZShmcmFtZSk7XG4gIH1cbiAgaWYgKHR5cGVvZiB0eXBlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdmFyIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IHR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzO1xuICAgIHZhciBzdGF0ZSA9IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhpbnN0YW5jZS5wcm9wcywgaW5zdGFuY2Uuc3RhdGUpO1xuICAgIGlmIChzdGF0ZSAhPT0gbnVsbCAmJiBzdGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpbnN0YW5jZS5zdGF0ZSA9IF9leHRlbmRzKHt9LCBpbnN0YW5jZS5zdGF0ZSwgc3RhdGUpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpO1xuICB9XG4gIHJldHVybiBpbnN0YW5jZTtcbn07XG5cbnZhciBtYWtlRnJhbWUgPSBmdW5jdGlvbih0eXBlLCBpbnN0YW5jZSwgdGhlbmFibGUpIHtcbiAgcmV0dXJuIHtcbiAgICBjb250ZXh0TWFwOiBnZXRDdXJyZW50Q29udGV4dE1hcCgpLFxuICAgIGNvbnRleHRTdG9yZTogZ2V0Q3VycmVudENvbnRleHRTdG9yZSgpLFxuICAgIGVycm9yRnJhbWU6IGdldEN1cnJlbnRFcnJvckZyYW1lKCksXG4gICAgdGhlbmFibGU6IHRoZW5hYmxlLFxuICAgIGtpbmQ6IFwiZnJhbWUuY2xhc3NcIixcbiAgICBlcnJvcjogbnVsbCxcbiAgICBpbnN0YW5jZTogaW5zdGFuY2UsXG4gICAgdHlwZTogdHlwZVxuICB9O1xufTtcblxudmFyIHJlbmRlciQyID0gZnVuY3Rpb24odHlwZSwgaW5zdGFuY2UsIHF1ZXVlKSB7XG4gIGZsdXNoRW5xdWV1ZWRTdGF0ZShpbnN0YW5jZSk7XG4gIHZhciBjaGlsZCA9IG51bGw7XG4gIHRyeSB7XG4gICAgY2hpbGQgPSBpbnN0YW5jZS5yZW5kZXIoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAodHlwZW9mIGVycm9yLnRoZW4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY29uc29sZS53YXJuKFwiUExBU01JQzogRW5jb3VudGVyZWQgZXJyb3Igd2hlbiBwcmUtcmVuZGVyaW5nIGNvbXBvbmVudCBcIiArIGdldENvbXBvbmVudE5hbWUodHlwZSkgKyBcIi4gVGhpcyBpcyBmaW5lIGFzIGxvbmcgYXMgeW91IGFyZSBub3QgZmV0Y2hpbmcgZGF0YSB3aXRoIEBwbGFzbWljYXBwL3F1ZXJ5IGluc2lkZSB0aGlzIGNvbXBvbmVudC4gIEVycm9yOiBcIiArIGVycm9yKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG1ha2VGcmFtZSh0eXBlLCBpbnN0YW5jZSwgZXJyb3IpKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAodHlwZS5jaGlsZENvbnRleHRUeXBlcyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHZhciBjaGlsZENvbnRleHQgPSBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQoKTtcbiAgICBpZiAoY2hpbGRDb250ZXh0ICE9PSBudWxsICYmIHR5cGVvZiBjaGlsZENvbnRleHQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGFzc2lnbkNvbnRleHRNYXAoY2hpbGRDb250ZXh0KTtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgIT09IFwiZnVuY3Rpb25cIiAmJiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSBcImZ1bmN0aW9uXCIpICYmIHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdHJ5IHtcbiAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XG4gICAgfSBjYXRjaCAoX2Vycikge31cbiAgfVxuICBpbnN0YW5jZS5faXNNb3VudGVkID0gZmFsc2U7XG4gIHJldHVybiBjaGlsZDtcbn07XG5cbnZhciBtb3VudCQxID0gZnVuY3Rpb24odHlwZSwgcHJvcHMsIHF1ZXVlLCB2aXNpdG9yLCBlbGVtZW50KSB7XG4gIHNldEN1cnJlbnRJZGVudGl0eShudWxsKTtcbiAgdmFyIGluc3RhbmNlID0gY3JlYXRlSW5zdGFuY2UodHlwZSwgcHJvcHMpO1xuICB2YXIgcHJvbWlzZSA9IHZpc2l0b3IoZWxlbWVudCwgaW5zdGFuY2UpO1xuICBpZiAocHJvbWlzZSkge1xuICAgIHF1ZXVlLnB1c2gobWFrZUZyYW1lKHR5cGUsIGluc3RhbmNlLCBwcm9taXNlKSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHJlbmRlciQyKHR5cGUsIGluc3RhbmNlLCBxdWV1ZSk7XG59O1xuXG52YXIgdXBkYXRlJDIgPSBmdW5jdGlvbihxdWV1ZSwgZnJhbWUpIHtcbiAgc2V0Q3VycmVudElkZW50aXR5KG51bGwpO1xuICBzZXRDdXJyZW50Q29udGV4dE1hcChmcmFtZS5jb250ZXh0TWFwKTtcbiAgc2V0Q3VycmVudENvbnRleHRTdG9yZShmcmFtZS5jb250ZXh0U3RvcmUpO1xuICBzZXRDdXJyZW50RXJyb3JGcmFtZShmcmFtZS5lcnJvckZyYW1lKTtcbiAgaWYgKGZyYW1lLmVycm9yKSB7XG4gICAgaWYgKCsrZnJhbWUuaW5zdGFuY2UudXBkYXRlci5fdGhyb3duID49IFJFX1JFTkRFUl9MSU1JVCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZyYW1lLmluc3RhbmNlLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgIGlmICh0eXBlb2YgZnJhbWUuaW5zdGFuY2UuY29tcG9uZW50RGlkQ2F0Y2ggPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgZnJhbWUuaW5zdGFuY2UuY29tcG9uZW50RGlkQ2F0Y2goZnJhbWUuZXJyb3IpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGZyYW1lLnR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGZyYW1lLmluc3RhbmNlLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKGZyYW1lLmluc3RhbmNlLCBmcmFtZS50eXBlLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihmcmFtZS5lcnJvcikpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVuZGVyJDIoZnJhbWUudHlwZSwgZnJhbWUuaW5zdGFuY2UsIHF1ZXVlKTtcbn07XG5cbmZ1bmN0aW9uIF9yZWYkMShlbHQpIHtcbiAgcmV0dXJuIGVsdCAmJiB0eXBlb2YgZWx0ID09PSBcIm9iamVjdFwiICYmIHR5cGVPZihlbHQpO1xufVxuXG52YXIgcmVuZGVyJDEgPSBmdW5jdGlvbih0eXBlLCBwcm9wcywgcXVldWUsIGNsaWVudFJlZlZpc2l0b3IsIGVsZW1lbnQpIHtcbiAgdHJ5IHtcbiAgICB2YXIgbm9kZSA9IGNsaWVudFJlZlZpc2l0b3IoZWxlbWVudCk7XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIHt9LCBbXS5jb25jYXQobm9kZSA/IGdldENoaWxkcmVuQXJyYXkobm9kZSkgOiBPYmplY3QudmFsdWVzKHByb3BzKS5mbGF0KEluZmluaXR5KS5maWx0ZXIoX3JlZiQxKSkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmICh0eXBlb2YgZXJyb3IudGhlbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJQTEFTTUlDOiBFbmNvdW50ZXJlZCBlcnJvciB3aGVuIHByZS1yZW5kZXJpbmcgY2xpZW50IHJlZmVyZW5jZTogXCIgKyBlcnJvcik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcXVldWUucHVzaCh7XG4gICAgICBjb250ZXh0TWFwOiBnZXRDdXJyZW50Q29udGV4dE1hcCgpLFxuICAgICAgY29udGV4dFN0b3JlOiBnZXRDdXJyZW50Q29udGV4dFN0b3JlKCksXG4gICAgICBlcnJvckZyYW1lOiBnZXRDdXJyZW50RXJyb3JGcmFtZSgpLFxuICAgICAgaWQ6IGdldEN1cnJlbnRJZGVudGl0eSgpLFxuICAgICAgaG9vazogZ2V0Rmlyc3RIb29rKCksXG4gICAgICB0aGVuYWJsZTogZXJyb3IsXG4gICAgICBraW5kOiBcImNsaWVudC1yZWZcIixcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBwcm9wczogcHJvcHMsXG4gICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgY2xpZW50UmVmVmlzaXRvcjogY2xpZW50UmVmVmlzaXRvclxuICAgIH0pO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG52YXIgbW91bnQgPSBmdW5jdGlvbih0eXBlLCBwcm9wcywgcXVldWUsIGNsaWVudFJlZlZpc2l0b3IsIGVsZW1lbnQpIHtcbiAgc2V0Rmlyc3RIb29rKG51bGwpO1xuICBzZXRDdXJyZW50SWRlbnRpdHkobWFrZUlkZW50aXR5KCkpO1xuICByZXR1cm4gcmVuZGVyJDEodHlwZSwgcHJvcHMsIHF1ZXVlLCBjbGllbnRSZWZWaXNpdG9yLCBlbGVtZW50KTtcbn07XG5cbnZhciB1cGRhdGUkMSA9IGZ1bmN0aW9uKHF1ZXVlLCBmcmFtZSkge1xuICBzZXRGaXJzdEhvb2soZnJhbWUuaG9vayk7XG4gIHNldEN1cnJlbnRJZGVudGl0eShmcmFtZS5pZCk7XG4gIHNldEN1cnJlbnRDb250ZXh0TWFwKGZyYW1lLmNvbnRleHRNYXApO1xuICBzZXRDdXJyZW50Q29udGV4dFN0b3JlKGZyYW1lLmNvbnRleHRTdG9yZSk7XG4gIHNldEN1cnJlbnRFcnJvckZyYW1lKGZyYW1lLmVycm9yRnJhbWUpO1xuICByZXR1cm4gcmVuZGVyJDEoZnJhbWUudHlwZSwgZnJhbWUucHJvcHMsIHF1ZXVlLCBmcmFtZS5jbGllbnRSZWZWaXNpdG9yLCBmcmFtZS5lbGVtZW50KTtcbn07XG5cbnZhciBSRUFDVF9JTlRFUk5BTFMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCB8fCBSZWFjdC5fX0NMSUVOVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUgfHwgUmVhY3QuX19TRVJWRVJfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFO1xuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJFQUNUX0lOVEVSTkFMUy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyIHx8IFJFQUNUX0lOVEVSTkFMUztcblxudmFyIGdldFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCB8fCBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLkg7XG59O1xuXG52YXIgaW5qZWN0UmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IGZ1bmN0aW9uKG5ld0Rpc3BhdGNoZXIpIHtcbiAgaWYgKCFpc1JlYWN0MTkoKSkge1xuICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IG5ld0Rpc3BhdGNoZXI7XG4gIH0gZWxzZSB7XG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5IID0gbmV3RGlzcGF0Y2hlcjtcbiAgfVxufTtcblxudmFyIFNIT1VMRF9ZSUVMRCA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIjtcblxudmFyIFlJRUxEX0FGVEVSX01TID0gNTtcblxudmFyIHJlbmRlciA9IGZ1bmN0aW9uKHR5cGUsIHByb3BzLCBxdWV1ZSwgdmlzaXRvciwgY2xpZW50UmVmVmlzaXRvciwgZWxlbWVudCkge1xuICBpZiAoaXNDbGllbnRSZWZlcmVuY2UodHlwZSkpIHtcbiAgICByZXR1cm4gbW91bnQodHlwZSwgcHJvcHMsIHF1ZXVlLCBjbGllbnRSZWZWaXNpdG9yLCBlbGVtZW50KTtcbiAgfVxuICByZXR1cm4gc2hvdWxkQ29uc3RydWN0KHR5cGUpID8gbW91bnQkMSh0eXBlLCBwcm9wcywgcXVldWUsIHZpc2l0b3IsIGVsZW1lbnQpIDogbW91bnQkMih0eXBlLCBwcm9wcywgcXVldWUsIHZpc2l0b3IsIGVsZW1lbnQpO1xufTtcblxudmFyIHZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uKGVsZW1lbnQsIHF1ZXVlLCB2aXNpdG9yLCBjbGllbnRSZWZWaXNpdG9yKSB7XG4gIHN3aXRjaCAodHlwZU9mKGVsZW1lbnQpKSB7XG4gICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICBjYXNlIFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFOlxuICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgIHtcbiAgICAgIHZhciBmcmFnbWVudEVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgcmV0dXJuIGdldENoaWxkcmVuQXJyYXkoZnJhZ21lbnRFbGVtZW50LnByb3BzLmNoaWxkcmVuKTtcbiAgICB9XG5cbiAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICB7XG4gICAgICB2YXIgcHJvdmlkZXJFbGVtZW50ID0gZWxlbWVudDtcbiAgICAgIHZhciByZWYgPSBwcm92aWRlckVsZW1lbnQucHJvcHM7XG4gICAgICB2YXIgdmFsdWUgPSByZWYudmFsdWU7XG4gICAgICB2YXIgY2hpbGRyZW4gPSByZWYuY2hpbGRyZW47XG4gICAgICB2YXIgdHlwZSA9IHByb3ZpZGVyRWxlbWVudC50eXBlO1xuICAgICAgdmFyIGNvbnRleHQgPSB0eXBlb2YgdHlwZS5fY29udGV4dCA9PT0gXCJvYmplY3RcIiA/IHR5cGUuX2NvbnRleHQgOiB0eXBlO1xuICAgICAgc2V0Q29udGV4dFZhbHVlKGNvbnRleHQsIHZhbHVlKTtcbiAgICAgIHJldHVybiBnZXRDaGlsZHJlbkFycmF5KGNoaWxkcmVuKTtcbiAgICB9XG5cbiAgIGNhc2UgUkVBQ1RfQ09OU1VNRVJfVFlQRTpcbiAgICB7XG4gICAgICB2YXIgY29uc3VtZXJFbGVtZW50ID0gZWxlbWVudDtcbiAgICAgIHZhciByZWYkMSA9IGNvbnN1bWVyRWxlbWVudC5wcm9wcztcbiAgICAgIHZhciBjaGlsZHJlbiQxID0gcmVmJDEuY2hpbGRyZW47XG4gICAgICBpZiAodHlwZW9mIGNoaWxkcmVuJDEgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB2YXIgdHlwZSQxID0gY29uc3VtZXJFbGVtZW50LnR5cGU7XG4gICAgICAgIHZhciBjb250ZXh0JDEgPSB0eXBlb2YgdHlwZSQxLl9jb250ZXh0ID09PSBcIm9iamVjdFwiID8gdHlwZSQxLl9jb250ZXh0IDogdHlwZSQxO1xuICAgICAgICB2YXIgdmFsdWUkMSA9IHJlYWRDb250ZXh0VmFsdWUoY29udGV4dCQxKTtcbiAgICAgICAgcmV0dXJuIGdldENoaWxkcmVuQXJyYXkoY2hpbGRyZW4kMSh2YWx1ZSQxKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgfVxuXG4gICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICB7XG4gICAgICB2YXIgbGF6eUVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgdmFyIHR5cGUkMiA9IGxhenlFbGVtZW50LnR5cGU7XG4gICAgICB2YXIgY2hpbGQgPSBtb3VudCQzKHR5cGUkMiwgbGF6eUVsZW1lbnQucHJvcHMsIHF1ZXVlKTtcbiAgICAgIHJldHVybiBnZXRDaGlsZHJlbkFycmF5KGNoaWxkKTtcbiAgICB9XG5cbiAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgIHtcbiAgICAgIHZhciBtZW1vRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB2YXIgcmVmJDIgPSBtZW1vRWxlbWVudC50eXBlO1xuICAgICAgdmFyIHR5cGUkMyA9IHJlZiQyLnR5cGU7XG4gICAgICB2YXIgY2hpbGQkMSA9IGNyZWF0ZUVsZW1lbnQodHlwZSQzLCBtZW1vRWxlbWVudC5wcm9wcyk7XG4gICAgICByZXR1cm4gZ2V0Q2hpbGRyZW5BcnJheShjaGlsZCQxKTtcbiAgICB9XG5cbiAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICB7XG4gICAgICB2YXIgcmVmRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB2YXIgcmVmJDMgPSByZWZFbGVtZW50LnR5cGU7XG4gICAgICB2YXIgdHlwZSQ0ID0gcmVmJDMucmVuZGVyO1xuICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHJlZiQzLmRlZmF1bHRQcm9wcztcbiAgICAgIHZhciBwcm9wcyA9IGNvbXB1dGVQcm9wcyhyZWZFbGVtZW50LnByb3BzLCBkZWZhdWx0UHJvcHMpO1xuICAgICAgdmFyIGNoaWxkJDIgPSBjcmVhdGVFbGVtZW50KHR5cGUkNCwgcHJvcHMpO1xuICAgICAgcmV0dXJuIGdldENoaWxkcmVuQXJyYXkoY2hpbGQkMik7XG4gICAgfVxuXG4gICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICB7XG4gICAgICB2YXIgZWwgPSBlbGVtZW50O1xuICAgICAgaWYgKHR5cGVvZiBlbC50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBnZXRDaGlsZHJlbkFycmF5KGVsLnByb3BzLmNoaWxkcmVuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB1c2VyRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHZhciB0eXBlJDUgPSB1c2VyRWxlbWVudC50eXBlO1xuICAgICAgICB2YXIgcHJvcHMkMSA9IHVzZXJFbGVtZW50LnByb3BzO1xuICAgICAgICB2YXIgY2hpbGQkMyA9IHJlbmRlcih0eXBlJDUsIHByb3BzJDEsIHF1ZXVlLCB2aXNpdG9yLCBjbGllbnRSZWZWaXNpdG9yLCB1c2VyRWxlbWVudCk7XG4gICAgICAgIHJldHVybiBnZXRDaGlsZHJlbkFycmF5KGNoaWxkJDMpO1xuICAgICAgfVxuICAgIH1cblxuICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgIGRlZmF1bHQ6XG4gICAgcmV0dXJuIFtdO1xuICB9XG59O1xuXG52YXIgdmlzaXRMb29wID0gZnVuY3Rpb24odHJhdmVyc2FsQ2hpbGRyZW4sIHRyYXZlcnNhbE1hcCwgdHJhdmVyc2FsU3RvcmUsIHRyYXZlcnNhbEVycm9yRnJhbWUsIHF1ZXVlLCB2aXNpdG9yLCBjbGllbnRSZWZWaXNpdG9yKSB7XG4gIHZhciBwcmV2RGlzcGF0Y2hlciA9IGdldFJlYWN0Q3VycmVudERpc3BhdGNoZXIoKTtcbiAgdmFyIHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgdHJ5IHtcbiAgICBpbmplY3RSZWFjdEN1cnJlbnREaXNwYXRjaGVyKERpc3BhdGNoZXIpO1xuICAgIHdoaWxlICh0cmF2ZXJzYWxDaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHRyYXZlcnNhbENoaWxkcmVuW3RyYXZlcnNhbENoaWxkcmVuLmxlbmd0aCAtIDFdLnNoaWZ0KCk7XG4gICAgICBpZiAoZWxlbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHZpc2l0RWxlbWVudChlbGVtZW50LCBxdWV1ZSwgdmlzaXRvciwgY2xpZW50UmVmVmlzaXRvcik7XG4gICAgICAgIHRyYXZlcnNhbENoaWxkcmVuLnB1c2goY2hpbGRyZW4pO1xuICAgICAgICB0cmF2ZXJzYWxNYXAucHVzaChmbHVzaFByZXZDb250ZXh0TWFwKCkpO1xuICAgICAgICB0cmF2ZXJzYWxTdG9yZS5wdXNoKGZsdXNoUHJldkNvbnRleHRTdG9yZSgpKTtcbiAgICAgICAgdHJhdmVyc2FsRXJyb3JGcmFtZS5wdXNoKGdldEN1cnJlbnRFcnJvckZyYW1lKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJhdmVyc2FsQ2hpbGRyZW4ucG9wKCk7XG4gICAgICAgIHJlc3RvcmVDb250ZXh0TWFwKHRyYXZlcnNhbE1hcC5wb3AoKSk7XG4gICAgICAgIHJlc3RvcmVDb250ZXh0U3RvcmUodHJhdmVyc2FsU3RvcmUucG9wKCkpO1xuICAgICAgICBzZXRDdXJyZW50RXJyb3JGcmFtZSh0cmF2ZXJzYWxFcnJvckZyYW1lLnBvcCgpKTtcbiAgICAgIH1cbiAgICAgIGlmIChTSE9VTERfWUlFTEQgJiYgRGF0ZS5ub3coKSAtIHN0YXJ0ID4gWUlFTERfQUZURVJfTVMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB2YXIgZXJyb3JGcmFtZSA9IGdldEN1cnJlbnRFcnJvckZyYW1lKCk7XG4gICAgaWYgKCFlcnJvckZyYW1lKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgZXJyb3JGcmFtZS5lcnJvciA9IGVycm9yO1xuICAgIHF1ZXVlLnVuc2hpZnQoZXJyb3JGcmFtZSk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGZpbmFsbHkge1xuICAgIGluamVjdFJlYWN0Q3VycmVudERpc3BhdGNoZXIocHJldkRpc3BhdGNoZXIpO1xuICB9XG59O1xuXG52YXIgbWFrZVlpZWxkRnJhbWUgPSBmdW5jdGlvbih0cmF2ZXJzYWxDaGlsZHJlbiwgdHJhdmVyc2FsTWFwLCB0cmF2ZXJzYWxTdG9yZSwgdHJhdmVyc2FsRXJyb3JGcmFtZSkge1xuICByZXR1cm4ge1xuICAgIGNvbnRleHRNYXA6IGdldEN1cnJlbnRDb250ZXh0TWFwKCksXG4gICAgY29udGV4dFN0b3JlOiBnZXRDdXJyZW50Q29udGV4dFN0b3JlKCksXG4gICAgZXJyb3JGcmFtZTogZ2V0Q3VycmVudEVycm9yRnJhbWUoKSxcbiAgICB0aGVuYWJsZTogbnVsbCxcbiAgICBraW5kOiBcImZyYW1lLnlpZWxkXCIsXG4gICAgdHJhdmVyc2FsQ2hpbGRyZW46IHRyYXZlcnNhbENoaWxkcmVuLFxuICAgIHRyYXZlcnNhbE1hcDogdHJhdmVyc2FsTWFwLFxuICAgIHRyYXZlcnNhbFN0b3JlOiB0cmF2ZXJzYWxTdG9yZSxcbiAgICB0cmF2ZXJzYWxFcnJvckZyYW1lOiB0cmF2ZXJzYWxFcnJvckZyYW1lXG4gIH07XG59O1xuXG52YXIgdmlzaXQgPSBmdW5jdGlvbihpbml0LCBxdWV1ZSwgdmlzaXRvciwgY2xpZW50UmVmVmlzaXRvcikge1xuICB2YXIgdHJhdmVyc2FsQ2hpbGRyZW4gPSBbIGluaXQgXTtcbiAgdmFyIHRyYXZlcnNhbE1hcCA9IFsgZmx1c2hQcmV2Q29udGV4dE1hcCgpIF07XG4gIHZhciB0cmF2ZXJzYWxTdG9yZSA9IFsgZmx1c2hQcmV2Q29udGV4dFN0b3JlKCkgXTtcbiAgdmFyIHRyYXZlcnNhbEVycm9yRnJhbWUgPSBbIGdldEN1cnJlbnRFcnJvckZyYW1lKCkgXTtcbiAgdmFyIGhhc1lpZWxkZWQgPSB2aXNpdExvb3AodHJhdmVyc2FsQ2hpbGRyZW4sIHRyYXZlcnNhbE1hcCwgdHJhdmVyc2FsU3RvcmUsIHRyYXZlcnNhbEVycm9yRnJhbWUsIHF1ZXVlLCB2aXNpdG9yLCBjbGllbnRSZWZWaXNpdG9yKTtcbiAgaWYgKGhhc1lpZWxkZWQpIHtcbiAgICBxdWV1ZS51bnNoaWZ0KG1ha2VZaWVsZEZyYW1lKHRyYXZlcnNhbENoaWxkcmVuLCB0cmF2ZXJzYWxNYXAsIHRyYXZlcnNhbFN0b3JlLCB0cmF2ZXJzYWxFcnJvckZyYW1lKSk7XG4gIH1cbn07XG5cbnZhciB1cGRhdGUgPSBmdW5jdGlvbihmcmFtZSwgcXVldWUsIHZpc2l0b3IsIGNsaWVudFJlZlZpc2l0b3IpIHtcbiAgaWYgKGZyYW1lLmtpbmQgPT09IFwiZnJhbWUueWllbGRcIikge1xuICAgIHNldEN1cnJlbnRJZGVudGl0eShudWxsKTtcbiAgICBzZXRDdXJyZW50Q29udGV4dE1hcChmcmFtZS5jb250ZXh0TWFwKTtcbiAgICBzZXRDdXJyZW50Q29udGV4dFN0b3JlKGZyYW1lLmNvbnRleHRTdG9yZSk7XG4gICAgc2V0Q3VycmVudEVycm9yRnJhbWUoZnJhbWUuZXJyb3JGcmFtZSk7XG4gICAgdmFyIGhhc1lpZWxkZWQgPSB2aXNpdExvb3AoZnJhbWUudHJhdmVyc2FsQ2hpbGRyZW4sIGZyYW1lLnRyYXZlcnNhbE1hcCwgZnJhbWUudHJhdmVyc2FsU3RvcmUsIGZyYW1lLnRyYXZlcnNhbEVycm9yRnJhbWUsIHF1ZXVlLCB2aXNpdG9yLCBjbGllbnRSZWZWaXNpdG9yKTtcbiAgICBpZiAoaGFzWWllbGRlZCkge1xuICAgICAgcXVldWUudW5zaGlmdChtYWtlWWllbGRGcmFtZShmcmFtZS50cmF2ZXJzYWxDaGlsZHJlbiwgZnJhbWUudHJhdmVyc2FsTWFwLCBmcmFtZS50cmF2ZXJzYWxTdG9yZSwgZnJhbWUudHJhdmVyc2FsRXJyb3JGcmFtZSkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBnZXRSZWFjdEN1cnJlbnREaXNwYXRjaGVyKCk7XG4gICAgdmFyIGNoaWxkcmVuID0gbnVsbDtcbiAgICBpbmplY3RSZWFjdEN1cnJlbnREaXNwYXRjaGVyKERpc3BhdGNoZXIpO1xuICAgIHRyeSB7XG4gICAgICBpZiAoZnJhbWUua2luZCA9PT0gXCJmcmFtZS5jbGFzc1wiKSB7XG4gICAgICAgIGNoaWxkcmVuID0gdXBkYXRlJDIocXVldWUsIGZyYW1lKTtcbiAgICAgIH0gZWxzZSBpZiAoZnJhbWUua2luZCA9PT0gXCJmcmFtZS5ob29rc1wiKSB7XG4gICAgICAgIGNoaWxkcmVuID0gdXBkYXRlJDMocXVldWUsIGZyYW1lKTtcbiAgICAgIH0gZWxzZSBpZiAoZnJhbWUua2luZCA9PT0gXCJmcmFtZS5sYXp5XCIpIHtcbiAgICAgICAgY2hpbGRyZW4gPSB1cGRhdGUkNChxdWV1ZSwgZnJhbWUpO1xuICAgICAgfSBlbHNlIGlmIChmcmFtZS5raW5kID09PSBcImNsaWVudC1yZWZcIikge1xuICAgICAgICBjaGlsZHJlbiA9IHVwZGF0ZSQxKHF1ZXVlLCBmcmFtZSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHZhciBlcnJvckZyYW1lID0gZ2V0Q3VycmVudEVycm9yRnJhbWUoKTtcbiAgICAgIGlmICghZXJyb3JGcmFtZSkge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIGVycm9yRnJhbWUuZXJyb3IgPSBlcnJvcjtcbiAgICAgIHF1ZXVlLnVuc2hpZnQoZXJyb3JGcmFtZSk7XG4gICAgICBjaGlsZHJlbiA9IG51bGw7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGluamVjdFJlYWN0Q3VycmVudERpc3BhdGNoZXIocHJldkRpc3BhdGNoZXIpO1xuICAgIH1cbiAgICB2aXNpdChnZXRDaGlsZHJlbkFycmF5KGNoaWxkcmVuKSwgcXVldWUsIHZpc2l0b3IsIGNsaWVudFJlZlZpc2l0b3IpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfcmVmKHJlc29sdmUsIHJlamVjdCkge1xuICBzZXRJbW1lZGlhdGUocmVzb2x2ZSk7XG59XG5cbnZhciBmbHVzaEZyYW1lcyA9IGZ1bmN0aW9uKHF1ZXVlLCB2aXNpdG9yLCBjbGllbnRSZWZWaXNpdG9yLCBzdGF0ZSkge1xuICB2YXIgZnJhbWUgPSBxdWV1ZS5zaGlmdCgpO1xuICBpZiAoIWZyYW1lKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG4gIGlmIChTSE9VTERfWUlFTEQgJiYgZnJhbWUua2luZCA9PT0gXCJmcmFtZS55aWVsZFwiKSB7XG4gICAgZnJhbWUudGhlbmFibGUgPSBuZXcgUHJvbWlzZShfcmVmKTtcbiAgfVxuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZyYW1lLnRoZW5hYmxlKS50aGVuKChmdW5jdGlvbigpIHtcbiAgICBzZXRDdXJyZW50UmVuZGVyZXJTdGF0ZShzdGF0ZSk7XG4gICAgdXBkYXRlKGZyYW1lLCBxdWV1ZSwgdmlzaXRvciwgY2xpZW50UmVmVmlzaXRvcik7XG4gICAgcmV0dXJuIGZsdXNoRnJhbWVzKHF1ZXVlLCB2aXNpdG9yLCBjbGllbnRSZWZWaXNpdG9yLCBzdGF0ZSk7XG4gIH0pLCAoZnVuY3Rpb24oZXJyb3IpIHtcbiAgICBpZiAoIWZyYW1lLmVycm9yRnJhbWUpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBmcmFtZS5lcnJvckZyYW1lLmVycm9yID0gZXJyb3I7XG4gICAgdXBkYXRlKGZyYW1lLmVycm9yRnJhbWUsIHF1ZXVlLCB2aXNpdG9yLCBjbGllbnRSZWZWaXNpdG9yKTtcbiAgfSkpO1xufTtcblxudmFyIGRlZmF1bHRWaXNpdG9yID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG52YXIgcnVubmluZ1ByZXBhc3NDb3VudCA9IDA7XG5cbmZ1bmN0aW9uIF9yZWYyKCkge1xuICBydW5uaW5nUHJlcGFzc0NvdW50LS07XG4gIGlmICghcnVubmluZ1ByZXBhc3NDb3VudCkge1xuICAgIGRlbGV0ZSBnbG9iYWxUaGlzLl9fc3NyUHJlcGFzc0VudjtcbiAgfVxufVxuXG52YXIgcmVuZGVyUHJlcGFzcyA9IGZ1bmN0aW9uKGVsZW1lbnQsIHZpc2l0b3IsIGNsaWVudFJlZlZpc2l0b3IpIHtcbiAgaWYgKCF2aXNpdG9yKSB7XG4gICAgdmlzaXRvciA9IGRlZmF1bHRWaXNpdG9yO1xuICB9XG4gIGlmICghY2xpZW50UmVmVmlzaXRvcikge1xuICAgIGNsaWVudFJlZlZpc2l0b3IgPSBkZWZhdWx0VmlzaXRvcjtcbiAgfVxuICB2YXIgcXVldWUgPSBbXTtcbiAgdmFyIHN0YXRlID0gaW5pdFJlbmRlcmVyU3RhdGUoKTtcbiAgc2V0Q3VycmVudENvbnRleHRNYXAoe30pO1xuICBzZXRDdXJyZW50Q29udGV4dFN0b3JlKG5ldyBNYXApO1xuICBzZXRDdXJyZW50RXJyb3JGcmFtZShudWxsKTtcbiAgdHJ5IHtcbiAgICBydW5uaW5nUHJlcGFzc0NvdW50Kys7XG4gICAgZ2xvYmFsVGhpcy5fX3NzclByZXBhc3NFbnYgPSB7XG4gICAgICByZWFkQ29udGV4dFZhbHVlOiByZWFkQ29udGV4dFZhbHVlLFxuICAgICAgc2V0Q29udGV4dFZhbHVlOiBzZXRDb250ZXh0VmFsdWVcbiAgICB9O1xuICAgIHZpc2l0KGdldENoaWxkcmVuQXJyYXkoZWxlbWVudCksIHF1ZXVlLCB2aXNpdG9yLCBjbGllbnRSZWZWaXNpdG9yKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBydW5uaW5nUHJlcGFzc0NvdW50LS07XG4gICAgaWYgKCFydW5uaW5nUHJlcGFzc0NvdW50KSB7XG4gICAgICBkZWxldGUgZ2xvYmFsVGhpcy5fX3NzclByZXBhc3NFbnY7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gIH1cbiAgcmV0dXJuIGZsdXNoRnJhbWVzKHF1ZXVlLCB2aXNpdG9yLCBjbGllbnRSZWZWaXNpdG9yLCBzdGF0ZSkuZmluYWxseShfcmVmMik7XG59O1xuXG5leHBvcnQgeyByZW5kZXJQcmVwYXNzIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlYWN0LXNzci1wcmVwYXNzLmVzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@plasmicapp/react-ssr-prepass/dist/react-ssr-prepass.es.js\n");

/***/ })

};
;